(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

/*! modernizr 3.4.0 (Custom Build) | MIT *
 * https://modernizr.com/download/?-classlist-cssanimations-csspointerevents-cssremunit-csstransforms-documentfragment-eventlistener-history-matchmedia-opacity-queryselector-requestanimationframe-touchevents !*/
!function (e, t, n) {
  function r(e, t) {
    return typeof e === t;
  }function o() {
    var e, t, n, o, i, s, a;for (var u in g) if (g.hasOwnProperty(u)) {
      if (e = [], t = g[u], t.name && (e.push(t.name.toLowerCase()), t.options && t.options.aliases && t.options.aliases.length)) for (n = 0; n < t.options.aliases.length; n++) e.push(t.options.aliases[n].toLowerCase());for (o = r(t.fn, "function") ? t.fn() : t.fn, i = 0; i < e.length; i++) s = e[i], a = s.split("."), 1 === a.length ? Modernizr[a[0]] = o : (!Modernizr[a[0]] || Modernizr[a[0]] instanceof Boolean || (Modernizr[a[0]] = new Boolean(Modernizr[a[0]])), Modernizr[a[0]][a[1]] = o), S.push((o ? "" : "no-") + a.join("-"));
    }
  }function i(e) {
    return e.replace(/([a-z])-([a-z])/g, function (e, t, n) {
      return t + n.toUpperCase();
    }).replace(/^-/, "");
  }function s() {
    return "function" != typeof t.createElement ? t.createElement(arguments[0]) : w ? t.createElementNS.call(t, "http://www.w3.org/2000/svg", arguments[0]) : t.createElement.apply(t, arguments);
  }function a() {
    var e = t.body;return e || (e = s(w ? "svg" : "body"), e.fake = !0), e;
  }function u(e, n, r, o) {
    var i,
        u,
        l,
        f,
        d = "modernizr",
        c = s("div"),
        p = a();if (parseInt(r, 10)) for (; r--;) l = s("div"), l.id = o ? o[r] : d + (r + 1), c.appendChild(l);return i = s("style"), i.type = "text/css", i.id = "s" + d, (p.fake ? p : c).appendChild(i), p.appendChild(c), i.styleSheet ? i.styleSheet.cssText = e : i.appendChild(t.createTextNode(e)), c.id = d, p.fake && (p.style.background = "", p.style.overflow = "hidden", f = T.style.overflow, T.style.overflow = "hidden", T.appendChild(p)), u = n(c, e), p.fake ? (p.parentNode.removeChild(p), T.style.overflow = f, T.offsetHeight) : c.parentNode.removeChild(c), !!u;
  }function l(e, t) {
    return !!~("" + e).indexOf(t);
  }function f(e, t) {
    return function () {
      return e.apply(t, arguments);
    };
  }function d(e, t, n) {
    var o;for (var i in e) if (e[i] in t) return n === !1 ? e[i] : (o = t[e[i]], r(o, "function") ? f(o, n || t) : o);return !1;
  }function c(e) {
    return e.replace(/([A-Z])/g, function (e, t) {
      return "-" + t.toLowerCase();
    }).replace(/^ms-/, "-ms-");
  }function p(t, n, r) {
    var o;if ("getComputedStyle" in e) {
      o = getComputedStyle.call(e, t, n);var i = e.console;if (null !== o) r && (o = o.getPropertyValue(r));else if (i) {
        var s = i.error ? "error" : "log";i[s].call(i, "getComputedStyle returning null, its possible modernizr test results are inaccurate");
      }
    } else o = !n && t.currentStyle && t.currentStyle[r];return o;
  }function m(t, r) {
    var o = t.length;if ("CSS" in e && "supports" in e.CSS) {
      for (; o--;) if (e.CSS.supports(c(t[o]), r)) return !0;return !1;
    }if ("CSSSupportsRule" in e) {
      for (var i = []; o--;) i.push("(" + c(t[o]) + ":" + r + ")");return i = i.join(" or "), u("@supports (" + i + ") { #modernizr { position: absolute; } }", function (e) {
        return "absolute" == p(e, null, "position");
      });
    }return n;
  }function v(e, t, o, a) {
    function u() {
      d && (delete P.style, delete P.modElem);
    }if (a = r(a, "undefined") ? !1 : a, !r(o, "undefined")) {
      var f = m(e, o);if (!r(f, "undefined")) return f;
    }for (var d, c, p, v, y, h = ["modernizr", "tspan", "samp"]; !P.style && h.length;) d = !0, P.modElem = s(h.shift()), P.style = P.modElem.style;for (p = e.length, c = 0; p > c; c++) if (v = e[c], y = P.style[v], l(v, "-") && (v = i(v)), P.style[v] !== n) {
      if (a || r(o, "undefined")) return u(), "pfx" == t ? v : !0;try {
        P.style[v] = o;
      } catch (g) {}if (P.style[v] != y) return u(), "pfx" == t ? v : !0;
    }return u(), !1;
  }function y(e, t, n, o, i) {
    var s = e.charAt(0).toUpperCase() + e.slice(1),
        a = (e + " " + b.join(s + " ") + s).split(" ");return r(t, "string") || r(t, "undefined") ? v(a, t, o, i) : (a = (e + " " + E.join(s + " ") + s).split(" "), d(a, t, n));
  }function h(e, t, r) {
    return y(e, n, n, t, r);
  }var g = [],
      C = { _version: "3.4.0", _config: { classPrefix: "", enableClasses: !0, enableJSClass: !0, usePrefixes: !0 }, _q: [], on: function (e, t) {
      var n = this;setTimeout(function () {
        t(n[e]);
      }, 0);
    }, addTest: function (e, t, n) {
      g.push({ name: e, fn: t, options: n });
    }, addAsyncTest: function (e) {
      g.push({ name: null, fn: e });
    } },
      Modernizr = function () {};Modernizr.prototype = C, Modernizr = new Modernizr(), Modernizr.addTest("eventlistener", "addEventListener" in e), Modernizr.addTest("history", function () {
    var t = navigator.userAgent;return -1 === t.indexOf("Android 2.") && -1 === t.indexOf("Android 4.0") || -1 === t.indexOf("Mobile Safari") || -1 !== t.indexOf("Chrome") || -1 !== t.indexOf("Windows Phone") || "file:" === location.protocol ? e.history && "pushState" in e.history : !1;
  }), Modernizr.addTest("queryselector", "querySelector" in t && "querySelectorAll" in t);var S = [],
      x = C._config.usePrefixes ? " -webkit- -moz- -o- -ms- ".split(" ") : ["", ""];C._prefixes = x;var T = t.documentElement;Modernizr.addTest("classlist", "classList" in T), Modernizr.addTest("documentfragment", function () {
    return "createDocumentFragment" in t && "appendChild" in T;
  });var w = "svg" === T.nodeName.toLowerCase();Modernizr.addTest("opacity", function () {
    var e = s("a").style;return e.cssText = x.join("opacity:.55;"), /^0.55$/.test(e.opacity);
  }), Modernizr.addTest("csspointerevents", function () {
    var e = s("a").style;return e.cssText = "pointer-events:auto", "auto" === e.pointerEvents;
  }), Modernizr.addTest("cssremunit", function () {
    var e = s("a").style;try {
      e.fontSize = "3rem";
    } catch (t) {}return (/rem/.test(e.fontSize)
    );
  });var _ = C.testStyles = u;Modernizr.addTest("touchevents", function () {
    var n;if ("ontouchstart" in e || e.DocumentTouch && t instanceof DocumentTouch) n = !0;else {
      var r = ["@media (", x.join("touch-enabled),("), "heartz", ")", "{#modernizr{top:9px;position:absolute}}"].join("");_(r, function (e) {
        n = 9 === e.offsetTop;
      });
    }return n;
  });var z = "Moz O ms Webkit",
      b = C._config.usePrefixes ? z.split(" ") : [];C._cssomPrefixes = b;var A = function (t) {
    var r,
        o = x.length,
        i = e.CSSRule;if ("undefined" == typeof i) return n;if (!t) return !1;if (t = t.replace(/^@/, ""), r = t.replace(/-/g, "_").toUpperCase() + "_RULE", r in i) return "@" + t;for (var s = 0; o > s; s++) {
      var a = x[s],
          u = a.toUpperCase() + "_" + r;if (u in i) return "@-" + a.toLowerCase() + "-" + t;
    }return !1;
  };C.atRule = A;var E = C._config.usePrefixes ? z.toLowerCase().split(" ") : [];C._domPrefixes = E;var O = { elem: s("modernizr") };Modernizr._q.push(function () {
    delete O.elem;
  });var P = { style: O.elem.style };Modernizr._q.unshift(function () {
    delete P.style;
  }), C.testAllProps = y;var q = C.prefixed = function (e, t, n) {
    return 0 === e.indexOf("@") ? A(e) : (-1 != e.indexOf("-") && (e = i(e)), t ? y(e, t, n) : y(e, "pfx"));
  };Modernizr.addTest("requestanimationframe", !!q("requestAnimationFrame", e), { aliases: ["raf"] }), Modernizr.addTest("matchmedia", !!q("matchMedia", e)), C.testAllProps = h, Modernizr.addTest("cssanimations", h("animationName", "a", !0)), Modernizr.addTest("csstransforms", function () {
    return -1 === navigator.userAgent.indexOf("Android 2.") && h("transform", "scale(1)", !0);
  }), o(), delete C.addTest, delete C.addAsyncTest;for (var L = 0; L < Modernizr._q.length; L++) Modernizr._q[L]();e.Modernizr = Modernizr;
}(window, document);

},{}],2:[function(require,module,exports){
'use strict';

console.log(' __  __                __                                     __         \r\n\/\\ \\\/\\ \\              \/\\ \\             __                    \/\\ \\        \r\n\\ \\ \\_\\ \\   __  __    \\_\\ \\      __   \/\\_\\      __       ___ \\ \\ \\\/\'\\    \r\n \\ \\  _  \\ \/\\ \\\/\\ \\   \/\'_` \\   \/\'__`\\ \\\/\\ \\   \/\'__`\\    \/\'___\\\\ \\ , <    \r\n  \\ \\ \\ \\ \\\\ \\ \\_\\ \\ \/\\ \\L\\ \\ \/\\  __\/  \\ \\ \\ \/\\ \\L\\.\\_ \/\\ \\__\/ \\ \\ \\\\`\\  \r\n   \\ \\_\\ \\_\\\\\/`____ \\\\ \\___,_\\\\ \\____\\ _\\ \\ \\\\ \\__\/.\\_\\\\ \\____\\ \\ \\_\\ \\_\\\r\n    \\\/_\/\\\/_\/ `\/___\/> \\\\\/__,_ \/ \\\/____\/\/\\ \\_\\ \\\\\/__\/\\\/_\/ \\\/____\/  \\\/_\/\\\/_\/\r\n                \/\\___\/                \\ \\____\/                           \r\n                \\\/__\/                  \\\/___\/                            ');
console.log('Copyright (c) 2017 Florian Klampfer.');
console.log('Licensed under MIT.');
console.log('Design: Hydejack by @qwtel. Get it at: https://qwtel.com/hydejack');
console.log(`Version: ${window._version}`);

},{}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unhide = undefined;
exports.hasFeatures = hasFeatures;
exports.show = show;
exports.hide = hide;
exports.unshow = unshow;
exports.matches = matches;
exports.animate = animate;

var _Observable = require('rxjs/Observable');

function hasFeatures(features) {
  let acc = true;
  for (let i = 0; i < features.length; i += 1) {
    const feature = features[i];
    const hasFeature = window.Modernizr[feature];
    // if (!hasFeature) console.warn('Feature "' + feature + '" missing!');
    acc = acc && hasFeature;
  }
  return acc;
} // Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/* eslint-disable no-param-reassign */

function show(el) {
  el.style.display = 'block';
  el.style.visibility = 'visible';
}

function hide(el) {
  el.style.display = 'none';
  el.style.visibility = 'hidden';
}

function unshow(el) {
  el.style.display = '';
  el.style.visibility = '';
}

const unhide = exports.unhide = unshow;

function matches(el, selector) {
  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
}

function animate(el, keyframes, options) {
  return _Observable.Observable.create(observer => {
    const anim = el.animate(keyframes, options);

    anim.addEventListener('finish', e => {
      observer.next(e);
      observer.complete();
    });

    return () => {
      // if (anim.playState !== 'finished') anim.cancel();
    };
  });
}

},{"rxjs/Observable":117}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Observable = require('rxjs/Observable');

var _empty = require('rxjs/observable/empty');

var _fromEvent = require('rxjs/observable/fromEvent');

var _timer = require('rxjs/observable/timer');

var _color = require('color');

var _color2 = _interopRequireDefault(_color);

var _do = require('rxjs/operator/do');

var _finally = require('rxjs/operator/finally');

var _map = require('rxjs/operator/map');

var _zip = require('rxjs/operator/zip');

var _common = require('./common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/*
eslint-disable
no-param-reassign,
import/no-extraneous-dependencies,
import/no-unresolved,
import/extensions,
class-methods-use-this,
*/

const { find } = Array.prototype;

const BORDER_COLOR_FADE = 0.8;

function updateStyle({ color = '#00f' } = {}) {
  this.rules[0].style.color = color; // .content a
  this.rules[0].style.borderColor = (0, _color2.default)(color).fade(BORDER_COLOR_FADE).string();
  this.rules[1].style.borderColor = color;
  this.rules[2].style.outlineColor = color; // :focus
  this.rules[3].style.backgroundColor = color; // ::selection
}

class CrossFader {
  constructor({ duration }) {
    var _context;

    this.sidebar = document.getElementById('_sidebar');
    this.duration = duration;

    const pageStyle = document.getElementById('_pageStyle');
    const styleSheet = (_context = document.styleSheets, find).call(_context, ss => ss.ownerNode === pageStyle);
    this.rules = styleSheet.cssRules || styleSheet.rules;
    this.lastImage = document.getElementById('_main').getAttribute('data-image');
  }

  fetchImage(dataset) {
    var _context3;

    const { color, image } = dataset;

    if (image === this.lastImage) {
      return _empty.empty.call(_Observable.Observable);
    }

    let res$;
    if (image === '') {
      res$ = _timer.timer.call(_Observable.Observable, this.duration);
    } else {
      var _context2;

      const imgObj = new Image();

      res$ = (_context2 = (_context2 = _fromEvent.fromEvent.call(_Observable.Observable, imgObj, 'load'), _zip.zipProto).call(_context2, _timer.timer.call(_Observable.Observable, this.duration), x => x), _finally._finally).call(_context2, () => {
        imgObj.src = '';
      });

      imgObj.src = image;
    }

    return (_context3 = (_context3 = res$, _do._do).call(_context3, () => {
      updateStyle.call(this, dataset);
      this.lastImage = image;
    }), _map.map).call(_context3, () => {
      const div = document.createElement('div');
      div.classList.add('sidebar-bg');
      div.style.backgroundColor = color;
      if (image !== '') div.style.backgroundImage = `url(${image})`;
      return div;
    });
  }

  crossFade([prevDiv, div]) {
    var _context4;

    prevDiv.parentNode.insertBefore(div, prevDiv.nextElementSibling);

    return (_context4 = (0, _common.animate)(div, [{ opacity: 0 }, { opacity: 1 }], {
      duration: this.duration
    }), _finally._finally).call(_context4, () => prevDiv.parentNode.removeChild(prevDiv));
  }
}
exports.default = CrossFader;

},{"./common":3,"color":17,"rxjs/Observable":117,"rxjs/observable/empty":131,"rxjs/observable/fromEvent":132,"rxjs/observable/timer":134,"rxjs/operator/do":138,"rxjs/operator/finally":141,"rxjs/operator/map":142,"rxjs/operator/zip":151}],5:[function(require,module,exports){
'use strict';

var _vanilla = require('y-drawer/src/vanilla');

var _vanilla2 = _interopRequireDefault(_vanilla);

var _common = require('./common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

const REQUIREMENTS = ['eventlistener', 'queryselector', 'matchmedia', 'requestanimationframe', 'classlist', 'opacity', 'csstransforms', 'csspointerevents', 'cssremunit'];

const MEDIA_QUERY = '(min-width: 801px)';

function resizeCallback() {
  const hasChanged = window.isDesktop !== window.matchMedia(MEDIA_QUERY).matches;
  if (hasChanged) {
    window.isDesktop = !window.isDesktop;
    window.drawer.persistent = window.isDesktop;
    window.drawer.jumpTo(window.isDesktop);
  }
}

function menuClickClallback(e) {
  if (!window.isDesktop) {
    e.preventDefault();
    window.drawer.toggle();
  }
}

function addEventListeners(drawer) {
  window.drawer = drawer;
  window.addEventListener('resize', resizeCallback);
  document.getElementById('_menu').addEventListener('click', menuClickClallback);
}

if ((0, _common.hasFeatures)(REQUIREMENTS)) {
  window.isDesktop = window.matchMedia(MEDIA_QUERY).matches;
  const drawer = document.getElementById('_yDrawer');

  addEventListeners(new _vanilla2.default(drawer, {
    opened: window.isDesktop,
    persistent: window.isDesktop,
    transitionDuration: 150
  }));

  drawer.classList.add('loaded');
}

},{"./common":3,"y-drawer/src/vanilla":179}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Observable = require('rxjs/Observable');

var _empty = require('rxjs/observable/empty');

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/*
eslint-disable
class-methods-use-this
*/

class Flip {
  static create(type, ...args) {
    return Flip.types[type] != null ? new Flip.types[type](...args) : new Flip(...args);
  }

  constructor({ shadowMain, duration }) {
    this.shadowMain = shadowMain;
    this.duration = duration;
  }

  start() {
    // HACK: use proper cleanup instead
    this.shadowMain.style.opacity = 0;
    this.shadowMain.style.willChange = '';

    return _empty.empty.call(_Observable.Observable);
  }

  ready() {
    return _empty.empty.call(_Observable.Observable);
  }
}

exports.default = Flip;
Flip.types = {};

},{"rxjs/Observable":117,"rxjs/observable/empty":131}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Observable = require('rxjs/Observable');

var _of = require('rxjs/observable/of');

var _fromEvent = require('rxjs/observable/fromEvent');

var _timer = require('rxjs/observable/timer');

var _do = require('rxjs/operator/do');

var _finally = require('rxjs/operator/finally');

var _zip = require('rxjs/operator/zip');

var _common = require('../common');

var _flip = require('./flip');

var _flip2 = _interopRequireDefault(_flip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ProjectFlip extends _flip2.default {
  start(currentTarget) {
    var _context;

    const img = currentTarget.querySelector('.img');

    this.shadowMain.querySelector('.page').innerHTML = `
      <h1 class="page-title" style="opacity:0">|</h1>
      <div class="post-date heading" style="opacity:0">|</div>
    `;

    const placeholder = document.createElement('div');
    placeholder.classList.add('sixteen-nine');

    img.parentNode.insertBefore(placeholder, img);
    img.classList.add('lead');
    img.style.transformOrigin = 'left top';

    this.shadowMain.querySelector('.page').appendChild(img);
    this.shadowMain.style.position = 'fixed';
    this.shadowMain.style.opacity = 1;

    const first = placeholder.getBoundingClientRect();
    const last = img.getBoundingClientRect();

    const invertX = first.left - last.left;
    const invertY = first.top - last.top;
    const invertScale = first.width / last.width;

    return (_context = (0, _common.animate)(img, [{ transform: `translate3d(${invertX}px, ${invertY}px, 0) scale(${invertScale})` }, { transform: 'translate3d(0, 0, 0) scale(1)' }], {
      duration: this.duration,
      // easing: 'ease',
      easing: 'cubic-bezier(0,0,0.32,1)'
    }), _do._do).call(_context, () => {
      this.shadowMain.style.position = 'absolute';
    });
  }

  ready(main) {
    var _context2;

    this.shadowMain.style.willChange = 'opacity';

    const img = main.querySelector('.img');

    if (img != null) {
      img.style.opacity = 0;
      img.style.willChange = 'opacity';
    }

    const realImg = img.querySelector('img');
    return (_context2 = (_context2 = (_context2 = realImg == null ? _of.of.call(_Observable.Observable, true) : _fromEvent.fromEvent.call(_Observable.Observable, realImg, 'load'),
    // HACK: add some extra time to prevent hiccups
    _zip.zipProto).call(_context2, _timer.timer.call(_Observable.Observable, this.duration + 100)), _do._do).call(_context2, () => {
      if (img != null) {
        img.style.opacity = 1;
        img.style.willChange = '';
      }
    }), _finally._finally).call(_context2, () => {
      this.shadowMain.style.opacity = 0;
      this.shadowMain.style.willChange = '';
    });
  }
}

exports.default = ProjectFlip; // Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/*
eslint-disable
no-param-reassign,
import/no-extraneous-dependencies,
import/no-unresolved,
import/extensions,
class-methods-use-this,
*/

_flip2.default.types.project = ProjectFlip;

},{"../common":3,"./flip":6,"rxjs/Observable":117,"rxjs/observable/fromEvent":132,"rxjs/observable/of":133,"rxjs/observable/timer":134,"rxjs/operator/do":138,"rxjs/operator/finally":141,"rxjs/operator/zip":151}],8:[function(require,module,exports){
'use strict';

var _Observable = require('rxjs/Observable');

var _timer = require('rxjs/observable/timer');

var _do = require('rxjs/operator/do');

var _finally = require('rxjs/operator/finally');

var _common = require('../common');

var _flip = require('./flip');

var _flip2 = _interopRequireDefault(_flip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/*
eslint-disable
no-param-reassign,
import/no-extraneous-dependencies,
import/no-unresolved,
import/extensions,
class-methods-use-this,
*/

const TITLE_SELECTOR = '.page-title, .post-title';

class TitleFlip extends _flip2.default {
  start(currentTarget) {
    var _context;

    const title = document.createElement('h1');

    title.classList.add('page-title');
    title.textContent = currentTarget.textContent;
    title.style.transformOrigin = 'left top';

    this.shadowMain.querySelector('.page').innerHTML = '';
    this.shadowMain.querySelector('.page').appendChild(title);
    this.shadowMain.style.position = 'fixed';
    this.shadowMain.style.opacity = 1;

    const first = currentTarget.getBoundingClientRect();
    const firstFontSize = parseInt(getComputedStyle(currentTarget).fontSize, 10);
    const last = title.getBoundingClientRect();
    const lastFontSize = parseInt(getComputedStyle(title).fontSize, 10);

    const invertX = first.left - last.left;
    const invertY = first.top - last.top;
    const invertScale = firstFontSize / lastFontSize;

    currentTarget.style.opacity = 0;

    return (_context = (0, _common.animate)(title, [{ transform: `translate3d(${invertX}px, ${invertY}px, 0) scale(${invertScale})` }, { transform: 'translate3d(0, 0, 0) scale(1)' }], {
      duration: this.duration,
      // easing: 'ease',
      easing: 'cubic-bezier(0,0,0.32,1)'
    }), _do._do).call(_context, () => {
      this.shadowMain.style.position = 'absolute';
    });
  }

  ready(main) {
    var _context2;

    this.shadowMain.style.willChange = 'opacity';

    const title = main.querySelector(TITLE_SELECTOR);

    if (title != null) {
      title.style.opacity = 0;
      title.style.willChange = 'opacity';
    }

    // HACK: add some extra time to prevent hiccups
    return (_context2 = (_context2 = _timer.timer.call(_Observable.Observable, this.duration + 100), _do._do).call(_context2, () => {
      if (title != null) {
        title.style.opacity = 1;
        title.style.willChange = '';
      }
    }), _finally._finally).call(_context2, () => {
      this.shadowMain.style.opacity = 0;
      this.shadowMain.style.willChange = '';
    });
  }
}

_flip2.default.types.title = TitleFlip;

},{"../common":3,"./flip":6,"rxjs/Observable":117,"rxjs/observable/timer":134,"rxjs/operator/do":138,"rxjs/operator/finally":141}],9:[function(require,module,exports){
'use strict';

require('core-js/fn/array/for-each');

require('core-js/fn/array/find');

require('core-js/fn/function/bind');

require('core-js/fn/number/constructor');

require('core-js/fn/object/assign');

require('core-js/fn/object/define-property');

require('core-js/fn/object/keys');

require('core-js/fn/array/reduce');

require('web-animations-js');

require('../lib/modernizr');

require('../lib/version');

require('./katex');

require('./drawer');

require('./push-state');

},{"../lib/modernizr":1,"../lib/version":2,"./drawer":5,"./katex":10,"./push-state":11,"core-js/fn/array/find":18,"core-js/fn/array/for-each":19,"core-js/fn/array/reduce":20,"core-js/fn/function/bind":21,"core-js/fn/number/constructor":22,"core-js/fn/object/assign":23,"core-js/fn/object/define-property":24,"core-js/fn/object/keys":25,"web-animations-js":175}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = upgradeMathBlocks;

var _katex = require('katex');

var _katex2 = _interopRequireDefault(_katex);

var _common = require('./common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/* eslint-disable no-param-reassign */

const REQUIREMENTS = ['eventlistener', 'queryselector'];

function willChangeContent(mathBlocks) {
  Array.prototype.forEach.call(mathBlocks, el => {
    el.style.willChange = 'content'; // eslint-disable-line no-param-reassign
  });
}

function replaceMathBlock(el, tex) {
  el.outerHTML = _katex2.default.renderToString(tex, {
    displayMode: el.type === 'math/tex; mode=display'
  });
}

function renderKatex(el, tex) {
  try {
    const prev = el.previousElementSibling;
    replaceMathBlock(el, tex);
    if (prev && (0, _common.matches)(prev, '.MathJax_Preview')) (0, _common.hide)(prev);
  } catch (e) {
    // TODO: remove in production builds?
    console.error(e); // eslint-disable-line no-console
  } finally {
    el.style.willChange = '';
  }
}

function readTexSource(el) {
  return el.textContent.replace('% <![CDATA[', '').replace('%]]>', '');
}

function changeContent(mathBlocks) {
  // kramdown generates script tags with type "math/tex"
  Array.prototype.forEach.call(mathBlocks, script => {
    const tex = readTexSource(script);
    renderKatex(script, tex);
  });
}

function upgradeMathBlocks() {
  if ((0, _common.hasFeatures)(REQUIREMENTS)) {
    const mathBlocks = document.querySelectorAll('script[type^="math/tex"]');
    if (mathBlocks.length) {
      willChangeContent(mathBlocks);
      changeContent(mathBlocks);
    }
  }
}

if ((0, _common.hasFeatures)(REQUIREMENTS)) {
  const ref = document.getElementsByTagName('style')[0];
  const style = loadCSS('https://unpkg.com/katex@0.6.0/dist/katex.min.css', ref);
  style.addEventListener('load', upgradeMathBlocks);
}

},{"./common":3,"katex":91}],11:[function(require,module,exports){
'use strict';

var _Observable = require('rxjs/Observable');

var _fromEvent = require('rxjs/observable/fromEvent');

var _catch = require('rxjs/operator/catch');

var _do = require('rxjs/operator/do');

var _debounceTime = require('rxjs/operator/debounceTime');

var _exhaustMap = require('rxjs/operator/exhaustMap');

var _filter = require('rxjs/operator/filter');

var _map = require('rxjs/operator/map');

var _mergeMap = require('rxjs/operator/mergeMap');

var _pairwise = require('rxjs/operator/pairwise');

var _share = require('rxjs/operator/share');

var _startWith = require('rxjs/operator/startWith');

var _switchMap = require('rxjs/operator/switchMap');

var _takeUntil = require('rxjs/operator/takeUntil');

var _zip = require('rxjs/operator/zip');

var _vanilla = require('y-push-state/src/vanilla');

var _vanilla2 = _interopRequireDefault(_vanilla);

var _elemDataset = require('elem-dataset');

var _elemDataset2 = _interopRequireDefault(_elemDataset);

var _common = require('./common');

var _crossFader = require('./cross-fader');

var _crossFader2 = _interopRequireDefault(_crossFader);

var _katex = require('./katex');

var _katex2 = _interopRequireDefault(_katex);

var _flip = require('./flip/flip');

var _flip2 = _interopRequireDefault(_flip);

require('./flip/title');

require('./flip/project');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const REQUIREMENTS = ['eventlistener', 'queryselector', 'requestanimationframe', 'classlist', 'documentfragment', 'history', 'opacity', 'cssanimations']; // Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/*
eslint-disable
no-param-reassign,
import/no-extraneous-dependencies,
import/no-unresolved,
import/extensions
*/

const DURATION = 250;
const FADE_DURATION = 500;

// whenever the source observable encounters an error,
// we log it to the console, but continue as if it never happend
function makeUnstoppable() {
  return _catch._catch.call(this, (error, caught) => {
    console.error(error); // eslint-disable-line
    return caught;
  });
}

if ((0, _common.hasFeatures)(REQUIREMENTS)) {
  var _context;

  const ua = navigator.userAgent.toLowerCase();
  const isSafari = ua.indexOf('safari') > 0 && ua.indexOf('chrome') < 0;

  const crossFader = new _crossFader2.default({ duration: FADE_DURATION });

  const pushState = document.getElementById('_yPushState');

  const shadowMain = document.createElement('div');
  shadowMain.classList.add('shadow-main');
  shadowMain.innerHTML = `
    <div class="content container">
      <div class="page"></div>
    </div>`;
  pushState.parentNode.insertBefore(shadowMain, pushState);

  const loading = document.createElement('div');
  loading.classList.add('loading');
  loading.innerHTML = `
    <span class="sr-only">Loading...</span>
    <div class="sk-folding-cube">
      <div class="sk-cube1 sk-cube"></div>
      <div class="sk-cube2 sk-cube"></div>
      <div class="sk-cube4 sk-cube"></div>
      <div class="sk-cube3 sk-cube"></div>
    </div>
  `;
  pushState.parentNode.insertBefore(loading, pushState);

  const start$ = (_context = (_context = (_context = (_context = _fromEvent.fromEvent.call(_Observable.Observable, pushState, 'y-push-state-start'), _map.map).call(_context, ({ detail }) => detail), _map.map).call(_context, detail => [detail, document.getElementById('_main')]), _do._do).call(_context, () => {
    // If a link on the drawer has been clicked, close it
    if (!window.isDesktop && window.drawer.opened) {
      window.drawer.close();
    }
  }), _share.share).call(_context);

  const ready$ = (_context = (_context = _fromEvent.fromEvent.call(_Observable.Observable, pushState, 'y-push-state-ready'), _map.map).call(_context, ({ detail }) => detail), _share.share).call(_context);

  const progress$ = (_context = _fromEvent.fromEvent.call(_Observable.Observable, pushState, 'y-push-state-progress'), _map.map).call(_context, ({ detail }) => detail);
  // ::share();

  const after$ = (_context = (_context = _fromEvent.fromEvent.call(_Observable.Observable, pushState, 'y-push-state-after'), _map.map).call(_context, ({ detail }) => detail), _share.share).call(_context);

  // const error$ = Observable.fromEvent(pushState, 'y-push-state-error');

  // HACK
  if (isSafari) {
    _fromEvent.fromEvent.call(_Observable.Observable, window, 'popstate').subscribe(() => {
      document.body.style.minHeight = '999999px';
    });

    after$.subscribe(() => {
      document.body.style.minHeight = '';
    });
  }

  // FLIP animation (when applicable)
  (_context = _switchMap.switchMap.call(start$, ([detail]) => {
    const { event: { currentTarget } } = detail;

    const flip = _flip2.default.create(currentTarget.getAttribute && currentTarget.getAttribute('data-flip'), {
      shadowMain,
      currentTarget,
      duration: DURATION
    });

    // HACK: This assumes knowledge of the internal rx pipeline.
    // Could possibly be replaced with `withLatestFrom` shinanigans,
    // but it's more convenient like that.
    detail.flip = flip;

    return flip.start(currentTarget);
  }), makeUnstoppable).call(_context).subscribe();

  // Fade main content out
  (_context = (_context = (_context = _do._do.call(start$, ([, main]) => {
    main.style.opacity = 0;
  }), _filter.filter).call(_context, ([{ type }]) => type === 'push' || !isSafari), _exhaustMap.exhaustMap).call(_context, ([{ type }, main]) => {
    var _context2;

    return (_context2 = (_context2 = (0, _common.animate)(main, [{ opacity: 1 }, { opacity: 0 }], {
      duration: DURATION,
      // easing: 'ease',
      easing: 'cubic-bezier(0,0,0.32,1)'
    }), _do._do).call(_context2, () => {
      if (type === 'push') window.scroll(0, 0);
    }), _zip.zipProto).call(_context2, after$);
  }), makeUnstoppable).call(_context).subscribe();

  // Show loading bar when taking longer than expected
  (_context = _do._do.call(progress$, () => {
    loading.style.display = 'block';
  }), makeUnstoppable).call(_context).subscribe();

  // TODO: error message!?
  // error$
  //   // .delay(DURATION) // HACK
  //   .do(() => {
  //     loading.style.display = 'none';
  //   })
  //   .subscribe();

  // Prepare showing the new content
  (_context = (_context = (_context = _do._do.call(ready$, () => {
    loading.style.display = 'none';
  }), _filter.filter).call(_context, ({ type }) => type === 'push' || !isSafari), _switchMap.switchMap).call(_context, ({ flip, content: [main] }) => {
    var _context3;

    return (_context3 = flip.ready(main), _takeUntil.takeUntil).call(_context3, start$);
  }), makeUnstoppable).call(_context).subscribe();

  (_context = (_context = (_context = (_context = _switchMap.switchMap.call(ready$, ({ content: [main] }) => {
    var _context4;

    return (_context4 = crossFader.fetchImage((0, _elemDataset2.default)(main)), _takeUntil.takeUntil).call(_context4, start$);
  }), _startWith.startWith).call(_context, document.querySelector('.sidebar-bg')), _pairwise.pairwise).call(_context), _mergeMap.mergeMap).call(_context, crossFader.crossFade.bind(crossFader)), makeUnstoppable).call(_context).subscribe();

  // Animate the new content
  (_context = (_context = (_context = _filter.filter.call(after$, ({ type }) => type === 'push' || !isSafari), _map.map).call(_context, kind => [kind, document.querySelector('main')]), _switchMap.switchMap).call(_context, ([, main]) => (0, _common.animate)(main, [{ transform: 'translateY(-2rem)', opacity: 0 }, { transform: 'translateY(0)', opacity: 1 }], {
    duration: DURATION,
    // easing: 'ease',
    easing: 'cubic-bezier(0,0,0.32,1)'
  })), makeUnstoppable).call(_context).subscribe();

  (_context = (_context =
  // Don't send a pageview when the user blasts through the history..
  _debounceTime.debounceTime.call(after$, 2 * DURATION), _do._do).call(_context, () => {
    // Send google analytics pageview
    if (window.ga) window.ga('send', 'pageview');

    // Upgrade math blocks
    (0, _katex2.default)();
  }), makeUnstoppable).call(_context).subscribe();

  new _vanilla2.default(pushState, {
    replaceIds: ['_main'],
    linkSelector: 'a[href^="/"]',
    duration: DURATION,
    noPopDuration: isSafari,
    scrollRestoration: !isSafari
  }).startHistory();
}

},{"./common":3,"./cross-fader":4,"./flip/flip":6,"./flip/project":7,"./flip/title":8,"./katex":10,"elem-dataset":89,"rxjs/Observable":117,"rxjs/observable/fromEvent":132,"rxjs/operator/catch":135,"rxjs/operator/debounceTime":137,"rxjs/operator/do":138,"rxjs/operator/exhaustMap":139,"rxjs/operator/filter":140,"rxjs/operator/map":142,"rxjs/operator/mergeMap":144,"rxjs/operator/pairwise":146,"rxjs/operator/share":147,"rxjs/operator/startWith":148,"rxjs/operator/switchMap":149,"rxjs/operator/takeUntil":150,"rxjs/operator/zip":151,"y-push-state/src/vanilla":279}],12:[function(require,module,exports){
/* MIT license */
var cssKeywords = require('color-name');

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var v;

	if (max === 0) {
		s = 0;
	} else {
		s = (delta / max * 1000) / 10;
	}

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	v = ((max / 255) * 1000) / 10;

	return [h, s, v];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

},{"color-name":15}],13:[function(require,module,exports){
var conversions = require('./conversions');
var route = require('./route');

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;

},{"./conversions":12,"./route":14}],14:[function(require,module,exports){
var conversions = require('./conversions');

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

// https://jsperf.com/object-keys-vs-for-in-with-closure/3
var models = Object.keys(conversions);

function buildGraph() {
	var graph = {};

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};


},{"./conversions":12}],15:[function(require,module,exports){
module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};
},{}],16:[function(require,module,exports){
/* MIT license */
var colorNames = require('color-name');
var swizzle = require('simple-swizzle');

var reverseNames = {};

// create a list of reverse color names
for (var name in colorNames) {
	if (colorNames.hasOwnProperty(name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = module.exports = {
	to: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorNames[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = swizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

},{"color-name":15,"simple-swizzle":174}],17:[function(require,module,exports){
'use strict';

var colorString = require('color-string');
var convert = require('color-convert');

var _slice = [].slice;

var skippedModels = [
	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// gray conflicts with some method names, and has its own method defined.
	'gray',

	// shouldn't really be in color-convert either...
	'hex'
];

var hashedModelKeys = {};
Object.keys(convert).forEach(function (model) {
	hashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;
});

var limiters = {};

function Color(obj, model) {
	if (!(this instanceof Color)) {
		return new Color(obj, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in convert)) {
		throw new Error('Unknown model: ' + model);
	}

	var i;
	var channels;

	if (!obj) {
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (obj instanceof Color) {
		this.model = obj.model;
		this.color = obj.color.slice();
		this.valpha = obj.valpha;
	} else if (typeof obj === 'string') {
		var result = colorString.get(obj);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + obj);
		}

		this.model = result.model;
		channels = convert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (obj.length) {
		this.model = model || 'rgb';
		channels = convert[this.model].channels;
		var newArr = _slice.call(obj, 0, channels);
		this.color = zeroArray(newArr, channels);
		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
	} else if (typeof obj === 'number') {
		// this is always RGB - can be converted later on.
		obj &= 0xFFFFFF;
		this.model = 'rgb';
		this.color = [
			(obj >> 16) & 0xFF,
			(obj >> 8) & 0xFF,
			obj & 0xFF
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		var keys = Object.keys(obj);
		if ('alpha' in obj) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
		}

		var hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
		}

		this.model = hashedModelKeys[hashedKeys];

		var labels = convert[this.model].labels;
		var color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(obj[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = convert[this.model].channels;
		for (i = 0; i < channels; i++) {
			var limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString: function () {
		return this.string();
	},

	toJSON: function () {
		return this[this.model]();
	},

	string: function (places) {
		var self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to[self.model](args);
	},

	percentString: function (places) {
		var self = this.rgb().round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to.rgb.percent(args);
	},

	array: function () {
		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
	},

	object: function () {
		var result = {};
		var channels = convert[this.model].channels;
		var labels = convert[this.model].labels;

		for (var i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray: function () {
		var rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject: function () {
		var rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round: function (places) {
		places = Math.max(places || 0, 0);
		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
	},

	alpha: function (val) {
		if (arguments.length) {
			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
		}

		return this.valpha;
	},

	// rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(100)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(100)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return convert[this.model].keyword(this.color);
	},

	hex: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	rgbNumber: function () {
		var rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.rgb().color;

		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	dark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.rgb().color;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	light: function () {
		return !this.dark();
	},

	negate: function () {
		var rgb = this.rgb();
		for (var i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}
		return rgb;
	},

	lighten: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten: function (ratio) {
		var hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken: function (ratio) {
		var hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale: function () {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var rgb = this.rgb().color;
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(val, val, val);
	},

	fade: function (ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer: function (ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate: function (degrees) {
		var hsl = this.hsl();
		var hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix: function (mixinColor, weight) {
		// ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		var color1 = this.rgb();
		var color2 = mixinColor.rgb();
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return Color.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue(),
				color1.alpha() * p + color2.alpha() * (1 - p));
	}
};

// model conversion methods and static constructors
Object.keys(convert).forEach(function (model) {
	if (skippedModels.indexOf(model) !== -1) {
		return;
	}

	var channels = convert[model].channels;

	// conversion methods
	Color.prototype[model] = function () {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments.length) {
			return new Color(arguments, model);
		}

		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
		return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
	};

	// 'static' construction methods
	Color[model] = function (color) {
		if (typeof color === 'number') {
			color = zeroArray(_slice.call(arguments), channels);
		}
		return new Color(color, model);
	};
});

function roundTo(num, places) {
	return Number(num.toFixed(places));
}

function roundToPlace(places) {
	return function (num) {
		return roundTo(num, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	model.forEach(function (m) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	});

	model = model[0];

	return function (val) {
		var result;

		if (arguments.length) {
			if (modifier) {
				val = modifier(val);
			}

			result = this[model]();
			result.color[channel] = val;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(val) {
	return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
	for (var i = 0; i < length; i++) {
		if (typeof arr[i] !== 'number') {
			arr[i] = 0;
		}
	}

	return arr;
}

module.exports = Color;

},{"color-convert":13,"color-string":16}],18:[function(require,module,exports){
require('../../modules/es6.array.find');
module.exports = require('../../modules/_core').Array.find;
},{"../../modules/_core":36,"../../modules/es6.array.find":81}],19:[function(require,module,exports){
require('../../modules/es6.array.for-each');
module.exports = require('../../modules/_core').Array.forEach;
},{"../../modules/_core":36,"../../modules/es6.array.for-each":82}],20:[function(require,module,exports){
require('../../modules/es6.array.reduce');
module.exports = require('../../modules/_core').Array.reduce;
},{"../../modules/_core":36,"../../modules/es6.array.reduce":83}],21:[function(require,module,exports){
require('../../modules/es6.function.bind');
module.exports = require('../../modules/_core').Function.bind;
},{"../../modules/_core":36,"../../modules/es6.function.bind":84}],22:[function(require,module,exports){
require('../../modules/es6.number.constructor');
module.exports = Number;
},{"../../modules/es6.number.constructor":85}],23:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;
},{"../../modules/_core":36,"../../modules/es6.object.assign":86}],24:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};
},{"../../modules/_core":36,"../../modules/es6.object.define-property":87}],25:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/_core').Object.keys;
},{"../../modules/_core":36,"../../modules/es6.object.keys":88}],26:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],27:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};
},{"./_hide":46,"./_wks":80}],28:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":53}],29:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":73,"./_to-iobject":75,"./_to-length":76}],30:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = require('./_ctx')
  , IObject  = require('./_iobject')
  , toObject = require('./_to-object')
  , toLength = require('./_to-length')
  , asc      = require('./_array-species-create');
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./_array-species-create":33,"./_ctx":37,"./_iobject":51,"./_to-length":76,"./_to-object":77}],31:[function(require,module,exports){
var aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , IObject   = require('./_iobject')
  , toLength  = require('./_to-length');

module.exports = function(that, callbackfn, aLen, memo, isRight){
  aFunction(callbackfn);
  var O      = toObject(that)
    , self   = IObject(O)
    , length = toLength(O.length)
    , index  = isRight ? length - 1 : 0
    , i      = isRight ? -1 : 1;
  if(aLen < 2)for(;;){
    if(index in self){
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if(isRight ? index < 0 : length <= index){
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};
},{"./_a-function":26,"./_iobject":51,"./_to-length":76,"./_to-object":77}],32:[function(require,module,exports){
var isObject = require('./_is-object')
  , isArray  = require('./_is-array')
  , SPECIES  = require('./_wks')('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};
},{"./_is-array":52,"./_is-object":53,"./_wks":80}],33:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};
},{"./_array-species-constructor":32}],34:[function(require,module,exports){
'use strict';
var aFunction  = require('./_a-function')
  , isObject   = require('./_is-object')
  , invoke     = require('./_invoke')
  , arraySlice = [].slice
  , factories  = {};

var construct = function(F, len, args){
  if(!(len in factories)){
    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /*, args... */){
  var fn       = aFunction(this)
    , partArgs = arraySlice.call(arguments, 1);
  var bound = function(/* args... */){
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if(isObject(fn.prototype))bound.prototype = fn.prototype;
  return bound;
};
},{"./_a-function":26,"./_invoke":50,"./_is-object":53}],35:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],36:[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],37:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":26}],38:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],39:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":43}],40:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":44,"./_is-object":53}],41:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],42:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , hide      = require('./_hide')
  , redefine  = require('./_redefine')
  , ctx       = require('./_ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":36,"./_ctx":37,"./_global":44,"./_hide":46,"./_redefine":66}],43:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],44:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],45:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],46:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":39,"./_object-dp":56,"./_property-desc":65}],47:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":44}],48:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":39,"./_dom-create":40,"./_fails":43}],49:[function(require,module,exports){
var isObject       = require('./_is-object')
  , setPrototypeOf = require('./_set-proto').set;
module.exports = function(that, target, C){
  var P, S = target.constructor;
  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
    setPrototypeOf(that, P);
  } return that;
};
},{"./_is-object":53,"./_set-proto":67}],50:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],51:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":35}],52:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":35}],53:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],54:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = require('./_object-keys')
  , gOPS     = require('./_object-gops')
  , pIE      = require('./_object-pie')
  , toObject = require('./_to-object')
  , IObject  = require('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":43,"./_iobject":51,"./_object-gops":60,"./_object-keys":62,"./_object-pie":63,"./_to-object":77}],55:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":28,"./_dom-create":40,"./_enum-bug-keys":41,"./_html":47,"./_object-dps":57,"./_shared-key":68}],56:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":28,"./_descriptors":39,"./_ie8-dom-define":48,"./_to-primitive":78}],57:[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":28,"./_descriptors":39,"./_object-dp":56,"./_object-keys":62}],58:[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":39,"./_has":45,"./_ie8-dom-define":48,"./_object-pie":63,"./_property-desc":65,"./_to-iobject":75,"./_to-primitive":78}],59:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":41,"./_object-keys-internal":61}],60:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],61:[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":29,"./_has":45,"./_shared-key":68,"./_to-iobject":75}],62:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":41,"./_object-keys-internal":61}],63:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],64:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export')
  , core    = require('./_core')
  , fails   = require('./_fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./_core":36,"./_export":42,"./_fails":43}],65:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],66:[function(require,module,exports){
var global    = require('./_global')
  , hide      = require('./_hide')
  , has       = require('./_has')
  , SRC       = require('./_uid')('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
},{"./_core":36,"./_global":44,"./_has":45,"./_hide":46,"./_uid":79}],67:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object')
  , anObject = require('./_an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./_an-object":28,"./_ctx":37,"./_is-object":53,"./_object-gopd":58}],68:[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":69,"./_uid":79}],69:[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":44}],70:[function(require,module,exports){
var fails = require('./_fails');

module.exports = function(method, arg){
  return !!method && fails(function(){
    arg ? method.call(null, function(){}, 1) : method.call(null);
  });
};
},{"./_fails":43}],71:[function(require,module,exports){
var $export = require('./_export')
  , defined = require('./_defined')
  , fails   = require('./_fails')
  , spaces  = require('./_string-ws')
  , space   = '[' + spaces + ']'
  , non     = '\u200b\u0085'
  , ltrim   = RegExp('^' + space + space + '*')
  , rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function(string, TYPE){
  string = String(defined(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;
},{"./_defined":38,"./_export":42,"./_fails":43,"./_string-ws":72}],72:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
},{}],73:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":74}],74:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],75:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":38,"./_iobject":51}],76:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":74}],77:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":38}],78:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":53}],79:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],80:[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":44,"./_shared":69,"./_uid":79}],81:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":27,"./_array-methods":30,"./_export":42}],82:[function(require,module,exports){
'use strict';
var $export  = require('./_export')
  , $forEach = require('./_array-methods')(0)
  , STRICT   = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */){
    return $forEach(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":30,"./_export":42,"./_strict-method":70}],83:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});
},{"./_array-reduce":31,"./_export":42,"./_strict-method":70}],84:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', {bind: require('./_bind')});
},{"./_bind":34,"./_export":42}],85:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , has               = require('./_has')
  , cof               = require('./_cof')
  , inheritIfRequired = require('./_inherit-if-required')
  , toPrimitive       = require('./_to-primitive')
  , fails             = require('./_fails')
  , gOPN              = require('./_object-gopn').f
  , gOPD              = require('./_object-gopd').f
  , dP                = require('./_object-dp').f
  , $trim             = require('./_string-trim').trim
  , NUMBER            = 'Number'
  , $Number           = global[NUMBER]
  , Base              = $Number
  , proto             = $Number.prototype
  // Opera ~12 has broken Object#toString
  , BROKEN_COF        = cof(require('./_object-create')(proto)) == NUMBER
  , TRIM              = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function(argument){
  var it = toPrimitive(argument, false);
  if(typeof it == 'string' && it.length > 2){
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0)
      , third, radix, maxCode;
    if(first === 43 || first === 45){
      third = it.charCodeAt(2);
      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if(first === 48){
      switch(it.charCodeAt(1)){
        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default : return +it;
      }
      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if(code < 48 || code > maxCode)return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
  $Number = function Number(value){
    var it = arguments.length < 1 ? 0 : value
      , that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for(var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++){
    if(has(Base, key = keys[j]) && !has($Number, key)){
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}
},{"./_cof":35,"./_descriptors":39,"./_fails":43,"./_global":44,"./_has":45,"./_inherit-if-required":49,"./_object-create":55,"./_object-dp":56,"./_object-gopd":58,"./_object-gopn":59,"./_redefine":66,"./_string-trim":71,"./_to-primitive":78}],86:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});
},{"./_export":42,"./_object-assign":54}],87:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});
},{"./_descriptors":39,"./_export":42,"./_object-dp":56}],88:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object')
  , $keys    = require('./_object-keys');

require('./_object-sap')('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./_object-keys":62,"./_object-sap":64,"./_to-object":77}],89:[function(require,module,exports){
'use strict';

// <3 Modernizr
// https://raw.githubusercontent.com/Modernizr/Modernizr/master/feature-detects/dom/dataset.js

function useNative() {
	var elem = document.createElement('div');
	elem.setAttribute('data-a-b', 'c');

	return Boolean(elem.dataset && elem.dataset.aB === 'c');
}

function nativeDataset(element) {
	return element.dataset;
}

module.exports = useNative() ? nativeDataset : function (element) {
	var map = {};
	var attributes = element.attributes;

	function getter() {
		return this.value;
	}

	function setter(name, value) {
		if (typeof value === 'undefined') {
			this.removeAttribute(name);
		} else {
			this.setAttribute(name, value);
		}
	}

	for (var i = 0, j = attributes.length; i < j; i++) {
		var attribute = attributes[i];

		if (attribute) {
			var name = attribute.name;

			if (name.indexOf('data-') === 0) {
				var prop = name.slice(5).replace(/-./g, function (u) {
					return u.charAt(1).toUpperCase();
				});

				var value = attribute.value;

				Object.defineProperty(map, prop, {
					enumerable: true,
					get: getter.bind({ value: value || '' }),
					set: setter.bind(element, name)
				});
			}
		}
	}

	return map;
};

},{}],90:[function(require,module,exports){
'use strict';

module.exports = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

},{}],91:[function(require,module,exports){
/* eslint no-console:0 */
/**
 * This is the main entry point for KaTeX. Here, we expose functions for
 * rendering expressions either to DOM nodes or to markup strings.
 *
 * We also expose the ParseError class to check if errors thrown from KaTeX are
 * errors in the expression, or errors in javascript handling.
 */

var ParseError = require("./src/ParseError");
var Settings = require("./src/Settings");

var buildTree = require("./src/buildTree");
var parseTree = require("./src/parseTree");
var utils = require("./src/utils");

/**
 * Parse and build an expression, and place that expression in the DOM node
 * given.
 */
var render = function(expression, baseNode, options) {
    utils.clearNode(baseNode);

    var settings = new Settings(options);

    var tree = parseTree(expression, settings);
    var node = buildTree(tree, expression, settings).toNode();

    baseNode.appendChild(node);
};

// KaTeX's styles don't work properly in quirks mode. Print out an error, and
// disable rendering.
if (typeof document !== "undefined") {
    if (document.compatMode !== "CSS1Compat") {
        typeof console !== "undefined" && console.warn(
            "Warning: KaTeX doesn't work in quirks mode. Make sure your " +
                "website has a suitable doctype.");

        render = function() {
            throw new ParseError("KaTeX doesn't work in quirks mode.");
        };
    }
}

/**
 * Parse and build an expression, and return the markup for that.
 */
var renderToString = function(expression, options) {
    var settings = new Settings(options);

    var tree = parseTree(expression, settings);
    return buildTree(tree, expression, settings).toMarkup();
};

/**
 * Parse an expression and return the parse tree.
 */
var generateParseTree = function(expression, options) {
    var settings = new Settings(options);
    return parseTree(expression, settings);
};

module.exports = {
    render: render,
    renderToString: renderToString,
    /**
     * NOTE: This method is not currently recommended for public use.
     * The internal tree representation is unstable and is very likely
     * to change. Use at your own risk.
     */
    __parse: generateParseTree,
    ParseError: ParseError
};

},{"./src/ParseError":95,"./src/Settings":97,"./src/buildTree":102,"./src/parseTree":111,"./src/utils":114}],92:[function(require,module,exports){
/**
 * The Lexer class handles tokenizing the input in various ways. Since our
 * parser expects us to be able to backtrack, the lexer allows lexing from any
 * given starting point.
 *
 * Its main exposed function is the `lex` function, which takes a position to
 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
 * function.
 *
 * The various `_innerLex` functions perform the actual lexing of different
 * kinds.
 */

var matchAt = require("match-at");

var ParseError = require("./ParseError");

// The main lexer class
function Lexer(input) {
    this.input = input;
    this.pos = 0;
}

/**
 * The resulting token returned from `lex`.
 *
 * It consists of the token text plus some position information.
 * The position information is essentially a range in an input string,
 * but instead of referencing the bare input string, we refer to the lexer.
 * That way it is possible to attach extra metadata to the input string,
 * like for example a file name or similar.
 *
 * The position information (all three parameters) is optional,
 * so it is OK to construct synthetic tokens if appropriate.
 * Not providing available position information may lead to
 * degraded error reporting, though.
 *
 * @param {string}  text   the text of this token
 * @param {number=} start  the start offset, zero-based inclusive
 * @param {number=} end    the end offset, zero-based exclusive
 * @param {Lexer=}  lexer  the lexer which in turn holds the input string
 */
function Token(text, start, end, lexer) {
    this.text = text;
    this.start = start;
    this.end = end;
    this.lexer = lexer;
}

/**
 * Given a pair of tokens (this and endToken), compute a Token encompassing
 * the whole input range enclosed by these two.
 *
 * @param {Token}  endToken  last token of the range, inclusive
 * @param {string} text      the text of the newly constructed token
 */
Token.prototype.range = function(endToken, text) {
    if (endToken.lexer !== this.lexer) {
        return new Token(text); // sorry, no position information available
    }
    return new Token(text, this.start, endToken.end, this.lexer);
};

/* The following tokenRegex
 * - matches typical whitespace (but not NBSP etc.) using its first group
 * - does not match any control character \x00-\x1f except whitespace
 * - does not match a bare backslash
 * - matches any ASCII character except those just mentioned
 * - does not match the BMP private use area \uE000-\uF8FF
 * - does not match bare surrogate code units
 * - matches any BMP character except for those just described
 * - matches any valid Unicode surrogate pair
 * - matches a backslash followed by one or more letters
 * - matches a backslash followed by any BMP character, including newline
 * Just because the Lexer matches something doesn't mean it's valid input:
 * If there is no matching function or symbol definition, the Parser will
 * still reject the input.
 */
var tokenRegex = new RegExp(
    "([ \r\n\t]+)|" +                                 // whitespace
    "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" +  // single codepoint
    "|[\uD800-\uDBFF][\uDC00-\uDFFF]" +               // surrogate pair
    "|\\\\(?:[a-zA-Z]+|[^\uD800-\uDFFF])" +           // function name
    ")"
);

/**
 * This function lexes a single token.
 */
Lexer.prototype.lex = function() {
    var input = this.input;
    var pos = this.pos;
    if (pos === input.length) {
        return new Token("EOF", pos, pos, this);
    }
    var match = matchAt(tokenRegex, input, pos);
    if (match === null) {
        throw new ParseError(
            "Unexpected character: '" + input[pos] + "'",
            new Token(input[pos], pos, pos + 1, this));
    }
    var text = match[2] || " ";
    var start = this.pos;
    this.pos += match[0].length;
    var end = this.pos;
    return new Token(text, start, end, this);
};

module.exports = Lexer;

},{"./ParseError":95,"match-at":115}],93:[function(require,module,exports){
/**
 * This file contains the gullet where macros are expanded
 * until only non-macro tokens remain.
 */

var Lexer = require("./Lexer");

function MacroExpander(input, macros) {
    this.lexer = new Lexer(input);
    this.macros = macros;
    this.stack = []; // contains tokens in REVERSE order
    this.discardedWhiteSpace = [];
}

/**
 * Recursively expand first token, then return first non-expandable token.
 */
MacroExpander.prototype.nextToken = function() {
    for (;;) {
        if (this.stack.length === 0) {
            this.stack.push(this.lexer.lex());
        }
        var topToken = this.stack.pop();
        var name = topToken.text;
        if (!(name.charAt(0) === "\\" && this.macros.hasOwnProperty(name))) {
            return topToken;
        }
        var expansion = this.macros[name];
        if (typeof expansion === "string") {
            var bodyLexer = new Lexer(expansion);
            expansion = [];
            var tok = bodyLexer.lex();
            while (tok.text !== "EOF") {
                expansion.push(tok);
                tok = bodyLexer.lex();
            }
            expansion.reverse(); // to fit in with stack using push and pop
            this.macros[name] = expansion;
        }
        this.stack = this.stack.concat(expansion);
    }
};

MacroExpander.prototype.get = function(ignoreSpace) {
    this.discardedWhiteSpace = [];
    var token = this.nextToken();
    if (ignoreSpace) {
        while (token.text === " ") {
            this.discardedWhiteSpace.push(token);
            token = this.nextToken();
        }
    }
    return token;
};

/**
 * Undo the effect of the preceding call to the get method.
 * A call to this method MUST be immediately preceded and immediately followed
 * by a call to get.  Only used during mode switching, i.e. after one token
 * was got in the old mode but should get got again in a new mode
 * with possibly different whitespace handling.
 */
MacroExpander.prototype.unget = function(token) {
    this.stack.push(token);
    while (this.discardedWhiteSpace.length !== 0) {
        this.stack.push(this.discardedWhiteSpace.pop());
    }
};

module.exports = MacroExpander;

},{"./Lexer":92}],94:[function(require,module,exports){
/**
 * This file contains information about the options that the Parser carries
 * around with it while parsing. Data is held in an `Options` object, and when
 * recursing, a new `Options` object can be created with the `.with*` and
 * `.reset` functions.
 */

/**
 * This is the main options class. It contains the style, size, color, and font
 * of the current parse level. It also contains the style and size of the parent
 * parse level, so size changes can be handled efficiently.
 *
 * Each of the `.with*` and `.reset` functions passes its current style and size
 * as the parentStyle and parentSize of the new options class, so parent
 * handling is taken care of automatically.
 */
function Options(data) {
    this.style = data.style;
    this.color = data.color;
    this.size = data.size;
    this.phantom = data.phantom;
    this.font = data.font;

    if (data.parentStyle === undefined) {
        this.parentStyle = data.style;
    } else {
        this.parentStyle = data.parentStyle;
    }

    if (data.parentSize === undefined) {
        this.parentSize = data.size;
    } else {
        this.parentSize = data.parentSize;
    }
}

/**
 * Returns a new options object with the same properties as "this".  Properties
 * from "extension" will be copied to the new options object.
 */
Options.prototype.extend = function(extension) {
    var data = {
        style: this.style,
        size: this.size,
        color: this.color,
        parentStyle: this.style,
        parentSize: this.size,
        phantom: this.phantom,
        font: this.font
    };

    for (var key in extension) {
        if (extension.hasOwnProperty(key)) {
            data[key] = extension[key];
        }
    }

    return new Options(data);
};

/**
 * Create a new options object with the given style.
 */
Options.prototype.withStyle = function(style) {
    return this.extend({
        style: style
    });
};

/**
 * Create a new options object with the given size.
 */
Options.prototype.withSize = function(size) {
    return this.extend({
        size: size
    });
};

/**
 * Create a new options object with the given color.
 */
Options.prototype.withColor = function(color) {
    return this.extend({
        color: color
    });
};

/**
 * Create a new options object with "phantom" set to true.
 */
Options.prototype.withPhantom = function() {
    return this.extend({
        phantom: true
    });
};

/**
 * Create a new options objects with the give font.
 */
Options.prototype.withFont = function(font) {
    return this.extend({
        font: font || this.font
    });
};

/**
 * Create a new options object with the same style, size, and color. This is
 * used so that parent style and size changes are handled correctly.
 */
Options.prototype.reset = function() {
    return this.extend({});
};

/**
 * A map of color names to CSS colors.
 * TODO(emily): Remove this when we have real macros
 */
var colorMap = {
    "katex-blue": "#6495ed",
    "katex-orange": "#ffa500",
    "katex-pink": "#ff00af",
    "katex-red": "#df0030",
    "katex-green": "#28ae7b",
    "katex-gray": "gray",
    "katex-purple": "#9d38bd",
    "katex-blueA": "#ccfaff",
    "katex-blueB": "#80f6ff",
    "katex-blueC": "#63d9ea",
    "katex-blueD": "#11accd",
    "katex-blueE": "#0c7f99",
    "katex-tealA": "#94fff5",
    "katex-tealB": "#26edd5",
    "katex-tealC": "#01d1c1",
    "katex-tealD": "#01a995",
    "katex-tealE": "#208170",
    "katex-greenA": "#b6ffb0",
    "katex-greenB": "#8af281",
    "katex-greenC": "#74cf70",
    "katex-greenD": "#1fab54",
    "katex-greenE": "#0d923f",
    "katex-goldA": "#ffd0a9",
    "katex-goldB": "#ffbb71",
    "katex-goldC": "#ff9c39",
    "katex-goldD": "#e07d10",
    "katex-goldE": "#a75a05",
    "katex-redA": "#fca9a9",
    "katex-redB": "#ff8482",
    "katex-redC": "#f9685d",
    "katex-redD": "#e84d39",
    "katex-redE": "#bc2612",
    "katex-maroonA": "#ffbde0",
    "katex-maroonB": "#ff92c6",
    "katex-maroonC": "#ed5fa6",
    "katex-maroonD": "#ca337c",
    "katex-maroonE": "#9e034e",
    "katex-purpleA": "#ddd7ff",
    "katex-purpleB": "#c6b9fc",
    "katex-purpleC": "#aa87ff",
    "katex-purpleD": "#7854ab",
    "katex-purpleE": "#543b78",
    "katex-mintA": "#f5f9e8",
    "katex-mintB": "#edf2df",
    "katex-mintC": "#e0e5cc",
    "katex-grayA": "#f6f7f7",
    "katex-grayB": "#f0f1f2",
    "katex-grayC": "#e3e5e6",
    "katex-grayD": "#d6d8da",
    "katex-grayE": "#babec2",
    "katex-grayF": "#888d93",
    "katex-grayG": "#626569",
    "katex-grayH": "#3b3e40",
    "katex-grayI": "#21242c",
    "katex-kaBlue": "#314453",
    "katex-kaGreen": "#71B307"
};

/**
 * Gets the CSS color of the current options object, accounting for the
 * `colorMap`.
 */
Options.prototype.getColor = function() {
    if (this.phantom) {
        return "transparent";
    } else {
        return colorMap[this.color] || this.color;
    }
};

module.exports = Options;

},{}],95:[function(require,module,exports){
/**
 * This is the ParseError class, which is the main error thrown by KaTeX
 * functions when something has gone wrong. This is used to distinguish internal
 * errors from errors in the expression that the user provided.
 *
 * If possible, a caller should provide a Token or ParseNode with information
 * about where in the source string the problem occurred.
 *
 * @param {string} message  The error message
 * @param {(Token|ParseNode)=} token  An object providing position information
 */
function ParseError(message, token) {
    var error = "KaTeX parse error: " + message;
    var start;
    var end;

    if (token && token.lexer && token.start <= token.end) {
        // If we have the input and a position, make the error a bit fancier

        // Get the input
        var input = token.lexer.input;

        // Prepend some information
        start = token.start;
        end = token.end;
        if (start === input.length) {
            error += " at end of input: ";
        } else {
            error += " at position " + (start + 1) + ": ";
        }

        // Underline token in question using combining underscores
        var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");

        // Extract some context from the input and add it to the error
        var left;
        if (start > 15) {
            left = "" + input.slice(start - 15, start);
        } else {
            left = input.slice(0, start);
        }
        var right;
        if (end + 15 < input.length) {
            right = input.slice(end, end + 15) + "";
        } else {
            right = input.slice(end);
        }
        error += left + underlined + right;
    }

    // Some hackery to make ParseError a prototype of Error
    // See http://stackoverflow.com/a/8460753
    var self = new Error(error);
    self.name = "ParseError";
    self.__proto__ = ParseError.prototype;

    self.position = start;
    return self;
}

// More hackery
ParseError.prototype.__proto__ = Error.prototype;

module.exports = ParseError;

},{}],96:[function(require,module,exports){
/* eslint no-constant-condition:0 */
var functions = require("./functions");
var environments = require("./environments");
var MacroExpander = require("./MacroExpander");
var symbols = require("./symbols");
var utils = require("./utils");
var cjkRegex = require("./unicodeRegexes").cjkRegex;

var parseData = require("./parseData");
var ParseError = require("./ParseError");

/**
 * This file contains the parser used to parse out a TeX expression from the
 * input. Since TeX isn't context-free, standard parsers don't work particularly
 * well.
 *
 * The strategy of this parser is as such:
 *
 * The main functions (the `.parse...` ones) take a position in the current
 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
 * this.lexer) also supports pulling out tokens at arbitrary places. When
 * individual tokens are needed at a position, the lexer is called to pull out a
 * token, which is then used.
 *
 * The parser has a property called "mode" indicating the mode that
 * the parser is currently in. Currently it has to be one of "math" or
 * "text", which denotes whether the current environment is a math-y
 * one or a text-y one (e.g. inside \text). Currently, this serves to
 * limit the functions which can be used in text mode.
 *
 * The main functions then return an object which contains the useful data that
 * was parsed at its given point, and a new position at the end of the parsed
 * data. The main functions can call each other and continue the parsing by
 * using the returned position as a new starting point.
 *
 * There are also extra `.handle...` functions, which pull out some reused
 * functionality into self-contained functions.
 *
 * The earlier functions return ParseNodes.
 * The later functions (which are called deeper in the parse) sometimes return
 * ParseFuncOrArgument, which contain a ParseNode as well as some data about
 * whether the parsed object is a function which is missing some arguments, or a
 * standalone object which can be used as an argument to another function.
 */

/**
 * Main Parser class
 */
function Parser(input, settings) {
    // Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)
    this.gullet = new MacroExpander(input, settings.macros);
    // Store the settings for use in parsing
    this.settings = settings;
    // Count leftright depth (for \middle errors)
    this.leftrightDepth = 0;
}

var ParseNode = parseData.ParseNode;

/**
 * An initial function (without its arguments), or an argument to a function.
 * The `result` argument should be a ParseNode.
 */
function ParseFuncOrArgument(result, isFunction, token) {
    this.result = result;
    // Is this a function (i.e. is it something defined in functions.js)?
    this.isFunction = isFunction;
    this.token = token;
}

/**
 * Checks a result to make sure it has the right type, and throws an
 * appropriate error otherwise.
 *
 * @param {boolean=} consume whether to consume the expected token,
 *                           defaults to true
 */
Parser.prototype.expect = function(text, consume) {
    if (this.nextToken.text !== text) {
        throw new ParseError(
            "Expected '" + text + "', got '" + this.nextToken.text + "'",
            this.nextToken
        );
    }
    if (consume !== false) {
        this.consume();
    }
};

/**
 * Considers the current look ahead token as consumed,
 * and fetches the one after that as the new look ahead.
 */
Parser.prototype.consume = function() {
    this.nextToken = this.gullet.get(this.mode === "math");
};

Parser.prototype.switchMode = function(newMode) {
    this.gullet.unget(this.nextToken);
    this.mode = newMode;
    this.consume();
};

/**
 * Main parsing function, which parses an entire input.
 *
 * @return {?Array.<ParseNode>}
 */
Parser.prototype.parse = function() {
    // Try to parse the input
    this.mode = "math";
    this.consume();
    var parse = this.parseInput();
    return parse;
};

/**
 * Parses an entire input tree.
 */
Parser.prototype.parseInput = function() {
    // Parse an expression
    var expression = this.parseExpression(false);
    // If we succeeded, make sure there's an EOF at the end
    this.expect("EOF", false);
    return expression;
};

var endOfExpression = ["}", "\\end", "\\right", "&", "\\\\", "\\cr"];

/**
 * Parses an "expression", which is a list of atoms.
 *
 * @param {boolean} breakOnInfix  Should the parsing stop when we hit infix
 *                  nodes? This happens when functions have higher precendence
 *                  than infix nodes in implicit parses.
 *
 * @param {?string} breakOnTokenText  The text of the token that the expression
 *                  should end with, or `null` if something else should end the
 *                  expression.
 *
 * @return {ParseNode}
 */
Parser.prototype.parseExpression = function(breakOnInfix, breakOnTokenText) {
    var body = [];
    // Keep adding atoms to the body until we can't parse any more atoms (either
    // we reached the end, a }, or a \right)
    while (true) {
        var lex = this.nextToken;
        if (endOfExpression.indexOf(lex.text) !== -1) {
            break;
        }
        if (breakOnTokenText && lex.text === breakOnTokenText) {
            break;
        }
        if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
            break;
        }
        var atom = this.parseAtom();
        if (!atom) {
            if (!this.settings.throwOnError && lex.text[0] === "\\") {
                var errorNode = this.handleUnsupportedCmd();
                body.push(errorNode);
                continue;
            }

            break;
        }
        body.push(atom);
    }
    return this.handleInfixNodes(body);
};

/**
 * Rewrites infix operators such as \over with corresponding commands such
 * as \frac.
 *
 * There can only be one infix operator per group.  If there's more than one
 * then the expression is ambiguous.  This can be resolved by adding {}.
 *
 * @returns {Array}
 */
Parser.prototype.handleInfixNodes = function(body) {
    var overIndex = -1;
    var funcName;

    for (var i = 0; i < body.length; i++) {
        var node = body[i];
        if (node.type === "infix") {
            if (overIndex !== -1) {
                throw new ParseError(
                    "only one infix operator per group",
                    node.value.token);
            }
            overIndex = i;
            funcName = node.value.replaceWith;
        }
    }

    if (overIndex !== -1) {
        var numerNode;
        var denomNode;

        var numerBody = body.slice(0, overIndex);
        var denomBody = body.slice(overIndex + 1);

        if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
            numerNode = numerBody[0];
        } else {
            numerNode = new ParseNode("ordgroup", numerBody, this.mode);
        }

        if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
            denomNode = denomBody[0];
        } else {
            denomNode = new ParseNode("ordgroup", denomBody, this.mode);
        }

        var value = this.callFunction(
            funcName, [numerNode, denomNode], null);
        return [new ParseNode(value.type, value, this.mode)];
    } else {
        return body;
    }
};

// The greediness of a superscript or subscript
var SUPSUB_GREEDINESS = 1;

/**
 * Handle a subscript or superscript with nice errors.
 */
Parser.prototype.handleSupSubscript = function(name) {
    var symbolToken = this.nextToken;
    var symbol = symbolToken.text;
    this.consume();
    var group = this.parseGroup();

    if (!group) {
        if (!this.settings.throwOnError && this.nextToken.text[0] === "\\") {
            return this.handleUnsupportedCmd();
        } else {
            throw new ParseError(
                "Expected group after '" + symbol + "'",
                symbolToken
            );
        }
    } else if (group.isFunction) {
        // ^ and _ have a greediness, so handle interactions with functions'
        // greediness
        var funcGreediness = functions[group.result].greediness;
        if (funcGreediness > SUPSUB_GREEDINESS) {
            return this.parseFunction(group);
        } else {
            throw new ParseError(
                "Got function '" + group.result + "' with no arguments " +
                    "as " + name, symbolToken);
        }
    } else {
        return group.result;
    }
};

/**
 * Converts the textual input of an unsupported command into a text node
 * contained within a color node whose color is determined by errorColor
 */
Parser.prototype.handleUnsupportedCmd = function() {
    var text = this.nextToken.text;
    var textordArray = [];

    for (var i = 0; i < text.length; i++) {
        textordArray.push(new ParseNode("textord", text[i], "text"));
    }

    var textNode = new ParseNode(
        "text",
        {
            body: textordArray,
            type: "text"
        },
        this.mode);

    var colorNode = new ParseNode(
        "color",
        {
            color: this.settings.errorColor,
            value: [textNode],
            type: "color"
        },
        this.mode);

    this.consume();
    return colorNode;
};

/**
 * Parses a group with optional super/subscripts.
 *
 * @return {?ParseNode}
 */
Parser.prototype.parseAtom = function() {
    // The body of an atom is an implicit group, so that things like
    // \left(x\right)^2 work correctly.
    var base = this.parseImplicitGroup();

    // In text mode, we don't have superscripts or subscripts
    if (this.mode === "text") {
        return base;
    }

    // Note that base may be empty (i.e. null) at this point.

    var superscript;
    var subscript;
    while (true) {
        // Lex the first token
        var lex = this.nextToken;

        if (lex.text === "\\limits" || lex.text === "\\nolimits") {
            // We got a limit control
            if (!base || base.type !== "op") {
                throw new ParseError(
                    "Limit controls must follow a math operator",
                    lex);
            } else {
                var limits = lex.text === "\\limits";
                base.value.limits = limits;
                base.value.alwaysHandleSupSub = true;
            }
            this.consume();
        } else if (lex.text === "^") {
            // We got a superscript start
            if (superscript) {
                throw new ParseError("Double superscript", lex);
            }
            superscript = this.handleSupSubscript("superscript");
        } else if (lex.text === "_") {
            // We got a subscript start
            if (subscript) {
                throw new ParseError("Double subscript", lex);
            }
            subscript = this.handleSupSubscript("subscript");
        } else if (lex.text === "'") {
            // We got a prime
            var prime = new ParseNode("textord", "\\prime", this.mode);

            // Many primes can be grouped together, so we handle this here
            var primes = [prime];
            this.consume();
            // Keep lexing tokens until we get something that's not a prime
            while (this.nextToken.text === "'") {
                // For each one, add another prime to the list
                primes.push(prime);
                this.consume();
            }
            // Put them into an ordgroup as the superscript
            superscript = new ParseNode("ordgroup", primes, this.mode);
        } else {
            // If it wasn't ^, _, or ', stop parsing super/subscripts
            break;
        }
    }

    if (superscript || subscript) {
        // If we got either a superscript or subscript, create a supsub
        return new ParseNode("supsub", {
            base: base,
            sup: superscript,
            sub: subscript
        }, this.mode);
    } else {
        // Otherwise return the original body
        return base;
    }
};

// A list of the size-changing functions, for use in parseImplicitGroup
var sizeFuncs = [
    "\\tiny", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize",
    "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"
];

// A list of the style-changing functions, for use in parseImplicitGroup
var styleFuncs = [
    "\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"
];

/**
 * Parses an implicit group, which is a group that starts at the end of a
 * specified, and ends right before a higher explicit group ends, or at EOL. It
 * is used for functions that appear to affect the current style, like \Large or
 * \textrm, where instead of keeping a style we just pretend that there is an
 * implicit grouping after it until the end of the group. E.g.
 *   small text {\Large large text} small text again
 * It is also used for \left and \right to get the correct grouping.
 *
 * @return {?ParseNode}
 */
Parser.prototype.parseImplicitGroup = function() {
    var start = this.parseSymbol();

    if (start == null) {
        // If we didn't get anything we handle, fall back to parseFunction
        return this.parseFunction();
    }

    var func = start.result;
    var body;

    if (func === "\\left") {
        // If we see a left:
        // Parse the entire left function (including the delimiter)
        var left = this.parseFunction(start);
        // Parse out the implicit body
        ++this.leftrightDepth;
        body = this.parseExpression(false);
        --this.leftrightDepth;
        // Check the next token
        this.expect("\\right", false);
        var right = this.parseFunction();
        return new ParseNode("leftright", {
            body: body,
            left: left.value.value,
            right: right.value.value
        }, this.mode);
    } else if (func === "\\begin") {
        // begin...end is similar to left...right
        var begin = this.parseFunction(start);
        var envName = begin.value.name;
        if (!environments.hasOwnProperty(envName)) {
            throw new ParseError(
                "No such environment: " + envName, begin.value.nameGroup);
        }
        // Build the environment object. Arguments and other information will
        // be made available to the begin and end methods using properties.
        var env = environments[envName];
        var args = this.parseArguments("\\begin{" + envName + "}", env);
        var context = {
            mode: this.mode,
            envName: envName,
            parser: this,
            positions: args.pop()
        };
        var result = env.handler(context, args);
        this.expect("\\end", false);
        var endNameToken = this.nextToken;
        var end = this.parseFunction();
        if (end.value.name !== envName) {
            throw new ParseError(
                "Mismatch: \\begin{" + envName + "} matched " +
                "by \\end{" + end.value.name + "}",
                endNameToken);
        }
        result.position = end.position;
        return result;
    } else if (utils.contains(sizeFuncs, func)) {
        // If we see a sizing function, parse out the implict body
        body = this.parseExpression(false);
        return new ParseNode("sizing", {
            // Figure out what size to use based on the list of functions above
            size: "size" + (utils.indexOf(sizeFuncs, func) + 1),
            value: body
        }, this.mode);
    } else if (utils.contains(styleFuncs, func)) {
        // If we see a styling function, parse out the implict body
        body = this.parseExpression(true);
        return new ParseNode("styling", {
            // Figure out what style to use by pulling out the style from
            // the function name
            style: func.slice(1, func.length - 5),
            value: body
        }, this.mode);
    } else {
        // Defer to parseFunction if it's not a function we handle
        return this.parseFunction(start);
    }
};

/**
 * Parses an entire function, including its base and all of its arguments.
 * The base might either have been parsed already, in which case
 * it is provided as an argument, or it's the next group in the input.
 *
 * @param {ParseFuncOrArgument=} baseGroup optional as described above
 * @return {?ParseNode}
 */
Parser.prototype.parseFunction = function(baseGroup) {
    if (!baseGroup) {
        baseGroup = this.parseGroup();
    }

    if (baseGroup) {
        if (baseGroup.isFunction) {
            var func = baseGroup.result;
            var funcData = functions[func];
            if (this.mode === "text" && !funcData.allowedInText) {
                throw new ParseError(
                    "Can't use function '" + func + "' in text mode",
                    baseGroup.token);
            }

            var args = this.parseArguments(func, funcData);
            var token = baseGroup.token;
            var result = this.callFunction(func, args, args.pop(), token);
            return new ParseNode(result.type, result, this.mode);
        } else {
            return baseGroup.result;
        }
    } else {
        return null;
    }
};

/**
 * Call a function handler with a suitable context and arguments.
 */
Parser.prototype.callFunction = function(name, args, positions, token) {
    var context = {
        funcName: name,
        parser: this,
        positions: positions,
        token: token
    };
    return functions[name].handler(context, args);
};

/**
 * Parses the arguments of a function or environment
 *
 * @param {string} func  "\name" or "\begin{name}"
 * @param {{numArgs:number,numOptionalArgs:number|undefined}} funcData
 * @return the array of arguments, with the list of positions as last element
 */
Parser.prototype.parseArguments = function(func, funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
        return [[this.pos]];
    }

    var baseGreediness = funcData.greediness;
    var positions = [this.pos];
    var args = [];

    for (var i = 0; i < totalArgs; i++) {
        var nextToken = this.nextToken;
        var argType = funcData.argTypes && funcData.argTypes[i];
        var arg;
        if (i < funcData.numOptionalArgs) {
            if (argType) {
                arg = this.parseGroupOfType(argType, true);
            } else {
                arg = this.parseGroup(true);
            }
            if (!arg) {
                args.push(null);
                positions.push(this.pos);
                continue;
            }
        } else {
            if (argType) {
                arg = this.parseGroupOfType(argType);
            } else {
                arg = this.parseGroup();
            }
            if (!arg) {
                if (!this.settings.throwOnError &&
                    this.nextToken.text[0] === "\\") {
                    arg = new ParseFuncOrArgument(
                        this.handleUnsupportedCmd(this.nextToken.text),
                        false);
                } else {
                    throw new ParseError(
                        "Expected group after '" + func + "'", nextToken);
                }
            }
        }
        var argNode;
        if (arg.isFunction) {
            var argGreediness =
                functions[arg.result].greediness;
            if (argGreediness > baseGreediness) {
                argNode = this.parseFunction(arg);
            } else {
                throw new ParseError(
                    "Got function '" + arg.result + "' as " +
                    "argument to '" + func + "'", nextToken);
            }
        } else {
            argNode = arg.result;
        }
        args.push(argNode);
        positions.push(this.pos);
    }

    args.push(positions);

    return args;
};


/**
 * Parses a group when the mode is changing.
 *
 * @return {?ParseFuncOrArgument}
 */
Parser.prototype.parseGroupOfType = function(innerMode, optional) {
    var outerMode = this.mode;
    // Handle `original` argTypes
    if (innerMode === "original") {
        innerMode = outerMode;
    }

    if (innerMode === "color") {
        return this.parseColorGroup(optional);
    }
    if (innerMode === "size") {
        return this.parseSizeGroup(optional);
    }

    this.switchMode(innerMode);
    if (innerMode === "text") {
        // text mode is special because it should ignore the whitespace before
        // it
        while (this.nextToken.text === " ") {
            this.consume();
        }
    }
    // By the time we get here, innerMode is one of "text" or "math".
    // We switch the mode of the parser, recurse, then restore the old mode.
    var res = this.parseGroup(optional);
    this.switchMode(outerMode);
    return res;
};

/**
 * Parses a group, essentially returning the string formed by the
 * brace-enclosed tokens plus some position information.
 *
 * @param {string} modeName  Used to describe the mode in error messages
 * @param {boolean=} optional  Whether the group is optional or required
 */
Parser.prototype.parseStringGroup = function(modeName, optional) {
    if (optional && this.nextToken.text !== "[") {
        return null;
    }
    var outerMode = this.mode;
    this.mode = "text";
    this.expect(optional ? "[" : "{");
    var str = "";
    var firstToken = this.nextToken;
    var lastToken = firstToken;
    while (this.nextToken.text !== (optional ? "]" : "}")) {
        if (this.nextToken.text === "EOF") {
            throw new ParseError(
                "Unexpected end of input in " + modeName,
                firstToken.range(this.nextToken, str));
        }
        lastToken = this.nextToken;
        str += lastToken.text;
        this.consume();
    }
    this.mode = outerMode;
    this.expect(optional ? "]" : "}");
    return firstToken.range(lastToken, str);
};

/**
 * Parses a regex-delimited group: the largest sequence of tokens
 * whose concatenated strings match `regex`. Returns the string
 * formed by the tokens plus some position information.
 *
 * @param {RegExp} regex
 * @param {string} modeName  Used to describe the mode in error messages
 */
Parser.prototype.parseRegexGroup = function(regex, modeName) {
    var outerMode = this.mode;
    this.mode = "text";
    var firstToken = this.nextToken;
    var lastToken = firstToken;
    var str = "";
    while (this.nextToken.text !== "EOF"
           && regex.test(str + this.nextToken.text)) {
        lastToken = this.nextToken;
        str += lastToken.text;
        this.consume();
    }
    if (str === "") {
        throw new ParseError(
            "Invalid " + modeName + ": '" + firstToken.text + "'",
            firstToken);
    }
    this.mode = outerMode;
    return firstToken.range(lastToken, str);
};

/**
 * Parses a color description.
 */
Parser.prototype.parseColorGroup = function(optional) {
    var res = this.parseStringGroup("color", optional);
    if (!res) {
        return null;
    }
    var match = (/^(#[a-z0-9]+|[a-z]+)$/i).exec(res.text);
    if (!match) {
        throw new ParseError("Invalid color: '" + res.text + "'", res);
    }
    return new ParseFuncOrArgument(
        new ParseNode("color", match[0], this.mode),
        false);
};

/**
 * Parses a size specification, consisting of magnitude and unit.
 */
Parser.prototype.parseSizeGroup = function(optional) {
    var res;
    if (!optional && this.nextToken.text !== "{") {
        res = this.parseRegexGroup(
            /^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2}$/, "size");
    } else {
        res = this.parseStringGroup("size", optional);
    }
    if (!res) {
        return null;
    }
    var match = (/([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/).exec(res.text);
    if (!match) {
        throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    var data = {
        number: +(match[1] + match[2]), // sign + magnitude, cast to number
        unit: match[3]
    };
    if (data.unit !== "em" && data.unit !== "ex" && data.unit !== "mu") {
        throw new ParseError("Invalid unit: '" + data.unit + "'", res);
    }
    return new ParseFuncOrArgument(
        new ParseNode("color", data, this.mode),
        false);
};

/**
 * If the argument is false or absent, this parses an ordinary group,
 * which is either a single nucleus (like "x") or an expression
 * in braces (like "{x+y}").
 * If the argument is true, it parses either a bracket-delimited expression
 * (like "[x+y]") or returns null to indicate the absence of a
 * bracket-enclosed group.
 *
 * @param {boolean=} optional  Whether the group is optional or required
 * @return {?ParseFuncOrArgument}
 */
Parser.prototype.parseGroup = function(optional) {
    var firstToken = this.nextToken;
    // Try to parse an open brace
    if (this.nextToken.text === (optional ? "[" : "{")) {
        // If we get a brace, parse an expression
        this.consume();
        var expression = this.parseExpression(false, optional ? "]" : null);
        var lastToken = this.nextToken;
        // Make sure we get a close brace
        this.expect(optional ? "]" : "}");
        if (this.mode === "text") {
            this.formLigatures(expression);
        }
        return new ParseFuncOrArgument(
            new ParseNode("ordgroup", expression, this.mode,
                          firstToken, lastToken),
            false);
    } else {
        // Otherwise, just return a nucleus, or nothing for an optional group
        return optional ? null : this.parseSymbol();
    }
};

/**
 * Form ligature-like combinations of characters for text mode.
 * This includes inputs like "--", "---", "``" and "''".
 * The result will simply replace multiple textord nodes with a single
 * character in each value by a single textord node having multiple
 * characters in its value.  The representation is still ASCII source.
 *
 * @param {Array.<ParseNode>} group  the nodes of this group,
 *                                   list will be moified in place
 */
Parser.prototype.formLigatures = function(group) {
    var i;
    var n = group.length - 1;
    for (i = 0; i < n; ++i) {
        var a = group[i];
        var v = a.value;
        if (v === "-" && group[i + 1].value === "-") {
            if (i + 1 < n && group[i + 2].value === "-") {
                group.splice(i, 3, new ParseNode(
                    "textord", "---", "text", a, group[i + 2]));
                n -= 2;
            } else {
                group.splice(i, 2, new ParseNode(
                    "textord", "--", "text", a, group[i + 1]));
                n -= 1;
            }
        }
        if ((v === "'" || v === "`") && group[i + 1].value === v) {
            group.splice(i, 2, new ParseNode(
                "textord", v + v, "text", a, group[i + 1]));
            n -= 1;
        }
    }
};

/**
 * Parse a single symbol out of the string. Here, we handle both the functions
 * we have defined, as well as the single character symbols
 *
 * @return {?ParseFuncOrArgument}
 */
Parser.prototype.parseSymbol = function() {
    var nucleus = this.nextToken;

    if (functions[nucleus.text]) {
        this.consume();
        // If there exists a function with this name, we return the function and
        // say that it is a function.
        return new ParseFuncOrArgument(
            nucleus.text,
            true, nucleus);
    } else if (symbols[this.mode][nucleus.text]) {
        this.consume();
        // Otherwise if this is a no-argument function, find the type it
        // corresponds to in the symbols map
        return new ParseFuncOrArgument(
            new ParseNode(symbols[this.mode][nucleus.text].group,
                          nucleus.text, this.mode, nucleus),
            false, nucleus);
    } else if (this.mode === "text" && cjkRegex.test(nucleus.text)) {
        this.consume();
        return new ParseFuncOrArgument(
            new ParseNode("textord", nucleus.text, this.mode, nucleus),
            false, nucleus);
    } else {
        return null;
    }
};

Parser.prototype.ParseNode = ParseNode;

module.exports = Parser;

},{"./MacroExpander":93,"./ParseError":95,"./environments":105,"./functions":108,"./parseData":110,"./symbols":112,"./unicodeRegexes":113,"./utils":114}],97:[function(require,module,exports){
/**
 * This is a module for storing settings passed into KaTeX. It correctly handles
 * default settings.
 */

/**
 * Helper function for getting a default value if the value is undefined
 */
function get(option, defaultValue) {
    return option === undefined ? defaultValue : option;
}

/**
 * The main Settings object
 *
 * The current options stored are:
 *  - displayMode: Whether the expression should be typeset by default in
 *                 textstyle or displaystyle (default false)
 */
function Settings(options) {
    // allow null options
    options = options || {};
    this.displayMode = get(options.displayMode, false);
    this.throwOnError = get(options.throwOnError, true);
    this.errorColor = get(options.errorColor, "#cc0000");
    this.macros = options.macros || {};
}

module.exports = Settings;

},{}],98:[function(require,module,exports){
/**
 * This file contains information and classes for the various kinds of styles
 * used in TeX. It provides a generic `Style` class, which holds information
 * about a specific style. It then provides instances of all the different kinds
 * of styles possible, and provides functions to move between them and get
 * information about them.
 */

var sigmas = require("./fontMetrics.js").sigmas;

var metrics = [{}, {}, {}];
var i;
for (var key in sigmas) {
    if (sigmas.hasOwnProperty(key)) {
        for (i = 0; i < 3; i++) {
            metrics[i][key] = sigmas[key][i];
        }
    }
}
for (i = 0; i < 3; i++) {
    metrics[i].emPerEx = sigmas.xHeight[i] / sigmas.quad[i];
}

/**
 * The main style class. Contains a unique id for the style, a size (which is
 * the same for cramped and uncramped version of a style), a cramped flag, and a
 * size multiplier, which gives the size difference between a style and
 * textstyle.
 */
function Style(id, size, multiplier, cramped) {
    this.id = id;
    this.size = size;
    this.cramped = cramped;
    this.sizeMultiplier = multiplier;
    this.metrics = metrics[size > 0 ? size - 1 : 0];
}

/**
 * Get the style of a superscript given a base in the current style.
 */
Style.prototype.sup = function() {
    return styles[sup[this.id]];
};

/**
 * Get the style of a subscript given a base in the current style.
 */
Style.prototype.sub = function() {
    return styles[sub[this.id]];
};

/**
 * Get the style of a fraction numerator given the fraction in the current
 * style.
 */
Style.prototype.fracNum = function() {
    return styles[fracNum[this.id]];
};

/**
 * Get the style of a fraction denominator given the fraction in the current
 * style.
 */
Style.prototype.fracDen = function() {
    return styles[fracDen[this.id]];
};

/**
 * Get the cramped version of a style (in particular, cramping a cramped style
 * doesn't change the style).
 */
Style.prototype.cramp = function() {
    return styles[cramp[this.id]];
};

/**
 * HTML class name, like "displaystyle cramped"
 */
Style.prototype.cls = function() {
    return sizeNames[this.size] + (this.cramped ? " cramped" : " uncramped");
};

/**
 * HTML Reset class name, like "reset-textstyle"
 */
Style.prototype.reset = function() {
    return resetNames[this.size];
};

/**
 * Return if this style is tightly spaced (scriptstyle/scriptscriptstyle)
 */
Style.prototype.isTight = function() {
    return this.size >= 2;
};

// IDs of the different styles
var D = 0;
var Dc = 1;
var T = 2;
var Tc = 3;
var S = 4;
var Sc = 5;
var SS = 6;
var SSc = 7;

// String names for the different sizes
var sizeNames = [
    "displaystyle textstyle",
    "textstyle",
    "scriptstyle",
    "scriptscriptstyle"
];

// Reset names for the different sizes
var resetNames = [
    "reset-textstyle",
    "reset-textstyle",
    "reset-scriptstyle",
    "reset-scriptscriptstyle"
];

// Instances of the different styles
var styles = [
    new Style(D, 0, 1.0, false),
    new Style(Dc, 0, 1.0, true),
    new Style(T, 1, 1.0, false),
    new Style(Tc, 1, 1.0, true),
    new Style(S, 2, 0.7, false),
    new Style(Sc, 2, 0.7, true),
    new Style(SS, 3, 0.5, false),
    new Style(SSc, 3, 0.5, true)
];

// Lookup tables for switching from one style to another
var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];

// We only export some of the styles. Also, we don't export the `Style` class so
// no more styles can be generated.
module.exports = {
    DISPLAY: styles[D],
    TEXT: styles[T],
    SCRIPT: styles[S],
    SCRIPTSCRIPT: styles[SS]
};

},{"./fontMetrics.js":106}],99:[function(require,module,exports){
/* eslint no-console:0 */
/**
 * This module contains general functions that can be used for building
 * different kinds of domTree nodes in a consistent manner.
 */

var domTree = require("./domTree");
var fontMetrics = require("./fontMetrics");
var symbols = require("./symbols");
var utils = require("./utils");

var greekCapitals = [
    "\\Gamma",
    "\\Delta",
    "\\Theta",
    "\\Lambda",
    "\\Xi",
    "\\Pi",
    "\\Sigma",
    "\\Upsilon",
    "\\Phi",
    "\\Psi",
    "\\Omega"
];

// The following have to be loaded from Main-Italic font, using class mainit
var mainitLetters = [
    "\u0131",   // dotless i, \imath
    "\u0237",   // dotless j, \jmath
    "\u00a3"   // \pounds
];

/**
 * Makes a symbolNode after translation via the list of symbols in symbols.js.
 * Correctly pulls out metrics for the character, and optionally takes a list of
 * classes to be attached to the node.
 *
 * TODO: make argument order closer to makeSpan
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 */
var makeSymbol = function(value, fontFamily, mode, options, classes) {
    // Replace the value with its replaced value from symbol.js
    if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var metrics = fontMetrics.getCharacterMetrics(value, fontFamily);

    var symbolNode;
    if (metrics) {
        var italic = metrics.italic;
        if (mode === "text") {
            italic = 0;
        }
        symbolNode = new domTree.symbolNode(
            value, metrics.height, metrics.depth, italic, metrics.skew,
            classes);
    } else {
        // TODO(emily): Figure out a good way to only print this in development
        typeof console !== "undefined" && console.warn(
            "No character metrics for '" + value + "' in style '" +
                fontFamily + "'");
        symbolNode = new domTree.symbolNode(value, 0, 0, 0, 0, classes);
    }

    if (options) {
        if (options.style.isTight()) {
            symbolNode.classes.push("mtight");
        }
        if (options.getColor()) {
            symbolNode.style.color = options.getColor();
        }
    }

    return symbolNode;
};

/**
 * Makes a symbol in Main-Regular or AMS-Regular.
 * Used for rel, bin, open, close, inner, and punct.
 */
var mathsym = function(value, mode, options, classes) {
    // Decide what font to render the symbol in by its entry in the symbols
    // table.
    // Have a special case for when the value = \ because the \ is used as a
    // textord in unsupported command errors but cannot be parsed as a regular
    // text ordinal and is therefore not present as a symbol in the symbols
    // table for text
    if (value === "\\" || symbols[mode][value].font === "main") {
        return makeSymbol(value, "Main-Regular", mode, options, classes);
    } else {
        return makeSymbol(
            value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
    }
};

/**
 * Makes a symbol in the default font for mathords and textords.
 */
var mathDefault = function(value, mode, options, classes, type) {
    if (type === "mathord") {
        return mathit(value, mode, options, classes);
    } else if (type === "textord") {
        return makeSymbol(
            value, "Main-Regular", mode, options, classes.concat(["mathrm"]));
    } else {
        throw new Error("unexpected type: " + type + " in mathDefault");
    }
};

/**
 * Makes a symbol in the italic math font.
 */
var mathit = function(value, mode, options, classes) {
    if (/[0-9]/.test(value.charAt(0)) ||
            // glyphs for \imath and \jmath do not exist in Math-Italic so we
            // need to use Main-Italic instead
            utils.contains(mainitLetters, value) ||
            utils.contains(greekCapitals, value)) {
        return makeSymbol(
            value, "Main-Italic", mode, options, classes.concat(["mainit"]));
    } else {
        return makeSymbol(
            value, "Math-Italic", mode, options, classes.concat(["mathit"]));
    }
};

/**
 * Makes either a mathord or textord in the correct font and color.
 */
var makeOrd = function(group, options, type) {
    var mode = group.mode;
    var value = group.value;
    if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var classes = ["mord"];

    var font = options.font;
    if (font) {
        if (font === "mathit" || utils.contains(mainitLetters, value)) {
            return mathit(value, mode, options, classes);
        } else {
            var fontName = fontMap[font].fontName;
            if (fontMetrics.getCharacterMetrics(value, fontName)) {
                return makeSymbol(
                    value, fontName, mode, options, classes.concat([font]));
            } else {
                return mathDefault(value, mode, options, classes, type);
            }
        }
    } else {
        return mathDefault(value, mode, options, classes, type);
    }
};

/**
 * Calculate the height, depth, and maxFontSize of an element based on its
 * children.
 */
var sizeElementFromChildren = function(elem) {
    var height = 0;
    var depth = 0;
    var maxFontSize = 0;

    if (elem.children) {
        for (var i = 0; i < elem.children.length; i++) {
            if (elem.children[i].height > height) {
                height = elem.children[i].height;
            }
            if (elem.children[i].depth > depth) {
                depth = elem.children[i].depth;
            }
            if (elem.children[i].maxFontSize > maxFontSize) {
                maxFontSize = elem.children[i].maxFontSize;
            }
        }
    }

    elem.height = height;
    elem.depth = depth;
    elem.maxFontSize = maxFontSize;
};

/**
 * Makes a span with the given list of classes, list of children, and options.
 *
 * TODO: Ensure that `options` is always provided (currently some call sites
 * don't pass it).
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 */
var makeSpan = function(classes, children, options) {
    var span = new domTree.span(classes, children, options);

    sizeElementFromChildren(span);

    return span;
};

/**
 * Prepends the given children to the given span, updating height, depth, and
 * maxFontSize.
 */
var prependChildren = function(span, children) {
    span.children = children.concat(span.children);

    sizeElementFromChildren(span);
};

/**
 * Makes a document fragment with the given list of children.
 */
var makeFragment = function(children) {
    var fragment = new domTree.documentFragment(children);

    sizeElementFromChildren(fragment);

    return fragment;
};

/**
 * Makes an element placed in each of the vlist elements to ensure that each
 * element has the same max font size. To do this, we create a zero-width space
 * with the correct font size.
 */
var makeFontSizer = function(options, fontSize) {
    var fontSizeInner = makeSpan([], [new domTree.symbolNode("\u200b")]);
    fontSizeInner.style.fontSize =
        (fontSize / options.style.sizeMultiplier) + "em";

    var fontSizer = makeSpan(
        ["fontsize-ensurer", "reset-" + options.size, "size5"],
        [fontSizeInner]);

    return fontSizer;
};

/**
 * Makes a vertical list by stacking elements and kerns on top of each other.
 * Allows for many different ways of specifying the positioning method.
 *
 * Arguments:
 *  - children: A list of child or kern nodes to be stacked on top of each other
 *              (i.e. the first element will be at the bottom, and the last at
 *              the top). Element nodes are specified as
 *                {type: "elem", elem: node}
 *              while kern nodes are specified as
 *                {type: "kern", size: size}
 *  - positionType: The method by which the vlist should be positioned. Valid
 *                  values are:
 *                   - "individualShift": The children list only contains elem
 *                                        nodes, and each node contains an extra
 *                                        "shift" value of how much it should be
 *                                        shifted (note that shifting is always
 *                                        moving downwards). positionData is
 *                                        ignored.
 *                   - "top": The positionData specifies the topmost point of
 *                            the vlist (note this is expected to be a height,
 *                            so positive values move up)
 *                   - "bottom": The positionData specifies the bottommost point
 *                               of the vlist (note this is expected to be a
 *                               depth, so positive values move down
 *                   - "shift": The vlist will be positioned such that its
 *                              baseline is positionData away from the baseline
 *                              of the first child. Positive values move
 *                              downwards.
 *                   - "firstBaseline": The vlist will be positioned such that
 *                                      its baseline is aligned with the
 *                                      baseline of the first child.
 *                                      positionData is ignored. (this is
 *                                      equivalent to "shift" with
 *                                      positionData=0)
 *  - positionData: Data used in different ways depending on positionType
 *  - options: An Options object
 *
 */
var makeVList = function(children, positionType, positionData, options) {
    var depth;
    var currPos;
    var i;
    if (positionType === "individualShift") {
        var oldChildren = children;
        children = [oldChildren[0]];

        // Add in kerns to the list of children to get each element to be
        // shifted to the correct specified shift
        depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
        currPos = depth;
        for (i = 1; i < oldChildren.length; i++) {
            var diff = -oldChildren[i].shift - currPos -
                oldChildren[i].elem.depth;
            var size = diff -
                (oldChildren[i - 1].elem.height +
                 oldChildren[i - 1].elem.depth);

            currPos = currPos + diff;

            children.push({type: "kern", size: size});
            children.push(oldChildren[i]);
        }
    } else if (positionType === "top") {
        // We always start at the bottom, so calculate the bottom by adding up
        // all the sizes
        var bottom = positionData;
        for (i = 0; i < children.length; i++) {
            if (children[i].type === "kern") {
                bottom -= children[i].size;
            } else {
                bottom -= children[i].elem.height + children[i].elem.depth;
            }
        }
        depth = bottom;
    } else if (positionType === "bottom") {
        depth = -positionData;
    } else if (positionType === "shift") {
        depth = -children[0].elem.depth - positionData;
    } else if (positionType === "firstBaseline") {
        depth = -children[0].elem.depth;
    } else {
        depth = 0;
    }

    // Make the fontSizer
    var maxFontSize = 0;
    for (i = 0; i < children.length; i++) {
        if (children[i].type === "elem") {
            maxFontSize = Math.max(maxFontSize, children[i].elem.maxFontSize);
        }
    }
    var fontSizer = makeFontSizer(options, maxFontSize);

    // Create a new list of actual children at the correct offsets
    var realChildren = [];
    currPos = depth;
    for (i = 0; i < children.length; i++) {
        if (children[i].type === "kern") {
            currPos += children[i].size;
        } else {
            var child = children[i].elem;

            var shift = -child.depth - currPos;
            currPos += child.height + child.depth;

            var childWrap = makeSpan([], [fontSizer, child]);
            childWrap.height -= shift;
            childWrap.depth += shift;
            childWrap.style.top = shift + "em";

            realChildren.push(childWrap);
        }
    }

    // Add in an element at the end with no offset to fix the calculation of
    // baselines in some browsers (namely IE, sometimes safari)
    var baselineFix = makeSpan(
        ["baseline-fix"], [fontSizer, new domTree.symbolNode("\u200b")]);
    realChildren.push(baselineFix);

    var vlist = makeSpan(["vlist"], realChildren);
    // Fix the final height and depth, in case there were kerns at the ends
    // since the makeSpan calculation won't take that in to account.
    vlist.height = Math.max(currPos, vlist.height);
    vlist.depth = Math.max(-depth, vlist.depth);
    return vlist;
};

// A table of size -> font size for the different sizing functions
var sizingMultiplier = {
    size1: 0.5,
    size2: 0.7,
    size3: 0.8,
    size4: 0.9,
    size5: 1.0,
    size6: 1.2,
    size7: 1.44,
    size8: 1.73,
    size9: 2.07,
    size10: 2.49
};

// A map of spacing functions to their attributes, like size and corresponding
// CSS class
var spacingFunctions = {
    "\\qquad": {
        size: "2em",
        className: "qquad"
    },
    "\\quad": {
        size: "1em",
        className: "quad"
    },
    "\\enspace": {
        size: "0.5em",
        className: "enspace"
    },
    "\\;": {
        size: "0.277778em",
        className: "thickspace"
    },
    "\\:": {
        size: "0.22222em",
        className: "mediumspace"
    },
    "\\,": {
        size: "0.16667em",
        className: "thinspace"
    },
    "\\!": {
        size: "-0.16667em",
        className: "negativethinspace"
    }
};

/**
 * Maps TeX font commands to objects containing:
 * - variant: string used for "mathvariant" attribute in buildMathML.js
 * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
 */
// A map between tex font commands an MathML mathvariant attribute values
var fontMap = {
    // styles
    "mathbf": {
        variant: "bold",
        fontName: "Main-Bold"
    },
    "mathrm": {
        variant: "normal",
        fontName: "Main-Regular"
    },
    "textit": {
        variant: "italic",
        fontName: "Main-Italic"
    },

    // "mathit" is missing because it requires the use of two fonts: Main-Italic
    // and Math-Italic.  This is handled by a special case in makeOrd which ends
    // up calling mathit.

    // families
    "mathbb": {
        variant: "double-struck",
        fontName: "AMS-Regular"
    },
    "mathcal": {
        variant: "script",
        fontName: "Caligraphic-Regular"
    },
    "mathfrak": {
        variant: "fraktur",
        fontName: "Fraktur-Regular"
    },
    "mathscr": {
        variant: "script",
        fontName: "Script-Regular"
    },
    "mathsf": {
        variant: "sans-serif",
        fontName: "SansSerif-Regular"
    },
    "mathtt": {
        variant: "monospace",
        fontName: "Typewriter-Regular"
    }
};

module.exports = {
    fontMap: fontMap,
    makeSymbol: makeSymbol,
    mathsym: mathsym,
    makeSpan: makeSpan,
    makeFragment: makeFragment,
    makeVList: makeVList,
    makeOrd: makeOrd,
    prependChildren: prependChildren,
    sizingMultiplier: sizingMultiplier,
    spacingFunctions: spacingFunctions
};

},{"./domTree":104,"./fontMetrics":106,"./symbols":112,"./utils":114}],100:[function(require,module,exports){
/* eslint no-console:0 */
/**
 * This file does the main work of building a domTree structure from a parse
 * tree. The entry point is the `buildHTML` function, which takes a parse tree.
 * Then, the buildExpression, buildGroup, and various groupTypes functions are
 * called, to produce a final HTML tree.
 */

var ParseError = require("./ParseError");
var Style = require("./Style");

var buildCommon = require("./buildCommon");
var delimiter = require("./delimiter");
var domTree = require("./domTree");
var fontMetrics = require("./fontMetrics");
var utils = require("./utils");

var makeSpan = buildCommon.makeSpan;

var isSpace = function(node) {
    return node instanceof domTree.span && node.classes[0] === "mspace";
};

// Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)
// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,
// and the text before Rule 19.

var isBin = function(node) {
    return node && node.classes[0] === "mbin";
};

var isBinLeftCanceller = function(node, isRealGroup) {
    // TODO: This code assumes that a node's math class is the first element
    // of its `classes` array. A later cleanup should ensure this, for
    // instance by changing the signature of `makeSpan`.
    if (node) {
        return utils.contains(["mbin", "mopen", "mrel", "mop", "mpunct"],
                              node.classes[0]);
    } else {
        return isRealGroup;
    }
};

var isBinRightCanceller = function(node, isRealGroup) {
    if (node) {
        return utils.contains(["mrel", "mclose", "mpunct"], node.classes[0]);
    } else {
        return isRealGroup;
    }
};

/**
 * Take a list of nodes, build them in order, and return a list of the built
 * nodes. documentFragments are flattened into their contents, so the
 * returned list contains no fragments. `isRealGroup` is true if `expression`
 * is a real group (no atoms will be added on either side), as opposed to
 * a partial group (e.g. one created by \color).
 */
var buildExpression = function(expression, options, isRealGroup) {
    // Parse expressions into `groups`.
    var groups = [];
    for (var i = 0; i < expression.length; i++) {
        var group = expression[i];
        var output = buildGroup(group, options);
        if (output instanceof domTree.documentFragment) {
            Array.prototype.push.apply(groups, output.children);
        } else {
            groups.push(output);
        }
    }
    // At this point `groups` consists entirely of `symbolNode`s and `span`s.

    // Explicit spaces (e.g., \;, \,) should be ignored with respect to atom
    // spacing (e.g., "add thick space between mord and mrel"). Since CSS
    // adjacency rules implement atom spacing, spaces should be invisible to
    // CSS. So we splice them out of `groups` and into the atoms themselves.
    var spaces = null;
    for (i = 0; i < groups.length; i++) {
        if (isSpace(groups[i])) {
            spaces = spaces || [];
            spaces.push(groups[i]);
            groups.splice(i, 1);
            i--;
        } else if (spaces) {
            if (groups[i] instanceof domTree.symbolNode) {
                groups[i] = makeSpan([].concat(groups[i].classes), [groups[i]]);
            }
            buildCommon.prependChildren(groups[i], spaces);
            spaces = null;
        }
    }
    if (spaces) {
        Array.prototype.push.apply(groups, spaces);
    }

    // Binary operators change to ordinary symbols in some contexts.
    for (i = 0; i < groups.length; i++) {
        if (isBin(groups[i])
            && (isBinLeftCanceller(groups[i - 1], isRealGroup)
                || isBinRightCanceller(groups[i + 1], isRealGroup))) {
            groups[i].classes[0] = "mord";
        }
    }

    return groups;
};

// Return math atom class (mclass) of a domTree.
var getTypeOfDomTree = function(node) {
    if (node instanceof domTree.documentFragment) {
        if (node.children.length) {
            return getTypeOfDomTree(
                node.children[node.children.length - 1]);
        }
    } else {
        if (utils.contains(["mord", "mop", "mbin", "mrel", "mopen", "mclose",
            "mpunct", "minner"], node.classes[0])) {
            return node.classes[0];
        }
    }
    return null;
};

/**
 * Sometimes, groups perform special rules when they have superscripts or
 * subscripts attached to them. This function lets the `supsub` group know that
 * its inner element should handle the superscripts and subscripts instead of
 * handling them itself.
 */
var shouldHandleSupSub = function(group, options) {
    if (!group) {
        return false;
    } else if (group.type === "op") {
        // Operators handle supsubs differently when they have limits
        // (e.g. `\displaystyle\sum_2^3`)
        return group.value.limits &&
            (options.style.size === Style.DISPLAY.size ||
            group.value.alwaysHandleSupSub);
    } else if (group.type === "accent") {
        return isCharacterBox(group.value.base);
    } else {
        return null;
    }
};

/**
 * Sometimes we want to pull out the innermost element of a group. In most
 * cases, this will just be the group itself, but when ordgroups and colors have
 * a single element, we want to pull that out.
 */
var getBaseElem = function(group) {
    if (!group) {
        return false;
    } else if (group.type === "ordgroup") {
        if (group.value.length === 1) {
            return getBaseElem(group.value[0]);
        } else {
            return group;
        }
    } else if (group.type === "color") {
        if (group.value.value.length === 1) {
            return getBaseElem(group.value.value[0]);
        } else {
            return group;
        }
    } else if (group.type === "font") {
        return getBaseElem(group.value.body);
    } else {
        return group;
    }
};

/**
 * TeXbook algorithms often reference "character boxes", which are simply groups
 * with a single character in them. To decide if something is a character box,
 * we find its innermost group, and see if it is a single character.
 */
var isCharacterBox = function(group) {
    var baseElem = getBaseElem(group);

    // These are all they types of groups which hold single characters
    return baseElem.type === "mathord" ||
        baseElem.type === "textord" ||
        baseElem.type === "bin" ||
        baseElem.type === "rel" ||
        baseElem.type === "inner" ||
        baseElem.type === "open" ||
        baseElem.type === "close" ||
        baseElem.type === "punct";
};

var makeNullDelimiter = function(options, classes) {
    return makeSpan(classes.concat([
        "sizing", "reset-" + options.size, "size5",
        options.style.reset(), Style.TEXT.cls(),
        "nulldelimiter"]));
};

/**
 * This is a map of group types to the function used to handle that type.
 * Simpler types come at the beginning, while complicated types come afterwards.
 */
var groupTypes = {};

groupTypes.mathord = function(group, options) {
    return buildCommon.makeOrd(group, options, "mathord");
};

groupTypes.textord = function(group, options) {
    return buildCommon.makeOrd(group, options, "textord");
};

groupTypes.bin = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mbin"]);
};

groupTypes.rel = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mrel"]);
};

groupTypes.open = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mopen"]);
};

groupTypes.close = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mclose"]);
};

groupTypes.inner = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["minner"]);
};

groupTypes.punct = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mpunct"]);
};

groupTypes.ordgroup = function(group, options) {
    return makeSpan(
        ["mord", options.style.cls()],
        buildExpression(group.value, options.reset(), true),
        options
    );
};

groupTypes.text = function(group, options) {
    var newOptions = options.withFont(group.value.style);
    var inner = buildExpression(group.value.body, newOptions, true);
    for (var i = 0; i < inner.length - 1; i++) {
        if (inner[i].tryCombine(inner[i + 1])) {
            inner.splice(i + 1, 1);
            i--;
        }
    }
    return makeSpan(["mord", "text", newOptions.style.cls()],
        inner, newOptions);
};

groupTypes.color = function(group, options) {
    var elements = buildExpression(
        group.value.value,
        options.withColor(group.value.color),
        false
    );

    // \color isn't supposed to affect the type of the elements it contains.
    // To accomplish this, we wrap the results in a fragment, so the inner
    // elements will be able to directly interact with their neighbors. For
    // example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`
    return new buildCommon.makeFragment(elements);
};

groupTypes.supsub = function(group, options) {
    // Superscript and subscripts are handled in the TeXbook on page
    // 445-446, rules 18(a-f).

    // Here is where we defer to the inner group if it should handle
    // superscripts and subscripts itself.
    if (shouldHandleSupSub(group.value.base, options)) {
        return groupTypes[group.value.base.type](group, options);
    }

    var base = buildGroup(group.value.base, options.reset());
    var supmid;
    var submid;
    var sup;
    var sub;

    var style = options.style;
    var newOptions;

    if (group.value.sup) {
        newOptions = options.withStyle(style.sup());
        sup = buildGroup(group.value.sup, newOptions);
        supmid = makeSpan([style.reset(), style.sup().cls()],
            [sup], newOptions);
    }

    if (group.value.sub) {
        newOptions = options.withStyle(style.sub());
        sub = buildGroup(group.value.sub, newOptions);
        submid = makeSpan([style.reset(), style.sub().cls()],
            [sub], newOptions);
    }

    // Rule 18a
    var supShift;
    var subShift;
    if (isCharacterBox(group.value.base)) {
        supShift = 0;
        subShift = 0;
    } else {
        supShift = base.height - style.metrics.supDrop;
        subShift = base.depth + style.metrics.subDrop;
    }

    // Rule 18c
    var minSupShift;
    if (style === Style.DISPLAY) {
        minSupShift = style.metrics.sup1;
    } else if (style.cramped) {
        minSupShift = style.metrics.sup3;
    } else {
        minSupShift = style.metrics.sup2;
    }

    // scriptspace is a font-size-independent size, so scale it
    // appropriately
    var multiplier = Style.TEXT.sizeMultiplier *
            style.sizeMultiplier;
    var scriptspace =
        (0.5 / fontMetrics.metrics.ptPerEm) / multiplier + "em";

    var supsub;
    if (!group.value.sup) {
        // Rule 18b
        subShift = Math.max(
            subShift, style.metrics.sub1,
            sub.height - 0.8 * style.metrics.xHeight);

        supsub = buildCommon.makeVList([
            {type: "elem", elem: submid}
        ], "shift", subShift, options);

        supsub.children[0].style.marginRight = scriptspace;

        // Subscripts shouldn't be shifted by the base's italic correction.
        // Account for that by shifting the subscript back the appropriate
        // amount. Note we only do this when the base is a single symbol.
        if (base instanceof domTree.symbolNode) {
            supsub.children[0].style.marginLeft = -base.italic + "em";
        }
    } else if (!group.value.sub) {
        // Rule 18c, d
        supShift = Math.max(supShift, minSupShift,
            sup.depth + 0.25 * style.metrics.xHeight);

        supsub = buildCommon.makeVList([
            {type: "elem", elem: supmid}
        ], "shift", -supShift, options);

        supsub.children[0].style.marginRight = scriptspace;
    } else {
        supShift = Math.max(
            supShift, minSupShift, sup.depth + 0.25 * style.metrics.xHeight);
        subShift = Math.max(subShift, style.metrics.sub2);

        var ruleWidth = fontMetrics.metrics.defaultRuleThickness;

        // Rule 18e
        if ((supShift - sup.depth) - (sub.height - subShift) <
                4 * ruleWidth) {
            subShift = 4 * ruleWidth - (supShift - sup.depth) + sub.height;
            var psi = 0.8 * style.metrics.xHeight - (supShift - sup.depth);
            if (psi > 0) {
                supShift += psi;
                subShift -= psi;
            }
        }

        supsub = buildCommon.makeVList([
            {type: "elem", elem: submid, shift: subShift},
            {type: "elem", elem: supmid, shift: -supShift}
        ], "individualShift", null, options);

        // See comment above about subscripts not being shifted
        if (base instanceof domTree.symbolNode) {
            supsub.children[0].style.marginLeft = -base.italic + "em";
        }

        supsub.children[0].style.marginRight = scriptspace;
        supsub.children[1].style.marginRight = scriptspace;
    }

    // We ensure to wrap the supsub vlist in a span.msupsub to reset text-align
    var mclass = getTypeOfDomTree(base) || "mord";
    return makeSpan([mclass],
        [base, makeSpan(["msupsub"], [supsub])],
        options);
};

groupTypes.genfrac = function(group, options) {
    // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
    // Figure out what style this fraction should be in based on the
    // function used
    var style = options.style;
    if (group.value.size === "display") {
        style = Style.DISPLAY;
    } else if (group.value.size === "text") {
        style = Style.TEXT;
    }

    var nstyle = style.fracNum();
    var dstyle = style.fracDen();
    var newOptions;

    newOptions = options.withStyle(nstyle);
    var numer = buildGroup(group.value.numer, newOptions);
    var numerreset = makeSpan([style.reset(), nstyle.cls()],
        [numer], newOptions);

    newOptions = options.withStyle(dstyle);
    var denom = buildGroup(group.value.denom, newOptions);
    var denomreset = makeSpan([style.reset(), dstyle.cls()],
        [denom], newOptions);

    var ruleWidth;
    if (group.value.hasBarLine) {
        ruleWidth = fontMetrics.metrics.defaultRuleThickness /
            options.style.sizeMultiplier;
    } else {
        ruleWidth = 0;
    }

    // Rule 15b
    var numShift;
    var clearance;
    var denomShift;
    if (style.size === Style.DISPLAY.size) {
        numShift = style.metrics.num1;
        if (ruleWidth > 0) {
            clearance = 3 * ruleWidth;
        } else {
            clearance = 7 * fontMetrics.metrics.defaultRuleThickness;
        }
        denomShift = style.metrics.denom1;
    } else {
        if (ruleWidth > 0) {
            numShift = style.metrics.num2;
            clearance = ruleWidth;
        } else {
            numShift = style.metrics.num3;
            clearance = 3 * fontMetrics.metrics.defaultRuleThickness;
        }
        denomShift = style.metrics.denom2;
    }

    var frac;
    if (ruleWidth === 0) {
        // Rule 15c
        var candidateClearance =
            (numShift - numer.depth) - (denom.height - denomShift);
        if (candidateClearance < clearance) {
            numShift += 0.5 * (clearance - candidateClearance);
            denomShift += 0.5 * (clearance - candidateClearance);
        }

        frac = buildCommon.makeVList([
            {type: "elem", elem: denomreset, shift: denomShift},
            {type: "elem", elem: numerreset, shift: -numShift}
        ], "individualShift", null, options);
    } else {
        // Rule 15d
        var axisHeight = style.metrics.axisHeight;

        if ((numShift - numer.depth) - (axisHeight + 0.5 * ruleWidth) <
                clearance) {
            numShift +=
                clearance - ((numShift - numer.depth) -
                             (axisHeight + 0.5 * ruleWidth));
        }

        if ((axisHeight - 0.5 * ruleWidth) - (denom.height - denomShift) <
                clearance) {
            denomShift +=
                clearance - ((axisHeight - 0.5 * ruleWidth) -
                             (denom.height - denomShift));
        }

        var mid = makeSpan(
            [options.style.reset(), Style.TEXT.cls(), "frac-line"]);
        // Manually set the height of the line because its height is
        // created in CSS
        mid.height = ruleWidth;

        var midShift = -(axisHeight - 0.5 * ruleWidth);

        frac = buildCommon.makeVList([
            {type: "elem", elem: denomreset, shift: denomShift},
            {type: "elem", elem: mid,        shift: midShift},
            {type: "elem", elem: numerreset, shift: -numShift}
        ], "individualShift", null, options);
    }

    // Since we manually change the style sometimes (with \dfrac or \tfrac),
    // account for the possible size change here.
    frac.height *= style.sizeMultiplier / options.style.sizeMultiplier;
    frac.depth *= style.sizeMultiplier / options.style.sizeMultiplier;

    // Rule 15e
    var delimSize;
    if (style.size === Style.DISPLAY.size) {
        delimSize = style.metrics.delim1;
    } else {
        delimSize = style.metrics.delim2;
    }

    var leftDelim;
    var rightDelim;
    if (group.value.leftDelim == null) {
        leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
        leftDelim = delimiter.customSizedDelim(
            group.value.leftDelim, delimSize, true,
            options.withStyle(style), group.mode, ["mopen"]);
    }
    if (group.value.rightDelim == null) {
        rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
        rightDelim = delimiter.customSizedDelim(
            group.value.rightDelim, delimSize, true,
            options.withStyle(style), group.mode, ["mclose"]);
    }

    return makeSpan(
        ["mord", options.style.reset(), style.cls()],
        [leftDelim, makeSpan(["mfrac"], [frac]), rightDelim],
        options);
};

var calculateSize = function(sizeValue, style) {
    var x = sizeValue.number;
    if (sizeValue.unit === "ex") {
        x *= style.metrics.emPerEx;
    } else if (sizeValue.unit === "mu") {
        x /= 18;
    }
    return x;
};

groupTypes.array = function(group, options) {
    var r;
    var c;
    var nr = group.value.body.length;
    var nc = 0;
    var body = new Array(nr);

    var style = options.style;

    // Horizontal spacing
    var pt = 1 / fontMetrics.metrics.ptPerEm;
    var arraycolsep = 5 * pt; // \arraycolsep in article.cls

    // Vertical spacing
    var baselineskip = 12 * pt; // see size10.clo
    // Default \arraystretch from lttab.dtx
    // TODO(gagern): may get redefined once we have user-defined macros
    var arraystretch = utils.deflt(group.value.arraystretch, 1);
    var arrayskip = arraystretch * baselineskip;
    var arstrutHeight = 0.7 * arrayskip; // \strutbox in ltfsstrc.dtx and
    var arstrutDepth = 0.3 * arrayskip;  // \@arstrutbox in lttab.dtx

    var totalHeight = 0;
    for (r = 0; r < group.value.body.length; ++r) {
        var inrow = group.value.body[r];
        var height = arstrutHeight; // \@array adds an \@arstrut
        var depth = arstrutDepth;   // to each tow (via the template)

        if (nc < inrow.length) {
            nc = inrow.length;
        }

        var outrow = new Array(inrow.length);
        for (c = 0; c < inrow.length; ++c) {
            var elt = buildGroup(inrow[c], options);
            if (depth < elt.depth) {
                depth = elt.depth;
            }
            if (height < elt.height) {
                height = elt.height;
            }
            outrow[c] = elt;
        }

        var gap = 0;
        if (group.value.rowGaps[r]) {
            gap = calculateSize(group.value.rowGaps[r].value, style);
            if (gap > 0) { // \@argarraycr
                gap += arstrutDepth;
                if (depth < gap) {
                    depth = gap; // \@xargarraycr
                }
                gap = 0;
            }
        }

        outrow.height = height;
        outrow.depth = depth;
        totalHeight += height;
        outrow.pos = totalHeight;
        totalHeight += depth + gap; // \@yargarraycr
        body[r] = outrow;
    }

    var offset = totalHeight / 2 + style.metrics.axisHeight;
    var colDescriptions = group.value.cols || [];
    var cols = [];
    var colSep;
    var colDescrNum;
    for (c = 0, colDescrNum = 0;
         // Continue while either there are more columns or more column
         // descriptions, so trailing separators don't get lost.
         c < nc || colDescrNum < colDescriptions.length;
         ++c, ++colDescrNum) {

        var colDescr = colDescriptions[colDescrNum] || {};

        var firstSeparator = true;
        while (colDescr.type === "separator") {
            // If there is more than one separator in a row, add a space
            // between them.
            if (!firstSeparator) {
                colSep = makeSpan(["arraycolsep"], []);
                colSep.style.width =
                    fontMetrics.metrics.doubleRuleSep + "em";
                cols.push(colSep);
            }

            if (colDescr.separator === "|") {
                var separator = makeSpan(
                    ["vertical-separator"],
                    []);
                separator.style.height = totalHeight + "em";
                separator.style.verticalAlign =
                    -(totalHeight - offset) + "em";

                cols.push(separator);
            } else {
                throw new ParseError(
                    "Invalid separator type: " + colDescr.separator);
            }

            colDescrNum++;
            colDescr = colDescriptions[colDescrNum] || {};
            firstSeparator = false;
        }

        if (c >= nc) {
            continue;
        }

        var sepwidth;
        if (c > 0 || group.value.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
            if (sepwidth !== 0) {
                colSep = makeSpan(["arraycolsep"], []);
                colSep.style.width = sepwidth + "em";
                cols.push(colSep);
            }
        }

        var col = [];
        for (r = 0; r < nr; ++r) {
            var row = body[r];
            var elem = row[c];
            if (!elem) {
                continue;
            }
            var shift = row.pos - offset;
            elem.depth = row.depth;
            elem.height = row.height;
            col.push({type: "elem", elem: elem, shift: shift});
        }

        col = buildCommon.makeVList(col, "individualShift", null, options);
        col = makeSpan(
            ["col-align-" + (colDescr.align || "c")],
            [col]);
        cols.push(col);

        if (c < nc - 1 || group.value.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
            if (sepwidth !== 0) {
                colSep = makeSpan(["arraycolsep"], []);
                colSep.style.width = sepwidth + "em";
                cols.push(colSep);
            }
        }
    }
    body = makeSpan(["mtable"], cols);
    return makeSpan(["mord"], [body], options);
};

groupTypes.spacing = function(group, options) {
    if (group.value === "\\ " || group.value === "\\space" ||
        group.value === " " || group.value === "~") {
        // Spaces are generated by adding an actual space. Each of these
        // things has an entry in the symbols table, so these will be turned
        // into appropriate outputs.
        if (group.mode === "text") {
            return buildCommon.makeOrd(group, options, "textord");
        } else {
            return makeSpan(["mspace"],
                [buildCommon.mathsym(group.value, group.mode, options)],
                options);
        }
    } else {
        // Other kinds of spaces are of arbitrary width. We use CSS to
        // generate these.
        return makeSpan(
            ["mspace",
                buildCommon.spacingFunctions[group.value].className],
            [], options);
    }
};

groupTypes.llap = function(group, options) {
    var inner = makeSpan(
        ["inner"], [buildGroup(group.value.body, options.reset())]);
    var fix = makeSpan(["fix"], []);
    return makeSpan(
        ["mord", "llap", options.style.cls()], [inner, fix], options);
};

groupTypes.rlap = function(group, options) {
    var inner = makeSpan(
        ["inner"], [buildGroup(group.value.body, options.reset())]);
    var fix = makeSpan(["fix"], []);
    return makeSpan(
        ["mord", "rlap", options.style.cls()], [inner, fix], options);
};

groupTypes.op = function(group, options) {
    // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
    var supGroup;
    var subGroup;
    var hasLimits = false;
    if (group.type === "supsub") {
        // If we have limits, supsub will pass us its group to handle. Pull
        // out the superscript and subscript and set the group to the op in
        // its base.
        supGroup = group.value.sup;
        subGroup = group.value.sub;
        group = group.value.base;
        hasLimits = true;
    }

    var style = options.style;

    // Most operators have a large successor symbol, but these don't.
    var noSuccessor = [
        "\\smallint"
    ];

    var large = false;
    if (style.size === Style.DISPLAY.size &&
        group.value.symbol &&
        !utils.contains(noSuccessor, group.value.body)) {

        // Most symbol operators get larger in displaystyle (rule 13)
        large = true;
    }

    var base;
    var baseShift = 0;
    var slant = 0;
    if (group.value.symbol) {
        // If this is a symbol, create the symbol.
        var fontName = large ? "Size2-Regular" : "Size1-Regular";
        base = buildCommon.makeSymbol(
            group.value.body, fontName, "math", options,
            ["mop", "op-symbol", large ? "large-op" : "small-op"]);

        // Shift the symbol so its center lies on the axis (rule 13). It
        // appears that our fonts have the centers of the symbols already
        // almost on the axis, so these numbers are very small. Note we
        // don't actually apply this here, but instead it is used either in
        // the vlist creation or separately when there are no limits.
        baseShift = (base.height - base.depth) / 2 -
            style.metrics.axisHeight * style.sizeMultiplier;

        // The slant of the symbol is just its italic correction.
        slant = base.italic;
    } else if (group.value.value) {
        // If this is a list, compose that list.
        var inner = buildExpression(group.value.value, options, true);

        base = makeSpan(["mop"], inner, options);
    } else {
        // Otherwise, this is a text operator. Build the text from the
        // operator's name.
        // TODO(emily): Add a space in the middle of some of these
        // operators, like \limsup
        var output = [];
        for (var i = 1; i < group.value.body.length; i++) {
            output.push(buildCommon.mathsym(group.value.body[i], group.mode));
        }
        base = makeSpan(["mop"], output, options);
    }

    if (hasLimits) {
        // IE 8 clips \int if it is in a display: inline-block. We wrap it
        // in a new span so it is an inline, and works.
        base = makeSpan([], [base]);

        var supmid;
        var supKern;
        var submid;
        var subKern;
        var newOptions;
        // We manually have to handle the superscripts and subscripts. This,
        // aside from the kern calculations, is copied from supsub.
        if (supGroup) {
            newOptions = options.withStyle(style.sup());
            var sup = buildGroup(supGroup, newOptions);
            supmid = makeSpan([style.reset(), style.sup().cls()],
                [sup], newOptions);

            supKern = Math.max(
                fontMetrics.metrics.bigOpSpacing1,
                fontMetrics.metrics.bigOpSpacing3 - sup.depth);
        }

        if (subGroup) {
            newOptions = options.withStyle(style.sub());
            var sub = buildGroup(subGroup, newOptions);
            submid = makeSpan([style.reset(), style.sub().cls()],
                [sub], newOptions);

            subKern = Math.max(
                fontMetrics.metrics.bigOpSpacing2,
                fontMetrics.metrics.bigOpSpacing4 - sub.height);
        }

        // Build the final group as a vlist of the possible subscript, base,
        // and possible superscript.
        var finalGroup;
        var top;
        var bottom;
        if (!supGroup) {
            top = base.height - baseShift;

            finalGroup = buildCommon.makeVList([
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5},
                {type: "elem", elem: submid},
                {type: "kern", size: subKern},
                {type: "elem", elem: base}
            ], "top", top, options);

            // Here, we shift the limits by the slant of the symbol. Note
            // that we are supposed to shift the limits by 1/2 of the slant,
            // but since we are centering the limits adding a full slant of
            // margin will shift by 1/2 that.
            finalGroup.children[0].style.marginLeft = -slant + "em";
        } else if (!subGroup) {
            bottom = base.depth + baseShift;

            finalGroup = buildCommon.makeVList([
                {type: "elem", elem: base},
                {type: "kern", size: supKern},
                {type: "elem", elem: supmid},
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5}
            ], "bottom", bottom, options);

            // See comment above about slants
            finalGroup.children[1].style.marginLeft = slant + "em";
        } else if (!supGroup && !subGroup) {
            // This case probably shouldn't occur (this would mean the
            // supsub was sending us a group with no superscript or
            // subscript) but be safe.
            return base;
        } else {
            bottom = fontMetrics.metrics.bigOpSpacing5 +
                submid.height + submid.depth +
                subKern +
                base.depth + baseShift;

            finalGroup = buildCommon.makeVList([
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5},
                {type: "elem", elem: submid},
                {type: "kern", size: subKern},
                {type: "elem", elem: base},
                {type: "kern", size: supKern},
                {type: "elem", elem: supmid},
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5}
            ], "bottom", bottom, options);

            // See comment above about slants
            finalGroup.children[0].style.marginLeft = -slant + "em";
            finalGroup.children[2].style.marginLeft = slant + "em";
        }

        return makeSpan(["mop", "op-limits"], [finalGroup], options);
    } else {
        if (group.value.symbol) {
            base.style.top = baseShift + "em";
        }

        return base;
    }
};

groupTypes.mod = function(group, options) {
    var inner = [];

    if (group.value.modType === "bmod") {
        // \nonscript\mskip-\medmuskip\mkern5mu
        if (!options.style.isTight()) {
            inner.push(makeSpan(
                ["mspace", "negativemediumspace"], [], options));
        }
        inner.push(makeSpan(["mspace", "thickspace"], [], options));
    } else if (options.style.size === Style.DISPLAY.size) {
        inner.push(makeSpan(["mspace", "quad"], [], options));
    } else if (group.value.modType === "mod") {
        inner.push(makeSpan(["mspace", "twelvemuspace"], [], options));
    } else {
        inner.push(makeSpan(["mspace", "eightmuspace"], [], options));
    }

    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(buildCommon.mathsym("(", group.mode));
    }

    if (group.value.modType !== "pod") {
        var modInner = [
            buildCommon.mathsym("m", group.mode),
            buildCommon.mathsym("o", group.mode),
            buildCommon.mathsym("d", group.mode)];
        if (group.value.modType === "bmod") {
            inner.push(makeSpan(["mbin"], modInner, options));
            // \mkern5mu\nonscript\mskip-\medmuskip
            inner.push(makeSpan(["mspace", "thickspace"], [], options));
            if (!options.style.isTight()) {
                inner.push(makeSpan(
                    ["mspace", "negativemediumspace"], [], options));
            }
        } else {
            Array.prototype.push.apply(inner, modInner);
            inner.push(makeSpan(["mspace", "sixmuspace"], [], options));
        }
    }

    if (group.value.value) {
        Array.prototype.push.apply(inner,
            buildExpression(group.value.value, options, false));
    }

    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(buildCommon.mathsym(")", group.mode));
    }

    return buildCommon.makeFragment(inner);
};

groupTypes.katex = function(group, options) {
    // The KaTeX logo. The offsets for the K and a were chosen to look
    // good, but the offsets for the T, E, and X were taken from the
    // definition of \TeX in TeX (see TeXbook pg. 356)
    var k = makeSpan(
        ["k"], [buildCommon.mathsym("K", group.mode)], options);
    var a = makeSpan(
        ["a"], [buildCommon.mathsym("A", group.mode)], options);

    a.height = (a.height + 0.2) * 0.75;
    a.depth = (a.height - 0.2) * 0.75;

    var t = makeSpan(
        ["t"], [buildCommon.mathsym("T", group.mode)], options);
    var e = makeSpan(
        ["e"], [buildCommon.mathsym("E", group.mode)], options);

    e.height = (e.height - 0.2155);
    e.depth = (e.depth + 0.2155);

    var x = makeSpan(
        ["x"], [buildCommon.mathsym("X", group.mode)], options);

    return makeSpan(
        ["mord", "katex-logo"], [k, a, t, e, x], options);
};

groupTypes.overline = function(group, options) {
    // Overlines are handled in the TeXbook pg 443, Rule 9.
    var style = options.style;

    // Build the inner group in the cramped style.
    var innerGroup = buildGroup(group.value.body,
            options.withStyle(style.cramp()));

    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
        style.sizeMultiplier;

    // Create the line above the body
    var line = makeSpan(
        [style.reset(), Style.TEXT.cls(), "overline-line"]);
    line.height = ruleWidth;
    line.maxFontSize = 1.0;

    // Generate the vlist, with the appropriate kerns
    var vlist = buildCommon.makeVList([
        {type: "elem", elem: innerGroup},
        {type: "kern", size: 3 * ruleWidth},
        {type: "elem", elem: line},
        {type: "kern", size: ruleWidth}
    ], "firstBaseline", null, options);

    return makeSpan(["mord", "overline"], [vlist], options);
};

groupTypes.underline = function(group, options) {
    // Underlines are handled in the TeXbook pg 443, Rule 10.
    var style = options.style;

    // Build the inner group.
    var innerGroup = buildGroup(group.value.body, options);

    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
        style.sizeMultiplier;

    // Create the line above the body
    var line = makeSpan([style.reset(), Style.TEXT.cls(), "underline-line"]);
    line.height = ruleWidth;
    line.maxFontSize = 1.0;

    // Generate the vlist, with the appropriate kerns
    var vlist = buildCommon.makeVList([
        {type: "kern", size: ruleWidth},
        {type: "elem", elem: line},
        {type: "kern", size: 3 * ruleWidth},
        {type: "elem", elem: innerGroup}
    ], "top", innerGroup.height, options);

    return makeSpan(["mord", "underline"], [vlist], options);
};

groupTypes.sqrt = function(group, options) {
    // Square roots are handled in the TeXbook pg. 443, Rule 11.
    var style = options.style;

    // First, we do the same steps as in overline to build the inner group
    // and line
    var inner = buildGroup(group.value.body, options.withStyle(style.cramp()));

    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
        style.sizeMultiplier;

    var line = makeSpan(
        [style.reset(), Style.TEXT.cls(), "sqrt-line"], [],
        options);
    line.height = ruleWidth;
    line.maxFontSize = 1.0;

    var phi = ruleWidth;
    if (style.id < Style.TEXT.id) {
        phi = style.metrics.xHeight;
    }

    // Calculate the clearance between the body and line
    var lineClearance = ruleWidth + phi / 4;

    var innerHeight = (inner.height + inner.depth) * style.sizeMultiplier;
    var minDelimiterHeight = innerHeight + lineClearance + ruleWidth;

    // Create a \surd delimiter of the required minimum size
    var delim = makeSpan(["sqrt-sign"], [
        delimiter.customSizedDelim("\\surd", minDelimiterHeight,
                                   false, options, group.mode)],
                         options);

    var delimDepth = (delim.height + delim.depth) - ruleWidth;

    // Adjust the clearance based on the delimiter size
    if (delimDepth > inner.height + inner.depth + lineClearance) {
        lineClearance =
            (lineClearance + delimDepth - inner.height - inner.depth) / 2;
    }

    // Shift the delimiter so that its top lines up with the top of the line
    var delimShift = -(inner.height + lineClearance + ruleWidth) + delim.height;
    delim.style.top = delimShift + "em";
    delim.height -= delimShift;
    delim.depth += delimShift;

    // We add a special case here, because even when `inner` is empty, we
    // still get a line. So, we use a simple heuristic to decide if we
    // should omit the body entirely. (note this doesn't work for something
    // like `\sqrt{\rlap{x}}`, but if someone is doing that they deserve for
    // it not to work.
    var body;
    if (inner.height === 0 && inner.depth === 0) {
        body = makeSpan();
    } else {
        body = buildCommon.makeVList([
            {type: "elem", elem: inner},
            {type: "kern", size: lineClearance},
            {type: "elem", elem: line},
            {type: "kern", size: ruleWidth}
        ], "firstBaseline", null, options);
    }

    if (!group.value.index) {
        return makeSpan(["mord", "sqrt"], [delim, body], options);
    } else {
        // Handle the optional root index

        // The index is always in scriptscript style
        var newOptions = options.withStyle(Style.SCRIPTSCRIPT);
        var root = buildGroup(group.value.index, newOptions);
        var rootWrap = makeSpan(
            [style.reset(), Style.SCRIPTSCRIPT.cls()],
            [root],
            newOptions);

        // Figure out the height and depth of the inner part
        var innerRootHeight = Math.max(delim.height, body.height);
        var innerRootDepth = Math.max(delim.depth, body.depth);

        // The amount the index is shifted by. This is taken from the TeX
        // source, in the definition of `\r@@t`.
        var toShift = 0.6 * (innerRootHeight - innerRootDepth);

        // Build a VList with the superscript shifted up correctly
        var rootVList = buildCommon.makeVList(
            [{type: "elem", elem: rootWrap}],
            "shift", -toShift, options);
        // Add a class surrounding it so we can add on the appropriate
        // kerning
        var rootVListWrap = makeSpan(["root"], [rootVList]);

        return makeSpan(["mord", "sqrt"],
            [rootVListWrap, delim, body], options);
    }
};

groupTypes.sizing = function(group, options) {
    // Handle sizing operators like \Huge. Real TeX doesn't actually allow
    // these functions inside of math expressions, so we do some special
    // handling.
    var inner = buildExpression(group.value.value,
            options.withSize(group.value.size), false);

    // Compute the correct maxFontSize.
    var style = options.style;
    var fontSize = buildCommon.sizingMultiplier[group.value.size];
    fontSize = fontSize * style.sizeMultiplier;

    // Add size-resetting classes to the inner list and set maxFontSize
    // manually. Handle nested size changes.
    for (var i = 0; i < inner.length; i++) {
        var pos = utils.indexOf(inner[i].classes, "sizing");
        if (pos < 0) {
            inner[i].classes.push("sizing", "reset-" + options.size,
                                  group.value.size, style.cls());
            inner[i].maxFontSize = fontSize;
        } else if (inner[i].classes[pos + 1] === "reset-" + group.value.size) {
            // This is a nested size change: e.g., inner[i] is the "b" in
            // `\Huge a \small b`. Override the old size (the `reset-` class)
            // but not the new size.
            inner[i].classes[pos + 1] = "reset-" + options.size;
        }
    }

    return buildCommon.makeFragment(inner);
};

groupTypes.styling = function(group, options) {
    // Style changes are handled in the TeXbook on pg. 442, Rule 3.

    // Figure out what style we're changing to.
    var styleMap = {
        "display": Style.DISPLAY,
        "text": Style.TEXT,
        "script": Style.SCRIPT,
        "scriptscript": Style.SCRIPTSCRIPT
    };

    var newStyle = styleMap[group.value.style];
    var newOptions = options.withStyle(newStyle);

    // Build the inner expression in the new style.
    var inner = buildExpression(
        group.value.value, newOptions, false);

    // Add style-resetting classes to the inner list. Handle nested changes.
    for (var i = 0; i < inner.length; i++) {
        var pos = utils.indexOf(inner[i].classes, newStyle.reset());
        if (pos < 0) {
            inner[i].classes.push(options.style.reset(), newStyle.cls());
        } else {
            // This is a nested style change, as `\textstyle a\scriptstyle b`.
            // Only override the old style (the reset class).
            inner[i].classes[pos] = options.style.reset();
        }
    }

    return new buildCommon.makeFragment(inner);
};

groupTypes.font = function(group, options) {
    var font = group.value.font;
    return buildGroup(group.value.body, options.withFont(font));
};

groupTypes.delimsizing = function(group, options) {
    var delim = group.value.value;

    if (delim === ".") {
        // Empty delimiters still count as elements, even though they don't
        // show anything.
        return makeSpan([group.value.mclass]);
    }

    // Use delimiter.sizedDelim to generate the delimiter.
    return delimiter.sizedDelim(
            delim, group.value.size, options, group.mode,
            [group.value.mclass]);
};

groupTypes.leftright = function(group, options) {
    // Build the inner expression
    var inner = buildExpression(group.value.body, options.reset(), true);

    var innerHeight = 0;
    var innerDepth = 0;
    var hadMiddle = false;

    // Calculate its height and depth
    for (var i = 0; i < inner.length; i++) {
        if (inner[i].isMiddle) {
            hadMiddle = true;
        } else {
            innerHeight = Math.max(inner[i].height, innerHeight);
            innerDepth = Math.max(inner[i].depth, innerDepth);
        }
    }

    var style = options.style;

    // The size of delimiters is the same, regardless of what style we are
    // in. Thus, to correctly calculate the size of delimiter we need around
    // a group, we scale down the inner size based on the size.
    innerHeight *= style.sizeMultiplier;
    innerDepth *= style.sizeMultiplier;

    var leftDelim;
    if (group.value.left === ".") {
        // Empty delimiters in \left and \right make null delimiter spaces.
        leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
        // Otherwise, use leftRightDelim to generate the correct sized
        // delimiter.
        leftDelim = delimiter.leftRightDelim(
            group.value.left, innerHeight, innerDepth, options,
            group.mode, ["mopen"]);
    }
    // Add it to the beginning of the expression
    inner.unshift(leftDelim);

    // Handle middle delimiters
    if (hadMiddle) {
        for (i = 1; i < inner.length; i++) {
            if (inner[i].isMiddle) {
                // Apply the options that were active when \middle was called
                inner[i] = delimiter.leftRightDelim(
                    inner[i].isMiddle.value, innerHeight, innerDepth,
                    inner[i].isMiddle.options, group.mode, []);
            }
        }
    }

    var rightDelim;
    // Same for the right delimiter
    if (group.value.right === ".") {
        rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
        rightDelim = delimiter.leftRightDelim(
            group.value.right, innerHeight, innerDepth, options,
            group.mode, ["mclose"]);
    }
    // Add it to the end of the expression.
    inner.push(rightDelim);

    return makeSpan(
        ["minner", style.cls()], inner, options);
};

groupTypes.middle = function(group, options) {
    var middleDelim;
    if (group.value.value === ".") {
        middleDelim = makeNullDelimiter(options, []);
    } else {
        middleDelim = delimiter.sizedDelim(
            group.value.value, 1, options,
            group.mode, []);
        middleDelim.isMiddle = {value: group.value.value, options: options};
    }
    return middleDelim;
};

groupTypes.rule = function(group, options) {
    // Make an empty span for the rule
    var rule = makeSpan(["mord", "rule"], [], options);
    var style = options.style;

    // Calculate the shift, width, and height of the rule, and account for units
    var shift = 0;
    if (group.value.shift) {
        shift = calculateSize(group.value.shift, style);
    }

    var width = calculateSize(group.value.width, style);
    var height = calculateSize(group.value.height, style);

    // The sizes of rules are absolute, so make it larger if we are in a
    // smaller style.
    shift /= style.sizeMultiplier;
    width /= style.sizeMultiplier;
    height /= style.sizeMultiplier;

    // Style the rule to the right size
    rule.style.borderRightWidth = width + "em";
    rule.style.borderTopWidth = height + "em";
    rule.style.bottom = shift + "em";

    // Record the height and width
    rule.width = width;
    rule.height = height + shift;
    rule.depth = -shift;

    return rule;
};

groupTypes.kern = function(group, options) {
    // Make an empty span for the rule
    var rule = makeSpan(["mord", "rule"], [], options);
    var style = options.style;

    var dimension = 0;
    if (group.value.dimension) {
        dimension = calculateSize(group.value.dimension, style);
    }

    dimension /= style.sizeMultiplier;

    rule.style.marginLeft = dimension + "em";

    return rule;
};

groupTypes.accent = function(group, options) {
    // Accents are handled in the TeXbook pg. 443, rule 12.
    var base = group.value.base;
    var style = options.style;

    var supsubGroup;
    if (group.type === "supsub") {
        // If our base is a character box, and we have superscripts and
        // subscripts, the supsub will defer to us. In particular, we want
        // to attach the superscripts and subscripts to the inner body (so
        // that the position of the superscripts and subscripts won't be
        // affected by the height of the accent). We accomplish this by
        // sticking the base of the accent into the base of the supsub, and
        // rendering that, while keeping track of where the accent is.

        // The supsub group is the group that was passed in
        var supsub = group;
        // The real accent group is the base of the supsub group
        group = supsub.value.base;
        // The character box is the base of the accent group
        base = group.value.base;
        // Stick the character box into the base of the supsub group
        supsub.value.base = base;

        // Rerender the supsub group with its new base, and store that
        // result.
        supsubGroup = buildGroup(
            supsub, options.reset());
    }

    // Build the base group
    var body = buildGroup(
        base, options.withStyle(style.cramp()));

    // Calculate the skew of the accent. This is based on the line "If the
    // nucleus is not a single character, let s = 0; otherwise set s to the
    // kern amount for the nucleus followed by the \skewchar of its font."
    // Note that our skew metrics are just the kern between each character
    // and the skewchar.
    var skew;
    if (isCharacterBox(base)) {
        // If the base is a character box, then we want the skew of the
        // innermost character. To do that, we find the innermost character:
        var baseChar = getBaseElem(base);
        // Then, we render its group to get the symbol inside it
        var baseGroup = buildGroup(
            baseChar, options.withStyle(style.cramp()));
        // Finally, we pull the skew off of the symbol.
        skew = baseGroup.skew;
        // Note that we now throw away baseGroup, because the layers we
        // removed with getBaseElem might contain things like \color which
        // we can't get rid of.
        // TODO(emily): Find a better way to get the skew
    } else {
        skew = 0;
    }

    // calculate the amount of space between the body and the accent
    var clearance = Math.min(
        body.height,
        style.metrics.xHeight);

    // Build the accent
    var accent = buildCommon.makeSymbol(
        group.value.accent, "Main-Regular", "math", options);
    // Remove the italic correction of the accent, because it only serves to
    // shift the accent over to a place we don't want.
    accent.italic = 0;

    // The \vec character that the fonts use is a combining character, and
    // thus shows up much too far to the left. To account for this, we add a
    // specific class which shifts the accent over to where we want it.
    // TODO(emily): Fix this in a better way, like by changing the font
    var vecClass = group.value.accent === "\\vec" ? "accent-vec" : null;

    var accentBody = makeSpan(["accent-body", vecClass], [
        makeSpan([], [accent])]);

    accentBody = buildCommon.makeVList([
        {type: "elem", elem: body},
        {type: "kern", size: -clearance},
        {type: "elem", elem: accentBody}
    ], "firstBaseline", null, options);

    // Shift the accent over by the skew. Note we shift by twice the skew
    // because we are centering the accent, so by adding 2*skew to the left,
    // we shift it to the right by 1*skew.
    accentBody.children[1].style.marginLeft = 2 * skew + "em";

    var accentWrap = makeSpan(["mord", "accent"], [accentBody], options);

    if (supsubGroup) {
        // Here, we replace the "base" child of the supsub with our newly
        // generated accent.
        supsubGroup.children[0] = accentWrap;

        // Since we don't rerun the height calculation after replacing the
        // accent, we manually recalculate height.
        supsubGroup.height = Math.max(accentWrap.height, supsubGroup.height);

        // Accents should always be ords, even when their innards are not.
        supsubGroup.classes[0] = "mord";

        return supsubGroup;
    } else {
        return accentWrap;
    }
};

groupTypes.phantom = function(group, options) {
    var elements = buildExpression(
        group.value.value,
        options.withPhantom(),
        false
    );

    // \phantom isn't supposed to affect the elements it contains.
    // See "color" for more details.
    return new buildCommon.makeFragment(elements);
};

groupTypes.mclass = function(group, options) {
    var elements = buildExpression(group.value.value, options, true);

    return makeSpan([group.value.mclass], elements, options);
};

/**
 * buildGroup is the function that takes a group and calls the correct groupType
 * function for it. It also handles the interaction of size and style changes
 * between parents and children.
 */
var buildGroup = function(group, options) {
    if (!group) {
        return makeSpan();
    }

    if (groupTypes[group.type]) {
        // Call the groupTypes function
        var groupNode = groupTypes[group.type](group, options);
        var multiplier;

        // If the style changed between the parent and the current group,
        // account for the size difference
        if (options.style !== options.parentStyle) {
            multiplier = options.style.sizeMultiplier /
                    options.parentStyle.sizeMultiplier;

            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
        }

        // If the size changed between the parent and the current group, account
        // for that size difference.
        if (options.size !== options.parentSize) {
            multiplier = buildCommon.sizingMultiplier[options.size] /
                    buildCommon.sizingMultiplier[options.parentSize];

            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
        }

        return groupNode;
    } else {
        throw new ParseError(
            "Got group of unknown type: '" + group.type + "'");
    }
};

/**
 * Take an entire parse tree, and build it into an appropriate set of HTML
 * nodes.
 */
var buildHTML = function(tree, options) {
    // buildExpression is destructive, so we need to make a clone
    // of the incoming tree so that it isn't accidentally changed
    tree = JSON.parse(JSON.stringify(tree));

    // Build the expression contained in the tree
    var expression = buildExpression(tree, options, true);
    var body = makeSpan(["base", options.style.cls()], expression, options);

    // Add struts, which ensure that the top of the HTML element falls at the
    // height of the expression, and the bottom of the HTML element falls at the
    // depth of the expression.
    var topStrut = makeSpan(["strut"]);
    var bottomStrut = makeSpan(["strut", "bottom"]);

    topStrut.style.height = body.height + "em";
    bottomStrut.style.height = (body.height + body.depth) + "em";
    // We'd like to use `vertical-align: top` but in IE 9 this lowers the
    // baseline of the box to the bottom of this strut (instead staying in the
    // normal place) so we use an absolute value for vertical-align instead
    bottomStrut.style.verticalAlign = -body.depth + "em";

    // Wrap the struts and body together
    var htmlNode = makeSpan(["katex-html"], [topStrut, bottomStrut, body]);

    htmlNode.setAttribute("aria-hidden", "true");

    return htmlNode;
};

module.exports = buildHTML;

},{"./ParseError":95,"./Style":98,"./buildCommon":99,"./delimiter":103,"./domTree":104,"./fontMetrics":106,"./utils":114}],101:[function(require,module,exports){
/**
 * This file converts a parse tree into a cooresponding MathML tree. The main
 * entry point is the `buildMathML` function, which takes a parse tree from the
 * parser.
 */

var buildCommon = require("./buildCommon");
var fontMetrics = require("./fontMetrics");
var mathMLTree = require("./mathMLTree");
var ParseError = require("./ParseError");
var symbols = require("./symbols");
var utils = require("./utils");

var makeSpan = buildCommon.makeSpan;
var fontMap = buildCommon.fontMap;

/**
 * Takes a symbol and converts it into a MathML text node after performing
 * optional replacement from symbols.js.
 */
var makeText = function(text, mode) {
    if (symbols[mode][text] && symbols[mode][text].replace) {
        text = symbols[mode][text].replace;
    }

    return new mathMLTree.TextNode(text);
};

/**
 * Returns the math variant as a string or null if none is required.
 */
var getVariant = function(group, options) {
    var font = options.font;
    if (!font) {
        return null;
    }

    var mode = group.mode;
    if (font === "mathit") {
        return "italic";
    }

    var value = group.value;
    if (utils.contains(["\\imath", "\\jmath"], value)) {
        return null;
    }

    if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var fontName = fontMap[font].fontName;
    if (fontMetrics.getCharacterMetrics(value, fontName)) {
        return fontMap[options.font].variant;
    }

    return null;
};

/**
 * Functions for handling the different types of groups found in the parse
 * tree. Each function should take a parse group and return a MathML node.
 */
var groupTypes = {};

groupTypes.mathord = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mi",
        [makeText(group.value, group.mode)]);

    var variant = getVariant(group, options);
    if (variant) {
        node.setAttribute("mathvariant", variant);
    }
    return node;
};

groupTypes.textord = function(group, options) {
    var text = makeText(group.value, group.mode);

    var variant = getVariant(group, options) || "normal";

    var node;
    if (/[0-9]/.test(group.value)) {
        // TODO(kevinb) merge adjacent <mn> nodes
        // do it as a post processing step
        node = new mathMLTree.MathNode("mn", [text]);
        if (options.font) {
            node.setAttribute("mathvariant", variant);
        }
    } else {
        node = new mathMLTree.MathNode("mi", [text]);
        node.setAttribute("mathvariant", variant);
    }

    return node;
};

groupTypes.bin = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.rel = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.open = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.close = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.inner = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.punct = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    node.setAttribute("separator", "true");

    return node;
};

groupTypes.ordgroup = function(group, options) {
    var inner = buildExpression(group.value, options);

    var node = new mathMLTree.MathNode("mrow", inner);

    return node;
};

groupTypes.text = function(group, options) {
    var inner = buildExpression(group.value.body, options);

    var node = new mathMLTree.MathNode("mtext", inner);

    return node;
};

groupTypes.color = function(group, options) {
    var inner = buildExpression(group.value.value, options);

    var node = new mathMLTree.MathNode("mstyle", inner);

    node.setAttribute("mathcolor", group.value.color);

    return node;
};

groupTypes.supsub = function(group, options) {
    var children = [buildGroup(group.value.base, options)];

    if (group.value.sub) {
        children.push(buildGroup(group.value.sub, options));
    }

    if (group.value.sup) {
        children.push(buildGroup(group.value.sup, options));
    }

    var nodeType;
    if (!group.value.sub) {
        nodeType = "msup";
    } else if (!group.value.sup) {
        nodeType = "msub";
    } else {
        nodeType = "msubsup";
    }

    var node = new mathMLTree.MathNode(nodeType, children);

    return node;
};

groupTypes.genfrac = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mfrac",
        [buildGroup(group.value.numer, options),
            buildGroup(group.value.denom, options)]);

    if (!group.value.hasBarLine) {
        node.setAttribute("linethickness", "0px");
    }

    if (group.value.leftDelim != null || group.value.rightDelim != null) {
        var withDelims = [];

        if (group.value.leftDelim != null) {
            var leftOp = new mathMLTree.MathNode(
                "mo", [new mathMLTree.TextNode(group.value.leftDelim)]);

            leftOp.setAttribute("fence", "true");

            withDelims.push(leftOp);
        }

        withDelims.push(node);

        if (group.value.rightDelim != null) {
            var rightOp = new mathMLTree.MathNode(
                "mo", [new mathMLTree.TextNode(group.value.rightDelim)]);

            rightOp.setAttribute("fence", "true");

            withDelims.push(rightOp);
        }

        var outerNode = new mathMLTree.MathNode("mrow", withDelims);

        return outerNode;
    }

    return node;
};

groupTypes.array = function(group, options) {
    return new mathMLTree.MathNode(
        "mtable", group.value.body.map(function(row) {
            return new mathMLTree.MathNode(
                "mtr", row.map(function(cell) {
                    return new mathMLTree.MathNode(
                        "mtd", [buildGroup(cell, options)]);
                }));
        }));
};

groupTypes.sqrt = function(group, options) {
    var node;
    if (group.value.index) {
        node = new mathMLTree.MathNode(
            "mroot", [
                buildGroup(group.value.body, options),
                buildGroup(group.value.index, options)
            ]);
    } else {
        node = new mathMLTree.MathNode(
            "msqrt", [buildGroup(group.value.body, options)]);
    }

    return node;
};

groupTypes.leftright = function(group, options) {
    var inner = buildExpression(group.value.body, options);

    if (group.value.left !== ".") {
        var leftNode = new mathMLTree.MathNode(
            "mo", [makeText(group.value.left, group.mode)]);

        leftNode.setAttribute("fence", "true");

        inner.unshift(leftNode);
    }

    if (group.value.right !== ".") {
        var rightNode = new mathMLTree.MathNode(
            "mo", [makeText(group.value.right, group.mode)]);

        rightNode.setAttribute("fence", "true");

        inner.push(rightNode);
    }

    var outerNode = new mathMLTree.MathNode("mrow", inner);

    return outerNode;
};

groupTypes.middle = function(group, options) {
    var middleNode = new mathMLTree.MathNode(
        "mo", [makeText(group.value.middle, group.mode)]);
    middleNode.setAttribute("fence", "true");
    return middleNode;
};

groupTypes.accent = function(group, options) {
    var accentNode = new mathMLTree.MathNode(
        "mo", [makeText(group.value.accent, group.mode)]);

    var node = new mathMLTree.MathNode(
        "mover",
        [buildGroup(group.value.base, options),
            accentNode]);

    node.setAttribute("accent", "true");

    return node;
};

groupTypes.spacing = function(group) {
    var node;

    if (group.value === "\\ " || group.value === "\\space" ||
        group.value === " " || group.value === "~") {
        node = new mathMLTree.MathNode(
            "mtext", [new mathMLTree.TextNode("\u00a0")]);
    } else {
        node = new mathMLTree.MathNode("mspace");

        node.setAttribute(
            "width", buildCommon.spacingFunctions[group.value].size);
    }

    return node;
};

groupTypes.op = function(group, options) {
    var node;

    // TODO(emily): handle big operators using the `largeop` attribute

    if (group.value.symbol) {
        // This is a symbol. Just add the symbol.
        node = new mathMLTree.MathNode(
            "mo", [makeText(group.value.body, group.mode)]);
    } else if (group.value.value) {
        // This is an operator with children. Add them.
        node = new mathMLTree.MathNode(
            "mo", buildExpression(group.value.value, options));
    } else {
        // This is a text operator. Add all of the characters from the
        // operator's name.
        // TODO(emily): Add a space in the middle of some of these
        // operators, like \limsup.
        node = new mathMLTree.MathNode(
            "mi", [new mathMLTree.TextNode(group.value.body.slice(1))]);
    }

    return node;
};

groupTypes.mod = function(group, options) {
    var inner = [];

    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(new mathMLTree.MathNode(
            "mo", [makeText("(", group.mode)]));
    }
    if (group.value.modType !== "pod") {
        inner.push(new mathMLTree.MathNode(
            "mo", [makeText("mod", group.mode)]));
    }
    if (group.value.value) {
        var space = new mathMLTree.MathNode("mspace");
        space.setAttribute("width", "0.333333em");
        inner.push(space);
        inner = inner.concat(buildExpression(group.value.value, options));
    }
    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(new mathMLTree.MathNode(
            "mo", [makeText(")", group.mode)]));
    }

    return new mathMLTree.MathNode("mo", inner);
};

groupTypes.katex = function(group) {
    var node = new mathMLTree.MathNode(
        "mtext", [new mathMLTree.TextNode("KaTeX")]);

    return node;
};

groupTypes.font = function(group, options) {
    var font = group.value.font;
    return buildGroup(group.value.body, options.withFont(font));
};

groupTypes.delimsizing = function(group) {
    var children = [];

    if (group.value.value !== ".") {
        children.push(makeText(group.value.value, group.mode));
    }

    var node = new mathMLTree.MathNode("mo", children);

    if (group.value.mclass === "mopen" ||
        group.value.mclass === "mclose") {
        // Only some of the delimsizing functions act as fences, and they
        // return "mopen" or "mclose" mclass.
        node.setAttribute("fence", "true");
    } else {
        // Explicitly disable fencing if it's not a fence, to override the
        // defaults.
        node.setAttribute("fence", "false");
    }

    return node;
};

groupTypes.styling = function(group, options) {
    var inner = buildExpression(group.value.value, options);

    var node = new mathMLTree.MathNode("mstyle", inner);

    var styleAttributes = {
        "display": ["0", "true"],
        "text": ["0", "false"],
        "script": ["1", "false"],
        "scriptscript": ["2", "false"]
    };

    var attr = styleAttributes[group.value.style];

    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);

    return node;
};

groupTypes.sizing = function(group, options) {
    var inner = buildExpression(group.value.value, options);

    var node = new mathMLTree.MathNode("mstyle", inner);

    // TODO(emily): This doesn't produce the correct size for nested size
    // changes, because we don't keep state of what style we're currently
    // in, so we can't reset the size to normal before changing it.  Now
    // that we're passing an options parameter we should be able to fix
    // this.
    node.setAttribute(
        "mathsize", buildCommon.sizingMultiplier[group.value.size] + "em");

    return node;
};

groupTypes.overline = function(group, options) {
    var operator = new mathMLTree.MathNode(
        "mo", [new mathMLTree.TextNode("\u203e")]);
    operator.setAttribute("stretchy", "true");

    var node = new mathMLTree.MathNode(
        "mover",
        [buildGroup(group.value.body, options),
            operator]);
    node.setAttribute("accent", "true");

    return node;
};

groupTypes.underline = function(group, options) {
    var operator = new mathMLTree.MathNode(
        "mo", [new mathMLTree.TextNode("\u203e")]);
    operator.setAttribute("stretchy", "true");

    var node = new mathMLTree.MathNode(
        "munder",
        [buildGroup(group.value.body, options),
            operator]);
    node.setAttribute("accentunder", "true");

    return node;
};

groupTypes.rule = function(group) {
    // TODO(emily): Figure out if there's an actual way to draw black boxes
    // in MathML.
    var node = new mathMLTree.MathNode("mrow");

    return node;
};

groupTypes.kern = function(group) {
    // TODO(kevin): Figure out if there's a way to add space in MathML
    var node = new mathMLTree.MathNode("mrow");

    return node;
};

groupTypes.llap = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mpadded", [buildGroup(group.value.body, options)]);

    node.setAttribute("lspace", "-1width");
    node.setAttribute("width", "0px");

    return node;
};

groupTypes.rlap = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mpadded", [buildGroup(group.value.body, options)]);

    node.setAttribute("width", "0px");

    return node;
};

groupTypes.phantom = function(group, options) {
    var inner = buildExpression(group.value.value, options);
    return new mathMLTree.MathNode("mphantom", inner);
};

groupTypes.mclass = function(group, options) {
    var inner = buildExpression(group.value.value, options);
    return new mathMLTree.MathNode("mstyle", inner);
};

/**
 * Takes a list of nodes, builds them, and returns a list of the generated
 * MathML nodes. A little simpler than the HTML version because we don't do any
 * previous-node handling.
 */
var buildExpression = function(expression, options) {
    var groups = [];
    for (var i = 0; i < expression.length; i++) {
        var group = expression[i];
        groups.push(buildGroup(group, options));
    }
    return groups;
};

/**
 * Takes a group from the parser and calls the appropriate groupTypes function
 * on it to produce a MathML node.
 */
var buildGroup = function(group, options) {
    if (!group) {
        return new mathMLTree.MathNode("mrow");
    }

    if (groupTypes[group.type]) {
        // Call the groupTypes function
        return groupTypes[group.type](group, options);
    } else {
        throw new ParseError(
            "Got group of unknown type: '" + group.type + "'");
    }
};

/**
 * Takes a full parse tree and settings and builds a MathML representation of
 * it. In particular, we put the elements from building the parse tree into a
 * <semantics> tag so we can also include that TeX source as an annotation.
 *
 * Note that we actually return a domTree element with a `<math>` inside it so
 * we can do appropriate styling.
 */
var buildMathML = function(tree, texExpression, options) {
    var expression = buildExpression(tree, options);

    // Wrap up the expression in an mrow so it is presented in the semantics
    // tag correctly.
    var wrapper = new mathMLTree.MathNode("mrow", expression);

    // Build a TeX annotation of the source
    var annotation = new mathMLTree.MathNode(
        "annotation", [new mathMLTree.TextNode(texExpression)]);

    annotation.setAttribute("encoding", "application/x-tex");

    var semantics = new mathMLTree.MathNode(
        "semantics", [wrapper, annotation]);

    var math = new mathMLTree.MathNode("math", [semantics]);

    // You can't style <math> nodes, so we wrap the node in a span.
    return makeSpan(["katex-mathml"], [math]);
};

module.exports = buildMathML;

},{"./ParseError":95,"./buildCommon":99,"./fontMetrics":106,"./mathMLTree":109,"./symbols":112,"./utils":114}],102:[function(require,module,exports){
var buildHTML = require("./buildHTML");
var buildMathML = require("./buildMathML");
var buildCommon = require("./buildCommon");
var Options = require("./Options");
var Settings = require("./Settings");
var Style = require("./Style");

var makeSpan = buildCommon.makeSpan;

var buildTree = function(tree, expression, settings) {
    settings = settings || new Settings({});

    var startStyle = Style.TEXT;
    if (settings.displayMode) {
        startStyle = Style.DISPLAY;
    }

    // Setup the default options
    var options = new Options({
        style: startStyle,
        size: "size5"
    });

    // `buildHTML` sometimes messes with the parse tree (like turning bins ->
    // ords), so we build the MathML version first.
    var mathMLNode = buildMathML(tree, expression, options);
    var htmlNode = buildHTML(tree, options);

    var katexNode = makeSpan(["katex"], [
        mathMLNode, htmlNode
    ]);

    if (settings.displayMode) {
        return makeSpan(["katex-display"], [katexNode]);
    } else {
        return katexNode;
    }
};

module.exports = buildTree;

},{"./Options":94,"./Settings":97,"./Style":98,"./buildCommon":99,"./buildHTML":100,"./buildMathML":101}],103:[function(require,module,exports){
/**
 * This file deals with creating delimiters of various sizes. The TeXbook
 * discusses these routines on page 441-442, in the "Another subroutine sets box
 * x to a specified variable delimiter" paragraph.
 *
 * There are three main routines here. `makeSmallDelim` makes a delimiter in the
 * normal font, but in either text, script, or scriptscript style.
 * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
 * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
 * smaller pieces that are stacked on top of one another.
 *
 * The functions take a parameter `center`, which determines if the delimiter
 * should be centered around the axis.
 *
 * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
 * one of the given sizes. This is used for things like `\bigl`.
 * `customSizedDelim` makes a delimiter with a given total height+depth. It is
 * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
 * delimiter which surrounds an expression of a given height an depth. It is
 * used in `\left` and `\right`.
 */

var ParseError = require("./ParseError");
var Style = require("./Style");

var buildCommon = require("./buildCommon");
var fontMetrics = require("./fontMetrics");
var symbols = require("./symbols");
var utils = require("./utils");

var makeSpan = buildCommon.makeSpan;

/**
 * Get the metrics for a given symbol and font, after transformation (i.e.
 * after following replacement from symbols.js)
 */
var getMetrics = function(symbol, font) {
    if (symbols.math[symbol] && symbols.math[symbol].replace) {
        return fontMetrics.getCharacterMetrics(
            symbols.math[symbol].replace, font);
    } else {
        return fontMetrics.getCharacterMetrics(
            symbol, font);
    }
};

/**
 * Builds a symbol in the given font size (note size is an integer)
 */
var mathrmSize = function(value, size, mode, options) {
    return buildCommon.makeSymbol(value, "Size" + size + "-Regular",
        mode, options);
};

/**
 * Puts a delimiter span in a given style, and adds appropriate height, depth,
 * and maxFontSizes.
 */
var styleWrap = function(delim, toStyle, options, classes) {
    classes = classes || [];
    var span = makeSpan(
        classes.concat(["style-wrap", options.style.reset(), toStyle.cls()]),
        [delim], options);

    var multiplier = toStyle.sizeMultiplier / options.style.sizeMultiplier;

    span.height *= multiplier;
    span.depth *= multiplier;
    span.maxFontSize = toStyle.sizeMultiplier;

    return span;
};

/**
 * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
 * font, but is restyled to either be in textstyle, scriptstyle, or
 * scriptscriptstyle.
 */
var makeSmallDelim = function(delim, style, center, options, mode, classes) {
    var text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);

    var span = styleWrap(text, style, options, classes);

    if (center) {
        var shift =
            (1 - options.style.sizeMultiplier / style.sizeMultiplier) *
            options.style.metrics.axisHeight;

        span.style.top = shift + "em";
        span.height -= shift;
        span.depth += shift;
    }

    return span;
};

/**
 * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
 * Size3, or Size4 fonts. It is always rendered in textstyle.
 */
var makeLargeDelim = function(delim, size, center, options, mode, classes) {
    var inner = mathrmSize(delim, size, mode, options);

    var span = styleWrap(
        makeSpan(["delimsizing", "size" + size], [inner], options),
        Style.TEXT, options, classes);

    if (center) {
        var shift = (1 - options.style.sizeMultiplier) *
            options.style.metrics.axisHeight;

        span.style.top = shift + "em";
        span.height -= shift;
        span.depth += shift;
    }

    return span;
};

/**
 * Make an inner span with the given offset and in the given font. This is used
 * in `makeStackedDelim` to make the stacking pieces for the delimiter.
 */
var makeInner = function(symbol, font, mode) {
    var sizeClass;
    // Apply the correct CSS class to choose the right font.
    if (font === "Size1-Regular") {
        sizeClass = "delim-size1";
    } else if (font === "Size4-Regular") {
        sizeClass = "delim-size4";
    }

    var inner = makeSpan(
        ["delimsizinginner", sizeClass],
        [makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);

    // Since this will be passed into `makeVList` in the end, wrap the element
    // in the appropriate tag that VList uses.
    return {type: "elem", elem: inner};
};

/**
 * Make a stacked delimiter out of a given delimiter, with the total height at
 * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
 */
var makeStackedDelim = function(delim, heightTotal, center, options, mode,
                                classes) {
    // There are four parts, the top, an optional middle, a repeated part, and a
    // bottom.
    var top;
    var middle;
    var repeat;
    var bottom;
    top = repeat = bottom = delim;
    middle = null;
    // Also keep track of what font the delimiters are in
    var font = "Size1-Regular";

    // We set the parts and font based on the symbol. Note that we use
    // '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
    // repeats of the arrows
    if (delim === "\\uparrow") {
        repeat = bottom = "\u23d0";
    } else if (delim === "\\Uparrow") {
        repeat = bottom = "\u2016";
    } else if (delim === "\\downarrow") {
        top = repeat = "\u23d0";
    } else if (delim === "\\Downarrow") {
        top = repeat = "\u2016";
    } else if (delim === "\\updownarrow") {
        top = "\\uparrow";
        repeat = "\u23d0";
        bottom = "\\downarrow";
    } else if (delim === "\\Updownarrow") {
        top = "\\Uparrow";
        repeat = "\u2016";
        bottom = "\\Downarrow";
    } else if (delim === "[" || delim === "\\lbrack") {
        top = "\u23a1";
        repeat = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
    } else if (delim === "]" || delim === "\\rbrack") {
        top = "\u23a4";
        repeat = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
    } else if (delim === "\\lfloor") {
        repeat = top = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
    } else if (delim === "\\lceil") {
        top = "\u23a1";
        repeat = bottom = "\u23a2";
        font = "Size4-Regular";
    } else if (delim === "\\rfloor") {
        repeat = top = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
    } else if (delim === "\\rceil") {
        top = "\u23a4";
        repeat = bottom = "\u23a5";
        font = "Size4-Regular";
    } else if (delim === "(") {
        top = "\u239b";
        repeat = "\u239c";
        bottom = "\u239d";
        font = "Size4-Regular";
    } else if (delim === ")") {
        top = "\u239e";
        repeat = "\u239f";
        bottom = "\u23a0";
        font = "Size4-Regular";
    } else if (delim === "\\{" || delim === "\\lbrace") {
        top = "\u23a7";
        middle = "\u23a8";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\}" || delim === "\\rbrace") {
        top = "\u23ab";
        middle = "\u23ac";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\lgroup") {
        top = "\u23a7";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\rgroup") {
        top = "\u23ab";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\lmoustache") {
        top = "\u23a7";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\rmoustache") {
        top = "\u23ab";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\surd") {
        top = "\ue001";
        bottom = "\u23b7";
        repeat = "\ue000";
        font = "Size4-Regular";
    }

    // Get the metrics of the four sections
    var topMetrics = getMetrics(top, font);
    var topHeightTotal = topMetrics.height + topMetrics.depth;
    var repeatMetrics = getMetrics(repeat, font);
    var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
    var bottomMetrics = getMetrics(bottom, font);
    var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
    var middleHeightTotal = 0;
    var middleFactor = 1;
    if (middle !== null) {
        var middleMetrics = getMetrics(middle, font);
        middleHeightTotal = middleMetrics.height + middleMetrics.depth;
        middleFactor = 2; // repeat symmetrically above and below middle
    }

    // Calcuate the minimal height that the delimiter can have.
    // It is at least the size of the top, bottom, and optional middle combined.
    var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;

    // Compute the number of copies of the repeat symbol we will need
    var repeatCount = Math.ceil(
        (heightTotal - minHeight) / (middleFactor * repeatHeightTotal));

    // Compute the total height of the delimiter including all the symbols
    var realHeightTotal =
        minHeight + repeatCount * middleFactor * repeatHeightTotal;

    // The center of the delimiter is placed at the center of the axis. Note
    // that in this context, "center" means that the delimiter should be
    // centered around the axis in the current style, while normally it is
    // centered around the axis in textstyle.
    var axisHeight = options.style.metrics.axisHeight;
    if (center) {
        axisHeight *= options.style.sizeMultiplier;
    }
    // Calculate the depth
    var depth = realHeightTotal / 2 - axisHeight;

    // Now, we start building the pieces that will go into the vlist

    // Keep a list of the inner pieces
    var inners = [];

    // Add the bottom symbol
    inners.push(makeInner(bottom, font, mode));

    var i;
    if (middle === null) {
        // Add that many symbols
        for (i = 0; i < repeatCount; i++) {
            inners.push(makeInner(repeat, font, mode));
        }
    } else {
        // When there is a middle bit, we need the middle part and two repeated
        // sections
        for (i = 0; i < repeatCount; i++) {
            inners.push(makeInner(repeat, font, mode));
        }
        inners.push(makeInner(middle, font, mode));
        for (i = 0; i < repeatCount; i++) {
            inners.push(makeInner(repeat, font, mode));
        }
    }

    // Add the top symbol
    inners.push(makeInner(top, font, mode));

    // Finally, build the vlist
    var inner = buildCommon.makeVList(inners, "bottom", depth, options);

    return styleWrap(
        makeSpan(["delimsizing", "mult"], [inner], options),
        Style.TEXT, options, classes);
};

// There are three kinds of delimiters, delimiters that stack when they become
// too large
var stackLargeDelimiters = [
    "(", ")", "[", "\\lbrack", "]", "\\rbrack",
    "\\{", "\\lbrace", "\\}", "\\rbrace",
    "\\lfloor", "\\rfloor", "\\lceil", "\\rceil",
    "\\surd"
];

// delimiters that always stack
var stackAlwaysDelimiters = [
    "\\uparrow", "\\downarrow", "\\updownarrow",
    "\\Uparrow", "\\Downarrow", "\\Updownarrow",
    "|", "\\|", "\\vert", "\\Vert",
    "\\lvert", "\\rvert", "\\lVert", "\\rVert",
    "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache"
];

// and delimiters that never stack
var stackNeverDelimiters = [
    "<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"
];

// Metrics of the different sizes. Found by looking at TeX's output of
// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.
var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];

/**
 * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
 */
var makeSizedDelim = function(delim, size, options, mode, classes) {
    // < and > turn into \langle and \rangle in delimiters
    if (delim === "<" || delim === "\\lt") {
        delim = "\\langle";
    } else if (delim === ">" || delim === "\\gt") {
        delim = "\\rangle";
    }

    // Sized delimiters are never centered.
    if (utils.contains(stackLargeDelimiters, delim) ||
        utils.contains(stackNeverDelimiters, delim)) {
        return makeLargeDelim(delim, size, false, options, mode, classes);
    } else if (utils.contains(stackAlwaysDelimiters, delim)) {
        return makeStackedDelim(
            delim, sizeToMaxHeight[size], false, options, mode, classes);
    } else {
        throw new ParseError("Illegal delimiter: '" + delim + "'");
    }
};

/**
 * There are three different sequences of delimiter sizes that the delimiters
 * follow depending on the kind of delimiter. This is used when creating custom
 * sized delimiters to decide whether to create a small, large, or stacked
 * delimiter.
 *
 * In real TeX, these sequences aren't explicitly defined, but are instead
 * defined inside the font metrics. Since there are only three sequences that
 * are possible for the delimiters that TeX defines, it is easier to just encode
 * them explicitly here.
 */

// Delimiters that never stack try small delimiters and large delimiters only
var stackNeverDelimiterSequence = [
    {type: "small", style: Style.SCRIPTSCRIPT},
    {type: "small", style: Style.SCRIPT},
    {type: "small", style: Style.TEXT},
    {type: "large", size: 1},
    {type: "large", size: 2},
    {type: "large", size: 3},
    {type: "large", size: 4}
];

// Delimiters that always stack try the small delimiters first, then stack
var stackAlwaysDelimiterSequence = [
    {type: "small", style: Style.SCRIPTSCRIPT},
    {type: "small", style: Style.SCRIPT},
    {type: "small", style: Style.TEXT},
    {type: "stack"}
];

// Delimiters that stack when large try the small and then large delimiters, and
// stack afterwards
var stackLargeDelimiterSequence = [
    {type: "small", style: Style.SCRIPTSCRIPT},
    {type: "small", style: Style.SCRIPT},
    {type: "small", style: Style.TEXT},
    {type: "large", size: 1},
    {type: "large", size: 2},
    {type: "large", size: 3},
    {type: "large", size: 4},
    {type: "stack"}
];

/**
 * Get the font used in a delimiter based on what kind of delimiter it is.
 */
var delimTypeToFont = function(type) {
    if (type.type === "small") {
        return "Main-Regular";
    } else if (type.type === "large") {
        return "Size" + type.size + "-Regular";
    } else if (type.type === "stack") {
        return "Size4-Regular";
    }
};

/**
 * Traverse a sequence of types of delimiters to decide what kind of delimiter
 * should be used to create a delimiter of the given height+depth.
 */
var traverseSequence = function(delim, height, sequence, options) {
    // Here, we choose the index we should start at in the sequences. In smaller
    // sizes (which correspond to larger numbers in style.size) we start earlier
    // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
    // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
    var start = Math.min(2, 3 - options.style.size);
    for (var i = start; i < sequence.length; i++) {
        if (sequence[i].type === "stack") {
            // This is always the last delimiter, so we just break the loop now.
            break;
        }

        var metrics = getMetrics(delim, delimTypeToFont(sequence[i]));
        var heightDepth = metrics.height + metrics.depth;

        // Small delimiters are scaled down versions of the same font, so we
        // account for the style change size.

        if (sequence[i].type === "small") {
            heightDepth *= sequence[i].style.sizeMultiplier;
        }

        // Check if the delimiter at this size works for the given height.
        if (heightDepth > height) {
            return sequence[i];
        }
    }

    // If we reached the end of the sequence, return the last sequence element.
    return sequence[sequence.length - 1];
};

/**
 * Make a delimiter of a given height+depth, with optional centering. Here, we
 * traverse the sequences, and create a delimiter that the sequence tells us to.
 */
var makeCustomSizedDelim = function(delim, height, center, options, mode,
                                    classes) {
    if (delim === "<" || delim === "\\lt") {
        delim = "\\langle";
    } else if (delim === ">" || delim === "\\gt") {
        delim = "\\rangle";
    }

    // Decide what sequence to use
    var sequence;
    if (utils.contains(stackNeverDelimiters, delim)) {
        sequence = stackNeverDelimiterSequence;
    } else if (utils.contains(stackLargeDelimiters, delim)) {
        sequence = stackLargeDelimiterSequence;
    } else {
        sequence = stackAlwaysDelimiterSequence;
    }

    // Look through the sequence
    var delimType = traverseSequence(delim, height, sequence, options);

    // Depending on the sequence element we decided on, call the appropriate
    // function.
    if (delimType.type === "small") {
        return makeSmallDelim(delim, delimType.style, center, options, mode,
                              classes);
    } else if (delimType.type === "large") {
        return makeLargeDelim(delim, delimType.size, center, options, mode,
                              classes);
    } else if (delimType.type === "stack") {
        return makeStackedDelim(delim, height, center, options, mode, classes);
    }
};

/**
 * Make a delimiter for use with `\left` and `\right`, given a height and depth
 * of an expression that the delimiters surround.
 */
var makeLeftRightDelim = function(delim, height, depth, options, mode,
                                  classes) {
    // We always center \left/\right delimiters, so the axis is always shifted
    var axisHeight =
        options.style.metrics.axisHeight * options.style.sizeMultiplier;

    // Taken from TeX source, tex.web, function make_left_right
    var delimiterFactor = 901;
    var delimiterExtend = 5.0 / fontMetrics.metrics.ptPerEm;

    var maxDistFromAxis = Math.max(
        height - axisHeight, depth + axisHeight);

    var totalHeight = Math.max(
        // In real TeX, calculations are done using integral values which are
        // 65536 per pt, or 655360 per em. So, the division here truncates in
        // TeX but doesn't here, producing different results. If we wanted to
        // exactly match TeX's calculation, we could do
        //   Math.floor(655360 * maxDistFromAxis / 500) *
        //    delimiterFactor / 655360
        // (To see the difference, compare
        //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
        // in TeX and KaTeX)
        maxDistFromAxis / 500 * delimiterFactor,
        2 * maxDistFromAxis - delimiterExtend);

    // Finally, we defer to `makeCustomSizedDelim` with our calculated total
    // height
    return makeCustomSizedDelim(delim, totalHeight, true, options, mode,
                                classes);
};

module.exports = {
    sizedDelim: makeSizedDelim,
    customSizedDelim: makeCustomSizedDelim,
    leftRightDelim: makeLeftRightDelim
};

},{"./ParseError":95,"./Style":98,"./buildCommon":99,"./fontMetrics":106,"./symbols":112,"./utils":114}],104:[function(require,module,exports){
/**
 * These objects store the data about the DOM nodes we create, as well as some
 * extra data. They can then be transformed into real DOM nodes with the
 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
 * storing extra properties on the nodes, as well as providing a way to easily
 * work with the DOM.
 *
 * Similar functions for working with MathML nodes exist in mathMLTree.js.
 */
var unicodeRegexes = require("./unicodeRegexes");
var utils = require("./utils");

/**
 * Create an HTML className based on a list of classes. In addition to joining
 * with spaces, we also remove null or empty classes.
 */
var createClass = function(classes) {
    classes = classes.slice();
    for (var i = classes.length - 1; i >= 0; i--) {
        if (!classes[i]) {
            classes.splice(i, 1);
        }
    }

    return classes.join(" ");
};

/**
 * This node represents a span node, with a className, a list of children, and
 * an inline style. It also contains information about its height, depth, and
 * maxFontSize.
 */
function span(classes, children, options) {
    this.classes = classes || [];
    this.children = children || [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
    this.attributes = {};
    if (options) {
        if (options.style.isTight()) {
            this.classes.push("mtight");
        }
        if (options.getColor()) {
            this.style.color = options.getColor();
        }
    }
}

/**
 * Sets an arbitrary attribute on the span. Warning: use this wisely. Not all
 * browsers support attributes the same, and having too many custom attributes
 * is probably bad.
 */
span.prototype.setAttribute = function(attribute, value) {
    this.attributes[attribute] = value;
};

span.prototype.tryCombine = function(sibling) {
    return false;
};

/**
 * Convert the span into an HTML node
 */
span.prototype.toNode = function() {
    var span = document.createElement("span");

    // Apply the class
    span.className = createClass(this.classes);

    // Apply inline styles
    for (var style in this.style) {
        if (Object.prototype.hasOwnProperty.call(this.style, style)) {
            span.style[style] = this.style[style];
        }
    }

    // Apply attributes
    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            span.setAttribute(attr, this.attributes[attr]);
        }
    }

    // Append the children, also as HTML nodes
    for (var i = 0; i < this.children.length; i++) {
        span.appendChild(this.children[i].toNode());
    }

    return span;
};

/**
 * Convert the span into an HTML markup string
 */
span.prototype.toMarkup = function() {
    var markup = "<span";

    // Add the class
    if (this.classes.length) {
        markup += " class=\"";
        markup += utils.escape(createClass(this.classes));
        markup += "\"";
    }

    var styles = "";

    // Add the styles, after hyphenation
    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
    }

    if (styles) {
        markup += " style=\"" + utils.escape(styles) + "\"";
    }

    // Add the attributes
    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "=\"";
            markup += utils.escape(this.attributes[attr]);
            markup += "\"";
        }
    }

    markup += ">";

    // Add the markup of the children, also as markup
    for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
    }

    markup += "</span>";

    return markup;
};

/**
 * This node represents a document fragment, which contains elements, but when
 * placed into the DOM doesn't have any representation itself. Thus, it only
 * contains children and doesn't have any HTML properties. It also keeps track
 * of a height, depth, and maxFontSize.
 */
function documentFragment(children) {
    this.children = children || [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
}

/**
 * Convert the fragment into a node
 */
documentFragment.prototype.toNode = function() {
    // Create a fragment
    var frag = document.createDocumentFragment();

    // Append the children
    for (var i = 0; i < this.children.length; i++) {
        frag.appendChild(this.children[i].toNode());
    }

    return frag;
};

/**
 * Convert the fragment into HTML markup
 */
documentFragment.prototype.toMarkup = function() {
    var markup = "";

    // Simply concatenate the markup for the children together
    for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
    }

    return markup;
};

var iCombinations = {
    '': '\u0131\u0302',
    '': '\u0131\u0308',
    '': '\u0131\u0301',
    // '': '\u0131\u0304', // enable when we add Extended Latin
    '': '\u0131\u0300'
};

/**
 * A symbol node contains information about a single symbol. It either renders
 * to a single text node, or a span with a single text node in it, depending on
 * whether it has CSS classes, styles, or needs italic correction.
 */
function symbolNode(value, height, depth, italic, skew, classes, style) {
    this.value = value || "";
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.classes = classes || [];
    this.style = style || {};
    this.maxFontSize = 0;

    // Mark CJK characters with specific classes so that we can specify which
    // fonts to use.  This allows us to render these characters with a serif
    // font in situations where the browser would either default to a sans serif
    // or render a placeholder character.
    if (unicodeRegexes.cjkRegex.test(value)) {
        // I couldn't find any fonts that contained Hangul as well as all of
        // the other characters we wanted to test there for it gets its own
        // CSS class.
        if (unicodeRegexes.hangulRegex.test(value)) {
            this.classes.push('hangul_fallback');
        } else {
            this.classes.push('cjk_fallback');
        }
    }

    if (/[]/.test(this.value)) {    // add  when we add Extended Latin
        this.value = iCombinations[this.value];
    }
}

symbolNode.prototype.tryCombine = function(sibling) {
    if (!sibling
        || !(sibling instanceof symbolNode)
        || this.italic > 0
        || createClass(this.classes) !== createClass(sibling.classes)
        || this.skew !== sibling.skew
        || this.maxFontSize !== sibling.maxFontSize) {
        return false;
    }
    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)
            && this.style[style] !== sibling.style[style]) {
            return false;
        }
    }
    for (style in sibling.style) {
        if (sibling.style.hasOwnProperty(style)
            && this.style[style] !== sibling.style[style]) {
            return false;
        }
    }
    this.value += sibling.value;
    this.height = Math.max(this.height, sibling.height);
    this.depth = Math.max(this.depth, sibling.depth);
    this.italic = sibling.italic;
    return true;
};

/**
 * Creates a text node or span from a symbol node. Note that a span is only
 * created if it is needed.
 */
symbolNode.prototype.toNode = function() {
    var node = document.createTextNode(this.value);
    var span = null;

    if (this.italic > 0) {
        span = document.createElement("span");
        span.style.marginRight = this.italic + "em";
    }

    if (this.classes.length > 0) {
        span = span || document.createElement("span");
        span.className = createClass(this.classes);
    }

    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
            span = span || document.createElement("span");
            span.style[style] = this.style[style];
        }
    }

    if (span) {
        span.appendChild(node);
        return span;
    } else {
        return node;
    }
};

/**
 * Creates markup for a symbol node.
 */
symbolNode.prototype.toMarkup = function() {
    // TODO(alpert): More duplication than I'd like from
    // span.prototype.toMarkup and symbolNode.prototype.toNode...
    var needsSpan = false;

    var markup = "<span";

    if (this.classes.length) {
        needsSpan = true;
        markup += " class=\"";
        markup += utils.escape(createClass(this.classes));
        markup += "\"";
    }

    var styles = "";

    if (this.italic > 0) {
        styles += "margin-right:" + this.italic + "em;";
    }
    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
    }

    if (styles) {
        needsSpan = true;
        markup += " style=\"" + utils.escape(styles) + "\"";
    }

    var escaped = utils.escape(this.value);
    if (needsSpan) {
        markup += ">";
        markup += escaped;
        markup += "</span>";
        return markup;
    } else {
        return escaped;
    }
};

module.exports = {
    span: span,
    documentFragment: documentFragment,
    symbolNode: symbolNode
};

},{"./unicodeRegexes":113,"./utils":114}],105:[function(require,module,exports){
/* eslint no-constant-condition:0 */
var parseData = require("./parseData");
var ParseError = require("./ParseError");
var Style = require("./Style");

var ParseNode = parseData.ParseNode;

/**
 * Parse the body of the environment, with rows delimited by \\ and
 * columns delimited by &, and create a nested list in row-major order
 * with one group per cell.
 */
function parseArray(parser, result) {
    var row = [];
    var body = [row];
    var rowGaps = [];
    while (true) {
        var cell = parser.parseExpression(false, null);
        row.push(new ParseNode("ordgroup", cell, parser.mode));
        var next = parser.nextToken.text;
        if (next === "&") {
            parser.consume();
        } else if (next === "\\end") {
            break;
        } else if (next === "\\\\" || next === "\\cr") {
            var cr = parser.parseFunction();
            rowGaps.push(cr.value.size);
            row = [];
            body.push(row);
        } else {
            throw new ParseError("Expected & or \\\\ or \\end",
                                 parser.nextToken);
        }
    }
    result.body = body;
    result.rowGaps = rowGaps;
    return new ParseNode(result.type, result, parser.mode);
}

/*
 * An environment definition is very similar to a function definition:
 * it is declared with a name or a list of names, a set of properties
 * and a handler containing the actual implementation.
 *
 * The properties include:
 *  - numArgs: The number of arguments after the \begin{name} function.
 *  - argTypes: (optional) Just like for a function
 *  - allowedInText: (optional) Whether or not the environment is allowed inside
 *                   text mode (default false) (not enforced yet)
 *  - numOptionalArgs: (optional) Just like for a function
 * A bare number instead of that object indicates the numArgs value.
 *
 * The handler function will receive two arguments
 *  - context: information and references provided by the parser
 *  - args: an array of arguments passed to \begin{name}
 * The context contains the following properties:
 *  - envName: the name of the environment, one of the listed names.
 *  - parser: the parser object
 *  - lexer: the lexer object
 *  - positions: the positions associated with these arguments from args.
 * The handler must return a ParseResult.
 */

function defineEnvironment(names, props, handler) {
    if (typeof names === "string") {
        names = [names];
    }
    if (typeof props === "number") {
        props = { numArgs: props };
    }
    // Set default values of environments
    var data = {
        numArgs: props.numArgs || 0,
        argTypes: props.argTypes,
        greediness: 1,
        allowedInText: !!props.allowedInText,
        numOptionalArgs: props.numOptionalArgs || 0,
        handler: handler
    };
    for (var i = 0; i < names.length; ++i) {
        module.exports[names[i]] = data;
    }
}

// Arrays are part of LaTeX, defined in lttab.dtx so its documentation
// is part of the source2e.pdf file of LaTeX2e source documentation.
defineEnvironment("array", {
    numArgs: 1
}, function(context, args) {
    var colalign = args[0];
    colalign = colalign.value.map ? colalign.value : [colalign];
    var cols = colalign.map(function(node) {
        var ca = node.value;
        if ("lcr".indexOf(ca) !== -1) {
            return {
                type: "align",
                align: ca
            };
        } else if (ca === "|") {
            return {
                type: "separator",
                separator: "|"
            };
        }
        throw new ParseError(
            "Unknown column alignment: " + node.value,
            node);
    });
    var res = {
        type: "array",
        cols: cols,
        hskipBeforeAndAfter: true // \@preamble in lttab.dtx
    };
    res = parseArray(context.parser, res);
    return res;
});

// The matrix environments of amsmath builds on the array environment
// of LaTeX, which is discussed above.
defineEnvironment([
    "matrix",
    "pmatrix",
    "bmatrix",
    "Bmatrix",
    "vmatrix",
    "Vmatrix"
], {
}, function(context) {
    var delimiters = {
        "matrix": null,
        "pmatrix": ["(", ")"],
        "bmatrix": ["[", "]"],
        "Bmatrix": ["\\{", "\\}"],
        "vmatrix": ["|", "|"],
        "Vmatrix": ["\\Vert", "\\Vert"]
    }[context.envName];
    var res = {
        type: "array",
        hskipBeforeAndAfter: false // \hskip -\arraycolsep in amsmath
    };
    res = parseArray(context.parser, res);
    if (delimiters) {
        res = new ParseNode("leftright", {
            body: [res],
            left: delimiters[0],
            right: delimiters[1]
        }, context.mode);
    }
    return res;
});

// A cases environment (in amsmath.sty) is almost equivalent to
// \def\arraystretch{1.2}%
// \left\{\begin{array}{@{}l@{\quad}l@{}}  \end{array}\right.
defineEnvironment("cases", {
}, function(context) {
    var res = {
        type: "array",
        arraystretch: 1.2,
        cols: [{
            type: "align",
            align: "l",
            pregap: 0,
            // TODO(kevinb) get the current style.
            // For now we use the metrics for TEXT style which is what we were
            // doing before.  Before attempting to get the current style we
            // should look at TeX's behavior especially for \over and matrices.
            postgap: Style.TEXT.metrics.quad
        }, {
            type: "align",
            align: "l",
            pregap: 0,
            postgap: 0
        }]
    };
    res = parseArray(context.parser, res);
    res = new ParseNode("leftright", {
        body: [res],
        left: "\\{",
        right: "."
    }, context.mode);
    return res;
});

// An aligned environment is like the align* environment
// except it operates within math mode.
// Note that we assume \nomallineskiplimit to be zero,
// so that \strut@ is the same as \strut.
defineEnvironment("aligned", {
}, function(context) {
    var res = {
        type: "array",
        cols: []
    };
    res = parseArray(context.parser, res);
    var emptyGroup = new ParseNode("ordgroup", [], context.mode);
    var numCols = 0;
    res.value.body.forEach(function(row) {
        var i;
        for (i = 1; i < row.length; i += 2) {
            row[i].value.unshift(emptyGroup);
        }
        if (numCols < row.length) {
            numCols = row.length;
        }
    });
    for (var i = 0; i < numCols; ++i) {
        var align = "r";
        var pregap = 0;
        if (i % 2 === 1) {
            align = "l";
        } else if (i > 0) {
            pregap = 2; // one \qquad between columns
        }
        res.value.cols[i] = {
            type: "align",
            align: align,
            pregap: pregap,
            postgap: 0
        };
    }
    return res;
});

},{"./ParseError":95,"./Style":98,"./parseData":110}],106:[function(require,module,exports){
/* eslint no-unused-vars:0 */

var Style = require("./Style");
var cjkRegex = require("./unicodeRegexes").cjkRegex;

/**
 * This file contains metrics regarding fonts and individual symbols. The sigma
 * and xi variables, as well as the metricMap map contain data extracted from
 * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
 * `metrics` variable and the getCharacterMetrics function.
 */

// In TeX, there are actually three sets of dimensions, one for each of
// textstyle, scriptstyle, and scriptscriptstyle.  These are provided in the
// the arrays below, in that order.
//
// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respsectively.
// This was determined by running the folllowing script:
//
//     latex -interaction=nonstopmode \
//     '\documentclass{article}\usepackage{amsmath}\begin{document}' \
//     '$a$ \expandafter\show\the\textfont2' \
//     '\expandafter\show\the\scriptfont2' \
//     '\expandafter\show\the\scriptscriptfont2' \
//     '\stop'
//
// The metrics themselves were retreived using the following commands:
//
//     tftopl cmsy10
//     tftopl cmsy7
//     tftopl cmsy5
//
// The output of each of these commands is quite lengthy.  The only part we
// care about is the FONTDIMEN section. Each value is measured in EMs.
var sigmas = {
    slant: [0.250, 0.250, 0.250],       // sigma1
    space: [0.000, 0.000, 0.000],       // sigma2
    stretch: [0.000, 0.000, 0.000],     // sigma3
    shrink: [0.000, 0.000, 0.000],      // sigma4
    xHeight: [0.431, 0.431, 0.431],     // sigma5
    quad: [1.000, 1.171, 1.472],        // sigma6
    extraSpace: [0.000, 0.000, 0.000],  // sigma7
    num1: [0.677, 0.732, 0.925],        // sigma8
    num2: [0.394, 0.384, 0.387],        // sigma9
    num3: [0.444, 0.471, 0.504],        // sigma10
    denom1: [0.686, 0.752, 1.025],      // sigma11
    denom2: [0.345, 0.344, 0.532],      // sigma12
    sup1: [0.413, 0.503, 0.504],        // sigma13
    sup2: [0.363, 0.431, 0.404],        // sigma14
    sup3: [0.289, 0.286, 0.294],        // sigma15
    sub1: [0.150, 0.143, 0.200],        // sigma16
    sub2: [0.247, 0.286, 0.400],        // sigma17
    supDrop: [0.386, 0.353, 0.494],     // sigma18
    subDrop: [0.050, 0.071, 0.100],     // sigma19
    delim1: [2.390, 1.700, 1.980],      // sigma20
    delim2: [1.010, 1.157, 1.420],      // sigma21
    axisHeight: [0.250, 0.250, 0.250]  // sigma22
};

// These font metrics are extracted from TeX by using
// \font\a=cmex10
// \showthe\fontdimenX\a
// where X is the corresponding variable number. These correspond to the font
// parameters of the extension fonts (family 3). See the TeXbook, page 441.
var xi1 = 0;
var xi2 = 0;
var xi3 = 0;
var xi4 = 0;
var xi5 = 0.431;
var xi6 = 1;
var xi7 = 0;
var xi8 = 0.04;
var xi9 = 0.111;
var xi10 = 0.166;
var xi11 = 0.2;
var xi12 = 0.6;
var xi13 = 0.1;

// This value determines how large a pt is, for metrics which are defined in
// terms of pts.
// This value is also used in katex.less; if you change it make sure the values
// match.
var ptPerEm = 10.0;

// The space between adjacent `|` columns in an array definition. From
// `\showthe\doublerulesep` in LaTeX.
var doubleRuleSep = 2.0 / ptPerEm;

/**
 * This is just a mapping from common names to real metrics
 */
var metrics = {
    defaultRuleThickness: xi8,
    bigOpSpacing1: xi9,
    bigOpSpacing2: xi10,
    bigOpSpacing3: xi11,
    bigOpSpacing4: xi12,
    bigOpSpacing5: xi13,
    ptPerEm: ptPerEm,
    doubleRuleSep: doubleRuleSep
};

// This map contains a mapping from font name and character code to character
// metrics, including height, depth, italic correction, and skew (kern from the
// character to the corresponding \skewchar)
// This map is generated via `make metrics`. It should not be changed manually.
var metricMap = require("./fontMetricsData");

// These are very rough approximations.  We default to Times New Roman which
// should have Latin-1 and Cyrillic characters, but may not depending on the
// operating system.  The metrics do not account for extra height from the
// accents.  In the case of Cyrillic characters which have both ascenders and
// descenders we prefer approximations with ascenders, primarily to prevent
// the fraction bar or root line from intersecting the glyph.
// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.
var extraCharacterMap = {
    // Latin-1
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'C',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'D',
    '': 'N',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'Y',
    '': 'o',
    '': 'B',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'c',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'd',
    '': 'n',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'y',
    '': 'o',
    '': 'y',

    // Cyrillic
    '': 'A',
    '': 'B',
    '': 'B',
    '': 'F',
    '': 'A',
    '': 'E',
    '': 'K',
    '': '3',
    '': 'N',
    '': 'N',
    '': 'K',
    '': 'N',
    '': 'M',
    '': 'H',
    '': 'O',
    '': 'N',
    '': 'P',
    '': 'C',
    '': 'T',
    '': 'y',
    '': 'O',
    '': 'X',
    '': 'U',
    '': 'h',
    '': 'W',
    '': 'W',
    '': 'B',
    '': 'X',
    '': 'B',
    '': '3',
    '': 'X',
    '': 'R',
    '': 'a',
    '': 'b',
    '': 'a',
    '': 'r',
    '': 'y',
    '': 'e',
    '': 'm',
    '': 'e',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'm',
    '': 'n',
    '': 'o',
    '': 'n',
    '': 'p',
    '': 'c',
    '': 'o',
    '': 'y',
    '': 'b',
    '': 'x',
    '': 'n',
    '': 'n',
    '': 'w',
    '': 'w',
    '': 'a',
    '': 'm',
    '': 'a',
    '': 'e',
    '': 'm',
    '': 'r'
};

/**
 * This function is a convenience function for looking up information in the
 * metricMap table. It takes a character as a string, and a style.
 *
 * Note: the `width` property may be undefined if fontMetricsData.js wasn't
 * built using `Make extended_metrics`.
 */
var getCharacterMetrics = function(character, style) {
    var ch = character.charCodeAt(0);
    if (character[0] in extraCharacterMap) {
        ch = extraCharacterMap[character[0]].charCodeAt(0);
    } else if (cjkRegex.test(character[0])) {
        ch = 'M'.charCodeAt(0);
    }
    var metrics = metricMap[style][ch];
    if (metrics) {
        return {
            depth: metrics[0],
            height: metrics[1],
            italic: metrics[2],
            skew: metrics[3],
            width: metrics[4]
        };
    }
};

module.exports = {
    metrics: metrics,
    sigmas: sigmas,
    getCharacterMetrics: getCharacterMetrics
};

},{"./Style":98,"./fontMetricsData":107,"./unicodeRegexes":113}],107:[function(require,module,exports){
module.exports = {
    "AMS-Regular": {
        "65": [0, 0.68889, 0, 0],
        "66": [0, 0.68889, 0, 0],
        "67": [0, 0.68889, 0, 0],
        "68": [0, 0.68889, 0, 0],
        "69": [0, 0.68889, 0, 0],
        "70": [0, 0.68889, 0, 0],
        "71": [0, 0.68889, 0, 0],
        "72": [0, 0.68889, 0, 0],
        "73": [0, 0.68889, 0, 0],
        "74": [0.16667, 0.68889, 0, 0],
        "75": [0, 0.68889, 0, 0],
        "76": [0, 0.68889, 0, 0],
        "77": [0, 0.68889, 0, 0],
        "78": [0, 0.68889, 0, 0],
        "79": [0.16667, 0.68889, 0, 0],
        "80": [0, 0.68889, 0, 0],
        "81": [0.16667, 0.68889, 0, 0],
        "82": [0, 0.68889, 0, 0],
        "83": [0, 0.68889, 0, 0],
        "84": [0, 0.68889, 0, 0],
        "85": [0, 0.68889, 0, 0],
        "86": [0, 0.68889, 0, 0],
        "87": [0, 0.68889, 0, 0],
        "88": [0, 0.68889, 0, 0],
        "89": [0, 0.68889, 0, 0],
        "90": [0, 0.68889, 0, 0],
        "107": [0, 0.68889, 0, 0],
        "165": [0, 0.675, 0.025, 0],
        "174": [0.15559, 0.69224, 0, 0],
        "240": [0, 0.68889, 0, 0],
        "295": [0, 0.68889, 0, 0],
        "710": [0, 0.825, 0, 0],
        "732": [0, 0.9, 0, 0],
        "770": [0, 0.825, 0, 0],
        "771": [0, 0.9, 0, 0],
        "989": [0.08167, 0.58167, 0, 0],
        "1008": [0, 0.43056, 0.04028, 0],
        "8245": [0, 0.54986, 0, 0],
        "8463": [0, 0.68889, 0, 0],
        "8487": [0, 0.68889, 0, 0],
        "8498": [0, 0.68889, 0, 0],
        "8502": [0, 0.68889, 0, 0],
        "8503": [0, 0.68889, 0, 0],
        "8504": [0, 0.68889, 0, 0],
        "8513": [0, 0.68889, 0, 0],
        "8592": [-0.03598, 0.46402, 0, 0],
        "8594": [-0.03598, 0.46402, 0, 0],
        "8602": [-0.13313, 0.36687, 0, 0],
        "8603": [-0.13313, 0.36687, 0, 0],
        "8606": [0.01354, 0.52239, 0, 0],
        "8608": [0.01354, 0.52239, 0, 0],
        "8610": [0.01354, 0.52239, 0, 0],
        "8611": [0.01354, 0.52239, 0, 0],
        "8619": [0, 0.54986, 0, 0],
        "8620": [0, 0.54986, 0, 0],
        "8621": [-0.13313, 0.37788, 0, 0],
        "8622": [-0.13313, 0.36687, 0, 0],
        "8624": [0, 0.69224, 0, 0],
        "8625": [0, 0.69224, 0, 0],
        "8630": [0, 0.43056, 0, 0],
        "8631": [0, 0.43056, 0, 0],
        "8634": [0.08198, 0.58198, 0, 0],
        "8635": [0.08198, 0.58198, 0, 0],
        "8638": [0.19444, 0.69224, 0, 0],
        "8639": [0.19444, 0.69224, 0, 0],
        "8642": [0.19444, 0.69224, 0, 0],
        "8643": [0.19444, 0.69224, 0, 0],
        "8644": [0.1808, 0.675, 0, 0],
        "8646": [0.1808, 0.675, 0, 0],
        "8647": [0.1808, 0.675, 0, 0],
        "8648": [0.19444, 0.69224, 0, 0],
        "8649": [0.1808, 0.675, 0, 0],
        "8650": [0.19444, 0.69224, 0, 0],
        "8651": [0.01354, 0.52239, 0, 0],
        "8652": [0.01354, 0.52239, 0, 0],
        "8653": [-0.13313, 0.36687, 0, 0],
        "8654": [-0.13313, 0.36687, 0, 0],
        "8655": [-0.13313, 0.36687, 0, 0],
        "8666": [0.13667, 0.63667, 0, 0],
        "8667": [0.13667, 0.63667, 0, 0],
        "8669": [-0.13313, 0.37788, 0, 0],
        "8672": [-0.064, 0.437, 0, 0],
        "8674": [-0.064, 0.437, 0, 0],
        "8705": [0, 0.825, 0, 0],
        "8708": [0, 0.68889, 0, 0],
        "8709": [0.08167, 0.58167, 0, 0],
        "8717": [0, 0.43056, 0, 0],
        "8722": [-0.03598, 0.46402, 0, 0],
        "8724": [0.08198, 0.69224, 0, 0],
        "8726": [0.08167, 0.58167, 0, 0],
        "8733": [0, 0.69224, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8737": [0, 0.69224, 0, 0],
        "8738": [0.03517, 0.52239, 0, 0],
        "8739": [0.08167, 0.58167, 0, 0],
        "8740": [0.25142, 0.74111, 0, 0],
        "8741": [0.08167, 0.58167, 0, 0],
        "8742": [0.25142, 0.74111, 0, 0],
        "8756": [0, 0.69224, 0, 0],
        "8757": [0, 0.69224, 0, 0],
        "8764": [-0.13313, 0.36687, 0, 0],
        "8765": [-0.13313, 0.37788, 0, 0],
        "8769": [-0.13313, 0.36687, 0, 0],
        "8770": [-0.03625, 0.46375, 0, 0],
        "8774": [0.30274, 0.79383, 0, 0],
        "8776": [-0.01688, 0.48312, 0, 0],
        "8778": [0.08167, 0.58167, 0, 0],
        "8782": [0.06062, 0.54986, 0, 0],
        "8783": [0.06062, 0.54986, 0, 0],
        "8785": [0.08198, 0.58198, 0, 0],
        "8786": [0.08198, 0.58198, 0, 0],
        "8787": [0.08198, 0.58198, 0, 0],
        "8790": [0, 0.69224, 0, 0],
        "8791": [0.22958, 0.72958, 0, 0],
        "8796": [0.08198, 0.91667, 0, 0],
        "8806": [0.25583, 0.75583, 0, 0],
        "8807": [0.25583, 0.75583, 0, 0],
        "8808": [0.25142, 0.75726, 0, 0],
        "8809": [0.25142, 0.75726, 0, 0],
        "8812": [0.25583, 0.75583, 0, 0],
        "8814": [0.20576, 0.70576, 0, 0],
        "8815": [0.20576, 0.70576, 0, 0],
        "8816": [0.30274, 0.79383, 0, 0],
        "8817": [0.30274, 0.79383, 0, 0],
        "8818": [0.22958, 0.72958, 0, 0],
        "8819": [0.22958, 0.72958, 0, 0],
        "8822": [0.1808, 0.675, 0, 0],
        "8823": [0.1808, 0.675, 0, 0],
        "8828": [0.13667, 0.63667, 0, 0],
        "8829": [0.13667, 0.63667, 0, 0],
        "8830": [0.22958, 0.72958, 0, 0],
        "8831": [0.22958, 0.72958, 0, 0],
        "8832": [0.20576, 0.70576, 0, 0],
        "8833": [0.20576, 0.70576, 0, 0],
        "8840": [0.30274, 0.79383, 0, 0],
        "8841": [0.30274, 0.79383, 0, 0],
        "8842": [0.13597, 0.63597, 0, 0],
        "8843": [0.13597, 0.63597, 0, 0],
        "8847": [0.03517, 0.54986, 0, 0],
        "8848": [0.03517, 0.54986, 0, 0],
        "8858": [0.08198, 0.58198, 0, 0],
        "8859": [0.08198, 0.58198, 0, 0],
        "8861": [0.08198, 0.58198, 0, 0],
        "8862": [0, 0.675, 0, 0],
        "8863": [0, 0.675, 0, 0],
        "8864": [0, 0.675, 0, 0],
        "8865": [0, 0.675, 0, 0],
        "8872": [0, 0.69224, 0, 0],
        "8873": [0, 0.69224, 0, 0],
        "8874": [0, 0.69224, 0, 0],
        "8876": [0, 0.68889, 0, 0],
        "8877": [0, 0.68889, 0, 0],
        "8878": [0, 0.68889, 0, 0],
        "8879": [0, 0.68889, 0, 0],
        "8882": [0.03517, 0.54986, 0, 0],
        "8883": [0.03517, 0.54986, 0, 0],
        "8884": [0.13667, 0.63667, 0, 0],
        "8885": [0.13667, 0.63667, 0, 0],
        "8888": [0, 0.54986, 0, 0],
        "8890": [0.19444, 0.43056, 0, 0],
        "8891": [0.19444, 0.69224, 0, 0],
        "8892": [0.19444, 0.69224, 0, 0],
        "8901": [0, 0.54986, 0, 0],
        "8903": [0.08167, 0.58167, 0, 0],
        "8905": [0.08167, 0.58167, 0, 0],
        "8906": [0.08167, 0.58167, 0, 0],
        "8907": [0, 0.69224, 0, 0],
        "8908": [0, 0.69224, 0, 0],
        "8909": [-0.03598, 0.46402, 0, 0],
        "8910": [0, 0.54986, 0, 0],
        "8911": [0, 0.54986, 0, 0],
        "8912": [0.03517, 0.54986, 0, 0],
        "8913": [0.03517, 0.54986, 0, 0],
        "8914": [0, 0.54986, 0, 0],
        "8915": [0, 0.54986, 0, 0],
        "8916": [0, 0.69224, 0, 0],
        "8918": [0.0391, 0.5391, 0, 0],
        "8919": [0.0391, 0.5391, 0, 0],
        "8920": [0.03517, 0.54986, 0, 0],
        "8921": [0.03517, 0.54986, 0, 0],
        "8922": [0.38569, 0.88569, 0, 0],
        "8923": [0.38569, 0.88569, 0, 0],
        "8926": [0.13667, 0.63667, 0, 0],
        "8927": [0.13667, 0.63667, 0, 0],
        "8928": [0.30274, 0.79383, 0, 0],
        "8929": [0.30274, 0.79383, 0, 0],
        "8934": [0.23222, 0.74111, 0, 0],
        "8935": [0.23222, 0.74111, 0, 0],
        "8936": [0.23222, 0.74111, 0, 0],
        "8937": [0.23222, 0.74111, 0, 0],
        "8938": [0.20576, 0.70576, 0, 0],
        "8939": [0.20576, 0.70576, 0, 0],
        "8940": [0.30274, 0.79383, 0, 0],
        "8941": [0.30274, 0.79383, 0, 0],
        "8994": [0.19444, 0.69224, 0, 0],
        "8995": [0.19444, 0.69224, 0, 0],
        "9416": [0.15559, 0.69224, 0, 0],
        "9484": [0, 0.69224, 0, 0],
        "9488": [0, 0.69224, 0, 0],
        "9492": [0, 0.37788, 0, 0],
        "9496": [0, 0.37788, 0, 0],
        "9585": [0.19444, 0.68889, 0, 0],
        "9586": [0.19444, 0.74111, 0, 0],
        "9632": [0, 0.675, 0, 0],
        "9633": [0, 0.675, 0, 0],
        "9650": [0, 0.54986, 0, 0],
        "9651": [0, 0.54986, 0, 0],
        "9654": [0.03517, 0.54986, 0, 0],
        "9660": [0, 0.54986, 0, 0],
        "9661": [0, 0.54986, 0, 0],
        "9664": [0.03517, 0.54986, 0, 0],
        "9674": [0.11111, 0.69224, 0, 0],
        "9733": [0.19444, 0.69224, 0, 0],
        "10003": [0, 0.69224, 0, 0],
        "10016": [0, 0.69224, 0, 0],
        "10731": [0.11111, 0.69224, 0, 0],
        "10846": [0.19444, 0.75583, 0, 0],
        "10877": [0.13667, 0.63667, 0, 0],
        "10878": [0.13667, 0.63667, 0, 0],
        "10885": [0.25583, 0.75583, 0, 0],
        "10886": [0.25583, 0.75583, 0, 0],
        "10887": [0.13597, 0.63597, 0, 0],
        "10888": [0.13597, 0.63597, 0, 0],
        "10889": [0.26167, 0.75726, 0, 0],
        "10890": [0.26167, 0.75726, 0, 0],
        "10891": [0.48256, 0.98256, 0, 0],
        "10892": [0.48256, 0.98256, 0, 0],
        "10901": [0.13667, 0.63667, 0, 0],
        "10902": [0.13667, 0.63667, 0, 0],
        "10933": [0.25142, 0.75726, 0, 0],
        "10934": [0.25142, 0.75726, 0, 0],
        "10935": [0.26167, 0.75726, 0, 0],
        "10936": [0.26167, 0.75726, 0, 0],
        "10937": [0.26167, 0.75726, 0, 0],
        "10938": [0.26167, 0.75726, 0, 0],
        "10949": [0.25583, 0.75583, 0, 0],
        "10950": [0.25583, 0.75583, 0, 0],
        "10955": [0.28481, 0.79383, 0, 0],
        "10956": [0.28481, 0.79383, 0, 0],
        "57350": [0.08167, 0.58167, 0, 0],
        "57351": [0.08167, 0.58167, 0, 0],
        "57352": [0.08167, 0.58167, 0, 0],
        "57353": [0, 0.43056, 0.04028, 0],
        "57356": [0.25142, 0.75726, 0, 0],
        "57357": [0.25142, 0.75726, 0, 0],
        "57358": [0.41951, 0.91951, 0, 0],
        "57359": [0.30274, 0.79383, 0, 0],
        "57360": [0.30274, 0.79383, 0, 0],
        "57361": [0.41951, 0.91951, 0, 0],
        "57366": [0.25142, 0.75726, 0, 0],
        "57367": [0.25142, 0.75726, 0, 0],
        "57368": [0.25142, 0.75726, 0, 0],
        "57369": [0.25142, 0.75726, 0, 0],
        "57370": [0.13597, 0.63597, 0, 0],
        "57371": [0.13597, 0.63597, 0, 0]
    },
    "Caligraphic-Regular": {
        "48": [0, 0.43056, 0, 0],
        "49": [0, 0.43056, 0, 0],
        "50": [0, 0.43056, 0, 0],
        "51": [0.19444, 0.43056, 0, 0],
        "52": [0.19444, 0.43056, 0, 0],
        "53": [0.19444, 0.43056, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0.19444, 0.43056, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0.19444, 0.43056, 0, 0],
        "65": [0, 0.68333, 0, 0.19445],
        "66": [0, 0.68333, 0.03041, 0.13889],
        "67": [0, 0.68333, 0.05834, 0.13889],
        "68": [0, 0.68333, 0.02778, 0.08334],
        "69": [0, 0.68333, 0.08944, 0.11111],
        "70": [0, 0.68333, 0.09931, 0.11111],
        "71": [0.09722, 0.68333, 0.0593, 0.11111],
        "72": [0, 0.68333, 0.00965, 0.11111],
        "73": [0, 0.68333, 0.07382, 0],
        "74": [0.09722, 0.68333, 0.18472, 0.16667],
        "75": [0, 0.68333, 0.01445, 0.05556],
        "76": [0, 0.68333, 0, 0.13889],
        "77": [0, 0.68333, 0, 0.13889],
        "78": [0, 0.68333, 0.14736, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.11111],
        "80": [0, 0.68333, 0.08222, 0.08334],
        "81": [0.09722, 0.68333, 0, 0.11111],
        "82": [0, 0.68333, 0, 0.08334],
        "83": [0, 0.68333, 0.075, 0.13889],
        "84": [0, 0.68333, 0.25417, 0],
        "85": [0, 0.68333, 0.09931, 0.08334],
        "86": [0, 0.68333, 0.08222, 0],
        "87": [0, 0.68333, 0.08222, 0.08334],
        "88": [0, 0.68333, 0.14643, 0.13889],
        "89": [0.09722, 0.68333, 0.08222, 0.08334],
        "90": [0, 0.68333, 0.07944, 0.13889]
    },
    "Fraktur-Regular": {
        "33": [0, 0.69141, 0, 0],
        "34": [0, 0.69141, 0, 0],
        "38": [0, 0.69141, 0, 0],
        "39": [0, 0.69141, 0, 0],
        "40": [0.24982, 0.74947, 0, 0],
        "41": [0.24982, 0.74947, 0, 0],
        "42": [0, 0.62119, 0, 0],
        "43": [0.08319, 0.58283, 0, 0],
        "44": [0, 0.10803, 0, 0],
        "45": [0.08319, 0.58283, 0, 0],
        "46": [0, 0.10803, 0, 0],
        "47": [0.24982, 0.74947, 0, 0],
        "48": [0, 0.47534, 0, 0],
        "49": [0, 0.47534, 0, 0],
        "50": [0, 0.47534, 0, 0],
        "51": [0.18906, 0.47534, 0, 0],
        "52": [0.18906, 0.47534, 0, 0],
        "53": [0.18906, 0.47534, 0, 0],
        "54": [0, 0.69141, 0, 0],
        "55": [0.18906, 0.47534, 0, 0],
        "56": [0, 0.69141, 0, 0],
        "57": [0.18906, 0.47534, 0, 0],
        "58": [0, 0.47534, 0, 0],
        "59": [0.12604, 0.47534, 0, 0],
        "61": [-0.13099, 0.36866, 0, 0],
        "63": [0, 0.69141, 0, 0],
        "65": [0, 0.69141, 0, 0],
        "66": [0, 0.69141, 0, 0],
        "67": [0, 0.69141, 0, 0],
        "68": [0, 0.69141, 0, 0],
        "69": [0, 0.69141, 0, 0],
        "70": [0.12604, 0.69141, 0, 0],
        "71": [0, 0.69141, 0, 0],
        "72": [0.06302, 0.69141, 0, 0],
        "73": [0, 0.69141, 0, 0],
        "74": [0.12604, 0.69141, 0, 0],
        "75": [0, 0.69141, 0, 0],
        "76": [0, 0.69141, 0, 0],
        "77": [0, 0.69141, 0, 0],
        "78": [0, 0.69141, 0, 0],
        "79": [0, 0.69141, 0, 0],
        "80": [0.18906, 0.69141, 0, 0],
        "81": [0.03781, 0.69141, 0, 0],
        "82": [0, 0.69141, 0, 0],
        "83": [0, 0.69141, 0, 0],
        "84": [0, 0.69141, 0, 0],
        "85": [0, 0.69141, 0, 0],
        "86": [0, 0.69141, 0, 0],
        "87": [0, 0.69141, 0, 0],
        "88": [0, 0.69141, 0, 0],
        "89": [0.18906, 0.69141, 0, 0],
        "90": [0.12604, 0.69141, 0, 0],
        "91": [0.24982, 0.74947, 0, 0],
        "93": [0.24982, 0.74947, 0, 0],
        "94": [0, 0.69141, 0, 0],
        "97": [0, 0.47534, 0, 0],
        "98": [0, 0.69141, 0, 0],
        "99": [0, 0.47534, 0, 0],
        "100": [0, 0.62119, 0, 0],
        "101": [0, 0.47534, 0, 0],
        "102": [0.18906, 0.69141, 0, 0],
        "103": [0.18906, 0.47534, 0, 0],
        "104": [0.18906, 0.69141, 0, 0],
        "105": [0, 0.69141, 0, 0],
        "106": [0, 0.69141, 0, 0],
        "107": [0, 0.69141, 0, 0],
        "108": [0, 0.69141, 0, 0],
        "109": [0, 0.47534, 0, 0],
        "110": [0, 0.47534, 0, 0],
        "111": [0, 0.47534, 0, 0],
        "112": [0.18906, 0.52396, 0, 0],
        "113": [0.18906, 0.47534, 0, 0],
        "114": [0, 0.47534, 0, 0],
        "115": [0, 0.47534, 0, 0],
        "116": [0, 0.62119, 0, 0],
        "117": [0, 0.47534, 0, 0],
        "118": [0, 0.52396, 0, 0],
        "119": [0, 0.52396, 0, 0],
        "120": [0.18906, 0.47534, 0, 0],
        "121": [0.18906, 0.47534, 0, 0],
        "122": [0.18906, 0.47534, 0, 0],
        "8216": [0, 0.69141, 0, 0],
        "8217": [0, 0.69141, 0, 0],
        "58112": [0, 0.62119, 0, 0],
        "58113": [0, 0.62119, 0, 0],
        "58114": [0.18906, 0.69141, 0, 0],
        "58115": [0.18906, 0.69141, 0, 0],
        "58116": [0.18906, 0.47534, 0, 0],
        "58117": [0, 0.69141, 0, 0],
        "58118": [0, 0.62119, 0, 0],
        "58119": [0, 0.47534, 0, 0]
    },
    "Main-Bold": {
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.13333, 0.63333, 0, 0],
        "44": [0.19444, 0.15556, 0, 0],
        "45": [0, 0.44444, 0, 0],
        "46": [0, 0.15556, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.64444, 0, 0],
        "49": [0, 0.64444, 0, 0],
        "50": [0, 0.64444, 0, 0],
        "51": [0, 0.64444, 0, 0],
        "52": [0, 0.64444, 0, 0],
        "53": [0, 0.64444, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0, 0.64444, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0, 0.64444, 0, 0],
        "58": [0, 0.44444, 0, 0],
        "59": [0.19444, 0.44444, 0, 0],
        "60": [0.08556, 0.58556, 0, 0],
        "61": [-0.10889, 0.39111, 0, 0],
        "62": [0.08556, 0.58556, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.68611, 0, 0],
        "66": [0, 0.68611, 0, 0],
        "67": [0, 0.68611, 0, 0],
        "68": [0, 0.68611, 0, 0],
        "69": [0, 0.68611, 0, 0],
        "70": [0, 0.68611, 0, 0],
        "71": [0, 0.68611, 0, 0],
        "72": [0, 0.68611, 0, 0],
        "73": [0, 0.68611, 0, 0],
        "74": [0, 0.68611, 0, 0],
        "75": [0, 0.68611, 0, 0],
        "76": [0, 0.68611, 0, 0],
        "77": [0, 0.68611, 0, 0],
        "78": [0, 0.68611, 0, 0],
        "79": [0, 0.68611, 0, 0],
        "80": [0, 0.68611, 0, 0],
        "81": [0.19444, 0.68611, 0, 0],
        "82": [0, 0.68611, 0, 0],
        "83": [0, 0.68611, 0, 0],
        "84": [0, 0.68611, 0, 0],
        "85": [0, 0.68611, 0, 0],
        "86": [0, 0.68611, 0.01597, 0],
        "87": [0, 0.68611, 0.01597, 0],
        "88": [0, 0.68611, 0, 0],
        "89": [0, 0.68611, 0.02875, 0],
        "90": [0, 0.68611, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "92": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.31, 0.13444, 0.03194, 0],
        "96": [0, 0.69444, 0, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0, 0.69444, 0.10903, 0],
        "103": [0.19444, 0.44444, 0.01597, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.69444, 0, 0],
        "106": [0.19444, 0.69444, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0, 0],
        "114": [0, 0.44444, 0, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.63492, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.01597, 0],
        "119": [0, 0.44444, 0.01597, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.01597, 0],
        "122": [0, 0.44444, 0, 0],
        "123": [0.25, 0.75, 0, 0],
        "124": [0.25, 0.75, 0, 0],
        "125": [0.25, 0.75, 0, 0],
        "126": [0.35, 0.34444, 0, 0],
        "168": [0, 0.69444, 0, 0],
        "172": [0, 0.44444, 0, 0],
        "175": [0, 0.59611, 0, 0],
        "176": [0, 0.69444, 0, 0],
        "177": [0.13333, 0.63333, 0, 0],
        "180": [0, 0.69444, 0, 0],
        "215": [0.13333, 0.63333, 0, 0],
        "247": [0.13333, 0.63333, 0, 0],
        "305": [0, 0.44444, 0, 0],
        "567": [0.19444, 0.44444, 0, 0],
        "710": [0, 0.69444, 0, 0],
        "711": [0, 0.63194, 0, 0],
        "713": [0, 0.59611, 0, 0],
        "714": [0, 0.69444, 0, 0],
        "715": [0, 0.69444, 0, 0],
        "728": [0, 0.69444, 0, 0],
        "729": [0, 0.69444, 0, 0],
        "730": [0, 0.69444, 0, 0],
        "732": [0, 0.69444, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.69444, 0, 0],
        "772": [0, 0.59611, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.69444, 0, 0],
        "776": [0, 0.69444, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.63194, 0, 0],
        "824": [0.19444, 0.69444, 0, 0],
        "915": [0, 0.68611, 0, 0],
        "916": [0, 0.68611, 0, 0],
        "920": [0, 0.68611, 0, 0],
        "923": [0, 0.68611, 0, 0],
        "926": [0, 0.68611, 0, 0],
        "928": [0, 0.68611, 0, 0],
        "931": [0, 0.68611, 0, 0],
        "933": [0, 0.68611, 0, 0],
        "934": [0, 0.68611, 0, 0],
        "936": [0, 0.68611, 0, 0],
        "937": [0, 0.68611, 0, 0],
        "8211": [0, 0.44444, 0.03194, 0],
        "8212": [0, 0.44444, 0.03194, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0],
        "8224": [0.19444, 0.69444, 0, 0],
        "8225": [0.19444, 0.69444, 0, 0],
        "8242": [0, 0.55556, 0, 0],
        "8407": [0, 0.72444, 0.15486, 0],
        "8463": [0, 0.69444, 0, 0],
        "8465": [0, 0.69444, 0, 0],
        "8467": [0, 0.69444, 0, 0],
        "8472": [0.19444, 0.44444, 0, 0],
        "8476": [0, 0.69444, 0, 0],
        "8501": [0, 0.69444, 0, 0],
        "8592": [-0.10889, 0.39111, 0, 0],
        "8593": [0.19444, 0.69444, 0, 0],
        "8594": [-0.10889, 0.39111, 0, 0],
        "8595": [0.19444, 0.69444, 0, 0],
        "8596": [-0.10889, 0.39111, 0, 0],
        "8597": [0.25, 0.75, 0, 0],
        "8598": [0.19444, 0.69444, 0, 0],
        "8599": [0.19444, 0.69444, 0, 0],
        "8600": [0.19444, 0.69444, 0, 0],
        "8601": [0.19444, 0.69444, 0, 0],
        "8636": [-0.10889, 0.39111, 0, 0],
        "8637": [-0.10889, 0.39111, 0, 0],
        "8640": [-0.10889, 0.39111, 0, 0],
        "8641": [-0.10889, 0.39111, 0, 0],
        "8656": [-0.10889, 0.39111, 0, 0],
        "8657": [0.19444, 0.69444, 0, 0],
        "8658": [-0.10889, 0.39111, 0, 0],
        "8659": [0.19444, 0.69444, 0, 0],
        "8660": [-0.10889, 0.39111, 0, 0],
        "8661": [0.25, 0.75, 0, 0],
        "8704": [0, 0.69444, 0, 0],
        "8706": [0, 0.69444, 0.06389, 0],
        "8707": [0, 0.69444, 0, 0],
        "8709": [0.05556, 0.75, 0, 0],
        "8711": [0, 0.68611, 0, 0],
        "8712": [0.08556, 0.58556, 0, 0],
        "8715": [0.08556, 0.58556, 0, 0],
        "8722": [0.13333, 0.63333, 0, 0],
        "8723": [0.13333, 0.63333, 0, 0],
        "8725": [0.25, 0.75, 0, 0],
        "8726": [0.25, 0.75, 0, 0],
        "8727": [-0.02778, 0.47222, 0, 0],
        "8728": [-0.02639, 0.47361, 0, 0],
        "8729": [-0.02639, 0.47361, 0, 0],
        "8730": [0.18, 0.82, 0, 0],
        "8733": [0, 0.44444, 0, 0],
        "8734": [0, 0.44444, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8739": [0.25, 0.75, 0, 0],
        "8741": [0.25, 0.75, 0, 0],
        "8743": [0, 0.55556, 0, 0],
        "8744": [0, 0.55556, 0, 0],
        "8745": [0, 0.55556, 0, 0],
        "8746": [0, 0.55556, 0, 0],
        "8747": [0.19444, 0.69444, 0.12778, 0],
        "8764": [-0.10889, 0.39111, 0, 0],
        "8768": [0.19444, 0.69444, 0, 0],
        "8771": [0.00222, 0.50222, 0, 0],
        "8776": [0.02444, 0.52444, 0, 0],
        "8781": [0.00222, 0.50222, 0, 0],
        "8801": [0.00222, 0.50222, 0, 0],
        "8804": [0.19667, 0.69667, 0, 0],
        "8805": [0.19667, 0.69667, 0, 0],
        "8810": [0.08556, 0.58556, 0, 0],
        "8811": [0.08556, 0.58556, 0, 0],
        "8826": [0.08556, 0.58556, 0, 0],
        "8827": [0.08556, 0.58556, 0, 0],
        "8834": [0.08556, 0.58556, 0, 0],
        "8835": [0.08556, 0.58556, 0, 0],
        "8838": [0.19667, 0.69667, 0, 0],
        "8839": [0.19667, 0.69667, 0, 0],
        "8846": [0, 0.55556, 0, 0],
        "8849": [0.19667, 0.69667, 0, 0],
        "8850": [0.19667, 0.69667, 0, 0],
        "8851": [0, 0.55556, 0, 0],
        "8852": [0, 0.55556, 0, 0],
        "8853": [0.13333, 0.63333, 0, 0],
        "8854": [0.13333, 0.63333, 0, 0],
        "8855": [0.13333, 0.63333, 0, 0],
        "8856": [0.13333, 0.63333, 0, 0],
        "8857": [0.13333, 0.63333, 0, 0],
        "8866": [0, 0.69444, 0, 0],
        "8867": [0, 0.69444, 0, 0],
        "8868": [0, 0.69444, 0, 0],
        "8869": [0, 0.69444, 0, 0],
        "8900": [-0.02639, 0.47361, 0, 0],
        "8901": [-0.02639, 0.47361, 0, 0],
        "8902": [-0.02778, 0.47222, 0, 0],
        "8968": [0.25, 0.75, 0, 0],
        "8969": [0.25, 0.75, 0, 0],
        "8970": [0.25, 0.75, 0, 0],
        "8971": [0.25, 0.75, 0, 0],
        "8994": [-0.13889, 0.36111, 0, 0],
        "8995": [-0.13889, 0.36111, 0, 0],
        "9651": [0.19444, 0.69444, 0, 0],
        "9657": [-0.02778, 0.47222, 0, 0],
        "9661": [0.19444, 0.69444, 0, 0],
        "9667": [-0.02778, 0.47222, 0, 0],
        "9711": [0.19444, 0.69444, 0, 0],
        "9824": [0.12963, 0.69444, 0, 0],
        "9825": [0.12963, 0.69444, 0, 0],
        "9826": [0.12963, 0.69444, 0, 0],
        "9827": [0.12963, 0.69444, 0, 0],
        "9837": [0, 0.75, 0, 0],
        "9838": [0.19444, 0.69444, 0, 0],
        "9839": [0.19444, 0.69444, 0, 0],
        "10216": [0.25, 0.75, 0, 0],
        "10217": [0.25, 0.75, 0, 0],
        "10815": [0, 0.68611, 0, 0],
        "10927": [0.19667, 0.69667, 0, 0],
        "10928": [0.19667, 0.69667, 0, 0]
    },
    "Main-Italic": {
        "33": [0, 0.69444, 0.12417, 0],
        "34": [0, 0.69444, 0.06961, 0],
        "35": [0.19444, 0.69444, 0.06616, 0],
        "37": [0.05556, 0.75, 0.13639, 0],
        "38": [0, 0.69444, 0.09694, 0],
        "39": [0, 0.69444, 0.12417, 0],
        "40": [0.25, 0.75, 0.16194, 0],
        "41": [0.25, 0.75, 0.03694, 0],
        "42": [0, 0.75, 0.14917, 0],
        "43": [0.05667, 0.56167, 0.03694, 0],
        "44": [0.19444, 0.10556, 0, 0],
        "45": [0, 0.43056, 0.02826, 0],
        "46": [0, 0.10556, 0, 0],
        "47": [0.25, 0.75, 0.16194, 0],
        "48": [0, 0.64444, 0.13556, 0],
        "49": [0, 0.64444, 0.13556, 0],
        "50": [0, 0.64444, 0.13556, 0],
        "51": [0, 0.64444, 0.13556, 0],
        "52": [0.19444, 0.64444, 0.13556, 0],
        "53": [0, 0.64444, 0.13556, 0],
        "54": [0, 0.64444, 0.13556, 0],
        "55": [0.19444, 0.64444, 0.13556, 0],
        "56": [0, 0.64444, 0.13556, 0],
        "57": [0, 0.64444, 0.13556, 0],
        "58": [0, 0.43056, 0.0582, 0],
        "59": [0.19444, 0.43056, 0.0582, 0],
        "61": [-0.13313, 0.36687, 0.06616, 0],
        "63": [0, 0.69444, 0.1225, 0],
        "64": [0, 0.69444, 0.09597, 0],
        "65": [0, 0.68333, 0, 0],
        "66": [0, 0.68333, 0.10257, 0],
        "67": [0, 0.68333, 0.14528, 0],
        "68": [0, 0.68333, 0.09403, 0],
        "69": [0, 0.68333, 0.12028, 0],
        "70": [0, 0.68333, 0.13305, 0],
        "71": [0, 0.68333, 0.08722, 0],
        "72": [0, 0.68333, 0.16389, 0],
        "73": [0, 0.68333, 0.15806, 0],
        "74": [0, 0.68333, 0.14028, 0],
        "75": [0, 0.68333, 0.14528, 0],
        "76": [0, 0.68333, 0, 0],
        "77": [0, 0.68333, 0.16389, 0],
        "78": [0, 0.68333, 0.16389, 0],
        "79": [0, 0.68333, 0.09403, 0],
        "80": [0, 0.68333, 0.10257, 0],
        "81": [0.19444, 0.68333, 0.09403, 0],
        "82": [0, 0.68333, 0.03868, 0],
        "83": [0, 0.68333, 0.11972, 0],
        "84": [0, 0.68333, 0.13305, 0],
        "85": [0, 0.68333, 0.16389, 0],
        "86": [0, 0.68333, 0.18361, 0],
        "87": [0, 0.68333, 0.18361, 0],
        "88": [0, 0.68333, 0.15806, 0],
        "89": [0, 0.68333, 0.19383, 0],
        "90": [0, 0.68333, 0.14528, 0],
        "91": [0.25, 0.75, 0.1875, 0],
        "93": [0.25, 0.75, 0.10528, 0],
        "94": [0, 0.69444, 0.06646, 0],
        "95": [0.31, 0.12056, 0.09208, 0],
        "97": [0, 0.43056, 0.07671, 0],
        "98": [0, 0.69444, 0.06312, 0],
        "99": [0, 0.43056, 0.05653, 0],
        "100": [0, 0.69444, 0.10333, 0],
        "101": [0, 0.43056, 0.07514, 0],
        "102": [0.19444, 0.69444, 0.21194, 0],
        "103": [0.19444, 0.43056, 0.08847, 0],
        "104": [0, 0.69444, 0.07671, 0],
        "105": [0, 0.65536, 0.1019, 0],
        "106": [0.19444, 0.65536, 0.14467, 0],
        "107": [0, 0.69444, 0.10764, 0],
        "108": [0, 0.69444, 0.10333, 0],
        "109": [0, 0.43056, 0.07671, 0],
        "110": [0, 0.43056, 0.07671, 0],
        "111": [0, 0.43056, 0.06312, 0],
        "112": [0.19444, 0.43056, 0.06312, 0],
        "113": [0.19444, 0.43056, 0.08847, 0],
        "114": [0, 0.43056, 0.10764, 0],
        "115": [0, 0.43056, 0.08208, 0],
        "116": [0, 0.61508, 0.09486, 0],
        "117": [0, 0.43056, 0.07671, 0],
        "118": [0, 0.43056, 0.10764, 0],
        "119": [0, 0.43056, 0.10764, 0],
        "120": [0, 0.43056, 0.12042, 0],
        "121": [0.19444, 0.43056, 0.08847, 0],
        "122": [0, 0.43056, 0.12292, 0],
        "126": [0.35, 0.31786, 0.11585, 0],
        "163": [0, 0.69444, 0, 0],
        "305": [0, 0.43056, 0, 0.02778],
        "567": [0.19444, 0.43056, 0, 0.08334],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0.09694, 0],
        "770": [0, 0.69444, 0.06646, 0],
        "771": [0, 0.66786, 0.11585, 0],
        "772": [0, 0.56167, 0.10333, 0],
        "774": [0, 0.69444, 0.10806, 0],
        "775": [0, 0.66786, 0.11752, 0],
        "776": [0, 0.66786, 0.10474, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0.1225, 0],
        "780": [0, 0.62847, 0.08295, 0],
        "915": [0, 0.68333, 0.13305, 0],
        "916": [0, 0.68333, 0, 0],
        "920": [0, 0.68333, 0.09403, 0],
        "923": [0, 0.68333, 0, 0],
        "926": [0, 0.68333, 0.15294, 0],
        "928": [0, 0.68333, 0.16389, 0],
        "931": [0, 0.68333, 0.12028, 0],
        "933": [0, 0.68333, 0.11111, 0],
        "934": [0, 0.68333, 0.05986, 0],
        "936": [0, 0.68333, 0.11111, 0],
        "937": [0, 0.68333, 0.10257, 0],
        "8211": [0, 0.43056, 0.09208, 0],
        "8212": [0, 0.43056, 0.09208, 0],
        "8216": [0, 0.69444, 0.12417, 0],
        "8217": [0, 0.69444, 0.12417, 0],
        "8220": [0, 0.69444, 0.1685, 0],
        "8221": [0, 0.69444, 0.06961, 0],
        "8463": [0, 0.68889, 0, 0]
    },
    "Main-Regular": {
        "32": [0, 0, 0, 0],
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.08333, 0.58333, 0, 0],
        "44": [0.19444, 0.10556, 0, 0],
        "45": [0, 0.43056, 0, 0],
        "46": [0, 0.10556, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.64444, 0, 0],
        "49": [0, 0.64444, 0, 0],
        "50": [0, 0.64444, 0, 0],
        "51": [0, 0.64444, 0, 0],
        "52": [0, 0.64444, 0, 0],
        "53": [0, 0.64444, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0, 0.64444, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0, 0.64444, 0, 0],
        "58": [0, 0.43056, 0, 0],
        "59": [0.19444, 0.43056, 0, 0],
        "60": [0.0391, 0.5391, 0, 0],
        "61": [-0.13313, 0.36687, 0, 0],
        "62": [0.0391, 0.5391, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.68333, 0, 0],
        "66": [0, 0.68333, 0, 0],
        "67": [0, 0.68333, 0, 0],
        "68": [0, 0.68333, 0, 0],
        "69": [0, 0.68333, 0, 0],
        "70": [0, 0.68333, 0, 0],
        "71": [0, 0.68333, 0, 0],
        "72": [0, 0.68333, 0, 0],
        "73": [0, 0.68333, 0, 0],
        "74": [0, 0.68333, 0, 0],
        "75": [0, 0.68333, 0, 0],
        "76": [0, 0.68333, 0, 0],
        "77": [0, 0.68333, 0, 0],
        "78": [0, 0.68333, 0, 0],
        "79": [0, 0.68333, 0, 0],
        "80": [0, 0.68333, 0, 0],
        "81": [0.19444, 0.68333, 0, 0],
        "82": [0, 0.68333, 0, 0],
        "83": [0, 0.68333, 0, 0],
        "84": [0, 0.68333, 0, 0],
        "85": [0, 0.68333, 0, 0],
        "86": [0, 0.68333, 0.01389, 0],
        "87": [0, 0.68333, 0.01389, 0],
        "88": [0, 0.68333, 0, 0],
        "89": [0, 0.68333, 0.025, 0],
        "90": [0, 0.68333, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "92": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.31, 0.12056, 0.02778, 0],
        "96": [0, 0.69444, 0, 0],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.43056, 0, 0],
        "102": [0, 0.69444, 0.07778, 0],
        "103": [0.19444, 0.43056, 0.01389, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.66786, 0, 0],
        "106": [0.19444, 0.66786, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0],
        "112": [0.19444, 0.43056, 0, 0],
        "113": [0.19444, 0.43056, 0, 0],
        "114": [0, 0.43056, 0, 0],
        "115": [0, 0.43056, 0, 0],
        "116": [0, 0.61508, 0, 0],
        "117": [0, 0.43056, 0, 0],
        "118": [0, 0.43056, 0.01389, 0],
        "119": [0, 0.43056, 0.01389, 0],
        "120": [0, 0.43056, 0, 0],
        "121": [0.19444, 0.43056, 0.01389, 0],
        "122": [0, 0.43056, 0, 0],
        "123": [0.25, 0.75, 0, 0],
        "124": [0.25, 0.75, 0, 0],
        "125": [0.25, 0.75, 0, 0],
        "126": [0.35, 0.31786, 0, 0],
        "160": [0, 0, 0, 0],
        "168": [0, 0.66786, 0, 0],
        "172": [0, 0.43056, 0, 0],
        "175": [0, 0.56778, 0, 0],
        "176": [0, 0.69444, 0, 0],
        "177": [0.08333, 0.58333, 0, 0],
        "180": [0, 0.69444, 0, 0],
        "215": [0.08333, 0.58333, 0, 0],
        "247": [0.08333, 0.58333, 0, 0],
        "305": [0, 0.43056, 0, 0],
        "567": [0.19444, 0.43056, 0, 0],
        "710": [0, 0.69444, 0, 0],
        "711": [0, 0.62847, 0, 0],
        "713": [0, 0.56778, 0, 0],
        "714": [0, 0.69444, 0, 0],
        "715": [0, 0.69444, 0, 0],
        "728": [0, 0.69444, 0, 0],
        "729": [0, 0.66786, 0, 0],
        "730": [0, 0.69444, 0, 0],
        "732": [0, 0.66786, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.66786, 0, 0],
        "772": [0, 0.56778, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.66786, 0, 0],
        "776": [0, 0.66786, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.62847, 0, 0],
        "824": [0.19444, 0.69444, 0, 0],
        "915": [0, 0.68333, 0, 0],
        "916": [0, 0.68333, 0, 0],
        "920": [0, 0.68333, 0, 0],
        "923": [0, 0.68333, 0, 0],
        "926": [0, 0.68333, 0, 0],
        "928": [0, 0.68333, 0, 0],
        "931": [0, 0.68333, 0, 0],
        "933": [0, 0.68333, 0, 0],
        "934": [0, 0.68333, 0, 0],
        "936": [0, 0.68333, 0, 0],
        "937": [0, 0.68333, 0, 0],
        "8211": [0, 0.43056, 0.02778, 0],
        "8212": [0, 0.43056, 0.02778, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0],
        "8224": [0.19444, 0.69444, 0, 0],
        "8225": [0.19444, 0.69444, 0, 0],
        "8230": [0, 0.12, 0, 0],
        "8242": [0, 0.55556, 0, 0],
        "8407": [0, 0.71444, 0.15382, 0],
        "8463": [0, 0.68889, 0, 0],
        "8465": [0, 0.69444, 0, 0],
        "8467": [0, 0.69444, 0, 0.11111],
        "8472": [0.19444, 0.43056, 0, 0.11111],
        "8476": [0, 0.69444, 0, 0],
        "8501": [0, 0.69444, 0, 0],
        "8592": [-0.13313, 0.36687, 0, 0],
        "8593": [0.19444, 0.69444, 0, 0],
        "8594": [-0.13313, 0.36687, 0, 0],
        "8595": [0.19444, 0.69444, 0, 0],
        "8596": [-0.13313, 0.36687, 0, 0],
        "8597": [0.25, 0.75, 0, 0],
        "8598": [0.19444, 0.69444, 0, 0],
        "8599": [0.19444, 0.69444, 0, 0],
        "8600": [0.19444, 0.69444, 0, 0],
        "8601": [0.19444, 0.69444, 0, 0],
        "8614": [0.011, 0.511, 0, 0],
        "8617": [0.011, 0.511, 0, 0],
        "8618": [0.011, 0.511, 0, 0],
        "8636": [-0.13313, 0.36687, 0, 0],
        "8637": [-0.13313, 0.36687, 0, 0],
        "8640": [-0.13313, 0.36687, 0, 0],
        "8641": [-0.13313, 0.36687, 0, 0],
        "8652": [0.011, 0.671, 0, 0],
        "8656": [-0.13313, 0.36687, 0, 0],
        "8657": [0.19444, 0.69444, 0, 0],
        "8658": [-0.13313, 0.36687, 0, 0],
        "8659": [0.19444, 0.69444, 0, 0],
        "8660": [-0.13313, 0.36687, 0, 0],
        "8661": [0.25, 0.75, 0, 0],
        "8704": [0, 0.69444, 0, 0],
        "8706": [0, 0.69444, 0.05556, 0.08334],
        "8707": [0, 0.69444, 0, 0],
        "8709": [0.05556, 0.75, 0, 0],
        "8711": [0, 0.68333, 0, 0],
        "8712": [0.0391, 0.5391, 0, 0],
        "8715": [0.0391, 0.5391, 0, 0],
        "8722": [0.08333, 0.58333, 0, 0],
        "8723": [0.08333, 0.58333, 0, 0],
        "8725": [0.25, 0.75, 0, 0],
        "8726": [0.25, 0.75, 0, 0],
        "8727": [-0.03472, 0.46528, 0, 0],
        "8728": [-0.05555, 0.44445, 0, 0],
        "8729": [-0.05555, 0.44445, 0, 0],
        "8730": [0.2, 0.8, 0, 0],
        "8733": [0, 0.43056, 0, 0],
        "8734": [0, 0.43056, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8739": [0.25, 0.75, 0, 0],
        "8741": [0.25, 0.75, 0, 0],
        "8743": [0, 0.55556, 0, 0],
        "8744": [0, 0.55556, 0, 0],
        "8745": [0, 0.55556, 0, 0],
        "8746": [0, 0.55556, 0, 0],
        "8747": [0.19444, 0.69444, 0.11111, 0],
        "8764": [-0.13313, 0.36687, 0, 0],
        "8768": [0.19444, 0.69444, 0, 0],
        "8771": [-0.03625, 0.46375, 0, 0],
        "8773": [-0.022, 0.589, 0, 0],
        "8776": [-0.01688, 0.48312, 0, 0],
        "8781": [-0.03625, 0.46375, 0, 0],
        "8784": [-0.133, 0.67, 0, 0],
        "8800": [0.215, 0.716, 0, 0],
        "8801": [-0.03625, 0.46375, 0, 0],
        "8804": [0.13597, 0.63597, 0, 0],
        "8805": [0.13597, 0.63597, 0, 0],
        "8810": [0.0391, 0.5391, 0, 0],
        "8811": [0.0391, 0.5391, 0, 0],
        "8826": [0.0391, 0.5391, 0, 0],
        "8827": [0.0391, 0.5391, 0, 0],
        "8834": [0.0391, 0.5391, 0, 0],
        "8835": [0.0391, 0.5391, 0, 0],
        "8838": [0.13597, 0.63597, 0, 0],
        "8839": [0.13597, 0.63597, 0, 0],
        "8846": [0, 0.55556, 0, 0],
        "8849": [0.13597, 0.63597, 0, 0],
        "8850": [0.13597, 0.63597, 0, 0],
        "8851": [0, 0.55556, 0, 0],
        "8852": [0, 0.55556, 0, 0],
        "8853": [0.08333, 0.58333, 0, 0],
        "8854": [0.08333, 0.58333, 0, 0],
        "8855": [0.08333, 0.58333, 0, 0],
        "8856": [0.08333, 0.58333, 0, 0],
        "8857": [0.08333, 0.58333, 0, 0],
        "8866": [0, 0.69444, 0, 0],
        "8867": [0, 0.69444, 0, 0],
        "8868": [0, 0.69444, 0, 0],
        "8869": [0, 0.69444, 0, 0],
        "8872": [0.249, 0.75, 0, 0],
        "8900": [-0.05555, 0.44445, 0, 0],
        "8901": [-0.05555, 0.44445, 0, 0],
        "8902": [-0.03472, 0.46528, 0, 0],
        "8904": [0.005, 0.505, 0, 0],
        "8942": [0.03, 0.9, 0, 0],
        "8943": [-0.19, 0.31, 0, 0],
        "8945": [-0.1, 0.82, 0, 0],
        "8968": [0.25, 0.75, 0, 0],
        "8969": [0.25, 0.75, 0, 0],
        "8970": [0.25, 0.75, 0, 0],
        "8971": [0.25, 0.75, 0, 0],
        "8994": [-0.14236, 0.35764, 0, 0],
        "8995": [-0.14236, 0.35764, 0, 0],
        "9136": [0.244, 0.744, 0, 0],
        "9137": [0.244, 0.744, 0, 0],
        "9651": [0.19444, 0.69444, 0, 0],
        "9657": [-0.03472, 0.46528, 0, 0],
        "9661": [0.19444, 0.69444, 0, 0],
        "9667": [-0.03472, 0.46528, 0, 0],
        "9711": [0.19444, 0.69444, 0, 0],
        "9824": [0.12963, 0.69444, 0, 0],
        "9825": [0.12963, 0.69444, 0, 0],
        "9826": [0.12963, 0.69444, 0, 0],
        "9827": [0.12963, 0.69444, 0, 0],
        "9837": [0, 0.75, 0, 0],
        "9838": [0.19444, 0.69444, 0, 0],
        "9839": [0.19444, 0.69444, 0, 0],
        "10216": [0.25, 0.75, 0, 0],
        "10217": [0.25, 0.75, 0, 0],
        "10222": [0.244, 0.744, 0, 0],
        "10223": [0.244, 0.744, 0, 0],
        "10229": [0.011, 0.511, 0, 0],
        "10230": [0.011, 0.511, 0, 0],
        "10231": [0.011, 0.511, 0, 0],
        "10232": [0.024, 0.525, 0, 0],
        "10233": [0.024, 0.525, 0, 0],
        "10234": [0.024, 0.525, 0, 0],
        "10236": [0.011, 0.511, 0, 0],
        "10815": [0, 0.68333, 0, 0],
        "10927": [0.13597, 0.63597, 0, 0],
        "10928": [0.13597, 0.63597, 0, 0]
    },
    "Math-BoldItalic": {
        "47": [0.19444, 0.69444, 0, 0],
        "65": [0, 0.68611, 0, 0],
        "66": [0, 0.68611, 0.04835, 0],
        "67": [0, 0.68611, 0.06979, 0],
        "68": [0, 0.68611, 0.03194, 0],
        "69": [0, 0.68611, 0.05451, 0],
        "70": [0, 0.68611, 0.15972, 0],
        "71": [0, 0.68611, 0, 0],
        "72": [0, 0.68611, 0.08229, 0],
        "73": [0, 0.68611, 0.07778, 0],
        "74": [0, 0.68611, 0.10069, 0],
        "75": [0, 0.68611, 0.06979, 0],
        "76": [0, 0.68611, 0, 0],
        "77": [0, 0.68611, 0.11424, 0],
        "78": [0, 0.68611, 0.11424, 0],
        "79": [0, 0.68611, 0.03194, 0],
        "80": [0, 0.68611, 0.15972, 0],
        "81": [0.19444, 0.68611, 0, 0],
        "82": [0, 0.68611, 0.00421, 0],
        "83": [0, 0.68611, 0.05382, 0],
        "84": [0, 0.68611, 0.15972, 0],
        "85": [0, 0.68611, 0.11424, 0],
        "86": [0, 0.68611, 0.25555, 0],
        "87": [0, 0.68611, 0.15972, 0],
        "88": [0, 0.68611, 0.07778, 0],
        "89": [0, 0.68611, 0.25555, 0],
        "90": [0, 0.68611, 0.06979, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0.19444, 0.69444, 0.11042, 0],
        "103": [0.19444, 0.44444, 0.03704, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.69326, 0, 0],
        "106": [0.19444, 0.69326, 0.0622, 0],
        "107": [0, 0.69444, 0.01852, 0],
        "108": [0, 0.69444, 0.0088, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0.03704, 0],
        "114": [0, 0.44444, 0.03194, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.63492, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.03704, 0],
        "119": [0, 0.44444, 0.02778, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.03704, 0],
        "122": [0, 0.44444, 0.04213, 0],
        "915": [0, 0.68611, 0.15972, 0],
        "916": [0, 0.68611, 0, 0],
        "920": [0, 0.68611, 0.03194, 0],
        "923": [0, 0.68611, 0, 0],
        "926": [0, 0.68611, 0.07458, 0],
        "928": [0, 0.68611, 0.08229, 0],
        "931": [0, 0.68611, 0.05451, 0],
        "933": [0, 0.68611, 0.15972, 0],
        "934": [0, 0.68611, 0, 0],
        "936": [0, 0.68611, 0.11653, 0],
        "937": [0, 0.68611, 0.04835, 0],
        "945": [0, 0.44444, 0, 0],
        "946": [0.19444, 0.69444, 0.03403, 0],
        "947": [0.19444, 0.44444, 0.06389, 0],
        "948": [0, 0.69444, 0.03819, 0],
        "949": [0, 0.44444, 0, 0],
        "950": [0.19444, 0.69444, 0.06215, 0],
        "951": [0.19444, 0.44444, 0.03704, 0],
        "952": [0, 0.69444, 0.03194, 0],
        "953": [0, 0.44444, 0, 0],
        "954": [0, 0.44444, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.44444, 0, 0],
        "957": [0, 0.44444, 0.06898, 0],
        "958": [0.19444, 0.69444, 0.03021, 0],
        "959": [0, 0.44444, 0, 0],
        "960": [0, 0.44444, 0.03704, 0],
        "961": [0.19444, 0.44444, 0, 0],
        "962": [0.09722, 0.44444, 0.07917, 0],
        "963": [0, 0.44444, 0.03704, 0],
        "964": [0, 0.44444, 0.13472, 0],
        "965": [0, 0.44444, 0.03704, 0],
        "966": [0.19444, 0.44444, 0, 0],
        "967": [0.19444, 0.44444, 0, 0],
        "968": [0.19444, 0.69444, 0.03704, 0],
        "969": [0, 0.44444, 0.03704, 0],
        "977": [0, 0.69444, 0, 0],
        "981": [0.19444, 0.69444, 0, 0],
        "982": [0, 0.44444, 0.03194, 0],
        "1009": [0.19444, 0.44444, 0, 0],
        "1013": [0, 0.44444, 0, 0]
    },
    "Math-Italic": {
        "47": [0.19444, 0.69444, 0, 0],
        "65": [0, 0.68333, 0, 0.13889],
        "66": [0, 0.68333, 0.05017, 0.08334],
        "67": [0, 0.68333, 0.07153, 0.08334],
        "68": [0, 0.68333, 0.02778, 0.05556],
        "69": [0, 0.68333, 0.05764, 0.08334],
        "70": [0, 0.68333, 0.13889, 0.08334],
        "71": [0, 0.68333, 0, 0.08334],
        "72": [0, 0.68333, 0.08125, 0.05556],
        "73": [0, 0.68333, 0.07847, 0.11111],
        "74": [0, 0.68333, 0.09618, 0.16667],
        "75": [0, 0.68333, 0.07153, 0.05556],
        "76": [0, 0.68333, 0, 0.02778],
        "77": [0, 0.68333, 0.10903, 0.08334],
        "78": [0, 0.68333, 0.10903, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.08334],
        "80": [0, 0.68333, 0.13889, 0.08334],
        "81": [0.19444, 0.68333, 0, 0.08334],
        "82": [0, 0.68333, 0.00773, 0.08334],
        "83": [0, 0.68333, 0.05764, 0.08334],
        "84": [0, 0.68333, 0.13889, 0.08334],
        "85": [0, 0.68333, 0.10903, 0.02778],
        "86": [0, 0.68333, 0.22222, 0],
        "87": [0, 0.68333, 0.13889, 0],
        "88": [0, 0.68333, 0.07847, 0.08334],
        "89": [0, 0.68333, 0.22222, 0],
        "90": [0, 0.68333, 0.07153, 0.08334],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0.05556],
        "100": [0, 0.69444, 0, 0.16667],
        "101": [0, 0.43056, 0, 0.05556],
        "102": [0.19444, 0.69444, 0.10764, 0.16667],
        "103": [0.19444, 0.43056, 0.03588, 0.02778],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.65952, 0, 0],
        "106": [0.19444, 0.65952, 0.05724, 0],
        "107": [0, 0.69444, 0.03148, 0],
        "108": [0, 0.69444, 0.01968, 0.08334],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0.05556],
        "112": [0.19444, 0.43056, 0, 0.08334],
        "113": [0.19444, 0.43056, 0.03588, 0.08334],
        "114": [0, 0.43056, 0.02778, 0.05556],
        "115": [0, 0.43056, 0, 0.05556],
        "116": [0, 0.61508, 0, 0.08334],
        "117": [0, 0.43056, 0, 0.02778],
        "118": [0, 0.43056, 0.03588, 0.02778],
        "119": [0, 0.43056, 0.02691, 0.08334],
        "120": [0, 0.43056, 0, 0.02778],
        "121": [0.19444, 0.43056, 0.03588, 0.05556],
        "122": [0, 0.43056, 0.04398, 0.05556],
        "915": [0, 0.68333, 0.13889, 0.08334],
        "916": [0, 0.68333, 0, 0.16667],
        "920": [0, 0.68333, 0.02778, 0.08334],
        "923": [0, 0.68333, 0, 0.16667],
        "926": [0, 0.68333, 0.07569, 0.08334],
        "928": [0, 0.68333, 0.08125, 0.05556],
        "931": [0, 0.68333, 0.05764, 0.08334],
        "933": [0, 0.68333, 0.13889, 0.05556],
        "934": [0, 0.68333, 0, 0.08334],
        "936": [0, 0.68333, 0.11, 0.05556],
        "937": [0, 0.68333, 0.05017, 0.08334],
        "945": [0, 0.43056, 0.0037, 0.02778],
        "946": [0.19444, 0.69444, 0.05278, 0.08334],
        "947": [0.19444, 0.43056, 0.05556, 0],
        "948": [0, 0.69444, 0.03785, 0.05556],
        "949": [0, 0.43056, 0, 0.08334],
        "950": [0.19444, 0.69444, 0.07378, 0.08334],
        "951": [0.19444, 0.43056, 0.03588, 0.05556],
        "952": [0, 0.69444, 0.02778, 0.08334],
        "953": [0, 0.43056, 0, 0.05556],
        "954": [0, 0.43056, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.43056, 0, 0.02778],
        "957": [0, 0.43056, 0.06366, 0.02778],
        "958": [0.19444, 0.69444, 0.04601, 0.11111],
        "959": [0, 0.43056, 0, 0.05556],
        "960": [0, 0.43056, 0.03588, 0],
        "961": [0.19444, 0.43056, 0, 0.08334],
        "962": [0.09722, 0.43056, 0.07986, 0.08334],
        "963": [0, 0.43056, 0.03588, 0],
        "964": [0, 0.43056, 0.1132, 0.02778],
        "965": [0, 0.43056, 0.03588, 0.02778],
        "966": [0.19444, 0.43056, 0, 0.08334],
        "967": [0.19444, 0.43056, 0, 0.05556],
        "968": [0.19444, 0.69444, 0.03588, 0.11111],
        "969": [0, 0.43056, 0.03588, 0],
        "977": [0, 0.69444, 0, 0.08334],
        "981": [0.19444, 0.69444, 0, 0.08334],
        "982": [0, 0.43056, 0.02778, 0],
        "1009": [0.19444, 0.43056, 0, 0.08334],
        "1013": [0, 0.43056, 0, 0.05556]
    },
    "Math-Regular": {
        "65": [0, 0.68333, 0, 0.13889],
        "66": [0, 0.68333, 0.05017, 0.08334],
        "67": [0, 0.68333, 0.07153, 0.08334],
        "68": [0, 0.68333, 0.02778, 0.05556],
        "69": [0, 0.68333, 0.05764, 0.08334],
        "70": [0, 0.68333, 0.13889, 0.08334],
        "71": [0, 0.68333, 0, 0.08334],
        "72": [0, 0.68333, 0.08125, 0.05556],
        "73": [0, 0.68333, 0.07847, 0.11111],
        "74": [0, 0.68333, 0.09618, 0.16667],
        "75": [0, 0.68333, 0.07153, 0.05556],
        "76": [0, 0.68333, 0, 0.02778],
        "77": [0, 0.68333, 0.10903, 0.08334],
        "78": [0, 0.68333, 0.10903, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.08334],
        "80": [0, 0.68333, 0.13889, 0.08334],
        "81": [0.19444, 0.68333, 0, 0.08334],
        "82": [0, 0.68333, 0.00773, 0.08334],
        "83": [0, 0.68333, 0.05764, 0.08334],
        "84": [0, 0.68333, 0.13889, 0.08334],
        "85": [0, 0.68333, 0.10903, 0.02778],
        "86": [0, 0.68333, 0.22222, 0],
        "87": [0, 0.68333, 0.13889, 0],
        "88": [0, 0.68333, 0.07847, 0.08334],
        "89": [0, 0.68333, 0.22222, 0],
        "90": [0, 0.68333, 0.07153, 0.08334],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0.05556],
        "100": [0, 0.69444, 0, 0.16667],
        "101": [0, 0.43056, 0, 0.05556],
        "102": [0.19444, 0.69444, 0.10764, 0.16667],
        "103": [0.19444, 0.43056, 0.03588, 0.02778],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.65952, 0, 0],
        "106": [0.19444, 0.65952, 0.05724, 0],
        "107": [0, 0.69444, 0.03148, 0],
        "108": [0, 0.69444, 0.01968, 0.08334],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0.05556],
        "112": [0.19444, 0.43056, 0, 0.08334],
        "113": [0.19444, 0.43056, 0.03588, 0.08334],
        "114": [0, 0.43056, 0.02778, 0.05556],
        "115": [0, 0.43056, 0, 0.05556],
        "116": [0, 0.61508, 0, 0.08334],
        "117": [0, 0.43056, 0, 0.02778],
        "118": [0, 0.43056, 0.03588, 0.02778],
        "119": [0, 0.43056, 0.02691, 0.08334],
        "120": [0, 0.43056, 0, 0.02778],
        "121": [0.19444, 0.43056, 0.03588, 0.05556],
        "122": [0, 0.43056, 0.04398, 0.05556],
        "915": [0, 0.68333, 0.13889, 0.08334],
        "916": [0, 0.68333, 0, 0.16667],
        "920": [0, 0.68333, 0.02778, 0.08334],
        "923": [0, 0.68333, 0, 0.16667],
        "926": [0, 0.68333, 0.07569, 0.08334],
        "928": [0, 0.68333, 0.08125, 0.05556],
        "931": [0, 0.68333, 0.05764, 0.08334],
        "933": [0, 0.68333, 0.13889, 0.05556],
        "934": [0, 0.68333, 0, 0.08334],
        "936": [0, 0.68333, 0.11, 0.05556],
        "937": [0, 0.68333, 0.05017, 0.08334],
        "945": [0, 0.43056, 0.0037, 0.02778],
        "946": [0.19444, 0.69444, 0.05278, 0.08334],
        "947": [0.19444, 0.43056, 0.05556, 0],
        "948": [0, 0.69444, 0.03785, 0.05556],
        "949": [0, 0.43056, 0, 0.08334],
        "950": [0.19444, 0.69444, 0.07378, 0.08334],
        "951": [0.19444, 0.43056, 0.03588, 0.05556],
        "952": [0, 0.69444, 0.02778, 0.08334],
        "953": [0, 0.43056, 0, 0.05556],
        "954": [0, 0.43056, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.43056, 0, 0.02778],
        "957": [0, 0.43056, 0.06366, 0.02778],
        "958": [0.19444, 0.69444, 0.04601, 0.11111],
        "959": [0, 0.43056, 0, 0.05556],
        "960": [0, 0.43056, 0.03588, 0],
        "961": [0.19444, 0.43056, 0, 0.08334],
        "962": [0.09722, 0.43056, 0.07986, 0.08334],
        "963": [0, 0.43056, 0.03588, 0],
        "964": [0, 0.43056, 0.1132, 0.02778],
        "965": [0, 0.43056, 0.03588, 0.02778],
        "966": [0.19444, 0.43056, 0, 0.08334],
        "967": [0.19444, 0.43056, 0, 0.05556],
        "968": [0.19444, 0.69444, 0.03588, 0.11111],
        "969": [0, 0.43056, 0.03588, 0],
        "977": [0, 0.69444, 0, 0.08334],
        "981": [0.19444, 0.69444, 0, 0.08334],
        "982": [0, 0.43056, 0.02778, 0],
        "1009": [0.19444, 0.43056, 0, 0.08334],
        "1013": [0, 0.43056, 0, 0.05556]
    },
    "SansSerif-Regular": {
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.08333, 0.58333, 0, 0],
        "44": [0.125, 0.08333, 0, 0],
        "45": [0, 0.44444, 0, 0],
        "46": [0, 0.08333, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.65556, 0, 0],
        "49": [0, 0.65556, 0, 0],
        "50": [0, 0.65556, 0, 0],
        "51": [0, 0.65556, 0, 0],
        "52": [0, 0.65556, 0, 0],
        "53": [0, 0.65556, 0, 0],
        "54": [0, 0.65556, 0, 0],
        "55": [0, 0.65556, 0, 0],
        "56": [0, 0.65556, 0, 0],
        "57": [0, 0.65556, 0, 0],
        "58": [0, 0.44444, 0, 0],
        "59": [0.125, 0.44444, 0, 0],
        "61": [-0.13, 0.37, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.69444, 0, 0],
        "66": [0, 0.69444, 0, 0],
        "67": [0, 0.69444, 0, 0],
        "68": [0, 0.69444, 0, 0],
        "69": [0, 0.69444, 0, 0],
        "70": [0, 0.69444, 0, 0],
        "71": [0, 0.69444, 0, 0],
        "72": [0, 0.69444, 0, 0],
        "73": [0, 0.69444, 0, 0],
        "74": [0, 0.69444, 0, 0],
        "75": [0, 0.69444, 0, 0],
        "76": [0, 0.69444, 0, 0],
        "77": [0, 0.69444, 0, 0],
        "78": [0, 0.69444, 0, 0],
        "79": [0, 0.69444, 0, 0],
        "80": [0, 0.69444, 0, 0],
        "81": [0.125, 0.69444, 0, 0],
        "82": [0, 0.69444, 0, 0],
        "83": [0, 0.69444, 0, 0],
        "84": [0, 0.69444, 0, 0],
        "85": [0, 0.69444, 0, 0],
        "86": [0, 0.69444, 0.01389, 0],
        "87": [0, 0.69444, 0.01389, 0],
        "88": [0, 0.69444, 0, 0],
        "89": [0, 0.69444, 0.025, 0],
        "90": [0, 0.69444, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.35, 0.09444, 0.02778, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0, 0.69444, 0.06944, 0],
        "103": [0.19444, 0.44444, 0.01389, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.67937, 0, 0],
        "106": [0.19444, 0.67937, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0, 0],
        "114": [0, 0.44444, 0.01389, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.57143, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.01389, 0],
        "119": [0, 0.44444, 0.01389, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.01389, 0],
        "122": [0, 0.44444, 0, 0],
        "126": [0.35, 0.32659, 0, 0],
        "305": [0, 0.44444, 0, 0],
        "567": [0.19444, 0.44444, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.67659, 0, 0],
        "772": [0, 0.60889, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.67937, 0, 0],
        "776": [0, 0.67937, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.63194, 0, 0],
        "915": [0, 0.69444, 0, 0],
        "916": [0, 0.69444, 0, 0],
        "920": [0, 0.69444, 0, 0],
        "923": [0, 0.69444, 0, 0],
        "926": [0, 0.69444, 0, 0],
        "928": [0, 0.69444, 0, 0],
        "931": [0, 0.69444, 0, 0],
        "933": [0, 0.69444, 0, 0],
        "934": [0, 0.69444, 0, 0],
        "936": [0, 0.69444, 0, 0],
        "937": [0, 0.69444, 0, 0],
        "8211": [0, 0.44444, 0.02778, 0],
        "8212": [0, 0.44444, 0.02778, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0]
    },
    "Script-Regular": {
        "65": [0, 0.7, 0.22925, 0],
        "66": [0, 0.7, 0.04087, 0],
        "67": [0, 0.7, 0.1689, 0],
        "68": [0, 0.7, 0.09371, 0],
        "69": [0, 0.7, 0.18583, 0],
        "70": [0, 0.7, 0.13634, 0],
        "71": [0, 0.7, 0.17322, 0],
        "72": [0, 0.7, 0.29694, 0],
        "73": [0, 0.7, 0.19189, 0],
        "74": [0.27778, 0.7, 0.19189, 0],
        "75": [0, 0.7, 0.31259, 0],
        "76": [0, 0.7, 0.19189, 0],
        "77": [0, 0.7, 0.15981, 0],
        "78": [0, 0.7, 0.3525, 0],
        "79": [0, 0.7, 0.08078, 0],
        "80": [0, 0.7, 0.08078, 0],
        "81": [0, 0.7, 0.03305, 0],
        "82": [0, 0.7, 0.06259, 0],
        "83": [0, 0.7, 0.19189, 0],
        "84": [0, 0.7, 0.29087, 0],
        "85": [0, 0.7, 0.25815, 0],
        "86": [0, 0.7, 0.27523, 0],
        "87": [0, 0.7, 0.27523, 0],
        "88": [0, 0.7, 0.26006, 0],
        "89": [0, 0.7, 0.2939, 0],
        "90": [0, 0.7, 0.24037, 0]
    },
    "Size1-Regular": {
        "40": [0.35001, 0.85, 0, 0],
        "41": [0.35001, 0.85, 0, 0],
        "47": [0.35001, 0.85, 0, 0],
        "91": [0.35001, 0.85, 0, 0],
        "92": [0.35001, 0.85, 0, 0],
        "93": [0.35001, 0.85, 0, 0],
        "123": [0.35001, 0.85, 0, 0],
        "125": [0.35001, 0.85, 0, 0],
        "710": [0, 0.72222, 0, 0],
        "732": [0, 0.72222, 0, 0],
        "770": [0, 0.72222, 0, 0],
        "771": [0, 0.72222, 0, 0],
        "8214": [-0.00099, 0.601, 0, 0],
        "8593": [1e-05, 0.6, 0, 0],
        "8595": [1e-05, 0.6, 0, 0],
        "8657": [1e-05, 0.6, 0, 0],
        "8659": [1e-05, 0.6, 0, 0],
        "8719": [0.25001, 0.75, 0, 0],
        "8720": [0.25001, 0.75, 0, 0],
        "8721": [0.25001, 0.75, 0, 0],
        "8730": [0.35001, 0.85, 0, 0],
        "8739": [-0.00599, 0.606, 0, 0],
        "8741": [-0.00599, 0.606, 0, 0],
        "8747": [0.30612, 0.805, 0.19445, 0],
        "8748": [0.306, 0.805, 0.19445, 0],
        "8749": [0.306, 0.805, 0.19445, 0],
        "8750": [0.30612, 0.805, 0.19445, 0],
        "8896": [0.25001, 0.75, 0, 0],
        "8897": [0.25001, 0.75, 0, 0],
        "8898": [0.25001, 0.75, 0, 0],
        "8899": [0.25001, 0.75, 0, 0],
        "8968": [0.35001, 0.85, 0, 0],
        "8969": [0.35001, 0.85, 0, 0],
        "8970": [0.35001, 0.85, 0, 0],
        "8971": [0.35001, 0.85, 0, 0],
        "9168": [-0.00099, 0.601, 0, 0],
        "10216": [0.35001, 0.85, 0, 0],
        "10217": [0.35001, 0.85, 0, 0],
        "10752": [0.25001, 0.75, 0, 0],
        "10753": [0.25001, 0.75, 0, 0],
        "10754": [0.25001, 0.75, 0, 0],
        "10756": [0.25001, 0.75, 0, 0],
        "10758": [0.25001, 0.75, 0, 0]
    },
    "Size2-Regular": {
        "40": [0.65002, 1.15, 0, 0],
        "41": [0.65002, 1.15, 0, 0],
        "47": [0.65002, 1.15, 0, 0],
        "91": [0.65002, 1.15, 0, 0],
        "92": [0.65002, 1.15, 0, 0],
        "93": [0.65002, 1.15, 0, 0],
        "123": [0.65002, 1.15, 0, 0],
        "125": [0.65002, 1.15, 0, 0],
        "710": [0, 0.75, 0, 0],
        "732": [0, 0.75, 0, 0],
        "770": [0, 0.75, 0, 0],
        "771": [0, 0.75, 0, 0],
        "8719": [0.55001, 1.05, 0, 0],
        "8720": [0.55001, 1.05, 0, 0],
        "8721": [0.55001, 1.05, 0, 0],
        "8730": [0.65002, 1.15, 0, 0],
        "8747": [0.86225, 1.36, 0.44445, 0],
        "8748": [0.862, 1.36, 0.44445, 0],
        "8749": [0.862, 1.36, 0.44445, 0],
        "8750": [0.86225, 1.36, 0.44445, 0],
        "8896": [0.55001, 1.05, 0, 0],
        "8897": [0.55001, 1.05, 0, 0],
        "8898": [0.55001, 1.05, 0, 0],
        "8899": [0.55001, 1.05, 0, 0],
        "8968": [0.65002, 1.15, 0, 0],
        "8969": [0.65002, 1.15, 0, 0],
        "8970": [0.65002, 1.15, 0, 0],
        "8971": [0.65002, 1.15, 0, 0],
        "10216": [0.65002, 1.15, 0, 0],
        "10217": [0.65002, 1.15, 0, 0],
        "10752": [0.55001, 1.05, 0, 0],
        "10753": [0.55001, 1.05, 0, 0],
        "10754": [0.55001, 1.05, 0, 0],
        "10756": [0.55001, 1.05, 0, 0],
        "10758": [0.55001, 1.05, 0, 0]
    },
    "Size3-Regular": {
        "40": [0.95003, 1.45, 0, 0],
        "41": [0.95003, 1.45, 0, 0],
        "47": [0.95003, 1.45, 0, 0],
        "91": [0.95003, 1.45, 0, 0],
        "92": [0.95003, 1.45, 0, 0],
        "93": [0.95003, 1.45, 0, 0],
        "123": [0.95003, 1.45, 0, 0],
        "125": [0.95003, 1.45, 0, 0],
        "710": [0, 0.75, 0, 0],
        "732": [0, 0.75, 0, 0],
        "770": [0, 0.75, 0, 0],
        "771": [0, 0.75, 0, 0],
        "8730": [0.95003, 1.45, 0, 0],
        "8968": [0.95003, 1.45, 0, 0],
        "8969": [0.95003, 1.45, 0, 0],
        "8970": [0.95003, 1.45, 0, 0],
        "8971": [0.95003, 1.45, 0, 0],
        "10216": [0.95003, 1.45, 0, 0],
        "10217": [0.95003, 1.45, 0, 0]
    },
    "Size4-Regular": {
        "40": [1.25003, 1.75, 0, 0],
        "41": [1.25003, 1.75, 0, 0],
        "47": [1.25003, 1.75, 0, 0],
        "91": [1.25003, 1.75, 0, 0],
        "92": [1.25003, 1.75, 0, 0],
        "93": [1.25003, 1.75, 0, 0],
        "123": [1.25003, 1.75, 0, 0],
        "125": [1.25003, 1.75, 0, 0],
        "710": [0, 0.825, 0, 0],
        "732": [0, 0.825, 0, 0],
        "770": [0, 0.825, 0, 0],
        "771": [0, 0.825, 0, 0],
        "8730": [1.25003, 1.75, 0, 0],
        "8968": [1.25003, 1.75, 0, 0],
        "8969": [1.25003, 1.75, 0, 0],
        "8970": [1.25003, 1.75, 0, 0],
        "8971": [1.25003, 1.75, 0, 0],
        "9115": [0.64502, 1.155, 0, 0],
        "9116": [1e-05, 0.6, 0, 0],
        "9117": [0.64502, 1.155, 0, 0],
        "9118": [0.64502, 1.155, 0, 0],
        "9119": [1e-05, 0.6, 0, 0],
        "9120": [0.64502, 1.155, 0, 0],
        "9121": [0.64502, 1.155, 0, 0],
        "9122": [-0.00099, 0.601, 0, 0],
        "9123": [0.64502, 1.155, 0, 0],
        "9124": [0.64502, 1.155, 0, 0],
        "9125": [-0.00099, 0.601, 0, 0],
        "9126": [0.64502, 1.155, 0, 0],
        "9127": [1e-05, 0.9, 0, 0],
        "9128": [0.65002, 1.15, 0, 0],
        "9129": [0.90001, 0, 0, 0],
        "9130": [0, 0.3, 0, 0],
        "9131": [1e-05, 0.9, 0, 0],
        "9132": [0.65002, 1.15, 0, 0],
        "9133": [0.90001, 0, 0, 0],
        "9143": [0.88502, 0.915, 0, 0],
        "10216": [1.25003, 1.75, 0, 0],
        "10217": [1.25003, 1.75, 0, 0],
        "57344": [-0.00499, 0.605, 0, 0],
        "57345": [-0.00499, 0.605, 0, 0],
        "57680": [0, 0.12, 0, 0],
        "57681": [0, 0.12, 0, 0],
        "57682": [0, 0.12, 0, 0],
        "57683": [0, 0.12, 0, 0]
    },
    "Typewriter-Regular": {
        "33": [0, 0.61111, 0, 0],
        "34": [0, 0.61111, 0, 0],
        "35": [0, 0.61111, 0, 0],
        "36": [0.08333, 0.69444, 0, 0],
        "37": [0.08333, 0.69444, 0, 0],
        "38": [0, 0.61111, 0, 0],
        "39": [0, 0.61111, 0, 0],
        "40": [0.08333, 0.69444, 0, 0],
        "41": [0.08333, 0.69444, 0, 0],
        "42": [0, 0.52083, 0, 0],
        "43": [-0.08056, 0.53055, 0, 0],
        "44": [0.13889, 0.125, 0, 0],
        "45": [-0.08056, 0.53055, 0, 0],
        "46": [0, 0.125, 0, 0],
        "47": [0.08333, 0.69444, 0, 0],
        "48": [0, 0.61111, 0, 0],
        "49": [0, 0.61111, 0, 0],
        "50": [0, 0.61111, 0, 0],
        "51": [0, 0.61111, 0, 0],
        "52": [0, 0.61111, 0, 0],
        "53": [0, 0.61111, 0, 0],
        "54": [0, 0.61111, 0, 0],
        "55": [0, 0.61111, 0, 0],
        "56": [0, 0.61111, 0, 0],
        "57": [0, 0.61111, 0, 0],
        "58": [0, 0.43056, 0, 0],
        "59": [0.13889, 0.43056, 0, 0],
        "60": [-0.05556, 0.55556, 0, 0],
        "61": [-0.19549, 0.41562, 0, 0],
        "62": [-0.05556, 0.55556, 0, 0],
        "63": [0, 0.61111, 0, 0],
        "64": [0, 0.61111, 0, 0],
        "65": [0, 0.61111, 0, 0],
        "66": [0, 0.61111, 0, 0],
        "67": [0, 0.61111, 0, 0],
        "68": [0, 0.61111, 0, 0],
        "69": [0, 0.61111, 0, 0],
        "70": [0, 0.61111, 0, 0],
        "71": [0, 0.61111, 0, 0],
        "72": [0, 0.61111, 0, 0],
        "73": [0, 0.61111, 0, 0],
        "74": [0, 0.61111, 0, 0],
        "75": [0, 0.61111, 0, 0],
        "76": [0, 0.61111, 0, 0],
        "77": [0, 0.61111, 0, 0],
        "78": [0, 0.61111, 0, 0],
        "79": [0, 0.61111, 0, 0],
        "80": [0, 0.61111, 0, 0],
        "81": [0.13889, 0.61111, 0, 0],
        "82": [0, 0.61111, 0, 0],
        "83": [0, 0.61111, 0, 0],
        "84": [0, 0.61111, 0, 0],
        "85": [0, 0.61111, 0, 0],
        "86": [0, 0.61111, 0, 0],
        "87": [0, 0.61111, 0, 0],
        "88": [0, 0.61111, 0, 0],
        "89": [0, 0.61111, 0, 0],
        "90": [0, 0.61111, 0, 0],
        "91": [0.08333, 0.69444, 0, 0],
        "92": [0.08333, 0.69444, 0, 0],
        "93": [0.08333, 0.69444, 0, 0],
        "94": [0, 0.61111, 0, 0],
        "95": [0.09514, 0, 0, 0],
        "96": [0, 0.61111, 0, 0],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.61111, 0, 0],
        "99": [0, 0.43056, 0, 0],
        "100": [0, 0.61111, 0, 0],
        "101": [0, 0.43056, 0, 0],
        "102": [0, 0.61111, 0, 0],
        "103": [0.22222, 0.43056, 0, 0],
        "104": [0, 0.61111, 0, 0],
        "105": [0, 0.61111, 0, 0],
        "106": [0.22222, 0.61111, 0, 0],
        "107": [0, 0.61111, 0, 0],
        "108": [0, 0.61111, 0, 0],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0],
        "112": [0.22222, 0.43056, 0, 0],
        "113": [0.22222, 0.43056, 0, 0],
        "114": [0, 0.43056, 0, 0],
        "115": [0, 0.43056, 0, 0],
        "116": [0, 0.55358, 0, 0],
        "117": [0, 0.43056, 0, 0],
        "118": [0, 0.43056, 0, 0],
        "119": [0, 0.43056, 0, 0],
        "120": [0, 0.43056, 0, 0],
        "121": [0.22222, 0.43056, 0, 0],
        "122": [0, 0.43056, 0, 0],
        "123": [0.08333, 0.69444, 0, 0],
        "124": [0.08333, 0.69444, 0, 0],
        "125": [0.08333, 0.69444, 0, 0],
        "126": [0, 0.61111, 0, 0],
        "127": [0, 0.61111, 0, 0],
        "305": [0, 0.43056, 0, 0],
        "567": [0.22222, 0.43056, 0, 0],
        "768": [0, 0.61111, 0, 0],
        "769": [0, 0.61111, 0, 0],
        "770": [0, 0.61111, 0, 0],
        "771": [0, 0.61111, 0, 0],
        "772": [0, 0.56555, 0, 0],
        "774": [0, 0.61111, 0, 0],
        "776": [0, 0.61111, 0, 0],
        "778": [0, 0.61111, 0, 0],
        "780": [0, 0.56597, 0, 0],
        "915": [0, 0.61111, 0, 0],
        "916": [0, 0.61111, 0, 0],
        "920": [0, 0.61111, 0, 0],
        "923": [0, 0.61111, 0, 0],
        "926": [0, 0.61111, 0, 0],
        "928": [0, 0.61111, 0, 0],
        "931": [0, 0.61111, 0, 0],
        "933": [0, 0.61111, 0, 0],
        "934": [0, 0.61111, 0, 0],
        "936": [0, 0.61111, 0, 0],
        "937": [0, 0.61111, 0, 0],
        "2018": [0, 0.61111, 0, 0],
        "2019": [0, 0.61111, 0, 0],
        "8242": [0, 0.61111, 0, 0]
    }
};

},{}],108:[function(require,module,exports){
var utils = require("./utils");
var ParseError = require("./ParseError");
var parseData = require("./parseData");
var ParseNode = parseData.ParseNode;

/* This file contains a list of functions that we parse, identified by
 * the calls to defineFunction.
 *
 * The first argument to defineFunction is a single name or a list of names.
 * All functions named in such a list will share a single implementation.
 *
 * Each declared function can have associated properties, which
 * include the following:
 *
 *  - numArgs: The number of arguments the function takes.
 *             If this is the only property, it can be passed as a number
 *             instead of an element of a properties object.
 *  - argTypes: (optional) An array corresponding to each argument of the
 *              function, giving the type of argument that should be parsed. Its
 *              length should be equal to `numArgs + numOptionalArgs`. Valid
 *              types:
 *               - "size": A size-like thing, such as "1em" or "5ex"
 *               - "color": An html color, like "#abc" or "blue"
 *               - "original": The same type as the environment that the
 *                             function being parsed is in (e.g. used for the
 *                             bodies of functions like \color where the first
 *                             argument is special and the second argument is
 *                             parsed normally)
 *              Other possible types (probably shouldn't be used)
 *               - "text": Text-like (e.g. \text)
 *               - "math": Normal math
 *              If undefined, this will be treated as an appropriate length
 *              array of "original" strings
 *  - greediness: (optional) The greediness of the function to use ungrouped
 *                arguments.
 *
 *                E.g. if you have an expression
 *                  \sqrt \frac 1 2
 *                since \frac has greediness=2 vs \sqrt's greediness=1, \frac
 *                will use the two arguments '1' and '2' as its two arguments,
 *                then that whole function will be used as the argument to
 *                \sqrt. On the other hand, the expressions
 *                  \frac \frac 1 2 3
 *                and
 *                  \frac \sqrt 1 2
 *                will fail because \frac and \frac have equal greediness
 *                and \sqrt has a lower greediness than \frac respectively. To
 *                make these parse, we would have to change them to:
 *                  \frac {\frac 1 2} 3
 *                and
 *                  \frac {\sqrt 1} 2
 *
 *                The default value is `1`
 *  - allowedInText: (optional) Whether or not the function is allowed inside
 *                   text mode (default false)
 *  - numOptionalArgs: (optional) The number of optional arguments the function
 *                     should parse. If the optional arguments aren't found,
 *                     `null` will be passed to the handler in their place.
 *                     (default 0)
 *  - infix: (optional) Must be true if the function is an infix operator.
 *
 * The last argument is that implementation, the handler for the function(s).
 * It is called to handle these functions and their arguments.
 * It receives two arguments:
 *  - context contains information and references provided by the parser
 *  - args is an array of arguments obtained from TeX input
 * The context contains the following properties:
 *  - funcName: the text (i.e. name) of the function, including \
 *  - parser: the parser object
 *  - lexer: the lexer object
 *  - positions: the positions in the overall string of the function
 *               and the arguments.
 * The latter three should only be used to produce error messages.
 *
 * The function should return an object with the following keys:
 *  - type: The type of element that this is. This is then used in
 *          buildHTML/buildMathML to determine which function
 *          should be called to build this node into a DOM node
 * Any other data can be added to the object, which will be passed
 * in to the function in buildHTML/buildMathML as `group.value`.
 */

function defineFunction(names, props, handler) {
    if (typeof names === "string") {
        names = [names];
    }
    if (typeof props === "number") {
        props = { numArgs: props };
    }
    // Set default values of functions
    var data = {
        numArgs: props.numArgs,
        argTypes: props.argTypes,
        greediness: (props.greediness === undefined) ? 1 : props.greediness,
        allowedInText: !!props.allowedInText,
        numOptionalArgs: props.numOptionalArgs || 0,
        infix: !!props.infix,
        handler: handler
    };
    for (var i = 0; i < names.length; ++i) {
        module.exports[names[i]] = data;
    }
}

// Since the corresponding buildHTML/buildMathML function expects a
// list of elements, we normalize for different kinds of arguments
var ordargument = function(arg) {
    if (arg.type === "ordgroup") {
        return arg.value;
    } else {
        return [arg];
    }
};

// A normal square root
defineFunction("\\sqrt", {
    numArgs: 1,
    numOptionalArgs: 1
}, function(context, args) {
    var index = args[0];
    var body = args[1];
    return {
        type: "sqrt",
        body: body,
        index: index
    };
});

// Non-mathy text, possibly in a font
var textFunctionStyles = {
    "\\text": undefined, "\\textrm": "mathrm", "\\textsf": "mathsf",
    "\\texttt": "mathtt", "\\textnormal": "mathrm", "\\textbf": "mathbf",
    "\\textit": "textit"
};

defineFunction([
    "\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal",
    "\\textbf", "\\textit"
], {
    numArgs: 1,
    argTypes: ["text"],
    greediness: 2,
    allowedInText: true
}, function(context, args) {
    var body = args[0];
    return {
        type: "text",
        body: ordargument(body),
        style: textFunctionStyles[context.funcName]
    };
});

// A two-argument custom color
defineFunction("\\color", {
    numArgs: 2,
    allowedInText: true,
    greediness: 3,
    argTypes: ["color", "original"]
}, function(context, args) {
    var color = args[0];
    var body = args[1];
    return {
        type: "color",
        color: color.value,
        value: ordargument(body)
    };
});

// An overline
defineFunction("\\overline", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "overline",
        body: body
    };
});

// An underline
defineFunction("\\underline", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "underline",
        body: body
    };
});

// A box of the width and height
defineFunction("\\rule", {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
}, function(context, args) {
    var shift = args[0];
    var width = args[1];
    var height = args[2];
    return {
        type: "rule",
        shift: shift && shift.value,
        width: width.value,
        height: height.value
    };
});

// TODO: In TeX, \mkern only accepts mu-units, and \kern does not accept
// mu-units. In current KaTeX we relax this; both commands accept any unit.
defineFunction(["\\kern", "\\mkern"], {
    numArgs: 1,
    argTypes: ["size"]
}, function(context, args) {
    return {
        type: "kern",
        dimension: args[0].value
    };
});

// A KaTeX logo
defineFunction("\\KaTeX", {
    numArgs: 0
}, function(context) {
    return {
        type: "katex"
    };
});

defineFunction("\\phantom", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "phantom",
        value: ordargument(body)
    };
});

// Math class commands except \mathop
defineFunction([
    "\\mathord", "\\mathbin", "\\mathrel", "\\mathopen",
    "\\mathclose", "\\mathpunct", "\\mathinner"
], {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "mclass",
        mclass: "m" + context.funcName.substr(5),
        value: ordargument(body)
    };
});

// Build a relation by placing one symbol on top of another
defineFunction("\\stackrel", {
    numArgs: 2
}, function(context, args) {
    var top = args[0];
    var bottom = args[1];

    var bottomop = new ParseNode("op", {
        type: "op",
        limits: true,
        alwaysHandleSupSub: true,
        symbol: false,
        value: ordargument(bottom)
    }, bottom.mode);

    var supsub = new ParseNode("supsub", {
        base: bottomop,
        sup: top,
        sub: null
    }, top.mode);

    return {
        type: "mclass",
        mclass: "mrel",
        value: [supsub]
    };
});

// \mod-type functions
defineFunction("\\bmod", {
    numArgs: 0
}, function(context, args) {
    return {
        type: "mod",
        modType: "bmod",
        value: null
    };
});

defineFunction(["\\pod", "\\pmod", "\\mod"], {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "mod",
        modType: context.funcName.substr(1),
        value: ordargument(body)
    };
});

// Extra data needed for the delimiter handler down below
var delimiterSizes = {
    "\\bigl" : {mclass: "mopen",    size: 1},
    "\\Bigl" : {mclass: "mopen",    size: 2},
    "\\biggl": {mclass: "mopen",    size: 3},
    "\\Biggl": {mclass: "mopen",    size: 4},
    "\\bigr" : {mclass: "mclose",   size: 1},
    "\\Bigr" : {mclass: "mclose",   size: 2},
    "\\biggr": {mclass: "mclose",   size: 3},
    "\\Biggr": {mclass: "mclose",   size: 4},
    "\\bigm" : {mclass: "mrel",     size: 1},
    "\\Bigm" : {mclass: "mrel",     size: 2},
    "\\biggm": {mclass: "mrel",     size: 3},
    "\\Biggm": {mclass: "mrel",     size: 4},
    "\\big"  : {mclass: "mord",     size: 1},
    "\\Big"  : {mclass: "mord",     size: 2},
    "\\bigg" : {mclass: "mord",     size: 3},
    "\\Bigg" : {mclass: "mord",     size: 4}
};

var delimiters = [
    "(", ")", "[", "\\lbrack", "]", "\\rbrack",
    "\\{", "\\lbrace", "\\}", "\\rbrace",
    "\\lfloor", "\\rfloor", "\\lceil", "\\rceil",
    "<", ">", "\\langle", "\\rangle", "\\lt", "\\gt",
    "\\lvert", "\\rvert", "\\lVert", "\\rVert",
    "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache",
    "/", "\\backslash",
    "|", "\\vert", "\\|", "\\Vert",
    "\\uparrow", "\\Uparrow",
    "\\downarrow", "\\Downarrow",
    "\\updownarrow", "\\Updownarrow",
    "."
];

var fontAliases = {
    "\\Bbb": "\\mathbb",
    "\\bold": "\\mathbf",
    "\\frak": "\\mathfrak"
};

// Single-argument color functions
defineFunction([
    "\\blue", "\\orange", "\\pink", "\\red",
    "\\green", "\\gray", "\\purple",
    "\\blueA", "\\blueB", "\\blueC", "\\blueD", "\\blueE",
    "\\tealA", "\\tealB", "\\tealC", "\\tealD", "\\tealE",
    "\\greenA", "\\greenB", "\\greenC", "\\greenD", "\\greenE",
    "\\goldA", "\\goldB", "\\goldC", "\\goldD", "\\goldE",
    "\\redA", "\\redB", "\\redC", "\\redD", "\\redE",
    "\\maroonA", "\\maroonB", "\\maroonC", "\\maroonD", "\\maroonE",
    "\\purpleA", "\\purpleB", "\\purpleC", "\\purpleD", "\\purpleE",
    "\\mintA", "\\mintB", "\\mintC",
    "\\grayA", "\\grayB", "\\grayC", "\\grayD", "\\grayE",
    "\\grayF", "\\grayG", "\\grayH", "\\grayI",
    "\\kaBlue", "\\kaGreen"
], {
    numArgs: 1,
    allowedInText: true,
    greediness: 3
}, function(context, args) {
    var body = args[0];
    return {
        type: "color",
        color: "katex-" + context.funcName.slice(1),
        value: ordargument(body)
    };
});

// There are 2 flags for operators; whether they produce limits in
// displaystyle, and whether they are symbols and should grow in
// displaystyle. These four groups cover the four possible choices.

// No limits, not symbols
defineFunction([
    "\\arcsin", "\\arccos", "\\arctan", "\\arg", "\\cos", "\\cosh",
    "\\cot", "\\coth", "\\csc", "\\deg", "\\dim", "\\exp", "\\hom",
    "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh",
    "\\tan", "\\tanh"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: false,
        symbol: false,
        body: context.funcName
    };
});

// Limits, not symbols
defineFunction([
    "\\det", "\\gcd", "\\inf", "\\lim", "\\liminf", "\\limsup", "\\max",
    "\\min", "\\Pr", "\\sup"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: true,
        symbol: false,
        body: context.funcName
    };
});

// No limits, symbols
defineFunction([
    "\\int", "\\iint", "\\iiint", "\\oint"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: false,
        symbol: true,
        body: context.funcName
    };
});

// Limits, symbols
defineFunction([
    "\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap",
    "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes",
    "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: true,
        symbol: true,
        body: context.funcName
    };
});

// \mathop class command
defineFunction("\\mathop", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "op",
        limits: false,
        symbol: false,
        value: ordargument(body)
    };
});

// Fractions
defineFunction([
    "\\dfrac", "\\frac", "\\tfrac",
    "\\dbinom", "\\binom", "\\tbinom",
    "\\\\atopfrac" // cant be entered directly
], {
    numArgs: 2,
    greediness: 2
}, function(context, args) {
    var numer = args[0];
    var denom = args[1];
    var hasBarLine;
    var leftDelim = null;
    var rightDelim = null;
    var size = "auto";

    switch (context.funcName) {
        case "\\dfrac":
        case "\\frac":
        case "\\tfrac":
            hasBarLine = true;
            break;
        case "\\\\atopfrac":
            hasBarLine = false;
            break;
        case "\\dbinom":
        case "\\binom":
        case "\\tbinom":
            hasBarLine = false;
            leftDelim = "(";
            rightDelim = ")";
            break;
        default:
            throw new Error("Unrecognized genfrac command");
    }

    switch (context.funcName) {
        case "\\dfrac":
        case "\\dbinom":
            size = "display";
            break;
        case "\\tfrac":
        case "\\tbinom":
            size = "text";
            break;
    }

    return {
        type: "genfrac",
        numer: numer,
        denom: denom,
        hasBarLine: hasBarLine,
        leftDelim: leftDelim,
        rightDelim: rightDelim,
        size: size
    };
});

// Left and right overlap functions
defineFunction(["\\llap", "\\rlap"], {
    numArgs: 1,
    allowedInText: true
}, function(context, args) {
    var body = args[0];
    return {
        type: context.funcName.slice(1),
        body: body
    };
});

// Delimiter functions
var checkDelimiter = function(delim, context) {
    if (utils.contains(delimiters, delim.value)) {
        return delim;
    } else {
        throw new ParseError(
            "Invalid delimiter: '" + delim.value + "' after '" +
            context.funcName + "'", delim);
    }
};

defineFunction([
    "\\bigl", "\\Bigl", "\\biggl", "\\Biggl",
    "\\bigr", "\\Bigr", "\\biggr", "\\Biggr",
    "\\bigm", "\\Bigm", "\\biggm", "\\Biggm",
    "\\big",  "\\Big",  "\\bigg",  "\\Bigg"
], {
    numArgs: 1
}, function(context, args) {
    var delim = checkDelimiter(args[0], context);

    return {
        type: "delimsizing",
        size: delimiterSizes[context.funcName].size,
        mclass: delimiterSizes[context.funcName].mclass,
        value: delim.value
    };
});

defineFunction([
    "\\left", "\\right"
], {
    numArgs: 1
}, function(context, args) {
    var delim = checkDelimiter(args[0], context);

    // \left and \right are caught somewhere in Parser.js, which is
    // why this data doesn't match what is in buildHTML.
    return {
        type: "leftright",
        value: delim.value
    };
});

defineFunction("\\middle", {
    numArgs: 1
}, function(context, args) {
    var delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
        throw new ParseError("\\middle without preceding \\left", delim);
    }

    return {
        type: "middle",
        value: delim.value
    };
});

// Sizing functions (handled in Parser.js explicitly, hence no handler)
defineFunction([
    "\\tiny", "\\scriptsize", "\\footnotesize", "\\small",
    "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"
], 0, null);

// Style changing functions (handled in Parser.js explicitly, hence no
// handler)
defineFunction([
    "\\displaystyle", "\\textstyle", "\\scriptstyle",
    "\\scriptscriptstyle"
], 0, null);

defineFunction([
    // styles
    "\\mathrm", "\\mathit", "\\mathbf",

    // families
    "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf",
    "\\mathtt",

    // aliases
    "\\Bbb", "\\bold", "\\frak"
], {
    numArgs: 1,
    greediness: 2
}, function(context, args) {
    var body = args[0];
    var func = context.funcName;
    if (func in fontAliases) {
        func = fontAliases[func];
    }
    return {
        type: "font",
        font: func.slice(1),
        body: body
    };
});

// Accents
defineFunction([
    "\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve",
    "\\check", "\\hat", "\\vec", "\\dot"
    // We don't support expanding accents yet
    // "\\widetilde", "\\widehat"
], {
    numArgs: 1
}, function(context, args) {
    var base = args[0];
    return {
        type: "accent",
        accent: context.funcName,
        base: base
    };
});

// Infix generalized fractions
defineFunction(["\\over", "\\choose", "\\atop"], {
    numArgs: 0,
    infix: true
}, function(context) {
    var replaceWith;
    switch (context.funcName) {
        case "\\over":
            replaceWith = "\\frac";
            break;
        case "\\choose":
            replaceWith = "\\binom";
            break;
        case "\\atop":
            replaceWith = "\\\\atopfrac";
            break;
        default:
            throw new Error("Unrecognized infix genfrac command");
    }
    return {
        type: "infix",
        replaceWith: replaceWith,
        token: context.token
    };
});

// Row breaks for aligned data
defineFunction(["\\\\", "\\cr"], {
    numArgs: 0,
    numOptionalArgs: 1,
    argTypes: ["size"]
}, function(context, args) {
    var size = args[0];
    return {
        type: "cr",
        size: size
    };
});

// Environment delimiters
defineFunction(["\\begin", "\\end"], {
    numArgs: 1,
    argTypes: ["text"]
}, function(context, args) {
    var nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
        throw new ParseError("Invalid environment name", nameGroup);
    }
    var name = "";
    for (var i = 0; i < nameGroup.value.length; ++i) {
        name += nameGroup.value[i].value;
    }
    return {
        type: "environment",
        name: name,
        nameGroup: nameGroup
    };
});

},{"./ParseError":95,"./parseData":110,"./utils":114}],109:[function(require,module,exports){
/**
 * These objects store data about MathML nodes. This is the MathML equivalent
 * of the types in domTree.js. Since MathML handles its own rendering, and
 * since we're mainly using MathML to improve accessibility, we don't manage
 * any of the styling state that the plain DOM nodes do.
 *
 * The `toNode` and `toMarkup` functions work simlarly to how they do in
 * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
 */

var utils = require("./utils");

/**
 * This node represents a general purpose MathML node of any type. The
 * constructor requires the type of node to create (for example, `"mo"` or
 * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
 */
function MathNode(type, children) {
    this.type = type;
    this.attributes = {};
    this.children = children || [];
}

/**
 * Sets an attribute on a MathML node. MathML depends on attributes to convey a
 * semantic content, so this is used heavily.
 */
MathNode.prototype.setAttribute = function(name, value) {
    this.attributes[name] = value;
};

/**
 * Converts the math node into a MathML-namespaced DOM element.
 */
MathNode.prototype.toNode = function() {
    var node = document.createElementNS(
        "http://www.w3.org/1998/Math/MathML", this.type);

    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            node.setAttribute(attr, this.attributes[attr]);
        }
    }

    for (var i = 0; i < this.children.length; i++) {
        node.appendChild(this.children[i].toNode());
    }

    return node;
};

/**
 * Converts the math node into an HTML markup string.
 */
MathNode.prototype.toMarkup = function() {
    var markup = "<" + this.type;

    // Add the attributes
    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "=\"";
            markup += utils.escape(this.attributes[attr]);
            markup += "\"";
        }
    }

    markup += ">";

    for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
    }

    markup += "</" + this.type + ">";

    return markup;
};

/**
 * This node represents a piece of text.
 */
function TextNode(text) {
    this.text = text;
}

/**
 * Converts the text node into a DOM text node.
 */
TextNode.prototype.toNode = function() {
    return document.createTextNode(this.text);
};

/**
 * Converts the text node into HTML markup (which is just the text itself).
 */
TextNode.prototype.toMarkup = function() {
    return utils.escape(this.text);
};

module.exports = {
    MathNode: MathNode,
    TextNode: TextNode
};

},{"./utils":114}],110:[function(require,module,exports){
/**
 * The resulting parse tree nodes of the parse tree.
 *
 * It is possible to provide position information, so that a ParseNode can
 * fulfil a role similar to a Token in error reporting.
 * For details on the corresponding properties see Token constructor.
 * Providing such information can lead to better error reporting.
 *
 * @param {string}  type       type of node, like e.g. "ordgroup"
 * @param {?object} value      type-specific representation of the node
 * @param {string}  mode       parse mode in action for this node,
 *                             "math" or "text"
 * @param {Token=} firstToken  first token of the input for this node,
 *                             will omit position information if unset
 * @param {Token=} lastToken   last token of the input for this node,
 *                             will default to firstToken if unset
 */
function ParseNode(type, value, mode, firstToken, lastToken) {
    this.type = type;
    this.value = value;
    this.mode = mode;
    if (firstToken && (!lastToken || lastToken.lexer === firstToken.lexer)) {
        this.lexer = firstToken.lexer;
        this.start = firstToken.start;
        this.end = (lastToken || firstToken).end;
    }
}

module.exports = {
    ParseNode: ParseNode
};


},{}],111:[function(require,module,exports){
/**
 * Provides a single function for parsing an expression using a Parser
 * TODO(emily): Remove this
 */

var Parser = require("./Parser");

/**
 * Parses an expression using a Parser, then returns the parsed result.
 */
var parseTree = function(toParse, settings) {
    if (!(typeof toParse === 'string' || toParse instanceof String)) {
        throw new TypeError('KaTeX can only parse string typed expression');
    }
    var parser = new Parser(toParse, settings);

    return parser.parse();
};

module.exports = parseTree;

},{"./Parser":96}],112:[function(require,module,exports){
/**
 * This file holds a list of all no-argument functions and single-character
 * symbols (like 'a' or ';').
 *
 * For each of the symbols, there are three properties they can have:
 * - font (required): the font to be used for this symbol. Either "main" (the
     normal font), or "ams" (the ams fonts).
 * - group (required): the ParseNode group type the symbol should have (i.e.
     "textord", "mathord", etc).
     See https://github.com/Khan/KaTeX/wiki/Examining-TeX#group-types
 * - replace: the character that this symbol or function should be
 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
 *   character in the main font).
 *
 * The outermost map in the table indicates what mode the symbols should be
 * accepted in (e.g. "math" or "text").
 */

module.exports = {
    math: {},
    text: {}
};

function defineSymbol(mode, font, group, replace, name) {
    module.exports[mode][name] = {
        font: font,
        group: group,
        replace: replace
    };
}

// Some abbreviations for commonly used strings.
// This helps minify the code, and also spotting typos using jshint.

// modes:
var math = "math";
var text = "text";

// fonts:
var main = "main";
var ams = "ams";

// groups:
var accent = "accent";
var bin = "bin";
var close = "close";
var inner = "inner";
var mathord = "mathord";
var op = "op";
var open = "open";
var punct = "punct";
var rel = "rel";
var spacing = "spacing";
var textord = "textord";

// Now comes the symbol table

// Relation Symbols
defineSymbol(math, main, rel, "\u2261", "\\equiv");
defineSymbol(math, main, rel, "\u227a", "\\prec");
defineSymbol(math, main, rel, "\u227b", "\\succ");
defineSymbol(math, main, rel, "\u223c", "\\sim");
defineSymbol(math, main, rel, "\u22a5", "\\perp");
defineSymbol(math, main, rel, "\u2aaf", "\\preceq");
defineSymbol(math, main, rel, "\u2ab0", "\\succeq");
defineSymbol(math, main, rel, "\u2243", "\\simeq");
defineSymbol(math, main, rel, "\u2223", "\\mid");
defineSymbol(math, main, rel, "\u226a", "\\ll");
defineSymbol(math, main, rel, "\u226b", "\\gg");
defineSymbol(math, main, rel, "\u224d", "\\asymp");
defineSymbol(math, main, rel, "\u2225", "\\parallel");
defineSymbol(math, main, rel, "\u22c8", "\\bowtie");
defineSymbol(math, main, rel, "\u2323", "\\smile");
defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq");
defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq");
defineSymbol(math, main, rel, "\u2250", "\\doteq");
defineSymbol(math, main, rel, "\u2322", "\\frown");
defineSymbol(math, main, rel, "\u220b", "\\ni");
defineSymbol(math, main, rel, "\u221d", "\\propto");
defineSymbol(math, main, rel, "\u22a2", "\\vdash");
defineSymbol(math, main, rel, "\u22a3", "\\dashv");
defineSymbol(math, main, rel, "\u220b", "\\owns");

// Punctuation
defineSymbol(math, main, punct, "\u002e", "\\ldotp");
defineSymbol(math, main, punct, "\u22c5", "\\cdotp");

// Misc Symbols
defineSymbol(math, main, textord, "\u0023", "\\#");
defineSymbol(text, main, textord, "\u0023", "\\#");
defineSymbol(math, main, textord, "\u0026", "\\&");
defineSymbol(text, main, textord, "\u0026", "\\&");
defineSymbol(math, main, textord, "\u2135", "\\aleph");
defineSymbol(math, main, textord, "\u2200", "\\forall");
defineSymbol(math, main, textord, "\u210f", "\\hbar");
defineSymbol(math, main, textord, "\u2203", "\\exists");
defineSymbol(math, main, textord, "\u2207", "\\nabla");
defineSymbol(math, main, textord, "\u266d", "\\flat");
defineSymbol(math, main, textord, "\u2113", "\\ell");
defineSymbol(math, main, textord, "\u266e", "\\natural");
defineSymbol(math, main, textord, "\u2663", "\\clubsuit");
defineSymbol(math, main, textord, "\u2118", "\\wp");
defineSymbol(math, main, textord, "\u266f", "\\sharp");
defineSymbol(math, main, textord, "\u2662", "\\diamondsuit");
defineSymbol(math, main, textord, "\u211c", "\\Re");
defineSymbol(math, main, textord, "\u2661", "\\heartsuit");
defineSymbol(math, main, textord, "\u2111", "\\Im");
defineSymbol(math, main, textord, "\u2660", "\\spadesuit");

// Math and Text
defineSymbol(math, main, textord, "\u2020", "\\dag");
defineSymbol(math, main, textord, "\u2021", "\\ddag");

// Large Delimiters
defineSymbol(math, main, close, "\u23b1", "\\rmoustache");
defineSymbol(math, main, open, "\u23b0", "\\lmoustache");
defineSymbol(math, main, close, "\u27ef", "\\rgroup");
defineSymbol(math, main, open, "\u27ee", "\\lgroup");

// Binary Operators
defineSymbol(math, main, bin, "\u2213", "\\mp");
defineSymbol(math, main, bin, "\u2296", "\\ominus");
defineSymbol(math, main, bin, "\u228e", "\\uplus");
defineSymbol(math, main, bin, "\u2293", "\\sqcap");
defineSymbol(math, main, bin, "\u2217", "\\ast");
defineSymbol(math, main, bin, "\u2294", "\\sqcup");
defineSymbol(math, main, bin, "\u25ef", "\\bigcirc");
defineSymbol(math, main, bin, "\u2219", "\\bullet");
defineSymbol(math, main, bin, "\u2021", "\\ddagger");
defineSymbol(math, main, bin, "\u2240", "\\wr");
defineSymbol(math, main, bin, "\u2a3f", "\\amalg");

// Arrow Symbols
defineSymbol(math, main, rel, "\u27f5", "\\longleftarrow");
defineSymbol(math, main, rel, "\u21d0", "\\Leftarrow");
defineSymbol(math, main, rel, "\u27f8", "\\Longleftarrow");
defineSymbol(math, main, rel, "\u27f6", "\\longrightarrow");
defineSymbol(math, main, rel, "\u21d2", "\\Rightarrow");
defineSymbol(math, main, rel, "\u27f9", "\\Longrightarrow");
defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow");
defineSymbol(math, main, rel, "\u27f7", "\\longleftrightarrow");
defineSymbol(math, main, rel, "\u21d4", "\\Leftrightarrow");
defineSymbol(math, main, rel, "\u27fa", "\\Longleftrightarrow");
defineSymbol(math, main, rel, "\u21a6", "\\mapsto");
defineSymbol(math, main, rel, "\u27fc", "\\longmapsto");
defineSymbol(math, main, rel, "\u2197", "\\nearrow");
defineSymbol(math, main, rel, "\u21a9", "\\hookleftarrow");
defineSymbol(math, main, rel, "\u21aa", "\\hookrightarrow");
defineSymbol(math, main, rel, "\u2198", "\\searrow");
defineSymbol(math, main, rel, "\u21bc", "\\leftharpoonup");
defineSymbol(math, main, rel, "\u21c0", "\\rightharpoonup");
defineSymbol(math, main, rel, "\u2199", "\\swarrow");
defineSymbol(math, main, rel, "\u21bd", "\\leftharpoondown");
defineSymbol(math, main, rel, "\u21c1", "\\rightharpoondown");
defineSymbol(math, main, rel, "\u2196", "\\nwarrow");
defineSymbol(math, main, rel, "\u21cc", "\\rightleftharpoons");

// AMS Negated Binary Relations
defineSymbol(math, ams, rel, "\u226e", "\\nless");
defineSymbol(math, ams, rel, "\ue010", "\\nleqslant");
defineSymbol(math, ams, rel, "\ue011", "\\nleqq");
defineSymbol(math, ams, rel, "\u2a87", "\\lneq");
defineSymbol(math, ams, rel, "\u2268", "\\lneqq");
defineSymbol(math, ams, rel, "\ue00c", "\\lvertneqq");
defineSymbol(math, ams, rel, "\u22e6", "\\lnsim");
defineSymbol(math, ams, rel, "\u2a89", "\\lnapprox");
defineSymbol(math, ams, rel, "\u2280", "\\nprec");
defineSymbol(math, ams, rel, "\u22e0", "\\npreceq");
defineSymbol(math, ams, rel, "\u22e8", "\\precnsim");
defineSymbol(math, ams, rel, "\u2ab9", "\\precnapprox");
defineSymbol(math, ams, rel, "\u2241", "\\nsim");
defineSymbol(math, ams, rel, "\ue006", "\\nshortmid");
defineSymbol(math, ams, rel, "\u2224", "\\nmid");
defineSymbol(math, ams, rel, "\u22ac", "\\nvdash");
defineSymbol(math, ams, rel, "\u22ad", "\\nvDash");
defineSymbol(math, ams, rel, "\u22ea", "\\ntriangleleft");
defineSymbol(math, ams, rel, "\u22ec", "\\ntrianglelefteq");
defineSymbol(math, ams, rel, "\u228a", "\\subsetneq");
defineSymbol(math, ams, rel, "\ue01a", "\\varsubsetneq");
defineSymbol(math, ams, rel, "\u2acb", "\\subsetneqq");
defineSymbol(math, ams, rel, "\ue017", "\\varsubsetneqq");
defineSymbol(math, ams, rel, "\u226f", "\\ngtr");
defineSymbol(math, ams, rel, "\ue00f", "\\ngeqslant");
defineSymbol(math, ams, rel, "\ue00e", "\\ngeqq");
defineSymbol(math, ams, rel, "\u2a88", "\\gneq");
defineSymbol(math, ams, rel, "\u2269", "\\gneqq");
defineSymbol(math, ams, rel, "\ue00d", "\\gvertneqq");
defineSymbol(math, ams, rel, "\u22e7", "\\gnsim");
defineSymbol(math, ams, rel, "\u2a8a", "\\gnapprox");
defineSymbol(math, ams, rel, "\u2281", "\\nsucc");
defineSymbol(math, ams, rel, "\u22e1", "\\nsucceq");
defineSymbol(math, ams, rel, "\u22e9", "\\succnsim");
defineSymbol(math, ams, rel, "\u2aba", "\\succnapprox");
defineSymbol(math, ams, rel, "\u2246", "\\ncong");
defineSymbol(math, ams, rel, "\ue007", "\\nshortparallel");
defineSymbol(math, ams, rel, "\u2226", "\\nparallel");
defineSymbol(math, ams, rel, "\u22af", "\\nVDash");
defineSymbol(math, ams, rel, "\u22eb", "\\ntriangleright");
defineSymbol(math, ams, rel, "\u22ed", "\\ntrianglerighteq");
defineSymbol(math, ams, rel, "\ue018", "\\nsupseteqq");
defineSymbol(math, ams, rel, "\u228b", "\\supsetneq");
defineSymbol(math, ams, rel, "\ue01b", "\\varsupsetneq");
defineSymbol(math, ams, rel, "\u2acc", "\\supsetneqq");
defineSymbol(math, ams, rel, "\ue019", "\\varsupsetneqq");
defineSymbol(math, ams, rel, "\u22ae", "\\nVdash");
defineSymbol(math, ams, rel, "\u2ab5", "\\precneqq");
defineSymbol(math, ams, rel, "\u2ab6", "\\succneqq");
defineSymbol(math, ams, rel, "\ue016", "\\nsubseteqq");
defineSymbol(math, ams, bin, "\u22b4", "\\unlhd");
defineSymbol(math, ams, bin, "\u22b5", "\\unrhd");

// AMS Negated Arrows
defineSymbol(math, ams, rel, "\u219a", "\\nleftarrow");
defineSymbol(math, ams, rel, "\u219b", "\\nrightarrow");
defineSymbol(math, ams, rel, "\u21cd", "\\nLeftarrow");
defineSymbol(math, ams, rel, "\u21cf", "\\nRightarrow");
defineSymbol(math, ams, rel, "\u21ae", "\\nleftrightarrow");
defineSymbol(math, ams, rel, "\u21ce", "\\nLeftrightarrow");

// AMS Misc
defineSymbol(math, ams, rel, "\u25b3", "\\vartriangle");
defineSymbol(math, ams, textord, "\u210f", "\\hslash");
defineSymbol(math, ams, textord, "\u25bd", "\\triangledown");
defineSymbol(math, ams, textord, "\u25ca", "\\lozenge");
defineSymbol(math, ams, textord, "\u24c8", "\\circledS");
defineSymbol(math, ams, textord, "\u00ae", "\\circledR");
defineSymbol(math, ams, textord, "\u2221", "\\measuredangle");
defineSymbol(math, ams, textord, "\u2204", "\\nexists");
defineSymbol(math, ams, textord, "\u2127", "\\mho");
defineSymbol(math, ams, textord, "\u2132", "\\Finv");
defineSymbol(math, ams, textord, "\u2141", "\\Game");
defineSymbol(math, ams, textord, "\u006b", "\\Bbbk");
defineSymbol(math, ams, textord, "\u2035", "\\backprime");
defineSymbol(math, ams, textord, "\u25b2", "\\blacktriangle");
defineSymbol(math, ams, textord, "\u25bc", "\\blacktriangledown");
defineSymbol(math, ams, textord, "\u25a0", "\\blacksquare");
defineSymbol(math, ams, textord, "\u29eb", "\\blacklozenge");
defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle");
defineSymbol(math, ams, textord, "\u2201", "\\complement");
defineSymbol(math, ams, textord, "\u00f0", "\\eth");
defineSymbol(math, ams, textord, "\u2571", "\\diagup");
defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
defineSymbol(math, ams, textord, "\u25a1", "\\square");
defineSymbol(math, ams, textord, "\u25a1", "\\Box");
defineSymbol(math, ams, textord, "\u25ca", "\\Diamond");
defineSymbol(math, ams, textord, "\u00a5", "\\yen");
defineSymbol(math, ams, textord, "\u2713", "\\checkmark");

// AMS Hebrew
defineSymbol(math, ams, textord, "\u2136", "\\beth");
defineSymbol(math, ams, textord, "\u2138", "\\daleth");
defineSymbol(math, ams, textord, "\u2137", "\\gimel");

// AMS Greek
defineSymbol(math, ams, textord, "\u03dd", "\\digamma");
defineSymbol(math, ams, textord, "\u03f0", "\\varkappa");

// AMS Delimiters
defineSymbol(math, ams, open, "\u250c", "\\ulcorner");
defineSymbol(math, ams, close, "\u2510", "\\urcorner");
defineSymbol(math, ams, open, "\u2514", "\\llcorner");
defineSymbol(math, ams, close, "\u2518", "\\lrcorner");

// AMS Binary Relations
defineSymbol(math, ams, rel, "\u2266", "\\leqq");
defineSymbol(math, ams, rel, "\u2a7d", "\\leqslant");
defineSymbol(math, ams, rel, "\u2a95", "\\eqslantless");
defineSymbol(math, ams, rel, "\u2272", "\\lesssim");
defineSymbol(math, ams, rel, "\u2a85", "\\lessapprox");
defineSymbol(math, ams, rel, "\u224a", "\\approxeq");
defineSymbol(math, ams, bin, "\u22d6", "\\lessdot");
defineSymbol(math, ams, rel, "\u22d8", "\\lll");
defineSymbol(math, ams, rel, "\u2276", "\\lessgtr");
defineSymbol(math, ams, rel, "\u22da", "\\lesseqgtr");
defineSymbol(math, ams, rel, "\u2a8b", "\\lesseqqgtr");
defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq");
defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq");
defineSymbol(math, ams, rel, "\u223d", "\\backsim");
defineSymbol(math, ams, rel, "\u22cd", "\\backsimeq");
defineSymbol(math, ams, rel, "\u2ac5", "\\subseteqq");
defineSymbol(math, ams, rel, "\u22d0", "\\Subset");
defineSymbol(math, ams, rel, "\u228f", "\\sqsubset");
defineSymbol(math, ams, rel, "\u227c", "\\preccurlyeq");
defineSymbol(math, ams, rel, "\u22de", "\\curlyeqprec");
defineSymbol(math, ams, rel, "\u227e", "\\precsim");
defineSymbol(math, ams, rel, "\u2ab7", "\\precapprox");
defineSymbol(math, ams, rel, "\u22b2", "\\vartriangleleft");
defineSymbol(math, ams, rel, "\u22b4", "\\trianglelefteq");
defineSymbol(math, ams, rel, "\u22a8", "\\vDash");
defineSymbol(math, ams, rel, "\u22aa", "\\Vvdash");
defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
defineSymbol(math, ams, rel, "\u224f", "\\bumpeq");
defineSymbol(math, ams, rel, "\u224e", "\\Bumpeq");
defineSymbol(math, ams, rel, "\u2267", "\\geqq");
defineSymbol(math, ams, rel, "\u2a7e", "\\geqslant");
defineSymbol(math, ams, rel, "\u2a96", "\\eqslantgtr");
defineSymbol(math, ams, rel, "\u2273", "\\gtrsim");
defineSymbol(math, ams, rel, "\u2a86", "\\gtrapprox");
defineSymbol(math, ams, bin, "\u22d7", "\\gtrdot");
defineSymbol(math, ams, rel, "\u22d9", "\\ggg");
defineSymbol(math, ams, rel, "\u2277", "\\gtrless");
defineSymbol(math, ams, rel, "\u22db", "\\gtreqless");
defineSymbol(math, ams, rel, "\u2a8c", "\\gtreqqless");
defineSymbol(math, ams, rel, "\u2256", "\\eqcirc");
defineSymbol(math, ams, rel, "\u2257", "\\circeq");
defineSymbol(math, ams, rel, "\u225c", "\\triangleq");
defineSymbol(math, ams, rel, "\u223c", "\\thicksim");
defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
defineSymbol(math, ams, rel, "\u2ac6", "\\supseteqq");
defineSymbol(math, ams, rel, "\u22d1", "\\Supset");
defineSymbol(math, ams, rel, "\u2290", "\\sqsupset");
defineSymbol(math, ams, rel, "\u227d", "\\succcurlyeq");
defineSymbol(math, ams, rel, "\u22df", "\\curlyeqsucc");
defineSymbol(math, ams, rel, "\u227f", "\\succsim");
defineSymbol(math, ams, rel, "\u2ab8", "\\succapprox");
defineSymbol(math, ams, rel, "\u22b3", "\\vartriangleright");
defineSymbol(math, ams, rel, "\u22b5", "\\trianglerighteq");
defineSymbol(math, ams, rel, "\u22a9", "\\Vdash");
defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
defineSymbol(math, ams, rel, "\u226c", "\\between");
defineSymbol(math, ams, rel, "\u22d4", "\\pitchfork");
defineSymbol(math, ams, rel, "\u221d", "\\varpropto");
defineSymbol(math, ams, rel, "\u25c0", "\\blacktriangleleft");
defineSymbol(math, ams, rel, "\u2234", "\\therefore");
defineSymbol(math, ams, rel, "\u220d", "\\backepsilon");
defineSymbol(math, ams, rel, "\u25b6", "\\blacktriangleright");
defineSymbol(math, ams, rel, "\u2235", "\\because");
defineSymbol(math, ams, rel, "\u22d8", "\\llless");
defineSymbol(math, ams, rel, "\u22d9", "\\gggtr");
defineSymbol(math, ams, bin, "\u22b2", "\\lhd");
defineSymbol(math, ams, bin, "\u22b3", "\\rhd");
defineSymbol(math, ams, rel, "\u2242", "\\eqsim");
defineSymbol(math, main, rel, "\u22c8", "\\Join");
defineSymbol(math, ams, rel, "\u2251", "\\Doteq");

// AMS Binary Operators
defineSymbol(math, ams, bin, "\u2214", "\\dotplus");
defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
defineSymbol(math, ams, bin, "\u22d2", "\\Cap");
defineSymbol(math, ams, bin, "\u22d3", "\\Cup");
defineSymbol(math, ams, bin, "\u2a5e", "\\doublebarwedge");
defineSymbol(math, ams, bin, "\u229f", "\\boxminus");
defineSymbol(math, ams, bin, "\u229e", "\\boxplus");
defineSymbol(math, ams, bin, "\u22c7", "\\divideontimes");
defineSymbol(math, ams, bin, "\u22c9", "\\ltimes");
defineSymbol(math, ams, bin, "\u22ca", "\\rtimes");
defineSymbol(math, ams, bin, "\u22cb", "\\leftthreetimes");
defineSymbol(math, ams, bin, "\u22cc", "\\rightthreetimes");
defineSymbol(math, ams, bin, "\u22cf", "\\curlywedge");
defineSymbol(math, ams, bin, "\u22ce", "\\curlyvee");
defineSymbol(math, ams, bin, "\u229d", "\\circleddash");
defineSymbol(math, ams, bin, "\u229b", "\\circledast");
defineSymbol(math, ams, bin, "\u22c5", "\\centerdot");
defineSymbol(math, ams, bin, "\u22ba", "\\intercal");
defineSymbol(math, ams, bin, "\u22d2", "\\doublecap");
defineSymbol(math, ams, bin, "\u22d3", "\\doublecup");
defineSymbol(math, ams, bin, "\u22a0", "\\boxtimes");

// AMS Arrows
defineSymbol(math, ams, rel, "\u21e2", "\\dashrightarrow");
defineSymbol(math, ams, rel, "\u21e0", "\\dashleftarrow");
defineSymbol(math, ams, rel, "\u21c7", "\\leftleftarrows");
defineSymbol(math, ams, rel, "\u21c6", "\\leftrightarrows");
defineSymbol(math, ams, rel, "\u21da", "\\Lleftarrow");
defineSymbol(math, ams, rel, "\u219e", "\\twoheadleftarrow");
defineSymbol(math, ams, rel, "\u21a2", "\\leftarrowtail");
defineSymbol(math, ams, rel, "\u21ab", "\\looparrowleft");
defineSymbol(math, ams, rel, "\u21cb", "\\leftrightharpoons");
defineSymbol(math, ams, rel, "\u21b6", "\\curvearrowleft");
defineSymbol(math, ams, rel, "\u21ba", "\\circlearrowleft");
defineSymbol(math, ams, rel, "\u21b0", "\\Lsh");
defineSymbol(math, ams, rel, "\u21c8", "\\upuparrows");
defineSymbol(math, ams, rel, "\u21bf", "\\upharpoonleft");
defineSymbol(math, ams, rel, "\u21c3", "\\downharpoonleft");
defineSymbol(math, ams, rel, "\u22b8", "\\multimap");
defineSymbol(math, ams, rel, "\u21ad", "\\leftrightsquigarrow");
defineSymbol(math, ams, rel, "\u21c9", "\\rightrightarrows");
defineSymbol(math, ams, rel, "\u21c4", "\\rightleftarrows");
defineSymbol(math, ams, rel, "\u21a0", "\\twoheadrightarrow");
defineSymbol(math, ams, rel, "\u21a3", "\\rightarrowtail");
defineSymbol(math, ams, rel, "\u21ac", "\\looparrowright");
defineSymbol(math, ams, rel, "\u21b7", "\\curvearrowright");
defineSymbol(math, ams, rel, "\u21bb", "\\circlearrowright");
defineSymbol(math, ams, rel, "\u21b1", "\\Rsh");
defineSymbol(math, ams, rel, "\u21ca", "\\downdownarrows");
defineSymbol(math, ams, rel, "\u21be", "\\upharpoonright");
defineSymbol(math, ams, rel, "\u21c2", "\\downharpoonright");
defineSymbol(math, ams, rel, "\u21dd", "\\rightsquigarrow");
defineSymbol(math, ams, rel, "\u21dd", "\\leadsto");
defineSymbol(math, ams, rel, "\u21db", "\\Rrightarrow");
defineSymbol(math, ams, rel, "\u21be", "\\restriction");

defineSymbol(math, main, textord, "\u2018", "`");
defineSymbol(math, main, textord, "$", "\\$");
defineSymbol(text, main, textord, "$", "\\$");
defineSymbol(math, main, textord, "%", "\\%");
defineSymbol(text, main, textord, "%", "\\%");
defineSymbol(math, main, textord, "_", "\\_");
defineSymbol(text, main, textord, "_", "\\_");
defineSymbol(math, main, textord, "\u2220", "\\angle");
defineSymbol(math, main, textord, "\u221e", "\\infty");
defineSymbol(math, main, textord, "\u2032", "\\prime");
defineSymbol(math, main, textord, "\u25b3", "\\triangle");
defineSymbol(math, main, textord, "\u0393", "\\Gamma");
defineSymbol(math, main, textord, "\u0394", "\\Delta");
defineSymbol(math, main, textord, "\u0398", "\\Theta");
defineSymbol(math, main, textord, "\u039b", "\\Lambda");
defineSymbol(math, main, textord, "\u039e", "\\Xi");
defineSymbol(math, main, textord, "\u03a0", "\\Pi");
defineSymbol(math, main, textord, "\u03a3", "\\Sigma");
defineSymbol(math, main, textord, "\u03a5", "\\Upsilon");
defineSymbol(math, main, textord, "\u03a6", "\\Phi");
defineSymbol(math, main, textord, "\u03a8", "\\Psi");
defineSymbol(math, main, textord, "\u03a9", "\\Omega");
defineSymbol(math, main, textord, "\u00ac", "\\neg");
defineSymbol(math, main, textord, "\u00ac", "\\lnot");
defineSymbol(math, main, textord, "\u22a4", "\\top");
defineSymbol(math, main, textord, "\u22a5", "\\bot");
defineSymbol(math, main, textord, "\u2205", "\\emptyset");
defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
defineSymbol(math, main, mathord, "\u03b1", "\\alpha");
defineSymbol(math, main, mathord, "\u03b2", "\\beta");
defineSymbol(math, main, mathord, "\u03b3", "\\gamma");
defineSymbol(math, main, mathord, "\u03b4", "\\delta");
defineSymbol(math, main, mathord, "\u03f5", "\\epsilon");
defineSymbol(math, main, mathord, "\u03b6", "\\zeta");
defineSymbol(math, main, mathord, "\u03b7", "\\eta");
defineSymbol(math, main, mathord, "\u03b8", "\\theta");
defineSymbol(math, main, mathord, "\u03b9", "\\iota");
defineSymbol(math, main, mathord, "\u03ba", "\\kappa");
defineSymbol(math, main, mathord, "\u03bb", "\\lambda");
defineSymbol(math, main, mathord, "\u03bc", "\\mu");
defineSymbol(math, main, mathord, "\u03bd", "\\nu");
defineSymbol(math, main, mathord, "\u03be", "\\xi");
defineSymbol(math, main, mathord, "o", "\\omicron");
defineSymbol(math, main, mathord, "\u03c0", "\\pi");
defineSymbol(math, main, mathord, "\u03c1", "\\rho");
defineSymbol(math, main, mathord, "\u03c3", "\\sigma");
defineSymbol(math, main, mathord, "\u03c4", "\\tau");
defineSymbol(math, main, mathord, "\u03c5", "\\upsilon");
defineSymbol(math, main, mathord, "\u03d5", "\\phi");
defineSymbol(math, main, mathord, "\u03c7", "\\chi");
defineSymbol(math, main, mathord, "\u03c8", "\\psi");
defineSymbol(math, main, mathord, "\u03c9", "\\omega");
defineSymbol(math, main, mathord, "\u03b5", "\\varepsilon");
defineSymbol(math, main, mathord, "\u03d1", "\\vartheta");
defineSymbol(math, main, mathord, "\u03d6", "\\varpi");
defineSymbol(math, main, mathord, "\u03f1", "\\varrho");
defineSymbol(math, main, mathord, "\u03c2", "\\varsigma");
defineSymbol(math, main, mathord, "\u03c6", "\\varphi");
defineSymbol(math, main, bin, "\u2217", "*");
defineSymbol(math, main, bin, "+", "+");
defineSymbol(math, main, bin, "\u2212", "-");
defineSymbol(math, main, bin, "\u22c5", "\\cdot");
defineSymbol(math, main, bin, "\u2218", "\\circ");
defineSymbol(math, main, bin, "\u00f7", "\\div");
defineSymbol(math, main, bin, "\u00b1", "\\pm");
defineSymbol(math, main, bin, "\u00d7", "\\times");
defineSymbol(math, main, bin, "\u2229", "\\cap");
defineSymbol(math, main, bin, "\u222a", "\\cup");
defineSymbol(math, main, bin, "\u2216", "\\setminus");
defineSymbol(math, main, bin, "\u2227", "\\land");
defineSymbol(math, main, bin, "\u2228", "\\lor");
defineSymbol(math, main, bin, "\u2227", "\\wedge");
defineSymbol(math, main, bin, "\u2228", "\\vee");
defineSymbol(math, main, textord, "\u221a", "\\surd");
defineSymbol(math, main, open, "(", "(");
defineSymbol(math, main, open, "[", "[");
defineSymbol(math, main, open, "\u27e8", "\\langle");
defineSymbol(math, main, open, "\u2223", "\\lvert");
defineSymbol(math, main, open, "\u2225", "\\lVert");
defineSymbol(math, main, close, ")", ")");
defineSymbol(math, main, close, "]", "]");
defineSymbol(math, main, close, "?", "?");
defineSymbol(math, main, close, "!", "!");
defineSymbol(math, main, close, "\u27e9", "\\rangle");
defineSymbol(math, main, close, "\u2223", "\\rvert");
defineSymbol(math, main, close, "\u2225", "\\rVert");
defineSymbol(math, main, rel, "=", "=");
defineSymbol(math, main, rel, "<", "<");
defineSymbol(math, main, rel, ">", ">");
defineSymbol(math, main, rel, ":", ":");
defineSymbol(math, main, rel, "\u2248", "\\approx");
defineSymbol(math, main, rel, "\u2245", "\\cong");
defineSymbol(math, main, rel, "\u2265", "\\ge");
defineSymbol(math, main, rel, "\u2265", "\\geq");
defineSymbol(math, main, rel, "\u2190", "\\gets");
defineSymbol(math, main, rel, ">", "\\gt");
defineSymbol(math, main, rel, "\u2208", "\\in");
defineSymbol(math, main, rel, "\u2209", "\\notin");
defineSymbol(math, main, rel, "\u2282", "\\subset");
defineSymbol(math, main, rel, "\u2283", "\\supset");
defineSymbol(math, main, rel, "\u2286", "\\subseteq");
defineSymbol(math, main, rel, "\u2287", "\\supseteq");
defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq");
defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq");
defineSymbol(math, main, rel, "\u22a8", "\\models");
defineSymbol(math, main, rel, "\u2190", "\\leftarrow");
defineSymbol(math, main, rel, "\u2264", "\\le");
defineSymbol(math, main, rel, "\u2264", "\\leq");
defineSymbol(math, main, rel, "<", "\\lt");
defineSymbol(math, main, rel, "\u2260", "\\ne");
defineSymbol(math, main, rel, "\u2260", "\\neq");
defineSymbol(math, main, rel, "\u2192", "\\rightarrow");
defineSymbol(math, main, rel, "\u2192", "\\to");
defineSymbol(math, ams, rel, "\u2271", "\\ngeq");
defineSymbol(math, ams, rel, "\u2270", "\\nleq");
defineSymbol(math, main, spacing, null, "\\!");
defineSymbol(math, main, spacing, "\u00a0", "\\ ");
defineSymbol(math, main, spacing, "\u00a0", "~");
defineSymbol(math, main, spacing, null, "\\,");
defineSymbol(math, main, spacing, null, "\\:");
defineSymbol(math, main, spacing, null, "\\;");
defineSymbol(math, main, spacing, null, "\\enspace");
defineSymbol(math, main, spacing, null, "\\qquad");
defineSymbol(math, main, spacing, null, "\\quad");
defineSymbol(math, main, spacing, "\u00a0", "\\space");
defineSymbol(math, main, punct, ",", ",");
defineSymbol(math, main, punct, ";", ";");
defineSymbol(math, main, punct, ":", "\\colon");
defineSymbol(math, ams, bin, "\u22bc", "\\barwedge");
defineSymbol(math, ams, bin, "\u22bb", "\\veebar");
defineSymbol(math, main, bin, "\u2299", "\\odot");
defineSymbol(math, main, bin, "\u2295", "\\oplus");
defineSymbol(math, main, bin, "\u2297", "\\otimes");
defineSymbol(math, main, textord, "\u2202", "\\partial");
defineSymbol(math, main, bin, "\u2298", "\\oslash");
defineSymbol(math, ams, bin, "\u229a", "\\circledcirc");
defineSymbol(math, ams, bin, "\u22a1", "\\boxdot");
defineSymbol(math, main, bin, "\u25b3", "\\bigtriangleup");
defineSymbol(math, main, bin, "\u25bd", "\\bigtriangledown");
defineSymbol(math, main, bin, "\u2020", "\\dagger");
defineSymbol(math, main, bin, "\u22c4", "\\diamond");
defineSymbol(math, main, bin, "\u22c6", "\\star");
defineSymbol(math, main, bin, "\u25c3", "\\triangleleft");
defineSymbol(math, main, bin, "\u25b9", "\\triangleright");
defineSymbol(math, main, open, "{", "\\{");
defineSymbol(text, main, textord, "{", "\\{");
defineSymbol(math, main, close, "}", "\\}");
defineSymbol(text, main, textord, "}", "\\}");
defineSymbol(math, main, open, "{", "\\lbrace");
defineSymbol(math, main, close, "}", "\\rbrace");
defineSymbol(math, main, open, "[", "\\lbrack");
defineSymbol(math, main, close, "]", "\\rbrack");
defineSymbol(math, main, open, "\u230a", "\\lfloor");
defineSymbol(math, main, close, "\u230b", "\\rfloor");
defineSymbol(math, main, open, "\u2308", "\\lceil");
defineSymbol(math, main, close, "\u2309", "\\rceil");
defineSymbol(math, main, textord, "\\", "\\backslash");
defineSymbol(math, main, textord, "\u2223", "|");
defineSymbol(math, main, textord, "\u2223", "\\vert");
defineSymbol(math, main, textord, "\u2225", "\\|");
defineSymbol(math, main, textord, "\u2225", "\\Vert");
defineSymbol(math, main, rel, "\u2191", "\\uparrow");
defineSymbol(math, main, rel, "\u21d1", "\\Uparrow");
defineSymbol(math, main, rel, "\u2193", "\\downarrow");
defineSymbol(math, main, rel, "\u21d3", "\\Downarrow");
defineSymbol(math, main, rel, "\u2195", "\\updownarrow");
defineSymbol(math, main, rel, "\u21d5", "\\Updownarrow");
defineSymbol(math, math, op, "\u2210", "\\coprod");
defineSymbol(math, math, op, "\u22c1", "\\bigvee");
defineSymbol(math, math, op, "\u22c0", "\\bigwedge");
defineSymbol(math, math, op, "\u2a04", "\\biguplus");
defineSymbol(math, math, op, "\u22c2", "\\bigcap");
defineSymbol(math, math, op, "\u22c3", "\\bigcup");
defineSymbol(math, math, op, "\u222b", "\\int");
defineSymbol(math, math, op, "\u222b", "\\intop");
defineSymbol(math, math, op, "\u222c", "\\iint");
defineSymbol(math, math, op, "\u222d", "\\iiint");
defineSymbol(math, math, op, "\u220f", "\\prod");
defineSymbol(math, math, op, "\u2211", "\\sum");
defineSymbol(math, math, op, "\u2a02", "\\bigotimes");
defineSymbol(math, math, op, "\u2a01", "\\bigoplus");
defineSymbol(math, math, op, "\u2a00", "\\bigodot");
defineSymbol(math, math, op, "\u222e", "\\oint");
defineSymbol(math, math, op, "\u2a06", "\\bigsqcup");
defineSymbol(math, math, op, "\u222b", "\\smallint");
defineSymbol(text, main, inner, "\u2026", "\\textellipsis");
defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
defineSymbol(text, main, inner, "\u2026", "\\ldots");
defineSymbol(math, main, inner, "\u2026", "\\ldots");
defineSymbol(math, main, inner, "\u22ef", "\\cdots");
defineSymbol(math, main, inner, "\u22f1", "\\ddots");
defineSymbol(math, main, textord, "\u22ee", "\\vdots");
defineSymbol(math, main, accent, "\u00b4", "\\acute");
defineSymbol(math, main, accent, "\u0060", "\\grave");
defineSymbol(math, main, accent, "\u00a8", "\\ddot");
defineSymbol(math, main, accent, "\u007e", "\\tilde");
defineSymbol(math, main, accent, "\u00af", "\\bar");
defineSymbol(math, main, accent, "\u02d8", "\\breve");
defineSymbol(math, main, accent, "\u02c7", "\\check");
defineSymbol(math, main, accent, "\u005e", "\\hat");
defineSymbol(math, main, accent, "\u20d7", "\\vec");
defineSymbol(math, main, accent, "\u02d9", "\\dot");
defineSymbol(math, main, mathord, "\u0131", "\\imath");
defineSymbol(math, main, mathord, "\u0237", "\\jmath");

defineSymbol(text, main, textord, "\u2013", "--");
defineSymbol(text, main, textord, "\u2014", "---");
defineSymbol(text, main, textord, "\u2018", "`");
defineSymbol(text, main, textord, "\u2019", "'");
defineSymbol(text, main, textord, "\u201c", "``");
defineSymbol(text, main, textord, "\u201d", "''");
defineSymbol(math, main, textord, "\u00b0", "\\degree");
defineSymbol(text, main, textord, "\u00b0", "\\degree");
defineSymbol(math, main, mathord, "\u00a3", "\\pounds");
defineSymbol(math, ams, textord, "\u2720", "\\maltese");
defineSymbol(text, ams, textord, "\u2720", "\\maltese");

defineSymbol(text, main, spacing, "\u00a0", "\\ ");
defineSymbol(text, main, spacing, "\u00a0", " ");
defineSymbol(text, main, spacing, "\u00a0", "~");

// There are lots of symbols which are the same, so we add them in afterwards.
var i;
var ch;

// All of these are textords in math mode
var mathTextSymbols = "0123456789/@.\"";
for (i = 0; i < mathTextSymbols.length; i++) {
    ch = mathTextSymbols.charAt(i);
    defineSymbol(math, main, textord, ch, ch);
}

// All of these are textords in text mode
var textSymbols = "0123456789!@*()-=+[]\";:?/.,";
for (i = 0; i < textSymbols.length; i++) {
    ch = textSymbols.charAt(i);
    defineSymbol(text, main, textord, ch, ch);
}

// All of these are textords in text mode, and mathords in math mode
var letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
for (i = 0; i < letters.length; i++) {
    ch = letters.charAt(i);
    defineSymbol(math, main, mathord, ch, ch);
    defineSymbol(text, main, textord, ch, ch);
}

// Latin-1 letters
for (i = 0x00C0; i <= 0x00D6; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

for (i = 0x00D8; i <= 0x00F6; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

for (i = 0x00F8; i <= 0x00FF; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

// Cyrillic
for (i = 0x0410; i <= 0x044F; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

// Unicode versions of existing characters
defineSymbol(text, main, textord, "\u2013", "");
defineSymbol(text, main, textord, "\u2014", "");
defineSymbol(text, main, textord, "\u2018", "");
defineSymbol(text, main, textord, "\u2019", "");
defineSymbol(text, main, textord, "\u201c", "");
defineSymbol(text, main, textord, "\u201d", "");

},{}],113:[function(require,module,exports){
var hangulRegex = /[\uAC00-\uD7AF]/;

// This regex combines
// - Hiragana: [\u3040-\u309F]
// - Katakana: [\u30A0-\u30FF]
// - CJK ideograms: [\u4E00-\u9FAF]
// - Hangul syllables: [\uAC00-\uD7AF]
// Notably missing are halfwidth Katakana and Romanji glyphs.
var cjkRegex =
    /[\u3040-\u309F]|[\u30A0-\u30FF]|[\u4E00-\u9FAF]|[\uAC00-\uD7AF]/;

module.exports = {
    cjkRegex: cjkRegex,
    hangulRegex: hangulRegex
};

},{}],114:[function(require,module,exports){
/**
 * This file contains a list of utility functions which are useful in other
 * files.
 */

/**
 * Provide an `indexOf` function which works in IE8, but defers to native if
 * possible.
 */
var nativeIndexOf = Array.prototype.indexOf;
var indexOf = function(list, elem) {
    if (list == null) {
        return -1;
    }
    if (nativeIndexOf && list.indexOf === nativeIndexOf) {
        return list.indexOf(elem);
    }
    var i = 0;
    var l = list.length;
    for (; i < l; i++) {
        if (list[i] === elem) {
            return i;
        }
    }
    return -1;
};

/**
 * Return whether an element is contained in a list
 */
var contains = function(list, elem) {
    return indexOf(list, elem) !== -1;
};

/**
 * Provide a default value if a setting is undefined
 */
var deflt = function(setting, defaultIfUndefined) {
    return setting === undefined ? defaultIfUndefined : setting;
};

// hyphenate and escape adapted from Facebook's React under Apache 2 license

var uppercase = /([A-Z])/g;
var hyphenate = function(str) {
    return str.replace(uppercase, "-$1").toLowerCase();
};

var ESCAPE_LOOKUP = {
    "&": "&amp;",
    ">": "&gt;",
    "<": "&lt;",
    "\"": "&quot;",
    "'": "&#x27;"
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
    return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escape(text) {
    return ("" + text).replace(ESCAPE_REGEX, escaper);
}

/**
 * A function to set the text content of a DOM element in all supported
 * browsers. Note that we don't define this if there is no document.
 */
var setTextContent;
if (typeof document !== "undefined") {
    var testNode = document.createElement("span");
    if ("textContent" in testNode) {
        setTextContent = function(node, text) {
            node.textContent = text;
        };
    } else {
        setTextContent = function(node, text) {
            node.innerText = text;
        };
    }
}

/**
 * A function to clear a node.
 */
function clearNode(node) {
    setTextContent(node, "");
}

module.exports = {
    contains: contains,
    deflt: deflt,
    escape: escape,
    hyphenate: hyphenate,
    indexOf: indexOf,
    setTextContent: setTextContent,
    clearNode: clearNode
};

},{}],115:[function(require,module,exports){
/** @flow */

"use strict";

function getRelocatable(re) {
  // In the future, this could use a WeakMap instead of an expando.
  if (!re.__matchAtRelocatable) {
    // Disjunctions are the lowest-precedence operator, so we can make any
    // pattern match the empty string by appending `|()` to it:
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-patterns
    var source = re.source + "|()";

    // We always make the new regex global.
    var flags = "g" + (re.ignoreCase ? "i" : "") + (re.multiline ? "m" : "") + (re.unicode ? "u" : "")
    // sticky (/.../y) doesn't make sense in conjunction with our relocation
    // logic, so we ignore it here.
    ;

    re.__matchAtRelocatable = new RegExp(source, flags);
  }
  return re.__matchAtRelocatable;
}

function matchAt(re, str, pos) {
  if (re.global || re.sticky) {
    throw new Error("matchAt(...): Only non-global regexes are supported");
  }
  var reloc = getRelocatable(re);
  reloc.lastIndex = pos;
  var match = reloc.exec(str);
  // Last capturing group is our sentinel that indicates whether the regex
  // matched at the given location.
  if (match[match.length - 1] == null) {
    // Original regex matched.
    match.length = match.length - 1;
    return match;
  } else {
    return null;
  }
}

module.exports = matchAt;
},{}],116:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber);
exports.InnerSubscriber = InnerSubscriber;


},{"./Subscriber":123}],117:[function(require,module,exports){
"use strict";

var root_1 = require('./util/root');
var toSubscriber_1 = require('./util/toSubscriber');
var observable_1 = require('./symbol/observable');
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        } else {
            sink.add(this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        } catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            } else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    } catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                } else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}();
exports.Observable = Observable;


},{"./symbol/observable":157,"./util/root":170,"./util/toSubscriber":172}],118:[function(require,module,exports){
"use strict";

exports.empty = {
    closed: true,
    next: function (value) {},
    error: function (err) {
        throw err;
    },
    complete: function () {}
};


},{}],119:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber);
exports.OuterSubscriber = OuterSubscriber;


},{"./Subscriber":123}],120:[function(require,module,exports){
"use strict";
/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */

var Scheduler = function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () {
        return +new Date();
    };
    return Scheduler;
}();
exports.Scheduler = Scheduler;


},{}],121:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber);
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        } else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable);
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        } else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject);
exports.AnonymousSubject = AnonymousSubject;


},{"./Observable":117,"./SubjectSubscription":122,"./Subscriber":123,"./Subscription":124,"./symbol/rxSubscriber":158,"./util/ObjectUnsubscribedError":159}],122:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription);
exports.SubjectSubscription = SubjectSubscription;


},{"./Subscription":124}],123:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    } else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () {
        return this;
    };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription);
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        } else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer_1.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = this.unsubscribe.bind(this);
            }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            } else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            } else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._complete);
                    this.unsubscribe();
                }
            } else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber);


},{"./Observer":118,"./Subscription":124,"./symbol/rxSubscriber":158,"./util/isFunction":165}],124:[function(require,module,exports){
"use strict";

var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents,
            _unsubscribe = _a._unsubscribe,
            _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        } else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || teardown === Subscription.EMPTY) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                } else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                } else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        } else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        } else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription());
    return Subscription;
}();
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) {
        return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
    }, []);
}


},{"./util/UnsubscriptionError":160,"./util/errorObject":161,"./util/isArray":162,"./util/isFunction":165,"./util/isObject":167,"./util/tryCatch":173}],125:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var ScalarObservable_1 = require('./ScalarObservable');
var EmptyObservable_1 = require('./EmptyObservable');
var isScheduler_1 = require('../util/isScheduler');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        } else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        } else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        } else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array,
            index = state.index,
            count = state.count,
            subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable);
exports.ArrayObservable = ArrayObservable;


},{"../Observable":117,"../util/isScheduler":169,"./EmptyObservable":127,"./ScalarObservable":129}],126:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('../Subject');
var Observable_1 = require('../Observable');
var Subscriber_1 = require('../Subscriber');
var Subscription_1 = require('../Subscription');
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            } else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return this.lift(new RefCountOperator(this));
    };
    return ConnectableObservable;
}(Observable_1.Observable);
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: ConnectableObservable.prototype._subscribe },
    getSubject: { value: ConnectableObservable.prototype.getSubject },
    connect: { value: ConnectableObservable.prototype.connect },
    refCount: { value: ConnectableObservable.prototype.refCount }
};
var ConnectableSubscriber = function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber);
var RefCountOperator = function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}();
var RefCountSubscriber = function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber);


},{"../Observable":117,"../Subject":121,"../Subscriber":123,"../Subscription":124}],127:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        } else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable);
exports.EmptyObservable = EmptyObservable;


},{"../Observable":117}],128:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var tryCatch_1 = require('../util/tryCatch');
var isFunction_1 = require('../util/isFunction');
var errorObject_1 = require('../util/errorObject');
var Subscription_1 = require('../Subscription');
var toString = Object.prototype.toString;
function isNodeStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isNodeList(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
}
function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
}
function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventObservable = function (_super) {
    __extends(FromEventObservable, _super);
    function FromEventObservable(sourceObj, eventName, selector, options) {
        _super.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
        this.options = options;
    }
    /* tslint:enable:max-line-length */
    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * Creates an Observable by attaching an event listener to an "event target",
     * which may be an object with `addEventListener` and `removeEventListener`,
     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
     * the output Observable is subscribed, and removed when the Subscription is
     * unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console everytime a click
     * // occurs on the document.
     *
     * @see {@link from}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOMElement, event target, Node.js
     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @param {SelectorMethodSignature<T>} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    FromEventObservable.create = function (target, eventName, options, selector) {
        if (isFunction_1.isFunction(options)) {
            selector = options;
            options = undefined;
        }
        return new FromEventObservable(target, eventName, selector, options);
    };
    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        } else if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function () {
                return source_1.removeEventListener(eventName, handler);
            };
        } else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function () {
                return source_2.off(eventName, handler);
            };
        } else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () {
                return source_3.removeListener(eventName, handler);
            };
        } else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(new Subscription_1.Subscription(unsubscribe));
    };
    FromEventObservable.prototype._subscribe = function (subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var options = this.options;
        var selector = this.selector;
        var handler = selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
            if (result === errorObject_1.errorObject) {
                subscriber.error(errorObject_1.errorObject.e);
            } else {
                subscriber.next(result);
            }
        } : function (e) {
            return subscriber.next(e);
        };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
    };
    return FromEventObservable;
}(Observable_1.Observable);
exports.FromEventObservable = FromEventObservable;


},{"../Observable":117,"../Subscription":124,"../util/errorObject":161,"../util/isFunction":165,"../util/tryCatch":173}],129:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done,
            value = state.value,
            subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        } else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable);
exports.ScalarObservable = ScalarObservable;


},{"../Observable":117}],130:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = require('../util/isNumeric');
var Observable_1 = require('../Observable');
var async_1 = require('../scheduler/async');
var isScheduler_1 = require('../util/isScheduler');
var isDate_1 = require('../util/isDate');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = function (_super) {
    __extends(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) {
            dueTime = 0;
        }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        } else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ? +dueTime - this.scheduler.now() : dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) {
            initialDelay = 0;
        }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index,
            period = state.period,
            subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        } else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            period = _a.period,
            dueTime = _a.dueTime,
            scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable);
exports.TimerObservable = TimerObservable;


},{"../Observable":117,"../scheduler/async":155,"../util/isDate":164,"../util/isNumeric":166,"../util/isScheduler":169}],131:[function(require,module,exports){
"use strict";

var EmptyObservable_1 = require('./EmptyObservable');
exports.empty = EmptyObservable_1.EmptyObservable.create;


},{"./EmptyObservable":127}],132:[function(require,module,exports){
"use strict";

var FromEventObservable_1 = require('./FromEventObservable');
exports.fromEvent = FromEventObservable_1.FromEventObservable.create;


},{"./FromEventObservable":128}],133:[function(require,module,exports){
"use strict";

var ArrayObservable_1 = require('./ArrayObservable');
exports.of = ArrayObservable_1.ArrayObservable.of;


},{"./ArrayObservable":125}],134:[function(require,module,exports){
"use strict";

var TimerObservable_1 = require('./TimerObservable');
exports.timer = TimerObservable_1.TimerObservable.create;


},{"./TimerObservable":130}],135:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @name catch
 * @owner Observable
 */
function _catch(selector) {
    var operator = new CatchOperator(selector);
    var caught = this.lift(operator);
    return operator.caught = caught;
}
exports._catch = _catch;
var CatchOperator = function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            } catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":119,"../util/subscribeToResult":171}],136:[function(require,module,exports){
"use strict";

var Observable_1 = require('../Observable');
var isScheduler_1 = require('../util/isScheduler');
var ArrayObservable_1 = require('../observable/ArrayObservable');
var mergeAll_1 = require('./mergeAll');
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));
}
exports.concat = concat;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from given
 * Observable and then moves on to the next.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * `concat` joins multiple Observables together, by subscribing to them one at a time and
 * merging their results into the output Observable. You can pass either an array of
 * Observables, or put them directly as arguments. Passing an empty array will result
 * in Observable that completes immediately.
 *
 * `concat` will subscribe to first input Observable and emit all its values, without
 * changing or affecting them in any way. When that Observable completes, it will
 * subscribe to then next Observable passed and, again, emit its values. This will be
 * repeated, until the operator runs out of Observables. When last input Observable completes,
 * `concat` will complete as well. At any given moment only one Observable passed to operator
 * emits values. If you would like to emit values from passed Observables concurrently, check out
 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
 *
 * Note that if some input Observable never completes, `concat` will also never complete
 * and Observables following the one that did not complete will never be subscribed. On the other
 * hand, if some Observable simply completes immediately after it is subscribed, it will be
 * invisible for `concat`, which will just move on to the next Observable.
 *
 * If any Observable in chain errors, instead of passing control to the next Observable,
 * `concat` will error immediately as well. Observables that would be subscribed after
 * the one that emitted error, never will.
 *
 * If you pass to `concat` the same Observable many times, its stream of values
 * will be "replayed" on every subscription, which means you can repeat given Observable
 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
 * you can always use {@link repeat}.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 *
 * @example <caption>Concatenate an array of 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 *
 * @example <caption>Concatenate the same Observable to repeat it</caption>
 * const timer = Rx.Observable.interval(1000).take(2);
 *
 * Rx.Observable.concat(timer, timer) // concating the same Observable!
 * .subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('...and it is done!')
 * );
 *
 * // Logs:
 * // 0 after 1s
 * // 1 after 2s
 * // 0 after 3s
 * // 1 after 4s
 * // "...and it is done!" also after 4s
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} input1 An input Observable to concatenate with others.
 * @param {ObservableInput} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */
function concatStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var scheduler = null;
    var args = observables;
    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
        scheduler = args.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
}
exports.concatStatic = concatStatic;


},{"../Observable":117,"../observable/ArrayObservable":125,"../util/isScheduler":169,"./mergeAll":143}],137:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var async_1 = require('../scheduler/async');
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber);
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}


},{"../Subscriber":123,"../scheduler/async":155}],138:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
function _do(nextOrObserver, error, complete) {
    return this.lift(new DoOperator(nextOrObserver, error, complete));
}
exports._do = _do;
var DoOperator = function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":123}],139:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable only if the previous projected Observable has completed.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link exhaust}.</span>
 *
 * <img src="./img/exhaustMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. When it projects a source value to
 * an Observable, the output Observable begins emitting the items emitted by
 * that projected Observable. However, `exhaustMap` ignores every new projected
 * Observable if the previous projected Observable has not yet completed. Once
 * that one completes, it will accept and flatten the next projected Observable
 * and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaust}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable containing projected Observables
 * of each item of the source, ignoring projected Observables that start before
 * their preceding Observable has completed.
 * @method exhaustMap
 * @owner Observable
 */
function exhaustMap(project, resultSelector) {
    return this.lift(new SwitchFirstMapOperator(project, resultSelector));
}
exports.exhaustMap = exhaustMap;
var SwitchFirstMapOperator = function () {
    function SwitchFirstMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchFirstMapOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstMapSubscriber = function (_super) {
    __extends(SwitchFirstMapSubscriber, _super);
    function SwitchFirstMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.hasSubscription = false;
        this.hasCompleted = false;
        this.index = 0;
    }
    SwitchFirstMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
        var index = this.index++;
        var destination = this.destination;
        try {
            var result = this.project(value, index);
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
        } catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            destination.next(innerValue);
        }
    };
    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        try {
            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            destination.next(result);
        } catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":119,"../util/subscribeToResult":171}],140:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return this.lift(new FilterOperator(predicate, thisArg));
}
exports.filter = filter;
var FilterOperator = function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
        this.predicate = predicate;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":123}],141:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var Subscription_1 = require('../Subscription');
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function _finally(callback) {
    return this.lift(new FinallyOperator(callback));
}
exports._finally = _finally;
var FinallyOperator = function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        _super.call(this, destination);
        this.add(new Subscription_1.Subscription(callback));
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":123,"../Subscription":124}],142:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return this.lift(new MapOperator(project, thisArg));
}
exports.map = map;
var MapOperator = function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}();
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":123}],143:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return this.lift(new MergeAllOperator(concurrent));
}
exports.mergeAll = mergeAll;
var MergeAllOperator = function () {
    function MergeAllOperator(concurrent) {
        this.concurrent = concurrent;
    }
    MergeAllOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
    };
    return MergeAllOperator;
}();
exports.MergeAllOperator = MergeAllOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeAllSubscriber = function (_super) {
    __extends(MergeAllSubscriber, _super);
    function MergeAllSubscriber(destination, concurrent) {
        _super.call(this, destination);
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
    }
    MergeAllSubscriber.prototype._next = function (observable) {
        if (this.active < this.concurrent) {
            this.active++;
            this.add(subscribeToResult_1.subscribeToResult(this, observable));
        } else {
            this.buffer.push(observable);
        }
    };
    MergeAllSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeAllSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeAllSubscriber = MergeAllSubscriber;


},{"../OuterSubscriber":119,"../util/subscribeToResult":171}],144:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var subscribeToResult_1 = require('../util/subscribeToResult');
var OuterSubscriber_1 = require('../OuterSubscriber');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
}
exports.mergeMap = mergeMap;
var MergeMapOperator = function () {
    function MergeMapOperator(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
    };
    return MergeMapOperator;
}();
exports.MergeMapOperator = MergeMapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        } else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeMapSubscriber = MergeMapSubscriber;


},{"../OuterSubscriber":119,"../util/subscribeToResult":171}],145:[function(require,module,exports){
"use strict";

var ConnectableObservable_1 = require('../observable/ConnectableObservable');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} An Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
function multicast(subjectOrSubjectFactory, selector) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === 'function') {
        subjectFactory = subjectOrSubjectFactory;
    } else {
        subjectFactory = function subjectFactory() {
            return subjectOrSubjectFactory;
        };
    }
    if (typeof selector === 'function') {
        return this.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);
    connectable.source = this;
    connectable.subjectFactory = subjectFactory;
    return connectable;
}
exports.multicast = multicast;
var MulticastOperator = function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}();
exports.MulticastOperator = MulticastOperator;


},{"../observable/ConnectableObservable":126}],146:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise() {
    return this.lift(new PairwiseOperator());
}
exports.pairwise = pairwise;
var PairwiseOperator = function () {
    function PairwiseOperator() {}
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        _super.call(this, destination);
        this.hasPrev = false;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        } else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":123}],147:[function(require,module,exports){
"use strict";

var multicast_1 = require('./multicast');
var Subject_1 = require('../Subject');
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .publish().refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */
function share() {
    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();
}
exports.share = share;
;


},{"../Subject":121,"./multicast":145}],148:[function(require,module,exports){
"use strict";

var ArrayObservable_1 = require('../observable/ArrayObservable');
var ScalarObservable_1 = require('../observable/ScalarObservable');
var EmptyObservable_1 = require('../observable/EmptyObservable');
var concat_1 = require('./concat');
var isScheduler_1 = require('../util/isScheduler');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
    } else {
        scheduler = null;
    }
    var len = array.length;
    if (len === 1) {
        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
    } else if (len > 1) {
        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
    } else {
        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
    }
}
exports.startWith = startWith;


},{"../observable/ArrayObservable":125,"../observable/EmptyObservable":127,"../observable/ScalarObservable":129,"../util/isScheduler":169,"./concat":136}],149:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return this.lift(new SwitchMapOperator(project, resultSelector));
}
exports.switchMap = switchMap;
var SwitchMapOperator = function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":119,"../util/subscribeToResult":171}],150:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return this.lift(new TakeUntilOperator(notifier));
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":119,"../util/subscribeToResult":171}],151:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = require('../observable/ArrayObservable');
var isArray_1 = require('../util/isArray');
var Subscriber_1 = require('../Subscriber');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
var iterator_1 = require('../symbol/iterator');
/* tslint:enable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
function zipProto() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));
}
exports.zipProto = zipProto;
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the latest parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * @example <caption>Combine age and name from different sources</caption>
 *
 * let age$ = Observable.of<number>(27, 25, 29);
 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
 * let isDev$ = Observable.of<boolean>(true, true, false);
 *
 * Observable
 *     .zip(age$,
 *          name$,
 *          isDev$,
 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
 *     .subscribe(x => console.log(x));
 *
 * // outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 *
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */
function zipStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}
exports.zipStatic = zipStatic;
var ZipOperator = function () {
    function ZipOperator(project) {
        this.project = project;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.project));
    };
    return ZipOperator;
}();
exports.ZipOperator = ZipOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = typeof project === 'function' ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[iterator_1.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.iterator]()));
        } else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                this.add(iterator.subscribe(iterator, i));
            } else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        } else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber);
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}();
var StaticArrayIterator = function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator_1.iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        } else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        } else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":119,"../Subscriber":123,"../observable/ArrayObservable":125,"../symbol/iterator":156,"../util/isArray":162,"../util/subscribeToResult":171}],152:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('../Subscription');
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription_1.Subscription);
exports.Action = Action;


},{"../Subscription":124}],153:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Action_1 = require('./Action');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        } else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        } catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.delay = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
    };
    return AsyncAction;
}(Action_1.Action);
exports.AsyncAction = AsyncAction;


},{"../util/root":170,"./Action":152}],154:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = require('../Scheduler');
var AsyncScheduler = function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler);
exports.AsyncScheduler = AsyncScheduler;


},{"../Scheduler":120}],155:[function(require,module,exports){
"use strict";

var AsyncAction_1 = require('./AsyncAction');
var AsyncScheduler_1 = require('./AsyncScheduler');
/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);


},{"./AsyncAction":153,"./AsyncScheduler":154}],156:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function symbolIteratorPonyfill(root) {
    var Symbol = root.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    } else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.iterator = symbolIteratorPonyfill(root_1.root);
/**
 * @deprecated use iterator instead
 */
exports.$$iterator = exports.iterator;


},{"../util/root":170}],157:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        } else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    } else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.observable = getSymbolObservable(root_1.root);
/**
 * @deprecated use observable instead
 */
exports.$$observable = exports.observable;


},{"../util/root":170}],158:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
var Symbol = root_1.root.Symbol;
exports.rxSubscriber = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('rxSubscriber') : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;


},{"../util/root":170}],159:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error);
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;


},{}],160:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) {
            return i + 1 + ") " + err.toString();
        }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error);
exports.UnsubscriptionError = UnsubscriptionError;


},{}],161:[function(require,module,exports){
"use strict";
// typeof any so that it we don't have to cast when comparing a result to the error object

exports.errorObject = { e: {} };


},{}],162:[function(require,module,exports){
"use strict";

exports.isArray = Array.isArray || function (x) {
  return x && typeof x.length === 'number';
};


},{}],163:[function(require,module,exports){
"use strict";

exports.isArrayLike = function (x) {
  return x && typeof x.length === 'number';
};


},{}],164:[function(require,module,exports){
"use strict";

function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;


},{}],165:[function(require,module,exports){
"use strict";

function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;


},{}],166:[function(require,module,exports){
"use strict";

var isArray_1 = require('../util/isArray');
function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray_1.isArray(val) && val - parseFloat(val) + 1 >= 0;
}
exports.isNumeric = isNumeric;
;


},{"../util/isArray":162}],167:[function(require,module,exports){
"use strict";

function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;


},{}],168:[function(require,module,exports){
"use strict";

function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;


},{}],169:[function(require,module,exports){
"use strict";

function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;


},{}],170:[function(require,module,exports){
(function (global){
"use strict";
/**
 * window: browser in DOM main thread
 * self: browser in WebWorker
 * global: Node.js/other
 */

exports.root = typeof window == 'object' && window.window === window && window || typeof self == 'object' && self.self === self && self || typeof global == 'object' && global.global === global && global;
if (!exports.root) {
    throw new Error('RxJS could not find any global context (window, self, global)');
}


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],171:[function(require,module,exports){
"use strict";

var root_1 = require('./root');
var isArrayLike_1 = require('./isArrayLike');
var isPromise_1 = require('./isPromise');
var isObject_1 = require('./isObject');
var Observable_1 = require('../Observable');
var iterator_1 = require('../symbol/iterator');
var InnerSubscriber_1 = require('../InnerSubscriber');
var observable_1 = require('../symbol/observable');
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        } else {
            return result.subscribe(destination);
        }
    } else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    } else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) {
            return destination.error(err);
        }).then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () {
                throw err;
            });
        });
        return destination;
    } else if (result && typeof result[iterator_1.iterator] === 'function') {
        var iterator = result[iterator_1.iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    } else if (result && typeof result[observable_1.observable] === 'function') {
        var obs = result[observable_1.observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        } else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    } else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;


},{"../InnerSubscriber":116,"../Observable":117,"../symbol/iterator":156,"../symbol/observable":157,"./isArrayLike":163,"./isObject":167,"./isPromise":168,"./root":170}],172:[function(require,module,exports){
"use strict";

var Subscriber_1 = require('../Subscriber');
var rxSubscriber_1 = require('../symbol/rxSubscriber');
var Observer_1 = require('../Observer');
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;


},{"../Observer":118,"../Subscriber":123,"../symbol/rxSubscriber":158}],173:[function(require,module,exports){
"use strict";

var errorObject_1 = require('./errorObject');
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    } catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;


},{"./errorObject":161}],174:[function(require,module,exports){
'use strict';

var isArrayish = require('is-arrayish');

var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};

},{"is-arrayish":90}],175:[function(require,module,exports){
// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//     You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//     See the License for the specific language governing permissions and
// limitations under the License.

!function(a,b){var c={},d={},e={},f=null;!function(a,b){function c(a){if("number"==typeof a)return a;var b={};for(var c in a)b[c]=a[c];return b}function d(){this._delay=0,this._endDelay=0,this._fill="none",this._iterationStart=0,this._iterations=1,this._duration=0,this._playbackRate=1,this._direction="normal",this._easing="linear",this._easingFunction=x}function e(){return a.isDeprecated("Invalid timing inputs","2016-03-02","TypeError exceptions will be thrown instead.",!0)}function f(b,c,e){var f=new d;return c&&(f.fill="both",f.duration="auto"),"number"!=typeof b||isNaN(b)?void 0!==b&&Object.getOwnPropertyNames(b).forEach(function(c){if("auto"!=b[c]){if(("number"==typeof f[c]||"duration"==c)&&("number"!=typeof b[c]||isNaN(b[c])))return;if("fill"==c&&v.indexOf(b[c])==-1)return;if("direction"==c&&w.indexOf(b[c])==-1)return;if("playbackRate"==c&&1!==b[c]&&a.isDeprecated("AnimationEffectTiming.playbackRate","2014-11-28","Use Animation.playbackRate instead."))return;f[c]=b[c]}}):f.duration=b,f}function g(a){return"number"==typeof a&&(a=isNaN(a)?{duration:0}:{duration:a}),a}function h(b,c){return b=a.numericTimingToObject(b),f(b,c)}function i(a,b,c,d){return a<0||a>1||c<0||c>1?x:function(e){function f(a,b,c){return 3*a*(1-c)*(1-c)*c+3*b*(1-c)*c*c+c*c*c}if(e<=0){var g=0;return a>0?g=b/a:!b&&c>0&&(g=d/c),g*e}if(e>=1){var h=0;return c<1?h=(d-1)/(c-1):1==c&&a<1&&(h=(b-1)/(a-1)),1+h*(e-1)}for(var i=0,j=1;i<j;){var k=(i+j)/2,l=f(a,c,k);if(Math.abs(e-l)<1e-5)return f(b,d,k);l<e?i=k:j=k}return f(b,d,k)}}function j(a,b){return function(c){if(c>=1)return 1;var d=1/a;return c+=b*d,c-c%d}}function k(a){C||(C=document.createElement("div").style),C.animationTimingFunction="",C.animationTimingFunction=a;var b=C.animationTimingFunction;if(""==b&&e())throw new TypeError(a+" is not a valid value for easing");return b}function l(a){if("linear"==a)return x;var b=E.exec(a);if(b)return i.apply(this,b.slice(1).map(Number));var c=F.exec(a);if(c)return j(Number(c[1]),{start:y,middle:z,end:A}[c[2]]);var d=B[a];return d?d:x}function m(a){return Math.abs(n(a)/a.playbackRate)}function n(a){return 0===a.duration||0===a.iterations?0:a.duration*a.iterations}function o(a,b,c){if(null==b)return G;var d=c.delay+a+c.endDelay;return b<Math.min(c.delay,d)?H:b>=Math.min(c.delay+a,d)?I:J}function p(a,b,c,d,e){switch(d){case H:return"backwards"==b||"both"==b?0:null;case J:return c-e;case I:return"forwards"==b||"both"==b?a:null;case G:return null}}function q(a,b,c,d,e){var f=e;return 0===a?b!==H&&(f+=c):f+=d/a,f}function r(a,b,c,d,e,f){var g=a===1/0?b%1:a%1;return 0!==g||c!==I||0===d||0===e&&0!==f||(g=1),g}function s(a,b,c,d){return a===I&&b===1/0?1/0:1===c?Math.floor(d)-1:Math.floor(d)}function t(a,b,c){var d=a;if("normal"!==a&&"reverse"!==a){var e=b;"alternate-reverse"===a&&(e+=1),d="normal",e!==1/0&&e%2!==0&&(d="reverse")}return"normal"===d?c:1-c}function u(a,b,c){var d=o(a,b,c),e=p(a,c.fill,b,d,c.delay);if(null===e)return null;var f=q(c.duration,d,c.iterations,e,c.iterationStart),g=r(f,c.iterationStart,d,c.iterations,e,c.duration),h=s(d,c.iterations,g,f),i=t(c.direction,h,g);return c._easingFunction(i)}var v="backwards|forwards|both|none".split("|"),w="reverse|alternate|alternate-reverse".split("|"),x=function(a){return a};d.prototype={_setMember:function(b,c){this["_"+b]=c,this._effect&&(this._effect._timingInput[b]=c,this._effect._timing=a.normalizeTimingInput(this._effect._timingInput),this._effect.activeDuration=a.calculateActiveDuration(this._effect._timing),this._effect._animation&&this._effect._animation._rebuildUnderlyingAnimation())},get playbackRate(){return this._playbackRate},set delay(a){this._setMember("delay",a)},get delay(){return this._delay},set endDelay(a){this._setMember("endDelay",a)},get endDelay(){return this._endDelay},set fill(a){this._setMember("fill",a)},get fill(){return this._fill},set iterationStart(a){if((isNaN(a)||a<0)&&e())throw new TypeError("iterationStart must be a non-negative number, received: "+timing.iterationStart);this._setMember("iterationStart",a)},get iterationStart(){return this._iterationStart},set duration(a){if("auto"!=a&&(isNaN(a)||a<0)&&e())throw new TypeError("duration must be non-negative or auto, received: "+a);this._setMember("duration",a)},get duration(){return this._duration},set direction(a){this._setMember("direction",a)},get direction(){return this._direction},set easing(a){this._easingFunction=l(k(a)),this._setMember("easing",a)},get easing(){return this._easing},set iterations(a){if((isNaN(a)||a<0)&&e())throw new TypeError("iterations must be non-negative, received: "+a);this._setMember("iterations",a)},get iterations(){return this._iterations}};var y=1,z=.5,A=0,B={ease:i(.25,.1,.25,1),"ease-in":i(.42,0,1,1),"ease-out":i(0,0,.58,1),"ease-in-out":i(.42,0,.58,1),"step-start":j(1,y),"step-middle":j(1,z),"step-end":j(1,A)},C=null,D="\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*",E=new RegExp("cubic-bezier\\("+D+","+D+","+D+","+D+"\\)"),F=/steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/,G=0,H=1,I=2,J=3;a.cloneTimingInput=c,a.makeTiming=f,a.numericTimingToObject=g,a.normalizeTimingInput=h,a.calculateActiveDuration=m,a.calculateIterationProgress=u,a.calculatePhase=o,a.normalizeEasing=k,a.parseEasingFunction=l}(c,f),function(a,b){function c(a,b){return a in k?k[a][b]||b:b}function d(a){return"display"===a||0===a.lastIndexOf("animation",0)||0===a.lastIndexOf("transition",0)}function e(a,b,e){if(!d(a)){var f=h[a];if(f){i.style[a]=b;for(var g in f){var j=f[g],k=i.style[j];e[j]=c(j,k)}}else e[a]=c(a,b)}}function f(a){var b=[];for(var c in a)if(!(c in["easing","offset","composite"])){var d=a[c];Array.isArray(d)||(d=[d]);for(var e,f=d.length,g=0;g<f;g++)e={},"offset"in a?e.offset=a.offset:1==f?e.offset=1:e.offset=g/(f-1),"easing"in a&&(e.easing=a.easing),"composite"in a&&(e.composite=a.composite),e[c]=d[g],b.push(e)}return b.sort(function(a,b){return a.offset-b.offset}),b}function g(b){function c(){var a=d.length;null==d[a-1].offset&&(d[a-1].offset=1),a>1&&null==d[0].offset&&(d[0].offset=0);for(var b=0,c=d[0].offset,e=1;e<a;e++){var f=d[e].offset;if(null!=f){for(var g=1;g<e-b;g++)d[b+g].offset=c+(f-c)*g/(e-b);b=e,c=f}}}if(null==b)return[];window.Symbol&&Symbol.iterator&&Array.prototype.from&&b[Symbol.iterator]&&(b=Array.from(b)),Array.isArray(b)||(b=f(b));for(var d=b.map(function(b){var c={};for(var d in b){var f=b[d];if("offset"==d){if(null!=f){if(f=Number(f),!isFinite(f))throw new TypeError("Keyframe offsets must be numbers.");if(f<0||f>1)throw new TypeError("Keyframe offsets must be between 0 and 1.")}}else if("composite"==d){if("add"==f||"accumulate"==f)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"add compositing is not supported"};if("replace"!=f)throw new TypeError("Invalid composite mode "+f+".")}else f="easing"==d?a.normalizeEasing(f):""+f;e(d,f,c)}return void 0==c.offset&&(c.offset=null),void 0==c.easing&&(c.easing="linear"),c}),g=!0,h=-(1/0),i=0;i<d.length;i++){var j=d[i].offset;if(null!=j){if(j<h)throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");h=j}else g=!1}return d=d.filter(function(a){return a.offset>=0&&a.offset<=1}),g||c(),d}var h={background:["backgroundImage","backgroundPosition","backgroundSize","backgroundRepeat","backgroundAttachment","backgroundOrigin","backgroundClip","backgroundColor"],border:["borderTopColor","borderTopStyle","borderTopWidth","borderRightColor","borderRightStyle","borderRightWidth","borderBottomColor","borderBottomStyle","borderBottomWidth","borderLeftColor","borderLeftStyle","borderLeftWidth"],borderBottom:["borderBottomWidth","borderBottomStyle","borderBottomColor"],borderColor:["borderTopColor","borderRightColor","borderBottomColor","borderLeftColor"],borderLeft:["borderLeftWidth","borderLeftStyle","borderLeftColor"],borderRadius:["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],borderRight:["borderRightWidth","borderRightStyle","borderRightColor"],borderTop:["borderTopWidth","borderTopStyle","borderTopColor"],borderWidth:["borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth"],flex:["flexGrow","flexShrink","flexBasis"],font:["fontFamily","fontSize","fontStyle","fontVariant","fontWeight","lineHeight"],margin:["marginTop","marginRight","marginBottom","marginLeft"],outline:["outlineColor","outlineStyle","outlineWidth"],padding:["paddingTop","paddingRight","paddingBottom","paddingLeft"]},i=document.createElementNS("http://www.w3.org/1999/xhtml","div"),j={thin:"1px",medium:"3px",thick:"5px"},k={borderBottomWidth:j,borderLeftWidth:j,borderRightWidth:j,borderTopWidth:j,fontSize:{"xx-small":"60%","x-small":"75%",small:"89%",medium:"100%",large:"120%","x-large":"150%","xx-large":"200%"},fontWeight:{normal:"400",bold:"700"},outlineWidth:j,textShadow:{none:"0px 0px 0px transparent"},boxShadow:{none:"0px 0px 0px 0px transparent"}};a.convertToArrayForm=f,a.normalizeKeyframes=g}(c,f),function(a){var b={};a.isDeprecated=function(a,c,d,e){var f=e?"are":"is",g=new Date,h=new Date(c);return h.setMonth(h.getMonth()+3),!(g<h&&(a in b||console.warn("Web Animations: "+a+" "+f+" deprecated and will stop working on "+h.toDateString()+". "+d),b[a]=!0,1))},a.deprecated=function(b,c,d,e){var f=e?"are":"is";if(a.isDeprecated(b,c,d,e))throw new Error(b+" "+f+" no longer supported. "+d)}}(c),function(){if(document.documentElement.animate){var a=document.documentElement.animate([],0),b=!0;if(a&&(b=!1,"play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState".split("|").forEach(function(c){void 0===a[c]&&(b=!0)})),!b)return}!function(a,b,c){function d(a){for(var b={},c=0;c<a.length;c++)for(var d in a[c])if("offset"!=d&&"easing"!=d&&"composite"!=d){var e={offset:a[c].offset,easing:a[c].easing,value:a[c][d]};b[d]=b[d]||[],b[d].push(e)}for(var f in b){var g=b[f];if(0!=g[0].offset||1!=g[g.length-1].offset)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"Partial keyframes are not supported"}}return b}function e(c){var d=[];for(var e in c)for(var f=c[e],g=0;g<f.length-1;g++){var h=g,i=g+1,j=f[h].offset,k=f[i].offset,l=j,m=k;0==g&&(l=-(1/0),0==k&&(i=h)),g==f.length-2&&(m=1/0,1==j&&(h=i)),d.push({applyFrom:l,applyTo:m,startOffset:f[h].offset,endOffset:f[i].offset,easingFunction:a.parseEasingFunction(f[h].easing),property:e,interpolation:b.propertyInterpolation(e,f[h].value,f[i].value)})}return d.sort(function(a,b){return a.startOffset-b.startOffset}),d}b.convertEffectInput=function(c){var f=a.normalizeKeyframes(c),g=d(f),h=e(g);return function(a,c){if(null!=c)h.filter(function(a){return c>=a.applyFrom&&c<a.applyTo}).forEach(function(d){var e=c-d.startOffset,f=d.endOffset-d.startOffset,g=0==f?0:d.easingFunction(e/f);b.apply(a,d.property,d.interpolation(g))});else for(var d in g)"offset"!=d&&"easing"!=d&&"composite"!=d&&b.clear(a,d)}}}(c,d,f),function(a,b,c){function d(a){return a.replace(/-(.)/g,function(a,b){return b.toUpperCase()})}function e(a,b,c){h[c]=h[c]||[],h[c].push([a,b])}function f(a,b,c){for(var f=0;f<c.length;f++){var g=c[f];e(a,b,d(g))}}function g(c,e,f){var g=c;/-/.test(c)&&!a.isDeprecated("Hyphenated property names","2016-03-22","Use camelCase instead.",!0)&&(g=d(c)),"initial"!=e&&"initial"!=f||("initial"==e&&(e=i[g]),"initial"==f&&(f=i[g]));for(var j=e==f?[]:h[g],k=0;j&&k<j.length;k++){var l=j[k][0](e),m=j[k][0](f);if(void 0!==l&&void 0!==m){var n=j[k][1](l,m);if(n){var o=b.Interpolation.apply(null,n);return function(a){return 0==a?e:1==a?f:o(a)}}}}return b.Interpolation(!1,!0,function(a){return a?f:e})}var h={};b.addPropertiesHandler=f;var i={backgroundColor:"transparent",backgroundPosition:"0% 0%",borderBottomColor:"currentColor",borderBottomLeftRadius:"0px",borderBottomRightRadius:"0px",borderBottomWidth:"3px",borderLeftColor:"currentColor",borderLeftWidth:"3px",borderRightColor:"currentColor",borderRightWidth:"3px",borderSpacing:"2px",borderTopColor:"currentColor",borderTopLeftRadius:"0px",borderTopRightRadius:"0px",borderTopWidth:"3px",bottom:"auto",clip:"rect(0px, 0px, 0px, 0px)",color:"black",fontSize:"100%",fontWeight:"400",height:"auto",left:"auto",letterSpacing:"normal",lineHeight:"120%",marginBottom:"0px",marginLeft:"0px",marginRight:"0px",marginTop:"0px",maxHeight:"none",maxWidth:"none",minHeight:"0px",minWidth:"0px",opacity:"1.0",outlineColor:"invert",outlineOffset:"0px",outlineWidth:"3px",paddingBottom:"0px",paddingLeft:"0px",paddingRight:"0px",paddingTop:"0px",right:"auto",textIndent:"0px",textShadow:"0px 0px 0px transparent",top:"auto",transform:"",verticalAlign:"0px",visibility:"visible",width:"auto",wordSpacing:"normal",zIndex:"auto"};b.propertyInterpolation=g}(c,d,f),function(a,b,c){function d(b){var c=a.calculateActiveDuration(b),d=function(d){return a.calculateIterationProgress(c,d,b)};return d._totalDuration=b.delay+c+b.endDelay,d}b.KeyframeEffect=function(c,e,f,g){var h,i=d(a.normalizeTimingInput(f)),j=b.convertEffectInput(e),k=function(){j(c,h)};return k._update=function(a){return h=i(a),null!==h},k._clear=function(){j(c,null)},k._hasSameTarget=function(a){return c===a},k._target=c,k._totalDuration=i._totalDuration,k._id=g,k},b.NullEffect=function(a){var b=function(){a&&(a(),a=null)};return b._update=function(){return null},b._totalDuration=0,b._hasSameTarget=function(){return!1},b}}(c,d,f),function(a,b){function c(a,b,c){c.enumerable=!0,c.configurable=!0,Object.defineProperty(a,b,c)}function d(a){this._surrogateStyle=document.createElementNS("http://www.w3.org/1999/xhtml","div").style,this._style=a.style,this._length=0,this._isAnimatedProperty={};for(var b=0;b<this._style.length;b++){var c=this._style[b];this._surrogateStyle[c]=this._style[c]}this._updateIndices()}function e(a){if(!a._webAnimationsPatchedStyle){var b=new d(a);try{c(a,"style",{get:function(){return b}})}catch(b){a.style._set=function(b,c){a.style[b]=c},a.style._clear=function(b){a.style[b]=""}}a._webAnimationsPatchedStyle=a.style}}var f={cssText:1,length:1,parentRule:1},g={getPropertyCSSValue:1,getPropertyPriority:1,getPropertyValue:1,item:1,removeProperty:1,setProperty:1},h={removeProperty:1,setProperty:1};d.prototype={get cssText(){return this._surrogateStyle.cssText},set cssText(a){for(var b={},c=0;c<this._surrogateStyle.length;c++)b[this._surrogateStyle[c]]=!0;this._surrogateStyle.cssText=a,this._updateIndices();for(var c=0;c<this._surrogateStyle.length;c++)b[this._surrogateStyle[c]]=!0;for(var d in b)this._isAnimatedProperty[d]||this._style.setProperty(d,this._surrogateStyle.getPropertyValue(d))},get length(){return this._surrogateStyle.length},get parentRule(){return this._style.parentRule},_updateIndices:function(){for(;this._length<this._surrogateStyle.length;)Object.defineProperty(this,this._length,{configurable:!0,enumerable:!1,get:function(a){return function(){return this._surrogateStyle[a]}}(this._length)}),this._length++;for(;this._length>this._surrogateStyle.length;)this._length--,Object.defineProperty(this,this._length,{configurable:!0,enumerable:!1,value:void 0})},_set:function(a,b){this._style[a]=b,this._isAnimatedProperty[a]=!0},_clear:function(a){this._style[a]=this._surrogateStyle[a],delete this._isAnimatedProperty[a]}};for(var i in g)d.prototype[i]=function(a,b){return function(){var c=this._surrogateStyle[a].apply(this._surrogateStyle,arguments);return b&&(this._isAnimatedProperty[arguments[0]]||this._style[a].apply(this._style,arguments),this._updateIndices()),c}}(i,i in h);for(var j in document.documentElement.style)j in f||j in g||!function(a){c(d.prototype,a,{get:function(){return this._surrogateStyle[a]},set:function(b){this._surrogateStyle[a]=b,this._updateIndices(),this._isAnimatedProperty[a]||(this._style[a]=b)}})}(j);a.apply=function(b,c,d){e(b),b.style._set(a.propertyName(c),d)},a.clear=function(b,c){b._webAnimationsPatchedStyle&&b.style._clear(a.propertyName(c))}}(d,f),function(a){window.Element.prototype.animate=function(b,c){var d="";return c&&c.id&&(d=c.id),a.timeline._play(a.KeyframeEffect(this,b,c,d))}}(d),function(a,b){function c(a,b,d){if("number"==typeof a&&"number"==typeof b)return a*(1-d)+b*d;if("boolean"==typeof a&&"boolean"==typeof b)return d<.5?a:b;if(a.length==b.length){for(var e=[],f=0;f<a.length;f++)e.push(c(a[f],b[f],d));return e}throw"Mismatched interpolation arguments "+a+":"+b}a.Interpolation=function(a,b,d){return function(e){return d(c(a,b,e))}}}(d,f),function(a,b){function c(a,b,c){return Math.max(Math.min(a,c),b)}function d(b,d,e){var f=a.dot(b,d);f=c(f,-1,1);var g=[];if(1===f)g=b;else for(var h=Math.acos(f),i=1*Math.sin(e*h)/Math.sqrt(1-f*f),j=0;j<4;j++)g.push(b[j]*(Math.cos(e*h)-f*i)+d[j]*i);return g}var e=function(){function a(a,b){for(var c=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]],d=0;d<4;d++)for(var e=0;e<4;e++)for(var f=0;f<4;f++)c[d][e]+=b[d][f]*a[f][e];return c}function b(a){return 0==a[0][2]&&0==a[0][3]&&0==a[1][2]&&0==a[1][3]&&0==a[2][0]&&0==a[2][1]&&1==a[2][2]&&0==a[2][3]&&0==a[3][2]&&1==a[3][3]}function c(c,d,e,f,g){for(var h=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],i=0;i<4;i++)h[i][3]=g[i];for(var i=0;i<3;i++)for(var j=0;j<3;j++)h[3][i]+=c[j]*h[j][i];var k=f[0],l=f[1],m=f[2],n=f[3],o=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];o[0][0]=1-2*(l*l+m*m),o[0][1]=2*(k*l-m*n),o[0][2]=2*(k*m+l*n),o[1][0]=2*(k*l+m*n),o[1][1]=1-2*(k*k+m*m),o[1][2]=2*(l*m-k*n),o[2][0]=2*(k*m-l*n),o[2][1]=2*(l*m+k*n),o[2][2]=1-2*(k*k+l*l),h=a(h,o);var p=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];e[2]&&(p[2][1]=e[2],h=a(h,p)),e[1]&&(p[2][1]=0,p[2][0]=e[0],h=a(h,p)),e[0]&&(p[2][0]=0,p[1][0]=e[0],h=a(h,p));for(var i=0;i<3;i++)for(var j=0;j<3;j++)h[i][j]*=d[i];return b(h)?[h[0][0],h[0][1],h[1][0],h[1][1],h[3][0],h[3][1]]:h[0].concat(h[1],h[2],h[3])}return c}();a.composeMatrix=e,a.quat=d}(d,f),function(a,b,c){a.sequenceNumber=0;var d=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="finish",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()};b.Animation=function(b){this.id="",b&&b._id&&(this.id=b._id),this._sequenceNumber=a.sequenceNumber++,this._currentTime=0,this._startTime=null,this._paused=!1,this._playbackRate=1,this._inTimeline=!0,this._finishedFlag=!0,this.onfinish=null,this._finishHandlers=[],this._effect=b,this._inEffect=this._effect._update(0),this._idle=!0,this._currentTimePending=!1},b.Animation.prototype={_ensureAlive:function(){this.playbackRate<0&&0===this.currentTime?this._inEffect=this._effect._update(-1):this._inEffect=this._effect._update(this.currentTime),this._inTimeline||!this._inEffect&&this._finishedFlag||(this._inTimeline=!0,b.timeline._animations.push(this))},_tickCurrentTime:function(a,b){a!=this._currentTime&&(this._currentTime=a,this._isFinished&&!b&&(this._currentTime=this._playbackRate>0?this._totalDuration:0),this._ensureAlive())},get currentTime(){return this._idle||this._currentTimePending?null:this._currentTime},set currentTime(a){a=+a,isNaN(a)||(b.restart(),this._paused||null==this._startTime||(this._startTime=this._timeline.currentTime-a/this._playbackRate),this._currentTimePending=!1,this._currentTime!=a&&(this._idle&&(this._idle=!1,this._paused=!0),this._tickCurrentTime(a,!0),b.applyDirtiedAnimation(this)))},get startTime(){return this._startTime},set startTime(a){a=+a,isNaN(a)||this._paused||this._idle||(this._startTime=a,this._tickCurrentTime((this._timeline.currentTime-this._startTime)*this.playbackRate),b.applyDirtiedAnimation(this))},get playbackRate(){return this._playbackRate},set playbackRate(a){if(a!=this._playbackRate){var c=this.currentTime;this._playbackRate=a,this._startTime=null,"paused"!=this.playState&&"idle"!=this.playState&&(this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),b.applyDirtiedAnimation(this)),null!=c&&(this.currentTime=c)}},get _isFinished(){return!this._idle&&(this._playbackRate>0&&this._currentTime>=this._totalDuration||this._playbackRate<0&&this._currentTime<=0)},get _totalDuration(){return this._effect._totalDuration},get playState(){return this._idle?"idle":null==this._startTime&&!this._paused&&0!=this.playbackRate||this._currentTimePending?"pending":this._paused?"paused":this._isFinished?"finished":"running"},_rewind:function(){if(this._playbackRate>=0)this._currentTime=0;else{if(!(this._totalDuration<1/0))throw new DOMException("Unable to rewind negative playback rate animation with infinite duration","InvalidStateError");this._currentTime=this._totalDuration}},play:function(){this._paused=!1,(this._isFinished||this._idle)&&(this._rewind(),this._startTime=null),this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),b.applyDirtiedAnimation(this)},pause:function(){this._isFinished||this._paused||this._idle?this._idle&&(this._rewind(),this._idle=!1):this._currentTimePending=!0,this._startTime=null,this._paused=!0},finish:function(){this._idle||(this.currentTime=this._playbackRate>0?this._totalDuration:0,this._startTime=this._totalDuration-this.currentTime,this._currentTimePending=!1,b.applyDirtiedAnimation(this))},cancel:function(){this._inEffect&&(this._inEffect=!1,this._idle=!0,this._paused=!1,this._isFinished=!0,this._finishedFlag=!0,this._currentTime=0,this._startTime=null,this._effect._update(null),b.applyDirtiedAnimation(this))},reverse:function(){this.playbackRate*=-1,this.play()},addEventListener:function(a,b){"function"==typeof b&&"finish"==a&&this._finishHandlers.push(b)},removeEventListener:function(a,b){if("finish"==a){var c=this._finishHandlers.indexOf(b);c>=0&&this._finishHandlers.splice(c,1)}},_fireEvents:function(a){if(this._isFinished){if(!this._finishedFlag){var b=new d(this,this._currentTime,a),c=this._finishHandlers.concat(this.onfinish?[this.onfinish]:[]);setTimeout(function(){c.forEach(function(a){a.call(b.target,b)})},0),this._finishedFlag=!0}}else this._finishedFlag=!1},_tick:function(a,b){this._idle||this._paused||(null==this._startTime?b&&(this.startTime=a-this._currentTime/this.playbackRate):this._isFinished||this._tickCurrentTime((a-this._startTime)*this.playbackRate)),b&&(this._currentTimePending=!1,this._fireEvents(a))},get _needsTick(){return this.playState in{pending:1,running:1}||!this._finishedFlag},_targetAnimations:function(){var a=this._effect._target;return a._activeAnimations||(a._activeAnimations=[]),a._activeAnimations},_markTarget:function(){var a=this._targetAnimations();a.indexOf(this)===-1&&a.push(this)},_unmarkTarget:function(){var a=this._targetAnimations(),b=a.indexOf(this);b!==-1&&a.splice(b,1)}}}(c,d,f),function(a,b,c){function d(a){var b=j;j=[],a<q.currentTime&&(a=q.currentTime),q._animations.sort(e),q._animations=h(a,!0,q._animations)[0],b.forEach(function(b){b[1](a)}),g(),l=void 0}function e(a,b){return a._sequenceNumber-b._sequenceNumber}function f(){this._animations=[],this.currentTime=window.performance&&performance.now?performance.now():0}function g(){o.forEach(function(a){a()}),o.length=0}function h(a,c,d){p=!0,n=!1;var e=b.timeline;e.currentTime=a,m=!1;var f=[],g=[],h=[],i=[];return d.forEach(function(b){b._tick(a,c),b._inEffect?(g.push(b._effect),b._markTarget()):(f.push(b._effect),b._unmarkTarget()),b._needsTick&&(m=!0);var d=b._inEffect||b._needsTick;b._inTimeline=d,d?h.push(b):i.push(b)}),o.push.apply(o,f),o.push.apply(o,g),m&&requestAnimationFrame(function(){}),p=!1,[h,i]}var i=window.requestAnimationFrame,j=[],k=0;window.requestAnimationFrame=function(a){var b=k++;return 0==j.length&&i(d),j.push([b,a]),b},window.cancelAnimationFrame=function(a){j.forEach(function(b){b[0]==a&&(b[1]=function(){})})},f.prototype={_play:function(c){c._timing=a.normalizeTimingInput(c.timing);var d=new b.Animation(c);return d._idle=!1,d._timeline=this,this._animations.push(d),b.restart(),b.applyDirtiedAnimation(d),d}};var l=void 0,m=!1,n=!1;b.restart=function(){return m||(m=!0,requestAnimationFrame(function(){}),n=!0),n},b.applyDirtiedAnimation=function(a){if(!p){a._markTarget();var c=a._targetAnimations();c.sort(e);var d=h(b.timeline.currentTime,!1,c.slice())[1];d.forEach(function(a){var b=q._animations.indexOf(a);b!==-1&&q._animations.splice(b,1)}),g()}};var o=[],p=!1,q=new f;b.timeline=q}(c,d,f),function(a,b){function c(a,b){for(var c=0,d=0;d<a.length;d++)c+=a[d]*b[d];return c}function d(a,b){return[a[0]*b[0]+a[4]*b[1]+a[8]*b[2]+a[12]*b[3],a[1]*b[0]+a[5]*b[1]+a[9]*b[2]+a[13]*b[3],a[2]*b[0]+a[6]*b[1]+a[10]*b[2]+a[14]*b[3],a[3]*b[0]+a[7]*b[1]+a[11]*b[2]+a[15]*b[3],a[0]*b[4]+a[4]*b[5]+a[8]*b[6]+a[12]*b[7],a[1]*b[4]+a[5]*b[5]+a[9]*b[6]+a[13]*b[7],a[2]*b[4]+a[6]*b[5]+a[10]*b[6]+a[14]*b[7],a[3]*b[4]+a[7]*b[5]+a[11]*b[6]+a[15]*b[7],a[0]*b[8]+a[4]*b[9]+a[8]*b[10]+a[12]*b[11],a[1]*b[8]+a[5]*b[9]+a[9]*b[10]+a[13]*b[11],a[2]*b[8]+a[6]*b[9]+a[10]*b[10]+a[14]*b[11],a[3]*b[8]+a[7]*b[9]+a[11]*b[10]+a[15]*b[11],a[0]*b[12]+a[4]*b[13]+a[8]*b[14]+a[12]*b[15],a[1]*b[12]+a[5]*b[13]+a[9]*b[14]+a[13]*b[15],a[2]*b[12]+a[6]*b[13]+a[10]*b[14]+a[14]*b[15],a[3]*b[12]+a[7]*b[13]+a[11]*b[14]+a[15]*b[15]]}function e(a){var b=a.rad||0,c=a.deg||0,d=a.grad||0,e=a.turn||0,f=(c/360+d/400+e)*(2*Math.PI)+b;return f}function f(a){switch(a.t){case"rotatex":var b=e(a.d[0]);return[1,0,0,0,0,Math.cos(b),Math.sin(b),0,0,-Math.sin(b),Math.cos(b),0,0,0,0,1];case"rotatey":var b=e(a.d[0]);return[Math.cos(b),0,-Math.sin(b),0,0,1,0,0,Math.sin(b),0,Math.cos(b),0,0,0,0,1];case"rotate":case"rotatez":var b=e(a.d[0]);return[Math.cos(b),Math.sin(b),0,0,-Math.sin(b),Math.cos(b),0,0,0,0,1,0,0,0,0,1];case"rotate3d":var c=a.d[0],d=a.d[1],f=a.d[2],b=e(a.d[3]),g=c*c+d*d+f*f;if(0===g)c=1,d=0,f=0;else if(1!==g){var h=Math.sqrt(g);c/=h,d/=h,f/=h}var i=Math.sin(b/2),j=i*Math.cos(b/2),k=i*i;return[1-2*(d*d+f*f)*k,2*(c*d*k+f*j),2*(c*f*k-d*j),0,2*(c*d*k-f*j),1-2*(c*c+f*f)*k,2*(d*f*k+c*j),0,2*(c*f*k+d*j),2*(d*f*k-c*j),1-2*(c*c+d*d)*k,0,0,0,0,1];case"scale":return[a.d[0],0,0,0,0,a.d[1],0,0,0,0,1,0,0,0,0,1];case"scalex":return[a.d[0],0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];case"scaley":return[1,0,0,0,0,a.d[0],0,0,0,0,1,0,0,0,0,1];case"scalez":return[1,0,0,0,0,1,0,0,0,0,a.d[0],0,0,0,0,1];case"scale3d":return[a.d[0],0,0,0,0,a.d[1],0,0,0,0,a.d[2],0,0,0,0,1];case"skew":var l=e(a.d[0]),m=e(a.d[1]);return[1,Math.tan(m),0,0,Math.tan(l),1,0,0,0,0,1,0,0,0,0,1];case"skewx":var b=e(a.d[0]);return[1,0,0,0,Math.tan(b),1,0,0,0,0,1,0,0,0,0,1];case"skewy":var b=e(a.d[0]);return[1,Math.tan(b),0,0,0,1,0,0,0,0,1,0,0,0,0,1];case"translate":var c=a.d[0].px||0,d=a.d[1].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,d,0,1];case"translatex":var c=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,0,0,1];case"translatey":var d=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,0,d,0,1];case"translatez":var f=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,f,1];case"translate3d":var c=a.d[0].px||0,d=a.d[1].px||0,f=a.d[2].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,d,f,1];case"perspective":var n=a.d[0].px?-1/a.d[0].px:0;return[1,0,0,0,0,1,0,0,0,0,1,n,0,0,0,1];case"matrix":return[a.d[0],a.d[1],0,0,a.d[2],a.d[3],0,0,0,0,1,0,a.d[4],a.d[5],0,1];case"matrix3d":return a.d}}function g(a){return 0===a.length?[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]:a.map(f).reduce(d)}function h(a){return[i(g(a))]}var i=function(){function a(a){return a[0][0]*a[1][1]*a[2][2]+a[1][0]*a[2][1]*a[0][2]+a[2][0]*a[0][1]*a[1][2]-a[0][2]*a[1][1]*a[2][0]-a[1][2]*a[2][1]*a[0][0]-a[2][2]*a[0][1]*a[1][0]}function b(b){for(var c=1/a(b),d=b[0][0],e=b[0][1],f=b[0][2],g=b[1][0],h=b[1][1],i=b[1][2],j=b[2][0],k=b[2][1],l=b[2][2],m=[[(h*l-i*k)*c,(f*k-e*l)*c,(e*i-f*h)*c,0],[(i*j-g*l)*c,(d*l-f*j)*c,(f*g-d*i)*c,0],[(g*k-h*j)*c,(j*e-d*k)*c,(d*h-e*g)*c,0]],n=[],o=0;o<3;o++){for(var p=0,q=0;q<3;q++)p+=b[3][q]*m[q][o];n.push(p)}return n.push(1),m.push(n),m}function d(a){return[[a[0][0],a[1][0],a[2][0],a[3][0]],[a[0][1],a[1][1],a[2][1],a[3][1]],[a[0][2],a[1][2],a[2][2],a[3][2]],[a[0][3],a[1][3],a[2][3],a[3][3]]]}function e(a,b){for(var c=[],d=0;d<4;d++){for(var e=0,f=0;f<4;f++)e+=a[f]*b[f][d];c.push(e)}return c}function f(a){var b=g(a);return[a[0]/b,a[1]/b,a[2]/b]}function g(a){return Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2])}function h(a,b,c,d){return[c*a[0]+d*b[0],c*a[1]+d*b[1],c*a[2]+d*b[2]]}function i(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]}function j(j){var k=[j.slice(0,4),j.slice(4,8),j.slice(8,12),j.slice(12,16)];if(1!==k[3][3])return null;for(var l=[],m=0;m<4;m++)l.push(k[m].slice());for(var m=0;m<3;m++)l[m][3]=0;if(0===a(l))return!1;var n,o=[];if(k[0][3]||k[1][3]||k[2][3]){o.push(k[0][3]),o.push(k[1][3]),o.push(k[2][3]),o.push(k[3][3]);var p=b(l),q=d(p);n=e(o,q)}else n=[0,0,0,1];var r=k[3].slice(0,3),s=[];s.push(k[0].slice(0,3));var t=[];t.push(g(s[0])),s[0]=f(s[0]);var u=[];s.push(k[1].slice(0,3)),u.push(c(s[0],s[1])),s[1]=h(s[1],s[0],1,-u[0]),t.push(g(s[1])),s[1]=f(s[1]),u[0]/=t[1],s.push(k[2].slice(0,3)),u.push(c(s[0],s[2])),s[2]=h(s[2],s[0],1,-u[1]),u.push(c(s[1],s[2])),s[2]=h(s[2],s[1],1,-u[2]),t.push(g(s[2])),s[2]=f(s[2]),u[1]/=t[2],u[2]/=t[2];var v=i(s[1],s[2]);if(c(s[0],v)<0)for(var m=0;m<3;m++)t[m]*=-1,s[m][0]*=-1,s[m][1]*=-1,s[m][2]*=-1;var w,x,y=s[0][0]+s[1][1]+s[2][2]+1;return y>1e-4?(w=.5/Math.sqrt(y),x=[(s[2][1]-s[1][2])*w,(s[0][2]-s[2][0])*w,(s[1][0]-s[0][1])*w,.25/w]):s[0][0]>s[1][1]&&s[0][0]>s[2][2]?(w=2*Math.sqrt(1+s[0][0]-s[1][1]-s[2][2]),x=[.25*w,(s[0][1]+s[1][0])/w,(s[0][2]+s[2][0])/w,(s[2][1]-s[1][2])/w]):s[1][1]>s[2][2]?(w=2*Math.sqrt(1+s[1][1]-s[0][0]-s[2][2]),x=[(s[0][1]+s[1][0])/w,.25*w,(s[1][2]+s[2][1])/w,(s[0][2]-s[2][0])/w]):(w=2*Math.sqrt(1+s[2][2]-s[0][0]-s[1][1]),x=[(s[0][2]+s[2][0])/w,(s[1][2]+s[2][1])/w,.25*w,(s[1][0]-s[0][1])/w]),[r,t,u,x,n]}return j}();a.dot=c,a.makeMatrixDecomposition=h}(d,f),function(a){function b(a,b){var c=a.exec(b);if(c)return c=a.ignoreCase?c[0].toLowerCase():c[0],[c,b.substr(c.length)]}function c(a,b){b=b.replace(/^\s*/,"");var c=a(b);if(c)return[c[0],c[1].replace(/^\s*/,"")]}function d(a,d,e){a=c.bind(null,a);for(var f=[];;){var g=a(e);if(!g)return[f,e];if(f.push(g[0]),e=g[1],g=b(d,e),!g||""==g[1])return[f,e];e=g[1]}}function e(a,b){for(var c=0,d=0;d<b.length&&(!/\s|,/.test(b[d])||0!=c);d++)if("("==b[d])c++;else if(")"==b[d]&&(c--,0==c&&d++,c<=0))break;var e=a(b.substr(0,d));return void 0==e?void 0:[e,b.substr(d)]}function f(a,b){for(var c=a,d=b;c&&d;)c>d?c%=d:d%=c;return c=a*b/(c+d)}function g(a){return function(b){var c=a(b);return c&&(c[0]=void 0),c}}function h(a,b){return function(c){var d=a(c);return d?d:[b,c]}}function i(b,c){for(var d=[],e=0;e<b.length;e++){var f=a.consumeTrimmed(b[e],c);if(!f||""==f[0])return;void 0!==f[0]&&d.push(f[0]),c=f[1]}if(""==c)return d}function j(a,b,c,d,e){for(var g=[],h=[],i=[],j=f(d.length,e.length),k=0;k<j;k++){var l=b(d[k%d.length],e[k%e.length]);if(!l)return;g.push(l[0]),h.push(l[1]),i.push(l[2])}return[g,h,function(b){var d=b.map(function(a,b){return i[b](a)}).join(c);return a?a(d):d}]}function k(a,b,c){for(var d=[],e=[],f=[],g=0,h=0;h<c.length;h++)if("function"==typeof c[h]){var i=c[h](a[g],b[g++]);d.push(i[0]),e.push(i[1]),f.push(i[2])}else!function(a){d.push(!1),e.push(!1),f.push(function(){return c[a]})}(h);return[d,e,function(a){for(var b="",c=0;c<a.length;c++)b+=f[c](a[c]);return b}]}a.consumeToken=b,a.consumeTrimmed=c,a.consumeRepeated=d,a.consumeParenthesised=e,a.ignore=g,a.optional=h,a.consumeList=i,a.mergeNestedRepeated=j.bind(null,null),a.mergeWrappedNestedRepeated=j,a.mergeList=k}(d),function(a){function b(b){function c(b){var c=a.consumeToken(/^inset/i,b);if(c)return d.inset=!0,c;var c=a.consumeLengthOrPercent(b);if(c)return d.lengths.push(c[0]),c;var c=a.consumeColor(b);return c?(d.color=c[0],c):void 0}var d={inset:!1,lengths:[],color:null},e=a.consumeRepeated(c,/^/,b);if(e&&e[0].length)return[d,e[1]]}function c(c){var d=a.consumeRepeated(b,/^,/,c);if(d&&""==d[1])return d[0]}function d(b,c){for(;b.lengths.length<Math.max(b.lengths.length,c.lengths.length);)b.lengths.push({px:0});for(;c.lengths.length<Math.max(b.lengths.length,c.lengths.length);)c.lengths.push({px:0});if(b.inset==c.inset&&!!b.color==!!c.color){for(var d,e=[],f=[[],0],g=[[],0],h=0;h<b.lengths.length;h++){var i=a.mergeDimensions(b.lengths[h],c.lengths[h],2==h);f[0].push(i[0]),g[0].push(i[1]),e.push(i[2])}if(b.color&&c.color){var j=a.mergeColors(b.color,c.color);f[1]=j[0],g[1]=j[1],d=j[2];
}return[f,g,function(a){for(var c=b.inset?"inset ":" ",f=0;f<e.length;f++)c+=e[f](a[0][f])+" ";return d&&(c+=d(a[1])),c}]}}function e(b,c,d,e){function f(a){return{inset:a,color:[0,0,0,0],lengths:[{px:0},{px:0},{px:0},{px:0}]}}for(var g=[],h=[],i=0;i<d.length||i<e.length;i++){var j=d[i]||f(e[i].inset),k=e[i]||f(d[i].inset);g.push(j),h.push(k)}return a.mergeNestedRepeated(b,c,g,h)}var f=e.bind(null,d,", ");a.addPropertiesHandler(c,f,["box-shadow","text-shadow"])}(d),function(a,b){function c(a){return a.toFixed(3).replace(".000","")}function d(a,b,c){return Math.min(b,Math.max(a,c))}function e(a){if(/^\s*[-+]?(\d*\.)?\d+\s*$/.test(a))return Number(a)}function f(a,b){return[a,b,c]}function g(a,b){if(0!=a)return i(0,1/0)(a,b)}function h(a,b){return[a,b,function(a){return Math.round(d(1,1/0,a))}]}function i(a,b){return function(e,f){return[e,f,function(e){return c(d(a,b,e))}]}}function j(a,b){return[a,b,Math.round]}a.clamp=d,a.addPropertiesHandler(e,i(0,1/0),["border-image-width","line-height"]),a.addPropertiesHandler(e,i(0,1),["opacity","shape-image-threshold"]),a.addPropertiesHandler(e,g,["flex-grow","flex-shrink"]),a.addPropertiesHandler(e,h,["orphans","widows"]),a.addPropertiesHandler(e,j,["z-index"]),a.parseNumber=e,a.mergeNumbers=f,a.numberToString=c}(d,f),function(a,b){function c(a,b){if("visible"==a||"visible"==b)return[0,1,function(c){return c<=0?a:c>=1?b:"visible"}]}a.addPropertiesHandler(String,c,["visibility"])}(d),function(a,b){function c(a){a=a.trim(),f.fillStyle="#000",f.fillStyle=a;var b=f.fillStyle;if(f.fillStyle="#fff",f.fillStyle=a,b==f.fillStyle){f.fillRect(0,0,1,1);var c=f.getImageData(0,0,1,1).data;f.clearRect(0,0,1,1);var d=c[3]/255;return[c[0]*d,c[1]*d,c[2]*d,d]}}function d(b,c){return[b,c,function(b){function c(a){return Math.max(0,Math.min(255,a))}if(b[3])for(var d=0;d<3;d++)b[d]=Math.round(c(b[d]/b[3]));return b[3]=a.numberToString(a.clamp(0,1,b[3])),"rgba("+b.join(",")+")"}]}var e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");e.width=e.height=1;var f=e.getContext("2d");a.addPropertiesHandler(c,d,["background-color","border-bottom-color","border-left-color","border-right-color","border-top-color","color","outline-color","text-decoration-color"]),a.consumeColor=a.consumeParenthesised.bind(null,c),a.mergeColors=d}(d,f),function(a,b){function c(a,b){if(b=b.trim().toLowerCase(),"0"==b&&"px".search(a)>=0)return{px:0};if(/^[^(]*$|^calc/.test(b)){b=b.replace(/calc\(/g,"(");var c={};b=b.replace(a,function(a){return c[a]=null,"U"+a});for(var d="U("+a.source+")",e=b.replace(/[-+]?(\d*\.)?\d+/g,"N").replace(new RegExp("N"+d,"g"),"D").replace(/\s[+-]\s/g,"O").replace(/\s/g,""),f=[/N\*(D)/g,/(N|D)[*\/]N/g,/(N|D)O\1/g,/\((N|D)\)/g],g=0;g<f.length;)f[g].test(e)?(e=e.replace(f[g],"$1"),g=0):g++;if("D"==e){for(var h in c){var i=eval(b.replace(new RegExp("U"+h,"g"),"").replace(new RegExp(d,"g"),"*0"));if(!isFinite(i))return;c[h]=i}return c}}}function d(a,b){return e(a,b,!0)}function e(b,c,d){var e,f=[];for(e in b)f.push(e);for(e in c)f.indexOf(e)<0&&f.push(e);return b=f.map(function(a){return b[a]||0}),c=f.map(function(a){return c[a]||0}),[b,c,function(b){var c=b.map(function(c,e){return 1==b.length&&d&&(c=Math.max(c,0)),a.numberToString(c)+f[e]}).join(" + ");return b.length>1?"calc("+c+")":c}]}var f="px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc",g=c.bind(null,new RegExp(f,"g")),h=c.bind(null,new RegExp(f+"|%","g")),i=c.bind(null,/deg|rad|grad|turn/g);a.parseLength=g,a.parseLengthOrPercent=h,a.consumeLengthOrPercent=a.consumeParenthesised.bind(null,h),a.parseAngle=i,a.mergeDimensions=e;var j=a.consumeParenthesised.bind(null,g),k=a.consumeRepeated.bind(void 0,j,/^/),l=a.consumeRepeated.bind(void 0,k,/^,/);a.consumeSizePairList=l;var m=function(a){var b=l(a);if(b&&""==b[1])return b[0]},n=a.mergeNestedRepeated.bind(void 0,d," "),o=a.mergeNestedRepeated.bind(void 0,n,",");a.mergeNonNegativeSizePair=n,a.addPropertiesHandler(m,o,["background-size"]),a.addPropertiesHandler(h,d,["border-bottom-width","border-image-width","border-left-width","border-right-width","border-top-width","flex-basis","font-size","height","line-height","max-height","max-width","outline-width","width"]),a.addPropertiesHandler(h,e,["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius","bottom","left","letter-spacing","margin-bottom","margin-left","margin-right","margin-top","min-height","min-width","outline-offset","padding-bottom","padding-left","padding-right","padding-top","perspective","right","shape-margin","text-indent","top","vertical-align","word-spacing"])}(d,f),function(a,b){function c(b){return a.consumeLengthOrPercent(b)||a.consumeToken(/^auto/,b)}function d(b){var d=a.consumeList([a.ignore(a.consumeToken.bind(null,/^rect/)),a.ignore(a.consumeToken.bind(null,/^\(/)),a.consumeRepeated.bind(null,c,/^,/),a.ignore(a.consumeToken.bind(null,/^\)/))],b);if(d&&4==d[0].length)return d[0]}function e(b,c){return"auto"==b||"auto"==c?[!0,!1,function(d){var e=d?b:c;if("auto"==e)return"auto";var f=a.mergeDimensions(e,e);return f[2](f[0])}]:a.mergeDimensions(b,c)}function f(a){return"rect("+a+")"}var g=a.mergeWrappedNestedRepeated.bind(null,f,e,", ");a.parseBox=d,a.mergeBoxes=g,a.addPropertiesHandler(d,g,["clip"])}(d,f),function(a,b){function c(a){return function(b){var c=0;return a.map(function(a){return a===k?b[c++]:a})}}function d(a){return a}function e(b){if(b=b.toLowerCase().trim(),"none"==b)return[];for(var c,d=/\s*(\w+)\(([^)]*)\)/g,e=[],f=0;c=d.exec(b);){if(c.index!=f)return;f=c.index+c[0].length;var g=c[1],h=n[g];if(!h)return;var i=c[2].split(","),j=h[0];if(j.length<i.length)return;for(var k=[],o=0;o<j.length;o++){var p,q=i[o],r=j[o];if(p=q?{A:function(b){return"0"==b.trim()?m:a.parseAngle(b)},N:a.parseNumber,T:a.parseLengthOrPercent,L:a.parseLength}[r.toUpperCase()](q):{a:m,n:k[0],t:l}[r],void 0===p)return;k.push(p)}if(e.push({t:g,d:k}),d.lastIndex==b.length)return e}}function f(a){return a.toFixed(6).replace(".000000","")}function g(b,c){if(b.decompositionPair!==c){b.decompositionPair=c;var d=a.makeMatrixDecomposition(b)}if(c.decompositionPair!==b){c.decompositionPair=b;var e=a.makeMatrixDecomposition(c)}return null==d[0]||null==e[0]?[[!1],[!0],function(a){return a?c[0].d:b[0].d}]:(d[0].push(0),e[0].push(1),[d,e,function(b){var c=a.quat(d[0][3],e[0][3],b[5]),g=a.composeMatrix(b[0],b[1],b[2],c,b[4]),h=g.map(f).join(",");return h}])}function h(a){return a.replace(/[xy]/,"")}function i(a){return a.replace(/(x|y|z|3d)?$/,"3d")}function j(b,c){var d=a.makeMatrixDecomposition&&!0,e=!1;if(!b.length||!c.length){b.length||(e=!0,b=c,c=[]);for(var f=0;f<b.length;f++){var j=b[f].t,k=b[f].d,l="scale"==j.substr(0,5)?1:0;c.push({t:j,d:k.map(function(a){if("number"==typeof a)return l;var b={};for(var c in a)b[c]=l;return b})})}}var m=function(a,b){return"perspective"==a&&"perspective"==b||("matrix"==a||"matrix3d"==a)&&("matrix"==b||"matrix3d"==b)},o=[],p=[],q=[];if(b.length!=c.length){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]]}else for(var f=0;f<b.length;f++){var j,s=b[f].t,t=c[f].t,u=b[f].d,v=c[f].d,w=n[s],x=n[t];if(m(s,t)){if(!d)return;var r=g([b[f]],[c[f]]);o.push(r[0]),p.push(r[1]),q.push(["matrix",[r[2]]])}else{if(s==t)j=s;else if(w[2]&&x[2]&&h(s)==h(t))j=h(s),u=w[2](u),v=x[2](v);else{if(!w[1]||!x[1]||i(s)!=i(t)){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]];break}j=i(s),u=w[1](u),v=x[1](v)}for(var y=[],z=[],A=[],B=0;B<u.length;B++){var C="number"==typeof u[B]?a.mergeNumbers:a.mergeDimensions,r=C(u[B],v[B]);y[B]=r[0],z[B]=r[1],A.push(r[2])}o.push(y),p.push(z),q.push([j,A])}}if(e){var D=o;o=p,p=D}return[o,p,function(a){return a.map(function(a,b){var c=a.map(function(a,c){return q[b][1][c](a)}).join(",");return"matrix"==q[b][0]&&16==c.split(",").length&&(q[b][0]="matrix3d"),q[b][0]+"("+c+")"}).join(" ")}]}var k=null,l={px:0},m={deg:0},n={matrix:["NNNNNN",[k,k,0,0,k,k,0,0,0,0,1,0,k,k,0,1],d],matrix3d:["NNNNNNNNNNNNNNNN",d],rotate:["A"],rotatex:["A"],rotatey:["A"],rotatez:["A"],rotate3d:["NNNA"],perspective:["L"],scale:["Nn",c([k,k,1]),d],scalex:["N",c([k,1,1]),c([k,1])],scaley:["N",c([1,k,1]),c([1,k])],scalez:["N",c([1,1,k])],scale3d:["NNN",d],skew:["Aa",null,d],skewx:["A",null,c([k,m])],skewy:["A",null,c([m,k])],translate:["Tt",c([k,k,l]),d],translatex:["T",c([k,l,l]),c([k,l])],translatey:["T",c([l,k,l]),c([l,k])],translatez:["L",c([l,l,k])],translate3d:["TTL",d]};a.addPropertiesHandler(e,j,["transform"])}(d,f),function(a){function b(a){var b=Number(a);if(!(isNaN(b)||b<100||b>900||b%100!==0))return b}function c(b){return b=100*Math.round(b/100),b=a.clamp(100,900,b),400===b?"normal":700===b?"bold":String(b)}function d(a,b){return[a,b,c]}a.addPropertiesHandler(b,d,["font-weight"])}(d),function(a){function b(a){var b={};for(var c in a)b[c]=-a[c];return b}function c(b){return a.consumeToken(/^(left|center|right|top|bottom)\b/i,b)||a.consumeLengthOrPercent(b)}function d(b,d){var e=a.consumeRepeated(c,/^/,d);if(e&&""==e[1]){var f=e[0];if(f[0]=f[0]||"center",f[1]=f[1]||"center",3==b&&(f[2]=f[2]||{px:0}),f.length==b){if(/top|bottom/.test(f[0])||/left|right/.test(f[1])){var h=f[0];f[0]=f[1],f[1]=h}if(/left|right|center|Object/.test(f[0])&&/top|bottom|center|Object/.test(f[1]))return f.map(function(a){return"object"==typeof a?a:g[a]})}}}function e(d){var e=a.consumeRepeated(c,/^/,d);if(e){for(var f=e[0],h=[{"%":50},{"%":50}],i=0,j=!1,k=0;k<f.length;k++){var l=f[k];"string"==typeof l?(j=/bottom|right/.test(l),i={left:0,right:0,center:i,top:1,bottom:1}[l],h[i]=g[l],"center"==l&&i++):(j&&(l=b(l),l["%"]=(l["%"]||0)+100),h[i]=l,i++,j=!1)}return[h,e[1]]}}function f(b){var c=a.consumeRepeated(e,/^,/,b);if(c&&""==c[1])return c[0]}var g={left:{"%":0},center:{"%":50},right:{"%":100},top:{"%":0},bottom:{"%":100}},h=a.mergeNestedRepeated.bind(null,a.mergeDimensions," ");a.addPropertiesHandler(d.bind(null,3),h,["transform-origin"]),a.addPropertiesHandler(d.bind(null,2),h,["perspective-origin"]),a.consumePosition=e,a.mergeOffsetList=h;var i=a.mergeNestedRepeated.bind(null,h,", ");a.addPropertiesHandler(f,i,["background-position","object-position"])}(d),function(a){function b(b){var c=a.consumeToken(/^circle/,b);if(c&&c[0])return["circle"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),d,a.ignore(a.consumeToken.bind(void 0,/^at/)),a.consumePosition,a.ignore(a.consumeToken.bind(void 0,/^\)/))],c[1]));var f=a.consumeToken(/^ellipse/,b);if(f&&f[0])return["ellipse"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),e,a.ignore(a.consumeToken.bind(void 0,/^at/)),a.consumePosition,a.ignore(a.consumeToken.bind(void 0,/^\)/))],f[1]));var g=a.consumeToken(/^polygon/,b);return g&&g[0]?["polygon"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),a.optional(a.consumeToken.bind(void 0,/^nonzero\s*,|^evenodd\s*,/),"nonzero,"),a.consumeSizePairList,a.ignore(a.consumeToken.bind(void 0,/^\)/))],g[1])):void 0}function c(b,c){if(b[0]===c[0])return"circle"==b[0]?a.mergeList(b.slice(1),c.slice(1),["circle(",a.mergeDimensions," at ",a.mergeOffsetList,")"]):"ellipse"==b[0]?a.mergeList(b.slice(1),c.slice(1),["ellipse(",a.mergeNonNegativeSizePair," at ",a.mergeOffsetList,")"]):"polygon"==b[0]&&b[1]==c[1]?a.mergeList(b.slice(2),c.slice(2),["polygon(",b[1],g,")"]):void 0}var d=a.consumeParenthesised.bind(null,a.parseLengthOrPercent),e=a.consumeRepeated.bind(void 0,d,/^/),f=a.mergeNestedRepeated.bind(void 0,a.mergeDimensions," "),g=a.mergeNestedRepeated.bind(void 0,f,",");a.addPropertiesHandler(b,c,["shape-outside"])}(d),function(a,b){function c(a,b){b.concat([a]).forEach(function(b){b in document.documentElement.style&&(d[a]=b)})}var d={};c("transform",["webkitTransform","msTransform"]),c("transformOrigin",["webkitTransformOrigin"]),c("perspective",["webkitPerspective"]),c("perspectiveOrigin",["webkitPerspectiveOrigin"]),a.propertyName=function(a){return d[a]||a}}(d,f)}(),!function(){if(void 0===document.createElement("div").animate([]).oncancel){var a;if(window.performance&&performance.now)var a=function(){return performance.now()};else var a=function(){return Date.now()};var b=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="cancel",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()},c=window.Element.prototype.animate;window.Element.prototype.animate=function(d,e){var f=c.call(this,d,e);f._cancelHandlers=[],f.oncancel=null;var g=f.cancel;f.cancel=function(){g.call(this);var c=new b(this,null,a()),d=this._cancelHandlers.concat(this.oncancel?[this.oncancel]:[]);setTimeout(function(){d.forEach(function(a){a.call(c.target,c)})},0)};var h=f.addEventListener;f.addEventListener=function(a,b){"function"==typeof b&&"cancel"==a?this._cancelHandlers.push(b):h.call(this,a,b)};var i=f.removeEventListener;return f.removeEventListener=function(a,b){if("cancel"==a){var c=this._cancelHandlers.indexOf(b);c>=0&&this._cancelHandlers.splice(c,1)}else i.call(this,a,b)},f}}}(),function(a){var b=document.documentElement,c=null,d=!1;try{var e=getComputedStyle(b).getPropertyValue("opacity"),f="0"==e?"1":"0";c=b.animate({opacity:[f,f]},{duration:1}),c.currentTime=0,d=getComputedStyle(b).getPropertyValue("opacity")==f}catch(a){}finally{c&&c.cancel()}if(!d){var g=window.Element.prototype.animate;window.Element.prototype.animate=function(b,c){return window.Symbol&&Symbol.iterator&&Array.prototype.from&&b[Symbol.iterator]&&(b=Array.from(b)),Array.isArray(b)||null===b||(b=a.convertToArrayForm(b)),g.call(this,b,c)}}}(c),b.true=a}({},function(){return this}());

},{}],176:[function(require,module,exports){
(function (global){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

// const JS_FEATURES = [
//   'fn/array/for-each',
//   'fn/function/bind',
//   'fn/number/constructor',
//   'fn/object/assign',
//   'fn/object/define-property',
//   'fn/object/keys',
// ];

// const MODERNIZR_TESTS = [
//   'customevent',
// ];

var Mix = function Mix() {
  _classCallCheck(this, Mix);
};

var _Symbol = global.Symbol || function (x) {
  return '_' + x;
};

var def = Object.defineProperty.bind(Object);

var ROOT = _Symbol('root');
var STATE = _Symbol('state');

function createEvent(eventName) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  try {
    return new CustomEvent(eventName, data);
  } catch (e) {
    var event = document.createEvent('CustomEvent');
    event.initCustomEvent(eventName, true, true, data.detail);
    return event;
  }
}

function setupProperty(key, sideEffect) {
  var _this = this;

  def(this, key, {
    enumerable: true,
    get: function get() {
      return _this[STATE][key];
    },
    set: function set(value) {
      if (sideEffect != null) {
        sideEffect(value);
      } else {
        _this.setState(key, value);
      }
    }
  });
}

// TODO: study how native elements deal with attributes/properites
function setupProperties() {
  var _this2 = this;

  var sideEffects = this.sideEffects();

  Object.keys(this[STATE]).forEach(function (key) {
    if (typeof _this2[key] === 'undefined') {
      var sideEffect = sideEffects[key];
      setupProperty.call(_this2, key, sideEffect);
    }
  });
}

exports.default = function () {
  var C = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Mix;
  return function (_C) {
    _inherits(_class, _C);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'getComponentName',
      value: function getComponentName() {
        throw Error('Component needs to have a name, e.g. `my-tag`. Override `getComponentName`');
      }
    }, {
      key: 'setupComponent',
      value: function setupComponent(el, state) {
        def(this, STATE, { value: Object.assign({}, this.defaults(), state) });
        setupProperties.call(this);
        def(this, ROOT, { value: this.setupDOM(el) });
        return this;
      }
    }, {
      key: 'setupDOM',
      value: function setupDOM(el) {
        return el;
      }
    }, {
      key: 'getRoot',
      value: function getRoot() {
        return this[ROOT];
      }
    }, {
      key: 'getEl',
      value: function getEl() {
        return this[ROOT];
      }
    }, {
      key: 'fireEvent',
      value: function fireEvent(eventName, data) {
        var eventNameNS = this.componentName + '-' + eventName;
        this.el.dispatchEvent(createEvent(eventNameNS, data));
      }
    }, {
      key: 'defaults',
      value: function defaults() {
        // TODO: production builds with preprocess?
        console.warn('defaults not provided'); // eslint-disable-line no-console
        return {};
      }
    }, {
      key: 'sideEffects',
      value: function sideEffects() {
        // TODO: production builds with preprocess?
        console.warn('sideEffects not provided'); // eslint-disable-line no-console
        return {};
      }
    }, {
      key: 'setState',
      value: function setState(keyOrMap, value) {
        if (typeof keyOrMap === 'string') {
          this.setStateKV(keyOrMap, value);
        } else if ((typeof keyOrMap === 'undefined' ? 'undefined' : _typeof(keyOrMap)) === 'object') {
          this.setStateMap(keyOrMap);
        } else {
          throw Error('setState needs argument');
        }
      }
    }, {
      key: 'setStateKV',
      value: function setStateKV(key, value) {
        this[STATE][key] = value;
      }
    }, {
      key: 'setStateMap',
      value: function setStateMap(map) {
        var _this4 = this;

        Object.keys(this[STATE]).forEach(function (key) {
          _this4.setStateKV(key, map[key]);
        });
      }
    }, {
      key: 'componentName',
      get: function get() {
        return this.getComponentName();
      }
    }, {
      key: 'root',
      get: function get() {
        return this.getRoot();
      }
    }, {
      key: 'el',
      get: function get() {
        return this.getEl();
      }
    }]);

    return _class;
  }(C);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],177:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/**
  * @param t current time
  * @param b start value
  * @param c change in value
  * @param d duration
  * @returns {number}
  */
function linearTween(t, b, c, d) {
  return c * t / d + b;
}

function pageDist(p1, p2) {
  return Math.sqrt(Math.pow(p1.pageX - p2.pageX, 2) + Math.pow(p1.pageY - p2.pageY, 2));
}

function contains(target, className) {
  var t = target;
  while (t != null) {
    if (t.classList && t.classList.contains(className)) {
      return true;
    }
    t = t.parentNode;
  }
  return false;
}

exports.linearTween = linearTween;
exports.pageDist = pageDist;
exports.contains = contains;

},{}],178:[function(require,module,exports){
(function (global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _componentCore2 = require('y-component/src/component-core');

var _componentCore3 = _interopRequireDefault(_componentCore2);

var _common = require('../common');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

// const JS_FEATURES = [
//   'fn/array/for-each',
//   'fn/function/bind',
//   'fn/number/constructor',
//   'fn/object/assign',
//   'fn/object/define-property',
//   'fn/object/keys',
//   'fn/array/reduce',
// ];
//
// const MODERNIZR_TESTS = [
//   'customevent',
//   'eventlistener',
//   'queryselector',
//   'requestanimationframe',
//   'classlist',
//   'opacity',
//   'csstransforms',
//   'csspointerevents',
// ];

var _Symbol = global.Symbol || function (x) {
  return '_' + x;
};

var IDLE = _Symbol('idle');
var TOUCHING = _Symbol('touching');
var START_ANIMATING = _Symbol('startAnimating');
var ANIMATING = _Symbol('animating');

var VELOCITY_THRESHOLD = 0.2;
var VELOCITY_LINEAR_COMBINATION = 0.8;

var def = Object.defineProperty.bind(Object);

exports.default = function (C) {
  return function (_componentCore) {
    _inherits(_class, _componentCore);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'getComponentName',

      // @override
      value: function getComponentName() {
        return 'y-drawer';
      }

      // @override

    }, {
      key: 'defaults',
      value: function defaults() {
        return {
          opened: false,
          transitionDuration: 200,
          persistent: false
        };
      }

      // @override

    }, {
      key: 'sideEffects',
      value: function sideEffects() {
        var _this2 = this;

        return {
          opened: function opened(o) {
            if (o === true) _this2.open();else _this2.close();
          },
          persistent: function persistent(d) {
            if (d === true) _this2.persist();else _this2.unpersist();
          }
        };
      }

      // @override

    }, {
      key: 'setupComponent',
      value: function setupComponent(el, props) {
        _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'setupComponent', this).call(this, el, props);

        this.cacheDOMElements();
        this.defProperties();
        this.bindCallbacks();

        this.jumpTo(this.opened);
        if (!this.persistent) this.addEventListeners();
        if (this.persistent) this.scrim.style.display = 'none';

        return this;
      }
    }, {
      key: 'cacheDOMElements',
      value: function cacheDOMElements() {
        def(this, 'scrim', { value: this.root.querySelector('.y-drawer-scrim') });
        def(this, 'content', { value: this.root.querySelector('.y-drawer-content') });
      }
    }, {
      key: 'defProperties',
      value: function defProperties() {
        def(this, 'startX', { value: 0, writable: true });
        def(this, 'startY', { value: 0, writable: true });
        def(this, 'pageX', { value: 0, writable: true });
        def(this, 'pageY', { value: 0, writable: true });
        def(this, 'lastPageX', { value: 0, writable: true });
        def(this, 'lastPageY', { value: 0, writable: true });
        def(this, 'isScrolling', { writable: true });
        def(this, 'startedMoving', { value: false, writable: true });
        def(this, 'loopState', { value: IDLE, writable: true });
        def(this, 'velocity', { value: 0, writable: true });
        def(this, 'startTranslateX', { value: 0, writable: true });
        def(this, 'translateX', { value: 0, writable: true });
        def(this, 'animationFrameRequested', { value: false, writable: true });
        def(this, 'touching', { value: false, writable: true });
        def(this, 'lastTime', { writable: true });
        def(this, 'sliderWidth', { writable: true });
        def(this, 'animation', { writable: true, configurable: true });
      }
    }, {
      key: 'bindCallbacks',
      value: function bindCallbacks() {
        def(this, 'touchStartCallback', { value: this.touchStartCallback.bind(this) });
        def(this, 'touchMoveCallback', { value: this.touchMoveCallback.bind(this) });
        def(this, 'touchEndCallback', { value: this.touchEndCallback.bind(this) });
        def(this, 'scrimClickCallback', { value: this.scrimClickCallback.bind(this) });
        def(this, 'animationFrameCallback', { value: this.animationFrameCallback.bind(this) });
      }
    }, {
      key: 'addEventListeners',
      value: function addEventListeners() {
        document.addEventListener('touchstart', this.touchStartCallback, { passive: false });
        document.addEventListener('touchmove', this.touchMoveCallback, { passive: false });
        document.addEventListener('touchend', this.touchEndCallback, { passive: false });

        this.scrim.addEventListener('click', this.scrimClickCallback);
      }
    }, {
      key: 'removeEventListeners',
      value: function removeEventListeners() {
        document.removeEventListener('touchstart', this.touchStartCallback, { passive: false });
        document.removeEventListener('touchmove', this.touchMoveCallback, { passive: false });
        document.removeEventListener('touchend', this.touchEndCallback, { passive: false });

        this.scrim.removeEventListener('click', this.scrimClickCallback);
      }
    }, {
      key: 'requestAnimationLoop',
      value: function requestAnimationLoop() {
        if (!this.animationFrameRequested) {
          this.animationFrameRequested = true;
          requestAnimationFrame(this.animationFrameCallback);
        }
      }
    }, {
      key: 'getNearestTouch',
      value: function getNearestTouch(touches) {
        var _this3 = this;

        if (touches.length === 1) return touches[0];
        return Array.prototype.reduce.call(touches, function (acc, touch) {
          var dist = (0, _common.pageDist)(_this3, touch);
          return dist < acc.dist ? {
            dist: dist,
            touch: touch
          } : acc;
        }, {
          dist: Number.POSITIVE_INFINITY,
          touch: null
        }).touch;
      }
    }, {
      key: 'touchStartCallback',
      value: function touchStartCallback(e) {
        if (e.touches.length === 1) {
          this.isScrolling = undefined;

          var touch = e.touches[0];
          this.startX = touch.pageX;
          this.startY = touch.pageY;
          this.pageX = touch.pageX;
          this.pageY = touch.pageY;
          this.lastPageX = touch.pageX;
          this.lastPageY = touch.pageY;

          if (this.opened || this.pageX < window.innerWidth / 3) {
            this.prepInteraction();
            this.touching = true;
            this.loopState = TOUCHING;
          }
        }
      }
    }, {
      key: 'touchMoveCallback',
      value: function touchMoveCallback(e) {
        if (this.touching) {
          var touch = this.getNearestTouch(e.touches);
          this.pageX = touch.pageX;
          this.pageY = touch.pageY;

          if (typeof this.isScrolling === 'undefined' && this.startedMoving) {
            this.isScrolling = Math.abs(this.startY - this.pageY) > Math.abs(this.startX - this.pageX);
            if (!this.isScrolling) {
              this.loopState = TOUCHING;
              this.requestAnimationLoop();
            }
          }

          if (this.isScrolling) {
            return;
          }

          e.preventDefault();

          this.startedMoving = true;
        }
      }
    }, {
      key: 'updateMenuOpen',
      value: function updateMenuOpen() {
        if (this.velocity > VELOCITY_THRESHOLD) {
          this.setState('opened', true);
        } else if (this.velocity < -VELOCITY_THRESHOLD) {
          this.setState('opened', false);
        } else if (this.translateX >= this.sliderWidth / 2) {
          this.setState('opened', true);
        } else {
          this.setState('opened', false);
        }
      }
    }, {
      key: 'touchEndCallback',
      value: function touchEndCallback(e) {
        if (this.touching) {
          if (this.isScrolling || e.touches.length > 0) {
            return;
          }

          if (this.startedMoving) {
            this.updateMenuOpen();
          }

          if (this.opened) {
            this.scrim.style.pointerEvents = 'all';
          } else {
            this.scrim.style.pointerEvents = '';
          }

          this.loopState = START_ANIMATING;
          this.startedMoving = false;
          this.touching = false;
        }
      }
    }, {
      key: 'scrimClickCallback',
      value: function scrimClickCallback() {
        this.close();
      }
    }, {
      key: 'prepInteraction',
      value: function prepInteraction() {
        this.content.style.willChange = 'transform';
        this.scrim.style.willChange = 'opacity';
        this.content.classList.remove('y-drawer-opened');
        this.sliderWidth = this.getMovableSliderWidth();
      }
    }, {
      key: 'getMovableSliderWidth',
      value: function getMovableSliderWidth() {
        // Since part of the slider could be visible,
        // the width that is "movable" is less than the complete slider width
        // and given by
        return -this.content.offsetLeft;
      }
    }, {
      key: 'animateTo',
      value: function animateTo(opened) {
        this.prepInteraction();
        this.setState('opened', opened);
        this.loopState = START_ANIMATING;
        this.requestAnimationLoop();
      }
    }, {
      key: 'jumpTo',
      value: function jumpTo(opened) {
        this.prepInteraction();
        this.setState('opened', opened);
        this.loopState = IDLE;
        this.startTranslateX = opened * this.sliderWidth;
        this.endAnimating();
        this.updateDOM(this.startTranslateX, this.sliderWidth);
      }
    }, {
      key: 'updateTranslateX',
      value: function updateTranslateX() {
        var deltaX = this.pageX - this.startX;
        this.translateX = this.startTranslateX + deltaX;
        this.translateX = Math.max(0, Math.min(this.sliderWidth, this.translateX));
        return deltaX;
      }
    }, {
      key: 'animationFrameCallback',
      value: function animationFrameCallback(time) {
        switch (this.loopState) {
          case TOUCHING:
            {
              this.touchingFrame(time);
              break;
            }

          case START_ANIMATING:
            {
              this.startAnimatingFrame(time);
              this.loopState = ANIMATING;
              this.animationFrameCallback(time); // jump to next case block
              break;
            }

          case ANIMATING:
            {
              this.animatingFrame(time);
              break;
            }

          default:
            {
              break;
            }
        }
      }
    }, {
      key: 'touchingFrame',
      value: function touchingFrame(time) {
        var timeDiff = time - this.lastTime;

        if (timeDiff > 0) {
          var pageXDiff = this.pageX - this.lastPageX;
          this.velocity = VELOCITY_LINEAR_COMBINATION * (pageXDiff / timeDiff) + (1 - VELOCITY_LINEAR_COMBINATION) * this.velocity;
        }

        this.updateTranslateX();
        this.updateDOM(this.translateX, this.sliderWidth);

        this.lastTime = time;
        this.lastPageX = this.pageX;
        this.lastPageY = this.pageY;

        requestAnimationFrame(this.animationFrameCallback);
      }
    }, {
      key: 'startAnimatingFrame',
      value: function startAnimatingFrame(time) {
        this.updateTranslateX();

        // store all animation related data in this object,
        // delete after animation is completed
        var animation = {};
        animation.startX = this.translateX;
        animation.endX = (this.opened ? 1 : 0) * this.sliderWidth;
        animation.changeInValue = animation.endX - animation.startX;
        animation.startTime = time;
        this.animation = animation;
      }
    }, {
      key: 'animatingFrame',
      value: function animatingFrame(time) {
        var timeInAnimation = time - this.animation.startTime;

        if (timeInAnimation < this.transitionDuration) {
          this.animatingCont(timeInAnimation);
        } else {
          this.animatingEnd();
        }

        this.updateDOM(this.startTranslateX, this.sliderWidth);
      }
    }, {
      key: 'animatingCont',
      value: function animatingCont(timeInAnimation) {
        var startValue = this.animation.startX;
        var changeInValue = this.animation.changeInValue;
        this.startTranslateX = (0, _common.linearTween)(timeInAnimation, startValue, changeInValue, this.transitionDuration);
        requestAnimationFrame(this.animationFrameCallback);
      }
    }, {
      key: 'animatingEnd',
      value: function animatingEnd() {
        // end animation
        this.startTranslateX = this.animation.endX;
        delete this.animation;
        this.endAnimating();
      }
    }, {
      key: 'endAnimating',
      value: function endAnimating() {
        this.animationFrameRequested = false;
        this.loopState = IDLE;
        this.velocity = 0;

        if (this.opened) {
          // document.body.style.overflowY = 'hidden';
          this.scrim.style.pointerEvents = 'all';
          this.content.classList.add('y-drawer-opened');
        } else {
          // document.body.style.overflowY = '';
          this.scrim.style.pointerEvents = '';
        }

        this.content.style.willChange = '';
        this.scrim.style.willChange = '';

        this.fireEvent('transitioned');
      }
    }, {
      key: 'updateDOM',
      value: function updateDOM(translateX, sliderWidth) {
        this.content.style.transform = 'translateX(' + translateX + 'px)';
        this.scrim.style.opacity = translateX / sliderWidth;
      }
    }, {
      key: 'close',
      value: function close() {
        this.animateTo(false);
        return this;
      }
    }, {
      key: 'open',
      value: function open() {
        this.animateTo(true);
        return this;
      }
    }, {
      key: 'toggle',
      value: function toggle() {
        if (this.opened) {
          this.close();
        } else {
          this.open();
        }
        return this;
      }
    }, {
      key: 'persist',
      value: function persist() {
        this.scrim.style.display = 'none';
        this.removeEventListeners();
        this.setState('persistent', true);
      }
    }, {
      key: 'unpersist',
      value: function unpersist() {
        this.scrim.style.display = '';
        this.addEventListeners();
        this.setState('persistent', false);
      }
    }]);

    return _class;
  }((0, _componentCore3.default)(C));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common":177,"y-component/src/component-core":176}],179:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

var style = '\n<style>\n@media screen {\n  .y-drawer-scrim {\n    display: block;\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    opacity: 0;\n    z-index: 0;\n    pointer-events: none;\n    transform: translate3d(0,0,0);\n    -webkit-tap-highlight-color: transparent;\n\n    background: rgba(0, 0, 0, 0.67);\n  }\n\n  .y-drawer-content {\n    position: fixed;\n    left: 0;\n    bottom: 0;\n    top: 0;\n    z-index: 1;\n    overflow-x: hidden;\n    overflow-y: auto;\n    transform: translate3d(0,0,0);\n    -webkit-overflow-scrolling: touch;\n    contain: strict;\n\n    left: -18rem;\n    width: 18rem;\n    background: #e8e8e8;\n  }\n\n  .y-drawer-content.y-drawer-opened {\n    left: 0!important;\n    transform: translate3d(0,0,0)!important;\n  }\n}\n\n@media print {\n  .y-drawer-scrim {\n    display: none!important;\n  }\n\n  .y-drawer-content {\n    transform: none!important;\n  }\n}\n\n</style>';

function fragmentFromString(strHTML) {
  return document.createRange().createContextualFragment(strHTML);
}

var Drawer = function (_drawerCore) {
  _inherits(Drawer, _drawerCore);

  function Drawer(el, props) {
    _classCallCheck(this, Drawer);

    var _this = _possibleConstructorReturn(this, (Drawer.__proto__ || Object.getPrototypeOf(Drawer)).call(this));

    _this.setupComponent(el, props);
    return _this;
  }

  // @override


  _createClass(Drawer, [{
    key: 'setupDOM',
    value: function setupDOM(el) {
      if (!el) throw Error('No element provided');

      var scrim = document.createElement('div');
      scrim.classList.add('y-drawer-scrim');

      var content = document.createElement('div');
      content.classList.add('y-drawer-content');
      while (el.children.length > 0) {
        content.appendChild(el.children[0]);
      }

      el.appendChild(scrim);
      el.appendChild(content);

      var ref = document.getElementsByTagName('style')[0];
      ref.parentNode.insertBefore(fragmentFromString(style), ref);

      return el;
    }
  }]);

  return Drawer;
}((0, _core2.default)());

exports.default = Drawer;

},{"../core":178}],180:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber);
exports.InnerSubscriber = InnerSubscriber;


},{"./Subscriber":188}],181:[function(require,module,exports){
"use strict";

var Observable_1 = require('./Observable');
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        } else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return this.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return this.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}();
exports.Notification = Notification;


},{"./Observable":182}],182:[function(require,module,exports){
"use strict";

var root_1 = require('./util/root');
var toSubscriber_1 = require('./util/toSubscriber');
var observable_1 = require('./symbol/observable');
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        } else {
            sink.add(this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        } catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            } else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    } catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                } else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.$$observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}();
exports.Observable = Observable;


},{"./symbol/observable":258,"./util/root":272,"./util/toSubscriber":274}],183:[function(require,module,exports){
"use strict";

exports.empty = {
    closed: true,
    next: function next(value) {},
    error: function error(err) {
        throw err;
    },
    complete: function complete() {}
};


},{}],184:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber);
exports.OuterSubscriber = OuterSubscriber;


},{"./Subscriber":188}],185:[function(require,module,exports){
arguments[4][120][0].apply(exports,arguments)
},{"dup":120}],186:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber);
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        } else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable);
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        } else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject);
exports.AnonymousSubject = AnonymousSubject;


},{"./Observable":182,"./SubjectSubscription":187,"./Subscriber":188,"./Subscription":189,"./symbol/rxSubscriber":259,"./util/ObjectUnsubscribedError":261}],187:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription);
exports.SubjectSubscription = SubjectSubscription;


},{"./Subscription":189}],188:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if ((typeof destinationOrNext === 'undefined' ? 'undefined' : _typeof(destinationOrNext)) === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    } else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return this;
    };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription);
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        } else if (observerOrNext) {
            context = observerOrNext;
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (isFunction_1.isFunction(context.unsubscribe)) {
                this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            } else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            } else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._complete);
                    this.unsubscribe();
                }
            } else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber);


},{"./Observer":183,"./Subscription":189,"./symbol/rxSubscriber":259,"./util/isFunction":267}],189:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents,
            _unsubscribe = _a._unsubscribe,
            _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        } else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || teardown === Subscription.EMPTY) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown === 'undefined' ? 'undefined' : _typeof(teardown)) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                } else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                } else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        } else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        } else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription());
    return Subscription;
}();
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) {
        return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
    }, []);
}


},{"./util/UnsubscriptionError":262,"./util/errorObject":263,"./util/isArray":264,"./util/isFunction":267,"./util/isObject":269,"./util/tryCatch":275}],190:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var defer_1 = require('../../observable/defer');
Observable_1.Observable.defer = defer_1.defer;


},{"../../Observable":182,"../../observable/defer":223}],191:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../../Observable');
var ajax_1 = require('../../../observable/dom/ajax');
Observable_1.Observable.ajax = ajax_1.ajax;


},{"../../../Observable":182,"../../../observable/dom/ajax":225}],192:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var fromEvent_1 = require('../../observable/fromEvent');
Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;


},{"../../Observable":182,"../../observable/fromEvent":226}],193:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var merge_1 = require('../../observable/merge');
Observable_1.Observable.merge = merge_1.merge;


},{"../../Observable":182,"../../observable/merge":227}],194:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var of_1 = require('../../observable/of');
Observable_1.Observable.of = of_1.of;


},{"../../Observable":182,"../../observable/of":228}],195:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var throw_1 = require('../../observable/throw');
Observable_1.Observable.throw = throw_1._throw;


},{"../../Observable":182,"../../observable/throw":229}],196:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var timer_1 = require('../../observable/timer');
Observable_1.Observable.timer = timer_1.timer;


},{"../../Observable":182,"../../observable/timer":230}],197:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var catch_1 = require('../../operator/catch');
Observable_1.Observable.prototype.catch = catch_1._catch;
Observable_1.Observable.prototype._catch = catch_1._catch;


},{"../../Observable":182,"../../operator/catch":231}],198:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var debounceTime_1 = require('../../operator/debounceTime');
Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;


},{"../../Observable":182,"../../operator/debounceTime":233}],199:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var delay_1 = require('../../operator/delay');
Observable_1.Observable.prototype.delay = delay_1.delay;


},{"../../Observable":182,"../../operator/delay":234}],200:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var distinctUntilKeyChanged_1 = require('../../operator/distinctUntilKeyChanged');
Observable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;


},{"../../Observable":182,"../../operator/distinctUntilKeyChanged":236}],201:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var do_1 = require('../../operator/do');
Observable_1.Observable.prototype.do = do_1._do;
Observable_1.Observable.prototype._do = do_1._do;


},{"../../Observable":182,"../../operator/do":237}],202:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var filter_1 = require('../../operator/filter');
Observable_1.Observable.prototype.filter = filter_1.filter;


},{"../../Observable":182,"../../operator/filter":238}],203:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var map_1 = require('../../operator/map');
Observable_1.Observable.prototype.map = map_1.map;


},{"../../Observable":182,"../../operator/map":239}],204:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var mergeAll_1 = require('../../operator/mergeAll');
Observable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;


},{"../../Observable":182,"../../operator/mergeAll":241}],205:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var retryWhen_1 = require('../../operator/retryWhen');
Observable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;


},{"../../Observable":182,"../../operator/retryWhen":243}],206:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var share_1 = require('../../operator/share');
Observable_1.Observable.prototype.share = share_1.share;


},{"../../Observable":182,"../../operator/share":244}],207:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var startWith_1 = require('../../operator/startWith');
Observable_1.Observable.prototype.startWith = startWith_1.startWith;


},{"../../Observable":182,"../../operator/startWith":245}],208:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var switch_1 = require('../../operator/switch');
Observable_1.Observable.prototype.switch = switch_1._switch;
Observable_1.Observable.prototype._switch = switch_1._switch;


},{"../../Observable":182,"../../operator/switch":246}],209:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var switchMap_1 = require('../../operator/switchMap');
Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;


},{"../../Observable":182,"../../operator/switchMap":247}],210:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var take_1 = require('../../operator/take');
Observable_1.Observable.prototype.take = take_1.take;


},{"../../Observable":182,"../../operator/take":248}],211:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var takeUntil_1 = require('../../operator/takeUntil');
Observable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;


},{"../../Observable":182,"../../operator/takeUntil":249}],212:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var throttleTime_1 = require('../../operator/throttleTime');
Observable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;


},{"../../Observable":182,"../../operator/throttleTime":250}],213:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var withLatestFrom_1 = require('../../operator/withLatestFrom');
Observable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;


},{"../../Observable":182,"../../operator/withLatestFrom":251}],214:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var zip_1 = require('../../operator/zip');
Observable_1.Observable.prototype.zip = zip_1.zipProto;


},{"../../Observable":182,"../../operator/zip":252}],215:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var ScalarObservable_1 = require('./ScalarObservable');
var EmptyObservable_1 = require('./EmptyObservable');
var isScheduler_1 = require('../util/isScheduler');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        } else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        } else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        } else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array,
            index = state.index,
            count = state.count,
            subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable);
exports.ArrayObservable = ArrayObservable;


},{"../Observable":182,"../util/isScheduler":271,"./EmptyObservable":218,"./ScalarObservable":221}],216:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('../Subject');
var Observable_1 = require('../Observable');
var Subscriber_1 = require('../Subscriber');
var Subscription_1 = require('../Subscription');
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            } else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return this.lift(new RefCountOperator(this));
    };
    return ConnectableObservable;
}(Observable_1.Observable);
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subscribe: { value: ConnectableObservable.prototype._subscribe },
    getSubject: { value: ConnectableObservable.prototype.getSubject },
    connect: { value: ConnectableObservable.prototype.connect },
    refCount: { value: ConnectableObservable.prototype.refCount }
};
var ConnectableSubscriber = function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber);
var RefCountOperator = function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}();
var RefCountSubscriber = function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber);


},{"../Observable":182,"../Subject":186,"../Subscriber":188,"../Subscription":189}],217:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var subscribeToResult_1 = require('../util/subscribeToResult');
var OuterSubscriber_1 = require('../OuterSubscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var DeferObservable = function (_super) {
    __extends(DeferObservable, _super);
    function DeferObservable(observableFactory) {
        _super.call(this);
        this.observableFactory = observableFactory;
    }
    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * // Results in the following behavior:
     * // If the result of Math.random() is greater than 0.5 it will listen
     * // for clicks anywhere on the "document"; when document is clicked it
     * // will log a MouseEvent object to the console. If the result is less
     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
     *
     * @see {@link create}
     *
     * @param {function(): SubscribableOrPromise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */
    DeferObservable.create = function (observableFactory) {
        return new DeferObservable(observableFactory);
    };
    DeferObservable.prototype._subscribe = function (subscriber) {
        return new DeferSubscriber(subscriber, this.observableFactory);
    };
    return DeferObservable;
}(Observable_1.Observable);
exports.DeferObservable = DeferObservable;
var DeferSubscriber = function (_super) {
    __extends(DeferSubscriber, _super);
    function DeferSubscriber(destination, factory) {
        _super.call(this, destination);
        this.factory = factory;
        this.tryDefer();
    }
    DeferSubscriber.prototype.tryDefer = function () {
        try {
            this._callFactory();
        } catch (err) {
            this._error(err);
        }
    };
    DeferSubscriber.prototype._callFactory = function () {
        var result = this.factory();
        if (result) {
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return DeferSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../Observable":182,"../OuterSubscriber":184,"../util/subscribeToResult":273}],218:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        } else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable);
exports.EmptyObservable = EmptyObservable;


},{"../Observable":182}],219:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ErrorObservable = function (_super) {
    __extends(ErrorObservable, _super);
    function ErrorObservable(error, scheduler) {
        _super.call(this);
        this.error = error;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x === 13 ?
     *     Rx.Observable.throw('Thirteens are bad') :
     *     Rx.Observable.of('a', 'b', 'c')
     * );
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */
    ErrorObservable.create = function (error, scheduler) {
        return new ErrorObservable(error, scheduler);
    };
    ErrorObservable.dispatch = function (arg) {
        var error = arg.error,
            subscriber = arg.subscriber;
        subscriber.error(error);
    };
    ErrorObservable.prototype._subscribe = function (subscriber) {
        var error = this.error;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ErrorObservable.dispatch, 0, {
                error: error, subscriber: subscriber
            });
        } else {
            subscriber.error(error);
        }
    };
    return ErrorObservable;
}(Observable_1.Observable);
exports.ErrorObservable = ErrorObservable;


},{"../Observable":182}],220:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var tryCatch_1 = require('../util/tryCatch');
var isFunction_1 = require('../util/isFunction');
var errorObject_1 = require('../util/errorObject');
var Subscription_1 = require('../Subscription');
var toString = Object.prototype.toString;
function isNodeStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isNodeList(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
}
function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
}
function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventObservable = function (_super) {
    __extends(FromEventObservable, _super);
    function FromEventObservable(sourceObj, eventName, selector, options) {
        _super.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
        this.options = options;
    }
    /* tslint:enable:max-line-length */
    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * Creates an Observable by attaching an event listener to an "event target",
     * which may be an object with `addEventListener` and `removeEventListener`,
     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
     * the output Observable is subscribed, and removed when the Subscription is
     * unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console everytime a click
     * // occurs on the document.
     *
     * @see {@link from}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOMElement, event target, Node.js
     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @param {SelectorMethodSignature<T>} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    FromEventObservable.create = function (target, eventName, options, selector) {
        if (isFunction_1.isFunction(options)) {
            selector = options;
            options = undefined;
        }
        return new FromEventObservable(target, eventName, selector, options);
    };
    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        } else if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function unsubscribe() {
                return source_1.removeEventListener(eventName, handler);
            };
        } else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function unsubscribe() {
                return source_2.off(eventName, handler);
            };
        } else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function unsubscribe() {
                return source_3.removeListener(eventName, handler);
            };
        } else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(new Subscription_1.Subscription(unsubscribe));
    };
    FromEventObservable.prototype._subscribe = function (subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var options = this.options;
        var selector = this.selector;
        var handler = selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
            if (result === errorObject_1.errorObject) {
                subscriber.error(errorObject_1.errorObject.e);
            } else {
                subscriber.next(result);
            }
        } : function (e) {
            return subscriber.next(e);
        };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
    };
    return FromEventObservable;
}(Observable_1.Observable);
exports.FromEventObservable = FromEventObservable;


},{"../Observable":182,"../Subscription":189,"../util/errorObject":263,"../util/isFunction":267,"../util/tryCatch":275}],221:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done,
            value = state.value,
            subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        } else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable);
exports.ScalarObservable = ScalarObservable;


},{"../Observable":182}],222:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = require('../util/isNumeric');
var Observable_1 = require('../Observable');
var async_1 = require('../scheduler/async');
var isScheduler_1 = require('../util/isScheduler');
var isDate_1 = require('../util/isDate');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = function (_super) {
    __extends(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) {
            dueTime = 0;
        }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        } else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ? +dueTime - this.scheduler.now() : dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) {
            initialDelay = 0;
        }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index,
            period = state.period,
            subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        } else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            period = _a.period,
            dueTime = _a.dueTime,
            scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable);
exports.TimerObservable = TimerObservable;


},{"../Observable":182,"../scheduler/async":256,"../util/isDate":266,"../util/isNumeric":268,"../util/isScheduler":271}],223:[function(require,module,exports){
"use strict";

var DeferObservable_1 = require('./DeferObservable');
exports.defer = DeferObservable_1.DeferObservable.create;


},{"./DeferObservable":217}],224:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../../util/root');
var tryCatch_1 = require('../../util/tryCatch');
var errorObject_1 = require('../../util/errorObject');
var Observable_1 = require('../../Observable');
var Subscriber_1 = require('../../Subscriber');
var map_1 = require('../../operator/map');
function getCORSRequest() {
    if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
    } else if (!!root_1.root.XDomainRequest) {
        return new root_1.root.XDomainRequest();
    } else {
        throw new Error('CORS is not supported by your browser');
    }
}
function getXMLHttpRequest() {
    if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
    } else {
        var progId = void 0;
        try {
            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
            for (var i = 0; i < 3; i++) {
                try {
                    progId = progIds[i];
                    if (new root_1.root.ActiveXObject(progId)) {
                        break;
                    }
                } catch (e) {}
            }
            return new root_1.root.ActiveXObject(progId);
        } catch (e) {
            throw new Error('XMLHttpRequest is not supported by your browser');
        }
    }
}
function ajaxGet(url, headers) {
    if (headers === void 0) {
        headers = null;
    }
    return new AjaxObservable({ method: 'GET', url: url, headers: headers });
}
exports.ajaxGet = ajaxGet;
;
function ajaxPost(url, body, headers) {
    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });
}
exports.ajaxPost = ajaxPost;
;
function ajaxDelete(url, headers) {
    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });
}
exports.ajaxDelete = ajaxDelete;
;
function ajaxPut(url, body, headers) {
    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });
}
exports.ajaxPut = ajaxPut;
;
function ajaxPatch(url, body, headers) {
    return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });
}
exports.ajaxPatch = ajaxPatch;
;
function ajaxGetJSON(url, headers) {
    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers }).lift(new map_1.MapOperator(function (x, index) {
        return x.response;
    }, null));
}
exports.ajaxGetJSON = ajaxGetJSON;
;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var AjaxObservable = function (_super) {
    __extends(AjaxObservable, _super);
    function AjaxObservable(urlOrRequest) {
        _super.call(this);
        var request = {
            async: true,
            createXHR: function createXHR() {
                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();
            },
            crossDomain: false,
            withCredentials: false,
            headers: {},
            method: 'GET',
            responseType: 'json',
            timeout: 0
        };
        if (typeof urlOrRequest === 'string') {
            request.url = urlOrRequest;
        } else {
            for (var prop in urlOrRequest) {
                if (urlOrRequest.hasOwnProperty(prop)) {
                    request[prop] = urlOrRequest[prop];
                }
            }
        }
        this.request = request;
    }
    AjaxObservable.prototype._subscribe = function (subscriber) {
        return new AjaxSubscriber(subscriber, this.request);
    };
    /**
     * Creates an observable for an Ajax request with either a request object with
     * url, headers, etc or a string for a URL.
     *
     * @example
     * source = Rx.Observable.ajax('/products');
     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });
     *
     * @param {string|Object} request Can be one of the following:
     *   A string of the URL to make the Ajax call.
     *   An object with the following properties
     *   - url: URL of the request
     *   - body: The body of the request
     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
     *   - async: Whether the request is async
     *   - headers: Optional headers
     *   - crossDomain: true if a cross domain request, else false
     *   - createXHR: a function to override if you need to use an alternate
     *   XMLHttpRequest implementation.
     *   - resultSelector: a function to use to alter the output value type of
     *   the Observable. Gets {@link AjaxResponse} as an argument.
     * @return {Observable} An observable sequence containing the XMLHttpRequest.
     * @static true
     * @name ajax
     * @owner Observable
    */
    AjaxObservable.create = function () {
        var create = function create(urlOrRequest) {
            return new AjaxObservable(urlOrRequest);
        };
        create.get = ajaxGet;
        create.post = ajaxPost;
        create.delete = ajaxDelete;
        create.put = ajaxPut;
        create.patch = ajaxPatch;
        create.getJSON = ajaxGetJSON;
        return create;
    }();
    return AjaxObservable;
}(Observable_1.Observable);
exports.AjaxObservable = AjaxObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AjaxSubscriber = function (_super) {
    __extends(AjaxSubscriber, _super);
    function AjaxSubscriber(destination, request) {
        _super.call(this, destination);
        this.request = request;
        this.done = false;
        var headers = request.headers = request.headers || {};
        // force CORS if requested
        if (!request.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
        }
        // ensure content type is set
        if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {
            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
        }
        // properly serialize body
        request.body = this.serializeBody(request.body, request.headers['Content-Type']);
        this.send();
    }
    AjaxSubscriber.prototype.next = function (e) {
        this.done = true;
        var _a = this,
            xhr = _a.xhr,
            request = _a.request,
            destination = _a.destination;
        var response = new AjaxResponse(e, xhr, request);
        destination.next(response);
    };
    AjaxSubscriber.prototype.send = function () {
        var _a = this,
            request = _a.request,
            _b = _a.request,
            user = _b.user,
            method = _b.method,
            url = _b.url,
            async = _b.async,
            password = _b.password,
            headers = _b.headers,
            body = _b.body;
        var createXHR = request.createXHR;
        var xhr = tryCatch_1.tryCatch(createXHR).call(request);
        if (xhr === errorObject_1.errorObject) {
            this.error(errorObject_1.errorObject.e);
        } else {
            this.xhr = xhr;
            // set up the events before open XHR
            // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
            // You need to add the event listeners before calling open() on the request.
            // Otherwise the progress events will not fire.
            this.setupEvents(xhr, request);
            // open XHR
            var result = void 0;
            if (user) {
                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);
            } else {
                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);
            }
            if (result === errorObject_1.errorObject) {
                this.error(errorObject_1.errorObject.e);
                return null;
            }
            // timeout, responseType and withCredentials can be set once the XHR is open
            xhr.timeout = request.timeout;
            xhr.responseType = request.responseType;
            if ('withCredentials' in xhr) {
                xhr.withCredentials = !!request.withCredentials;
            }
            // set headers
            this.setHeaders(xhr, headers);
            // finally send the request
            result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);
            if (result === errorObject_1.errorObject) {
                this.error(errorObject_1.errorObject.e);
                return null;
            }
        }
        return xhr;
    };
    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {
        if (!body || typeof body === 'string') {
            return body;
        } else if (root_1.root.FormData && body instanceof root_1.root.FormData) {
            return body;
        }
        if (contentType) {
            var splitIndex = contentType.indexOf(';');
            if (splitIndex !== -1) {
                contentType = contentType.substring(0, splitIndex);
            }
        }
        switch (contentType) {
            case 'application/x-www-form-urlencoded':
                return Object.keys(body).map(function (key) {
                    return encodeURI(key) + "=" + encodeURI(body[key]);
                }).join('&');
            case 'application/json':
                return JSON.stringify(body);
            default:
                return body;
        }
    };
    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {
        for (var key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
    };
    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {
        var progressSubscriber = request.progressSubscriber;
        function xhrTimeout(e) {
            var _a = xhrTimeout,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
            if (progressSubscriber) {
                progressSubscriber.error(e);
            }
            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.
        }
        ;
        xhr.ontimeout = xhrTimeout;
        xhrTimeout.request = request;
        xhrTimeout.subscriber = this;
        xhrTimeout.progressSubscriber = progressSubscriber;
        if (xhr.upload && 'withCredentials' in xhr) {
            if (progressSubscriber) {
                var _xhrProgress_;
                _xhrProgress_ = function xhrProgress_1(e) {
                    var progressSubscriber = _xhrProgress_.progressSubscriber;
                    progressSubscriber.next(e);
                };
                if (root_1.root.XDomainRequest) {
                    xhr.onprogress = _xhrProgress_;
                } else {
                    xhr.upload.onprogress = _xhrProgress_;
                }
                _xhrProgress_.progressSubscriber = progressSubscriber;
            }
            var _xhrError_;
            _xhrError_ = function xhrError_1(e) {
                var _a = _xhrError_,
                    progressSubscriber = _a.progressSubscriber,
                    subscriber = _a.subscriber,
                    request = _a.request;
                if (progressSubscriber) {
                    progressSubscriber.error(e);
                }
                subscriber.error(new AjaxError('ajax error', this, request));
            };
            xhr.onerror = _xhrError_;
            _xhrError_.request = request;
            _xhrError_.subscriber = this;
            _xhrError_.progressSubscriber = progressSubscriber;
        }
        function xhrReadyStateChange(e) {
            var _a = xhrReadyStateChange,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
            if (this.readyState === 4) {
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                var status_1 = this.status === 1223 ? 204 : this.status;
                var response = this.responseType === 'text' ? this.response || this.responseText : this.response;
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status_1 === 0) {
                    status_1 = response ? 200 : 0;
                }
                if (200 <= status_1 && status_1 < 300) {
                    if (progressSubscriber) {
                        progressSubscriber.complete();
                    }
                    subscriber.next(e);
                    subscriber.complete();
                } else {
                    if (progressSubscriber) {
                        progressSubscriber.error(e);
                    }
                    subscriber.error(new AjaxError('ajax error ' + status_1, this, request));
                }
            }
        }
        ;
        xhr.onreadystatechange = xhrReadyStateChange;
        xhrReadyStateChange.subscriber = this;
        xhrReadyStateChange.progressSubscriber = progressSubscriber;
        xhrReadyStateChange.request = request;
    };
    AjaxSubscriber.prototype.unsubscribe = function () {
        var _a = this,
            done = _a.done,
            xhr = _a.xhr;
        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {
            xhr.abort();
        }
        _super.prototype.unsubscribe.call(this);
    };
    return AjaxSubscriber;
}(Subscriber_1.Subscriber);
exports.AjaxSubscriber = AjaxSubscriber;
/**
 * A normalized AJAX response.
 *
 * @see {@link ajax}
 *
 * @class AjaxResponse
 */
var AjaxResponse = function () {
    function AjaxResponse(originalEvent, xhr, request) {
        this.originalEvent = originalEvent;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
        this.responseType = xhr.responseType || request.responseType;
        switch (this.responseType) {
            case 'json':
                if ('response' in xhr) {
                    //IE does not support json as responseType, parse it internally
                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
                } else {
                    this.response = JSON.parse(xhr.responseText || 'null');
                }
                break;
            case 'xml':
                this.response = xhr.responseXML;
                break;
            case 'text':
            default:
                this.response = 'response' in xhr ? xhr.response : xhr.responseText;
                break;
        }
    }
    return AjaxResponse;
}();
exports.AjaxResponse = AjaxResponse;
/**
 * A normalized AJAX error.
 *
 * @see {@link ajax}
 *
 * @class AjaxError
 */
var AjaxError = function (_super) {
    __extends(AjaxError, _super);
    function AjaxError(message, xhr, request) {
        _super.call(this, message);
        this.message = message;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
    }
    return AjaxError;
}(Error);
exports.AjaxError = AjaxError;
/**
 * @see {@link ajax}
 *
 * @class AjaxTimeoutError
 */
var AjaxTimeoutError = function (_super) {
    __extends(AjaxTimeoutError, _super);
    function AjaxTimeoutError(xhr, request) {
        _super.call(this, 'ajax timeout', xhr, request);
    }
    return AjaxTimeoutError;
}(AjaxError);
exports.AjaxTimeoutError = AjaxTimeoutError;


},{"../../Observable":182,"../../Subscriber":188,"../../operator/map":239,"../../util/errorObject":263,"../../util/root":272,"../../util/tryCatch":275}],225:[function(require,module,exports){
"use strict";

var AjaxObservable_1 = require('./AjaxObservable');
exports.ajax = AjaxObservable_1.AjaxObservable.create;


},{"./AjaxObservable":224}],226:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"./FromEventObservable":220,"dup":132}],227:[function(require,module,exports){
"use strict";

var merge_1 = require('../operator/merge');
exports.merge = merge_1.mergeStatic;


},{"../operator/merge":240}],228:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"./ArrayObservable":215,"dup":133}],229:[function(require,module,exports){
"use strict";

var ErrorObservable_1 = require('./ErrorObservable');
exports._throw = ErrorObservable_1.ErrorObservable.create;


},{"./ErrorObservable":219}],230:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"./TimerObservable":222,"dup":134}],231:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @name catch
 * @owner Observable
 */
function _catch(selector) {
    var operator = new CatchOperator(selector);
    var caught = this.lift(operator);
    return operator.caught = caught;
}
exports._catch = _catch;
var CatchOperator = function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            } catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":184,"../util/subscribeToResult":273}],232:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"../Observable":182,"../observable/ArrayObservable":215,"../util/isScheduler":271,"./mergeAll":241,"dup":136}],233:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var async_1 = require('../scheduler/async');
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber);
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}


},{"../Subscriber":188,"../scheduler/async":256}],234:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = require('../scheduler/async');
var isDate_1 = require('../util/isDate');
var Subscriber_1 = require('../Subscriber');
var Notification_1 = require('../Notification');
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * <img src="./img/delay.png" width="100%">
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * @example <caption>Delay each click by one second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @example <caption>Delay all clicks until a future date happens</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var date = new Date('March 15, 2050 12:00:00'); // in the future
 * var delayedClicks = clicks.delay(date); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {Scheduler} [scheduler=async] The IScheduler to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */
function delay(delay, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);
    return this.lift(new DelayOperator(delayFor, scheduler));
}
exports.delay = delay;
var DelayOperator = function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        _super.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        } else {
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber);
var DelayMessage = function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}();


},{"../Notification":181,"../Subscriber":188,"../scheduler/async":256,"../util/isDate":266}],235:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var tryCatch_1 = require('../util/tryCatch');
var errorObject_1 = require('../util/errorObject');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        } else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":188,"../util/errorObject":263,"../util/tryCatch":275}],236:[function(require,module,exports){
"use strict";

var distinctUntilChanged_1 = require('./distinctUntilChanged');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
 * using a property accessed by using the key provided to check if the two items are distinct.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>An example comparing the name of persons</caption>
 *
 *  interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'},
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilKeyChanged('name')
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @example <caption>An example comparing the first letters of the name</caption>
 *
 * interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo1'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo2'},
 *     { age: 6, name: 'Foo3'})
 *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo1' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo2' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 *
 * @param {string} key String key for object property lookup on each item.
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.
 * @method distinctUntilKeyChanged
 * @owner Observable
 */
function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged.call(this, function (x, y) {
        if (compare) {
            return compare(x[key], y[key]);
        }
        return x[key] === y[key];
    });
}
exports.distinctUntilKeyChanged = distinctUntilKeyChanged;


},{"./distinctUntilChanged":235}],237:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
function _do(nextOrObserver, error, complete) {
    return this.lift(new DoOperator(nextOrObserver, error, complete));
}
exports._do = _do;
var DoOperator = function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":188}],238:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return this.lift(new FilterOperator(predicate, thisArg));
}
exports.filter = filter;
var FilterOperator = function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
        this.predicate = predicate;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":188}],239:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return this.lift(new MapOperator(project, thisArg));
}
exports.map = map;
var MapOperator = function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}();
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":188}],240:[function(require,module,exports){
"use strict";

var Observable_1 = require('../Observable');
var ArrayObservable_1 = require('../observable/ArrayObservable');
var mergeAll_1 = require('./mergeAll');
var isScheduler_1 = require('../util/isScheduler');
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {ObservableInput} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} An Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
}
exports.merge = merge;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (as arguments), and simply
 * forwards (without doing any transformation) all the values from all the input
 * Observables to the output Observable. The output Observable only completes
 * once all input Observables have completed. Any error delivered by an input
 * Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // timer will emit ascending values, one every second(1000ms) to console
 * // clicks logs MouseEvents to console everytime the "document" is clicked
 * // Since the two streams are merged you see these happening
 * // as they occur.
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - First timer1 and timer2 will run concurrently
 * // - timer1 will emit a value every 1000ms for 10 iterations
 * // - timer2 will emit a value every 2000ms for 6 iterations
 * // - after timer1 hits it's max iteration, timer2 will
 * //   continue, and timer3 will start to run concurrently with timer2
 * // - when timer2 hits it's max iteration it terminates, and
 * //   timer3 will continue to emit a value every 500ms until it is complete
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {...ObservableInput} observables Input Observables to merge together.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @static true
 * @name merge
 * @owner Observable
 */
function mergeStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    } else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
}
exports.mergeStatic = mergeStatic;


},{"../Observable":182,"../observable/ArrayObservable":215,"../util/isScheduler":271,"./mergeAll":241}],241:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return this.lift(new MergeAllOperator(concurrent));
}
exports.mergeAll = mergeAll;
var MergeAllOperator = function () {
    function MergeAllOperator(concurrent) {
        this.concurrent = concurrent;
    }
    MergeAllOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
    };
    return MergeAllOperator;
}();
exports.MergeAllOperator = MergeAllOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeAllSubscriber = function (_super) {
    __extends(MergeAllSubscriber, _super);
    function MergeAllSubscriber(destination, concurrent) {
        _super.call(this, destination);
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
    }
    MergeAllSubscriber.prototype._next = function (observable) {
        if (this.active < this.concurrent) {
            this.active++;
            this.add(subscribeToResult_1.subscribeToResult(this, observable));
        } else {
            this.buffer.push(observable);
        }
    };
    MergeAllSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeAllSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeAllSubscriber = MergeAllSubscriber;


},{"../OuterSubscriber":184,"../util/subscribeToResult":273}],242:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"../observable/ConnectableObservable":216,"dup":145}],243:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('../Subject');
var tryCatch_1 = require('../util/tryCatch');
var errorObject_1 = require('../util/errorObject');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.
 * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child
 * subscription. Otherwise this method will resubscribe to the source Observable.
 *
 * <img src="./img/retryWhen.png" width="100%">
 *
 * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a
 * user can `complete` or `error`, aborting the retry.
 * @return {Observable} The source Observable modified with retry logic.
 * @method retryWhen
 * @owner Observable
 */
function retryWhen(notifier) {
    return this.lift(new RetryWhenOperator(notifier, this));
}
exports.retryWhen = retryWhen;
var RetryWhenOperator = function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetryWhenSubscriber = function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject_1.Subject();
                retries = tryCatch_1.tryCatch(this.notifier)(errors);
                if (retries === errorObject_1.errorObject) {
                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);
                }
                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
            } else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this,
            errors = _a.errors,
            retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this,
            errors = _a.errors,
            retries = _a.retries,
            retriesSubscription = _a.retriesSubscription;
        this.errors = null;
        this.retries = null;
        this.retriesSubscription = null;
        this._unsubscribeAndRecycle();
        this.errors = errors;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":184,"../Subject":186,"../util/errorObject":263,"../util/subscribeToResult":273,"../util/tryCatch":275}],244:[function(require,module,exports){
arguments[4][147][0].apply(exports,arguments)
},{"../Subject":186,"./multicast":242,"dup":147}],245:[function(require,module,exports){
arguments[4][148][0].apply(exports,arguments)
},{"../observable/ArrayObservable":215,"../observable/EmptyObservable":218,"../observable/ScalarObservable":221,"../util/isScheduler":271,"./concat":232,"dup":148}],246:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Converts a higher-order Observable into a first-order Observable by
 * subscribing to only the most recently emitted of those inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * previous inner Observable once a new one appears.</span>
 *
 * <img src="./img/switch.png" width="100%">
 *
 * `switch` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable subscribes to the inner Observable and
 * begins emitting the items emitted by that. So far, it behaves
 * like {@link mergeAll}. However, when a new inner Observable is emitted,
 * `switch` unsubscribes from the earlier-emitted inner Observable and
 * subscribes to the new inner Observable and begins emitting items from it. It
 * continues to behave like this for subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * // Each click event is mapped to an Observable that ticks every second
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var switched = higherOrder.switch();
 * // The outcome is that `switched` is essentially a timer that restarts
 * // on every click. The interval Observables from older clicks do not merge
 * // with the current interval Observable.
 * switched.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switchMap}
 * @see {@link switchMapTo}
 * @see {@link zipAll}
 *
 * @return {Observable<T>} An Observable that emits the items emitted by the
 * Observable most recently emitted by the source Observable.
 * @method switch
 * @name switch
 * @owner Observable
 */
function _switch() {
    return this.lift(new SwitchOperator());
}
exports._switch = _switch;
var SwitchOperator = function () {
    function SwitchOperator() {}
    SwitchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchSubscriber(subscriber));
    };
    return SwitchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchSubscriber = function (_super) {
    __extends(SwitchSubscriber, _super);
    function SwitchSubscriber(destination) {
        _super.call(this, destination);
        this.active = 0;
        this.hasCompleted = false;
    }
    SwitchSubscriber.prototype._next = function (value) {
        this.unsubscribeInner();
        this.active++;
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, value));
    };
    SwitchSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    SwitchSubscriber.prototype.unsubscribeInner = function () {
        this.active = this.active > 0 ? this.active - 1 : 0;
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
            this.remove(innerSubscription);
        }
    };
    SwitchSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    SwitchSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchSubscriber.prototype.notifyComplete = function () {
        this.unsubscribeInner();
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return SwitchSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":184,"../util/subscribeToResult":273}],247:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return this.lift(new SwitchMapOperator(project, resultSelector));
}
exports.switchMap = switchMap;
var SwitchMapOperator = function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":184,"../util/subscribeToResult":273}],248:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');
var EmptyObservable_1 = require('../observable/EmptyObservable');
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    } else {
        return this.lift(new TakeOperator(count));
    }
}
exports.take = take;
var TakeOperator = function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":188,"../observable/EmptyObservable":218,"../util/ArgumentOutOfRangeError":260}],249:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return this.lift(new TakeUntilOperator(notifier));
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":184,"../util/subscribeToResult":273}],250:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var async_1 = require('../scheduler/async');
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * <img src="./img/throttleTime.png" width="100%">
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {number} duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the sampling.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */
function throttleTime(duration, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    return this.lift(new ThrottleTimeOperator(duration, scheduler));
}
exports.throttleTime = throttleTime;
var ThrottleTimeOperator = function () {
    function ThrottleTimeOperator(duration, scheduler) {
        this.duration = duration;
        this.scheduler = scheduler;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler));
    };
    return ThrottleTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleTimeSubscriber = function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler) {
        _super.call(this, destination);
        this.duration = duration;
        this.scheduler = scheduler;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (!this.throttled) {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            this.destination.next(value);
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber);
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}


},{"../Subscriber":188,"../scheduler/async":256}],251:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var project;
    if (typeof args[args.length - 1] === 'function') {
        project = args.pop();
    }
    var observables = args;
    return this.lift(new WithLatestFromOperator(observables, project));
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WithLatestFromSubscriber = function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        _super.call(this, destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        var len = observables.length;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
        }
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            } else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":184,"../util/subscribeToResult":273}],252:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = require('../observable/ArrayObservable');
var isArray_1 = require('../util/isArray');
var Subscriber_1 = require('../Subscriber');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
var iterator_1 = require('../symbol/iterator');
/* tslint:enable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
function zipProto() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));
}
exports.zipProto = zipProto;
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the latest parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * @example <caption>Combine age and name from different sources</caption>
 *
 * let age$ = Observable.of<number>(27, 25, 29);
 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
 * let isDev$ = Observable.of<boolean>(true, true, false);
 *
 * Observable
 *     .zip(age$,
 *          name$,
 *          isDev$,
 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
 *     .subscribe(x => console.log(x));
 *
 * // outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 *
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */
function zipStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}
exports.zipStatic = zipStatic;
var ZipOperator = function () {
    function ZipOperator(project) {
        this.project = project;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.project));
    };
    return ZipOperator;
}();
exports.ZipOperator = ZipOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = typeof project === 'function' ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[iterator_1.$$iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.$$iterator]()));
        } else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                this.add(iterator.subscribe(iterator, i));
            } else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        } else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber);
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}();
var StaticArrayIterator = function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.$$iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator_1.$$iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        } else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        } else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":184,"../Subscriber":188,"../observable/ArrayObservable":215,"../symbol/iterator":257,"../util/isArray":264,"../util/subscribeToResult":273}],253:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('../Subscription');
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription_1.Subscription);
exports.Action = Action;


},{"../Subscription":189}],254:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Action_1 = require('./Action');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        } else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        } catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.delay = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
    };
    return AsyncAction;
}(Action_1.Action);
exports.AsyncAction = AsyncAction;


},{"../util/root":272,"./Action":253}],255:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = require('../Scheduler');
var AsyncScheduler = function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler);
exports.AsyncScheduler = AsyncScheduler;


},{"../Scheduler":185}],256:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"./AsyncAction":254,"./AsyncScheduler":255,"dup":155}],257:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function symbolIteratorPonyfill(root) {
    var _Symbol = root.Symbol;
    if (typeof _Symbol === 'function') {
        if (!_Symbol.iterator) {
            _Symbol.iterator = _Symbol('iterator polyfill');
        }
        return _Symbol.iterator;
    } else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.$$iterator = symbolIteratorPonyfill(root_1.root);


},{"../util/root":272}],258:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function getSymbolObservable(context) {
    var $$observable;
    var _Symbol = context.Symbol;
    if (typeof _Symbol === 'function') {
        if (_Symbol.observable) {
            $$observable = _Symbol.observable;
        } else {
            $$observable = _Symbol('observable');
            _Symbol.observable = $$observable;
        }
    } else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.$$observable = getSymbolObservable(root_1.root);


},{"../util/root":272}],259:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
var _Symbol = root_1.root.Symbol;
exports.$$rxSubscriber = typeof _Symbol === 'function' && typeof _Symbol.for === 'function' ? _Symbol.for('rxSubscriber') : '@@rxSubscriber';


},{"../util/root":272}],260:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = function (_super) {
    __extends(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var err = _super.call(this, 'argument out of range');
        this.name = err.name = 'ArgumentOutOfRangeError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ArgumentOutOfRangeError;
}(Error);
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;


},{}],261:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error);
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;


},{}],262:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) {
            return i + 1 + ") " + err.toString();
        }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error);
exports.UnsubscriptionError = UnsubscriptionError;


},{}],263:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"dup":161}],264:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"dup":162}],265:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"dup":163}],266:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"dup":164}],267:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"dup":165}],268:[function(require,module,exports){
arguments[4][166][0].apply(exports,arguments)
},{"../util/isArray":264,"dup":166}],269:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isObject(x) {
    return x != null && (typeof x === "undefined" ? "undefined" : _typeof(x)) === 'object';
}
exports.isObject = isObject;


},{}],270:[function(require,module,exports){
arguments[4][168][0].apply(exports,arguments)
},{"dup":168}],271:[function(require,module,exports){
arguments[4][169][0].apply(exports,arguments)
},{"dup":169}],272:[function(require,module,exports){
(function (global){
"use strict";
/**
 * window: browser in DOM main thread
 * self: browser in WebWorker
 * global: Node.js/other
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.root = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object' && window.window === window && window || (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self.self === self && self || (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global.global === global && global;
if (!exports.root) {
    throw new Error('RxJS could not find any global context (window, self, global)');
}


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],273:[function(require,module,exports){
"use strict";

var root_1 = require('./root');
var isArrayLike_1 = require('./isArrayLike');
var isPromise_1 = require('./isPromise');
var isObject_1 = require('./isObject');
var Observable_1 = require('../Observable');
var iterator_1 = require('../symbol/iterator');
var InnerSubscriber_1 = require('../InnerSubscriber');
var observable_1 = require('../symbol/observable');
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        } else {
            return result.subscribe(destination);
        }
    } else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    } else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) {
            return destination.error(err);
        }).then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () {
                throw err;
            });
        });
        return destination;
    } else if (result && typeof result[iterator_1.$$iterator] === 'function') {
        var iterator = result[iterator_1.$$iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    } else if (result && typeof result[observable_1.$$observable] === 'function') {
        var obs = result[observable_1.$$observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        } else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    } else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;


},{"../InnerSubscriber":180,"../Observable":182,"../symbol/iterator":257,"../symbol/observable":258,"./isArrayLike":265,"./isObject":269,"./isPromise":270,"./root":272}],274:[function(require,module,exports){
"use strict";

var Subscriber_1 = require('../Subscriber');
var rxSubscriber_1 = require('../symbol/rxSubscriber');
var Observer_1 = require('../Observer');
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;


},{"../Observer":183,"../Subscriber":188,"../symbol/rxSubscriber":259}],275:[function(require,module,exports){
arguments[4][173][0].apply(exports,arguments)
},{"./errorObject":263,"dup":173}],276:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isExternal = isExternal;
exports.stripHash = stripHash;
exports.isHash = isHash;
exports.matches = matches;
exports.querySelectorInv = querySelectorInv;
exports.shouldLoadAnchor = shouldLoadAnchor;
exports.getScrollHeight = getScrollHeight;
exports.getScrollLeft = getScrollLeft;
exports.getScrollTop = getScrollTop;
exports.expInterval = expInterval;
exports.fragmentFromString = fragmentFromString;

var _Observable = require('rxjs/Observable');

/**
 * Checks to see if the url is external
 *
 * @param   {string}    url - url being evaluated
 * @see     http://stackoverflow.com/questions/6238351/fastest-way-to-detect-external-urls
 */
function isExternal(url) {
  var match = url.match(/^([^:\/?#]+:)?(?:\/\/([^\/?#]*))?([^?#]+)?(\?[^#]*)?(#.*)?/); // eslint-disable-line no-useless-escape

  if (typeof match[1] === 'string' && match[1].length > 0 && match[1].toLowerCase() !== window.location.protocol) {
    return true;
  }

  var port = { http: 80, https: 443 }[window.location.protocol];

  if (typeof match[2] === 'string' && match[2].length > 0 && match[2].replace(new RegExp(':(' + port + ')?$'), '') !== window.location.host) {
    return true;
  }

  return false;
}

/**
 * Strips the hash from a url and returns the new href
 *
 * @param   {string}    href - url being evaluated
 */
// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

function stripHash(href) {
  return href.replace(/#.*/, '');
}

/**
 * Checks to see if the url is an internal hash
 *
 * @param   {string}    href - url being evaluated
 * @param   {string}    prev - previous url (optional)
 */
function isHash(href, prev) {
  var p = prev || window.location.href;

  var hasHash = href.indexOf('#') > -1;
  var samePath = stripHash(href) === stripHash(p);

  return hasHash && samePath;
}

function matches(el, selector) {
  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
  // if (!matches.memo) {
  //   matches.memo =
  //     el.matches ||
  //     el.matchesSelector ||
  //     el.msMatchesSelector ||
  //     el.mozMatchesSelector ||
  //     el.webkitMatchesSelector ||
  //     el.oMatchesSelector;
  // }
  // return matches.memo.call(el, selector);
}

function querySelectorInv(el, selector) {
  var curr = el;
  while (curr !== document && curr !== document.documentElement) {
    if (matches(curr, selector)) return curr;
    curr = curr.parentNode;
  }
  return null;
}

/**
 * Checks to see if we should be loading this URL
 *
 * @param   {string}    url - url being evaluated
 * @param   {string}    blacklist - jquery selector
 */
function shouldLoadAnchor(anchor, blacklist, hrefRegex) {
  var href = anchor.href;
  // URL will only be loaded if it's not an external link, hash, or
  // blacklisted
  return !isExternal(href) && !isHash(href) && !matches(anchor, blacklist) && anchor.target === '' && (hrefRegex === null || href.search(hrefRegex) !== -1);
}

function getScrollHeight() {
  var h = document.documentElement;
  var b = document.body;
  var sh = 'scrollHeight';
  return h[sh] || b[sh];
}

function getScrollLeft() {
  return window.pageXOffset || document.body.scrollLeft;
}

function getScrollTop() {
  return window.pageYOffset || document.body.scrollTop;
}

function expInterval(init, exp) {
  return _Observable.Observable.create(function (observer) {
    var n = init;
    var id = void 0;

    function next() {
      observer.next(n);
      n *= exp;
      id = setTimeout(next, n);
    }

    id = setTimeout(next, n);

    return function () {
      clearTimeout(id);
    };
  });
}

function fragmentFromString(strHTML) {
  return document.createRange().createContextualFragment(strHTML);
}

},{"rxjs/Observable":182}],277:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;_e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }return _arr;
  }return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _Observable = require('rxjs/Observable');

var _Subject = require('rxjs/Subject');

require('rxjs/add/observable/defer');

require('rxjs/add/observable/fromEvent');

require('rxjs/add/observable/merge');

require('rxjs/add/observable/of');

require('rxjs/add/observable/throw');

require('rxjs/add/observable/timer');

require('rxjs/add/observable/dom/ajax');

require('rxjs/add/operator/catch');

require('rxjs/add/operator/debounceTime');

require('rxjs/add/operator/delay');

require('rxjs/add/operator/distinctUntilKeyChanged');

require('rxjs/add/operator/do');

require('rxjs/add/operator/filter');

require('rxjs/add/operator/map');

require('rxjs/add/operator/mergeAll');

require('rxjs/add/operator/retryWhen');

require('rxjs/add/operator/share');

require('rxjs/add/operator/startWith');

require('rxjs/add/operator/switch');

require('rxjs/add/operator/switchMap');

require('rxjs/add/operator/take');

require('rxjs/add/operator/takeUntil');

require('rxjs/add/operator/throttleTime');

require('rxjs/add/operator/withLatestFrom');

require('rxjs/add/operator/zip');

var _componentCore2 = require('y-component/src/component-core');

var _componentCore3 = _interopRequireDefault(_componentCore2);

var _common = require('../common');

var _kind = require('./kind');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

/*
eslint-disable
import/no-extraneous-dependencies,
import/no-unresolved,
import/extensions,
no-console
*/

// const JS_FEATURES = [
//   'fn/array/for-each',
//   'fn/function/bind',
//   'fn/number/constructor',
//   'fn/object/assign',
//   'fn/object/define-property',
//   'fn/object/keys',
// ];
//
// const MODERNIZR_TESTS = [
//   'customevent',
//   'documentfragment',
//   'eventlistener',
//   'history',
//   'requestanimationframe',
//   'queryselector',
// ];

// ~ mixin pushStateCore with componentCore { ...
exports.default = function (C) {
  return function (_componentCore) {
    _inherits(_class, _componentCore);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'getComponentName',

      // @override
      value: function getComponentName() {
        return 'y-push-state';
      }

      // @override

    }, {
      key: 'defaults',
      value: function defaults() {
        return {
          replaceIds: [],
          linkSelector: 'a[href]',
          scrollRestoration: false,
          hrefRegex: null,
          blacklist: '.no-push-state',
          duration: 0,
          noPopDuration: true
        };
      }

      // @override

    }, {
      key: 'sideEffects',
      value: function sideEffects() {
        return {};
      }

      // @override

    }, {
      key: 'startHistory',
      value: function startHistory() {
        this.checkPreCondition();
        this.setupScrollRestoration();
        this.cacheTitleElement();
        this.setupObservables();
        return this;
      }
    }, {
      key: 'checkPreCondition',
      value: function checkPreCondition() {
        if (this.replaceIds.length === 0) {
          var id = this.el.id;
          if (id) {
            console.warn('No replace ids provided. Will replace entire content of #' + id);
          } else {
            throw Error('No replace ids provided nor does this component have and id');
          }
        }
      }
    }, {
      key: 'setupScrollRestoration',
      value: function setupScrollRestoration() {
        if ('scrollRestoration' in history) {
          history.scrollRestoration = this.scrollRestoration ? 'manual' : 'auto';
        }

        this.setScrollPosition();
        window.addEventListener('beforeunload', this.updateHistoryState.bind(this));
      }
    }, {
      key: 'cacheTitleElement',
      value: function cacheTitleElement() {
        this.titleElement = document.querySelector('title') || {};
      }
    }, {
      key: 'bindPushEvents',
      value: function bindPushEvents(link$) {
        var _this2 = this;

        return this.fromEvents(link$, 'click').map(function (event) {
          return new _kind.Push(event);
        }).filter(function (kind) {
          return _this2.isPageChangeEvent(kind);
        }).do(function (_ref) {
          var event = _ref.event;

          _this2.updateHistoryState();
          event.preventDefault();
        });
      }
    }, {
      key: 'bindHintEvents',
      value: function bindHintEvents(link$) {
        var _this3 = this;

        return _Observable.Observable.merge(this.fromEvents(link$, 'mouseenter'), this.fromEvents(link$, 'touchstart'), this.fromEvents(link$, 'focus')).map(function (event) {
          return new _kind.Hint(event);
        }).filter(function (kind) {
          return _this3.isPageChangeAnchor(kind);
        });
      }
    }, {
      key: 'bindPopstateEvent',
      value: function bindPopstateEvent() {
        return _Observable.Observable.fromEvent(window, 'popstate').map(function (event) {
          return new _kind.Pop(event);
        }).filter(function () {
          return window.history.state != null;
        });
      }
    }, {
      key: 'linkObservable',
      value: function linkObservable() {
        return _Observable.Observable.of(this.el.querySelectorAll(this.linkSelector));
      }
    }, {
      key: 'fromEvents',
      value: function fromEvents(link$, event) {
        return link$.map(function (link) {
          return _Observable.Observable.fromEvent(link, event);
        }).mergeAll();
      }
    }, {
      key: 'fetchPage',
      value: function fetchPage(kind) {
        var _this4 = this;

        return _Observable.Observable.ajax(this.hrefToAjax(kind)).map(function (_ref2) {
          var response = _ref2.response;
          return Object.assign(kind, { response: response });
        }).catch(function (error) {
          return _this4.recoverIfResponse(kind, error);
        }).retryWhen(function () {
          return _Observable.Observable.merge(_Observable.Observable.fromEvent(window, 'online'), (0, _common.expInterval)(1000, 2)).do(_this4.onRetry.bind(_this4, kind));
        });
      }
    }, {
      key: 'hrefToAjax',
      value: function hrefToAjax(_ref3) {
        var href = _ref3.href;

        return {
          method: 'GET',
          url: href,
          responseType: 'text'
        };
      }
    }, {
      key: 'recoverIfResponse',
      value: function recoverIfResponse(kind, error) {
        var status = error.status,
            xhr = error.xhr;

        if (xhr && status && status > 400) {
          // Recover with error page returned from server.
          // NOTE: This assumes error page contains the same ids as the other pages...
          return _Observable.Observable.of(Object.assign(kind, { response: xhr.response }));
        }

        // else
        this.onError(Object.assign(kind, error));
        return _Observable.Observable.throw(error);
      }
    }, {
      key: 'setupObservables',
      value: function setupObservables() {
        var _this5 = this;

        // See `renewEventListeners`
        // TODO: Possible without subjects?
        this.push$$ = new _Subject.Subject();
        this.hint$$ = new _Subject.Subject();

        var push$ = this.push$$.switch()
        // TODO: This prevents a whole class of concurrency bugs,
        // This is not an issue for fast animations (and prevents accidential double tapping)
        // Ideally the UI is fully repsonsive at all times though..
        // Note that spamming the back/forward button is still possible (only affects `push$`)
        .throttleTime(this.duration + 100);

        var pop$ = this.bindPopstateEvent();

        // Definitive page change (i.e. either push or pop event)
        this.page$ = _Observable.Observable.merge(push$, pop$).share();

        // We don't want to prefetch (i.e. use bandwidth) for a _probabilistic_ page load,
        // while a _definitive_ page load is going on => `pauser$` stream.
        // Needs to be deferred b/c of "cyclical" dependency.
        var pauser$ = _Observable.Observable.defer(function () {
          return _Observable.Observable.merge(
          // A page change event means we want to pause prefetching
          _this5.page$.map(function () {
            return true;
          }),
          // A render complete event means we want to resume prefetching
          _this5.render$.map(function () {
            return false;
          }))
          // Start with prefetching
          .startWith(false);
        });

        // The stream of hint (prefetch) events, possibly paused.
        // Dream syntax (not supported, yet): `this.hint$$.switch().pauseable(pauser$)`
        this.hint$ = this.hint$$.switch().withLatestFrom(pauser$).filter(function (_ref4) {
          var _ref5 = _slicedToArray(_ref4, 2),
              paused = _ref5[1];

          return paused === false;
        }).map(function (_ref6) {
          var _ref7 = _slicedToArray(_ref6, 1),
              x = _ref7[0];

          return x;
        });

        // The stream of (pre-)fetch events.
        // Includes definitive page change events do deal with unexpected page changes.
        this.prefetch$ = _Observable.Observable.merge(this.hint$, this.page$).distinctUntilKeyChanged('href') // Don't abort a request if the user "jiggles" over a link
        .switchMap(function (kind) {
          return _this5.fetchPage(kind);
        }).catch(function (err, caught) {
          return caught;
        }).startWith({}) // Start with some value so `withLatestFrom` below doesn't "block"
        .share();

        this.render$ = this.page$.do(this.onStart.bind(this)).withLatestFrom(this.prefetch$).switchMap(this.getResponse.bind(this)).map(this.responseToContent.bind(this)).do(this.onReady.bind(this)).do(this.updateDOM.bind(this)).do(this.resetScrollPostion.bind(this)).do(this.onAfter.bind(this)).catch(function (error, caught) {
          _this5.onError(error);
          return caught;
        })
        // `share`ing the stream between the subscription below and `pauser$`.
        .share();

        this.render$
        // Renewing event listeners after DOM update/layout/painting is complete
        // HACK: don't use time, use outside observable instead?
        .debounceTime(this.duration).do(this.renewEventListeners.bind(this)).subscribe();

        // fire `progress` event when fetching takes longer than `this.duration`.
        this.page$
        // HACK: add some time, jtbs
        .switchMap(function () {
          return _Observable.Observable.timer(_this5.duration + 200).takeUntil(_this5.render$);
        }).subscribe(this.onProgress.bind(this));

        // Start pulling values
        this.render$.subscribe();

        // Push streams into `push$$` and `hint$$`
        this.renewEventListeners();
      }
    }, {
      key: 'getResponse',
      value: function getResponse(_ref8) {
        var _ref9 = _slicedToArray(_ref8, 2),
            kind = _ref9[0],
            prefetch = _ref9[1];

        var res = void 0;

        // Prefetch already complete, use result
        if (kind.href === prefetch.href) {
          res = _Observable.Observable.of(Object.assign(kind, { response: prefetch.response }));

          if (kind instanceof _kind.Push || !this.noPopDuration) {
            // HACK: add some extra time to prevent 'flickering'
            // ideally, we'd like to take an animation observable as input instead
            res = res.delay(this.duration + 100);
          }
          // Prefetch in progress, use next result (this is why `prefetch$` had to be `share`d)
        } else {
          res = this.prefetch$.take(1).map(function (fetch) {
            return Object.assign(kind, { response: fetch.response });
          });

          if (kind instanceof _kind.Push || !this.noPopDuration) {
            // HACK: add some extra time to prevent 'flickering'
            // ideally, we'd like to take an animation observable as input instead
            res = res.zip(_Observable.Observable.timer(this.duration + 100), function (x) {
              return x;
            });
          }
        }

        return res;
      }
    }, {
      key: 'onStart',
      value: function onStart(sponge) {
        var href = sponge.href;

        if (sponge instanceof _kind.Push) {
          window.history.pushState({ id: this.componentName }, '', href);
        }

        this.fireEvent('start', { detail: sponge });
      }
    }, {
      key: 'onProgress',
      value: function onProgress(sponge) {
        this.fireEvent('progress', { detail: sponge });
      }
    }, {
      key: 'responseToContent',
      value: function responseToContent(sponge) {
        var response = sponge.response;

        var documentFragment = (0, _common.fragmentFromString)(response);
        var title = this.getTitleFromDocumentFragment(documentFragment);
        var content = this.getContentFromDocumentFragment(documentFragment);

        return Object.assign(sponge, { title: title, content: content });
      }
    }, {
      key: 'onReady',
      value: function onReady(sponge) {
        this.fireEvent('ready', { detail: sponge });
      }
    }, {
      key: 'updateDOM',
      value: function updateDOM(sponge) {
        try {
          var href = sponge.href,
              title = sponge.title,
              content = sponge.content;

          if (sponge instanceof _kind.Push) {
            window.history.replaceState({ id: this.componentName }, title, href);
          }

          this.titleElement.textContent = title;
          this.replaceContent(content);
        } catch (error) {
          throw Object.assign(sponge, { error: error });
        }
      }
    }, {
      key: 'onAfter',
      value: function onAfter(sponge) {
        this.fireEvent('after', { detail: sponge });
      }
    }, {
      key: 'renewEventListeners',
      value: function renewEventListeners() {
        var link$ = this.linkObservable();
        this.push$$.next(this.bindPushEvents(link$));
        this.hint$$.next(this.bindHintEvents(link$));
      }
    }, {
      key: 'onError',
      value: function onError(err) {
        this.el.style.willChange = '';
        this.fireEvent('error', { detail: err });
      }
    }, {
      key: 'onRetry',
      value: function onRetry(kind) {
        this.fireEvent('retry', { detail: kind });
      }
    }, {
      key: 'isPageChangeEvent',
      value: function isPageChangeEvent(kind) {
        var event = kind.event;

        return !event.metaKey && !event.ctrlKey && this.isPageChangeAnchor(kind);
      }
    }, {
      key: 'isPageChangeAnchor',
      value: function isPageChangeAnchor(_ref10) {
        var anchor = _ref10.event.currentTarget;

        return anchor != null && (0, _common.shouldLoadAnchor)(anchor, this.blacklist, this.hrefRegex);
      }
    }, {
      key: 'getTitleFromDocumentFragment',
      value: function getTitleFromDocumentFragment(documentFragment) {
        return (documentFragment.querySelector('title') || {}).textContent;
      }
    }, {
      key: 'getContentFromDocumentFragment',
      value: function getContentFromDocumentFragment(documentFragment) {
        if (this.replaceIds.length > 0) {
          return this.replaceIds.map(function (id) {
            return documentFragment.querySelector('#' + id);
          });
        }

        return documentFragment.querySelector('#' + this.el.id);
      }
    }, {
      key: 'replaceContent',
      value: function replaceContent(content) {
        if (this.replaceIds.length > 0) {
          this.replaceContentByIds(content);
        } else {
          this.replaceContentWholesale(content);
        }
      }
    }, {
      key: 'replaceContentByIds',
      value: function replaceContentByIds(elements) {
        var oldElements = this.replaceIds.map(function (id) {
          return document.getElementById(id);
        });

        Array.prototype.forEach.call(oldElements, function (oldElement) {
          oldElement.parentNode.replaceChild(elements.shift(), oldElement);
        });
      }
    }, {
      key: 'replaceContentWholesale',
      value: function replaceContentWholesale(content) {
        this.el.innerHTML = content.innerHTML;
      }
    }, {
      key: 'saveScrollPosition',
      value: function saveScrollPosition(state) {
        return Object.assign(state, {
          scrollTop: (0, _common.getScrollTop)(),
          scrollHeight: (0, _common.getScrollHeight)()
        });
      }
    }, {
      key: 'updateHistoryState',
      value: function updateHistoryState() {
        var state = history.state || { id: this.componentName };
        state = this.scrollRestoration ? this.saveScrollPosition(state) : state;
        history.replaceState(state, document.title, window.location.href);
      }
    }, {
      key: 'setScrollPosition',
      value: function setScrollPosition() {
        var state = history.state || {};
        document.body.style.minHeight = (state.scrollHeight || 0) + 'px';
        if (state.scrollTop != null) window.scroll(window.pageXOffset, state.scrollTop);
        document.body.style.minHeight = '';
      }
    }, {
      key: 'resetScrollPostion',
      value: function resetScrollPostion(sponge) {
        if (this.scrollRestoration) {
          if (sponge instanceof _kind.Pop) {
            this.setScrollPosition();
          }
        }
      }
    }]);

    return _class;
  }((0, _componentCore3.default)(C));
};

},{"../common":276,"./kind":278,"rxjs/Observable":182,"rxjs/Subject":186,"rxjs/add/observable/defer":190,"rxjs/add/observable/dom/ajax":191,"rxjs/add/observable/fromEvent":192,"rxjs/add/observable/merge":193,"rxjs/add/observable/of":194,"rxjs/add/observable/throw":195,"rxjs/add/observable/timer":196,"rxjs/add/operator/catch":197,"rxjs/add/operator/debounceTime":198,"rxjs/add/operator/delay":199,"rxjs/add/operator/distinctUntilKeyChanged":200,"rxjs/add/operator/do":201,"rxjs/add/operator/filter":202,"rxjs/add/operator/map":203,"rxjs/add/operator/mergeAll":204,"rxjs/add/operator/retryWhen":205,"rxjs/add/operator/share":206,"rxjs/add/operator/startWith":207,"rxjs/add/operator/switch":208,"rxjs/add/operator/switchMap":209,"rxjs/add/operator/take":210,"rxjs/add/operator/takeUntil":211,"rxjs/add/operator/throttleTime":212,"rxjs/add/operator/withLatestFrom":213,"rxjs/add/operator/zip":214,"y-component/src/component-core":176}],278:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

// Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

var Kind = exports.Kind = function Kind(event) {
  _classCallCheck(this, Kind);

  this.event = event;
};

var Push = exports.Push = function (_Kind) {
  _inherits(Push, _Kind);

  function Push(event) {
    _classCallCheck(this, Push);

    var _this = _possibleConstructorReturn(this, (Push.__proto__ || Object.getPrototypeOf(Push)).call(this, event));

    _this.href = event.currentTarget.href;
    return _this;
  }

  _createClass(Push, [{
    key: 'type',
    get: function get() {
      return 'push';
    }
  }]);

  return Push;
}(Kind);

var Hint = exports.Hint = function (_Kind2) {
  _inherits(Hint, _Kind2);

  function Hint(event) {
    _classCallCheck(this, Hint);

    var _this2 = _possibleConstructorReturn(this, (Hint.__proto__ || Object.getPrototypeOf(Hint)).call(this, event));

    _this2.href = event.currentTarget.href;
    return _this2;
  }

  _createClass(Hint, [{
    key: 'type',
    get: function get() {
      return 'hint';
    }
  }]);

  return Hint;
}(Kind);

var Pop = exports.Pop = function (_Kind3) {
  _inherits(Pop, _Kind3);

  function Pop(event) {
    _classCallCheck(this, Pop);

    var _this3 = _possibleConstructorReturn(this, (Pop.__proto__ || Object.getPrototypeOf(Pop)).call(this, event));

    _this3.href = window.location.href;
    return _this3;
  }

  _createClass(Pop, [{
    key: 'type',
    get: function get() {
      return 'pop';
    }
  }]);

  return Pop;
}(Kind);

},{}],279:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} // Copyright (c) 2017 Florian Klampfer
// Licensed under MIT

var PushState = function (_pushStateCore) {
  _inherits(PushState, _pushStateCore);

  function PushState(el, props) {
    _classCallCheck(this, PushState);

    var _this = _possibleConstructorReturn(this, (PushState.__proto__ || Object.getPrototypeOf(PushState)).call(this));

    _this.setupComponent(el, props);
    return _this;
  }

  // @override


  _createClass(PushState, [{
    key: 'setupDOM',
    value: function setupDOM(el) {
      if (!el) throw Error('No element provided');
      return el;
    }
  }]);

  return PushState;
}((0, _core2.default)());

exports.default = PushState;

},{"../core":277}]},{},[9])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJfanMvbGliL21vZGVybml6ci5qcyIsIl9qcy9saWIvdmVyc2lvbi5qcyIsIl9qcy9zcmMvY29tbW9uLmpzIiwiX2pzL3NyYy9jcm9zcy1mYWRlci5qcyIsIl9qcy9zcmMvZHJhd2VyLmpzIiwiX2pzL3NyYy9mbGlwL2ZsaXAuanMiLCJfanMvc3JjL2ZsaXAvcHJvamVjdC5qcyIsIl9qcy9zcmMvZmxpcC90aXRsZS5qcyIsIl9qcy9zcmMvaW5kZXguanMiLCJfanMvc3JjL2thdGV4LmpzIiwiX2pzL3NyYy9wdXNoLXN0YXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yLWNvbnZlcnQvY29udmVyc2lvbnMuanMiLCJub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb2xvci1jb252ZXJ0L3JvdXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yLW5hbWUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29sb3Itc3RyaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvbG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vYXJyYXkvZmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL2FycmF5L2Zvci1lYWNoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vYXJyYXkvcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vZnVuY3Rpb24vYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL251bWJlci9jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vb2JqZWN0L2tleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaWN0LW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2VsZW0tZGF0YXNldC9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWFycmF5aXNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L2thdGV4LmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9MZXhlci5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvTWFjcm9FeHBhbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvT3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvUGFyc2VFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvUGFyc2VyLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9TZXR0aW5ncy5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvU3R5bGUuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2J1aWxkQ29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9idWlsZEhUTUwuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2J1aWxkTWF0aE1MLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9idWlsZFRyZWUuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2RlbGltaXRlci5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvZG9tVHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvZW52aXJvbm1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9mb250TWV0cmljcy5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvZm9udE1ldHJpY3NEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9mdW5jdGlvbnMuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL21hdGhNTFRyZWUuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL3BhcnNlRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvcGFyc2VUcmVlLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9zeW1ib2xzLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy91bmljb2RlUmVnZXhlcy5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvbWF0Y2gtYXQvbGliL21hdGNoQXQuanMiLCJub2RlX21vZHVsZXMvcnhqcy9Jbm5lclN1YnNjcmliZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy9PYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvT2JzZXJ2ZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy9PdXRlclN1YnNjcmliZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy9TY2hlZHVsZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy9TdWJqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvU3ViamVjdFN1YnNjcmlwdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL1N1YnNjcmliZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy9TdWJzY3JpcHRpb24uanMiLCJub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0Zyb21FdmVudE9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL1NjYWxhck9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL1RpbWVyT2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvZW1wdHkuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvb2YuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL3RpbWVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvY2F0Y2guanMiLCJub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9jb25jYXQuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9kZWJvdW5jZVRpbWUuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9kby5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2V4aGF1c3RNYXAuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9maW5hbGx5LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWFwLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWVyZ2VBbGwuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9tZXJnZU1hcC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL211bHRpY2FzdC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3BhaXJ3aXNlLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3Ivc2hhcmUuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9zdGFydFdpdGguanMiLCJub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9zd2l0Y2hNYXAuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci90YWtlVW50aWwuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci96aXAuanMiLCJub2RlX21vZHVsZXMvcnhqcy9zY2hlZHVsZXIvQWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL0FzeW5jQWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL0FzeW5jU2NoZWR1bGVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL2FzeW5jLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvc3ltYm9sL29ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvcnhqcy9zeW1ib2wvcnhTdWJzY3JpYmVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvZXJyb3JPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzQXJyYXkuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzQXJyYXlMaWtlLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc0RhdGUuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzTnVtZXJpYy5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNPYmplY3QuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzUHJvbWlzZS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNTY2hlZHVsZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL3Jvb3QuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL3N1YnNjcmliZVRvUmVzdWx0LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC90b1N1YnNjcmliZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL3RyeUNhdGNoLmpzIiwibm9kZV9tb2R1bGVzL3NpbXBsZS1zd2l6emxlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYi1hbmltYXRpb25zLWpzL3dlYi1hbmltYXRpb25zLm1pbi5qcyIsIi4uLy5ucG0tcGFja2FnZXMvbGliL25vZGVfbW9kdWxlcy95LWNvbXBvbmVudC9zcmMvY29tcG9uZW50LWNvcmUuanMiLCIuLi95LWRyYXdlci9zcmMvY29tbW9uLmpzIiwiLi4veS1kcmF3ZXIvc3JjL2NvcmUvaW5kZXguanMiLCIuLi95LWRyYXdlci9zcmMvdmFuaWxsYS9pbmRleC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9Jbm5lclN1YnNjcmliZXIuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvTm90aWZpY2F0aW9uLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL09ic2VydmFibGUuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvT2JzZXJ2ZXIuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvT3V0ZXJTdWJzY3JpYmVyLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL1N1YmplY3QuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvU3ViamVjdFN1YnNjcmlwdGlvbi5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9TdWJzY3JpYmVyLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL1N1YnNjcmlwdGlvbi5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS9kZWZlci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS9kb20vYWpheC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tRXZlbnQuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvbWVyZ2UuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvb2YuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvdGhyb3cuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvdGltZXIuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2NhdGNoLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9kZWJvdW5jZVRpbWUuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2RlbGF5LmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvZG8uanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2ZpbHRlci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvbWFwLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9tZXJnZUFsbC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvcmV0cnlXaGVuLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9zaGFyZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3Ivc3RhcnRXaXRoLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9zd2l0Y2guanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaE1hcC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvdGFrZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvdGFrZVVudGlsLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci90aHJvdHRsZVRpbWUuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3dpdGhMYXRlc3RGcm9tLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci96aXAuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9Db25uZWN0YWJsZU9ic2VydmFibGUuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9EZWZlck9ic2VydmFibGUuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9FcnJvck9ic2VydmFibGUuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9Gcm9tRXZlbnRPYnNlcnZhYmxlLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvU2NhbGFyT2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL1RpbWVyT2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL2RlZmVyLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvZG9tL0FqYXhPYnNlcnZhYmxlLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvZG9tL2FqYXguanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9tZXJnZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL3Rocm93LmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2NhdGNoLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2RlYm91bmNlVGltZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9kZWxheS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9kaXN0aW5jdFVudGlsQ2hhbmdlZC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9kby5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9maWx0ZXIuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWFwLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL21lcmdlLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL21lcmdlQWxsLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3JldHJ5V2hlbi5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9zd2l0Y2guanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3Ivc3dpdGNoTWFwLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3Rha2UuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvdGFrZVVudGlsLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3Rocm90dGxlVGltZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci93aXRoTGF0ZXN0RnJvbS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci96aXAuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL0FjdGlvbi5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9zY2hlZHVsZXIvQXN5bmNBY3Rpb24uanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL0FzeW5jU2NoZWR1bGVyLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9zeW1ib2wvb2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9zeW1ib2wvcnhTdWJzY3JpYmVyLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc09iamVjdC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy91dGlsL3Jvb3QuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy91dGlsL3RvU3Vic2NyaWJlci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9zcmMvY29tbW9uLmpzIiwiLi4veS1wdXNoLXN0YXRlL3NyYy9jb3JlL2luZGV4LmpzIiwiLi4veS1wdXNoLXN0YXRlL3NyYy9jb3JlL2tpbmQuanMiLCIuLi95LXB1c2gtc3RhdGUvc3JjL3ZhbmlsbGEvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBOztBQUVBLENBQUMsVUFBUyxDQUFULEVBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZTtBQUFDLFdBQVMsQ0FBVCxDQUFXLENBQVgsRUFBYSxDQUFiLEVBQWU7QUFBQyxXQUFPLE9BQU8sQ0FBUCxLQUFXLENBQWxCO0FBQW9CLFlBQVMsQ0FBVCxHQUFZO0FBQUMsUUFBSSxDQUFKLEVBQU0sQ0FBTixFQUFRLENBQVIsRUFBVSxDQUFWLEVBQVksQ0FBWixFQUFjLENBQWQsRUFBZ0IsQ0FBaEIsQ0FBa0IsS0FBSSxJQUFJLENBQVIsSUFBYSxDQUFiLEVBQWUsSUFBRyxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSCxFQUF1QjtBQUFDLFVBQUcsSUFBRSxFQUFG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LGNBQVUsUUFIYTtBQUl2QixtQkFBZSxRQUpRO0FBS3ZCLHVCQUFtQixDQUFDO0FBTEcsR0FBekIsRUFNRyxZQU5IO0FBT0Q7OztBQ3pPRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3MUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBOztBQ0FBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDajFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ppREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3h0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQsRUFBaUIsSUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUMxQyxhQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxjQUFSLENBQW5CO0FBQ0E7Ozs7O0FBS0EsSUFBSSxrQkFBbUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3JDLGNBQVUsZUFBVixFQUEyQixNQUEzQjtBQUNBLGFBQVMsZUFBVCxDQUF5QixNQUF6QixFQUFpQyxVQUFqQyxFQUE2QyxVQUE3QyxFQUF5RDtBQUNyRCxlQUFPLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLGFBQUssVUFBTCxHQUFrQixVQUFsQjtBQUNBLGFBQUssVUFBTCxHQUFrQixVQUFsQjtBQUNBLGFBQUssS0FBTCxHQUFhLENBQWI7QUFDSDtBQUNELG9CQUFnQixTQUFoQixDQUEwQixLQUExQixHQUFrQyxVQUFVLEtBQVYsRUFBaUI7QUFDL0MsYUFBSyxNQUFMLENBQVksVUFBWixDQUF1QixLQUFLLFVBQTVCLEVBQXdDLEtBQXhDLEVBQStDLEtBQUssVUFBcEQsRUFBZ0UsS0FBSyxLQUFMLEVBQWhFLEVBQThFLElBQTlFO0FBQ0gsS0FGRDtBQUdBLG9CQUFnQixTQUFoQixDQUEwQixNQUExQixHQUFtQyxVQUFVLEtBQVYsRUFBaUI7QUFDaEQsYUFBSyxNQUFMLENBQVksV0FBWixDQUF3QixLQUF4QixFQUErQixJQUEvQjtBQUNBLGFBQUssV0FBTDtBQUNILEtBSEQ7QUFJQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsU0FBMUIsR0FBc0MsWUFBWTtBQUM5QyxhQUFLLE1BQUwsQ0FBWSxjQUFaLENBQTJCLElBQTNCO0FBQ0EsYUFBSyxXQUFMO0FBQ0gsS0FIRDtBQUlBLFdBQU8sZUFBUDtBQUNILENBckJzQixDQXFCckIsYUFBYSxVQXJCUSxDQUF2QjtBQXNCQSxRQUFRLGVBQVIsR0FBMEIsZUFBMUI7QUFDQTs7O0FDbkNBOztBQUNBLElBQUksU0FBUyxRQUFRLGFBQVIsQ0FBYjtBQUNBLElBQUksaUJBQWlCLFFBQVEscUJBQVIsQ0FBckI7QUFDQSxJQUFJLGVBQWUsUUFBUSxxQkFBUixDQUFuQjtBQUNBOzs7Ozs7QUFNQSxJQUFJLGFBQWMsWUFBWTtBQUMxQjs7Ozs7OztBQU9BLGFBQVMsVUFBVCxDQUFvQixTQUFwQixFQUErQjtBQUMzQixhQUFLLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxZQUFJLFNBQUosRUFBZTtBQUNYLGlCQUFLLFVBQUwsR0FBa0IsU0FBbEI7QUFDSDtBQUNKO0FBQ0Q7Ozs7Ozs7QUFPQSxlQUFXLFNBQVgsQ0FBcUIsSUFBckIsR0FBNEIsVUFBVSxRQUFWLEVBQW9CO0FBQzVDLFlBQUksYUFBYSxJQUFJLFVBQUosRUFBakI7QUFDQSxtQkFBVyxNQUFYLEdBQW9CLElBQXBCO0FBQ0EsbUJBQVcsUUFBWCxHQUFzQixRQUF0QjtBQUNBLGVBQU8sVUFBUDtBQUNILEtBTEQ7QUFNQSxlQUFXLFNBQVgsQ0FBcUIsU0FBckIsR0FBaUMsVUFBVSxjQUFWLEVBQTBCLEtBQTFCLEVBQWlDLFFBQWpDLEVBQTJDO0FBQ3hFLFlBQUksV0FBVyxLQUFLLFFBQXBCO0FBQ0EsWUFBSSxPQUFPLGVBQWUsWUFBZixDQUE0QixjQUE1QixFQUE0QyxLQUE1QyxFQUFtRCxRQUFuRCxDQUFYO0FBQ0EsWUFBSSxRQUFKLEVBQWM7QUFDVixxQkFBUyxJQUFULENBQWMsSUFBZCxFQUFvQixLQUFLLE1BQXpCO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsaUJBQUssR0FBTCxDQUFTLEtBQUssYUFBTCxDQUFtQixJQUFuQixDQUFUO0FBQ0g7QUFDRCxZQUFJLEtBQUssa0JBQVQsRUFBNkI7QUFDekIsaUJBQUssa0JBQUwsR0FBMEIsS0FBMUI7QUFDQSxnQkFBSSxLQUFLLGVBQVQsRUFBMEI7QUFDdEIsc0JBQU0sS0FBSyxjQUFYO0FBQ0g7QUFDSjtBQUNELGVBQU8sSUFBUDtBQUNILEtBaEJEO0FBaUJBLGVBQVcsU0FBWCxDQUFxQixhQUFyQixHQUFxQyxVQUFVLElBQVYsRUFBZ0I7QUFDakQsWUFBSTtBQUNBLG1CQUFPLEtBQUssVUFBTCxDQUFnQixJQUFoQixDQUFQO0FBQ0gsU0FGRCxDQUdBLE9BQU8sR0FBUCxFQUFZO0FBQ1IsaUJBQUssZUFBTCxHQUF1QixJQUF2QjtBQUNBLGlCQUFLLGNBQUwsR0FBc0IsR0FBdEI7QUFDQSxpQkFBSyxLQUFMLENBQVcsR0FBWDtBQUNIO0FBQ0osS0FURDtBQVVBOzs7Ozs7O0FBT0EsZUFBVyxTQUFYLENBQXFCLE9BQXJCLEdBQStCLFVBQVUsSUFBVixFQUFnQixXQUFoQixFQUE2QjtBQUN4RCxZQUFJLFFBQVEsSUFBWjtBQUNBLFlBQUksQ0FBQyxXQUFMLEVBQWtCO0FBQ2QsZ0JBQUksT0FBTyxJQUFQLENBQVksRUFBWixJQUFrQixPQUFPLElBQVAsQ0FBWSxFQUFaLENBQWUsTUFBakMsSUFBMkMsT0FBTyxJQUFQLENBQVksRUFBWixDQUFlLE1BQWYsQ0FBc0IsT0FBckUsRUFBOEU7QUFDMUUsOEJBQWMsT0FBTyxJQUFQLENBQVksRUFBWixDQUFlLE1BQWYsQ0FBc0IsT0FBcEM7QUFDSCxhQUZELE1BR0ssSUFBSSxPQUFPLElBQVAsQ0FBWSxPQUFoQixFQUF5QjtBQUMxQiw4QkFBYyxPQUFPLElBQVAsQ0FBWSxPQUExQjtBQUNIO0FBQ0o7QUFDRCxZQUFJLENBQUMsV0FBTCxFQUFrQjtBQUNkLGtCQUFNLElBQUksS0FBSixDQUFVLHVCQUFWLENBQU47QUFDSDtBQUNELGVBQU8sSUFBSSxXQUFKLENBQWdCLFVBQVUsT0FBVixFQUFtQixNQUFuQixFQUEyQjtBQUM5QztBQUNBO0FBQ0EsZ0JBQUksWUFBSjtBQUNBLDJCQUFlLE1BQU0sU0FBTixDQUFnQixVQUFVLEtBQVYsRUFBaUI7QUFDNUMsb0JBQUksWUFBSixFQUFrQjtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQUk7QUFDQSw2QkFBSyxLQUFMO0FBQ0gscUJBRkQsQ0FHQSxPQUFPLEdBQVAsRUFBWTtBQUNSLCtCQUFPLEdBQVA7QUFDQSxxQ0FBYSxXQUFiO0FBQ0g7QUFDSixpQkFaRCxNQWFLO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQUssS0FBTDtBQUNIO0FBQ0osYUF2QmMsRUF1QlosTUF2QlksRUF1QkosT0F2QkksQ0FBZjtBQXdCSCxTQTVCTSxDQUFQO0FBNkJILEtBMUNEO0FBMkNBLGVBQVcsU0FBWCxDQUFxQixVQUFyQixHQUFrQyxVQUFVLFVBQVYsRUFBc0I7QUFDcEQsZUFBTyxLQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLFVBQXRCLENBQVA7QUFDSCxLQUZEO0FBR0E7Ozs7O0FBS0EsZUFBVyxTQUFYLENBQXFCLGFBQWEsVUFBbEMsSUFBZ0QsWUFBWTtBQUN4RCxlQUFPLElBQVA7QUFDSCxLQUZEO0FBR0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBLGVBQVcsTUFBWCxHQUFvQixVQUFVLFNBQVYsRUFBcUI7QUFDckMsZUFBTyxJQUFJLFVBQUosQ0FBZSxTQUFmLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxVQUFQO0FBQ0gsQ0FqSWlCLEVBQWxCO0FBa0lBLFFBQVEsVUFBUixHQUFxQixVQUFyQjtBQUNBOzs7QUM3SUE7O0FBQ0EsUUFBUSxLQUFSLEdBQWdCO0FBQ1osWUFBUSxJQURJO0FBRVosVUFBTSxVQUFVLEtBQVYsRUFBaUIsQ0FBRyxDQUZkO0FBR1osV0FBTyxVQUFVLEdBQVYsRUFBZTtBQUFFLGNBQU0sR0FBTjtBQUFZLEtBSHhCO0FBSVosY0FBVSxZQUFZLENBQUc7QUFKYixDQUFoQjtBQU1BOzs7QUNQQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQsRUFBaUIsSUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUMxQyxhQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxjQUFSLENBQW5CO0FBQ0E7Ozs7O0FBS0EsSUFBSSxrQkFBbUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3JDLGNBQVUsZUFBVixFQUEyQixNQUEzQjtBQUNBLGFBQVMsZUFBVCxHQUEyQjtBQUN2QixlQUFPLEtBQVAsQ0FBYSxJQUFiLEVBQW1CLFNBQW5CO0FBQ0g7QUFDRCxvQkFBZ0IsU0FBaEIsQ0FBMEIsVUFBMUIsR0FBdUMsVUFBVSxVQUFWLEVBQXNCLFVBQXRCLEVBQWtDLFVBQWxDLEVBQThDLFVBQTlDLEVBQTBELFFBQTFELEVBQW9FO0FBQ3ZHLGFBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixVQUF0QjtBQUNILEtBRkQ7QUFHQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsV0FBMUIsR0FBd0MsVUFBVSxLQUFWLEVBQWlCLFFBQWpCLEVBQTJCO0FBQy9ELGFBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixLQUF2QjtBQUNILEtBRkQ7QUFHQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsY0FBMUIsR0FBMkMsVUFBVSxRQUFWLEVBQW9CO0FBQzNELGFBQUssV0FBTCxDQUFpQixRQUFqQjtBQUNILEtBRkQ7QUFHQSxXQUFPLGVBQVA7QUFDSCxDQWZzQixDQWVyQixhQUFhLFVBZlEsQ0FBdkI7QUFnQkEsUUFBUSxlQUFSLEdBQTBCLGVBQTFCO0FBQ0E7OztBQzdCQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQSxJQUFJLFlBQWEsWUFBWTtBQUN6QixhQUFTLFNBQVQsQ0FBbUIsZUFBbkIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDckMsWUFBSSxRQUFRLEtBQUssQ0FBakIsRUFBb0I7QUFBRSxrQkFBTSxVQUFVLEdBQWhCO0FBQXNCO0FBQzVDLGFBQUssZUFBTCxHQUF1QixlQUF2QjtBQUNBLGFBQUssR0FBTCxHQUFXLEdBQVg7QUFDSDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxjQUFVLFNBQVYsQ0FBb0IsUUFBcEIsR0FBK0IsVUFBVSxJQUFWLEVBQWdCLEtBQWhCLEVBQXVCLEtBQXZCLEVBQThCO0FBQ3pELFlBQUksVUFBVSxLQUFLLENBQW5CLEVBQXNCO0FBQUUsb0JBQVEsQ0FBUjtBQUFZO0FBQ3BDLGVBQU8sSUFBSSxLQUFLLGVBQVQsQ0FBeUIsSUFBekIsRUFBK0IsSUFBL0IsRUFBcUMsUUFBckMsQ0FBOEMsS0FBOUMsRUFBcUQsS0FBckQsQ0FBUDtBQUNILEtBSEQ7QUFJQSxjQUFVLEdBQVYsR0FBZ0IsS0FBSyxHQUFMLEdBQVcsS0FBSyxHQUFoQixHQUFzQixZQUFZO0FBQUUsZUFBTyxDQUFDLElBQUksSUFBSixFQUFSO0FBQXFCLEtBQXpFO0FBQ0EsV0FBTyxTQUFQO0FBQ0gsQ0E3QmdCLEVBQWpCO0FBOEJBLFFBQVEsU0FBUixHQUFvQixTQUFwQjtBQUNBOzs7QUNoREE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkLEVBQWlCLElBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFDMUMsYUFBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxlQUFlLFFBQVEsY0FBUixDQUFuQjtBQUNBLElBQUksZUFBZSxRQUFRLGNBQVIsQ0FBbkI7QUFDQSxJQUFJLGlCQUFpQixRQUFRLGdCQUFSLENBQXJCO0FBQ0EsSUFBSSw0QkFBNEIsUUFBUSxnQ0FBUixDQUFoQztBQUNBLElBQUksd0JBQXdCLFFBQVEsdUJBQVIsQ0FBNUI7QUFDQSxJQUFJLGlCQUFpQixRQUFRLHVCQUFSLENBQXJCO0FBQ0E7OztBQUdBLElBQUksb0JBQXFCLFVBQVUsTUFBVixFQUFrQjtBQUN2QyxjQUFVLGlCQUFWLEVBQTZCLE1BQTdCO0FBQ0EsYUFBUyxpQkFBVCxDQUEyQixXQUEzQixFQUF3QztBQUNwQyxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0g7QUFDRCxXQUFPLGlCQUFQO0FBQ0gsQ0FQd0IsQ0FPdkIsYUFBYSxVQVBVLENBQXpCO0FBUUEsUUFBUSxpQkFBUixHQUE0QixpQkFBNUI7QUFDQTs7O0FBR0EsSUFBSSxVQUFXLFVBQVUsTUFBVixFQUFrQjtBQUM3QixjQUFVLE9BQVYsRUFBbUIsTUFBbkI7QUFDQSxhQUFTLE9BQVQsR0FBbUI7QUFDZixlQUFPLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLEVBQWpCO0FBQ0EsYUFBSyxNQUFMLEdBQWMsS0FBZDtBQUNBLGFBQUssU0FBTCxHQUFpQixLQUFqQjtBQUNBLGFBQUssUUFBTCxHQUFnQixLQUFoQjtBQUNBLGFBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNIO0FBQ0QsWUFBUSxTQUFSLENBQWtCLGVBQWUsWUFBakMsSUFBaUQsWUFBWTtBQUN6RCxlQUFPLElBQUksaUJBQUosQ0FBc0IsSUFBdEIsQ0FBUDtBQUNILEtBRkQ7QUFHQSxZQUFRLFNBQVIsQ0FBa0IsSUFBbEIsR0FBeUIsVUFBVSxRQUFWLEVBQW9CO0FBQ3pDLFlBQUksVUFBVSxJQUFJLGdCQUFKLENBQXFCLElBQXJCLEVBQTJCLElBQTNCLENBQWQ7QUFDQSxnQkFBUSxRQUFSLEdBQW1CLFFBQW5CO0FBQ0EsZUFBTyxPQUFQO0FBQ0gsS0FKRDtBQUtBLFlBQVEsU0FBUixDQUFrQixJQUFsQixHQUF5QixVQUFVLEtBQVYsRUFBaUI7QUFDdEMsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYixrQkFBTSxJQUFJLDBCQUEwQix1QkFBOUIsRUFBTjtBQUNIO0FBQ0QsWUFBSSxDQUFDLEtBQUssU0FBVixFQUFxQjtBQUNqQixnQkFBSSxZQUFZLEtBQUssU0FBckI7QUFDQSxnQkFBSSxNQUFNLFVBQVUsTUFBcEI7QUFDQSxnQkFBSSxPQUFPLFVBQVUsS0FBVixFQUFYO0FBQ0EsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxHQUFwQixFQUF5QixHQUF6QixFQUE4QjtBQUMxQixxQkFBSyxDQUFMLEVBQVEsSUFBUixDQUFhLEtBQWI7QUFDSDtBQUNKO0FBQ0osS0FaRDtBQWFBLFlBQVEsU0FBUixDQUFrQixLQUFsQixHQUEwQixVQUFVLEdBQVYsRUFBZTtBQUNyQyxZQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNiLGtCQUFNLElBQUksMEJBQTBCLHVCQUE5QixFQUFOO0FBQ0g7QUFDRCxhQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxhQUFLLFdBQUwsR0FBbUIsR0FBbkI7QUFDQSxhQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxZQUFJLFlBQVksS0FBSyxTQUFyQjtBQUNBLFlBQUksTUFBTSxVQUFVLE1BQXBCO0FBQ0EsWUFBSSxPQUFPLFVBQVUsS0FBVixFQUFYO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLGlCQUFLLENBQUwsRUFBUSxLQUFSLENBQWMsR0FBZDtBQUNIO0FBQ0QsYUFBSyxTQUFMLENBQWUsTUFBZixHQUF3QixDQUF4QjtBQUNILEtBZEQ7QUFlQSxZQUFRLFNBQVIsQ0FBa0IsUUFBbEIsR0FBNkIsWUFBWTtBQUNyQyxZQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNiLGtCQUFNLElBQUksMEJBQTBCLHVCQUE5QixFQUFOO0FBQ0g7QUFDRCxhQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxZQUFJLFlBQVksS0FBSyxTQUFyQjtBQUNBLFlBQUksTUFBTSxVQUFVLE1BQXBCO0FBQ0EsWUFBSSxPQUFPLFVBQVUsS0FBVixFQUFYO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLGlCQUFLLENBQUwsRUFBUSxRQUFSO0FBQ0g7QUFDRCxhQUFLLFNBQUwsQ0FBZSxNQUFmLEdBQXdCLENBQXhCO0FBQ0gsS0FaRDtBQWFBLFlBQVEsU0FBUixDQUFrQixXQUFsQixHQUFnQyxZQUFZO0FBQ3hDLGFBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLGFBQUssTUFBTCxHQUFjLElBQWQ7QUFDQSxhQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDSCxLQUpEO0FBS0EsWUFBUSxTQUFSLENBQWtCLGFBQWxCLEdBQWtDLFVBQVUsVUFBVixFQUFzQjtBQUNwRCxZQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNiLGtCQUFNLElBQUksMEJBQTBCLHVCQUE5QixFQUFOO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsbUJBQU8sT0FBTyxTQUFQLENBQWlCLGFBQWpCLENBQStCLElBQS9CLENBQW9DLElBQXBDLEVBQTBDLFVBQTFDLENBQVA7QUFDSDtBQUNKLEtBUEQ7QUFRQSxZQUFRLFNBQVIsQ0FBa0IsVUFBbEIsR0FBK0IsVUFBVSxVQUFWLEVBQXNCO0FBQ2pELFlBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2Isa0JBQU0sSUFBSSwwQkFBMEIsdUJBQTlCLEVBQU47QUFDSCxTQUZELE1BR0ssSUFBSSxLQUFLLFFBQVQsRUFBbUI7QUFDcEIsdUJBQVcsS0FBWCxDQUFpQixLQUFLLFdBQXRCO0FBQ0EsbUJBQU8sZUFBZSxZQUFmLENBQTRCLEtBQW5DO0FBQ0gsU0FISSxNQUlBLElBQUksS0FBSyxTQUFULEVBQW9CO0FBQ3JCLHVCQUFXLFFBQVg7QUFDQSxtQkFBTyxlQUFlLFlBQWYsQ0FBNEIsS0FBbkM7QUFDSCxTQUhJLE1BSUE7QUFDRCxpQkFBSyxTQUFMLENBQWUsSUFBZixDQUFvQixVQUFwQjtBQUNBLG1CQUFPLElBQUksc0JBQXNCLG1CQUExQixDQUE4QyxJQUE5QyxFQUFvRCxVQUFwRCxDQUFQO0FBQ0g7QUFDSixLQWhCRDtBQWlCQSxZQUFRLFNBQVIsQ0FBa0IsWUFBbEIsR0FBaUMsWUFBWTtBQUN6QyxZQUFJLGFBQWEsSUFBSSxhQUFhLFVBQWpCLEVBQWpCO0FBQ0EsbUJBQVcsTUFBWCxHQUFvQixJQUFwQjtBQUNBLGVBQU8sVUFBUDtBQUNILEtBSkQ7QUFLQSxZQUFRLE1BQVIsR0FBaUIsVUFBVSxXQUFWLEVBQXVCLE1BQXZCLEVBQStCO0FBQzVDLGVBQU8sSUFBSSxnQkFBSixDQUFxQixXQUFyQixFQUFrQyxNQUFsQyxDQUFQO0FBQ0gsS0FGRDtBQUdBLFdBQU8sT0FBUDtBQUNILENBbEdjLENBa0diLGFBQWEsVUFsR0EsQ0FBZjtBQW1HQSxRQUFRLE9BQVIsR0FBa0IsT0FBbEI7QUFDQTs7O0FBR0EsSUFBSSxtQkFBb0IsVUFBVSxNQUFWLEVBQWtCO0FBQ3RDLGNBQVUsZ0JBQVYsRUFBNEIsTUFBNUI7QUFDQSxhQUFTLGdCQUFULENBQTBCLFdBQTFCLEVBQXVDLE1BQXZDLEVBQStDO0FBQzNDLGVBQU8sSUFBUCxDQUFZLElBQVo7QUFDQSxhQUFLLFdBQUwsR0FBbUIsV0FBbkI7QUFDQSxhQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0g7QUFDRCxxQkFBaUIsU0FBakIsQ0FBMkIsSUFBM0IsR0FBa0MsVUFBVSxLQUFWLEVBQWlCO0FBQy9DLFlBQUksY0FBYyxLQUFLLFdBQXZCO0FBQ0EsWUFBSSxlQUFlLFlBQVksSUFBL0IsRUFBcUM7QUFDakMsd0JBQVksSUFBWixDQUFpQixLQUFqQjtBQUNIO0FBQ0osS0FMRDtBQU1BLHFCQUFpQixTQUFqQixDQUEyQixLQUEzQixHQUFtQyxVQUFVLEdBQVYsRUFBZTtBQUM5QyxZQUFJLGNBQWMsS0FBSyxXQUF2QjtBQUNBLFlBQUksZUFBZSxZQUFZLEtBQS9CLEVBQXNDO0FBQ2xDLGlCQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBdUIsR0FBdkI7QUFDSDtBQUNKLEtBTEQ7QUFNQSxxQkFBaUIsU0FBakIsQ0FBMkIsUUFBM0IsR0FBc0MsWUFBWTtBQUM5QyxZQUFJLGNBQWMsS0FBSyxXQUF2QjtBQUNBLFlBQUksZUFBZSxZQUFZLFFBQS9CLEVBQXlDO0FBQ3JDLGlCQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDSDtBQUNKLEtBTEQ7QUFNQSxxQkFBaUIsU0FBakIsQ0FBMkIsVUFBM0IsR0FBd0MsVUFBVSxVQUFWLEVBQXNCO0FBQzFELFlBQUksU0FBUyxLQUFLLE1BQWxCO0FBQ0EsWUFBSSxNQUFKLEVBQVk7QUFDUixtQkFBTyxLQUFLLE1BQUwsQ0FBWSxTQUFaLENBQXNCLFVBQXRCLENBQVA7QUFDSCxTQUZELE1BR0s7QUFDRCxtQkFBTyxlQUFlLFlBQWYsQ0FBNEIsS0FBbkM7QUFDSDtBQUNKLEtBUkQ7QUFTQSxXQUFPLGdCQUFQO0FBQ0gsQ0FuQ3VCLENBbUN0QixPQW5Dc0IsQ0FBeEI7QUFvQ0EsUUFBUSxnQkFBUixHQUEyQixnQkFBM0I7QUFDQTs7O0FDdktBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZCxFQUFpQixJQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQzFDLGFBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksaUJBQWlCLFFBQVEsZ0JBQVIsQ0FBckI7QUFDQTs7Ozs7QUFLQSxJQUFJLHNCQUF1QixVQUFVLE1BQVYsRUFBa0I7QUFDekMsY0FBVSxtQkFBVixFQUErQixNQUEvQjtBQUNBLGFBQVMsbUJBQVQsQ0FBNkIsT0FBN0IsRUFBc0MsVUFBdEMsRUFBa0Q7QUFDOUMsZUFBTyxJQUFQLENBQVksSUFBWjtBQUNBLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxhQUFLLFVBQUwsR0FBa0IsVUFBbEI7QUFDQSxhQUFLLE1BQUwsR0FBYyxLQUFkO0FBQ0g7QUFDRCx3QkFBb0IsU0FBcEIsQ0FBOEIsV0FBOUIsR0FBNEMsWUFBWTtBQUNwRCxZQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNiO0FBQ0g7QUFDRCxhQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0EsWUFBSSxVQUFVLEtBQUssT0FBbkI7QUFDQSxZQUFJLFlBQVksUUFBUSxTQUF4QjtBQUNBLGFBQUssT0FBTCxHQUFlLElBQWY7QUFDQSxZQUFJLENBQUMsU0FBRCxJQUFjLFVBQVUsTUFBVixLQUFxQixDQUFuQyxJQUF3QyxRQUFRLFNBQWhELElBQTZELFFBQVEsTUFBekUsRUFBaUY7QUFDN0U7QUFDSDtBQUNELFlBQUksa0JBQWtCLFVBQVUsT0FBVixDQUFrQixLQUFLLFVBQXZCLENBQXRCO0FBQ0EsWUFBSSxvQkFBb0IsQ0FBQyxDQUF6QixFQUE0QjtBQUN4QixzQkFBVSxNQUFWLENBQWlCLGVBQWpCLEVBQWtDLENBQWxDO0FBQ0g7QUFDSixLQWZEO0FBZ0JBLFdBQU8sbUJBQVA7QUFDSCxDQXpCMEIsQ0F5QnpCLGVBQWUsWUF6QlUsQ0FBM0I7QUEwQkEsUUFBUSxtQkFBUixHQUE4QixtQkFBOUI7QUFDQTs7O0FDdkNBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZCxFQUFpQixJQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQzFDLGFBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksZUFBZSxRQUFRLG1CQUFSLENBQW5CO0FBQ0EsSUFBSSxpQkFBaUIsUUFBUSxnQkFBUixDQUFyQjtBQUNBLElBQUksYUFBYSxRQUFRLFlBQVIsQ0FBakI7QUFDQSxJQUFJLGlCQUFpQixRQUFRLHVCQUFSLENBQXJCO0FBQ0E7Ozs7Ozs7Ozs7QUFVQSxJQUFJLGFBQWMsVUFBVSxNQUFWLEVBQWtCO0FBQ2hDLGNBQVUsVUFBVixFQUFzQixNQUF0QjtBQUNBOzs7Ozs7OztBQVFBLGFBQVMsVUFBVCxDQUFvQixpQkFBcEIsRUFBdUMsS0FBdkMsRUFBOEMsUUFBOUMsRUFBd0Q7QUFDcEQsZUFBTyxJQUFQLENBQVksSUFBWjtBQUNBLGFBQUssY0FBTCxHQUFzQixJQUF0QjtBQUNBLGFBQUssZUFBTCxHQUF1QixLQUF2QjtBQUNBLGFBQUssa0JBQUwsR0FBMEIsS0FBMUI7QUFDQSxhQUFLLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxnQkFBUSxVQUFVLE1BQWxCO0FBQ0ksaUJBQUssQ0FBTDtBQUNJLHFCQUFLLFdBQUwsR0FBbUIsV0FBVyxLQUE5QjtBQUNBO0FBQ0osaUJBQUssQ0FBTDtBQUNJLG9CQUFJLENBQUMsaUJBQUwsRUFBd0I7QUFDcEIseUJBQUssV0FBTCxHQUFtQixXQUFXLEtBQTlCO0FBQ0E7QUFDSDtBQUNELG9CQUFJLE9BQU8saUJBQVAsS0FBNkIsUUFBakMsRUFBMkM7QUFDdkMsd0JBQUksNkJBQTZCLFVBQWpDLEVBQTZDO0FBQ3pDLDZCQUFLLFdBQUwsR0FBbUIsaUJBQW5CO0FBQ0EsNkJBQUssV0FBTCxDQUFpQixHQUFqQixDQUFxQixJQUFyQjtBQUNILHFCQUhELE1BSUs7QUFDRCw2QkFBSyxrQkFBTCxHQUEwQixJQUExQjtBQUNBLDZCQUFLLFdBQUwsR0FBbUIsSUFBSSxjQUFKLENBQW1CLElBQW5CLEVBQXlCLGlCQUF6QixDQUFuQjtBQUNIO0FBQ0Q7QUFDSDtBQUNMO0FBQ0kscUJBQUssa0JBQUwsR0FBMEIsSUFBMUI7QUFDQSxxQkFBSyxXQUFMLEdBQW1CLElBQUksY0FBSixDQUFtQixJQUFuQixFQUF5QixpQkFBekIsRUFBNEMsS0FBNUMsRUFBbUQsUUFBbkQsQ0FBbkI7QUFDQTtBQXZCUjtBQXlCSDtBQUNELGVBQVcsU0FBWCxDQUFxQixlQUFlLFlBQXBDLElBQW9ELFlBQVk7QUFBRSxlQUFPLElBQVA7QUFBYyxLQUFoRjtBQUNBOzs7Ozs7Ozs7OztBQVdBLGVBQVcsTUFBWCxHQUFvQixVQUFVLElBQVYsRUFBZ0IsS0FBaEIsRUFBdUIsUUFBdkIsRUFBaUM7QUFDakQsWUFBSSxhQUFhLElBQUksVUFBSixDQUFlLElBQWYsRUFBcUIsS0FBckIsRUFBNEIsUUFBNUIsQ0FBakI7QUFDQSxtQkFBVyxrQkFBWCxHQUFnQyxLQUFoQztBQUNBLGVBQU8sVUFBUDtBQUNILEtBSkQ7QUFLQTs7Ozs7OztBQU9BLGVBQVcsU0FBWCxDQUFxQixJQUFyQixHQUE0QixVQUFVLEtBQVYsRUFBaUI7QUFDekMsWUFBSSxDQUFDLEtBQUssU0FBVixFQUFxQjtBQUNqQixpQkFBSyxLQUFMLENBQVcsS0FBWDtBQUNIO0FBQ0osS0FKRDtBQUtBOzs7Ozs7O0FBT0EsZUFBVyxTQUFYLENBQXFCLEtBQXJCLEdBQTZCLFVBQVUsR0FBVixFQUFlO0FBQ3hDLFlBQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUI7QUFDakIsaUJBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLGlCQUFLLE1BQUwsQ0FBWSxHQUFaO0FBQ0g7QUFDSixLQUxEO0FBTUE7Ozs7OztBQU1BLGVBQVcsU0FBWCxDQUFxQixRQUFyQixHQUFnQyxZQUFZO0FBQ3hDLFlBQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUI7QUFDakIsaUJBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLGlCQUFLLFNBQUw7QUFDSDtBQUNKLEtBTEQ7QUFNQSxlQUFXLFNBQVgsQ0FBcUIsV0FBckIsR0FBbUMsWUFBWTtBQUMzQyxZQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNiO0FBQ0g7QUFDRCxhQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxlQUFPLFNBQVAsQ0FBaUIsV0FBakIsQ0FBNkIsSUFBN0IsQ0FBa0MsSUFBbEM7QUFDSCxLQU5EO0FBT0EsZUFBVyxTQUFYLENBQXFCLEtBQXJCLEdBQTZCLFVBQVUsS0FBVixFQUFpQjtBQUMxQyxhQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsS0FBdEI7QUFDSCxLQUZEO0FBR0EsZUFBVyxTQUFYLENBQXFCLE1BQXJCLEdBQThCLFVBQVUsR0FBVixFQUFlO0FBQ3pDLGFBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixHQUF2QjtBQUNBLGFBQUssV0FBTDtBQUNILEtBSEQ7QUFJQSxlQUFXLFNBQVgsQ0FBcUIsU0FBckIsR0FBaUMsWUFBWTtBQUN6QyxhQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDQSxhQUFLLFdBQUw7QUFDSCxLQUhEO0FBSUEsZUFBVyxTQUFYLENBQXFCLHNCQUFyQixHQUE4QyxZQUFZO0FBQ3RELFlBQUksS0FBSyxJQUFUO0FBQUEsWUFBZSxVQUFVLEdBQUcsT0FBNUI7QUFBQSxZQUFxQyxXQUFXLEdBQUcsUUFBbkQ7QUFDQSxhQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsYUFBSyxXQUFMO0FBQ0EsYUFBSyxNQUFMLEdBQWMsS0FBZDtBQUNBLGFBQUssU0FBTCxHQUFpQixLQUFqQjtBQUNBLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxlQUFPLElBQVA7QUFDSCxLQVZEO0FBV0EsV0FBTyxVQUFQO0FBQ0gsQ0E5SGlCLENBOEhoQixlQUFlLFlBOUhDLENBQWxCO0FBK0hBLFFBQVEsVUFBUixHQUFxQixVQUFyQjtBQUNBOzs7OztBQUtBLElBQUksaUJBQWtCLFVBQVUsTUFBVixFQUFrQjtBQUNwQyxjQUFVLGNBQVYsRUFBMEIsTUFBMUI7QUFDQSxhQUFTLGNBQVQsQ0FBd0IsaUJBQXhCLEVBQTJDLGNBQTNDLEVBQTJELEtBQTNELEVBQWtFLFFBQWxFLEVBQTRFO0FBQ3hFLGVBQU8sSUFBUCxDQUFZLElBQVo7QUFDQSxhQUFLLGlCQUFMLEdBQXlCLGlCQUF6QjtBQUNBLFlBQUksSUFBSjtBQUNBLFlBQUksVUFBVSxJQUFkO0FBQ0EsWUFBSSxhQUFhLFVBQWIsQ0FBd0IsY0FBeEIsQ0FBSixFQUE2QztBQUN6QyxtQkFBTyxjQUFQO0FBQ0gsU0FGRCxNQUdLLElBQUksY0FBSixFQUFvQjtBQUNyQixtQkFBTyxlQUFlLElBQXRCO0FBQ0Esb0JBQVEsZUFBZSxLQUF2QjtBQUNBLHVCQUFXLGVBQWUsUUFBMUI7QUFDQSxnQkFBSSxtQkFBbUIsV0FBVyxLQUFsQyxFQUF5QztBQUNyQywwQkFBVSxPQUFPLE1BQVAsQ0FBYyxjQUFkLENBQVY7QUFDQSxvQkFBSSxhQUFhLFVBQWIsQ0FBd0IsUUFBUSxXQUFoQyxDQUFKLEVBQWtEO0FBQzlDLHlCQUFLLEdBQUwsQ0FBUyxRQUFRLFdBQVIsQ0FBb0IsSUFBcEIsQ0FBeUIsT0FBekIsQ0FBVDtBQUNIO0FBQ0Qsd0JBQVEsV0FBUixHQUFzQixLQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBdEI7QUFDSDtBQUNKO0FBQ0QsYUFBSyxRQUFMLEdBQWdCLE9BQWhCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUssTUFBTCxHQUFjLEtBQWQ7QUFDQSxhQUFLLFNBQUwsR0FBaUIsUUFBakI7QUFDSDtBQUNELG1CQUFlLFNBQWYsQ0FBeUIsSUFBekIsR0FBZ0MsVUFBVSxLQUFWLEVBQWlCO0FBQzdDLFlBQUksQ0FBQyxLQUFLLFNBQU4sSUFBbUIsS0FBSyxLQUE1QixFQUFtQztBQUMvQixnQkFBSSxvQkFBb0IsS0FBSyxpQkFBN0I7QUFDQSxnQkFBSSxDQUFDLGtCQUFrQixrQkFBdkIsRUFBMkM7QUFDdkMscUJBQUssWUFBTCxDQUFrQixLQUFLLEtBQXZCLEVBQThCLEtBQTlCO0FBQ0gsYUFGRCxNQUdLLElBQUksS0FBSyxlQUFMLENBQXFCLGlCQUFyQixFQUF3QyxLQUFLLEtBQTdDLEVBQW9ELEtBQXBELENBQUosRUFBZ0U7QUFDakUscUJBQUssV0FBTDtBQUNIO0FBQ0o7QUFDSixLQVZEO0FBV0EsbUJBQWUsU0FBZixDQUF5QixLQUF6QixHQUFpQyxVQUFVLEdBQVYsRUFBZTtBQUM1QyxZQUFJLENBQUMsS0FBSyxTQUFWLEVBQXFCO0FBQ2pCLGdCQUFJLG9CQUFvQixLQUFLLGlCQUE3QjtBQUNBLGdCQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNiLG9CQUFJLENBQUMsa0JBQWtCLGtCQUF2QixFQUEyQztBQUN2Qyx5QkFBSyxZQUFMLENBQWtCLEtBQUssTUFBdkIsRUFBK0IsR0FBL0I7QUFDQSx5QkFBSyxXQUFMO0FBQ0gsaUJBSEQsTUFJSztBQUNELHlCQUFLLGVBQUwsQ0FBcUIsaUJBQXJCLEVBQXdDLEtBQUssTUFBN0MsRUFBcUQsR0FBckQ7QUFDQSx5QkFBSyxXQUFMO0FBQ0g7QUFDSixhQVRELE1BVUssSUFBSSxDQUFDLGtCQUFrQixrQkFBdkIsRUFBMkM7QUFDNUMscUJBQUssV0FBTDtBQUNBLHNCQUFNLEdBQU47QUFDSCxhQUhJLE1BSUE7QUFDRCxrQ0FBa0IsY0FBbEIsR0FBbUMsR0FBbkM7QUFDQSxrQ0FBa0IsZUFBbEIsR0FBb0MsSUFBcEM7QUFDQSxxQkFBSyxXQUFMO0FBQ0g7QUFDSjtBQUNKLEtBdkJEO0FBd0JBLG1CQUFlLFNBQWYsQ0FBeUIsUUFBekIsR0FBb0MsWUFBWTtBQUM1QyxZQUFJLENBQUMsS0FBSyxTQUFWLEVBQXFCO0FBQ2pCLGdCQUFJLG9CQUFvQixLQUFLLGlCQUE3QjtBQUNBLGdCQUFJLEtBQUssU0FBVCxFQUFvQjtBQUNoQixvQkFBSSxDQUFDLGtCQUFrQixrQkFBdkIsRUFBMkM7QUFDdkMseUJBQUssWUFBTCxDQUFrQixLQUFLLFNBQXZCO0FBQ0EseUJBQUssV0FBTDtBQUNILGlCQUhELE1BSUs7QUFDRCx5QkFBSyxlQUFMLENBQXFCLGlCQUFyQixFQUF3QyxLQUFLLFNBQTdDO0FBQ0EseUJBQUssV0FBTDtBQUNIO0FBQ0osYUFURCxNQVVLO0FBQ0QscUJBQUssV0FBTDtBQUNIO0FBQ0o7QUFDSixLQWpCRDtBQWtCQSxtQkFBZSxTQUFmLENBQXlCLFlBQXpCLEdBQXdDLFVBQVUsRUFBVixFQUFjLEtBQWQsRUFBcUI7QUFDekQsWUFBSTtBQUNBLGVBQUcsSUFBSCxDQUFRLEtBQUssUUFBYixFQUF1QixLQUF2QjtBQUNILFNBRkQsQ0FHQSxPQUFPLEdBQVAsRUFBWTtBQUNSLGlCQUFLLFdBQUw7QUFDQSxrQkFBTSxHQUFOO0FBQ0g7QUFDSixLQVJEO0FBU0EsbUJBQWUsU0FBZixDQUF5QixlQUF6QixHQUEyQyxVQUFVLE1BQVYsRUFBa0IsRUFBbEIsRUFBc0IsS0FBdEIsRUFBNkI7QUFDcEUsWUFBSTtBQUNBLGVBQUcsSUFBSCxDQUFRLEtBQUssUUFBYixFQUF1QixLQUF2QjtBQUNILFNBRkQsQ0FHQSxPQUFPLEdBQVAsRUFBWTtBQUNSLG1CQUFPLGNBQVAsR0FBd0IsR0FBeEI7QUFDQSxtQkFBTyxlQUFQLEdBQXlCLElBQXpCO0FBQ0EsbUJBQU8sSUFBUDtBQUNIO0FBQ0QsZUFBTyxLQUFQO0FBQ0gsS0FWRDtBQVdBLG1CQUFlLFNBQWYsQ0FBeUIsWUFBekIsR0FBd0MsWUFBWTtBQUNoRCxZQUFJLG9CQUFvQixLQUFLLGlCQUE3QjtBQUNBLGFBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLGFBQUssaUJBQUwsR0FBeUIsSUFBekI7QUFDQSwwQkFBa0IsV0FBbEI7QUFDSCxLQUxEO0FBTUEsV0FBTyxjQUFQO0FBQ0gsQ0EzR3FCLENBMkdwQixVQTNHb0IsQ0FBdEI7QUE0R0E7OztBQ3JRQTs7QUFDQSxJQUFJLFlBQVksUUFBUSxnQkFBUixDQUFoQjtBQUNBLElBQUksYUFBYSxRQUFRLGlCQUFSLENBQWpCO0FBQ0EsSUFBSSxlQUFlLFFBQVEsbUJBQVIsQ0FBbkI7QUFDQSxJQUFJLGFBQWEsUUFBUSxpQkFBUixDQUFqQjtBQUNBLElBQUksZ0JBQWdCLFFBQVEsb0JBQVIsQ0FBcEI7QUFDQSxJQUFJLHdCQUF3QixRQUFRLDRCQUFSLENBQTVCO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBLElBQUksZUFBZ0IsWUFBWTtBQUM1Qjs7OztBQUlBLGFBQVMsWUFBVCxDQUFzQixXQUF0QixFQUFtQztBQUMvQjs7OztBQUlBLGFBQUssTUFBTCxHQUFjLEtBQWQ7QUFDQSxhQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsYUFBSyxjQUFMLEdBQXNCLElBQXRCO0FBQ0EsWUFBSSxXQUFKLEVBQWlCO0FBQ2IsaUJBQUssWUFBTCxHQUFvQixXQUFwQjtBQUNIO0FBQ0o7QUFDRDs7Ozs7O0FBTUEsaUJBQWEsU0FBYixDQUF1QixXQUF2QixHQUFxQyxZQUFZO0FBQzdDLFlBQUksWUFBWSxLQUFoQjtBQUNBLFlBQUksTUFBSjtBQUNBLFlBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2I7QUFDSDtBQUNELFlBQUksS0FBSyxJQUFUO0FBQUEsWUFBZSxVQUFVLEdBQUcsT0FBNUI7QUFBQSxZQUFxQyxXQUFXLEdBQUcsUUFBbkQ7QUFBQSxZQUE2RCxlQUFlLEdBQUcsWUFBL0U7QUFBQSxZQUE2RixpQkFBaUIsR0FBRyxjQUFqSDtBQUNBLGFBQUssTUFBTCxHQUFjLElBQWQ7QUFDQSxhQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0E7QUFDQTtBQUNBLGFBQUssY0FBTCxHQUFzQixJQUF0QjtBQUNBLFlBQUksUUFBUSxDQUFDLENBQWI7QUFDQSxZQUFJLE1BQU0sV0FBVyxTQUFTLE1BQXBCLEdBQTZCLENBQXZDO0FBQ0E7QUFDQTtBQUNBLGVBQU8sT0FBUCxFQUFnQjtBQUNaLG9CQUFRLE1BQVIsQ0FBZSxJQUFmO0FBQ0E7QUFDQTtBQUNBLHNCQUFVLEVBQUUsS0FBRixHQUFVLEdBQVYsSUFBaUIsU0FBUyxLQUFULENBQWpCLElBQW9DLElBQTlDO0FBQ0g7QUFDRCxZQUFJLGFBQWEsVUFBYixDQUF3QixZQUF4QixDQUFKLEVBQTJDO0FBQ3ZDLGdCQUFJLFFBQVEsV0FBVyxRQUFYLENBQW9CLFlBQXBCLEVBQWtDLElBQWxDLENBQXVDLElBQXZDLENBQVo7QUFDQSxnQkFBSSxVQUFVLGNBQWMsV0FBNUIsRUFBeUM7QUFDckMsNEJBQVksSUFBWjtBQUNBLHlCQUFTLFdBQVcsY0FBYyxXQUFkLENBQTBCLENBQTFCLFlBQXVDLHNCQUFzQixtQkFBN0QsR0FDaEIsNEJBQTRCLGNBQWMsV0FBZCxDQUEwQixDQUExQixDQUE0QixNQUF4RCxDQURnQixHQUNrRCxDQUFDLGNBQWMsV0FBZCxDQUEwQixDQUEzQixDQUQ3RCxDQUFUO0FBRUg7QUFDSjtBQUNELFlBQUksVUFBVSxPQUFWLENBQWtCLGNBQWxCLENBQUosRUFBdUM7QUFDbkMsb0JBQVEsQ0FBQyxDQUFUO0FBQ0Esa0JBQU0sZUFBZSxNQUFyQjtBQUNBLG1CQUFPLEVBQUUsS0FBRixHQUFVLEdBQWpCLEVBQXNCO0FBQ2xCLG9CQUFJLE1BQU0sZUFBZSxLQUFmLENBQVY7QUFDQSxvQkFBSSxXQUFXLFFBQVgsQ0FBb0IsR0FBcEIsQ0FBSixFQUE4QjtBQUMxQix3QkFBSSxRQUFRLFdBQVcsUUFBWCxDQUFvQixJQUFJLFdBQXhCLEVBQXFDLElBQXJDLENBQTBDLEdBQTFDLENBQVo7QUFDQSx3QkFBSSxVQUFVLGNBQWMsV0FBNUIsRUFBeUM7QUFDckMsb0NBQVksSUFBWjtBQUNBLGlDQUFTLFVBQVUsRUFBbkI7QUFDQSw0QkFBSSxNQUFNLGNBQWMsV0FBZCxDQUEwQixDQUFwQztBQUNBLDRCQUFJLGVBQWUsc0JBQXNCLG1CQUF6QyxFQUE4RDtBQUMxRCxxQ0FBUyxPQUFPLE1BQVAsQ0FBYyw0QkFBNEIsSUFBSSxNQUFoQyxDQUFkLENBQVQ7QUFDSCx5QkFGRCxNQUdLO0FBQ0QsbUNBQU8sSUFBUCxDQUFZLEdBQVo7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKO0FBQ0QsWUFBSSxTQUFKLEVBQWU7QUFDWCxrQkFBTSxJQUFJLHNCQUFzQixtQkFBMUIsQ0FBOEMsTUFBOUMsQ0FBTjtBQUNIO0FBQ0osS0F2REQ7QUF3REE7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWtCQSxpQkFBYSxTQUFiLENBQXVCLEdBQXZCLEdBQTZCLFVBQVUsUUFBVixFQUFvQjtBQUM3QyxZQUFJLENBQUMsUUFBRCxJQUFjLGFBQWEsYUFBYSxLQUE1QyxFQUFvRDtBQUNoRCxtQkFBTyxhQUFhLEtBQXBCO0FBQ0g7QUFDRCxZQUFJLGFBQWEsSUFBakIsRUFBdUI7QUFDbkIsbUJBQU8sSUFBUDtBQUNIO0FBQ0QsWUFBSSxlQUFlLFFBQW5CO0FBQ0EsZ0JBQVEsT0FBTyxRQUFmO0FBQ0ksaUJBQUssVUFBTDtBQUNJLCtCQUFlLElBQUksWUFBSixDQUFpQixRQUFqQixDQUFmO0FBQ0osaUJBQUssUUFBTDtBQUNJLG9CQUFJLGFBQWEsTUFBYixJQUF1QixPQUFPLGFBQWEsV0FBcEIsS0FBb0MsVUFBL0QsRUFBMkU7QUFDdkUsMkJBQU8sWUFBUDtBQUNILGlCQUZELE1BR0ssSUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDbEIsaUNBQWEsV0FBYjtBQUNBLDJCQUFPLFlBQVA7QUFDSCxpQkFISSxNQUlBLElBQUksT0FBTyxhQUFhLFVBQXBCLEtBQW1DLFVBQXZDLENBQWtELGlCQUFsRCxFQUFxRTtBQUN0RSw0QkFBSSxNQUFNLFlBQVY7QUFDQSx1Q0FBZSxJQUFJLFlBQUosRUFBZjtBQUNBLHFDQUFhLGNBQWIsR0FBOEIsQ0FBQyxHQUFELENBQTlCO0FBQ0g7QUFDRDtBQUNKO0FBQ0ksc0JBQU0sSUFBSSxLQUFKLENBQVUsMkJBQTJCLFFBQTNCLEdBQXNDLHlCQUFoRCxDQUFOO0FBbEJSO0FBb0JBLFlBQUksZ0JBQWdCLEtBQUssY0FBTCxLQUF3QixLQUFLLGNBQUwsR0FBc0IsRUFBOUMsQ0FBcEI7QUFDQSxzQkFBYyxJQUFkLENBQW1CLFlBQW5CO0FBQ0EscUJBQWEsVUFBYixDQUF3QixJQUF4QjtBQUNBLGVBQU8sWUFBUDtBQUNILEtBaENEO0FBaUNBOzs7Ozs7QUFNQSxpQkFBYSxTQUFiLENBQXVCLE1BQXZCLEdBQWdDLFVBQVUsWUFBVixFQUF3QjtBQUNwRCxZQUFJLGdCQUFnQixLQUFLLGNBQXpCO0FBQ0EsWUFBSSxhQUFKLEVBQW1CO0FBQ2YsZ0JBQUksb0JBQW9CLGNBQWMsT0FBZCxDQUFzQixZQUF0QixDQUF4QjtBQUNBLGdCQUFJLHNCQUFzQixDQUFDLENBQTNCLEVBQThCO0FBQzFCLDhCQUFjLE1BQWQsQ0FBcUIsaUJBQXJCLEVBQXdDLENBQXhDO0FBQ0g7QUFDSjtBQUNKLEtBUkQ7QUFTQSxpQkFBYSxTQUFiLENBQXVCLFVBQXZCLEdBQW9DLFVBQVUsTUFBVixFQUFrQjtBQUNsRCxZQUFJLEtBQUssSUFBVDtBQUFBLFlBQWUsVUFBVSxHQUFHLE9BQTVCO0FBQUEsWUFBcUMsV0FBVyxHQUFHLFFBQW5EO0FBQ0EsWUFBSSxDQUFDLE9BQUQsSUFBWSxZQUFZLE1BQTVCLEVBQW9DO0FBQ2hDO0FBQ0E7QUFDQSxpQkFBSyxPQUFMLEdBQWUsTUFBZjtBQUNILFNBSkQsTUFLSyxJQUFJLENBQUMsUUFBTCxFQUFlO0FBQ2hCO0FBQ0E7QUFDQSxpQkFBSyxRQUFMLEdBQWdCLENBQUMsTUFBRCxDQUFoQjtBQUNILFNBSkksTUFLQSxJQUFJLFNBQVMsT0FBVCxDQUFpQixNQUFqQixNQUE2QixDQUFDLENBQWxDLEVBQXFDO0FBQ3RDO0FBQ0EscUJBQVMsSUFBVCxDQUFjLE1BQWQ7QUFDSDtBQUNKLEtBaEJEO0FBaUJBLGlCQUFhLEtBQWIsR0FBc0IsVUFBVSxLQUFWLEVBQWlCO0FBQ25DLGNBQU0sTUFBTixHQUFlLElBQWY7QUFDQSxlQUFPLEtBQVA7QUFDSCxLQUhxQixDQUdwQixJQUFJLFlBQUosRUFIb0IsQ0FBdEI7QUFJQSxXQUFPLFlBQVA7QUFDSCxDQXhLbUIsRUFBcEI7QUF5S0EsUUFBUSxZQUFSLEdBQXVCLFlBQXZCO0FBQ0EsU0FBUywyQkFBVCxDQUFxQyxNQUFyQyxFQUE2QztBQUN6QyxXQUFPLE9BQU8sTUFBUCxDQUFjLFVBQVUsSUFBVixFQUFnQixHQUFoQixFQUFxQjtBQUFFLGVBQU8sS0FBSyxNQUFMLENBQWEsZUFBZSxzQkFBc0IsbUJBQXRDLEdBQTZELElBQUksTUFBakUsR0FBMEUsR0FBdEYsQ0FBUDtBQUFvRyxLQUF6SSxFQUEySSxFQUEzSSxDQUFQO0FBQ0g7QUFDRDs7O0FDaE1BOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZCxFQUFpQixJQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQzFDLGFBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksZUFBZSxRQUFRLGVBQVIsQ0FBbkI7QUFDQSxJQUFJLHFCQUFxQixRQUFRLG9CQUFSLENBQXpCO0FBQ0EsSUFBSSxvQkFBb0IsUUFBUSxtQkFBUixDQUF4QjtBQUNBLElBQUksZ0JBQWdCLFFBQVEscUJBQVIsQ0FBcEI7QUFDQTs7Ozs7QUFLQSxJQUFJLGtCQUFtQixVQUFVLE1BQVYsRUFBa0I7QUFDckMsY0FBVSxlQUFWLEVBQTJCLE1BQTNCO0FBQ0EsYUFBUyxlQUFULENBQXlCLEtBQXpCLEVBQWdDLFNBQWhDLEVBQTJDO0FBQ3ZDLGVBQU8sSUFBUCxDQUFZLElBQVo7QUFDQSxhQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0EsWUFBSSxDQUFDLFNBQUQsSUFBYyxNQUFNLE1BQU4sS0FBaUIsQ0FBbkMsRUFBc0M7QUFDbEMsaUJBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLGlCQUFLLEtBQUwsR0FBYSxNQUFNLENBQU4sQ0FBYjtBQUNIO0FBQ0o7QUFDRCxvQkFBZ0IsTUFBaEIsR0FBeUIsVUFBVSxLQUFWLEVBQWlCLFNBQWpCLEVBQTRCO0FBQ2pELGVBQU8sSUFBSSxlQUFKLENBQW9CLEtBQXBCLEVBQTJCLFNBQTNCLENBQVA7QUFDSCxLQUZEO0FBR0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9DQSxvQkFBZ0IsRUFBaEIsR0FBcUIsWUFBWTtBQUM3QixZQUFJLFFBQVEsRUFBWjtBQUNBLGFBQUssSUFBSSxLQUFLLENBQWQsRUFBaUIsS0FBSyxVQUFVLE1BQWhDLEVBQXdDLElBQXhDLEVBQThDO0FBQzFDLGtCQUFNLEtBQUssQ0FBWCxJQUFnQixVQUFVLEVBQVYsQ0FBaEI7QUFDSDtBQUNELFlBQUksWUFBWSxNQUFNLE1BQU0sTUFBTixHQUFlLENBQXJCLENBQWhCO0FBQ0EsWUFBSSxjQUFjLFdBQWQsQ0FBMEIsU0FBMUIsQ0FBSixFQUEwQztBQUN0QyxrQkFBTSxHQUFOO0FBQ0gsU0FGRCxNQUdLO0FBQ0Qsd0JBQVksSUFBWjtBQUNIO0FBQ0QsWUFBSSxNQUFNLE1BQU0sTUFBaEI7QUFDQSxZQUFJLE1BQU0sQ0FBVixFQUFhO0FBQ1QsbUJBQU8sSUFBSSxlQUFKLENBQW9CLEtBQXBCLEVBQTJCLFNBQTNCLENBQVA7QUFDSCxTQUZELE1BR0ssSUFBSSxRQUFRLENBQVosRUFBZTtBQUNoQixtQkFBTyxJQUFJLG1CQUFtQixnQkFBdkIsQ0FBd0MsTUFBTSxDQUFOLENBQXhDLEVBQWtELFNBQWxELENBQVA7QUFDSCxTQUZJLE1BR0E7QUFDRCxtQkFBTyxJQUFJLGtCQUFrQixlQUF0QixDQUFzQyxTQUF0QyxDQUFQO0FBQ0g7QUFDSixLQXRCRDtBQXVCQSxvQkFBZ0IsUUFBaEIsR0FBMkIsVUFBVSxLQUFWLEVBQWlCO0FBQ3hDLFlBQUksUUFBUSxNQUFNLEtBQWxCO0FBQUEsWUFBeUIsUUFBUSxNQUFNLEtBQXZDO0FBQUEsWUFBOEMsUUFBUSxNQUFNLEtBQTVEO0FBQUEsWUFBbUUsYUFBYSxNQUFNLFVBQXRGO0FBQ0EsWUFBSSxTQUFTLEtBQWIsRUFBb0I7QUFDaEIsdUJBQVcsUUFBWDtBQUNBO0FBQ0g7QUFDRCxtQkFBVyxJQUFYLENBQWdCLE1BQU0sS0FBTixDQUFoQjtBQUNBLFlBQUksV0FBVyxNQUFmLEVBQXVCO0FBQ25CO0FBQ0g7QUFDRCxjQUFNLEtBQU4sR0FBYyxRQUFRLENBQXRCO0FBQ0EsYUFBSyxRQUFMLENBQWMsS0FBZDtBQUNILEtBWkQ7QUFhQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsVUFBMUIsR0FBdUMsVUFBVSxVQUFWLEVBQXNCO0FBQ3pELFlBQUksUUFBUSxDQUFaO0FBQ0EsWUFBSSxRQUFRLEtBQUssS0FBakI7QUFDQSxZQUFJLFFBQVEsTUFBTSxNQUFsQjtBQUNBLFlBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0EsWUFBSSxTQUFKLEVBQWU7QUFDWCxtQkFBTyxVQUFVLFFBQVYsQ0FBbUIsZ0JBQWdCLFFBQW5DLEVBQTZDLENBQTdDLEVBQWdEO0FBQ25ELHVCQUFPLEtBRDRDLEVBQ3JDLE9BQU8sS0FEOEIsRUFDdkIsT0FBTyxLQURnQixFQUNULFlBQVk7QUFESCxhQUFoRCxDQUFQO0FBR0gsU0FKRCxNQUtLO0FBQ0QsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFKLElBQWEsQ0FBQyxXQUFXLE1BQXpDLEVBQWlELEdBQWpELEVBQXNEO0FBQ2xELDJCQUFXLElBQVgsQ0FBZ0IsTUFBTSxDQUFOLENBQWhCO0FBQ0g7QUFDRCx1QkFBVyxRQUFYO0FBQ0g7QUFDSixLQWhCRDtBQWlCQSxXQUFPLGVBQVA7QUFDSCxDQXhHc0IsQ0F3R3JCLGFBQWEsVUF4R1EsQ0FBdkI7QUF5R0EsUUFBUSxlQUFSLEdBQTBCLGVBQTFCO0FBQ0E7OztBQ3pIQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQsRUFBaUIsSUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUMxQyxhQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLFlBQVksUUFBUSxZQUFSLENBQWhCO0FBQ0EsSUFBSSxlQUFlLFFBQVEsZUFBUixDQUFuQjtBQUNBLElBQUksZUFBZSxRQUFRLGVBQVIsQ0FBbkI7QUFDQSxJQUFJLGlCQUFpQixRQUFRLGlCQUFSLENBQXJCO0FBQ0E7OztBQUdBLElBQUksd0JBQXlCLFVBQVUsTUFBVixFQUFrQjtBQUMzQyxjQUFVLHFCQUFWLEVBQWlDLE1BQWpDO0FBQ0EsYUFBUyxxQkFBVCxDQUErQixNQUEvQixFQUF1QyxjQUF2QyxFQUF1RDtBQUNuRCxlQUFPLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLGFBQUssY0FBTCxHQUFzQixjQUF0QjtBQUNBLGFBQUssU0FBTCxHQUFpQixDQUFqQjtBQUNIO0FBQ0QsMEJBQXNCLFNBQXRCLENBQWdDLFVBQWhDLEdBQTZDLFVBQVUsVUFBVixFQUFzQjtBQUMvRCxlQUFPLEtBQUssVUFBTCxHQUFrQixTQUFsQixDQUE0QixVQUE1QixDQUFQO0FBQ0gsS0FGRDtBQUdBLDBCQUFzQixTQUF0QixDQUFnQyxVQUFoQyxHQUE2QyxZQUFZO0FBQ3JELFlBQUksVUFBVSxLQUFLLFFBQW5CO0FBQ0EsWUFBSSxDQUFDLE9BQUQsSUFBWSxRQUFRLFNBQXhCLEVBQW1DO0FBQy9CLGlCQUFLLFFBQUwsR0FBZ0IsS0FBSyxjQUFMLEVBQWhCO0FBQ0g7QUFDRCxlQUFPLEtBQUssUUFBWjtBQUNILEtBTkQ7QUFPQSwwQkFBc0IsU0FBdEIsQ0FBZ0MsT0FBaEMsR0FBMEMsWUFBWTtBQUNsRCxZQUFJLGFBQWEsS0FBSyxXQUF0QjtBQUNBLFlBQUksQ0FBQyxVQUFMLEVBQWlCO0FBQ2IseUJBQWEsS0FBSyxXQUFMLEdBQW1CLElBQUksZUFBZSxZQUFuQixFQUFoQztBQUNBLHVCQUFXLEdBQVgsQ0FBZSxLQUFLLE1BQUwsQ0FDVixTQURVLENBQ0EsSUFBSSxxQkFBSixDQUEwQixLQUFLLFVBQUwsRUFBMUIsRUFBNkMsSUFBN0MsQ0FEQSxDQUFmO0FBRUEsZ0JBQUksV0FBVyxNQUFmLEVBQXVCO0FBQ25CLHFCQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSw2QkFBYSxlQUFlLFlBQWYsQ0FBNEIsS0FBekM7QUFDSCxhQUhELE1BSUs7QUFDRCxxQkFBSyxXQUFMLEdBQW1CLFVBQW5CO0FBQ0g7QUFDSjtBQUNELGVBQU8sVUFBUDtBQUNILEtBZkQ7QUFnQkEsMEJBQXNCLFNBQXRCLENBQWdDLFFBQWhDLEdBQTJDLFlBQVk7QUFDbkQsZUFBTyxLQUFLLElBQUwsQ0FBVSxJQUFJLGdCQUFKLENBQXFCLElBQXJCLENBQVYsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPLHFCQUFQO0FBQ0gsQ0F0QzRCLENBc0MzQixhQUFhLFVBdENjLENBQTdCO0FBdUNBLFFBQVEscUJBQVIsR0FBZ0MscUJBQWhDO0FBQ0EsUUFBUSwrQkFBUixHQUEwQztBQUN0QyxjQUFVLEVBQUUsT0FBTyxJQUFULEVBRDRCO0FBRXRDLGVBQVcsRUFBRSxPQUFPLENBQVQsRUFBWSxVQUFVLElBQXRCLEVBRjJCO0FBR3RDLGNBQVUsRUFBRSxPQUFPLElBQVQsRUFBZSxVQUFVLElBQXpCLEVBSDRCO0FBSXRDLGlCQUFhLEVBQUUsT0FBTyxJQUFULEVBQWUsVUFBVSxJQUF6QixFQUp5QjtBQUt0QyxnQkFBWSxFQUFFLE9BQU8sc0JBQXNCLFNBQXRCLENBQWdDLFVBQXpDLEVBTDBCO0FBTXRDLGdCQUFZLEVBQUUsT0FBTyxzQkFBc0IsU0FBdEIsQ0FBZ0MsVUFBekMsRUFOMEI7QUFPdEMsYUFBUyxFQUFFLE9BQU8sc0JBQXNCLFNBQXRCLENBQWdDLE9BQXpDLEVBUDZCO0FBUXRDLGNBQVUsRUFBRSxPQUFPLHNCQUFzQixTQUF0QixDQUFnQyxRQUF6QztBQVI0QixDQUExQztBQVVBLElBQUksd0JBQXlCLFVBQVUsTUFBVixFQUFrQjtBQUMzQyxjQUFVLHFCQUFWLEVBQWlDLE1BQWpDO0FBQ0EsYUFBUyxxQkFBVCxDQUErQixXQUEvQixFQUE0QyxXQUE1QyxFQUF5RDtBQUNyRCxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0g7QUFDRCwwQkFBc0IsU0FBdEIsQ0FBZ0MsTUFBaEMsR0FBeUMsVUFBVSxHQUFWLEVBQWU7QUFDcEQsYUFBSyxZQUFMO0FBQ0EsZUFBTyxTQUFQLENBQWlCLE1BQWpCLENBQXdCLElBQXhCLENBQTZCLElBQTdCLEVBQW1DLEdBQW5DO0FBQ0gsS0FIRDtBQUlBLDBCQUFzQixTQUF0QixDQUFnQyxTQUFoQyxHQUE0QyxZQUFZO0FBQ3BELGFBQUssWUFBTDtBQUNBLGVBQU8sU0FBUCxDQUFpQixTQUFqQixDQUEyQixJQUEzQixDQUFnQyxJQUFoQztBQUNILEtBSEQ7QUFJQSwwQkFBc0IsU0FBdEIsQ0FBZ0MsWUFBaEMsR0FBK0MsWUFBWTtBQUN2RCxZQUFJLGNBQWMsS0FBSyxXQUF2QjtBQUNBLFlBQUksV0FBSixFQUFpQjtBQUNiLGlCQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxnQkFBSSxhQUFhLFlBQVksV0FBN0I7QUFDQSx3QkFBWSxTQUFaLEdBQXdCLENBQXhCO0FBQ0Esd0JBQVksUUFBWixHQUF1QixJQUF2QjtBQUNBLHdCQUFZLFdBQVosR0FBMEIsSUFBMUI7QUFDQSxnQkFBSSxVQUFKLEVBQWdCO0FBQ1osMkJBQVcsV0FBWDtBQUNIO0FBQ0o7QUFDSixLQVpEO0FBYUEsV0FBTyxxQkFBUDtBQUNILENBNUI0QixDQTRCM0IsVUFBVSxpQkE1QmlCLENBQTdCO0FBNkJBLElBQUksbUJBQW9CLFlBQVk7QUFDaEMsYUFBUyxnQkFBVCxDQUEwQixXQUExQixFQUF1QztBQUNuQyxhQUFLLFdBQUwsR0FBbUIsV0FBbkI7QUFDSDtBQUNELHFCQUFpQixTQUFqQixDQUEyQixJQUEzQixHQUFrQyxVQUFVLFVBQVYsRUFBc0IsTUFBdEIsRUFBOEI7QUFDNUQsWUFBSSxjQUFjLEtBQUssV0FBdkI7QUFDQSxvQkFBWSxTQUFaO0FBQ0EsWUFBSSxhQUFhLElBQUksa0JBQUosQ0FBdUIsVUFBdkIsRUFBbUMsV0FBbkMsQ0FBakI7QUFDQSxZQUFJLGVBQWUsT0FBTyxTQUFQLENBQWlCLFVBQWpCLENBQW5CO0FBQ0EsWUFBSSxDQUFDLFdBQVcsTUFBaEIsRUFBd0I7QUFDcEIsdUJBQVcsVUFBWCxHQUF3QixZQUFZLE9BQVosRUFBeEI7QUFDSDtBQUNELGVBQU8sWUFBUDtBQUNILEtBVEQ7QUFVQSxXQUFPLGdCQUFQO0FBQ0gsQ0FmdUIsRUFBeEI7QUFnQkEsSUFBSSxxQkFBc0IsVUFBVSxNQUFWLEVBQWtCO0FBQ3hDLGNBQVUsa0JBQVYsRUFBOEIsTUFBOUI7QUFDQSxhQUFTLGtCQUFULENBQTRCLFdBQTVCLEVBQXlDLFdBQXpDLEVBQXNEO0FBQ2xELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLFdBQUwsR0FBbUIsV0FBbkI7QUFDSDtBQUNELHVCQUFtQixTQUFuQixDQUE2QixZQUE3QixHQUE0QyxZQUFZO0FBQ3BELFlBQUksY0FBYyxLQUFLLFdBQXZCO0FBQ0EsWUFBSSxDQUFDLFdBQUwsRUFBa0I7QUFDZCxpQkFBSyxVQUFMLEdBQWtCLElBQWxCO0FBQ0E7QUFDSDtBQUNELGFBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBLFlBQUksV0FBVyxZQUFZLFNBQTNCO0FBQ0EsWUFBSSxZQUFZLENBQWhCLEVBQW1CO0FBQ2YsaUJBQUssVUFBTCxHQUFrQixJQUFsQjtBQUNBO0FBQ0g7QUFDRCxvQkFBWSxTQUFaLEdBQXdCLFdBQVcsQ0FBbkM7QUFDQSxZQUFJLFdBQVcsQ0FBZixFQUFrQjtBQUNkLGlCQUFLLFVBQUwsR0FBa0IsSUFBbEI7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUksYUFBYSxLQUFLLFVBQXRCO0FBQ0EsWUFBSSxtQkFBbUIsWUFBWSxXQUFuQztBQUNBLGFBQUssVUFBTCxHQUFrQixJQUFsQjtBQUNBLFlBQUkscUJBQXFCLENBQUMsVUFBRCxJQUFlLHFCQUFxQixVQUF6RCxDQUFKLEVBQTBFO0FBQ3RFLDZCQUFpQixXQUFqQjtBQUNIO0FBQ0osS0E5Q0Q7QUErQ0EsV0FBTyxrQkFBUDtBQUNILENBdER5QixDQXNEeEIsYUFBYSxVQXREVyxDQUExQjtBQXVEQTs7O0FDbktBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZCxFQUFpQixJQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQzFDLGFBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksZUFBZSxRQUFRLGVBQVIsQ0FBbkI7QUFDQTs7Ozs7QUFLQSxJQUFJLGtCQUFtQixVQUFVLE1BQVYsRUFBa0I7QUFDckMsY0FBVSxlQUFWLEVBQTJCLE1BQTNCO0FBQ0EsYUFBUyxlQUFULENBQXlCLFNBQXpCLEVBQW9DO0FBQ2hDLGVBQU8sSUFBUCxDQUFZLElBQVo7QUFDQSxhQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDSDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkNBLG9CQUFnQixNQUFoQixHQUF5QixVQUFVLFNBQVYsRUFBcUI7QUFDMUMsZUFBTyxJQUFJLGVBQUosQ0FBb0IsU0FBcEIsQ0FBUDtBQUNILEtBRkQ7QUFHQSxvQkFBZ0IsUUFBaEIsR0FBMkIsVUFBVSxHQUFWLEVBQWU7QUFDdEMsWUFBSSxhQUFhLElBQUksVUFBckI7QUFDQSxtQkFBVyxRQUFYO0FBQ0gsS0FIRDtBQUlBLG9CQUFnQixTQUFoQixDQUEwQixVQUExQixHQUF1QyxVQUFVLFVBQVYsRUFBc0I7QUFDekQsWUFBSSxZQUFZLEtBQUssU0FBckI7QUFDQSxZQUFJLFNBQUosRUFBZTtBQUNYLG1CQUFPLFVBQVUsUUFBVixDQUFtQixnQkFBZ0IsUUFBbkMsRUFBNkMsQ0FBN0MsRUFBZ0QsRUFBRSxZQUFZLFVBQWQsRUFBaEQsQ0FBUDtBQUNILFNBRkQsTUFHSztBQUNELHVCQUFXLFFBQVg7QUFDSDtBQUNKLEtBUkQ7QUFTQSxXQUFPLGVBQVA7QUFDSCxDQWxFc0IsQ0FrRXJCLGFBQWEsVUFsRVEsQ0FBdkI7QUFtRUEsUUFBUSxlQUFSLEdBQTBCLGVBQTFCO0FBQ0E7OztBQ2hGQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQsRUFBaUIsSUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUMxQyxhQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0EsSUFBSSxhQUFhLFFBQVEsa0JBQVIsQ0FBakI7QUFDQSxJQUFJLGVBQWUsUUFBUSxvQkFBUixDQUFuQjtBQUNBLElBQUksZ0JBQWdCLFFBQVEscUJBQVIsQ0FBcEI7QUFDQSxJQUFJLGlCQUFpQixRQUFRLGlCQUFSLENBQXJCO0FBQ0EsSUFBSSxXQUFXLE9BQU8sU0FBUCxDQUFpQixRQUFoQztBQUNBLFNBQVMsdUJBQVQsQ0FBaUMsU0FBakMsRUFBNEM7QUFDeEMsV0FBTyxDQUFDLENBQUMsU0FBRixJQUFlLE9BQU8sVUFBVSxXQUFqQixLQUFpQyxVQUFoRCxJQUE4RCxPQUFPLFVBQVUsY0FBakIsS0FBb0MsVUFBekc7QUFDSDtBQUNELFNBQVMseUJBQVQsQ0FBbUMsU0FBbkMsRUFBOEM7QUFDMUMsV0FBTyxDQUFDLENBQUMsU0FBRixJQUFlLE9BQU8sVUFBVSxFQUFqQixLQUF3QixVQUF2QyxJQUFxRCxPQUFPLFVBQVUsR0FBakIsS0FBeUIsVUFBckY7QUFDSDtBQUNELFNBQVMsVUFBVCxDQUFvQixTQUFwQixFQUErQjtBQUMzQixXQUFPLENBQUMsQ0FBQyxTQUFGLElBQWUsU0FBUyxJQUFULENBQWMsU0FBZCxNQUE2QixtQkFBbkQ7QUFDSDtBQUNELFNBQVMsZ0JBQVQsQ0FBMEIsU0FBMUIsRUFBcUM7QUFDakMsV0FBTyxDQUFDLENBQUMsU0FBRixJQUFlLFNBQVMsSUFBVCxDQUFjLFNBQWQsTUFBNkIseUJBQW5EO0FBQ0g7QUFDRCxTQUFTLGFBQVQsQ0FBdUIsU0FBdkIsRUFBa0M7QUFDOUIsV0FBTyxDQUFDLENBQUMsU0FBRixJQUFlLE9BQU8sVUFBVSxnQkFBakIsS0FBc0MsVUFBckQsSUFBbUUsT0FBTyxVQUFVLG1CQUFqQixLQUF5QyxVQUFuSDtBQUNIO0FBQ0Q7Ozs7O0FBS0EsSUFBSSxzQkFBdUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3pDLGNBQVUsbUJBQVYsRUFBK0IsTUFBL0I7QUFDQSxhQUFTLG1CQUFULENBQTZCLFNBQTdCLEVBQXdDLFNBQXhDLEVBQW1ELFFBQW5ELEVBQTZELE9BQTdELEVBQXNFO0FBQ2xFLGVBQU8sSUFBUCxDQUFZLElBQVo7QUFDQSxhQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDQSxhQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0g7QUFDRDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0NBLHdCQUFvQixNQUFwQixHQUE2QixVQUFVLE1BQVYsRUFBa0IsU0FBbEIsRUFBNkIsT0FBN0IsRUFBc0MsUUFBdEMsRUFBZ0Q7QUFDekUsWUFBSSxhQUFhLFVBQWIsQ0FBd0IsT0FBeEIsQ0FBSixFQUFzQztBQUNsQyx1QkFBVyxPQUFYO0FBQ0Esc0JBQVUsU0FBVjtBQUNIO0FBQ0QsZUFBTyxJQUFJLG1CQUFKLENBQXdCLE1BQXhCLEVBQWdDLFNBQWhDLEVBQTJDLFFBQTNDLEVBQXFELE9BQXJELENBQVA7QUFDSCxLQU5EO0FBT0Esd0JBQW9CLGlCQUFwQixHQUF3QyxVQUFVLFNBQVYsRUFBcUIsU0FBckIsRUFBZ0MsT0FBaEMsRUFBeUMsVUFBekMsRUFBcUQsT0FBckQsRUFBOEQ7QUFDbEcsWUFBSSxXQUFKO0FBQ0EsWUFBSSxXQUFXLFNBQVgsS0FBeUIsaUJBQWlCLFNBQWpCLENBQTdCLEVBQTBEO0FBQ3RELGlCQUFLLElBQUksSUFBSSxDQUFSLEVBQVcsTUFBTSxVQUFVLE1BQWhDLEVBQXdDLElBQUksR0FBNUMsRUFBaUQsR0FBakQsRUFBc0Q7QUFDbEQsb0NBQW9CLGlCQUFwQixDQUFzQyxVQUFVLENBQVYsQ0FBdEMsRUFBb0QsU0FBcEQsRUFBK0QsT0FBL0QsRUFBd0UsVUFBeEUsRUFBb0YsT0FBcEY7QUFDSDtBQUNKLFNBSkQsTUFLSyxJQUFJLGNBQWMsU0FBZCxDQUFKLEVBQThCO0FBQy9CLGdCQUFJLFdBQVcsU0FBZjtBQUNBLHNCQUFVLGdCQUFWLENBQTJCLFNBQTNCLEVBQXNDLE9BQXRDLEVBQStDLE9BQS9DO0FBQ0EsMEJBQWMsWUFBWTtBQUFFLHVCQUFPLFNBQVMsbUJBQVQsQ0FBNkIsU0FBN0IsRUFBd0MsT0FBeEMsQ0FBUDtBQUEwRCxhQUF0RjtBQUNILFNBSkksTUFLQSxJQUFJLDBCQUEwQixTQUExQixDQUFKLEVBQTBDO0FBQzNDLGdCQUFJLFdBQVcsU0FBZjtBQUNBLHNCQUFVLEVBQVYsQ0FBYSxTQUFiLEVBQXdCLE9BQXhCO0FBQ0EsMEJBQWMsWUFBWTtBQUFFLHVCQUFPLFNBQVMsR0FBVCxDQUFhLFNBQWIsRUFBd0IsT0FBeEIsQ0FBUDtBQUEwQyxhQUF0RTtBQUNILFNBSkksTUFLQSxJQUFJLHdCQUF3QixTQUF4QixDQUFKLEVBQXdDO0FBQ3pDLGdCQUFJLFdBQVcsU0FBZjtBQUNBLHNCQUFVLFdBQVYsQ0FBc0IsU0FBdEIsRUFBaUMsT0FBakM7QUFDQSwwQkFBYyxZQUFZO0FBQUUsdUJBQU8sU0FBUyxjQUFULENBQXdCLFNBQXhCLEVBQW1DLE9BQW5DLENBQVA7QUFBcUQsYUFBakY7QUFDSCxTQUpJLE1BS0E7QUFDRCxrQkFBTSxJQUFJLFNBQUosQ0FBYyxzQkFBZCxDQUFOO0FBQ0g7QUFDRCxtQkFBVyxHQUFYLENBQWUsSUFBSSxlQUFlLFlBQW5CLENBQWdDLFdBQWhDLENBQWY7QUFDSCxLQTFCRDtBQTJCQSx3QkFBb0IsU0FBcEIsQ0FBOEIsVUFBOUIsR0FBMkMsVUFBVSxVQUFWLEVBQXNCO0FBQzdELFlBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0EsWUFBSSxZQUFZLEtBQUssU0FBckI7QUFDQSxZQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBLFlBQUksV0FBVyxLQUFLLFFBQXBCO0FBQ0EsWUFBSSxVQUFVLFdBQVcsWUFBWTtBQUNqQyxnQkFBSSxPQUFPLEVBQVg7QUFDQSxpQkFBSyxJQUFJLEtBQUssQ0FBZCxFQUFpQixLQUFLLFVBQVUsTUFBaEMsRUFBd0MsSUFBeEMsRUFBOEM7QUFDMUMscUJBQUssS0FBSyxDQUFWLElBQWUsVUFBVSxFQUFWLENBQWY7QUFDSDtBQUNELGdCQUFJLFNBQVMsV0FBVyxRQUFYLENBQW9CLFFBQXBCLEVBQThCLEtBQTlCLENBQW9DLEtBQUssQ0FBekMsRUFBNEMsSUFBNUMsQ0FBYjtBQUNBLGdCQUFJLFdBQVcsY0FBYyxXQUE3QixFQUEwQztBQUN0QywyQkFBVyxLQUFYLENBQWlCLGNBQWMsV0FBZCxDQUEwQixDQUEzQztBQUNILGFBRkQsTUFHSztBQUNELDJCQUFXLElBQVgsQ0FBZ0IsTUFBaEI7QUFDSDtBQUNKLFNBWmEsR0FZVixVQUFVLENBQVYsRUFBYTtBQUFFLG1CQUFPLFdBQVcsSUFBWCxDQUFnQixDQUFoQixDQUFQO0FBQTRCLFNBWi9DO0FBYUEsNEJBQW9CLGlCQUFwQixDQUFzQyxTQUF0QyxFQUFpRCxTQUFqRCxFQUE0RCxPQUE1RCxFQUFxRSxVQUFyRSxFQUFpRixPQUFqRjtBQUNILEtBbkJEO0FBb0JBLFdBQU8sbUJBQVA7QUFDSCxDQXpHMEIsQ0F5R3pCLGFBQWEsVUF6R1ksQ0FBM0I7QUEwR0EsUUFBUSxtQkFBUixHQUE4QixtQkFBOUI7QUFDQTs7O0FDM0lBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZCxFQUFpQixJQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQzFDLGFBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksZUFBZSxRQUFRLGVBQVIsQ0FBbkI7QUFDQTs7Ozs7QUFLQSxJQUFJLG1CQUFvQixVQUFVLE1BQVYsRUFBa0I7QUFDdEMsY0FBVSxnQkFBVixFQUE0QixNQUE1QjtBQUNBLGFBQVMsZ0JBQVQsQ0FBMEIsS0FBMUIsRUFBaUMsU0FBakMsRUFBNEM7QUFDeEMsZUFBTyxJQUFQLENBQVksSUFBWjtBQUNBLGFBQUssS0FBTCxHQUFhLEtBQWI7QUFDQSxhQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDQSxhQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxZQUFJLFNBQUosRUFBZTtBQUNYLGlCQUFLLFNBQUwsR0FBaUIsS0FBakI7QUFDSDtBQUNKO0FBQ0QscUJBQWlCLE1BQWpCLEdBQTBCLFVBQVUsS0FBVixFQUFpQixTQUFqQixFQUE0QjtBQUNsRCxlQUFPLElBQUksZ0JBQUosQ0FBcUIsS0FBckIsRUFBNEIsU0FBNUIsQ0FBUDtBQUNILEtBRkQ7QUFHQSxxQkFBaUIsUUFBakIsR0FBNEIsVUFBVSxLQUFWLEVBQWlCO0FBQ3pDLFlBQUksT0FBTyxNQUFNLElBQWpCO0FBQUEsWUFBdUIsUUFBUSxNQUFNLEtBQXJDO0FBQUEsWUFBNEMsYUFBYSxNQUFNLFVBQS9EO0FBQ0EsWUFBSSxJQUFKLEVBQVU7QUFDTix1QkFBVyxRQUFYO0FBQ0E7QUFDSDtBQUNELG1CQUFXLElBQVgsQ0FBZ0IsS0FBaEI7QUFDQSxZQUFJLFdBQVcsTUFBZixFQUF1QjtBQUNuQjtBQUNIO0FBQ0QsY0FBTSxJQUFOLEdBQWEsSUFBYjtBQUNBLGFBQUssUUFBTCxDQUFjLEtBQWQ7QUFDSCxLQVpEO0FBYUEscUJBQWlCLFNBQWpCLENBQTJCLFVBQTNCLEdBQXdDLFVBQVUsVUFBVixFQUFzQjtBQUMxRCxZQUFJLFFBQVEsS0FBSyxLQUFqQjtBQUNBLFlBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0EsWUFBSSxTQUFKLEVBQWU7QUFDWCxtQkFBTyxVQUFVLFFBQVYsQ0FBbUIsaUJBQWlCLFFBQXBDLEVBQThDLENBQTlDLEVBQWlEO0FBQ3BELHNCQUFNLEtBRDhDLEVBQ3ZDLE9BQU8sS0FEZ0MsRUFDekIsWUFBWTtBQURhLGFBQWpELENBQVA7QUFHSCxTQUpELE1BS0s7QUFDRCx1QkFBVyxJQUFYLENBQWdCLEtBQWhCO0FBQ0EsZ0JBQUksQ0FBQyxXQUFXLE1BQWhCLEVBQXdCO0FBQ3BCLDJCQUFXLFFBQVg7QUFDSDtBQUNKO0FBQ0osS0FkRDtBQWVBLFdBQU8sZ0JBQVA7QUFDSCxDQTNDdUIsQ0EyQ3RCLGFBQWEsVUEzQ1MsQ0FBeEI7QUE0Q0EsUUFBUSxnQkFBUixHQUEyQixnQkFBM0I7QUFDQTs7O0FDekRBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZCxFQUFpQixJQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQzFDLGFBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksY0FBYyxRQUFRLG1CQUFSLENBQWxCO0FBQ0EsSUFBSSxlQUFlLFFBQVEsZUFBUixDQUFuQjtBQUNBLElBQUksVUFBVSxRQUFRLG9CQUFSLENBQWQ7QUFDQSxJQUFJLGdCQUFnQixRQUFRLHFCQUFSLENBQXBCO0FBQ0EsSUFBSSxXQUFXLFFBQVEsZ0JBQVIsQ0FBZjtBQUNBOzs7OztBQUtBLElBQUksa0JBQW1CLFVBQVUsTUFBVixFQUFrQjtBQUNyQyxjQUFVLGVBQVYsRUFBMkIsTUFBM0I7QUFDQSxhQUFTLGVBQVQsQ0FBeUIsT0FBekIsRUFBa0MsTUFBbEMsRUFBMEMsU0FBMUMsRUFBcUQ7QUFDakQsWUFBSSxZQUFZLEtBQUssQ0FBckIsRUFBd0I7QUFBRSxzQkFBVSxDQUFWO0FBQWM7QUFDeEMsZUFBTyxJQUFQLENBQVksSUFBWjtBQUNBLGFBQUssTUFBTCxHQUFjLENBQUMsQ0FBZjtBQUNBLGFBQUssT0FBTCxHQUFlLENBQWY7QUFDQSxZQUFJLFlBQVksU0FBWixDQUFzQixNQUF0QixDQUFKLEVBQW1DO0FBQy9CLGlCQUFLLE1BQUwsR0FBYyxPQUFPLE1BQVAsSUFBaUIsQ0FBakIsSUFBc0IsQ0FBdEIsSUFBMkIsT0FBTyxNQUFQLENBQXpDO0FBQ0gsU0FGRCxNQUdLLElBQUksY0FBYyxXQUFkLENBQTBCLE1BQTFCLENBQUosRUFBdUM7QUFDeEMsd0JBQVksTUFBWjtBQUNIO0FBQ0QsWUFBSSxDQUFDLGNBQWMsV0FBZCxDQUEwQixTQUExQixDQUFMLEVBQTJDO0FBQ3ZDLHdCQUFZLFFBQVEsS0FBcEI7QUFDSDtBQUNELGFBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNBLGFBQUssT0FBTCxHQUFlLFNBQVMsTUFBVCxDQUFnQixPQUFoQixJQUNWLENBQUMsT0FBRCxHQUFXLEtBQUssU0FBTCxDQUFlLEdBQWYsRUFERCxHQUVYLE9BRko7QUFHSDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQ0Esb0JBQWdCLE1BQWhCLEdBQXlCLFVBQVUsWUFBVixFQUF3QixNQUF4QixFQUFnQyxTQUFoQyxFQUEyQztBQUNoRSxZQUFJLGlCQUFpQixLQUFLLENBQTFCLEVBQTZCO0FBQUUsMkJBQWUsQ0FBZjtBQUFtQjtBQUNsRCxlQUFPLElBQUksZUFBSixDQUFvQixZQUFwQixFQUFrQyxNQUFsQyxFQUEwQyxTQUExQyxDQUFQO0FBQ0gsS0FIRDtBQUlBLG9CQUFnQixRQUFoQixHQUEyQixVQUFVLEtBQVYsRUFBaUI7QUFDeEMsWUFBSSxRQUFRLE1BQU0sS0FBbEI7QUFBQSxZQUF5QixTQUFTLE1BQU0sTUFBeEM7QUFBQSxZQUFnRCxhQUFhLE1BQU0sVUFBbkU7QUFDQSxZQUFJLFNBQVMsSUFBYjtBQUNBLG1CQUFXLElBQVgsQ0FBZ0IsS0FBaEI7QUFDQSxZQUFJLFdBQVcsTUFBZixFQUF1QjtBQUNuQjtBQUNILFNBRkQsTUFHSyxJQUFJLFdBQVcsQ0FBQyxDQUFoQixFQUFtQjtBQUNwQixtQkFBTyxXQUFXLFFBQVgsRUFBUDtBQUNIO0FBQ0QsY0FBTSxLQUFOLEdBQWMsUUFBUSxDQUF0QjtBQUNBLGVBQU8sUUFBUCxDQUFnQixLQUFoQixFQUF1QixNQUF2QjtBQUNILEtBWkQ7QUFhQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsVUFBMUIsR0FBdUMsVUFBVSxVQUFWLEVBQXNCO0FBQ3pELFlBQUksUUFBUSxDQUFaO0FBQ0EsWUFBSSxLQUFLLElBQVQ7QUFBQSxZQUFlLFNBQVMsR0FBRyxNQUEzQjtBQUFBLFlBQW1DLFVBQVUsR0FBRyxPQUFoRDtBQUFBLFlBQXlELFlBQVksR0FBRyxTQUF4RTtBQUNBLGVBQU8sVUFBVSxRQUFWLENBQW1CLGdCQUFnQixRQUFuQyxFQUE2QyxPQUE3QyxFQUFzRDtBQUN6RCxtQkFBTyxLQURrRCxFQUMzQyxRQUFRLE1BRG1DLEVBQzNCLFlBQVk7QUFEZSxTQUF0RCxDQUFQO0FBR0gsS0FORDtBQU9BLFdBQU8sZUFBUDtBQUNILENBeEZzQixDQXdGckIsYUFBYSxVQXhGUSxDQUF2QjtBQXlGQSxRQUFRLGVBQVIsR0FBMEIsZUFBMUI7QUFDQTs7O0FDMUdBOztBQUNBLElBQUksb0JBQW9CLFFBQVEsbUJBQVIsQ0FBeEI7QUFDQSxRQUFRLEtBQVIsR0FBZ0Isa0JBQWtCLGVBQWxCLENBQWtDLE1BQWxEO0FBQ0E7OztBQ0hBOztBQUNBLElBQUksd0JBQXdCLFFBQVEsdUJBQVIsQ0FBNUI7QUFDQSxRQUFRLFNBQVIsR0FBb0Isc0JBQXNCLG1CQUF0QixDQUEwQyxNQUE5RDtBQUNBOzs7QUNIQTs7QUFDQSxJQUFJLG9CQUFvQixRQUFRLG1CQUFSLENBQXhCO0FBQ0EsUUFBUSxFQUFSLEdBQWEsa0JBQWtCLGVBQWxCLENBQWtDLEVBQS9DO0FBQ0E7OztBQ0hBOztBQUNBLElBQUksb0JBQW9CLFFBQVEsbUJBQVIsQ0FBeEI7QUFDQSxRQUFRLEtBQVIsR0FBZ0Isa0JBQWtCLGVBQWxCLENBQWtDLE1BQWxEO0FBQ0E7OztBQ0hBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZCxFQUFpQixJQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQzFDLGFBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksb0JBQW9CLFFBQVEsb0JBQVIsQ0FBeEI7QUFDQSxJQUFJLHNCQUFzQixRQUFRLDJCQUFSLENBQTFCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkRBLFNBQVMsTUFBVCxDQUFnQixRQUFoQixFQUEwQjtBQUN0QixRQUFJLFdBQVcsSUFBSSxhQUFKLENBQWtCLFFBQWxCLENBQWY7QUFDQSxRQUFJLFNBQVMsS0FBSyxJQUFMLENBQVUsUUFBVixDQUFiO0FBQ0EsV0FBUSxTQUFTLE1BQVQsR0FBa0IsTUFBMUI7QUFDSDtBQUNELFFBQVEsTUFBUixHQUFpQixNQUFqQjtBQUNBLElBQUksZ0JBQWlCLFlBQVk7QUFDN0IsYUFBUyxhQUFULENBQXVCLFFBQXZCLEVBQWlDO0FBQzdCLGFBQUssUUFBTCxHQUFnQixRQUFoQjtBQUNIO0FBQ0Qsa0JBQWMsU0FBZCxDQUF3QixJQUF4QixHQUErQixVQUFVLFVBQVYsRUFBc0IsTUFBdEIsRUFBOEI7QUFDekQsZUFBTyxPQUFPLFNBQVAsQ0FBaUIsSUFBSSxlQUFKLENBQW9CLFVBQXBCLEVBQWdDLEtBQUssUUFBckMsRUFBK0MsS0FBSyxNQUFwRCxDQUFqQixDQUFQO0FBQ0gsS0FGRDtBQUdBLFdBQU8sYUFBUDtBQUNILENBUm9CLEVBQXJCO0FBU0E7Ozs7O0FBS0EsSUFBSSxrQkFBbUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3JDLGNBQVUsZUFBVixFQUEyQixNQUEzQjtBQUNBLGFBQVMsZUFBVCxDQUF5QixXQUF6QixFQUFzQyxRQUF0QyxFQUFnRCxNQUFoRCxFQUF3RDtBQUNwRCxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFnQixTQUFoQixDQUEwQixLQUExQixHQUFrQyxVQUFVLEdBQVYsRUFBZTtBQUM3QyxZQUFJLENBQUMsS0FBSyxTQUFWLEVBQXFCO0FBQ2pCLGdCQUFJLFNBQVMsS0FBSyxDQUFsQjtBQUNBLGdCQUFJO0FBQ0EseUJBQVMsS0FBSyxRQUFMLENBQWMsR0FBZCxFQUFtQixLQUFLLE1BQXhCLENBQVQ7QUFDSCxhQUZELENBR0EsT0FBTyxJQUFQLEVBQWE7QUFDVCx1QkFBTyxTQUFQLENBQWlCLEtBQWpCLENBQXVCLElBQXZCLENBQTRCLElBQTVCLEVBQWtDLElBQWxDO0FBQ0E7QUFDSDtBQUNELGlCQUFLLHNCQUFMO0FBQ0EsaUJBQUssR0FBTCxDQUFTLG9CQUFvQixpQkFBcEIsQ0FBc0MsSUFBdEMsRUFBNEMsTUFBNUMsQ0FBVDtBQUNIO0FBQ0osS0FiRDtBQWNBLFdBQU8sZUFBUDtBQUNILENBM0JzQixDQTJCckIsa0JBQWtCLGVBM0JHLENBQXZCO0FBNEJBOzs7QUNuSEE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEsZUFBUixDQUFuQjtBQUNBLElBQUksZ0JBQWdCLFFBQVEscUJBQVIsQ0FBcEI7QUFDQSxJQUFJLG9CQUFvQixRQUFRLCtCQUFSLENBQXhCO0FBQ0EsSUFBSSxhQUFhLFFBQVEsWUFBUixDQUFqQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpREEsU0FBUyxNQUFULEdBQWtCO0FBQ2QsUUFBSSxjQUFjLEVBQWxCO0FBQ0EsU0FBSyxJQUFJLEtBQUssQ0FBZCxFQUFpQixLQUFLLFVBQVUsTUFBaEMsRUFBd0MsSUFBeEMsRUFBOEM7QUFDMUMsb0JBQVksS0FBSyxDQUFqQixJQUFzQixVQUFVLEVBQVYsQ0FBdEI7QUFDSDtBQUNELFdBQU8sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLGFBQWEsS0FBYixDQUFtQixLQUFLLENBQXhCLEVBQTJCLENBQUMsSUFBRCxFQUFPLE1BQVAsQ0FBYyxXQUFkLENBQTNCLENBQWYsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxNQUFSLEdBQWlCLE1BQWpCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkZBLFNBQVMsWUFBVCxHQUF3QjtBQUNwQixRQUFJLGNBQWMsRUFBbEI7QUFDQSxTQUFLLElBQUksS0FBSyxDQUFkLEVBQWlCLEtBQUssVUFBVSxNQUFoQyxFQUF3QyxJQUF4QyxFQUE4QztBQUMxQyxvQkFBWSxLQUFLLENBQWpCLElBQXNCLFVBQVUsRUFBVixDQUF0QjtBQUNIO0FBQ0QsUUFBSSxZQUFZLElBQWhCO0FBQ0EsUUFBSSxPQUFPLFdBQVg7QUFDQSxRQUFJLGNBQWMsV0FBZCxDQUEwQixLQUFLLFlBQVksTUFBWixHQUFxQixDQUExQixDQUExQixDQUFKLEVBQTZEO0FBQ3pELG9CQUFZLEtBQUssR0FBTCxFQUFaO0FBQ0g7QUFDRCxRQUFJLGNBQWMsSUFBZCxJQUFzQixZQUFZLE1BQVosS0FBdUIsQ0FBN0MsSUFBa0QsWUFBWSxDQUFaLGFBQTBCLGFBQWEsVUFBN0YsRUFBeUc7QUFDckcsZUFBTyxZQUFZLENBQVosQ0FBUDtBQUNIO0FBQ0QsV0FBTyxJQUFJLGtCQUFrQixlQUF0QixDQUFzQyxXQUF0QyxFQUFtRCxTQUFuRCxFQUE4RCxJQUE5RCxDQUFtRSxJQUFJLFdBQVcsZ0JBQWYsQ0FBZ0MsQ0FBaEMsQ0FBbkUsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxZQUFSLEdBQXVCLFlBQXZCO0FBQ0E7OztBQzdLQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQsRUFBaUIsSUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUMxQyxhQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0EsSUFBSSxVQUFVLFFBQVEsb0JBQVIsQ0FBZDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOENBLFNBQVMsWUFBVCxDQUFzQixPQUF0QixFQUErQixTQUEvQixFQUEwQztBQUN0QyxRQUFJLGNBQWMsS0FBSyxDQUF2QixFQUEwQjtBQUFFLG9CQUFZLFFBQVEsS0FBcEI7QUFBNEI7QUFDeEQsV0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFJLG9CQUFKLENBQXlCLE9BQXpCLEVBQWtDLFNBQWxDLENBQVYsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxZQUFSLEdBQXVCLFlBQXZCO0FBQ0EsSUFBSSx1QkFBd0IsWUFBWTtBQUNwQyxhQUFTLG9CQUFULENBQThCLE9BQTlCLEVBQXVDLFNBQXZDLEVBQWtEO0FBQzlDLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxhQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDSDtBQUNELHlCQUFxQixTQUFyQixDQUErQixJQUEvQixHQUFzQyxVQUFVLFVBQVYsRUFBc0IsTUFBdEIsRUFBOEI7QUFDaEUsZUFBTyxPQUFPLFNBQVAsQ0FBaUIsSUFBSSxzQkFBSixDQUEyQixVQUEzQixFQUF1QyxLQUFLLE9BQTVDLEVBQXFELEtBQUssU0FBMUQsQ0FBakIsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPLG9CQUFQO0FBQ0gsQ0FUMkIsRUFBNUI7QUFVQTs7Ozs7QUFLQSxJQUFJLHlCQUEwQixVQUFVLE1BQVYsRUFBa0I7QUFDNUMsY0FBVSxzQkFBVixFQUFrQyxNQUFsQztBQUNBLGFBQVMsc0JBQVQsQ0FBZ0MsV0FBaEMsRUFBNkMsT0FBN0MsRUFBc0QsU0FBdEQsRUFBaUU7QUFDN0QsZUFBTyxJQUFQLENBQVksSUFBWixFQUFrQixXQUFsQjtBQUNBLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxhQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDQSxhQUFLLHFCQUFMLEdBQTZCLElBQTdCO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLEtBQWhCO0FBQ0g7QUFDRCwyQkFBdUIsU0FBdkIsQ0FBaUMsS0FBakMsR0FBeUMsVUFBVSxLQUFWLEVBQWlCO0FBQ3RELGFBQUssYUFBTDtBQUNBLGFBQUssU0FBTCxHQUFpQixLQUFqQjtBQUNBLGFBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLGFBQUssR0FBTCxDQUFTLEtBQUsscUJBQUwsR0FBNkIsS0FBSyxTQUFMLENBQWUsUUFBZixDQUF3QixZQUF4QixFQUFzQyxLQUFLLE9BQTNDLEVBQW9ELElBQXBELENBQXRDO0FBQ0gsS0FMRDtBQU1BLDJCQUF1QixTQUF2QixDQUFpQyxTQUFqQyxHQUE2QyxZQUFZO0FBQ3JELGFBQUssYUFBTDtBQUNBLGFBQUssV0FBTCxDQUFpQixRQUFqQjtBQUNILEtBSEQ7QUFJQSwyQkFBdUIsU0FBdkIsQ0FBaUMsYUFBakMsR0FBaUQsWUFBWTtBQUN6RCxhQUFLLGFBQUw7QUFDQSxZQUFJLEtBQUssUUFBVCxFQUFtQjtBQUNmLGlCQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsS0FBSyxTQUEzQjtBQUNBLGlCQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxpQkFBSyxRQUFMLEdBQWdCLEtBQWhCO0FBQ0g7QUFDSixLQVBEO0FBUUEsMkJBQXVCLFNBQXZCLENBQWlDLGFBQWpDLEdBQWlELFlBQVk7QUFDekQsWUFBSSx3QkFBd0IsS0FBSyxxQkFBakM7QUFDQSxZQUFJLDBCQUEwQixJQUE5QixFQUFvQztBQUNoQyxpQkFBSyxNQUFMLENBQVkscUJBQVo7QUFDQSxrQ0FBc0IsV0FBdEI7QUFDQSxpQkFBSyxxQkFBTCxHQUE2QixJQUE3QjtBQUNIO0FBQ0osS0FQRDtBQVFBLFdBQU8sc0JBQVA7QUFDSCxDQXJDNkIsQ0FxQzVCLGFBQWEsVUFyQ2UsQ0FBOUI7QUFzQ0EsU0FBUyxZQUFULENBQXNCLFVBQXRCLEVBQWtDO0FBQzlCLGVBQVcsYUFBWDtBQUNIO0FBQ0Q7OztBQ25IQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQsRUFBaUIsSUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUMxQyxhQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJDQSxTQUFTLEdBQVQsQ0FBYSxjQUFiLEVBQTZCLEtBQTdCLEVBQW9DLFFBQXBDLEVBQThDO0FBQzFDLFdBQU8sS0FBSyxJQUFMLENBQVUsSUFBSSxVQUFKLENBQWUsY0FBZixFQUErQixLQUEvQixFQUFzQyxRQUF0QyxDQUFWLENBQVA7QUFDSDtBQUNELFFBQVEsR0FBUixHQUFjLEdBQWQ7QUFDQSxJQUFJLGFBQWMsWUFBWTtBQUMxQixhQUFTLFVBQVQsQ0FBb0IsY0FBcEIsRUFBb0MsS0FBcEMsRUFBMkMsUUFBM0MsRUFBcUQ7QUFDakQsYUFBSyxjQUFMLEdBQXNCLGNBQXRCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLGFBQUssUUFBTCxHQUFnQixRQUFoQjtBQUNIO0FBQ0QsZUFBVyxTQUFYLENBQXFCLElBQXJCLEdBQTRCLFVBQVUsVUFBVixFQUFzQixNQUF0QixFQUE4QjtBQUN0RCxlQUFPLE9BQU8sU0FBUCxDQUFpQixJQUFJLFlBQUosQ0FBaUIsVUFBakIsRUFBNkIsS0FBSyxjQUFsQyxFQUFrRCxLQUFLLEtBQXZELEVBQThELEtBQUssUUFBbkUsQ0FBakIsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPLFVBQVA7QUFDSCxDQVZpQixFQUFsQjtBQVdBOzs7OztBQUtBLElBQUksZUFBZ0IsVUFBVSxNQUFWLEVBQWtCO0FBQ2xDLGNBQVUsWUFBVixFQUF3QixNQUF4QjtBQUNBLGFBQVMsWUFBVCxDQUFzQixXQUF0QixFQUFtQyxjQUFuQyxFQUFtRCxLQUFuRCxFQUEwRCxRQUExRCxFQUFvRTtBQUNoRSxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsWUFBSSxpQkFBaUIsSUFBSSxhQUFhLFVBQWpCLENBQTRCLGNBQTVCLEVBQTRDLEtBQTVDLEVBQW1ELFFBQW5ELENBQXJCO0FBQ0EsdUJBQWUsa0JBQWYsR0FBb0MsSUFBcEM7QUFDQSxhQUFLLEdBQUwsQ0FBUyxjQUFUO0FBQ0EsYUFBSyxjQUFMLEdBQXNCLGNBQXRCO0FBQ0g7QUFDRCxpQkFBYSxTQUFiLENBQXVCLEtBQXZCLEdBQStCLFVBQVUsS0FBVixFQUFpQjtBQUM1QyxZQUFJLGlCQUFpQixLQUFLLGNBQTFCO0FBQ0EsdUJBQWUsSUFBZixDQUFvQixLQUFwQjtBQUNBLFlBQUksZUFBZSxlQUFuQixFQUFvQztBQUNoQyxpQkFBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLGVBQWUsY0FBdEM7QUFDSCxTQUZELE1BR0s7QUFDRCxpQkFBSyxXQUFMLENBQWlCLElBQWpCLENBQXNCLEtBQXRCO0FBQ0g7QUFDSixLQVREO0FBVUEsaUJBQWEsU0FBYixDQUF1QixNQUF2QixHQUFnQyxVQUFVLEdBQVYsRUFBZTtBQUMzQyxZQUFJLGlCQUFpQixLQUFLLGNBQTFCO0FBQ0EsdUJBQWUsS0FBZixDQUFxQixHQUFyQjtBQUNBLFlBQUksZUFBZSxlQUFuQixFQUFvQztBQUNoQyxpQkFBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLGVBQWUsY0FBdEM7QUFDSCxTQUZELE1BR0s7QUFDRCxpQkFBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLEdBQXZCO0FBQ0g7QUFDSixLQVREO0FBVUEsaUJBQWEsU0FBYixDQUF1QixTQUF2QixHQUFtQyxZQUFZO0FBQzNDLFlBQUksaUJBQWlCLEtBQUssY0FBMUI7QUFDQSx1QkFBZSxRQUFmO0FBQ0EsWUFBSSxlQUFlLGVBQW5CLEVBQW9DO0FBQ2hDLGlCQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBdUIsZUFBZSxjQUF0QztBQUNILFNBRkQsTUFHSztBQUNELGlCQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDSDtBQUNKLEtBVEQ7QUFVQSxXQUFPLFlBQVA7QUFDSCxDQXhDbUIsQ0F3Q2xCLGFBQWEsVUF4Q0ssQ0FBcEI7QUF5Q0E7OztBQ2hIQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQsRUFBaUIsSUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUMxQyxhQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLG9CQUFvQixRQUFRLG9CQUFSLENBQXhCO0FBQ0EsSUFBSSxzQkFBc0IsUUFBUSwyQkFBUixDQUExQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZDQSxTQUFTLFVBQVQsQ0FBb0IsT0FBcEIsRUFBNkIsY0FBN0IsRUFBNkM7QUFDekMsV0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFJLHNCQUFKLENBQTJCLE9BQTNCLEVBQW9DLGNBQXBDLENBQVYsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxVQUFSLEdBQXFCLFVBQXJCO0FBQ0EsSUFBSSx5QkFBMEIsWUFBWTtBQUN0QyxhQUFTLHNCQUFULENBQWdDLE9BQWhDLEVBQXlDLGNBQXpDLEVBQXlEO0FBQ3JELGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxhQUFLLGNBQUwsR0FBc0IsY0FBdEI7QUFDSDtBQUNELDJCQUF1QixTQUF2QixDQUFpQyxJQUFqQyxHQUF3QyxVQUFVLFVBQVYsRUFBc0IsTUFBdEIsRUFBOEI7QUFDbEUsZUFBTyxPQUFPLFNBQVAsQ0FBaUIsSUFBSSx3QkFBSixDQUE2QixVQUE3QixFQUF5QyxLQUFLLE9BQTlDLEVBQXVELEtBQUssY0FBNUQsQ0FBakIsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPLHNCQUFQO0FBQ0gsQ0FUNkIsRUFBOUI7QUFVQTs7Ozs7QUFLQSxJQUFJLDJCQUE0QixVQUFVLE1BQVYsRUFBa0I7QUFDOUMsY0FBVSx3QkFBVixFQUFvQyxNQUFwQztBQUNBLGFBQVMsd0JBQVQsQ0FBa0MsV0FBbEMsRUFBK0MsT0FBL0MsRUFBd0QsY0FBeEQsRUFBd0U7QUFDcEUsZUFBTyxJQUFQLENBQVksSUFBWixFQUFrQixXQUFsQjtBQUNBLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxhQUFLLGNBQUwsR0FBc0IsY0FBdEI7QUFDQSxhQUFLLGVBQUwsR0FBdUIsS0FBdkI7QUFDQSxhQUFLLFlBQUwsR0FBb0IsS0FBcEI7QUFDQSxhQUFLLEtBQUwsR0FBYSxDQUFiO0FBQ0g7QUFDRCw2QkFBeUIsU0FBekIsQ0FBbUMsS0FBbkMsR0FBMkMsVUFBVSxLQUFWLEVBQWlCO0FBQ3hELFlBQUksQ0FBQyxLQUFLLGVBQVYsRUFBMkI7QUFDdkIsaUJBQUssT0FBTCxDQUFhLEtBQWI7QUFDSDtBQUNKLEtBSkQ7QUFLQSw2QkFBeUIsU0FBekIsQ0FBbUMsT0FBbkMsR0FBNkMsVUFBVSxLQUFWLEVBQWlCO0FBQzFELFlBQUksUUFBUSxLQUFLLEtBQUwsRUFBWjtBQUNBLFlBQUksY0FBYyxLQUFLLFdBQXZCO0FBQ0EsWUFBSTtBQUNBLGdCQUFJLFNBQVMsS0FBSyxPQUFMLENBQWEsS0FBYixFQUFvQixLQUFwQixDQUFiO0FBQ0EsaUJBQUssZUFBTCxHQUF1QixJQUF2QjtBQUNBLGlCQUFLLEdBQUwsQ0FBUyxvQkFBb0IsaUJBQXBCLENBQXNDLElBQXRDLEVBQTRDLE1BQTVDLEVBQW9ELEtBQXBELEVBQTJELEtBQTNELENBQVQ7QUFDSCxTQUpELENBS0EsT0FBTyxHQUFQLEVBQVk7QUFDUix3QkFBWSxLQUFaLENBQWtCLEdBQWxCO0FBQ0g7QUFDSixLQVhEO0FBWUEsNkJBQXlCLFNBQXpCLENBQW1DLFNBQW5DLEdBQStDLFlBQVk7QUFDdkQsYUFBSyxZQUFMLEdBQW9CLElBQXBCO0FBQ0EsWUFBSSxDQUFDLEtBQUssZUFBVixFQUEyQjtBQUN2QixpQkFBSyxXQUFMLENBQWlCLFFBQWpCO0FBQ0g7QUFDSixLQUxEO0FBTUEsNkJBQXlCLFNBQXpCLENBQW1DLFVBQW5DLEdBQWdELFVBQVUsVUFBVixFQUFzQixVQUF0QixFQUFrQyxVQUFsQyxFQUE4QyxVQUE5QyxFQUEwRCxRQUExRCxFQUFvRTtBQUNoSCxZQUFJLEtBQUssSUFBVDtBQUFBLFlBQWUsaUJBQWlCLEdBQUcsY0FBbkM7QUFBQSxZQUFtRCxjQUFjLEdBQUcsV0FBcEU7QUFDQSxZQUFJLGNBQUosRUFBb0I7QUFDaEIsaUJBQUssZUFBTCxDQUFxQixVQUFyQixFQUFpQyxVQUFqQyxFQUE2QyxVQUE3QyxFQUF5RCxVQUF6RDtBQUNILFNBRkQsTUFHSztBQUNELHdCQUFZLElBQVosQ0FBaUIsVUFBakI7QUFDSDtBQUNKLEtBUkQ7QUFTQSw2QkFBeUIsU0FBekIsQ0FBbUMsZUFBbkMsR0FBcUQsVUFBVSxVQUFWLEVBQXNCLFVBQXRCLEVBQWtDLFVBQWxDLEVBQThDLFVBQTlDLEVBQTBEO0FBQzNHLFlBQUksS0FBSyxJQUFUO0FBQUEsWUFBZSxpQkFBaUIsR0FBRyxjQUFuQztBQUFBLFlBQW1ELGNBQWMsR0FBRyxXQUFwRTtBQUNBLFlBQUk7QUFDQSxnQkFBSSxTQUFTLGVBQWUsVUFBZixFQUEyQixVQUEzQixFQUF1QyxVQUF2QyxFQUFtRCxVQUFuRCxDQUFiO0FBQ0Esd0JBQVksSUFBWixDQUFpQixNQUFqQjtBQUNILFNBSEQsQ0FJQSxPQUFPLEdBQVAsRUFBWTtBQUNSLHdCQUFZLEtBQVosQ0FBa0IsR0FBbEI7QUFDSDtBQUNKLEtBVEQ7QUFVQSw2QkFBeUIsU0FBekIsQ0FBbUMsV0FBbkMsR0FBaUQsVUFBVSxHQUFWLEVBQWU7QUFDNUQsYUFBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLEdBQXZCO0FBQ0gsS0FGRDtBQUdBLDZCQUF5QixTQUF6QixDQUFtQyxjQUFuQyxHQUFvRCxVQUFVLFFBQVYsRUFBb0I7QUFDcEUsYUFBSyxNQUFMLENBQVksUUFBWjtBQUNBLGFBQUssZUFBTCxHQUF1QixLQUF2QjtBQUNBLFlBQUksS0FBSyxZQUFULEVBQXVCO0FBQ25CLGlCQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDSDtBQUNKLEtBTkQ7QUFPQSxXQUFPLHdCQUFQO0FBQ0gsQ0EvRCtCLENBK0Q5QixrQkFBa0IsZUEvRFksQ0FBaEM7QUFnRUE7OztBQ3pJQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQsRUFBaUIsSUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUMxQyxhQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBLFNBQVMsTUFBVCxDQUFnQixTQUFoQixFQUEyQixPQUEzQixFQUFvQztBQUNoQyxXQUFPLEtBQUssSUFBTCxDQUFVLElBQUksY0FBSixDQUFtQixTQUFuQixFQUE4QixPQUE5QixDQUFWLENBQVA7QUFDSDtBQUNELFFBQVEsTUFBUixHQUFpQixNQUFqQjtBQUNBLElBQUksaUJBQWtCLFlBQVk7QUFDOUIsYUFBUyxjQUFULENBQXdCLFNBQXhCLEVBQW1DLE9BQW5DLEVBQTRDO0FBQ3hDLGFBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNBLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDSDtBQUNELG1CQUFlLFNBQWYsQ0FBeUIsSUFBekIsR0FBZ0MsVUFBVSxVQUFWLEVBQXNCLE1BQXRCLEVBQThCO0FBQzFELGVBQU8sT0FBTyxTQUFQLENBQWlCLElBQUksZ0JBQUosQ0FBcUIsVUFBckIsRUFBaUMsS0FBSyxTQUF0QyxFQUFpRCxLQUFLLE9BQXRELENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxjQUFQO0FBQ0gsQ0FUcUIsRUFBdEI7QUFVQTs7Ozs7QUFLQSxJQUFJLG1CQUFvQixVQUFVLE1BQVYsRUFBa0I7QUFDdEMsY0FBVSxnQkFBVixFQUE0QixNQUE1QjtBQUNBLGFBQVMsZ0JBQVQsQ0FBMEIsV0FBMUIsRUFBdUMsU0FBdkMsRUFBa0QsT0FBbEQsRUFBMkQ7QUFDdkQsZUFBTyxJQUFQLENBQVksSUFBWixFQUFrQixXQUFsQjtBQUNBLGFBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNBLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxhQUFLLEtBQUwsR0FBYSxDQUFiO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0g7QUFDRDtBQUNBO0FBQ0EscUJBQWlCLFNBQWpCLENBQTJCLEtBQTNCLEdBQW1DLFVBQVUsS0FBVixFQUFpQjtBQUNoRCxZQUFJLE1BQUo7QUFDQSxZQUFJO0FBQ0EscUJBQVMsS0FBSyxTQUFMLENBQWUsSUFBZixDQUFvQixLQUFLLE9BQXpCLEVBQWtDLEtBQWxDLEVBQXlDLEtBQUssS0FBTCxFQUF6QyxDQUFUO0FBQ0gsU0FGRCxDQUdBLE9BQU8sR0FBUCxFQUFZO0FBQ1IsaUJBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixHQUF2QjtBQUNBO0FBQ0g7QUFDRCxZQUFJLE1BQUosRUFBWTtBQUNSLGlCQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsS0FBdEI7QUFDSDtBQUNKLEtBWkQ7QUFhQSxXQUFPLGdCQUFQO0FBQ0gsQ0F6QnVCLENBeUJ0QixhQUFhLFVBekJTLENBQXhCO0FBMEJBOzs7QUM1RkE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkLEVBQWlCLElBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFDMUMsYUFBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxlQUFlLFFBQVEsZUFBUixDQUFuQjtBQUNBLElBQUksaUJBQWlCLFFBQVEsaUJBQVIsQ0FBckI7QUFDQTs7Ozs7Ozs7QUFRQSxTQUFTLFFBQVQsQ0FBa0IsUUFBbEIsRUFBNEI7QUFDeEIsV0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFJLGVBQUosQ0FBb0IsUUFBcEIsQ0FBVixDQUFQO0FBQ0g7QUFDRCxRQUFRLFFBQVIsR0FBbUIsUUFBbkI7QUFDQSxJQUFJLGtCQUFtQixZQUFZO0FBQy9CLGFBQVMsZUFBVCxDQUF5QixRQUF6QixFQUFtQztBQUMvQixhQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDSDtBQUNELG9CQUFnQixTQUFoQixDQUEwQixJQUExQixHQUFpQyxVQUFVLFVBQVYsRUFBc0IsTUFBdEIsRUFBOEI7QUFDM0QsZUFBTyxPQUFPLFNBQVAsQ0FBaUIsSUFBSSxpQkFBSixDQUFzQixVQUF0QixFQUFrQyxLQUFLLFFBQXZDLENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxlQUFQO0FBQ0gsQ0FSc0IsRUFBdkI7QUFTQTs7Ozs7QUFLQSxJQUFJLG9CQUFxQixVQUFVLE1BQVYsRUFBa0I7QUFDdkMsY0FBVSxpQkFBVixFQUE2QixNQUE3QjtBQUNBLGFBQVMsaUJBQVQsQ0FBMkIsV0FBM0IsRUFBd0MsUUFBeEMsRUFBa0Q7QUFDOUMsZUFBTyxJQUFQLENBQVksSUFBWixFQUFrQixXQUFsQjtBQUNBLGFBQUssR0FBTCxDQUFTLElBQUksZUFBZSxZQUFuQixDQUFnQyxRQUFoQyxDQUFUO0FBQ0g7QUFDRCxXQUFPLGlCQUFQO0FBQ0gsQ0FQd0IsQ0FPdkIsYUFBYSxVQVBVLENBQXpCO0FBUUE7OztBQzFDQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQsRUFBaUIsSUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUMxQyxhQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDQSxTQUFTLEdBQVQsQ0FBYSxPQUFiLEVBQXNCLE9BQXRCLEVBQStCO0FBQzNCLFFBQUksT0FBTyxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQy9CLGNBQU0sSUFBSSxTQUFKLENBQWMsNERBQWQsQ0FBTjtBQUNIO0FBQ0QsV0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFJLFdBQUosQ0FBZ0IsT0FBaEIsRUFBeUIsT0FBekIsQ0FBVixDQUFQO0FBQ0g7QUFDRCxRQUFRLEdBQVIsR0FBYyxHQUFkO0FBQ0EsSUFBSSxjQUFlLFlBQVk7QUFDM0IsYUFBUyxXQUFULENBQXFCLE9BQXJCLEVBQThCLE9BQTlCLEVBQXVDO0FBQ25DLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0g7QUFDRCxnQkFBWSxTQUFaLENBQXNCLElBQXRCLEdBQTZCLFVBQVUsVUFBVixFQUFzQixNQUF0QixFQUE4QjtBQUN2RCxlQUFPLE9BQU8sU0FBUCxDQUFpQixJQUFJLGFBQUosQ0FBa0IsVUFBbEIsRUFBOEIsS0FBSyxPQUFuQyxFQUE0QyxLQUFLLE9BQWpELENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxXQUFQO0FBQ0gsQ0FUa0IsRUFBbkI7QUFVQSxRQUFRLFdBQVIsR0FBc0IsV0FBdEI7QUFDQTs7Ozs7QUFLQSxJQUFJLGdCQUFpQixVQUFVLE1BQVYsRUFBa0I7QUFDbkMsY0FBVSxhQUFWLEVBQXlCLE1BQXpCO0FBQ0EsYUFBUyxhQUFULENBQXVCLFdBQXZCLEVBQW9DLE9BQXBDLEVBQTZDLE9BQTdDLEVBQXNEO0FBQ2xELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsYUFBSyxLQUFMLEdBQWEsQ0FBYjtBQUNBLGFBQUssT0FBTCxHQUFlLFdBQVcsSUFBMUI7QUFDSDtBQUNEO0FBQ0E7QUFDQSxrQkFBYyxTQUFkLENBQXdCLEtBQXhCLEdBQWdDLFVBQVUsS0FBVixFQUFpQjtBQUM3QyxZQUFJLE1BQUo7QUFDQSxZQUFJO0FBQ0EscUJBQVMsS0FBSyxPQUFMLENBQWEsSUFBYixDQUFrQixLQUFLLE9BQXZCLEVBQWdDLEtBQWhDLEVBQXVDLEtBQUssS0FBTCxFQUF2QyxDQUFUO0FBQ0gsU0FGRCxDQUdBLE9BQU8sR0FBUCxFQUFZO0FBQ1IsaUJBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixHQUF2QjtBQUNBO0FBQ0g7QUFDRCxhQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsTUFBdEI7QUFDSCxLQVZEO0FBV0EsV0FBTyxhQUFQO0FBQ0gsQ0F0Qm9CLENBc0JuQixhQUFhLFVBdEJNLENBQXJCO0FBdUJBOzs7QUN0RkE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkLEVBQWlCLElBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFDMUMsYUFBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxvQkFBb0IsUUFBUSxvQkFBUixDQUF4QjtBQUNBLElBQUksc0JBQXNCLFFBQVEsMkJBQVIsQ0FBMUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0Q0EsU0FBUyxRQUFULENBQWtCLFVBQWxCLEVBQThCO0FBQzFCLFFBQUksZUFBZSxLQUFLLENBQXhCLEVBQTJCO0FBQUUscUJBQWEsT0FBTyxpQkFBcEI7QUFBd0M7QUFDckUsV0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFJLGdCQUFKLENBQXFCLFVBQXJCLENBQVYsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxRQUFSLEdBQW1CLFFBQW5CO0FBQ0EsSUFBSSxtQkFBb0IsWUFBWTtBQUNoQyxhQUFTLGdCQUFULENBQTBCLFVBQTFCLEVBQXNDO0FBQ2xDLGFBQUssVUFBTCxHQUFrQixVQUFsQjtBQUNIO0FBQ0QscUJBQWlCLFNBQWpCLENBQTJCLElBQTNCLEdBQWtDLFVBQVUsUUFBVixFQUFvQixNQUFwQixFQUE0QjtBQUMxRCxlQUFPLE9BQU8sU0FBUCxDQUFpQixJQUFJLGtCQUFKLENBQXVCLFFBQXZCLEVBQWlDLEtBQUssVUFBdEMsQ0FBakIsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPLGdCQUFQO0FBQ0gsQ0FSdUIsRUFBeEI7QUFTQSxRQUFRLGdCQUFSLEdBQTJCLGdCQUEzQjtBQUNBOzs7OztBQUtBLElBQUkscUJBQXNCLFVBQVUsTUFBVixFQUFrQjtBQUN4QyxjQUFVLGtCQUFWLEVBQThCLE1BQTlCO0FBQ0EsYUFBUyxrQkFBVCxDQUE0QixXQUE1QixFQUF5QyxVQUF6QyxFQUFxRDtBQUNqRCxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLFVBQWxCO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLEtBQXBCO0FBQ0EsYUFBSyxNQUFMLEdBQWMsRUFBZDtBQUNBLGFBQUssTUFBTCxHQUFjLENBQWQ7QUFDSDtBQUNELHVCQUFtQixTQUFuQixDQUE2QixLQUE3QixHQUFxQyxVQUFVLFVBQVYsRUFBc0I7QUFDdkQsWUFBSSxLQUFLLE1BQUwsR0FBYyxLQUFLLFVBQXZCLEVBQW1DO0FBQy9CLGlCQUFLLE1BQUw7QUFDQSxpQkFBSyxHQUFMLENBQVMsb0JBQW9CLGlCQUFwQixDQUFzQyxJQUF0QyxFQUE0QyxVQUE1QyxDQUFUO0FBQ0gsU0FIRCxNQUlLO0FBQ0QsaUJBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsVUFBakI7QUFDSDtBQUNKLEtBUkQ7QUFTQSx1QkFBbUIsU0FBbkIsQ0FBNkIsU0FBN0IsR0FBeUMsWUFBWTtBQUNqRCxhQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxZQUFJLEtBQUssTUFBTCxLQUFnQixDQUFoQixJQUFxQixLQUFLLE1BQUwsQ0FBWSxNQUFaLEtBQXVCLENBQWhELEVBQW1EO0FBQy9DLGlCQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDSDtBQUNKLEtBTEQ7QUFNQSx1QkFBbUIsU0FBbkIsQ0FBNkIsY0FBN0IsR0FBOEMsVUFBVSxRQUFWLEVBQW9CO0FBQzlELFlBQUksU0FBUyxLQUFLLE1BQWxCO0FBQ0EsYUFBSyxNQUFMLENBQVksUUFBWjtBQUNBLGFBQUssTUFBTDtBQUNBLFlBQUksT0FBTyxNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ25CLGlCQUFLLEtBQUwsQ0FBVyxPQUFPLEtBQVAsRUFBWDtBQUNILFNBRkQsTUFHSyxJQUFJLEtBQUssTUFBTCxLQUFnQixDQUFoQixJQUFxQixLQUFLLFlBQTlCLEVBQTRDO0FBQzdDLGlCQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDSDtBQUNKLEtBVkQ7QUFXQSxXQUFPLGtCQUFQO0FBQ0gsQ0FwQ3lCLENBb0N4QixrQkFBa0IsZUFwQ00sQ0FBMUI7QUFxQ0EsUUFBUSxrQkFBUixHQUE2QixrQkFBN0I7QUFDQTs7O0FDOUdBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZCxFQUFpQixJQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQzFDLGFBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksc0JBQXNCLFFBQVEsMkJBQVIsQ0FBMUI7QUFDQSxJQUFJLG9CQUFvQixRQUFRLG9CQUFSLENBQXhCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBEQSxTQUFTLFFBQVQsQ0FBa0IsT0FBbEIsRUFBMkIsY0FBM0IsRUFBMkMsVUFBM0MsRUFBdUQ7QUFDbkQsUUFBSSxlQUFlLEtBQUssQ0FBeEIsRUFBMkI7QUFBRSxxQkFBYSxPQUFPLGlCQUFwQjtBQUF3QztBQUNyRSxRQUFJLE9BQU8sY0FBUCxLQUEwQixRQUE5QixFQUF3QztBQUNwQyxxQkFBYSxjQUFiO0FBQ0EseUJBQWlCLElBQWpCO0FBQ0g7QUFDRCxXQUFPLEtBQUssSUFBTCxDQUFVLElBQUksZ0JBQUosQ0FBcUIsT0FBckIsRUFBOEIsY0FBOUIsRUFBOEMsVUFBOUMsQ0FBVixDQUFQO0FBQ0g7QUFDRCxRQUFRLFFBQVIsR0FBbUIsUUFBbkI7QUFDQSxJQUFJLG1CQUFvQixZQUFZO0FBQ2hDLGFBQVMsZ0JBQVQsQ0FBMEIsT0FBMUIsRUFBbUMsY0FBbkMsRUFBbUQsVUFBbkQsRUFBK0Q7QUFDM0QsWUFBSSxlQUFlLEtBQUssQ0FBeEIsRUFBMkI7QUFBRSx5QkFBYSxPQUFPLGlCQUFwQjtBQUF3QztBQUNyRSxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsYUFBSyxjQUFMLEdBQXNCLGNBQXRCO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLFVBQWxCO0FBQ0g7QUFDRCxxQkFBaUIsU0FBakIsQ0FBMkIsSUFBM0IsR0FBa0MsVUFBVSxRQUFWLEVBQW9CLE1BQXBCLEVBQTRCO0FBQzFELGVBQU8sT0FBTyxTQUFQLENBQWlCLElBQUksa0JBQUosQ0FBdUIsUUFBdkIsRUFBaUMsS0FBSyxPQUF0QyxFQUErQyxLQUFLLGNBQXBELEVBQW9FLEtBQUssVUFBekUsQ0FBakIsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPLGdCQUFQO0FBQ0gsQ0FYdUIsRUFBeEI7QUFZQSxRQUFRLGdCQUFSLEdBQTJCLGdCQUEzQjtBQUNBOzs7OztBQUtBLElBQUkscUJBQXNCLFVBQVUsTUFBVixFQUFrQjtBQUN4QyxjQUFVLGtCQUFWLEVBQThCLE1BQTlCO0FBQ0EsYUFBUyxrQkFBVCxDQUE0QixXQUE1QixFQUF5QyxPQUF6QyxFQUFrRCxjQUFsRCxFQUFrRSxVQUFsRSxFQUE4RTtBQUMxRSxZQUFJLGVBQWUsS0FBSyxDQUF4QixFQUEyQjtBQUFFLHlCQUFhLE9BQU8saUJBQXBCO0FBQXdDO0FBQ3JFLGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsYUFBSyxjQUFMLEdBQXNCLGNBQXRCO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLFVBQWxCO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLEtBQXBCO0FBQ0EsYUFBSyxNQUFMLEdBQWMsRUFBZDtBQUNBLGFBQUssTUFBTCxHQUFjLENBQWQ7QUFDQSxhQUFLLEtBQUwsR0FBYSxDQUFiO0FBQ0g7QUFDRCx1QkFBbUIsU0FBbkIsQ0FBNkIsS0FBN0IsR0FBcUMsVUFBVSxLQUFWLEVBQWlCO0FBQ2xELFlBQUksS0FBSyxNQUFMLEdBQWMsS0FBSyxVQUF2QixFQUFtQztBQUMvQixpQkFBSyxRQUFMLENBQWMsS0FBZDtBQUNILFNBRkQsTUFHSztBQUNELGlCQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLEtBQWpCO0FBQ0g7QUFDSixLQVBEO0FBUUEsdUJBQW1CLFNBQW5CLENBQTZCLFFBQTdCLEdBQXdDLFVBQVUsS0FBVixFQUFpQjtBQUNyRCxZQUFJLE1BQUo7QUFDQSxZQUFJLFFBQVEsS0FBSyxLQUFMLEVBQVo7QUFDQSxZQUFJO0FBQ0EscUJBQVMsS0FBSyxPQUFMLENBQWEsS0FBYixFQUFvQixLQUFwQixDQUFUO0FBQ0gsU0FGRCxDQUdBLE9BQU8sR0FBUCxFQUFZO0FBQ1IsaUJBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixHQUF2QjtBQUNBO0FBQ0g7QUFDRCxhQUFLLE1BQUw7QUFDQSxhQUFLLFNBQUwsQ0FBZSxNQUFmLEVBQXVCLEtBQXZCLEVBQThCLEtBQTlCO0FBQ0gsS0FaRDtBQWFBLHVCQUFtQixTQUFuQixDQUE2QixTQUE3QixHQUF5QyxVQUFVLEdBQVYsRUFBZSxLQUFmLEVBQXNCLEtBQXRCLEVBQTZCO0FBQ2xFLGFBQUssR0FBTCxDQUFTLG9CQUFvQixpQkFBcEIsQ0FBc0MsSUFBdEMsRUFBNEMsR0FBNUMsRUFBaUQsS0FBakQsRUFBd0QsS0FBeEQsQ0FBVDtBQUNILEtBRkQ7QUFHQSx1QkFBbUIsU0FBbkIsQ0FBNkIsU0FBN0IsR0FBeUMsWUFBWTtBQUNqRCxhQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxZQUFJLEtBQUssTUFBTCxLQUFnQixDQUFoQixJQUFxQixLQUFLLE1BQUwsQ0FBWSxNQUFaLEtBQXVCLENBQWhELEVBQW1EO0FBQy9DLGlCQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDSDtBQUNKLEtBTEQ7QUFNQSx1QkFBbUIsU0FBbkIsQ0FBNkIsVUFBN0IsR0FBMEMsVUFBVSxVQUFWLEVBQXNCLFVBQXRCLEVBQWtDLFVBQWxDLEVBQThDLFVBQTlDLEVBQTBELFFBQTFELEVBQW9FO0FBQzFHLFlBQUksS0FBSyxjQUFULEVBQXlCO0FBQ3JCLGlCQUFLLHFCQUFMLENBQTJCLFVBQTNCLEVBQXVDLFVBQXZDLEVBQW1ELFVBQW5ELEVBQStELFVBQS9EO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsaUJBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixVQUF0QjtBQUNIO0FBQ0osS0FQRDtBQVFBLHVCQUFtQixTQUFuQixDQUE2QixxQkFBN0IsR0FBcUQsVUFBVSxVQUFWLEVBQXNCLFVBQXRCLEVBQWtDLFVBQWxDLEVBQThDLFVBQTlDLEVBQTBEO0FBQzNHLFlBQUksTUFBSjtBQUNBLFlBQUk7QUFDQSxxQkFBUyxLQUFLLGNBQUwsQ0FBb0IsVUFBcEIsRUFBZ0MsVUFBaEMsRUFBNEMsVUFBNUMsRUFBd0QsVUFBeEQsQ0FBVDtBQUNILFNBRkQsQ0FHQSxPQUFPLEdBQVAsRUFBWTtBQUNSLGlCQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBdUIsR0FBdkI7QUFDQTtBQUNIO0FBQ0QsYUFBSyxXQUFMLENBQWlCLElBQWpCLENBQXNCLE1BQXRCO0FBQ0gsS0FWRDtBQVdBLHVCQUFtQixTQUFuQixDQUE2QixjQUE3QixHQUE4QyxVQUFVLFFBQVYsRUFBb0I7QUFDOUQsWUFBSSxTQUFTLEtBQUssTUFBbEI7QUFDQSxhQUFLLE1BQUwsQ0FBWSxRQUFaO0FBQ0EsYUFBSyxNQUFMO0FBQ0EsWUFBSSxPQUFPLE1BQVAsR0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkIsaUJBQUssS0FBTCxDQUFXLE9BQU8sS0FBUCxFQUFYO0FBQ0gsU0FGRCxNQUdLLElBQUksS0FBSyxNQUFMLEtBQWdCLENBQWhCLElBQXFCLEtBQUssWUFBOUIsRUFBNEM7QUFDN0MsaUJBQUssV0FBTCxDQUFpQixRQUFqQjtBQUNIO0FBQ0osS0FWRDtBQVdBLFdBQU8sa0JBQVA7QUFDSCxDQTFFeUIsQ0EwRXhCLGtCQUFrQixlQTFFTSxDQUExQjtBQTJFQSxRQUFRLGtCQUFSLEdBQTZCLGtCQUE3QjtBQUNBOzs7QUMxS0E7O0FBQ0EsSUFBSSwwQkFBMEIsUUFBUSxxQ0FBUixDQUE5QjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEsU0FBUyxTQUFULENBQW1CLHVCQUFuQixFQUE0QyxRQUE1QyxFQUFzRDtBQUNsRCxRQUFJLGNBQUo7QUFDQSxRQUFJLE9BQU8sdUJBQVAsS0FBbUMsVUFBdkMsRUFBbUQ7QUFDL0MseUJBQWlCLHVCQUFqQjtBQUNILEtBRkQsTUFHSztBQUNELHlCQUFpQixTQUFTLGNBQVQsR0FBMEI7QUFDdkMsbUJBQU8sdUJBQVA7QUFDSCxTQUZEO0FBR0g7QUFDRCxRQUFJLE9BQU8sUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNoQyxlQUFPLEtBQUssSUFBTCxDQUFVLElBQUksaUJBQUosQ0FBc0IsY0FBdEIsRUFBc0MsUUFBdEMsQ0FBVixDQUFQO0FBQ0g7QUFDRCxRQUFJLGNBQWMsT0FBTyxNQUFQLENBQWMsSUFBZCxFQUFvQix3QkFBd0IsK0JBQTVDLENBQWxCO0FBQ0EsZ0JBQVksTUFBWixHQUFxQixJQUFyQjtBQUNBLGdCQUFZLGNBQVosR0FBNkIsY0FBN0I7QUFDQSxXQUFPLFdBQVA7QUFDSDtBQUNELFFBQVEsU0FBUixHQUFvQixTQUFwQjtBQUNBLElBQUksb0JBQXFCLFlBQVk7QUFDakMsYUFBUyxpQkFBVCxDQUEyQixjQUEzQixFQUEyQyxRQUEzQyxFQUFxRDtBQUNqRCxhQUFLLGNBQUwsR0FBc0IsY0FBdEI7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDSDtBQUNELHNCQUFrQixTQUFsQixDQUE0QixJQUE1QixHQUFtQyxVQUFVLFVBQVYsRUFBc0IsTUFBdEIsRUFBOEI7QUFDN0QsWUFBSSxXQUFXLEtBQUssUUFBcEI7QUFDQSxZQUFJLFVBQVUsS0FBSyxjQUFMLEVBQWQ7QUFDQSxZQUFJLGVBQWUsU0FBUyxPQUFULEVBQWtCLFNBQWxCLENBQTRCLFVBQTVCLENBQW5CO0FBQ0EscUJBQWEsR0FBYixDQUFpQixPQUFPLFNBQVAsQ0FBaUIsT0FBakIsQ0FBakI7QUFDQSxlQUFPLFlBQVA7QUFDSCxLQU5EO0FBT0EsV0FBTyxpQkFBUDtBQUNILENBYndCLEVBQXpCO0FBY0EsUUFBUSxpQkFBUixHQUE0QixpQkFBNUI7QUFDQTs7O0FDeERBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZCxFQUFpQixJQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQzFDLGFBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksZUFBZSxRQUFRLGVBQVIsQ0FBbkI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQ0EsU0FBUyxRQUFULEdBQW9CO0FBQ2hCLFdBQU8sS0FBSyxJQUFMLENBQVUsSUFBSSxnQkFBSixFQUFWLENBQVA7QUFDSDtBQUNELFFBQVEsUUFBUixHQUFtQixRQUFuQjtBQUNBLElBQUksbUJBQW9CLFlBQVk7QUFDaEMsYUFBUyxnQkFBVCxHQUE0QixDQUMzQjtBQUNELHFCQUFpQixTQUFqQixDQUEyQixJQUEzQixHQUFrQyxVQUFVLFVBQVYsRUFBc0IsTUFBdEIsRUFBOEI7QUFDNUQsZUFBTyxPQUFPLFNBQVAsQ0FBaUIsSUFBSSxrQkFBSixDQUF1QixVQUF2QixDQUFqQixDQUFQO0FBQ0gsS0FGRDtBQUdBLFdBQU8sZ0JBQVA7QUFDSCxDQVB1QixFQUF4QjtBQVFBOzs7OztBQUtBLElBQUkscUJBQXNCLFVBQVUsTUFBVixFQUFrQjtBQUN4QyxjQUFVLGtCQUFWLEVBQThCLE1BQTlCO0FBQ0EsYUFBUyxrQkFBVCxDQUE0QixXQUE1QixFQUF5QztBQUNyQyxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsYUFBSyxPQUFMLEdBQWUsS0FBZjtBQUNIO0FBQ0QsdUJBQW1CLFNBQW5CLENBQTZCLEtBQTdCLEdBQXFDLFVBQVUsS0FBVixFQUFpQjtBQUNsRCxZQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNkLGlCQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsQ0FBQyxLQUFLLElBQU4sRUFBWSxLQUFaLENBQXRCO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsaUJBQUssT0FBTCxHQUFlLElBQWY7QUFDSDtBQUNELGFBQUssSUFBTCxHQUFZLEtBQVo7QUFDSCxLQVJEO0FBU0EsV0FBTyxrQkFBUDtBQUNILENBaEJ5QixDQWdCeEIsYUFBYSxVQWhCVyxDQUExQjtBQWlCQTs7O0FDNUVBOztBQUNBLElBQUksY0FBYyxRQUFRLGFBQVIsQ0FBbEI7QUFDQSxJQUFJLFlBQVksUUFBUSxZQUFSLENBQWhCO0FBQ0EsU0FBUyxtQkFBVCxHQUErQjtBQUMzQixXQUFPLElBQUksVUFBVSxPQUFkLEVBQVA7QUFDSDtBQUNEOzs7Ozs7Ozs7Ozs7QUFZQSxTQUFTLEtBQVQsR0FBaUI7QUFDYixXQUFPLFlBQVksU0FBWixDQUFzQixJQUF0QixDQUEyQixJQUEzQixFQUFpQyxtQkFBakMsRUFBc0QsUUFBdEQsRUFBUDtBQUNIO0FBQ0QsUUFBUSxLQUFSLEdBQWdCLEtBQWhCO0FBQ0E7QUFDQTs7O0FDdkJBOztBQUNBLElBQUksb0JBQW9CLFFBQVEsK0JBQVIsQ0FBeEI7QUFDQSxJQUFJLHFCQUFxQixRQUFRLGdDQUFSLENBQXpCO0FBQ0EsSUFBSSxvQkFBb0IsUUFBUSwrQkFBUixDQUF4QjtBQUNBLElBQUksV0FBVyxRQUFRLFVBQVIsQ0FBZjtBQUNBLElBQUksZ0JBQWdCLFFBQVEscUJBQVIsQ0FBcEI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBLFNBQVMsU0FBVCxHQUFxQjtBQUNqQixRQUFJLFFBQVEsRUFBWjtBQUNBLFNBQUssSUFBSSxLQUFLLENBQWQsRUFBaUIsS0FBSyxVQUFVLE1BQWhDLEVBQXdDLElBQXhDLEVBQThDO0FBQzFDLGNBQU0sS0FBSyxDQUFYLElBQWdCLFVBQVUsRUFBVixDQUFoQjtBQUNIO0FBQ0QsUUFBSSxZQUFZLE1BQU0sTUFBTSxNQUFOLEdBQWUsQ0FBckIsQ0FBaEI7QUFDQSxRQUFJLGNBQWMsV0FBZCxDQUEwQixTQUExQixDQUFKLEVBQTBDO0FBQ3RDLGNBQU0sR0FBTjtBQUNILEtBRkQsTUFHSztBQUNELG9CQUFZLElBQVo7QUFDSDtBQUNELFFBQUksTUFBTSxNQUFNLE1BQWhCO0FBQ0EsUUFBSSxRQUFRLENBQVosRUFBZTtBQUNYLGVBQU8sU0FBUyxZQUFULENBQXNCLElBQUksbUJBQW1CLGdCQUF2QixDQUF3QyxNQUFNLENBQU4sQ0FBeEMsRUFBa0QsU0FBbEQsQ0FBdEIsRUFBb0YsSUFBcEYsQ0FBUDtBQUNILEtBRkQsTUFHSyxJQUFJLE1BQU0sQ0FBVixFQUFhO0FBQ2QsZUFBTyxTQUFTLFlBQVQsQ0FBc0IsSUFBSSxrQkFBa0IsZUFBdEIsQ0FBc0MsS0FBdEMsRUFBNkMsU0FBN0MsQ0FBdEIsRUFBK0UsSUFBL0UsQ0FBUDtBQUNILEtBRkksTUFHQTtBQUNELGVBQU8sU0FBUyxZQUFULENBQXNCLElBQUksa0JBQWtCLGVBQXRCLENBQXNDLFNBQXRDLENBQXRCLEVBQXdFLElBQXhFLENBQVA7QUFDSDtBQUNKO0FBQ0QsUUFBUSxTQUFSLEdBQW9CLFNBQXBCO0FBQ0E7OztBQzdDQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQsRUFBaUIsSUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUMxQyxhQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLG9CQUFvQixRQUFRLG9CQUFSLENBQXhCO0FBQ0EsSUFBSSxzQkFBc0IsUUFBUSwyQkFBUixDQUExQjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0NBLFNBQVMsU0FBVCxDQUFtQixPQUFuQixFQUE0QixjQUE1QixFQUE0QztBQUN4QyxXQUFPLEtBQUssSUFBTCxDQUFVLElBQUksaUJBQUosQ0FBc0IsT0FBdEIsRUFBK0IsY0FBL0IsQ0FBVixDQUFQO0FBQ0g7QUFDRCxRQUFRLFNBQVIsR0FBb0IsU0FBcEI7QUFDQSxJQUFJLG9CQUFxQixZQUFZO0FBQ2pDLGFBQVMsaUJBQVQsQ0FBMkIsT0FBM0IsRUFBb0MsY0FBcEMsRUFBb0Q7QUFDaEQsYUFBSyxPQUFMLEdBQWUsT0FBZjtBQUNBLGFBQUssY0FBTCxHQUFzQixjQUF0QjtBQUNIO0FBQ0Qsc0JBQWtCLFNBQWxCLENBQTRCLElBQTVCLEdBQW1DLFVBQVUsVUFBVixFQUFzQixNQUF0QixFQUE4QjtBQUM3RCxlQUFPLE9BQU8sU0FBUCxDQUFpQixJQUFJLG1CQUFKLENBQXdCLFVBQXhCLEVBQW9DLEtBQUssT0FBekMsRUFBa0QsS0FBSyxjQUF2RCxDQUFqQixDQUFQO0FBQ0gsS0FGRDtBQUdBLFdBQU8saUJBQVA7QUFDSCxDQVR3QixFQUF6QjtBQVVBOzs7OztBQUtBLElBQUksc0JBQXVCLFVBQVUsTUFBVixFQUFrQjtBQUN6QyxjQUFVLG1CQUFWLEVBQStCLE1BQS9CO0FBQ0EsYUFBUyxtQkFBVCxDQUE2QixXQUE3QixFQUEwQyxPQUExQyxFQUFtRCxjQUFuRCxFQUFtRTtBQUMvRCxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsYUFBSyxPQUFMLEdBQWUsT0FBZjtBQUNBLGFBQUssY0FBTCxHQUFzQixjQUF0QjtBQUNBLGFBQUssS0FBTCxHQUFhLENBQWI7QUFDSDtBQUNELHdCQUFvQixTQUFwQixDQUE4QixLQUE5QixHQUFzQyxVQUFVLEtBQVYsRUFBaUI7QUFDbkQsWUFBSSxNQUFKO0FBQ0EsWUFBSSxRQUFRLEtBQUssS0FBTCxFQUFaO0FBQ0EsWUFBSTtBQUNBLHFCQUFTLEtBQUssT0FBTCxDQUFhLEtBQWIsRUFBb0IsS0FBcEIsQ0FBVDtBQUNILFNBRkQsQ0FHQSxPQUFPLEtBQVAsRUFBYztBQUNWLGlCQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBdUIsS0FBdkI7QUFDQTtBQUNIO0FBQ0QsYUFBSyxTQUFMLENBQWUsTUFBZixFQUF1QixLQUF2QixFQUE4QixLQUE5QjtBQUNILEtBWEQ7QUFZQSx3QkFBb0IsU0FBcEIsQ0FBOEIsU0FBOUIsR0FBMEMsVUFBVSxNQUFWLEVBQWtCLEtBQWxCLEVBQXlCLEtBQXpCLEVBQWdDO0FBQ3RFLFlBQUksb0JBQW9CLEtBQUssaUJBQTdCO0FBQ0EsWUFBSSxpQkFBSixFQUF1QjtBQUNuQiw4QkFBa0IsV0FBbEI7QUFDSDtBQUNELGFBQUssR0FBTCxDQUFTLEtBQUssaUJBQUwsR0FBeUIsb0JBQW9CLGlCQUFwQixDQUFzQyxJQUF0QyxFQUE0QyxNQUE1QyxFQUFvRCxLQUFwRCxFQUEyRCxLQUEzRCxDQUFsQztBQUNILEtBTkQ7QUFPQSx3QkFBb0IsU0FBcEIsQ0FBOEIsU0FBOUIsR0FBMEMsWUFBWTtBQUNsRCxZQUFJLG9CQUFvQixLQUFLLGlCQUE3QjtBQUNBLFlBQUksQ0FBQyxpQkFBRCxJQUFzQixrQkFBa0IsTUFBNUMsRUFBb0Q7QUFDaEQsbUJBQU8sU0FBUCxDQUFpQixTQUFqQixDQUEyQixJQUEzQixDQUFnQyxJQUFoQztBQUNIO0FBQ0osS0FMRDtBQU1BLHdCQUFvQixTQUFwQixDQUE4QixZQUE5QixHQUE2QyxZQUFZO0FBQ3JELGFBQUssaUJBQUwsR0FBeUIsSUFBekI7QUFDSCxLQUZEO0FBR0Esd0JBQW9CLFNBQXBCLENBQThCLGNBQTlCLEdBQStDLFVBQVUsUUFBVixFQUFvQjtBQUMvRCxhQUFLLE1BQUwsQ0FBWSxRQUFaO0FBQ0EsYUFBSyxpQkFBTCxHQUF5QixJQUF6QjtBQUNBLFlBQUksS0FBSyxTQUFULEVBQW9CO0FBQ2hCLG1CQUFPLFNBQVAsQ0FBaUIsU0FBakIsQ0FBMkIsSUFBM0IsQ0FBZ0MsSUFBaEM7QUFDSDtBQUNKLEtBTkQ7QUFPQSx3QkFBb0IsU0FBcEIsQ0FBOEIsVUFBOUIsR0FBMkMsVUFBVSxVQUFWLEVBQXNCLFVBQXRCLEVBQWtDLFVBQWxDLEVBQThDLFVBQTlDLEVBQTBELFFBQTFELEVBQW9FO0FBQzNHLFlBQUksS0FBSyxjQUFULEVBQXlCO0FBQ3JCLGlCQUFLLGNBQUwsQ0FBb0IsVUFBcEIsRUFBZ0MsVUFBaEMsRUFBNEMsVUFBNUMsRUFBd0QsVUFBeEQ7QUFDSCxTQUZELE1BR0s7QUFDRCxpQkFBSyxXQUFMLENBQWlCLElBQWpCLENBQXNCLFVBQXRCO0FBQ0g7QUFDSixLQVBEO0FBUUEsd0JBQW9CLFNBQXBCLENBQThCLGNBQTlCLEdBQStDLFVBQVUsVUFBVixFQUFzQixVQUF0QixFQUFrQyxVQUFsQyxFQUE4QyxVQUE5QyxFQUEwRDtBQUNyRyxZQUFJLE1BQUo7QUFDQSxZQUFJO0FBQ0EscUJBQVMsS0FBSyxjQUFMLENBQW9CLFVBQXBCLEVBQWdDLFVBQWhDLEVBQTRDLFVBQTVDLEVBQXdELFVBQXhELENBQVQ7QUFDSCxTQUZELENBR0EsT0FBTyxHQUFQLEVBQVk7QUFDUixpQkFBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLEdBQXZCO0FBQ0E7QUFDSDtBQUNELGFBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixNQUF0QjtBQUNILEtBVkQ7QUFXQSxXQUFPLG1CQUFQO0FBQ0gsQ0EvRDBCLENBK0R6QixrQkFBa0IsZUEvRE8sQ0FBM0I7QUFnRUE7OztBQzNJQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQsRUFBaUIsSUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUMxQyxhQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLG9CQUFvQixRQUFRLG9CQUFSLENBQXhCO0FBQ0EsSUFBSSxzQkFBc0IsUUFBUSwyQkFBUixDQUExQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0EsU0FBUyxTQUFULENBQW1CLFFBQW5CLEVBQTZCO0FBQ3pCLFdBQU8sS0FBSyxJQUFMLENBQVUsSUFBSSxpQkFBSixDQUFzQixRQUF0QixDQUFWLENBQVA7QUFDSDtBQUNELFFBQVEsU0FBUixHQUFvQixTQUFwQjtBQUNBLElBQUksb0JBQXFCLFlBQVk7QUFDakMsYUFBUyxpQkFBVCxDQUEyQixRQUEzQixFQUFxQztBQUNqQyxhQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDSDtBQUNELHNCQUFrQixTQUFsQixDQUE0QixJQUE1QixHQUFtQyxVQUFVLFVBQVYsRUFBc0IsTUFBdEIsRUFBOEI7QUFDN0QsZUFBTyxPQUFPLFNBQVAsQ0FBaUIsSUFBSSxtQkFBSixDQUF3QixVQUF4QixFQUFvQyxLQUFLLFFBQXpDLENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxpQkFBUDtBQUNILENBUndCLEVBQXpCO0FBU0E7Ozs7O0FBS0EsSUFBSSxzQkFBdUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3pDLGNBQVUsbUJBQVYsRUFBK0IsTUFBL0I7QUFDQSxhQUFTLG1CQUFULENBQTZCLFdBQTdCLEVBQTBDLFFBQTFDLEVBQW9EO0FBQ2hELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxhQUFLLEdBQUwsQ0FBUyxvQkFBb0IsaUJBQXBCLENBQXNDLElBQXRDLEVBQTRDLFFBQTVDLENBQVQ7QUFDSDtBQUNELHdCQUFvQixTQUFwQixDQUE4QixVQUE5QixHQUEyQyxVQUFVLFVBQVYsRUFBc0IsVUFBdEIsRUFBa0MsVUFBbEMsRUFBOEMsVUFBOUMsRUFBMEQsUUFBMUQsRUFBb0U7QUFDM0csYUFBSyxRQUFMO0FBQ0gsS0FGRDtBQUdBLHdCQUFvQixTQUFwQixDQUE4QixjQUE5QixHQUErQyxZQUFZO0FBQ3ZEO0FBQ0gsS0FGRDtBQUdBLFdBQU8sbUJBQVA7QUFDSCxDQWQwQixDQWN6QixrQkFBa0IsZUFkTyxDQUEzQjtBQWVBOzs7QUMxRUE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkLEVBQWlCLElBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFDMUMsYUFBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxvQkFBb0IsUUFBUSwrQkFBUixDQUF4QjtBQUNBLElBQUksWUFBWSxRQUFRLGlCQUFSLENBQWhCO0FBQ0EsSUFBSSxlQUFlLFFBQVEsZUFBUixDQUFuQjtBQUNBLElBQUksb0JBQW9CLFFBQVEsb0JBQVIsQ0FBeEI7QUFDQSxJQUFJLHNCQUFzQixRQUFRLDJCQUFSLENBQTFCO0FBQ0EsSUFBSSxhQUFhLFFBQVEsb0JBQVIsQ0FBakI7QUFDQTtBQUNBOzs7Ozs7QUFNQSxTQUFTLFFBQVQsR0FBb0I7QUFDaEIsUUFBSSxjQUFjLEVBQWxCO0FBQ0EsU0FBSyxJQUFJLEtBQUssQ0FBZCxFQUFpQixLQUFLLFVBQVUsTUFBaEMsRUFBd0MsSUFBeEMsRUFBOEM7QUFDMUMsb0JBQVksS0FBSyxDQUFqQixJQUFzQixVQUFVLEVBQVYsQ0FBdEI7QUFDSDtBQUNELFdBQU8sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFVBQVUsS0FBVixDQUFnQixLQUFLLENBQXJCLEVBQXdCLENBQUMsSUFBRCxFQUFPLE1BQVAsQ0FBYyxXQUFkLENBQXhCLENBQWYsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxRQUFSLEdBQW1CLFFBQW5CO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQSxTQUFTLFNBQVQsR0FBcUI7QUFDakIsUUFBSSxjQUFjLEVBQWxCO0FBQ0EsU0FBSyxJQUFJLEtBQUssQ0FBZCxFQUFpQixLQUFLLFVBQVUsTUFBaEMsRUFBd0MsSUFBeEMsRUFBOEM7QUFDMUMsb0JBQVksS0FBSyxDQUFqQixJQUFzQixVQUFVLEVBQVYsQ0FBdEI7QUFDSDtBQUNELFFBQUksVUFBVSxZQUFZLFlBQVksTUFBWixHQUFxQixDQUFqQyxDQUFkO0FBQ0EsUUFBSSxPQUFPLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDL0Isb0JBQVksR0FBWjtBQUNIO0FBQ0QsV0FBTyxJQUFJLGtCQUFrQixlQUF0QixDQUFzQyxXQUF0QyxFQUFtRCxJQUFuRCxDQUF3RCxJQUFJLFdBQUosQ0FBZ0IsT0FBaEIsQ0FBeEQsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxTQUFSLEdBQW9CLFNBQXBCO0FBQ0EsSUFBSSxjQUFlLFlBQVk7QUFDM0IsYUFBUyxXQUFULENBQXFCLE9BQXJCLEVBQThCO0FBQzFCLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDSDtBQUNELGdCQUFZLFNBQVosQ0FBc0IsSUFBdEIsR0FBNkIsVUFBVSxVQUFWLEVBQXNCLE1BQXRCLEVBQThCO0FBQ3ZELGVBQU8sT0FBTyxTQUFQLENBQWlCLElBQUksYUFBSixDQUFrQixVQUFsQixFQUE4QixLQUFLLE9BQW5DLENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxXQUFQO0FBQ0gsQ0FSa0IsRUFBbkI7QUFTQSxRQUFRLFdBQVIsR0FBc0IsV0FBdEI7QUFDQTs7Ozs7QUFLQSxJQUFJLGdCQUFpQixVQUFVLE1BQVYsRUFBa0I7QUFDbkMsY0FBVSxhQUFWLEVBQXlCLE1BQXpCO0FBQ0EsYUFBUyxhQUFULENBQXVCLFdBQXZCLEVBQW9DLE9BQXBDLEVBQTZDLE1BQTdDLEVBQXFEO0FBQ2pELFlBQUksV0FBVyxLQUFLLENBQXBCLEVBQXVCO0FBQUUscUJBQVMsT0FBTyxNQUFQLENBQWMsSUFBZCxDQUFUO0FBQStCO0FBQ3hELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxhQUFLLE1BQUwsR0FBYyxDQUFkO0FBQ0EsYUFBSyxPQUFMLEdBQWdCLE9BQU8sT0FBUCxLQUFtQixVQUFwQixHQUFrQyxPQUFsQyxHQUE0QyxJQUEzRDtBQUNBLGFBQUssTUFBTCxHQUFjLE1BQWQ7QUFDSDtBQUNELGtCQUFjLFNBQWQsQ0FBd0IsS0FBeEIsR0FBZ0MsVUFBVSxLQUFWLEVBQWlCO0FBQzdDLFlBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0EsWUFBSSxVQUFVLE9BQVYsQ0FBa0IsS0FBbEIsQ0FBSixFQUE4QjtBQUMxQixzQkFBVSxJQUFWLENBQWUsSUFBSSxtQkFBSixDQUF3QixLQUF4QixDQUFmO0FBQ0gsU0FGRCxNQUdLLElBQUksT0FBTyxNQUFNLFdBQVcsUUFBakIsQ0FBUCxLQUFzQyxVQUExQyxFQUFzRDtBQUN2RCxzQkFBVSxJQUFWLENBQWUsSUFBSSxjQUFKLENBQW1CLE1BQU0sV0FBVyxRQUFqQixHQUFuQixDQUFmO0FBQ0gsU0FGSSxNQUdBO0FBQ0Qsc0JBQVUsSUFBVixDQUFlLElBQUksaUJBQUosQ0FBc0IsS0FBSyxXQUEzQixFQUF3QyxJQUF4QyxFQUE4QyxLQUE5QyxDQUFmO0FBQ0g7QUFDSixLQVhEO0FBWUEsa0JBQWMsU0FBZCxDQUF3QixTQUF4QixHQUFvQyxZQUFZO0FBQzVDLFlBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0EsWUFBSSxNQUFNLFVBQVUsTUFBcEI7QUFDQSxZQUFJLFFBQVEsQ0FBWixFQUFlO0FBQ1gsaUJBQUssV0FBTCxDQUFpQixRQUFqQjtBQUNBO0FBQ0g7QUFDRCxhQUFLLE1BQUwsR0FBYyxHQUFkO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLGdCQUFJLFdBQVcsVUFBVSxDQUFWLENBQWY7QUFDQSxnQkFBSSxTQUFTLGlCQUFiLEVBQWdDO0FBQzVCLHFCQUFLLEdBQUwsQ0FBUyxTQUFTLFNBQVQsQ0FBbUIsUUFBbkIsRUFBNkIsQ0FBN0IsQ0FBVDtBQUNILGFBRkQsTUFHSztBQUNELHFCQUFLLE1BQUwsR0FEQyxDQUNjO0FBQ2xCO0FBQ0o7QUFDSixLQWpCRDtBQWtCQSxrQkFBYyxTQUFkLENBQXdCLGNBQXhCLEdBQXlDLFlBQVk7QUFDakQsYUFBSyxNQUFMO0FBQ0EsWUFBSSxLQUFLLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkIsaUJBQUssV0FBTCxDQUFpQixRQUFqQjtBQUNIO0FBQ0osS0FMRDtBQU1BLGtCQUFjLFNBQWQsQ0FBd0IsY0FBeEIsR0FBeUMsWUFBWTtBQUNqRCxZQUFJLFlBQVksS0FBSyxTQUFyQjtBQUNBLFlBQUksTUFBTSxVQUFVLE1BQXBCO0FBQ0EsWUFBSSxjQUFjLEtBQUssV0FBdkI7QUFDQTtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxHQUFwQixFQUF5QixHQUF6QixFQUE4QjtBQUMxQixnQkFBSSxXQUFXLFVBQVUsQ0FBVixDQUFmO0FBQ0EsZ0JBQUksT0FBTyxTQUFTLFFBQWhCLEtBQTZCLFVBQTdCLElBQTJDLENBQUMsU0FBUyxRQUFULEVBQWhELEVBQXFFO0FBQ2pFO0FBQ0g7QUFDSjtBQUNELFlBQUksaUJBQWlCLEtBQXJCO0FBQ0EsWUFBSSxPQUFPLEVBQVg7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIsZ0JBQUksV0FBVyxVQUFVLENBQVYsQ0FBZjtBQUNBLGdCQUFJLFNBQVMsU0FBUyxJQUFULEVBQWI7QUFDQTtBQUNBO0FBQ0EsZ0JBQUksU0FBUyxZQUFULEVBQUosRUFBNkI7QUFDekIsaUNBQWlCLElBQWpCO0FBQ0g7QUFDRCxnQkFBSSxPQUFPLElBQVgsRUFBaUI7QUFDYiw0QkFBWSxRQUFaO0FBQ0E7QUFDSDtBQUNELGlCQUFLLElBQUwsQ0FBVSxPQUFPLEtBQWpCO0FBQ0g7QUFDRCxZQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNkLGlCQUFLLFdBQUwsQ0FBaUIsSUFBakI7QUFDSCxTQUZELE1BR0s7QUFDRCx3QkFBWSxJQUFaLENBQWlCLElBQWpCO0FBQ0g7QUFDRCxZQUFJLGNBQUosRUFBb0I7QUFDaEIsd0JBQVksUUFBWjtBQUNIO0FBQ0osS0FwQ0Q7QUFxQ0Esa0JBQWMsU0FBZCxDQUF3QixXQUF4QixHQUFzQyxVQUFVLElBQVYsRUFBZ0I7QUFDbEQsWUFBSSxNQUFKO0FBQ0EsWUFBSTtBQUNBLHFCQUFTLEtBQUssT0FBTCxDQUFhLEtBQWIsQ0FBbUIsSUFBbkIsRUFBeUIsSUFBekIsQ0FBVDtBQUNILFNBRkQsQ0FHQSxPQUFPLEdBQVAsRUFBWTtBQUNSLGlCQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBdUIsR0FBdkI7QUFDQTtBQUNIO0FBQ0QsYUFBSyxXQUFMLENBQWlCLElBQWpCLENBQXNCLE1BQXRCO0FBQ0gsS0FWRDtBQVdBLFdBQU8sYUFBUDtBQUNILENBL0ZvQixDQStGbkIsYUFBYSxVQS9GTSxDQUFyQjtBQWdHQSxRQUFRLGFBQVIsR0FBd0IsYUFBeEI7QUFDQSxJQUFJLGlCQUFrQixZQUFZO0FBQzlCLGFBQVMsY0FBVCxDQUF3QixRQUF4QixFQUFrQztBQUM5QixhQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxhQUFLLFVBQUwsR0FBa0IsU0FBUyxJQUFULEVBQWxCO0FBQ0g7QUFDRCxtQkFBZSxTQUFmLENBQXlCLFFBQXpCLEdBQW9DLFlBQVk7QUFDNUMsZUFBTyxJQUFQO0FBQ0gsS0FGRDtBQUdBLG1CQUFlLFNBQWYsQ0FBeUIsSUFBekIsR0FBZ0MsWUFBWTtBQUN4QyxZQUFJLFNBQVMsS0FBSyxVQUFsQjtBQUNBLGFBQUssVUFBTCxHQUFrQixLQUFLLFFBQUwsQ0FBYyxJQUFkLEVBQWxCO0FBQ0EsZUFBTyxNQUFQO0FBQ0gsS0FKRDtBQUtBLG1CQUFlLFNBQWYsQ0FBeUIsWUFBekIsR0FBd0MsWUFBWTtBQUNoRCxZQUFJLGFBQWEsS0FBSyxVQUF0QjtBQUNBLGVBQU8sY0FBYyxXQUFXLElBQWhDO0FBQ0gsS0FIRDtBQUlBLFdBQU8sY0FBUDtBQUNILENBbEJxQixFQUF0QjtBQW1CQSxJQUFJLHNCQUF1QixZQUFZO0FBQ25DLGFBQVMsbUJBQVQsQ0FBNkIsS0FBN0IsRUFBb0M7QUFDaEMsYUFBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLGFBQUssS0FBTCxHQUFhLENBQWI7QUFDQSxhQUFLLE1BQUwsR0FBYyxDQUFkO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBTSxNQUFwQjtBQUNIO0FBQ0Qsd0JBQW9CLFNBQXBCLENBQThCLFdBQVcsUUFBekMsSUFBcUQsWUFBWTtBQUM3RCxlQUFPLElBQVA7QUFDSCxLQUZEO0FBR0Esd0JBQW9CLFNBQXBCLENBQThCLElBQTlCLEdBQXFDLFVBQVUsS0FBVixFQUFpQjtBQUNsRCxZQUFJLElBQUksS0FBSyxLQUFMLEVBQVI7QUFDQSxZQUFJLFFBQVEsS0FBSyxLQUFqQjtBQUNBLGVBQU8sSUFBSSxLQUFLLE1BQVQsR0FBa0IsRUFBRSxPQUFPLE1BQU0sQ0FBTixDQUFULEVBQW1CLE1BQU0sS0FBekIsRUFBbEIsR0FBcUQsRUFBRSxPQUFPLElBQVQsRUFBZSxNQUFNLElBQXJCLEVBQTVEO0FBQ0gsS0FKRDtBQUtBLHdCQUFvQixTQUFwQixDQUE4QixRQUE5QixHQUF5QyxZQUFZO0FBQ2pELGVBQU8sS0FBSyxLQUFMLENBQVcsTUFBWCxHQUFvQixLQUFLLEtBQWhDO0FBQ0gsS0FGRDtBQUdBLHdCQUFvQixTQUFwQixDQUE4QixZQUE5QixHQUE2QyxZQUFZO0FBQ3JELGVBQU8sS0FBSyxLQUFMLENBQVcsTUFBWCxLQUFzQixLQUFLLEtBQWxDO0FBQ0gsS0FGRDtBQUdBLFdBQU8sbUJBQVA7QUFDSCxDQXRCMEIsRUFBM0I7QUF1QkE7Ozs7O0FBS0EsSUFBSSxvQkFBcUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3ZDLGNBQVUsaUJBQVYsRUFBNkIsTUFBN0I7QUFDQSxhQUFTLGlCQUFULENBQTJCLFdBQTNCLEVBQXdDLE1BQXhDLEVBQWdELFVBQWhELEVBQTREO0FBQ3hELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLFVBQWxCO0FBQ0EsYUFBSyxpQkFBTCxHQUF5QixJQUF6QjtBQUNBLGFBQUssTUFBTCxHQUFjLEVBQWQ7QUFDQSxhQUFLLFVBQUwsR0FBa0IsS0FBbEI7QUFDSDtBQUNELHNCQUFrQixTQUFsQixDQUE0QixXQUFXLFFBQXZDLElBQW1ELFlBQVk7QUFDM0QsZUFBTyxJQUFQO0FBQ0gsS0FGRDtBQUdBO0FBQ0E7QUFDQSxzQkFBa0IsU0FBbEIsQ0FBNEIsSUFBNUIsR0FBbUMsWUFBWTtBQUMzQyxZQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUNBLFlBQUksT0FBTyxNQUFQLEtBQWtCLENBQWxCLElBQXVCLEtBQUssVUFBaEMsRUFBNEM7QUFDeEMsbUJBQU8sRUFBRSxPQUFPLElBQVQsRUFBZSxNQUFNLElBQXJCLEVBQVA7QUFDSCxTQUZELE1BR0s7QUFDRCxtQkFBTyxFQUFFLE9BQU8sT0FBTyxLQUFQLEVBQVQsRUFBeUIsTUFBTSxLQUEvQixFQUFQO0FBQ0g7QUFDSixLQVJEO0FBU0Esc0JBQWtCLFNBQWxCLENBQTRCLFFBQTVCLEdBQXVDLFlBQVk7QUFDL0MsZUFBTyxLQUFLLE1BQUwsQ0FBWSxNQUFaLEdBQXFCLENBQTVCO0FBQ0gsS0FGRDtBQUdBLHNCQUFrQixTQUFsQixDQUE0QixZQUE1QixHQUEyQyxZQUFZO0FBQ25ELGVBQU8sS0FBSyxNQUFMLENBQVksTUFBWixLQUF1QixDQUF2QixJQUE0QixLQUFLLFVBQXhDO0FBQ0gsS0FGRDtBQUdBLHNCQUFrQixTQUFsQixDQUE0QixjQUE1QixHQUE2QyxZQUFZO0FBQ3JELFlBQUksS0FBSyxNQUFMLENBQVksTUFBWixHQUFxQixDQUF6QixFQUE0QjtBQUN4QixpQkFBSyxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsaUJBQUssTUFBTCxDQUFZLGNBQVo7QUFDSCxTQUhELE1BSUs7QUFDRCxpQkFBSyxXQUFMLENBQWlCLFFBQWpCO0FBQ0g7QUFDSixLQVJEO0FBU0Esc0JBQWtCLFNBQWxCLENBQTRCLFVBQTVCLEdBQXlDLFVBQVUsVUFBVixFQUFzQixVQUF0QixFQUFrQyxVQUFsQyxFQUE4QyxVQUE5QyxFQUEwRCxRQUExRCxFQUFvRTtBQUN6RyxhQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLFVBQWpCO0FBQ0EsYUFBSyxNQUFMLENBQVksY0FBWjtBQUNILEtBSEQ7QUFJQSxzQkFBa0IsU0FBbEIsQ0FBNEIsU0FBNUIsR0FBd0MsVUFBVSxLQUFWLEVBQWlCLEtBQWpCLEVBQXdCO0FBQzVELGVBQU8sb0JBQW9CLGlCQUFwQixDQUFzQyxJQUF0QyxFQUE0QyxLQUFLLFVBQWpELEVBQTZELElBQTdELEVBQW1FLEtBQW5FLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxpQkFBUDtBQUNILENBL0N3QixDQStDdkIsa0JBQWtCLGVBL0NLLENBQXpCO0FBZ0RBOzs7QUN0UkE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkLEVBQWlCLElBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFDMUMsYUFBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxpQkFBaUIsUUFBUSxpQkFBUixDQUFyQjtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBLElBQUksU0FBVSxVQUFVLE1BQVYsRUFBa0I7QUFDNUIsY0FBVSxNQUFWLEVBQWtCLE1BQWxCO0FBQ0EsYUFBUyxNQUFULENBQWdCLFNBQWhCLEVBQTJCLElBQTNCLEVBQWlDO0FBQzdCLGVBQU8sSUFBUCxDQUFZLElBQVo7QUFDSDtBQUNEOzs7Ozs7Ozs7O0FBVUEsV0FBTyxTQUFQLENBQWlCLFFBQWpCLEdBQTRCLFVBQVUsS0FBVixFQUFpQixLQUFqQixFQUF3QjtBQUNoRCxZQUFJLFVBQVUsS0FBSyxDQUFuQixFQUFzQjtBQUFFLG9CQUFRLENBQVI7QUFBWTtBQUNwQyxlQUFPLElBQVA7QUFDSCxLQUhEO0FBSUEsV0FBTyxNQUFQO0FBQ0gsQ0FwQmEsQ0FvQlosZUFBZSxZQXBCSCxDQUFkO0FBcUJBLFFBQVEsTUFBUixHQUFpQixNQUFqQjtBQUNBOzs7QUMzQ0E7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkLEVBQWlCLElBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFDMUMsYUFBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxTQUFTLFFBQVEsY0FBUixDQUFiO0FBQ0EsSUFBSSxXQUFXLFFBQVEsVUFBUixDQUFmO0FBQ0E7Ozs7O0FBS0EsSUFBSSxjQUFlLFVBQVUsTUFBVixFQUFrQjtBQUNqQyxjQUFVLFdBQVYsRUFBdUIsTUFBdkI7QUFDQSxhQUFTLFdBQVQsQ0FBcUIsU0FBckIsRUFBZ0MsSUFBaEMsRUFBc0M7QUFDbEMsZUFBTyxJQUFQLENBQVksSUFBWixFQUFrQixTQUFsQixFQUE2QixJQUE3QjtBQUNBLGFBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNBLGFBQUssSUFBTCxHQUFZLElBQVo7QUFDQSxhQUFLLE9BQUwsR0FBZSxLQUFmO0FBQ0g7QUFDRCxnQkFBWSxTQUFaLENBQXNCLFFBQXRCLEdBQWlDLFVBQVUsS0FBVixFQUFpQixLQUFqQixFQUF3QjtBQUNyRCxZQUFJLFVBQVUsS0FBSyxDQUFuQixFQUFzQjtBQUFFLG9CQUFRLENBQVI7QUFBWTtBQUNwQyxZQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNiLG1CQUFPLElBQVA7QUFDSDtBQUNEO0FBQ0EsYUFBSyxLQUFMLEdBQWEsS0FBYjtBQUNBO0FBQ0E7QUFDQSxhQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0EsWUFBSSxLQUFLLEtBQUssRUFBZDtBQUNBLFlBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSSxNQUFNLElBQVYsRUFBZ0I7QUFDWixpQkFBSyxFQUFMLEdBQVUsS0FBSyxjQUFMLENBQW9CLFNBQXBCLEVBQStCLEVBQS9CLEVBQW1DLEtBQW5DLENBQVY7QUFDSDtBQUNELGFBQUssS0FBTCxHQUFhLEtBQWI7QUFDQTtBQUNBLGFBQUssRUFBTCxHQUFVLEtBQUssRUFBTCxJQUFXLEtBQUssY0FBTCxDQUFvQixTQUFwQixFQUErQixLQUFLLEVBQXBDLEVBQXdDLEtBQXhDLENBQXJCO0FBQ0EsZUFBTyxJQUFQO0FBQ0gsS0F4Q0Q7QUF5Q0EsZ0JBQVksU0FBWixDQUFzQixjQUF0QixHQUF1QyxVQUFVLFNBQVYsRUFBcUIsRUFBckIsRUFBeUIsS0FBekIsRUFBZ0M7QUFDbkUsWUFBSSxVQUFVLEtBQUssQ0FBbkIsRUFBc0I7QUFBRSxvQkFBUSxDQUFSO0FBQVk7QUFDcEMsZUFBTyxPQUFPLElBQVAsQ0FBWSxXQUFaLENBQXdCLFVBQVUsS0FBVixDQUFnQixJQUFoQixDQUFxQixTQUFyQixFQUFnQyxJQUFoQyxDQUF4QixFQUErRCxLQUEvRCxDQUFQO0FBQ0gsS0FIRDtBQUlBLGdCQUFZLFNBQVosQ0FBc0IsY0FBdEIsR0FBdUMsVUFBVSxTQUFWLEVBQXFCLEVBQXJCLEVBQXlCLEtBQXpCLEVBQWdDO0FBQ25FLFlBQUksVUFBVSxLQUFLLENBQW5CLEVBQXNCO0FBQUUsb0JBQVEsQ0FBUjtBQUFZO0FBQ3BDO0FBQ0EsWUFBSSxVQUFVLElBQVYsSUFBa0IsS0FBSyxLQUFMLEtBQWUsS0FBckMsRUFBNEM7QUFDeEMsbUJBQU8sRUFBUDtBQUNIO0FBQ0Q7QUFDQTtBQUNBLGVBQU8sT0FBTyxJQUFQLENBQVksYUFBWixDQUEwQixFQUExQixLQUFpQyxTQUFqQyxJQUE4QyxTQUFyRDtBQUNILEtBVEQ7QUFVQTs7OztBQUlBLGdCQUFZLFNBQVosQ0FBc0IsT0FBdEIsR0FBZ0MsVUFBVSxLQUFWLEVBQWlCLEtBQWpCLEVBQXdCO0FBQ3BELFlBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2IsbUJBQU8sSUFBSSxLQUFKLENBQVUsOEJBQVYsQ0FBUDtBQUNIO0FBQ0QsYUFBSyxPQUFMLEdBQWUsS0FBZjtBQUNBLFlBQUksUUFBUSxLQUFLLFFBQUwsQ0FBYyxLQUFkLEVBQXFCLEtBQXJCLENBQVo7QUFDQSxZQUFJLEtBQUosRUFBVztBQUNQLG1CQUFPLEtBQVA7QUFDSCxTQUZELE1BR0ssSUFBSSxLQUFLLE9BQUwsS0FBaUIsS0FBakIsSUFBMEIsS0FBSyxFQUFMLElBQVcsSUFBekMsRUFBK0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBSyxFQUFMLEdBQVUsS0FBSyxjQUFMLENBQW9CLEtBQUssU0FBekIsRUFBb0MsS0FBSyxFQUF6QyxFQUE2QyxJQUE3QyxDQUFWO0FBQ0g7QUFDSixLQXpCRDtBQTBCQSxnQkFBWSxTQUFaLENBQXNCLFFBQXRCLEdBQWlDLFVBQVUsS0FBVixFQUFpQixLQUFqQixFQUF3QjtBQUNyRCxZQUFJLFVBQVUsS0FBZDtBQUNBLFlBQUksYUFBYSxTQUFqQjtBQUNBLFlBQUk7QUFDQSxpQkFBSyxJQUFMLENBQVUsS0FBVjtBQUNILFNBRkQsQ0FHQSxPQUFPLENBQVAsRUFBVTtBQUNOLHNCQUFVLElBQVY7QUFDQSx5QkFBYSxDQUFDLENBQUMsQ0FBRixJQUFPLENBQVAsSUFBWSxJQUFJLEtBQUosQ0FBVSxDQUFWLENBQXpCO0FBQ0g7QUFDRCxZQUFJLE9BQUosRUFBYTtBQUNULGlCQUFLLFdBQUw7QUFDQSxtQkFBTyxVQUFQO0FBQ0g7QUFDSixLQWREO0FBZUEsZ0JBQVksU0FBWixDQUFzQixZQUF0QixHQUFxQyxZQUFZO0FBQzdDLFlBQUksS0FBSyxLQUFLLEVBQWQ7QUFDQSxZQUFJLFlBQVksS0FBSyxTQUFyQjtBQUNBLFlBQUksVUFBVSxVQUFVLE9BQXhCO0FBQ0EsWUFBSSxRQUFRLFFBQVEsT0FBUixDQUFnQixJQUFoQixDQUFaO0FBQ0EsYUFBSyxJQUFMLEdBQVksSUFBWjtBQUNBLGFBQUssS0FBTCxHQUFhLElBQWI7QUFDQSxhQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0EsYUFBSyxPQUFMLEdBQWUsS0FBZjtBQUNBLGFBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLFlBQUksVUFBVSxDQUFDLENBQWYsRUFBa0I7QUFDZCxvQkFBUSxNQUFSLENBQWUsS0FBZixFQUFzQixDQUF0QjtBQUNIO0FBQ0QsWUFBSSxNQUFNLElBQVYsRUFBZ0I7QUFDWixpQkFBSyxFQUFMLEdBQVUsS0FBSyxjQUFMLENBQW9CLFNBQXBCLEVBQStCLEVBQS9CLEVBQW1DLElBQW5DLENBQVY7QUFDSDtBQUNKLEtBaEJEO0FBaUJBLFdBQU8sV0FBUDtBQUNILENBOUhrQixDQThIakIsU0FBUyxNQTlIUSxDQUFuQjtBQStIQSxRQUFRLFdBQVIsR0FBc0IsV0FBdEI7QUFDQTs7O0FDN0lBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZCxFQUFpQixJQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQzFDLGFBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksY0FBYyxRQUFRLGNBQVIsQ0FBbEI7QUFDQSxJQUFJLGlCQUFrQixVQUFVLE1BQVYsRUFBa0I7QUFDcEMsY0FBVSxjQUFWLEVBQTBCLE1BQTFCO0FBQ0EsYUFBUyxjQUFULEdBQTBCO0FBQ3RCLGVBQU8sS0FBUCxDQUFhLElBQWIsRUFBbUIsU0FBbkI7QUFDQSxhQUFLLE9BQUwsR0FBZSxFQUFmO0FBQ0E7Ozs7O0FBS0EsYUFBSyxNQUFMLEdBQWMsS0FBZDtBQUNBOzs7Ozs7QUFNQSxhQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDSDtBQUNELG1CQUFlLFNBQWYsQ0FBeUIsS0FBekIsR0FBaUMsVUFBVSxNQUFWLEVBQWtCO0FBQy9DLFlBQUksVUFBVSxLQUFLLE9BQW5CO0FBQ0EsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYixvQkFBUSxJQUFSLENBQWEsTUFBYjtBQUNBO0FBQ0g7QUFDRCxZQUFJLEtBQUo7QUFDQSxhQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0EsV0FBRztBQUNDLGdCQUFJLFFBQVEsT0FBTyxPQUFQLENBQWUsT0FBTyxLQUF0QixFQUE2QixPQUFPLEtBQXBDLENBQVosRUFBd0Q7QUFDcEQ7QUFDSDtBQUNKLFNBSkQsUUFJUyxTQUFTLFFBQVEsS0FBUixFQUpsQixFQVIrQyxDQVlYO0FBQ3BDLGFBQUssTUFBTCxHQUFjLEtBQWQ7QUFDQSxZQUFJLEtBQUosRUFBVztBQUNQLG1CQUFPLFNBQVMsUUFBUSxLQUFSLEVBQWhCLEVBQWlDO0FBQzdCLHVCQUFPLFdBQVA7QUFDSDtBQUNELGtCQUFNLEtBQU47QUFDSDtBQUNKLEtBcEJEO0FBcUJBLFdBQU8sY0FBUDtBQUNILENBekNxQixDQXlDcEIsWUFBWSxTQXpDUSxDQUF0QjtBQTBDQSxRQUFRLGNBQVIsR0FBeUIsY0FBekI7QUFDQTs7O0FDbERBOztBQUNBLElBQUksZ0JBQWdCLFFBQVEsZUFBUixDQUFwQjtBQUNBLElBQUksbUJBQW1CLFFBQVEsa0JBQVIsQ0FBdkI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMENBLFFBQVEsS0FBUixHQUFnQixJQUFJLGlCQUFpQixjQUFyQixDQUFvQyxjQUFjLFdBQWxELENBQWhCO0FBQ0E7OztBQzlDQTs7QUFDQSxJQUFJLFNBQVMsUUFBUSxjQUFSLENBQWI7QUFDQSxTQUFTLHNCQUFULENBQWdDLElBQWhDLEVBQXNDO0FBQ2xDLFFBQUksU0FBUyxLQUFLLE1BQWxCO0FBQ0EsUUFBSSxPQUFPLE1BQVAsS0FBa0IsVUFBdEIsRUFBa0M7QUFDOUIsWUFBSSxDQUFDLE9BQU8sUUFBWixFQUFzQjtBQUNsQixtQkFBTyxRQUFQLEdBQWtCLE9BQU8sbUJBQVAsQ0FBbEI7QUFDSDtBQUNELGVBQU8sT0FBTyxRQUFkO0FBQ0gsS0FMRCxNQU1LO0FBQ0Q7QUFDQSxZQUFJLFFBQVEsS0FBSyxHQUFqQjtBQUNBLFlBQUksU0FBUyxPQUFPLElBQUksS0FBSixHQUFZLFlBQVosQ0FBUCxLQUFxQyxVQUFsRCxFQUE4RDtBQUMxRCxtQkFBTyxZQUFQO0FBQ0g7QUFDRCxZQUFJLFFBQVEsS0FBSyxHQUFqQjtBQUNBO0FBQ0EsWUFBSSxLQUFKLEVBQVc7QUFDUCxnQkFBSSxPQUFPLE9BQU8sbUJBQVAsQ0FBMkIsTUFBTSxTQUFqQyxDQUFYO0FBQ0EsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEVBQUUsQ0FBbkMsRUFBc0M7QUFDbEMsb0JBQUksTUFBTSxLQUFLLENBQUwsQ0FBVjtBQUNBO0FBQ0Esb0JBQUksUUFBUSxTQUFSLElBQXFCLFFBQVEsTUFBN0IsSUFBdUMsTUFBTSxTQUFOLENBQWdCLEdBQWhCLE1BQXlCLE1BQU0sU0FBTixDQUFnQixTQUFoQixDQUFwRSxFQUFnRztBQUM1RiwyQkFBTyxHQUFQO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsZUFBTyxZQUFQO0FBQ0g7QUFDSjtBQUNELFFBQVEsc0JBQVIsR0FBaUMsc0JBQWpDO0FBQ0EsUUFBUSxRQUFSLEdBQW1CLHVCQUF1QixPQUFPLElBQTlCLENBQW5CO0FBQ0E7OztBQUdBLFFBQVEsVUFBUixHQUFxQixRQUFRLFFBQTdCO0FBQ0E7OztBQ3JDQTs7QUFDQSxJQUFJLFNBQVMsUUFBUSxjQUFSLENBQWI7QUFDQSxTQUFTLG1CQUFULENBQTZCLE9BQTdCLEVBQXNDO0FBQ2xDLFFBQUksWUFBSjtBQUNBLFFBQUksU0FBUyxRQUFRLE1BQXJCO0FBQ0EsUUFBSSxPQUFPLE1BQVAsS0FBa0IsVUFBdEIsRUFBa0M7QUFDOUIsWUFBSSxPQUFPLFVBQVgsRUFBdUI7QUFDbkIsMkJBQWUsT0FBTyxVQUF0QjtBQUNILFNBRkQsTUFHSztBQUNELDJCQUFlLE9BQU8sWUFBUCxDQUFmO0FBQ0EsbUJBQU8sVUFBUCxHQUFvQixZQUFwQjtBQUNIO0FBQ0osS0FSRCxNQVNLO0FBQ0QsdUJBQWUsY0FBZjtBQUNIO0FBQ0QsV0FBTyxZQUFQO0FBQ0g7QUFDRCxRQUFRLG1CQUFSLEdBQThCLG1CQUE5QjtBQUNBLFFBQVEsVUFBUixHQUFxQixvQkFBb0IsT0FBTyxJQUEzQixDQUFyQjtBQUNBOzs7QUFHQSxRQUFRLFlBQVIsR0FBdUIsUUFBUSxVQUEvQjtBQUNBOzs7QUN6QkE7O0FBQ0EsSUFBSSxTQUFTLFFBQVEsY0FBUixDQUFiO0FBQ0EsSUFBSSxTQUFTLE9BQU8sSUFBUCxDQUFZLE1BQXpCO0FBQ0EsUUFBUSxZQUFSLEdBQXdCLE9BQU8sTUFBUCxLQUFrQixVQUFsQixJQUFnQyxPQUFPLE9BQU8sR0FBZCxLQUFzQixVQUF2RCxHQUNuQixPQUFPLEdBQVAsQ0FBVyxjQUFYLENBRG1CLEdBQ1UsZ0JBRGpDO0FBRUE7OztBQUdBLFFBQVEsY0FBUixHQUF5QixRQUFRLFlBQWpDO0FBQ0E7OztBQ1RBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZCxFQUFpQixJQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQzFDLGFBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBOzs7Ozs7Ozs7QUFTQSxJQUFJLDBCQUEyQixVQUFVLE1BQVYsRUFBa0I7QUFDN0MsY0FBVSx1QkFBVixFQUFtQyxNQUFuQztBQUNBLGFBQVMsdUJBQVQsR0FBbUM7QUFDL0IsWUFBSSxNQUFNLE9BQU8sSUFBUCxDQUFZLElBQVosRUFBa0IscUJBQWxCLENBQVY7QUFDQSxhQUFLLElBQUwsR0FBWSxJQUFJLElBQUosR0FBVyx5QkFBdkI7QUFDQSxhQUFLLEtBQUwsR0FBYSxJQUFJLEtBQWpCO0FBQ0EsYUFBSyxPQUFMLEdBQWUsSUFBSSxPQUFuQjtBQUNIO0FBQ0QsV0FBTyx1QkFBUDtBQUNILENBVDhCLENBUzdCLEtBVDZCLENBQS9CO0FBVUEsUUFBUSx1QkFBUixHQUFrQyx1QkFBbEM7QUFDQTs7O0FDMUJBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZCxFQUFpQixJQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQzFDLGFBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBOzs7O0FBSUEsSUFBSSxzQkFBdUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3pDLGNBQVUsbUJBQVYsRUFBK0IsTUFBL0I7QUFDQSxhQUFTLG1CQUFULENBQTZCLE1BQTdCLEVBQXFDO0FBQ2pDLGVBQU8sSUFBUCxDQUFZLElBQVo7QUFDQSxhQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsWUFBSSxNQUFNLE1BQU0sSUFBTixDQUFXLElBQVgsRUFBaUIsU0FDdkIsT0FBTyxNQUFQLEdBQWdCLDZDQUFoQixHQUFnRSxPQUFPLEdBQVAsQ0FBVyxVQUFVLEdBQVYsRUFBZSxDQUFmLEVBQWtCO0FBQUUsbUJBQVMsSUFBSSxDQUFMLEdBQVUsSUFBVixHQUFpQixJQUFJLFFBQUosRUFBekI7QUFBMkMsU0FBMUUsRUFBNEUsSUFBNUUsQ0FBaUYsTUFBakYsQ0FEekMsR0FDb0ksRUFEckosQ0FBVjtBQUVBLGFBQUssSUFBTCxHQUFZLElBQUksSUFBSixHQUFXLHFCQUF2QjtBQUNBLGFBQUssS0FBTCxHQUFhLElBQUksS0FBakI7QUFDQSxhQUFLLE9BQUwsR0FBZSxJQUFJLE9BQW5CO0FBQ0g7QUFDRCxXQUFPLG1CQUFQO0FBQ0gsQ0FaMEIsQ0FZekIsS0FaeUIsQ0FBM0I7QUFhQSxRQUFRLG1CQUFSLEdBQThCLG1CQUE5QjtBQUNBOzs7QUN4QkE7QUFDQTs7QUFDQSxRQUFRLFdBQVIsR0FBc0IsRUFBRSxHQUFHLEVBQUwsRUFBdEI7QUFDQTs7O0FDSEE7O0FBQ0EsUUFBUSxPQUFSLEdBQWtCLE1BQU0sT0FBTixJQUFrQixVQUFVLENBQVYsRUFBYTtBQUFFLFNBQU8sS0FBSyxPQUFPLEVBQUUsTUFBVCxLQUFvQixRQUFoQztBQUEyQyxDQUE5RjtBQUNBOzs7QUNGQTs7QUFDQSxRQUFRLFdBQVIsR0FBdUIsVUFBVSxDQUFWLEVBQWE7QUFBRSxTQUFPLEtBQUssT0FBTyxFQUFFLE1BQVQsS0FBb0IsUUFBaEM7QUFBMkMsQ0FBakY7QUFDQTs7O0FDRkE7O0FBQ0EsU0FBUyxNQUFULENBQWdCLEtBQWhCLEVBQXVCO0FBQ25CLFdBQU8saUJBQWlCLElBQWpCLElBQXlCLENBQUMsTUFBTSxDQUFDLEtBQVAsQ0FBakM7QUFDSDtBQUNELFFBQVEsTUFBUixHQUFpQixNQUFqQjtBQUNBOzs7QUNMQTs7QUFDQSxTQUFTLFVBQVQsQ0FBb0IsQ0FBcEIsRUFBdUI7QUFDbkIsV0FBTyxPQUFPLENBQVAsS0FBYSxVQUFwQjtBQUNIO0FBQ0QsUUFBUSxVQUFSLEdBQXFCLFVBQXJCO0FBQ0E7OztBQ0xBOztBQUNBLElBQUksWUFBWSxRQUFRLGlCQUFSLENBQWhCO0FBQ0EsU0FBUyxTQUFULENBQW1CLEdBQW5CLEVBQXdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBTyxDQUFDLFVBQVUsT0FBVixDQUFrQixHQUFsQixDQUFELElBQTRCLE1BQU0sV0FBVyxHQUFYLENBQU4sR0FBd0IsQ0FBekIsSUFBK0IsQ0FBakU7QUFDSDtBQUNELFFBQVEsU0FBUixHQUFvQixTQUFwQjtBQUNBO0FBQ0E7OztBQ1hBOztBQUNBLFNBQVMsUUFBVCxDQUFrQixDQUFsQixFQUFxQjtBQUNqQixXQUFPLEtBQUssSUFBTCxJQUFhLE9BQU8sQ0FBUCxLQUFhLFFBQWpDO0FBQ0g7QUFDRCxRQUFRLFFBQVIsR0FBbUIsUUFBbkI7QUFDQTs7O0FDTEE7O0FBQ0EsU0FBUyxTQUFULENBQW1CLEtBQW5CLEVBQTBCO0FBQ3RCLFdBQU8sU0FBUyxPQUFPLE1BQU0sU0FBYixLQUEyQixVQUFwQyxJQUFrRCxPQUFPLE1BQU0sSUFBYixLQUFzQixVQUEvRTtBQUNIO0FBQ0QsUUFBUSxTQUFSLEdBQW9CLFNBQXBCO0FBQ0E7OztBQ0xBOztBQUNBLFNBQVMsV0FBVCxDQUFxQixLQUFyQixFQUE0QjtBQUN4QixXQUFPLFNBQVMsT0FBTyxNQUFNLFFBQWIsS0FBMEIsVUFBMUM7QUFDSDtBQUNELFFBQVEsV0FBUixHQUFzQixXQUF0QjtBQUNBOzs7O0FDTEE7QUFDQTs7Ozs7O0FBS0EsUUFBUSxJQUFSLEdBQWdCLE9BQU8sTUFBUCxJQUFpQixRQUFqQixJQUE2QixPQUFPLE1BQVAsS0FBa0IsTUFBL0MsSUFBeUQsTUFBekQsSUFDVCxPQUFPLElBQVAsSUFBZSxRQUFmLElBQTJCLEtBQUssSUFBTCxLQUFjLElBQXpDLElBQWlELElBRHhDLElBRVQsT0FBTyxNQUFQLElBQWlCLFFBQWpCLElBQTZCLE9BQU8sTUFBUCxLQUFrQixNQUEvQyxJQUF5RCxNQUZoRTtBQUdBLElBQUksQ0FBQyxRQUFRLElBQWIsRUFBbUI7QUFDZixVQUFNLElBQUksS0FBSixDQUFVLCtEQUFWLENBQU47QUFDSDtBQUNEOzs7OztBQ1pBOztBQUNBLElBQUksU0FBUyxRQUFRLFFBQVIsQ0FBYjtBQUNBLElBQUksZ0JBQWdCLFFBQVEsZUFBUixDQUFwQjtBQUNBLElBQUksY0FBYyxRQUFRLGFBQVIsQ0FBbEI7QUFDQSxJQUFJLGFBQWEsUUFBUSxZQUFSLENBQWpCO0FBQ0EsSUFBSSxlQUFlLFFBQVEsZUFBUixDQUFuQjtBQUNBLElBQUksYUFBYSxRQUFRLG9CQUFSLENBQWpCO0FBQ0EsSUFBSSxvQkFBb0IsUUFBUSxvQkFBUixDQUF4QjtBQUNBLElBQUksZUFBZSxRQUFRLHNCQUFSLENBQW5CO0FBQ0EsU0FBUyxpQkFBVCxDQUEyQixlQUEzQixFQUE0QyxNQUE1QyxFQUFvRCxVQUFwRCxFQUFnRSxVQUFoRSxFQUE0RTtBQUN4RSxRQUFJLGNBQWMsSUFBSSxrQkFBa0IsZUFBdEIsQ0FBc0MsZUFBdEMsRUFBdUQsVUFBdkQsRUFBbUUsVUFBbkUsQ0FBbEI7QUFDQSxRQUFJLFlBQVksTUFBaEIsRUFBd0I7QUFDcEIsZUFBTyxJQUFQO0FBQ0g7QUFDRCxRQUFJLGtCQUFrQixhQUFhLFVBQW5DLEVBQStDO0FBQzNDLFlBQUksT0FBTyxTQUFYLEVBQXNCO0FBQ2xCLHdCQUFZLElBQVosQ0FBaUIsT0FBTyxLQUF4QjtBQUNBLHdCQUFZLFFBQVo7QUFDQSxtQkFBTyxJQUFQO0FBQ0gsU0FKRCxNQUtLO0FBQ0QsbUJBQU8sT0FBTyxTQUFQLENBQWlCLFdBQWpCLENBQVA7QUFDSDtBQUNKLEtBVEQsTUFVSyxJQUFJLGNBQWMsV0FBZCxDQUEwQixNQUExQixDQUFKLEVBQXVDO0FBQ3hDLGFBQUssSUFBSSxJQUFJLENBQVIsRUFBVyxNQUFNLE9BQU8sTUFBN0IsRUFBcUMsSUFBSSxHQUFKLElBQVcsQ0FBQyxZQUFZLE1BQTdELEVBQXFFLEdBQXJFLEVBQTBFO0FBQ3RFLHdCQUFZLElBQVosQ0FBaUIsT0FBTyxDQUFQLENBQWpCO0FBQ0g7QUFDRCxZQUFJLENBQUMsWUFBWSxNQUFqQixFQUF5QjtBQUNyQix3QkFBWSxRQUFaO0FBQ0g7QUFDSixLQVBJLE1BUUEsSUFBSSxZQUFZLFNBQVosQ0FBc0IsTUFBdEIsQ0FBSixFQUFtQztBQUNwQyxlQUFPLElBQVAsQ0FBWSxVQUFVLEtBQVYsRUFBaUI7QUFDekIsZ0JBQUksQ0FBQyxZQUFZLE1BQWpCLEVBQXlCO0FBQ3JCLDRCQUFZLElBQVosQ0FBaUIsS0FBakI7QUFDQSw0QkFBWSxRQUFaO0FBQ0g7QUFDSixTQUxELEVBS0csVUFBVSxHQUFWLEVBQWU7QUFBRSxtQkFBTyxZQUFZLEtBQVosQ0FBa0IsR0FBbEIsQ0FBUDtBQUFnQyxTQUxwRCxFQU1LLElBTkwsQ0FNVSxJQU5WLEVBTWdCLFVBQVUsR0FBVixFQUFlO0FBQzNCO0FBQ0EsbUJBQU8sSUFBUCxDQUFZLFVBQVosQ0FBdUIsWUFBWTtBQUFFLHNCQUFNLEdBQU47QUFBWSxhQUFqRDtBQUNILFNBVEQ7QUFVQSxlQUFPLFdBQVA7QUFDSCxLQVpJLE1BYUEsSUFBSSxVQUFVLE9BQU8sT0FBTyxXQUFXLFFBQWxCLENBQVAsS0FBdUMsVUFBckQsRUFBaUU7QUFDbEUsWUFBSSxXQUFXLE9BQU8sV0FBVyxRQUFsQixHQUFmO0FBQ0EsV0FBRztBQUNDLGdCQUFJLE9BQU8sU0FBUyxJQUFULEVBQVg7QUFDQSxnQkFBSSxLQUFLLElBQVQsRUFBZTtBQUNYLDRCQUFZLFFBQVo7QUFDQTtBQUNIO0FBQ0Qsd0JBQVksSUFBWixDQUFpQixLQUFLLEtBQXRCO0FBQ0EsZ0JBQUksWUFBWSxNQUFoQixFQUF3QjtBQUNwQjtBQUNIO0FBQ0osU0FWRCxRQVVTLElBVlQ7QUFXSCxLQWJJLE1BY0EsSUFBSSxVQUFVLE9BQU8sT0FBTyxhQUFhLFVBQXBCLENBQVAsS0FBMkMsVUFBekQsRUFBcUU7QUFDdEUsWUFBSSxNQUFNLE9BQU8sYUFBYSxVQUFwQixHQUFWO0FBQ0EsWUFBSSxPQUFPLElBQUksU0FBWCxLQUF5QixVQUE3QixFQUF5QztBQUNyQyx3QkFBWSxLQUFaLENBQWtCLElBQUksU0FBSixDQUFjLGdFQUFkLENBQWxCO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsbUJBQU8sSUFBSSxTQUFKLENBQWMsSUFBSSxrQkFBa0IsZUFBdEIsQ0FBc0MsZUFBdEMsRUFBdUQsVUFBdkQsRUFBbUUsVUFBbkUsQ0FBZCxDQUFQO0FBQ0g7QUFDSixLQVJJLE1BU0E7QUFDRCxZQUFJLFFBQVEsV0FBVyxRQUFYLENBQW9CLE1BQXBCLElBQThCLG1CQUE5QixHQUFvRCxNQUFNLE1BQU4sR0FBZSxHQUEvRTtBQUNBLFlBQUksTUFBTyxrQkFBa0IsS0FBbEIsR0FBMEIsK0JBQTNCLEdBQ0osOERBRE47QUFFQSxvQkFBWSxLQUFaLENBQWtCLElBQUksU0FBSixDQUFjLEdBQWQsQ0FBbEI7QUFDSDtBQUNELFdBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBUSxpQkFBUixHQUE0QixpQkFBNUI7QUFDQTs7O0FDN0VBOztBQUNBLElBQUksZUFBZSxRQUFRLGVBQVIsQ0FBbkI7QUFDQSxJQUFJLGlCQUFpQixRQUFRLHdCQUFSLENBQXJCO0FBQ0EsSUFBSSxhQUFhLFFBQVEsYUFBUixDQUFqQjtBQUNBLFNBQVMsWUFBVCxDQUFzQixjQUF0QixFQUFzQyxLQUF0QyxFQUE2QyxRQUE3QyxFQUF1RDtBQUNuRCxRQUFJLGNBQUosRUFBb0I7QUFDaEIsWUFBSSwwQkFBMEIsYUFBYSxVQUEzQyxFQUF1RDtBQUNuRCxtQkFBTyxjQUFQO0FBQ0g7QUFDRCxZQUFJLGVBQWUsZUFBZSxZQUE5QixDQUFKLEVBQWlEO0FBQzdDLG1CQUFPLGVBQWUsZUFBZSxZQUE5QixHQUFQO0FBQ0g7QUFDSjtBQUNELFFBQUksQ0FBQyxjQUFELElBQW1CLENBQUMsS0FBcEIsSUFBNkIsQ0FBQyxRQUFsQyxFQUE0QztBQUN4QyxlQUFPLElBQUksYUFBYSxVQUFqQixDQUE0QixXQUFXLEtBQXZDLENBQVA7QUFDSDtBQUNELFdBQU8sSUFBSSxhQUFhLFVBQWpCLENBQTRCLGNBQTVCLEVBQTRDLEtBQTVDLEVBQW1ELFFBQW5ELENBQVA7QUFDSDtBQUNELFFBQVEsWUFBUixHQUF1QixZQUF2QjtBQUNBOzs7QUNuQkE7O0FBQ0EsSUFBSSxnQkFBZ0IsUUFBUSxlQUFSLENBQXBCO0FBQ0EsSUFBSSxjQUFKO0FBQ0EsU0FBUyxVQUFULEdBQXNCO0FBQ2xCLFFBQUk7QUFDQSxlQUFPLGVBQWUsS0FBZixDQUFxQixJQUFyQixFQUEyQixTQUEzQixDQUFQO0FBQ0gsS0FGRCxDQUdBLE9BQU8sQ0FBUCxFQUFVO0FBQ04sc0JBQWMsV0FBZCxDQUEwQixDQUExQixHQUE4QixDQUE5QjtBQUNBLGVBQU8sY0FBYyxXQUFyQjtBQUNIO0FBQ0o7QUFDRCxTQUFTLFFBQVQsQ0FBa0IsRUFBbEIsRUFBc0I7QUFDbEIscUJBQWlCLEVBQWpCO0FBQ0EsV0FBTyxVQUFQO0FBQ0g7QUFDRCxRQUFRLFFBQVIsR0FBbUIsUUFBbkI7QUFDQTtBQUNBOzs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7SSxBQUVNOzs7O0FBRU4sSUFBTSxVQUFTLE9BQUEsQUFBTyxVQUFXLGFBQUE7ZUFBQSxBQUFTO0FBQTFDOztBQUVBLElBQU0sTUFBTSxPQUFBLEFBQU8sZUFBUCxBQUFzQixLQUFsQyxBQUFZLEFBQTJCOztBQUV2QyxJQUFNLE9BQU8sUUFBYixBQUFhLEFBQU87QUFDcEIsSUFBTSxRQUFRLFFBQWQsQUFBYyxBQUFPOztBQUVyQixTQUFBLEFBQVMsWUFBVCxBQUFxQixXQUFzQjtNQUFYLEFBQVcsMkVBQUosQUFBSSxBQUN6Qzs7TUFBSSxBQUNGO1dBQU8sSUFBQSxBQUFJLFlBQUosQUFBZ0IsV0FBdkIsQUFBTyxBQUEyQixBQUNuQztBQUZELElBRUUsT0FBQSxBQUFPLEdBQUcsQUFDVjtRQUFNLFFBQVEsU0FBQSxBQUFTLFlBQXZCLEFBQWMsQUFBcUIsQUFDbkM7VUFBQSxBQUFNLGdCQUFOLEFBQXNCLFdBQXRCLEFBQWlDLE1BQWpDLEFBQXVDLE1BQU0sS0FBN0MsQUFBa0QsQUFDbEQ7V0FBQSxBQUFPLEFBQ1I7QUFDRjs7O0FBRUQsU0FBQSxBQUFTLGNBQVQsQUFBdUIsS0FBdkIsQUFBNEIsWUFBWTtjQUN0Qzs7TUFBQSxBQUFJLE1BQUosQUFBVTtnQkFBSyxBQUNELEFBQ1o7U0FBSyxlQUFBO2FBQU0sTUFBQSxBQUFLLE9BQVgsQUFBTSxBQUFZO0FBRlYsQUFHYjtTQUFLLGFBQUEsQUFBQyxPQUFVLEFBQ2Q7VUFBSSxjQUFKLEFBQWtCLE1BQU0sQUFDdEI7bUJBQUEsQUFBVyxBQUNaO0FBRkQsYUFFTyxBQUNMO2NBQUEsQUFBSyxTQUFMLEFBQWMsS0FBZCxBQUFtQixBQUNwQjtBQUNGO0FBVEgsQUFBZSxBQVdoQjtBQVhnQixBQUNiOzs7QUFZSjtBQUNBLFNBQUEsQUFBUyxrQkFBa0I7ZUFDekI7O01BQU0sY0FBYyxLQUFwQixBQUFvQixBQUFLLEFBRXpCOztTQUFBLEFBQU8sS0FBSyxLQUFaLEFBQVksQUFBSyxRQUFqQixBQUF5QixRQUFRLFVBQUEsQUFBQyxLQUFRLEFBQ3hDO1FBQUksT0FBTyxPQUFQLEFBQU8sQUFBSyxTQUFoQixBQUF5QixhQUFhLEFBQ3BDO1VBQU0sYUFBYSxZQUFuQixBQUFtQixBQUFZLEFBQy9CO29CQUFBLEFBQWMsYUFBZCxBQUF5QixLQUF6QixBQUE4QixBQUMvQjtBQUNGO0FBTEQsQUFNRDs7O2tCQUVjLFlBQUE7TUFBQSxBQUFDLHdFQUFELEFBQUs7dUJBQUw7c0JBQUE7O3NCQUFBOzRCQUFBOzs4R0FBQTtBQUFBOzs7V0FBQTt5Q0FLTSxBQUNqQjtjQUFNLE1BQU4sQUFBTSxBQUFNLEFBQ2I7QUFQWTtBQUFBO1dBQUE7cUNBQUEsQUFTRSxJQVRGLEFBU00sT0FBTyxBQUN4QjtZQUFBLEFBQUksTUFBSixBQUFVLE9BQU8sRUFBRSxPQUFPLE9BQUEsQUFBTyxPQUFQLEFBQWMsSUFBSSxLQUFsQixBQUFrQixBQUFLLFlBQWpELEFBQWlCLEFBQVMsQUFBbUMsQUFDN0Q7d0JBQUEsQUFBZ0IsS0FBaEIsQUFBcUIsQUFDckI7WUFBQSxBQUFJLE1BQUosQUFBVSxNQUFNLEVBQUUsT0FBTyxLQUFBLEFBQUssU0FBOUIsQUFBZ0IsQUFBUyxBQUFjLEFBQ3ZDO2VBQUEsQUFBTyxBQUNSO0FBZFk7QUFBQTtXQUFBOytCQUFBLEFBZ0JKLElBQUksQUFDWDtlQUFBLEFBQU8sQUFDUjtBQWxCWTtBQUFBO1dBQUE7Z0NBNEJILEFBQ1I7ZUFBTyxLQUFQLEFBQU8sQUFBSyxBQUNiO0FBOUJZO0FBQUE7V0FBQTs4QkFnQ0wsQUFDTjtlQUFPLEtBQVAsQUFBTyxBQUFLLEFBQ2I7QUFsQ1k7QUFBQTtXQUFBO2dDQUFBLEFBb0NILFdBcENHLEFBb0NRLE1BQU0sQUFDekI7WUFBTSxjQUFpQixLQUFqQixBQUFzQixzQkFBNUIsQUFBNkMsQUFDN0M7YUFBQSxBQUFLLEdBQUwsQUFBUSxjQUFjLFlBQUEsQUFBWSxhQUFsQyxBQUFzQixBQUF5QixBQUNoRDtBQXZDWTtBQUFBO1dBQUE7aUNBeUNGLEFBQ1Q7QUFDQTtnQkFBQSxBQUFRLEtBRkMsQUFFVCxBQUFhLDBCQUEwQixBQUN2QztlQUFBLEFBQU8sQUFDUjtBQTdDWTtBQUFBO1dBQUE7b0NBK0NDLEFBQ1o7QUFDQTtnQkFBQSxBQUFRLEtBRkksQUFFWixBQUFhLDZCQUE2QixBQUMxQztlQUFBLEFBQU8sQUFDUjtBQW5EWTtBQUFBO1dBQUE7K0JBQUEsQUFxREosVUFyREksQUFxRE0sT0FBTyxBQUN4QjtZQUFJLE9BQUEsQUFBTyxhQUFYLEFBQXdCLFVBQVUsQUFDaEM7ZUFBQSxBQUFLLFdBQUwsQUFBZ0IsVUFBaEIsQUFBMEIsQUFDM0I7QUFGRCxtQkFFVyxRQUFBLEFBQU8saURBQVAsQUFBTyxlQUFYLEFBQXdCLFVBQVUsQUFDdkM7ZUFBQSxBQUFLLFlBQUwsQUFBaUIsQUFDbEI7QUFGTSxTQUFBLE1BRUEsQUFDTDtnQkFBTSxNQUFOLEFBQU0sQUFBTSxBQUNiO0FBQ0Y7QUE3RFk7QUFBQTtXQUFBO2lDQUFBLEFBK0RGLEtBL0RFLEFBK0RHLE9BQU8sQUFDckI7YUFBQSxBQUFLLE9BQUwsQUFBWSxPQUFaLEFBQW1CLEFBQ3BCO0FBakVZO0FBQUE7V0FBQTtrQ0FBQSxBQW1FRCxLQUFLO3FCQUNmOztlQUFBLEFBQU8sS0FBSyxLQUFaLEFBQVksQUFBSyxRQUFqQixBQUF5QixRQUFRLFVBQUEsQUFBQyxLQUFRLEFBQ3hDO2lCQUFBLEFBQUssV0FBTCxBQUFnQixLQUFLLElBQXJCLEFBQXFCLEFBQUksQUFDMUI7QUFGRCxBQUdEO0FBdkVZO0FBQUE7V0FBQTswQkFDTyxBQUNsQjtlQUFPLEtBQVAsQUFBTyxBQUFLLEFBQ2I7QUFIWTtBQUFBO1dBQUE7MEJBb0JGLEFBQ1Q7ZUFBTyxLQUFQLEFBQU8sQUFBSyxBQUNiO0FBdEJZO0FBQUE7V0FBQTswQkF3QkosQUFDUDtlQUFPLEtBQVAsQUFBTyxBQUFLLEFBQ2I7QUExQlk7QUFBQTs7V0FBQTtJQUFBLEFBQTJCO0E7Ozs7Ozs7Ozs7QUM3RDFDO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFBLEFBQVMsWUFBVCxBQUFxQixHQUFyQixBQUF3QixHQUF4QixBQUEyQixHQUEzQixBQUE4QixHQUFHLEFBQy9CO1NBQVMsSUFBRCxBQUFLLElBQU4sQUFBVyxJQUFsQixBQUF1QixBQUN4Qjs7O0FBRUQsU0FBQSxBQUFTLFNBQVQsQUFBa0IsSUFBbEIsQUFBc0IsSUFBSSxBQUN4QjtTQUFPLEtBQUEsQUFBSyxLQUFLLFNBQUUsR0FBQSxBQUFHLFFBQVEsR0FBYixBQUFnQixPQUFoQixBQUEwQixjQUFPLEdBQUEsQUFBRyxRQUFRLEdBQTVDLEFBQStDLE9BQWhFLEFBQU8sQUFBVSxBQUF5RCxBQUMzRTs7O0FBRUQsU0FBQSxBQUFTLFNBQVQsQUFBa0IsUUFBbEIsQUFBMEIsV0FBVyxBQUNuQztNQUFJLElBQUosQUFBUSxBQUNSO1NBQU8sS0FBUCxBQUFZLE1BQU0sQUFDaEI7UUFBSSxFQUFBLEFBQUUsYUFBYSxFQUFBLEFBQUUsVUFBRixBQUFZLFNBQS9CLEFBQW1CLEFBQXFCLFlBQVksQUFDbEQ7YUFBQSxBQUFPLEFBQ1I7QUFDRDtRQUFJLEVBQUosQUFBTSxBQUNQO0FBQ0Q7U0FBQSxBQUFPLEFBQ1I7OztRLEFBRVEsYyxBQUFBO1EsQUFBYSxXLEFBQUE7USxBQUFVLFcsQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QmhDOzs7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFQQTtBQUNBOztBQUVBOztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBTSxVQUFTLE9BQUEsQUFBTyxVQUFXLGFBQUE7ZUFBQSxBQUFTO0FBQTFDOztBQUVBLElBQU0sT0FBTyxRQUFiLEFBQWEsQUFBTztBQUNwQixJQUFNLFdBQVcsUUFBakIsQUFBaUIsQUFBTztBQUN4QixJQUFNLGtCQUFrQixRQUF4QixBQUF3QixBQUFPO0FBQy9CLElBQU0sWUFBWSxRQUFsQixBQUFrQixBQUFPOztBQUV6QixJQUFNLHFCQUFOLEFBQTJCO0FBQzNCLElBQU0sOEJBQU4sQUFBb0M7O0FBRXBDLElBQU0sTUFBTSxPQUFBLEFBQU8sZUFBUCxBQUFzQixLQUFsQyxBQUFZLEFBQTJCOztrQkFFeEIsYUFBQTttQ0FBQTtzQkFBQTs7c0JBQUE7NEJBQUE7OzhHQUFBO0FBQUE7OztXQUViOztBQUZhO3lDQUdNLEFBQ2pCO2VBQUEsQUFBTyxBQUNSO0FBRUQ7O0FBUGE7O0FBQUE7V0FBQTtpQ0FRRixBQUNUOztrQkFBTyxBQUNHLEFBQ1I7OEJBRkssQUFFZSxBQUNwQjtzQkFIRixBQUFPLEFBR08sQUFFZjtBQUxRLEFBQ0w7QUFNSjs7QUFoQmE7O0FBQUE7V0FBQTtvQ0FpQkM7cUJBQ1o7OztrQkFDVSxnQkFBQSxBQUFDLEdBQU0sQUFDYjtnQkFBSSxNQUFKLEFBQVUsTUFBTSxPQUFoQixBQUFnQixBQUFLLFlBQ2hCLE9BQUEsQUFBSyxBQUNYO0FBSkksQUFLTDtzQkFBWSxvQkFBQSxBQUFDLEdBQU0sQUFDakI7Z0JBQUksTUFBSixBQUFVLE1BQU0sT0FBaEIsQUFBZ0IsQUFBSyxlQUNoQixPQUFBLEFBQUssQUFDWDtBQVJILEFBQU8sQUFVUjtBQVZRLEFBQ0w7QUFXSjs7QUE5QmE7O0FBQUE7V0FBQTtxQ0FBQSxBQStCRSxJQS9CRixBQStCTSxPQUFPLEFBQ3hCO3VIQUFBLEFBQXFCLElBQXJCLEFBQXlCLEFBRXpCOzthQUFBLEFBQUssQUFDTDthQUFBLEFBQUssQUFDTDthQUFBLEFBQUssQUFFTDs7YUFBQSxBQUFLLE9BQU8sS0FBWixBQUFpQixBQUNqQjtZQUFJLENBQUMsS0FBTCxBQUFVLFlBQVksS0FBQSxBQUFLLEFBQzNCO1lBQUksS0FBSixBQUFTLFlBQVksS0FBQSxBQUFLLE1BQUwsQUFBVyxNQUFYLEFBQWlCLFVBQWpCLEFBQTJCLEFBRWhEOztlQUFBLEFBQU8sQUFDUjtBQTNDWTtBQUFBO1dBQUE7eUNBNkNNLEFBQ2pCO1lBQUEsQUFBSSxNQUFKLEFBQVUsU0FBUyxFQUFFLE9BQU8sS0FBQSxBQUFLLEtBQUwsQUFBVSxjQUF0QyxBQUFtQixBQUFTLEFBQXdCLEFBQ3BEO1lBQUEsQUFBSSxNQUFKLEFBQVUsV0FBVyxFQUFFLE9BQU8sS0FBQSxBQUFLLEtBQUwsQUFBVSxjQUF4QyxBQUFxQixBQUFTLEFBQXdCLEFBQ3ZEO0FBaERZO0FBQUE7V0FBQTtzQ0FrREcsQUFDZDtZQUFBLEFBQUksTUFBSixBQUFVLFVBQVUsRUFBRSxPQUFGLEFBQVMsR0FBRyxVQUFoQyxBQUFvQixBQUFzQixBQUMxQztZQUFBLEFBQUksTUFBSixBQUFVLFVBQVUsRUFBRSxPQUFGLEFBQVMsR0FBRyxVQUFoQyxBQUFvQixBQUFzQixBQUMxQztZQUFBLEFBQUksTUFBSixBQUFVLFNBQVMsRUFBRSxPQUFGLEFBQVMsR0FBRyxVQUEvQixBQUFtQixBQUFzQixBQUN6QztZQUFBLEFBQUksTUFBSixBQUFVLFNBQVMsRUFBRSxPQUFGLEFBQVMsR0FBRyxVQUEvQixBQUFtQixBQUFzQixBQUN6QztZQUFBLEFBQUksTUFBSixBQUFVLGFBQWEsRUFBRSxPQUFGLEFBQVMsR0FBRyxVQUFuQyxBQUF1QixBQUFzQixBQUM3QztZQUFBLEFBQUksTUFBSixBQUFVLGFBQWEsRUFBRSxPQUFGLEFBQVMsR0FBRyxVQUFuQyxBQUF1QixBQUFzQixBQUM3QztZQUFBLEFBQUksTUFBSixBQUFVLGVBQWUsRUFBRSxVQUEzQixBQUF5QixBQUFZLEFBQ3JDO1lBQUEsQUFBSSxNQUFKLEFBQVUsaUJBQWlCLEVBQUUsT0FBRixBQUFTLE9BQU8sVUFBM0MsQUFBMkIsQUFBMEIsQUFDckQ7WUFBQSxBQUFJLE1BQUosQUFBVSxhQUFhLEVBQUUsT0FBRixBQUFTLE1BQU0sVUFBdEMsQUFBdUIsQUFBeUIsQUFDaEQ7WUFBQSxBQUFJLE1BQUosQUFBVSxZQUFZLEVBQUUsT0FBRixBQUFTLEdBQUcsVUFBbEMsQUFBc0IsQUFBc0IsQUFDNUM7WUFBQSxBQUFJLE1BQUosQUFBVSxtQkFBbUIsRUFBRSxPQUFGLEFBQVMsR0FBRyxVQUF6QyxBQUE2QixBQUFzQixBQUNuRDtZQUFBLEFBQUksTUFBSixBQUFVLGNBQWMsRUFBRSxPQUFGLEFBQVMsR0FBRyxVQUFwQyxBQUF3QixBQUFzQixBQUM5QztZQUFBLEFBQUksTUFBSixBQUFVLDJCQUEyQixFQUFFLE9BQUYsQUFBUyxPQUFPLFVBQXJELEFBQXFDLEFBQTBCLEFBQy9EO1lBQUEsQUFBSSxNQUFKLEFBQVUsWUFBWSxFQUFFLE9BQUYsQUFBUyxPQUFPLFVBQXRDLEFBQXNCLEFBQTBCLEFBQ2hEO1lBQUEsQUFBSSxNQUFKLEFBQVUsWUFBWSxFQUFFLFVBQXhCLEFBQXNCLEFBQVksQUFDbEM7WUFBQSxBQUFJLE1BQUosQUFBVSxlQUFlLEVBQUUsVUFBM0IsQUFBeUIsQUFBWSxBQUNyQztZQUFBLEFBQUksTUFBSixBQUFVLGFBQWEsRUFBRSxVQUFGLEFBQVksTUFBTSxjQUF6QyxBQUF1QixBQUFnQyxBQUN4RDtBQXBFWTtBQUFBO1dBQUE7c0NBc0VHLEFBQ2Q7WUFBQSxBQUFJLE1BQUosQUFBVSxzQkFBc0IsRUFBRSxPQUFPLEtBQUEsQUFBSyxtQkFBTCxBQUF3QixLQUFqRSxBQUFnQyxBQUFTLEFBQTZCLEFBQ3RFO1lBQUEsQUFBSSxNQUFKLEFBQVUscUJBQXFCLEVBQUUsT0FBTyxLQUFBLEFBQUssa0JBQUwsQUFBdUIsS0FBL0QsQUFBK0IsQUFBUyxBQUE0QixBQUNwRTtZQUFBLEFBQUksTUFBSixBQUFVLG9CQUFvQixFQUFFLE9BQU8sS0FBQSxBQUFLLGlCQUFMLEFBQXNCLEtBQTdELEFBQThCLEFBQVMsQUFBMkIsQUFDbEU7WUFBQSxBQUFJLE1BQUosQUFBVSxzQkFBc0IsRUFBRSxPQUFPLEtBQUEsQUFBSyxtQkFBTCxBQUF3QixLQUFqRSxBQUFnQyxBQUFTLEFBQTZCLEFBQ3RFO1lBQUEsQUFBSSxNQUFKLEFBQVUsMEJBQTBCLEVBQUUsT0FBTyxLQUFBLEFBQUssdUJBQUwsQUFBNEIsS0FBekUsQUFBb0MsQUFBUyxBQUFpQyxBQUMvRTtBQTVFWTtBQUFBO1dBQUE7MENBOEVPLEFBQ2xCO2lCQUFBLEFBQVMsaUJBQVQsQUFBMEIsY0FBYyxLQUF4QyxBQUE2QyxvQkFBb0IsRUFBRSxTQUFuRSxBQUFpRSxBQUFXLEFBQzVFO2lCQUFBLEFBQVMsaUJBQVQsQUFBMEIsYUFBYSxLQUF2QyxBQUE0QyxtQkFBbUIsRUFBRSxTQUFqRSxBQUErRCxBQUFXLEFBQzFFO2lCQUFBLEFBQVMsaUJBQVQsQUFBMEIsWUFBWSxLQUF0QyxBQUEyQyxrQkFBa0IsRUFBRSxTQUEvRCxBQUE2RCxBQUFXLEFBRXhFOzthQUFBLEFBQUssTUFBTCxBQUFXLGlCQUFYLEFBQTRCLFNBQVMsS0FBckMsQUFBMEMsQUFDM0M7QUFwRlk7QUFBQTtXQUFBOzZDQXNGVSxBQUNyQjtpQkFBQSxBQUFTLG9CQUFULEFBQTZCLGNBQWMsS0FBM0MsQUFBZ0Qsb0JBQW9CLEVBQUUsU0FBdEUsQUFBb0UsQUFBVyxBQUMvRTtpQkFBQSxBQUFTLG9CQUFULEFBQTZCLGFBQWEsS0FBMUMsQUFBK0MsbUJBQW1CLEVBQUUsU0FBcEUsQUFBa0UsQUFBVyxBQUM3RTtpQkFBQSxBQUFTLG9CQUFULEFBQTZCLFlBQVksS0FBekMsQUFBOEMsa0JBQWtCLEVBQUUsU0FBbEUsQUFBZ0UsQUFBVyxBQUUzRTs7YUFBQSxBQUFLLE1BQUwsQUFBVyxvQkFBWCxBQUErQixTQUFTLEtBQXhDLEFBQTZDLEFBQzlDO0FBNUZZO0FBQUE7V0FBQTs2Q0E4RlUsQUFDckI7WUFBSSxDQUFDLEtBQUwsQUFBVSx5QkFBeUIsQUFDakM7ZUFBQSxBQUFLLDBCQUFMLEFBQStCLEFBQy9CO2dDQUFzQixLQUF0QixBQUEyQixBQUM1QjtBQUNGO0FBbkdZO0FBQUE7V0FBQTtzQ0FBQSxBQXFHRyxTQUFTO3FCQUN2Qjs7WUFBSSxRQUFBLEFBQVEsV0FBWixBQUF1QixHQUFHLE9BQU8sUUFBUCxBQUFPLEFBQVEsQUFDekM7cUJBQU8sQUFBTSxVQUFOLEFBQWdCLE9BQWhCLEFBQXVCLEtBQXZCLEFBQTRCLFNBQVMsVUFBQSxBQUFDLEtBQUQsQUFBTSxPQUFVLEFBQzFEO2NBQU0sT0FBTyw4QkFBYixBQUFhLEFBQWUsQUFDNUI7d0JBQWUsSUFBUixBQUFZO2tCQUFRLEFBRXpCO21CQUZLLEFBQW9CO0FBQUEsQUFDekIsV0FETSxHQUFSLEFBR0ksQUFDTDtBQU5NLFNBQUE7Z0JBT0MsT0FETCxBQUNZLEFBQ2I7aUJBUkssQUFNSixBQUVNO0FBRk4sQUFDRCxXQVBGLEFBU0csQUFDSjtBQWpIWTtBQUFBO1dBQUE7eUNBQUEsQUFtSE0sR0FBRyxBQUNwQjtZQUFJLEVBQUEsQUFBRSxRQUFGLEFBQVUsV0FBZCxBQUF5QixHQUFHLEFBQzFCO2VBQUEsQUFBSyxjQUFMLEFBQW1CLEFBRW5COztjQUFNLFFBQVEsRUFBQSxBQUFFLFFBQWhCLEFBQWMsQUFBVSxBQUN4QjtlQUFBLEFBQUssU0FBUyxNQUFkLEFBQW9CLEFBQ3BCO2VBQUEsQUFBSyxTQUFTLE1BQWQsQUFBb0IsQUFDcEI7ZUFBQSxBQUFLLFFBQVEsTUFBYixBQUFtQixBQUNuQjtlQUFBLEFBQUssUUFBUSxNQUFiLEFBQW1CLEFBQ25CO2VBQUEsQUFBSyxZQUFZLE1BQWpCLEFBQXVCLEFBQ3ZCO2VBQUEsQUFBSyxZQUFZLE1BQWpCLEFBQXVCLEFBRXZCOztjQUFJLEtBQUEsQUFBSyxVQUFXLEtBQUEsQUFBSyxRQUFRLE9BQUEsQUFBTyxhQUF4QyxBQUFxRCxHQUFJLEFBQ3ZEO2lCQUFBLEFBQUssQUFDTDtpQkFBQSxBQUFLLFdBQUwsQUFBZ0IsQUFDaEI7aUJBQUEsQUFBSyxZQUFMLEFBQWlCLEFBQ2xCO0FBQ0Y7QUFDRjtBQXJJWTtBQUFBO1dBQUE7d0NBQUEsQUF1SUssR0FBRyxBQUNuQjtZQUFJLEtBQUosQUFBUyxVQUFVLEFBQ2pCO2NBQU0sUUFBUSxLQUFBLEFBQUssZ0JBQWdCLEVBQW5DLEFBQWMsQUFBdUIsQUFDckM7ZUFBQSxBQUFLLFFBQVEsTUFBYixBQUFtQixBQUNuQjtlQUFBLEFBQUssUUFBUSxNQUFiLEFBQW1CLEFBRW5COztjQUFJLE9BQU8sS0FBUCxBQUFZLGdCQUFaLEFBQTRCLGVBQWUsS0FBL0MsQUFBb0QsZUFBZSxBQUNqRTtpQkFBQSxBQUFLLGNBQWMsS0FBQSxBQUFLLElBQUksS0FBQSxBQUFLLFNBQVMsS0FBdkIsQUFBNEIsU0FBUyxLQUFBLEFBQUssSUFBSSxLQUFBLEFBQUssU0FBUyxLQUEvRSxBQUF3RCxBQUE0QixBQUNwRjtnQkFBSSxDQUFDLEtBQUwsQUFBVSxhQUFhLEFBQ3JCO21CQUFBLEFBQUssWUFBTCxBQUFpQixBQUNqQjttQkFBQSxBQUFLLEFBQ047QUFDRjtBQUVEOztjQUFJLEtBQUosQUFBUyxhQUFhLEFBQ3BCO0FBQ0Q7QUFFRDs7WUFBQSxBQUFFLEFBRUY7O2VBQUEsQUFBSyxnQkFBTCxBQUFxQixBQUN0QjtBQUNGO0FBN0pZO0FBQUE7V0FBQTt1Q0ErSkksQUFDZjtZQUFJLEtBQUEsQUFBSyxXQUFULEFBQW9CLG9CQUFvQixBQUN0QztlQUFBLEFBQUssU0FBTCxBQUFjLFVBQWQsQUFBd0IsQUFDekI7QUFGRCxtQkFFVyxLQUFBLEFBQUssV0FBVyxDQUFwQixBQUFxQixvQkFBb0IsQUFDOUM7ZUFBQSxBQUFLLFNBQUwsQUFBYyxVQUFkLEFBQXdCLEFBQ3pCO0FBRk0sU0FBQSxVQUVJLEtBQUEsQUFBSyxjQUFjLEtBQUEsQUFBSyxjQUE1QixBQUEwQyxHQUFHLEFBQ2xEO2VBQUEsQUFBSyxTQUFMLEFBQWMsVUFBZCxBQUF3QixBQUN6QjtBQUZNLFNBQUEsTUFFQSxBQUNMO2VBQUEsQUFBSyxTQUFMLEFBQWMsVUFBZCxBQUF3QixBQUN6QjtBQUNGO0FBektZO0FBQUE7V0FBQTt1Q0FBQSxBQTJLSSxHQUFHLEFBQ2xCO1lBQUksS0FBSixBQUFTLFVBQVUsQUFDakI7Y0FBSSxLQUFBLEFBQUssZUFBZSxFQUFBLEFBQUUsUUFBRixBQUFVLFNBQWxDLEFBQTJDLEdBQUcsQUFDNUM7QUFDRDtBQUVEOztjQUFJLEtBQUosQUFBUyxlQUFlLEFBQ3RCO2lCQUFBLEFBQUssQUFDTjtBQUVEOztjQUFJLEtBQUosQUFBUyxRQUFRLEFBQ2Y7aUJBQUEsQUFBSyxNQUFMLEFBQVcsTUFBWCxBQUFpQixnQkFBakIsQUFBaUMsQUFDbEM7QUFGRCxpQkFFTyxBQUNMO2lCQUFBLEFBQUssTUFBTCxBQUFXLE1BQVgsQUFBaUIsZ0JBQWpCLEFBQWlDLEFBQ2xDO0FBRUQ7O2VBQUEsQUFBSyxZQUFMLEFBQWlCLEFBQ2pCO2VBQUEsQUFBSyxnQkFBTCxBQUFxQixBQUNyQjtlQUFBLEFBQUssV0FBTCxBQUFnQixBQUNqQjtBQUNGO0FBL0xZO0FBQUE7V0FBQTsyQ0FpTVEsQUFDbkI7YUFBQSxBQUFLLEFBQ047QUFuTVk7QUFBQTtXQUFBO3dDQXFNSyxBQUNoQjthQUFBLEFBQUssUUFBTCxBQUFhLE1BQWIsQUFBbUIsYUFBbkIsQUFBZ0MsQUFDaEM7YUFBQSxBQUFLLE1BQUwsQUFBVyxNQUFYLEFBQWlCLGFBQWpCLEFBQThCLEFBQzlCO2FBQUEsQUFBSyxRQUFMLEFBQWEsVUFBYixBQUF1QixPQUF2QixBQUE4QixBQUM5QjthQUFBLEFBQUssY0FBYyxLQUFuQixBQUFtQixBQUFLLEFBQ3pCO0FBMU1ZO0FBQUE7V0FBQTs4Q0E0TVcsQUFDdEI7QUFDQTtBQUNBO0FBQ0E7ZUFBTyxDQUFDLEtBQUEsQUFBSyxRQUFiLEFBQXFCLEFBQ3RCO0FBak5ZO0FBQUE7V0FBQTtnQ0FBQSxBQW1OSCxRQUFRLEFBQ2hCO2FBQUEsQUFBSyxBQUNMO2FBQUEsQUFBSyxTQUFMLEFBQWMsVUFBZCxBQUF3QixBQUN4QjthQUFBLEFBQUssWUFBTCxBQUFpQixBQUNqQjthQUFBLEFBQUssQUFDTjtBQXhOWTtBQUFBO1dBQUE7NkJBQUEsQUEwTk4sUUFBUSxBQUNiO2FBQUEsQUFBSyxBQUNMO2FBQUEsQUFBSyxTQUFMLEFBQWMsVUFBZCxBQUF3QixBQUN4QjthQUFBLEFBQUssWUFBTCxBQUFpQixBQUNqQjthQUFBLEFBQUssa0JBQWtCLFNBQVMsS0FBaEMsQUFBcUMsQUFDckM7YUFBQSxBQUFLLEFBQ0w7YUFBQSxBQUFLLFVBQVUsS0FBZixBQUFvQixpQkFBaUIsS0FBckMsQUFBMEMsQUFDM0M7QUFqT1k7QUFBQTtXQUFBO3lDQW1PTSxBQUNqQjtZQUFNLFNBQVMsS0FBQSxBQUFLLFFBQVEsS0FBNUIsQUFBaUMsQUFDakM7YUFBQSxBQUFLLGFBQWEsS0FBQSxBQUFLLGtCQUF2QixBQUF5QyxBQUN6QzthQUFBLEFBQUssYUFBYSxLQUFBLEFBQUssSUFBTCxBQUFTLEdBQUcsS0FBQSxBQUFLLElBQUksS0FBVCxBQUFjLGFBQWEsS0FBekQsQUFBa0IsQUFBWSxBQUFnQyxBQUM5RDtlQUFBLEFBQU8sQUFDUjtBQXhPWTtBQUFBO1dBQUE7NkNBQUEsQUEwT1UsTUFBTSxBQUMzQjtnQkFBUSxLQUFSLEFBQWEsQUFDWDtlQUFBLEFBQUssQUFBVTtBQUNiO21CQUFBLEFBQUssY0FBTCxBQUFtQixBQUNuQjtBQUNEO0FBRUQ7O2VBQUEsQUFBSyxBQUFpQjtBQUNwQjttQkFBQSxBQUFLLG9CQUFMLEFBQXlCLEFBQ3pCO21CQUFBLEFBQUssWUFBTCxBQUFpQixBQUNqQjttQkFBQSxBQUFLLHVCQUhlLEFBR3BCLEFBQTRCLE9BQU8sQUFDbkM7QUFDRDtBQUVEOztlQUFBLEFBQUssQUFBVztBQUNkO21CQUFBLEFBQUssZUFBTCxBQUFvQixBQUNwQjtBQUNEO0FBRUQ7O0FBQVM7QUFDUDtBQUNEO0FBcEJILEFBc0JEOztBQWpRWTtBQUFBO1dBQUE7b0NBQUEsQUFtUUMsTUFBTSxBQUNsQjtZQUFNLFdBQVcsT0FBTyxLQUF4QixBQUE2QixBQUU3Qjs7WUFBSSxXQUFKLEFBQWUsR0FBRyxBQUNoQjtjQUFNLFlBQVksS0FBQSxBQUFLLFFBQVEsS0FBL0IsQUFBb0MsQUFDcEM7ZUFBQSxBQUFLLFdBQVksK0JBQStCLFlBQWhDLEFBQUMsQUFBMkMsWUFDM0MsQ0FBQyxJQUFELEFBQUssK0JBQStCLEtBRHJELEFBQzBELEFBQzNEO0FBRUQ7O2FBQUEsQUFBSyxBQUNMO2FBQUEsQUFBSyxVQUFVLEtBQWYsQUFBb0IsWUFBWSxLQUFoQyxBQUFxQyxBQUVyQzs7YUFBQSxBQUFLLFdBQUwsQUFBZ0IsQUFDaEI7YUFBQSxBQUFLLFlBQVksS0FBakIsQUFBc0IsQUFDdEI7YUFBQSxBQUFLLFlBQVksS0FBakIsQUFBc0IsQUFFdEI7OzhCQUFzQixLQUF0QixBQUEyQixBQUM1QjtBQXBSWTtBQUFBO1dBQUE7MENBQUEsQUFzUk8sTUFBTSxBQUN4QjthQUFBLEFBQUssQUFFTDs7QUFDQTtBQUNBO1lBQU0sWUFBTixBQUFrQixBQUNsQjtrQkFBQSxBQUFVLFNBQVMsS0FBbkIsQUFBd0IsQUFDeEI7a0JBQUEsQUFBVSxPQUFPLENBQUMsS0FBQSxBQUFLLFNBQUwsQUFBYyxJQUFmLEFBQW1CLEtBQUssS0FBekMsQUFBOEMsQUFDOUM7a0JBQUEsQUFBVSxnQkFBZ0IsVUFBQSxBQUFVLE9BQU8sVUFBM0MsQUFBcUQsQUFDckQ7a0JBQUEsQUFBVSxZQUFWLEFBQXNCLEFBQ3RCO2FBQUEsQUFBSyxZQUFMLEFBQWlCLEFBQ2xCO0FBalNZO0FBQUE7V0FBQTtxQ0FBQSxBQW1TRSxNQUFNLEFBQ25CO1lBQU0sa0JBQWtCLE9BQU8sS0FBQSxBQUFLLFVBQXBDLEFBQThDLEFBRTlDOztZQUFJLGtCQUFrQixLQUF0QixBQUEyQixvQkFBb0IsQUFDN0M7ZUFBQSxBQUFLLGNBQUwsQUFBbUIsQUFDcEI7QUFGRCxlQUVPLEFBQ0w7ZUFBQSxBQUFLLEFBQ047QUFFRDs7YUFBQSxBQUFLLFVBQVUsS0FBZixBQUFvQixpQkFBaUIsS0FBckMsQUFBMEMsQUFDM0M7QUE3U1k7QUFBQTtXQUFBO29DQUFBLEFBK1NDLGlCQUFpQixBQUM3QjtZQUFNLGFBQWEsS0FBQSxBQUFLLFVBQXhCLEFBQWtDLEFBQ2xDO1lBQU0sZ0JBQWdCLEtBQUEsQUFBSyxVQUEzQixBQUFxQyxBQUNyQzthQUFBLEFBQUssa0JBQWtCLHlCQUFBLEFBQVksaUJBQVosQUFBNkIsWUFBN0IsQUFBeUMsZUFDOUQsS0FERixBQUF1QixBQUNoQixBQUNQOzhCQUFzQixLQUF0QixBQUEyQixBQUM1QjtBQXJUWTtBQUFBO1dBQUE7cUNBdVRFLEFBQ2I7QUFDQTthQUFBLEFBQUssa0JBQWtCLEtBQUEsQUFBSyxVQUE1QixBQUFzQyxBQUN0QztlQUFPLEtBQVAsQUFBWSxBQUNaO2FBQUEsQUFBSyxBQUNOO0FBNVRZO0FBQUE7V0FBQTtxQ0E4VEUsQUFDYjthQUFBLEFBQUssMEJBQUwsQUFBK0IsQUFDL0I7YUFBQSxBQUFLLFlBQUwsQUFBaUIsQUFDakI7YUFBQSxBQUFLLFdBQUwsQUFBZ0IsQUFFaEI7O1lBQUksS0FBSixBQUFTLFFBQVEsQUFDZjtBQUNBO2VBQUEsQUFBSyxNQUFMLEFBQVcsTUFBWCxBQUFpQixnQkFBakIsQUFBaUMsQUFDakM7ZUFBQSxBQUFLLFFBQUwsQUFBYSxVQUFiLEFBQXVCLElBQXZCLEFBQTJCLEFBQzVCO0FBSkQsZUFJTyxBQUNMO0FBQ0E7ZUFBQSxBQUFLLE1BQUwsQUFBVyxNQUFYLEFBQWlCLGdCQUFqQixBQUFpQyxBQUNsQztBQUVEOzthQUFBLEFBQUssUUFBTCxBQUFhLE1BQWIsQUFBbUIsYUFBbkIsQUFBZ0MsQUFDaEM7YUFBQSxBQUFLLE1BQUwsQUFBVyxNQUFYLEFBQWlCLGFBQWpCLEFBQThCLEFBRTlCOzthQUFBLEFBQUssVUFBTCxBQUFlLEFBQ2hCO0FBaFZZO0FBQUE7V0FBQTtnQ0FBQSxBQWtWSCxZQWxWRyxBQWtWUyxhQUFhLEFBQ2pDO2FBQUEsQUFBSyxRQUFMLEFBQWEsTUFBYixBQUFtQiw0QkFBbkIsQUFBNkMsYUFDN0M7YUFBQSxBQUFLLE1BQUwsQUFBVyxNQUFYLEFBQWlCLFVBQVUsYUFBM0IsQUFBd0MsQUFDekM7QUFyVlk7QUFBQTtXQUFBOzhCQXVWTCxBQUNOO2FBQUEsQUFBSyxVQUFMLEFBQWUsQUFDZjtlQUFBLEFBQU8sQUFDUjtBQTFWWTtBQUFBO1dBQUE7NkJBNFZOLEFBQ0w7YUFBQSxBQUFLLFVBQUwsQUFBZSxBQUNmO2VBQUEsQUFBTyxBQUNSO0FBL1ZZO0FBQUE7V0FBQTsrQkFpV0osQUFDUDtZQUFJLEtBQUosQUFBUyxRQUFRLEFBQ2Y7ZUFBQSxBQUFLLEFBQ047QUFGRCxlQUVPLEFBQ0w7ZUFBQSxBQUFLLEFBQ047QUFDRDtlQUFBLEFBQU8sQUFDUjtBQXhXWTtBQUFBO1dBQUE7Z0NBMFdILEFBQ1I7YUFBQSxBQUFLLE1BQUwsQUFBVyxNQUFYLEFBQWlCLFVBQWpCLEFBQTJCLEFBQzNCO2FBQUEsQUFBSyxBQUNMO2FBQUEsQUFBSyxTQUFMLEFBQWMsY0FBZCxBQUE0QixBQUM3QjtBQTlXWTtBQUFBO1dBQUE7a0NBZ1hELEFBQ1Y7YUFBQSxBQUFLLE1BQUwsQUFBVyxNQUFYLEFBQWlCLFVBQWpCLEFBQTJCLEFBQzNCO2FBQUEsQUFBSyxBQUNMO2FBQUEsQUFBSyxTQUFMLEFBQWMsY0FBZCxBQUE0QixBQUM3QjtBQXBYWTtBQUFBOztXQUFBO0lBQW1CLDZCQUFuQixBQUFtQixBQUFjO0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdENoRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBSkE7QUFDQTs7QUFFQTs7QUFHQSxJQUFNLFFBQU47O0FBdURBLFNBQUEsQUFBUyxtQkFBVCxBQUE0QixTQUFTLEFBQ25DO1NBQU8sU0FBQSxBQUFTLGNBQVQsQUFBdUIseUJBQTlCLEFBQU8sQUFBZ0QsQUFDeEQ7OztJLEFBRW9CO29CQUNuQjs7a0JBQUEsQUFBWSxJQUFaLEFBQWdCLE9BQU87MEJBQUE7OzBHQUVyQjs7VUFBQSxBQUFLLGVBQUwsQUFBb0IsSUFGQyxBQUVyQixBQUF3QjtXQUN6QjtBQUVEOzs7Ozs7OzZCLEFBQ1MsSUFBSSxBQUNYO1VBQUksQ0FBSixBQUFLLElBQUksTUFBTSxNQUFOLEFBQU0sQUFBTSxBQUVyQjs7VUFBTSxRQUFRLFNBQUEsQUFBUyxjQUF2QixBQUFjLEFBQXVCLEFBQ3JDO1lBQUEsQUFBTSxVQUFOLEFBQWdCLElBQWhCLEFBQW9CLEFBRXBCOztVQUFNLFVBQVUsU0FBQSxBQUFTLGNBQXpCLEFBQWdCLEFBQXVCLEFBQ3ZDO2NBQUEsQUFBUSxVQUFSLEFBQWtCLElBQWxCLEFBQXNCLEFBQ3RCO2FBQU8sR0FBQSxBQUFHLFNBQUgsQUFBWSxTQUFuQixBQUE0QixHQUFHLEFBQzdCO2dCQUFBLEFBQVEsWUFBWSxHQUFBLEFBQUcsU0FBdkIsQUFBb0IsQUFBWSxBQUNqQztBQUVEOztTQUFBLEFBQUcsWUFBSCxBQUFlLEFBQ2Y7U0FBQSxBQUFHLFlBQUgsQUFBZSxBQUVmOztVQUFNLE1BQU0sU0FBQSxBQUFTLHFCQUFULEFBQThCLFNBQTFDLEFBQVksQUFBdUMsQUFDbkQ7VUFBQSxBQUFJLFdBQUosQUFBZSxhQUFhLG1CQUE1QixBQUE0QixBQUFtQixRQUEvQyxBQUF1RCxBQUV2RDs7YUFBQSxBQUFPLEFBQ1I7Ozs7O0VBMUJpQyxXOztrQixBQUFmOzs7QUNqRXJCOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZDtBQUFpQixZQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxlQUFlLFFBQVEsY0FBUixDQUFuQjtBQUNBOzs7OztBQUtBLElBQUksa0JBQW1CLFVBQVUsTUFBVixFQUFrQjtBQUNyQyxjQUFVLGVBQVYsRUFBMkIsTUFBM0I7QUFDQSxhQUFTLGVBQVQsQ0FBeUIsTUFBekIsRUFBaUMsVUFBakMsRUFBNkMsVUFBN0MsRUFBeUQ7QUFDckQsZUFBTyxJQUFQLENBQVksSUFBWjtBQUNBLGFBQUssTUFBTCxHQUFjLE1BQWQ7QUFDQSxhQUFLLFVBQUwsR0FBa0IsVUFBbEI7QUFDQSxhQUFLLFVBQUwsR0FBa0IsVUFBbEI7QUFDQSxhQUFLLEtBQUwsR0FBYSxDQUFiO0FBQ0g7QUFDRCxvQkFBZ0IsU0FBaEIsQ0FBMEIsS0FBMUIsR0FBa0MsVUFBVSxLQUFWLEVBQWlCO0FBQy9DLGFBQUssTUFBTCxDQUFZLFVBQVosQ0FBdUIsS0FBSyxVQUE1QixFQUF3QyxLQUF4QyxFQUErQyxLQUFLLFVBQXBELEVBQWdFLEtBQUssS0FBTCxFQUFoRSxFQUE4RSxJQUE5RTtBQUNILEtBRkQ7QUFHQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsTUFBMUIsR0FBbUMsVUFBVSxLQUFWLEVBQWlCO0FBQ2hELGFBQUssTUFBTCxDQUFZLFdBQVosQ0FBd0IsS0FBeEIsRUFBK0IsSUFBL0I7QUFDQSxhQUFLLFdBQUw7QUFDSCxLQUhEO0FBSUEsb0JBQWdCLFNBQWhCLENBQTBCLFNBQTFCLEdBQXNDLFlBQVk7QUFDOUMsYUFBSyxNQUFMLENBQVksY0FBWixDQUEyQixJQUEzQjtBQUNBLGFBQUssV0FBTDtBQUNILEtBSEQ7QUFJQSxXQUFPLGVBQVA7QUFDSCxDQXJCc0IsQ0FxQnJCLGFBQWEsVUFyQlEsQ0FBdkI7QUFzQkEsUUFBUSxlQUFSLEdBQTBCLGVBQTFCO0FBQ0E7OztBQ25DQTs7QUFDQSxJQUFJLGVBQWUsUUFBUSxjQUFSLENBQW5CO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBY0EsSUFBSSxlQUFnQixZQUFZO0FBQzVCLGFBQVMsWUFBVCxDQUFzQixJQUF0QixFQUE0QixLQUE1QixFQUFtQyxLQUFuQyxFQUEwQztBQUN0QyxhQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsYUFBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLGFBQUssS0FBTCxHQUFhLEtBQWI7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsU0FBUyxHQUF6QjtBQUNIO0FBQ0Q7Ozs7O0FBS0EsaUJBQWEsU0FBYixDQUF1QixPQUF2QixHQUFpQyxVQUFVLFFBQVYsRUFBb0I7QUFDakQsZ0JBQVEsS0FBSyxJQUFiO0FBQ0ksaUJBQUssR0FBTDtBQUNJLHVCQUFPLFNBQVMsSUFBVCxJQUFpQixTQUFTLElBQVQsQ0FBYyxLQUFLLEtBQW5CLENBQXhCO0FBQ0osaUJBQUssR0FBTDtBQUNJLHVCQUFPLFNBQVMsS0FBVCxJQUFrQixTQUFTLEtBQVQsQ0FBZSxLQUFLLEtBQXBCLENBQXpCO0FBQ0osaUJBQUssR0FBTDtBQUNJLHVCQUFPLFNBQVMsUUFBVCxJQUFxQixTQUFTLFFBQVQsRUFBNUI7QUFOUjtBQVFILEtBVEQ7QUFVQTs7Ozs7Ozs7QUFRQSxpQkFBYSxTQUFiLENBQXVCLEVBQXZCLEdBQTRCLFVBQVUsSUFBVixFQUFnQixLQUFoQixFQUF1QixRQUF2QixFQUFpQztBQUN6RCxZQUFJLE9BQU8sS0FBSyxJQUFoQjtBQUNBLGdCQUFRLElBQVI7QUFDSSxpQkFBSyxHQUFMO0FBQ0ksdUJBQU8sUUFBUSxLQUFLLEtBQUssS0FBVixDQUFmO0FBQ0osaUJBQUssR0FBTDtBQUNJLHVCQUFPLFNBQVMsTUFBTSxLQUFLLEtBQVgsQ0FBaEI7QUFDSixpQkFBSyxHQUFMO0FBQ0ksdUJBQU8sWUFBWSxVQUFuQjtBQU5SO0FBUUgsS0FWRDtBQVdBOzs7Ozs7Ozs7QUFTQSxpQkFBYSxTQUFiLENBQXVCLE1BQXZCLEdBQWdDLFVBQVUsY0FBVixFQUEwQixLQUExQixFQUFpQyxRQUFqQyxFQUEyQztBQUN2RSxZQUFJLGtCQUFrQixPQUFPLGVBQWUsSUFBdEIsS0FBK0IsVUFBckQsRUFBaUU7QUFDN0QsbUJBQU8sS0FBSyxPQUFMLENBQWEsY0FBYixDQUFQO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsbUJBQU8sS0FBSyxFQUFMLENBQVEsY0FBUixFQUF3QixLQUF4QixFQUErQixRQUEvQixDQUFQO0FBQ0g7QUFDSixLQVBEO0FBUUE7Ozs7O0FBS0EsaUJBQWEsU0FBYixDQUF1QixZQUF2QixHQUFzQyxZQUFZO0FBQzlDLFlBQUksT0FBTyxLQUFLLElBQWhCO0FBQ0EsZ0JBQVEsSUFBUjtBQUNJLGlCQUFLLEdBQUw7QUFDSSx1QkFBTyxhQUFhLFVBQWIsQ0FBd0IsRUFBeEIsQ0FBMkIsS0FBSyxLQUFoQyxDQUFQO0FBQ0osaUJBQUssR0FBTDtBQUNJLHVCQUFPLGFBQWEsVUFBYixDQUF3QixLQUF4QixDQUE4QixLQUFLLEtBQW5DLENBQVA7QUFDSixpQkFBSyxHQUFMO0FBQ0ksdUJBQU8sYUFBYSxVQUFiLENBQXdCLEtBQXhCLEVBQVA7QUFOUjtBQVFBLGNBQU0sSUFBSSxLQUFKLENBQVUsb0NBQVYsQ0FBTjtBQUNILEtBWEQ7QUFZQTs7Ozs7OztBQU9BLGlCQUFhLFVBQWIsR0FBMEIsVUFBVSxLQUFWLEVBQWlCO0FBQ3ZDLFlBQUksT0FBTyxLQUFQLEtBQWlCLFdBQXJCLEVBQWtDO0FBQzlCLG1CQUFPLElBQUksWUFBSixDQUFpQixHQUFqQixFQUFzQixLQUF0QixDQUFQO0FBQ0g7QUFDRCxlQUFPLEtBQUssMEJBQVo7QUFDSCxLQUxEO0FBTUE7Ozs7Ozs7QUFPQSxpQkFBYSxXQUFiLEdBQTJCLFVBQVUsR0FBVixFQUFlO0FBQ3RDLGVBQU8sSUFBSSxZQUFKLENBQWlCLEdBQWpCLEVBQXNCLFNBQXRCLEVBQWlDLEdBQWpDLENBQVA7QUFDSCxLQUZEO0FBR0E7Ozs7QUFJQSxpQkFBYSxjQUFiLEdBQThCLFlBQVk7QUFDdEMsZUFBTyxLQUFLLG9CQUFaO0FBQ0gsS0FGRDtBQUdBLGlCQUFhLG9CQUFiLEdBQW9DLElBQUksWUFBSixDQUFpQixHQUFqQixDQUFwQztBQUNBLGlCQUFhLDBCQUFiLEdBQTBDLElBQUksWUFBSixDQUFpQixHQUFqQixFQUFzQixTQUF0QixDQUExQztBQUNBLFdBQU8sWUFBUDtBQUNILENBNUdtQixFQUFwQjtBQTZHQSxRQUFRLFlBQVIsR0FBdUIsWUFBdkI7QUFDQTs7O0FDOUhBOztBQUNBLElBQUksU0FBUyxRQUFRLGFBQVIsQ0FBYjtBQUNBLElBQUksaUJBQWlCLFFBQVEscUJBQVIsQ0FBckI7QUFDQSxJQUFJLGVBQWUsUUFBUSxxQkFBUixDQUFuQjtBQUNBOzs7Ozs7QUFNQSxJQUFJLGFBQWMsWUFBWTtBQUMxQjs7Ozs7OztBQU9BLGFBQVMsVUFBVCxDQUFvQixTQUFwQixFQUErQjtBQUMzQixhQUFLLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxZQUFJLFNBQUosRUFBZTtBQUNYLGlCQUFLLFVBQUwsR0FBa0IsU0FBbEI7QUFDSDtBQUNKO0FBQ0Q7Ozs7Ozs7QUFPQSxlQUFXLFNBQVgsQ0FBcUIsSUFBckIsR0FBNEIsVUFBVSxRQUFWLEVBQW9CO0FBQzVDLFlBQUksYUFBYSxJQUFJLFVBQUosRUFBakI7QUFDQSxtQkFBVyxNQUFYLEdBQW9CLElBQXBCO0FBQ0EsbUJBQVcsUUFBWCxHQUFzQixRQUF0QjtBQUNBLGVBQU8sVUFBUDtBQUNILEtBTEQ7QUFNQSxlQUFXLFNBQVgsQ0FBcUIsU0FBckIsR0FBaUMsVUFBVSxjQUFWLEVBQTBCLEtBQTFCLEVBQWlDLFFBQWpDLEVBQTJDO0FBQ3hFLFlBQUksV0FBVyxLQUFLLFFBQXBCO0FBQ0EsWUFBSSxPQUFPLGVBQWUsWUFBZixDQUE0QixjQUE1QixFQUE0QyxLQUE1QyxFQUFtRCxRQUFuRCxDQUFYO0FBQ0EsWUFBSSxRQUFKLEVBQWM7QUFDVixxQkFBUyxJQUFULENBQWMsSUFBZCxFQUFvQixLQUFLLE1BQXpCO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsaUJBQUssR0FBTCxDQUFTLEtBQUssYUFBTCxDQUFtQixJQUFuQixDQUFUO0FBQ0g7QUFDRCxZQUFJLEtBQUssa0JBQVQsRUFBNkI7QUFDekIsaUJBQUssa0JBQUwsR0FBMEIsS0FBMUI7QUFDQSxnQkFBSSxLQUFLLGVBQVQsRUFBMEI7QUFDdEIsc0JBQU0sS0FBSyxjQUFYO0FBQ0g7QUFDSjtBQUNELGVBQU8sSUFBUDtBQUNILEtBaEJEO0FBaUJBLGVBQVcsU0FBWCxDQUFxQixhQUFyQixHQUFxQyxVQUFVLElBQVYsRUFBZ0I7QUFDakQsWUFBSTtBQUNBLG1CQUFPLEtBQUssVUFBTCxDQUFnQixJQUFoQixDQUFQO0FBQ0gsU0FGRCxDQUdBLE9BQU8sR0FBUCxFQUFZO0FBQ1IsaUJBQUssZUFBTCxHQUF1QixJQUF2QjtBQUNBLGlCQUFLLGNBQUwsR0FBc0IsR0FBdEI7QUFDQSxpQkFBSyxLQUFMLENBQVcsR0FBWDtBQUNIO0FBQ0osS0FURDtBQVVBOzs7Ozs7O0FBT0EsZUFBVyxTQUFYLENBQXFCLE9BQXJCLEdBQStCLFVBQVUsSUFBVixFQUFnQixXQUFoQixFQUE2QjtBQUN4RCxZQUFJLFFBQVEsSUFBWjtBQUNBLFlBQUksQ0FBQyxXQUFMLEVBQWtCO0FBQ2QsZ0JBQUksT0FBTyxJQUFQLENBQVksRUFBWixJQUFrQixPQUFPLElBQVAsQ0FBWSxFQUFaLENBQWUsTUFBakMsSUFBMkMsT0FBTyxJQUFQLENBQVksRUFBWixDQUFlLE1BQWYsQ0FBc0IsT0FBckUsRUFBOEU7QUFDMUUsOEJBQWMsT0FBTyxJQUFQLENBQVksRUFBWixDQUFlLE1BQWYsQ0FBc0IsT0FBcEM7QUFDSCxhQUZELE1BR0ssSUFBSSxPQUFPLElBQVAsQ0FBWSxPQUFoQixFQUF5QjtBQUMxQiw4QkFBYyxPQUFPLElBQVAsQ0FBWSxPQUExQjtBQUNIO0FBQ0o7QUFDRCxZQUFJLENBQUMsV0FBTCxFQUFrQjtBQUNkLGtCQUFNLElBQUksS0FBSixDQUFVLHVCQUFWLENBQU47QUFDSDtBQUNELGVBQU8sSUFBSSxXQUFKLENBQWdCLFVBQVUsT0FBVixFQUFtQixNQUFuQixFQUEyQjtBQUM5QyxnQkFBSSxlQUFlLE1BQU0sU0FBTixDQUFnQixVQUFVLEtBQVYsRUFBaUI7QUFDaEQsb0JBQUksWUFBSixFQUFrQjtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQUk7QUFDQSw2QkFBSyxLQUFMO0FBQ0gscUJBRkQsQ0FHQSxPQUFPLEdBQVAsRUFBWTtBQUNSLCtCQUFPLEdBQVA7QUFDQSxxQ0FBYSxXQUFiO0FBQ0g7QUFDSixpQkFaRCxNQWFLO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQUssS0FBTDtBQUNIO0FBQ0osYUF2QmtCLEVBdUJoQixNQXZCZ0IsRUF1QlIsT0F2QlEsQ0FBbkI7QUF3QkgsU0F6Qk0sQ0FBUDtBQTBCSCxLQXZDRDtBQXdDQSxlQUFXLFNBQVgsQ0FBcUIsVUFBckIsR0FBa0MsVUFBVSxVQUFWLEVBQXNCO0FBQ3BELGVBQU8sS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixVQUF0QixDQUFQO0FBQ0gsS0FGRDtBQUdBOzs7OztBQUtBLGVBQVcsU0FBWCxDQUFxQixhQUFhLFlBQWxDLElBQWtELFlBQVk7QUFDMUQsZUFBTyxJQUFQO0FBQ0gsS0FGRDtBQUdBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQSxlQUFXLE1BQVgsR0FBb0IsVUFBVSxTQUFWLEVBQXFCO0FBQ3JDLGVBQU8sSUFBSSxVQUFKLENBQWUsU0FBZixDQUFQO0FBQ0gsS0FGRDtBQUdBLFdBQU8sVUFBUDtBQUNILENBOUhpQixFQUFsQjtBQStIQSxRQUFRLFVBQVIsR0FBcUIsVUFBckI7QUFDQTs7O0FDMUlBOztBQUNBLFFBQVEsS0FBUixHQUFnQjtBQUNaLFlBQVEsSUFESTtBQUVaLFVBQU0sY0FBVSxLQUFWLEVBQWlCLENBQUcsQ0FGZDtBQUdaLFdBQU8sZUFBVSxHQUFWLEVBQWU7QUFBRSxjQUFNLEdBQU47QUFBWSxLQUh4QjtBQUlaLGNBQVUsb0JBQVksQ0FBRztBQUpiLENBQWhCO0FBTUE7OztBQ1BBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZDtBQUFpQixZQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxlQUFlLFFBQVEsY0FBUixDQUFuQjtBQUNBOzs7OztBQUtBLElBQUksa0JBQW1CLFVBQVUsTUFBVixFQUFrQjtBQUNyQyxjQUFVLGVBQVYsRUFBMkIsTUFBM0I7QUFDQSxhQUFTLGVBQVQsR0FBMkI7QUFDdkIsZUFBTyxLQUFQLENBQWEsSUFBYixFQUFtQixTQUFuQjtBQUNIO0FBQ0Qsb0JBQWdCLFNBQWhCLENBQTBCLFVBQTFCLEdBQXVDLFVBQVUsVUFBVixFQUFzQixVQUF0QixFQUFrQyxVQUFsQyxFQUE4QyxVQUE5QyxFQUEwRCxRQUExRCxFQUFvRTtBQUN2RyxhQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsVUFBdEI7QUFDSCxLQUZEO0FBR0Esb0JBQWdCLFNBQWhCLENBQTBCLFdBQTFCLEdBQXdDLFVBQVUsS0FBVixFQUFpQixRQUFqQixFQUEyQjtBQUMvRCxhQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBdUIsS0FBdkI7QUFDSCxLQUZEO0FBR0Esb0JBQWdCLFNBQWhCLENBQTBCLGNBQTFCLEdBQTJDLFVBQVUsUUFBVixFQUFvQjtBQUMzRCxhQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDSCxLQUZEO0FBR0EsV0FBTyxlQUFQO0FBQ0gsQ0Fmc0IsQ0FlckIsYUFBYSxVQWZRLENBQXZCO0FBZ0JBLFFBQVEsZUFBUixHQUEwQixlQUExQjtBQUNBOzs7OztBQzdCQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQ7QUFBaUIsWUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksZUFBZSxRQUFRLGNBQVIsQ0FBbkI7QUFDQSxJQUFJLGVBQWUsUUFBUSxjQUFSLENBQW5CO0FBQ0EsSUFBSSxpQkFBaUIsUUFBUSxnQkFBUixDQUFyQjtBQUNBLElBQUksNEJBQTRCLFFBQVEsZ0NBQVIsQ0FBaEM7QUFDQSxJQUFJLHdCQUF3QixRQUFRLHVCQUFSLENBQTVCO0FBQ0EsSUFBSSxpQkFBaUIsUUFBUSx1QkFBUixDQUFyQjtBQUNBOzs7QUFHQSxJQUFJLG9CQUFxQixVQUFVLE1BQVYsRUFBa0I7QUFDdkMsY0FBVSxpQkFBVixFQUE2QixNQUE3QjtBQUNBLGFBQVMsaUJBQVQsQ0FBMkIsV0FBM0IsRUFBd0M7QUFDcEMsZUFBTyxJQUFQLENBQVksSUFBWixFQUFrQixXQUFsQjtBQUNBLGFBQUssV0FBTCxHQUFtQixXQUFuQjtBQUNIO0FBQ0QsV0FBTyxpQkFBUDtBQUNILENBUHdCLENBT3ZCLGFBQWEsVUFQVSxDQUF6QjtBQVFBLFFBQVEsaUJBQVIsR0FBNEIsaUJBQTVCO0FBQ0E7OztBQUdBLElBQUksVUFBVyxVQUFVLE1BQVYsRUFBa0I7QUFDN0IsY0FBVSxPQUFWLEVBQW1CLE1BQW5CO0FBQ0EsYUFBUyxPQUFULEdBQW1CO0FBQ2YsZUFBTyxJQUFQLENBQVksSUFBWjtBQUNBLGFBQUssU0FBTCxHQUFpQixFQUFqQjtBQUNBLGFBQUssTUFBTCxHQUFjLEtBQWQ7QUFDQSxhQUFLLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsS0FBaEI7QUFDQSxhQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDSDtBQUNELFlBQVEsU0FBUixDQUFrQixlQUFlLGNBQWpDLElBQW1ELFlBQVk7QUFDM0QsZUFBTyxJQUFJLGlCQUFKLENBQXNCLElBQXRCLENBQVA7QUFDSCxLQUZEO0FBR0EsWUFBUSxTQUFSLENBQWtCLElBQWxCLEdBQXlCLFVBQVUsUUFBVixFQUFvQjtBQUN6QyxZQUFJLFVBQVUsSUFBSSxnQkFBSixDQUFxQixJQUFyQixFQUEyQixJQUEzQixDQUFkO0FBQ0EsZ0JBQVEsUUFBUixHQUFtQixRQUFuQjtBQUNBLGVBQU8sT0FBUDtBQUNILEtBSkQ7QUFLQSxZQUFRLFNBQVIsQ0FBa0IsSUFBbEIsR0FBeUIsVUFBVSxLQUFWLEVBQWlCO0FBQ3RDLFlBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2Isa0JBQU0sSUFBSSwwQkFBMEIsdUJBQTlCLEVBQU47QUFDSDtBQUNELFlBQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUI7QUFDakIsZ0JBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0EsZ0JBQUksTUFBTSxVQUFVLE1BQXBCO0FBQ0EsZ0JBQUksT0FBTyxVQUFVLEtBQVYsRUFBWDtBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIscUJBQUssQ0FBTCxFQUFRLElBQVIsQ0FBYSxLQUFiO0FBQ0g7QUFDSjtBQUNKLEtBWkQ7QUFhQSxZQUFRLFNBQVIsQ0FBa0IsS0FBbEIsR0FBMEIsVUFBVSxHQUFWLEVBQWU7QUFDckMsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYixrQkFBTSxJQUFJLDBCQUEwQix1QkFBOUIsRUFBTjtBQUNIO0FBQ0QsYUFBSyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLEdBQW5CO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsWUFBSSxZQUFZLEtBQUssU0FBckI7QUFDQSxZQUFJLE1BQU0sVUFBVSxNQUFwQjtBQUNBLFlBQUksT0FBTyxVQUFVLEtBQVYsRUFBWDtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxHQUFwQixFQUF5QixHQUF6QixFQUE4QjtBQUMxQixpQkFBSyxDQUFMLEVBQVEsS0FBUixDQUFjLEdBQWQ7QUFDSDtBQUNELGFBQUssU0FBTCxDQUFlLE1BQWYsR0FBd0IsQ0FBeEI7QUFDSCxLQWREO0FBZUEsWUFBUSxTQUFSLENBQWtCLFFBQWxCLEdBQTZCLFlBQVk7QUFDckMsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYixrQkFBTSxJQUFJLDBCQUEwQix1QkFBOUIsRUFBTjtBQUNIO0FBQ0QsYUFBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsWUFBSSxZQUFZLEtBQUssU0FBckI7QUFDQSxZQUFJLE1BQU0sVUFBVSxNQUFwQjtBQUNBLFlBQUksT0FBTyxVQUFVLEtBQVYsRUFBWDtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxHQUFwQixFQUF5QixHQUF6QixFQUE4QjtBQUMxQixpQkFBSyxDQUFMLEVBQVEsUUFBUjtBQUNIO0FBQ0QsYUFBSyxTQUFMLENBQWUsTUFBZixHQUF3QixDQUF4QjtBQUNILEtBWkQ7QUFhQSxZQUFRLFNBQVIsQ0FBa0IsV0FBbEIsR0FBZ0MsWUFBWTtBQUN4QyxhQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxhQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0gsS0FKRDtBQUtBLFlBQVEsU0FBUixDQUFrQixhQUFsQixHQUFrQyxVQUFVLFVBQVYsRUFBc0I7QUFDcEQsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYixrQkFBTSxJQUFJLDBCQUEwQix1QkFBOUIsRUFBTjtBQUNILFNBRkQsTUFHSztBQUNELG1CQUFPLE9BQU8sU0FBUCxDQUFpQixhQUFqQixDQUErQixJQUEvQixDQUFvQyxJQUFwQyxFQUEwQyxVQUExQyxDQUFQO0FBQ0g7QUFDSixLQVBEO0FBUUEsWUFBUSxTQUFSLENBQWtCLFVBQWxCLEdBQStCLFVBQVUsVUFBVixFQUFzQjtBQUNqRCxZQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNiLGtCQUFNLElBQUksMEJBQTBCLHVCQUE5QixFQUFOO0FBQ0gsU0FGRCxNQUdLLElBQUksS0FBSyxRQUFULEVBQW1CO0FBQ3BCLHVCQUFXLEtBQVgsQ0FBaUIsS0FBSyxXQUF0QjtBQUNBLG1CQUFPLGVBQWUsWUFBZixDQUE0QixLQUFuQztBQUNILFNBSEksTUFJQSxJQUFJLEtBQUssU0FBVCxFQUFvQjtBQUNyQix1QkFBVyxRQUFYO0FBQ0EsbUJBQU8sZUFBZSxZQUFmLENBQTRCLEtBQW5DO0FBQ0gsU0FISSxNQUlBO0FBQ0QsaUJBQUssU0FBTCxDQUFlLElBQWYsQ0FBb0IsVUFBcEI7QUFDQSxtQkFBTyxJQUFJLHNCQUFzQixtQkFBMUIsQ0FBOEMsSUFBOUMsRUFBb0QsVUFBcEQsQ0FBUDtBQUNIO0FBQ0osS0FoQkQ7QUFpQkEsWUFBUSxTQUFSLENBQWtCLFlBQWxCLEdBQWlDLFlBQVk7QUFDekMsWUFBSSxhQUFhLElBQUksYUFBYSxVQUFqQixFQUFqQjtBQUNBLG1CQUFXLE1BQVgsR0FBb0IsSUFBcEI7QUFDQSxlQUFPLFVBQVA7QUFDSCxLQUpEO0FBS0EsWUFBUSxNQUFSLEdBQWlCLFVBQVUsV0FBVixFQUF1QixNQUF2QixFQUErQjtBQUM1QyxlQUFPLElBQUksZ0JBQUosQ0FBcUIsV0FBckIsRUFBa0MsTUFBbEMsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPLE9BQVA7QUFDSCxDQWxHYyxDQWtHYixhQUFhLFVBbEdBLENBQWY7QUFtR0EsUUFBUSxPQUFSLEdBQWtCLE9BQWxCO0FBQ0E7OztBQUdBLElBQUksbUJBQW9CLFVBQVUsTUFBVixFQUFrQjtBQUN0QyxjQUFVLGdCQUFWLEVBQTRCLE1BQTVCO0FBQ0EsYUFBUyxnQkFBVCxDQUEwQixXQUExQixFQUF1QyxNQUF2QyxFQUErQztBQUMzQyxlQUFPLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNIO0FBQ0QscUJBQWlCLFNBQWpCLENBQTJCLElBQTNCLEdBQWtDLFVBQVUsS0FBVixFQUFpQjtBQUMvQyxZQUFJLGNBQWMsS0FBSyxXQUF2QjtBQUNBLFlBQUksZUFBZSxZQUFZLElBQS9CLEVBQXFDO0FBQ2pDLHdCQUFZLElBQVosQ0FBaUIsS0FBakI7QUFDSDtBQUNKLEtBTEQ7QUFNQSxxQkFBaUIsU0FBakIsQ0FBMkIsS0FBM0IsR0FBbUMsVUFBVSxHQUFWLEVBQWU7QUFDOUMsWUFBSSxjQUFjLEtBQUssV0FBdkI7QUFDQSxZQUFJLGVBQWUsWUFBWSxLQUEvQixFQUFzQztBQUNsQyxpQkFBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLEdBQXZCO0FBQ0g7QUFDSixLQUxEO0FBTUEscUJBQWlCLFNBQWpCLENBQTJCLFFBQTNCLEdBQXNDLFlBQVk7QUFDOUMsWUFBSSxjQUFjLEtBQUssV0FBdkI7QUFDQSxZQUFJLGVBQWUsWUFBWSxRQUEvQixFQUF5QztBQUNyQyxpQkFBSyxXQUFMLENBQWlCLFFBQWpCO0FBQ0g7QUFDSixLQUxEO0FBTUEscUJBQWlCLFNBQWpCLENBQTJCLFVBQTNCLEdBQXdDLFVBQVUsVUFBVixFQUFzQjtBQUMxRCxZQUFJLFNBQVMsS0FBSyxNQUFsQjtBQUNBLFlBQUksTUFBSixFQUFZO0FBQ1IsbUJBQU8sS0FBSyxNQUFMLENBQVksU0FBWixDQUFzQixVQUF0QixDQUFQO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsbUJBQU8sZUFBZSxZQUFmLENBQTRCLEtBQW5DO0FBQ0g7QUFDSixLQVJEO0FBU0EsV0FBTyxnQkFBUDtBQUNILENBbkN1QixDQW1DdEIsT0FuQ3NCLENBQXhCO0FBb0NBLFFBQVEsZ0JBQVIsR0FBMkIsZ0JBQTNCO0FBQ0E7OztBQ3ZLQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQ7QUFBaUIsWUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksaUJBQWlCLFFBQVEsZ0JBQVIsQ0FBckI7QUFDQTs7Ozs7QUFLQSxJQUFJLHNCQUF1QixVQUFVLE1BQVYsRUFBa0I7QUFDekMsY0FBVSxtQkFBVixFQUErQixNQUEvQjtBQUNBLGFBQVMsbUJBQVQsQ0FBNkIsT0FBN0IsRUFBc0MsVUFBdEMsRUFBa0Q7QUFDOUMsZUFBTyxJQUFQLENBQVksSUFBWjtBQUNBLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxhQUFLLFVBQUwsR0FBa0IsVUFBbEI7QUFDQSxhQUFLLE1BQUwsR0FBYyxLQUFkO0FBQ0g7QUFDRCx3QkFBb0IsU0FBcEIsQ0FBOEIsV0FBOUIsR0FBNEMsWUFBWTtBQUNwRCxZQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNiO0FBQ0g7QUFDRCxhQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0EsWUFBSSxVQUFVLEtBQUssT0FBbkI7QUFDQSxZQUFJLFlBQVksUUFBUSxTQUF4QjtBQUNBLGFBQUssT0FBTCxHQUFlLElBQWY7QUFDQSxZQUFJLENBQUMsU0FBRCxJQUFjLFVBQVUsTUFBVixLQUFxQixDQUFuQyxJQUF3QyxRQUFRLFNBQWhELElBQTZELFFBQVEsTUFBekUsRUFBaUY7QUFDN0U7QUFDSDtBQUNELFlBQUksa0JBQWtCLFVBQVUsT0FBVixDQUFrQixLQUFLLFVBQXZCLENBQXRCO0FBQ0EsWUFBSSxvQkFBb0IsQ0FBQyxDQUF6QixFQUE0QjtBQUN4QixzQkFBVSxNQUFWLENBQWlCLGVBQWpCLEVBQWtDLENBQWxDO0FBQ0g7QUFDSixLQWZEO0FBZ0JBLFdBQU8sbUJBQVA7QUFDSCxDQXpCMEIsQ0F5QnpCLGVBQWUsWUF6QlUsQ0FBM0I7QUEwQkEsUUFBUSxtQkFBUixHQUE4QixtQkFBOUI7QUFDQTs7O0FDdkNBOzs7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxtQkFBUixDQUFuQjtBQUNBLElBQUksaUJBQWlCLFFBQVEsZ0JBQVIsQ0FBckI7QUFDQSxJQUFJLGFBQWEsUUFBUSxZQUFSLENBQWpCO0FBQ0EsSUFBSSxpQkFBaUIsUUFBUSx1QkFBUixDQUFyQjtBQUNBOzs7Ozs7Ozs7O0FBVUEsSUFBSSxhQUFjLFVBQVUsTUFBVixFQUFrQjtBQUNoQyxjQUFVLFVBQVYsRUFBc0IsTUFBdEI7QUFDQTs7Ozs7Ozs7QUFRQSxhQUFTLFVBQVQsQ0FBb0IsaUJBQXBCLEVBQXVDLEtBQXZDLEVBQThDLFFBQTlDLEVBQXdEO0FBQ3BELGVBQU8sSUFBUCxDQUFZLElBQVo7QUFDQSxhQUFLLGNBQUwsR0FBc0IsSUFBdEI7QUFDQSxhQUFLLGVBQUwsR0FBdUIsS0FBdkI7QUFDQSxhQUFLLGtCQUFMLEdBQTBCLEtBQTFCO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLEtBQWpCO0FBQ0EsZ0JBQVEsVUFBVSxNQUFsQjtBQUNJLGlCQUFLLENBQUw7QUFDSSxxQkFBSyxXQUFMLEdBQW1CLFdBQVcsS0FBOUI7QUFDQTtBQUNKLGlCQUFLLENBQUw7QUFDSSxvQkFBSSxDQUFDLGlCQUFMLEVBQXdCO0FBQ3BCLHlCQUFLLFdBQUwsR0FBbUIsV0FBVyxLQUE5QjtBQUNBO0FBQ0g7QUFDRCxvQkFBSSxRQUFPLGlCQUFQLHlDQUFPLGlCQUFQLE9BQTZCLFFBQWpDLEVBQTJDO0FBQ3ZDLHdCQUFJLDZCQUE2QixVQUFqQyxFQUE2QztBQUN6Qyw2QkFBSyxXQUFMLEdBQW1CLGlCQUFuQjtBQUNBLDZCQUFLLFdBQUwsQ0FBaUIsR0FBakIsQ0FBcUIsSUFBckI7QUFDSCxxQkFIRCxNQUlLO0FBQ0QsNkJBQUssa0JBQUwsR0FBMEIsSUFBMUI7QUFDQSw2QkFBSyxXQUFMLEdBQW1CLElBQUksY0FBSixDQUFtQixJQUFuQixFQUF5QixpQkFBekIsQ0FBbkI7QUFDSDtBQUNEO0FBQ0g7QUFDTDtBQUNJLHFCQUFLLGtCQUFMLEdBQTBCLElBQTFCO0FBQ0EscUJBQUssV0FBTCxHQUFtQixJQUFJLGNBQUosQ0FBbUIsSUFBbkIsRUFBeUIsaUJBQXpCLEVBQTRDLEtBQTVDLEVBQW1ELFFBQW5ELENBQW5CO0FBQ0E7QUF2QlI7QUF5Qkg7QUFDRCxlQUFXLFNBQVgsQ0FBcUIsZUFBZSxjQUFwQyxJQUFzRCxZQUFZO0FBQUUsZUFBTyxJQUFQO0FBQWMsS0FBbEY7QUFDQTs7Ozs7Ozs7Ozs7QUFXQSxlQUFXLE1BQVgsR0FBb0IsVUFBVSxJQUFWLEVBQWdCLEtBQWhCLEVBQXVCLFFBQXZCLEVBQWlDO0FBQ2pELFlBQUksYUFBYSxJQUFJLFVBQUosQ0FBZSxJQUFmLEVBQXFCLEtBQXJCLEVBQTRCLFFBQTVCLENBQWpCO0FBQ0EsbUJBQVcsa0JBQVgsR0FBZ0MsS0FBaEM7QUFDQSxlQUFPLFVBQVA7QUFDSCxLQUpEO0FBS0E7Ozs7Ozs7QUFPQSxlQUFXLFNBQVgsQ0FBcUIsSUFBckIsR0FBNEIsVUFBVSxLQUFWLEVBQWlCO0FBQ3pDLFlBQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUI7QUFDakIsaUJBQUssS0FBTCxDQUFXLEtBQVg7QUFDSDtBQUNKLEtBSkQ7QUFLQTs7Ozs7OztBQU9BLGVBQVcsU0FBWCxDQUFxQixLQUFyQixHQUE2QixVQUFVLEdBQVYsRUFBZTtBQUN4QyxZQUFJLENBQUMsS0FBSyxTQUFWLEVBQXFCO0FBQ2pCLGlCQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxpQkFBSyxNQUFMLENBQVksR0FBWjtBQUNIO0FBQ0osS0FMRDtBQU1BOzs7Ozs7QUFNQSxlQUFXLFNBQVgsQ0FBcUIsUUFBckIsR0FBZ0MsWUFBWTtBQUN4QyxZQUFJLENBQUMsS0FBSyxTQUFWLEVBQXFCO0FBQ2pCLGlCQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxpQkFBSyxTQUFMO0FBQ0g7QUFDSixLQUxEO0FBTUEsZUFBVyxTQUFYLENBQXFCLFdBQXJCLEdBQW1DLFlBQVk7QUFDM0MsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYjtBQUNIO0FBQ0QsYUFBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsZUFBTyxTQUFQLENBQWlCLFdBQWpCLENBQTZCLElBQTdCLENBQWtDLElBQWxDO0FBQ0gsS0FORDtBQU9BLGVBQVcsU0FBWCxDQUFxQixLQUFyQixHQUE2QixVQUFVLEtBQVYsRUFBaUI7QUFDMUMsYUFBSyxXQUFMLENBQWlCLElBQWpCLENBQXNCLEtBQXRCO0FBQ0gsS0FGRDtBQUdBLGVBQVcsU0FBWCxDQUFxQixNQUFyQixHQUE4QixVQUFVLEdBQVYsRUFBZTtBQUN6QyxhQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBdUIsR0FBdkI7QUFDQSxhQUFLLFdBQUw7QUFDSCxLQUhEO0FBSUEsZUFBVyxTQUFYLENBQXFCLFNBQXJCLEdBQWlDLFlBQVk7QUFDekMsYUFBSyxXQUFMLENBQWlCLFFBQWpCO0FBQ0EsYUFBSyxXQUFMO0FBQ0gsS0FIRDtBQUlBLGVBQVcsU0FBWCxDQUFxQixzQkFBckIsR0FBOEMsWUFBWTtBQUN0RCxZQUFJLEtBQUssSUFBVDtBQUFBLFlBQWUsVUFBVSxHQUFHLE9BQTVCO0FBQUEsWUFBcUMsV0FBVyxHQUFHLFFBQW5EO0FBQ0EsYUFBSyxPQUFMLEdBQWUsSUFBZjtBQUNBLGFBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLGFBQUssV0FBTDtBQUNBLGFBQUssTUFBTCxHQUFjLEtBQWQ7QUFDQSxhQUFLLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsZUFBTyxJQUFQO0FBQ0gsS0FWRDtBQVdBLFdBQU8sVUFBUDtBQUNILENBOUhpQixDQThIaEIsZUFBZSxZQTlIQyxDQUFsQjtBQStIQSxRQUFRLFVBQVIsR0FBcUIsVUFBckI7QUFDQTs7Ozs7QUFLQSxJQUFJLGlCQUFrQixVQUFVLE1BQVYsRUFBa0I7QUFDcEMsY0FBVSxjQUFWLEVBQTBCLE1BQTFCO0FBQ0EsYUFBUyxjQUFULENBQXdCLGlCQUF4QixFQUEyQyxjQUEzQyxFQUEyRCxLQUEzRCxFQUFrRSxRQUFsRSxFQUE0RTtBQUN4RSxlQUFPLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBSyxpQkFBTCxHQUF5QixpQkFBekI7QUFDQSxZQUFJLElBQUo7QUFDQSxZQUFJLFVBQVUsSUFBZDtBQUNBLFlBQUksYUFBYSxVQUFiLENBQXdCLGNBQXhCLENBQUosRUFBNkM7QUFDekMsbUJBQU8sY0FBUDtBQUNILFNBRkQsTUFHSyxJQUFJLGNBQUosRUFBb0I7QUFDckIsc0JBQVUsY0FBVjtBQUNBLG1CQUFPLGVBQWUsSUFBdEI7QUFDQSxvQkFBUSxlQUFlLEtBQXZCO0FBQ0EsdUJBQVcsZUFBZSxRQUExQjtBQUNBLGdCQUFJLGFBQWEsVUFBYixDQUF3QixRQUFRLFdBQWhDLENBQUosRUFBa0Q7QUFDOUMscUJBQUssR0FBTCxDQUFTLFFBQVEsV0FBUixDQUFvQixJQUFwQixDQUF5QixPQUF6QixDQUFUO0FBQ0g7QUFDRCxvQkFBUSxXQUFSLEdBQXNCLEtBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUF0QjtBQUNIO0FBQ0QsYUFBSyxRQUFMLEdBQWdCLE9BQWhCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUssTUFBTCxHQUFjLEtBQWQ7QUFDQSxhQUFLLFNBQUwsR0FBaUIsUUFBakI7QUFDSDtBQUNELG1CQUFlLFNBQWYsQ0FBeUIsSUFBekIsR0FBZ0MsVUFBVSxLQUFWLEVBQWlCO0FBQzdDLFlBQUksQ0FBQyxLQUFLLFNBQU4sSUFBbUIsS0FBSyxLQUE1QixFQUFtQztBQUMvQixnQkFBSSxvQkFBb0IsS0FBSyxpQkFBN0I7QUFDQSxnQkFBSSxDQUFDLGtCQUFrQixrQkFBdkIsRUFBMkM7QUFDdkMscUJBQUssWUFBTCxDQUFrQixLQUFLLEtBQXZCLEVBQThCLEtBQTlCO0FBQ0gsYUFGRCxNQUdLLElBQUksS0FBSyxlQUFMLENBQXFCLGlCQUFyQixFQUF3QyxLQUFLLEtBQTdDLEVBQW9ELEtBQXBELENBQUosRUFBZ0U7QUFDakUscUJBQUssV0FBTDtBQUNIO0FBQ0o7QUFDSixLQVZEO0FBV0EsbUJBQWUsU0FBZixDQUF5QixLQUF6QixHQUFpQyxVQUFVLEdBQVYsRUFBZTtBQUM1QyxZQUFJLENBQUMsS0FBSyxTQUFWLEVBQXFCO0FBQ2pCLGdCQUFJLG9CQUFvQixLQUFLLGlCQUE3QjtBQUNBLGdCQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNiLG9CQUFJLENBQUMsa0JBQWtCLGtCQUF2QixFQUEyQztBQUN2Qyx5QkFBSyxZQUFMLENBQWtCLEtBQUssTUFBdkIsRUFBK0IsR0FBL0I7QUFDQSx5QkFBSyxXQUFMO0FBQ0gsaUJBSEQsTUFJSztBQUNELHlCQUFLLGVBQUwsQ0FBcUIsaUJBQXJCLEVBQXdDLEtBQUssTUFBN0MsRUFBcUQsR0FBckQ7QUFDQSx5QkFBSyxXQUFMO0FBQ0g7QUFDSixhQVRELE1BVUssSUFBSSxDQUFDLGtCQUFrQixrQkFBdkIsRUFBMkM7QUFDNUMscUJBQUssV0FBTDtBQUNBLHNCQUFNLEdBQU47QUFDSCxhQUhJLE1BSUE7QUFDRCxrQ0FBa0IsY0FBbEIsR0FBbUMsR0FBbkM7QUFDQSxrQ0FBa0IsZUFBbEIsR0FBb0MsSUFBcEM7QUFDQSxxQkFBSyxXQUFMO0FBQ0g7QUFDSjtBQUNKLEtBdkJEO0FBd0JBLG1CQUFlLFNBQWYsQ0FBeUIsUUFBekIsR0FBb0MsWUFBWTtBQUM1QyxZQUFJLENBQUMsS0FBSyxTQUFWLEVBQXFCO0FBQ2pCLGdCQUFJLG9CQUFvQixLQUFLLGlCQUE3QjtBQUNBLGdCQUFJLEtBQUssU0FBVCxFQUFvQjtBQUNoQixvQkFBSSxDQUFDLGtCQUFrQixrQkFBdkIsRUFBMkM7QUFDdkMseUJBQUssWUFBTCxDQUFrQixLQUFLLFNBQXZCO0FBQ0EseUJBQUssV0FBTDtBQUNILGlCQUhELE1BSUs7QUFDRCx5QkFBSyxlQUFMLENBQXFCLGlCQUFyQixFQUF3QyxLQUFLLFNBQTdDO0FBQ0EseUJBQUssV0FBTDtBQUNIO0FBQ0osYUFURCxNQVVLO0FBQ0QscUJBQUssV0FBTDtBQUNIO0FBQ0o7QUFDSixLQWpCRDtBQWtCQSxtQkFBZSxTQUFmLENBQXlCLFlBQXpCLEdBQXdDLFVBQVUsRUFBVixFQUFjLEtBQWQsRUFBcUI7QUFDekQsWUFBSTtBQUNBLGVBQUcsSUFBSCxDQUFRLEtBQUssUUFBYixFQUF1QixLQUF2QjtBQUNILFNBRkQsQ0FHQSxPQUFPLEdBQVAsRUFBWTtBQUNSLGlCQUFLLFdBQUw7QUFDQSxrQkFBTSxHQUFOO0FBQ0g7QUFDSixLQVJEO0FBU0EsbUJBQWUsU0FBZixDQUF5QixlQUF6QixHQUEyQyxVQUFVLE1BQVYsRUFBa0IsRUFBbEIsRUFBc0IsS0FBdEIsRUFBNkI7QUFDcEUsWUFBSTtBQUNBLGVBQUcsSUFBSCxDQUFRLEtBQUssUUFBYixFQUF1QixLQUF2QjtBQUNILFNBRkQsQ0FHQSxPQUFPLEdBQVAsRUFBWTtBQUNSLG1CQUFPLGNBQVAsR0FBd0IsR0FBeEI7QUFDQSxtQkFBTyxlQUFQLEdBQXlCLElBQXpCO0FBQ0EsbUJBQU8sSUFBUDtBQUNIO0FBQ0QsZUFBTyxLQUFQO0FBQ0gsS0FWRDtBQVdBLG1CQUFlLFNBQWYsQ0FBeUIsWUFBekIsR0FBd0MsWUFBWTtBQUNoRCxZQUFJLG9CQUFvQixLQUFLLGlCQUE3QjtBQUNBLGFBQUssUUFBTCxHQUFnQixJQUFoQjtBQUNBLGFBQUssaUJBQUwsR0FBeUIsSUFBekI7QUFDQSwwQkFBa0IsV0FBbEI7QUFDSCxLQUxEO0FBTUEsV0FBTyxjQUFQO0FBQ0gsQ0F6R3FCLENBeUdwQixVQXpHb0IsQ0FBdEI7QUEwR0E7OztBQ25RQTs7OztBQUNBLElBQUksWUFBWSxRQUFRLGdCQUFSLENBQWhCO0FBQ0EsSUFBSSxhQUFhLFFBQVEsaUJBQVIsQ0FBakI7QUFDQSxJQUFJLGVBQWUsUUFBUSxtQkFBUixDQUFuQjtBQUNBLElBQUksYUFBYSxRQUFRLGlCQUFSLENBQWpCO0FBQ0EsSUFBSSxnQkFBZ0IsUUFBUSxvQkFBUixDQUFwQjtBQUNBLElBQUksd0JBQXdCLFFBQVEsNEJBQVIsQ0FBNUI7QUFDQTs7Ozs7Ozs7Ozs7O0FBWUEsSUFBSSxlQUFnQixZQUFZO0FBQzVCOzs7O0FBSUEsYUFBUyxZQUFULENBQXNCLFdBQXRCLEVBQW1DO0FBQy9COzs7O0FBSUEsYUFBSyxNQUFMLEdBQWMsS0FBZDtBQUNBLGFBQUssT0FBTCxHQUFlLElBQWY7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxhQUFLLGNBQUwsR0FBc0IsSUFBdEI7QUFDQSxZQUFJLFdBQUosRUFBaUI7QUFDYixpQkFBSyxZQUFMLEdBQW9CLFdBQXBCO0FBQ0g7QUFDSjtBQUNEOzs7Ozs7QUFNQSxpQkFBYSxTQUFiLENBQXVCLFdBQXZCLEdBQXFDLFlBQVk7QUFDN0MsWUFBSSxZQUFZLEtBQWhCO0FBQ0EsWUFBSSxNQUFKO0FBQ0EsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYjtBQUNIO0FBQ0QsWUFBSSxLQUFLLElBQVQ7QUFBQSxZQUFlLFVBQVUsR0FBRyxPQUE1QjtBQUFBLFlBQXFDLFdBQVcsR0FBRyxRQUFuRDtBQUFBLFlBQTZELGVBQWUsR0FBRyxZQUEvRTtBQUFBLFlBQTZGLGlCQUFpQixHQUFHLGNBQWpIO0FBQ0EsYUFBSyxNQUFMLEdBQWMsSUFBZDtBQUNBLGFBQUssT0FBTCxHQUFlLElBQWY7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQTtBQUNBO0FBQ0EsYUFBSyxjQUFMLEdBQXNCLElBQXRCO0FBQ0EsWUFBSSxRQUFRLENBQUMsQ0FBYjtBQUNBLFlBQUksTUFBTSxXQUFXLFNBQVMsTUFBcEIsR0FBNkIsQ0FBdkM7QUFDQTtBQUNBO0FBQ0EsZUFBTyxPQUFQLEVBQWdCO0FBQ1osb0JBQVEsTUFBUixDQUFlLElBQWY7QUFDQTtBQUNBO0FBQ0Esc0JBQVUsRUFBRSxLQUFGLEdBQVUsR0FBVixJQUFpQixTQUFTLEtBQVQsQ0FBakIsSUFBb0MsSUFBOUM7QUFDSDtBQUNELFlBQUksYUFBYSxVQUFiLENBQXdCLFlBQXhCLENBQUosRUFBMkM7QUFDdkMsZ0JBQUksUUFBUSxXQUFXLFFBQVgsQ0FBb0IsWUFBcEIsRUFBa0MsSUFBbEMsQ0FBdUMsSUFBdkMsQ0FBWjtBQUNBLGdCQUFJLFVBQVUsY0FBYyxXQUE1QixFQUF5QztBQUNyQyw0QkFBWSxJQUFaO0FBQ0EseUJBQVMsV0FBVyxjQUFjLFdBQWQsQ0FBMEIsQ0FBMUIsWUFBdUMsc0JBQXNCLG1CQUE3RCxHQUNoQiw0QkFBNEIsY0FBYyxXQUFkLENBQTBCLENBQTFCLENBQTRCLE1BQXhELENBRGdCLEdBQ2tELENBQUMsY0FBYyxXQUFkLENBQTBCLENBQTNCLENBRDdELENBQVQ7QUFFSDtBQUNKO0FBQ0QsWUFBSSxVQUFVLE9BQVYsQ0FBa0IsY0FBbEIsQ0FBSixFQUF1QztBQUNuQyxvQkFBUSxDQUFDLENBQVQ7QUFDQSxrQkFBTSxlQUFlLE1BQXJCO0FBQ0EsbUJBQU8sRUFBRSxLQUFGLEdBQVUsR0FBakIsRUFBc0I7QUFDbEIsb0JBQUksTUFBTSxlQUFlLEtBQWYsQ0FBVjtBQUNBLG9CQUFJLFdBQVcsUUFBWCxDQUFvQixHQUFwQixDQUFKLEVBQThCO0FBQzFCLHdCQUFJLFFBQVEsV0FBVyxRQUFYLENBQW9CLElBQUksV0FBeEIsRUFBcUMsSUFBckMsQ0FBMEMsR0FBMUMsQ0FBWjtBQUNBLHdCQUFJLFVBQVUsY0FBYyxXQUE1QixFQUF5QztBQUNyQyxvQ0FBWSxJQUFaO0FBQ0EsaUNBQVMsVUFBVSxFQUFuQjtBQUNBLDRCQUFJLE1BQU0sY0FBYyxXQUFkLENBQTBCLENBQXBDO0FBQ0EsNEJBQUksZUFBZSxzQkFBc0IsbUJBQXpDLEVBQThEO0FBQzFELHFDQUFTLE9BQU8sTUFBUCxDQUFjLDRCQUE0QixJQUFJLE1BQWhDLENBQWQsQ0FBVDtBQUNILHlCQUZELE1BR0s7QUFDRCxtQ0FBTyxJQUFQLENBQVksR0FBWjtBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBQ0o7QUFDRCxZQUFJLFNBQUosRUFBZTtBQUNYLGtCQUFNLElBQUksc0JBQXNCLG1CQUExQixDQUE4QyxNQUE5QyxDQUFOO0FBQ0g7QUFDSixLQXZERDtBQXdEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBLGlCQUFhLFNBQWIsQ0FBdUIsR0FBdkIsR0FBNkIsVUFBVSxRQUFWLEVBQW9CO0FBQzdDLFlBQUksQ0FBQyxRQUFELElBQWMsYUFBYSxhQUFhLEtBQTVDLEVBQW9EO0FBQ2hELG1CQUFPLGFBQWEsS0FBcEI7QUFDSDtBQUNELFlBQUksYUFBYSxJQUFqQixFQUF1QjtBQUNuQixtQkFBTyxJQUFQO0FBQ0g7QUFDRCxZQUFJLGVBQWUsUUFBbkI7QUFDQSx1QkFBZSxRQUFmLHlDQUFlLFFBQWY7QUFDSSxpQkFBSyxVQUFMO0FBQ0ksK0JBQWUsSUFBSSxZQUFKLENBQWlCLFFBQWpCLENBQWY7QUFDSixpQkFBSyxRQUFMO0FBQ0ksb0JBQUksYUFBYSxNQUFiLElBQXVCLE9BQU8sYUFBYSxXQUFwQixLQUFvQyxVQUEvRCxFQUEyRTtBQUN2RSwyQkFBTyxZQUFQO0FBQ0gsaUJBRkQsTUFHSyxJQUFJLEtBQUssTUFBVCxFQUFpQjtBQUNsQixpQ0FBYSxXQUFiO0FBQ0EsMkJBQU8sWUFBUDtBQUNILGlCQUhJLE1BSUEsSUFBSSxPQUFPLGFBQWEsVUFBcEIsS0FBbUMsVUFBdkMsQ0FBa0QsaUJBQWxELEVBQXFFO0FBQ3RFLDRCQUFJLE1BQU0sWUFBVjtBQUNBLHVDQUFlLElBQUksWUFBSixFQUFmO0FBQ0EscUNBQWEsY0FBYixHQUE4QixDQUFDLEdBQUQsQ0FBOUI7QUFDSDtBQUNEO0FBQ0o7QUFDSSxzQkFBTSxJQUFJLEtBQUosQ0FBVSwyQkFBMkIsUUFBM0IsR0FBc0MseUJBQWhELENBQU47QUFsQlI7QUFvQkEsWUFBSSxnQkFBZ0IsS0FBSyxjQUFMLEtBQXdCLEtBQUssY0FBTCxHQUFzQixFQUE5QyxDQUFwQjtBQUNBLHNCQUFjLElBQWQsQ0FBbUIsWUFBbkI7QUFDQSxxQkFBYSxVQUFiLENBQXdCLElBQXhCO0FBQ0EsZUFBTyxZQUFQO0FBQ0gsS0FoQ0Q7QUFpQ0E7Ozs7OztBQU1BLGlCQUFhLFNBQWIsQ0FBdUIsTUFBdkIsR0FBZ0MsVUFBVSxZQUFWLEVBQXdCO0FBQ3BELFlBQUksZ0JBQWdCLEtBQUssY0FBekI7QUFDQSxZQUFJLGFBQUosRUFBbUI7QUFDZixnQkFBSSxvQkFBb0IsY0FBYyxPQUFkLENBQXNCLFlBQXRCLENBQXhCO0FBQ0EsZ0JBQUksc0JBQXNCLENBQUMsQ0FBM0IsRUFBOEI7QUFDMUIsOEJBQWMsTUFBZCxDQUFxQixpQkFBckIsRUFBd0MsQ0FBeEM7QUFDSDtBQUNKO0FBQ0osS0FSRDtBQVNBLGlCQUFhLFNBQWIsQ0FBdUIsVUFBdkIsR0FBb0MsVUFBVSxNQUFWLEVBQWtCO0FBQ2xELFlBQUksS0FBSyxJQUFUO0FBQUEsWUFBZSxVQUFVLEdBQUcsT0FBNUI7QUFBQSxZQUFxQyxXQUFXLEdBQUcsUUFBbkQ7QUFDQSxZQUFJLENBQUMsT0FBRCxJQUFZLFlBQVksTUFBNUIsRUFBb0M7QUFDaEM7QUFDQTtBQUNBLGlCQUFLLE9BQUwsR0FBZSxNQUFmO0FBQ0gsU0FKRCxNQUtLLElBQUksQ0FBQyxRQUFMLEVBQWU7QUFDaEI7QUFDQTtBQUNBLGlCQUFLLFFBQUwsR0FBZ0IsQ0FBQyxNQUFELENBQWhCO0FBQ0gsU0FKSSxNQUtBLElBQUksU0FBUyxPQUFULENBQWlCLE1BQWpCLE1BQTZCLENBQUMsQ0FBbEMsRUFBcUM7QUFDdEM7QUFDQSxxQkFBUyxJQUFULENBQWMsTUFBZDtBQUNIO0FBQ0osS0FoQkQ7QUFpQkEsaUJBQWEsS0FBYixHQUFzQixVQUFVLEtBQVYsRUFBaUI7QUFDbkMsY0FBTSxNQUFOLEdBQWUsSUFBZjtBQUNBLGVBQU8sS0FBUDtBQUNILEtBSHFCLENBR3BCLElBQUksWUFBSixFQUhvQixDQUF0QjtBQUlBLFdBQU8sWUFBUDtBQUNILENBeEttQixFQUFwQjtBQXlLQSxRQUFRLFlBQVIsR0FBdUIsWUFBdkI7QUFDQSxTQUFTLDJCQUFULENBQXFDLE1BQXJDLEVBQTZDO0FBQ3pDLFdBQU8sT0FBTyxNQUFQLENBQWMsVUFBVSxJQUFWLEVBQWdCLEdBQWhCLEVBQXFCO0FBQUUsZUFBTyxLQUFLLE1BQUwsQ0FBYSxlQUFlLHNCQUFzQixtQkFBdEMsR0FBNkQsSUFBSSxNQUFqRSxHQUEwRSxHQUF0RixDQUFQO0FBQW9HLEtBQXpJLEVBQTJJLEVBQTNJLENBQVA7QUFDSDtBQUNEOzs7QUNoTUE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLFVBQVUsUUFBUSx3QkFBUixDQUFkO0FBQ0EsYUFBYSxVQUFiLENBQXdCLEtBQXhCLEdBQWdDLFFBQVEsS0FBeEM7QUFDQTs7O0FDSkE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEscUJBQVIsQ0FBbkI7QUFDQSxJQUFJLFNBQVMsUUFBUSw4QkFBUixDQUFiO0FBQ0EsYUFBYSxVQUFiLENBQXdCLElBQXhCLEdBQStCLE9BQU8sSUFBdEM7QUFDQTs7O0FDSkE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLGNBQWMsUUFBUSw0QkFBUixDQUFsQjtBQUNBLGFBQWEsVUFBYixDQUF3QixTQUF4QixHQUFvQyxZQUFZLFNBQWhEO0FBQ0E7OztBQ0pBOztBQUNBLElBQUksZUFBZSxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSSxVQUFVLFFBQVEsd0JBQVIsQ0FBZDtBQUNBLGFBQWEsVUFBYixDQUF3QixLQUF4QixHQUFnQyxRQUFRLEtBQXhDO0FBQ0E7OztBQ0pBOztBQUNBLElBQUksZUFBZSxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSSxPQUFPLFFBQVEscUJBQVIsQ0FBWDtBQUNBLGFBQWEsVUFBYixDQUF3QixFQUF4QixHQUE2QixLQUFLLEVBQWxDO0FBQ0E7OztBQ0pBOztBQUNBLElBQUksZUFBZSxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSSxVQUFVLFFBQVEsd0JBQVIsQ0FBZDtBQUNBLGFBQWEsVUFBYixDQUF3QixLQUF4QixHQUFnQyxRQUFRLE1BQXhDO0FBQ0E7OztBQ0pBOztBQUNBLElBQUksZUFBZSxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSSxVQUFVLFFBQVEsd0JBQVIsQ0FBZDtBQUNBLGFBQWEsVUFBYixDQUF3QixLQUF4QixHQUFnQyxRQUFRLEtBQXhDO0FBQ0E7OztBQ0pBOztBQUNBLElBQUksZUFBZSxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSSxVQUFVLFFBQVEsc0JBQVIsQ0FBZDtBQUNBLGFBQWEsVUFBYixDQUF3QixTQUF4QixDQUFrQyxLQUFsQyxHQUEwQyxRQUFRLE1BQWxEO0FBQ0EsYUFBYSxVQUFiLENBQXdCLFNBQXhCLENBQWtDLE1BQWxDLEdBQTJDLFFBQVEsTUFBbkQ7QUFDQTs7O0FDTEE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLGlCQUFpQixRQUFRLDZCQUFSLENBQXJCO0FBQ0EsYUFBYSxVQUFiLENBQXdCLFNBQXhCLENBQWtDLFlBQWxDLEdBQWlELGVBQWUsWUFBaEU7QUFDQTs7O0FDSkE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLFVBQVUsUUFBUSxzQkFBUixDQUFkO0FBQ0EsYUFBYSxVQUFiLENBQXdCLFNBQXhCLENBQWtDLEtBQWxDLEdBQTBDLFFBQVEsS0FBbEQ7QUFDQTs7O0FDSkE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLDRCQUE0QixRQUFRLHdDQUFSLENBQWhDO0FBQ0EsYUFBYSxVQUFiLENBQXdCLFNBQXhCLENBQWtDLHVCQUFsQyxHQUE0RCwwQkFBMEIsdUJBQXRGO0FBQ0E7OztBQ0pBOztBQUNBLElBQUksZUFBZSxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSSxPQUFPLFFBQVEsbUJBQVIsQ0FBWDtBQUNBLGFBQWEsVUFBYixDQUF3QixTQUF4QixDQUFrQyxFQUFsQyxHQUF1QyxLQUFLLEdBQTVDO0FBQ0EsYUFBYSxVQUFiLENBQXdCLFNBQXhCLENBQWtDLEdBQWxDLEdBQXdDLEtBQUssR0FBN0M7QUFDQTs7O0FDTEE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLFdBQVcsUUFBUSx1QkFBUixDQUFmO0FBQ0EsYUFBYSxVQUFiLENBQXdCLFNBQXhCLENBQWtDLE1BQWxDLEdBQTJDLFNBQVMsTUFBcEQ7QUFDQTs7O0FDSkE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLFFBQVEsUUFBUSxvQkFBUixDQUFaO0FBQ0EsYUFBYSxVQUFiLENBQXdCLFNBQXhCLENBQWtDLEdBQWxDLEdBQXdDLE1BQU0sR0FBOUM7QUFDQTs7O0FDSkE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLGFBQWEsUUFBUSx5QkFBUixDQUFqQjtBQUNBLGFBQWEsVUFBYixDQUF3QixTQUF4QixDQUFrQyxRQUFsQyxHQUE2QyxXQUFXLFFBQXhEO0FBQ0E7OztBQ0pBOztBQUNBLElBQUksZUFBZSxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSSxjQUFjLFFBQVEsMEJBQVIsQ0FBbEI7QUFDQSxhQUFhLFVBQWIsQ0FBd0IsU0FBeEIsQ0FBa0MsU0FBbEMsR0FBOEMsWUFBWSxTQUExRDtBQUNBOzs7QUNKQTs7QUFDQSxJQUFJLGVBQWUsUUFBUSxrQkFBUixDQUFuQjtBQUNBLElBQUksVUFBVSxRQUFRLHNCQUFSLENBQWQ7QUFDQSxhQUFhLFVBQWIsQ0FBd0IsU0FBeEIsQ0FBa0MsS0FBbEMsR0FBMEMsUUFBUSxLQUFsRDtBQUNBOzs7QUNKQTs7QUFDQSxJQUFJLGVBQWUsUUFBUSxrQkFBUixDQUFuQjtBQUNBLElBQUksY0FBYyxRQUFRLDBCQUFSLENBQWxCO0FBQ0EsYUFBYSxVQUFiLENBQXdCLFNBQXhCLENBQWtDLFNBQWxDLEdBQThDLFlBQVksU0FBMUQ7QUFDQTs7O0FDSkE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLFdBQVcsUUFBUSx1QkFBUixDQUFmO0FBQ0EsYUFBYSxVQUFiLENBQXdCLFNBQXhCLENBQWtDLE1BQWxDLEdBQTJDLFNBQVMsT0FBcEQ7QUFDQSxhQUFhLFVBQWIsQ0FBd0IsU0FBeEIsQ0FBa0MsT0FBbEMsR0FBNEMsU0FBUyxPQUFyRDtBQUNBOzs7QUNMQTs7QUFDQSxJQUFJLGVBQWUsUUFBUSxrQkFBUixDQUFuQjtBQUNBLElBQUksY0FBYyxRQUFRLDBCQUFSLENBQWxCO0FBQ0EsYUFBYSxVQUFiLENBQXdCLFNBQXhCLENBQWtDLFNBQWxDLEdBQThDLFlBQVksU0FBMUQ7QUFDQTs7O0FDSkE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLFNBQVMsUUFBUSxxQkFBUixDQUFiO0FBQ0EsYUFBYSxVQUFiLENBQXdCLFNBQXhCLENBQWtDLElBQWxDLEdBQXlDLE9BQU8sSUFBaEQ7QUFDQTs7O0FDSkE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLGNBQWMsUUFBUSwwQkFBUixDQUFsQjtBQUNBLGFBQWEsVUFBYixDQUF3QixTQUF4QixDQUFrQyxTQUFsQyxHQUE4QyxZQUFZLFNBQTFEO0FBQ0E7OztBQ0pBOztBQUNBLElBQUksZUFBZSxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSSxpQkFBaUIsUUFBUSw2QkFBUixDQUFyQjtBQUNBLGFBQWEsVUFBYixDQUF3QixTQUF4QixDQUFrQyxZQUFsQyxHQUFpRCxlQUFlLFlBQWhFO0FBQ0E7OztBQ0pBOztBQUNBLElBQUksZUFBZSxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSSxtQkFBbUIsUUFBUSwrQkFBUixDQUF2QjtBQUNBLGFBQWEsVUFBYixDQUF3QixTQUF4QixDQUFrQyxjQUFsQyxHQUFtRCxpQkFBaUIsY0FBcEU7QUFDQTs7O0FDSkE7O0FBQ0EsSUFBSSxlQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLFFBQVEsUUFBUSxvQkFBUixDQUFaO0FBQ0EsYUFBYSxVQUFiLENBQXdCLFNBQXhCLENBQWtDLEdBQWxDLEdBQXdDLE1BQU0sUUFBOUM7QUFDQTs7O0FDSkE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0EsSUFBSSxxQkFBcUIsUUFBUSxvQkFBUixDQUF6QjtBQUNBLElBQUksb0JBQW9CLFFBQVEsbUJBQVIsQ0FBeEI7QUFDQSxJQUFJLGdCQUFnQixRQUFRLHFCQUFSLENBQXBCO0FBQ0E7Ozs7O0FBS0EsSUFBSSxrQkFBbUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3JDLGNBQVUsZUFBVixFQUEyQixNQUEzQjtBQUNBLGFBQVMsZUFBVCxDQUF5QixLQUF6QixFQUFnQyxTQUFoQyxFQUEyQztBQUN2QyxlQUFPLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLGFBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNBLFlBQUksQ0FBQyxTQUFELElBQWMsTUFBTSxNQUFOLEtBQWlCLENBQW5DLEVBQXNDO0FBQ2xDLGlCQUFLLFNBQUwsR0FBaUIsSUFBakI7QUFDQSxpQkFBSyxLQUFMLEdBQWEsTUFBTSxDQUFOLENBQWI7QUFDSDtBQUNKO0FBQ0Qsb0JBQWdCLE1BQWhCLEdBQXlCLFVBQVUsS0FBVixFQUFpQixTQUFqQixFQUE0QjtBQUNqRCxlQUFPLElBQUksZUFBSixDQUFvQixLQUFwQixFQUEyQixTQUEzQixDQUFQO0FBQ0gsS0FGRDtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFvQ0Esb0JBQWdCLEVBQWhCLEdBQXFCLFlBQVk7QUFDN0IsWUFBSSxRQUFRLEVBQVo7QUFDQSxhQUFLLElBQUksS0FBSyxDQUFkLEVBQWlCLEtBQUssVUFBVSxNQUFoQyxFQUF3QyxJQUF4QyxFQUE4QztBQUMxQyxrQkFBTSxLQUFLLENBQVgsSUFBZ0IsVUFBVSxFQUFWLENBQWhCO0FBQ0g7QUFDRCxZQUFJLFlBQVksTUFBTSxNQUFNLE1BQU4sR0FBZSxDQUFyQixDQUFoQjtBQUNBLFlBQUksY0FBYyxXQUFkLENBQTBCLFNBQTFCLENBQUosRUFBMEM7QUFDdEMsa0JBQU0sR0FBTjtBQUNILFNBRkQsTUFHSztBQUNELHdCQUFZLElBQVo7QUFDSDtBQUNELFlBQUksTUFBTSxNQUFNLE1BQWhCO0FBQ0EsWUFBSSxNQUFNLENBQVYsRUFBYTtBQUNULG1CQUFPLElBQUksZUFBSixDQUFvQixLQUFwQixFQUEyQixTQUEzQixDQUFQO0FBQ0gsU0FGRCxNQUdLLElBQUksUUFBUSxDQUFaLEVBQWU7QUFDaEIsbUJBQU8sSUFBSSxtQkFBbUIsZ0JBQXZCLENBQXdDLE1BQU0sQ0FBTixDQUF4QyxFQUFrRCxTQUFsRCxDQUFQO0FBQ0gsU0FGSSxNQUdBO0FBQ0QsbUJBQU8sSUFBSSxrQkFBa0IsZUFBdEIsQ0FBc0MsU0FBdEMsQ0FBUDtBQUNIO0FBQ0osS0F0QkQ7QUF1QkEsb0JBQWdCLFFBQWhCLEdBQTJCLFVBQVUsS0FBVixFQUFpQjtBQUN4QyxZQUFJLFFBQVEsTUFBTSxLQUFsQjtBQUFBLFlBQXlCLFFBQVEsTUFBTSxLQUF2QztBQUFBLFlBQThDLFFBQVEsTUFBTSxLQUE1RDtBQUFBLFlBQW1FLGFBQWEsTUFBTSxVQUF0RjtBQUNBLFlBQUksU0FBUyxLQUFiLEVBQW9CO0FBQ2hCLHVCQUFXLFFBQVg7QUFDQTtBQUNIO0FBQ0QsbUJBQVcsSUFBWCxDQUFnQixNQUFNLEtBQU4sQ0FBaEI7QUFDQSxZQUFJLFdBQVcsTUFBZixFQUF1QjtBQUNuQjtBQUNIO0FBQ0QsY0FBTSxLQUFOLEdBQWMsUUFBUSxDQUF0QjtBQUNBLGFBQUssUUFBTCxDQUFjLEtBQWQ7QUFDSCxLQVpEO0FBYUEsb0JBQWdCLFNBQWhCLENBQTBCLFVBQTFCLEdBQXVDLFVBQVUsVUFBVixFQUFzQjtBQUN6RCxZQUFJLFFBQVEsQ0FBWjtBQUNBLFlBQUksUUFBUSxLQUFLLEtBQWpCO0FBQ0EsWUFBSSxRQUFRLE1BQU0sTUFBbEI7QUFDQSxZQUFJLFlBQVksS0FBSyxTQUFyQjtBQUNBLFlBQUksU0FBSixFQUFlO0FBQ1gsbUJBQU8sVUFBVSxRQUFWLENBQW1CLGdCQUFnQixRQUFuQyxFQUE2QyxDQUE3QyxFQUFnRDtBQUNuRCx1QkFBTyxLQUQ0QyxFQUNyQyxPQUFPLEtBRDhCLEVBQ3ZCLE9BQU8sS0FEZ0IsRUFDVCxZQUFZO0FBREgsYUFBaEQsQ0FBUDtBQUdILFNBSkQsTUFLSztBQUNELGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSixJQUFhLENBQUMsV0FBVyxNQUF6QyxFQUFpRCxHQUFqRCxFQUFzRDtBQUNsRCwyQkFBVyxJQUFYLENBQWdCLE1BQU0sQ0FBTixDQUFoQjtBQUNIO0FBQ0QsdUJBQVcsUUFBWDtBQUNIO0FBQ0osS0FoQkQ7QUFpQkEsV0FBTyxlQUFQO0FBQ0gsQ0F4R3NCLENBd0dyQixhQUFhLFVBeEdRLENBQXZCO0FBeUdBLFFBQVEsZUFBUixHQUEwQixlQUExQjtBQUNBOzs7QUN6SEE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLFlBQVksUUFBUSxZQUFSLENBQWhCO0FBQ0EsSUFBSSxlQUFlLFFBQVEsZUFBUixDQUFuQjtBQUNBLElBQUksZUFBZSxRQUFRLGVBQVIsQ0FBbkI7QUFDQSxJQUFJLGlCQUFpQixRQUFRLGlCQUFSLENBQXJCO0FBQ0E7OztBQUdBLElBQUksd0JBQXlCLFVBQVUsTUFBVixFQUFrQjtBQUMzQyxjQUFVLHFCQUFWLEVBQWlDLE1BQWpDO0FBQ0EsYUFBUyxxQkFBVCxDQUErQixNQUEvQixFQUF1QyxjQUF2QyxFQUF1RDtBQUNuRCxlQUFPLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLGFBQUssY0FBTCxHQUFzQixjQUF0QjtBQUNBLGFBQUssU0FBTCxHQUFpQixDQUFqQjtBQUNIO0FBQ0QsMEJBQXNCLFNBQXRCLENBQWdDLFVBQWhDLEdBQTZDLFVBQVUsVUFBVixFQUFzQjtBQUMvRCxlQUFPLEtBQUssVUFBTCxHQUFrQixTQUFsQixDQUE0QixVQUE1QixDQUFQO0FBQ0gsS0FGRDtBQUdBLDBCQUFzQixTQUF0QixDQUFnQyxVQUFoQyxHQUE2QyxZQUFZO0FBQ3JELFlBQUksVUFBVSxLQUFLLFFBQW5CO0FBQ0EsWUFBSSxDQUFDLE9BQUQsSUFBWSxRQUFRLFNBQXhCLEVBQW1DO0FBQy9CLGlCQUFLLFFBQUwsR0FBZ0IsS0FBSyxjQUFMLEVBQWhCO0FBQ0g7QUFDRCxlQUFPLEtBQUssUUFBWjtBQUNILEtBTkQ7QUFPQSwwQkFBc0IsU0FBdEIsQ0FBZ0MsT0FBaEMsR0FBMEMsWUFBWTtBQUNsRCxZQUFJLGFBQWEsS0FBSyxXQUF0QjtBQUNBLFlBQUksQ0FBQyxVQUFMLEVBQWlCO0FBQ2IseUJBQWEsS0FBSyxXQUFMLEdBQW1CLElBQUksZUFBZSxZQUFuQixFQUFoQztBQUNBLHVCQUFXLEdBQVgsQ0FBZSxLQUFLLE1BQUwsQ0FDVixTQURVLENBQ0EsSUFBSSxxQkFBSixDQUEwQixLQUFLLFVBQUwsRUFBMUIsRUFBNkMsSUFBN0MsQ0FEQSxDQUFmO0FBRUEsZ0JBQUksV0FBVyxNQUFmLEVBQXVCO0FBQ25CLHFCQUFLLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSw2QkFBYSxlQUFlLFlBQWYsQ0FBNEIsS0FBekM7QUFDSCxhQUhELE1BSUs7QUFDRCxxQkFBSyxXQUFMLEdBQW1CLFVBQW5CO0FBQ0g7QUFDSjtBQUNELGVBQU8sVUFBUDtBQUNILEtBZkQ7QUFnQkEsMEJBQXNCLFNBQXRCLENBQWdDLFFBQWhDLEdBQTJDLFlBQVk7QUFDbkQsZUFBTyxLQUFLLElBQUwsQ0FBVSxJQUFJLGdCQUFKLENBQXFCLElBQXJCLENBQVYsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPLHFCQUFQO0FBQ0gsQ0F0QzRCLENBc0MzQixhQUFhLFVBdENjLENBQTdCO0FBdUNBLFFBQVEscUJBQVIsR0FBZ0MscUJBQWhDO0FBQ0EsUUFBUSwrQkFBUixHQUEwQztBQUN0QyxjQUFVLEVBQUUsT0FBTyxJQUFULEVBRDRCO0FBRXRDLGVBQVcsRUFBRSxPQUFPLENBQVQsRUFBWSxVQUFVLElBQXRCLEVBRjJCO0FBR3RDLGdCQUFZLEVBQUUsT0FBTyxzQkFBc0IsU0FBdEIsQ0FBZ0MsVUFBekMsRUFIMEI7QUFJdEMsZ0JBQVksRUFBRSxPQUFPLHNCQUFzQixTQUF0QixDQUFnQyxVQUF6QyxFQUowQjtBQUt0QyxhQUFTLEVBQUUsT0FBTyxzQkFBc0IsU0FBdEIsQ0FBZ0MsT0FBekMsRUFMNkI7QUFNdEMsY0FBVSxFQUFFLE9BQU8sc0JBQXNCLFNBQXRCLENBQWdDLFFBQXpDO0FBTjRCLENBQTFDO0FBUUEsSUFBSSx3QkFBeUIsVUFBVSxNQUFWLEVBQWtCO0FBQzNDLGNBQVUscUJBQVYsRUFBaUMsTUFBakM7QUFDQSxhQUFTLHFCQUFULENBQStCLFdBQS9CLEVBQTRDLFdBQTVDLEVBQXlEO0FBQ3JELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLFdBQUwsR0FBbUIsV0FBbkI7QUFDSDtBQUNELDBCQUFzQixTQUF0QixDQUFnQyxNQUFoQyxHQUF5QyxVQUFVLEdBQVYsRUFBZTtBQUNwRCxhQUFLLFlBQUw7QUFDQSxlQUFPLFNBQVAsQ0FBaUIsTUFBakIsQ0FBd0IsSUFBeEIsQ0FBNkIsSUFBN0IsRUFBbUMsR0FBbkM7QUFDSCxLQUhEO0FBSUEsMEJBQXNCLFNBQXRCLENBQWdDLFNBQWhDLEdBQTRDLFlBQVk7QUFDcEQsYUFBSyxZQUFMO0FBQ0EsZUFBTyxTQUFQLENBQWlCLFNBQWpCLENBQTJCLElBQTNCLENBQWdDLElBQWhDO0FBQ0gsS0FIRDtBQUlBLDBCQUFzQixTQUF0QixDQUFnQyxZQUFoQyxHQUErQyxZQUFZO0FBQ3ZELFlBQUksY0FBYyxLQUFLLFdBQXZCO0FBQ0EsWUFBSSxXQUFKLEVBQWlCO0FBQ2IsaUJBQUssV0FBTCxHQUFtQixJQUFuQjtBQUNBLGdCQUFJLGFBQWEsWUFBWSxXQUE3QjtBQUNBLHdCQUFZLFNBQVosR0FBd0IsQ0FBeEI7QUFDQSx3QkFBWSxRQUFaLEdBQXVCLElBQXZCO0FBQ0Esd0JBQVksV0FBWixHQUEwQixJQUExQjtBQUNBLGdCQUFJLFVBQUosRUFBZ0I7QUFDWiwyQkFBVyxXQUFYO0FBQ0g7QUFDSjtBQUNKLEtBWkQ7QUFhQSxXQUFPLHFCQUFQO0FBQ0gsQ0E1QjRCLENBNEIzQixVQUFVLGlCQTVCaUIsQ0FBN0I7QUE2QkEsSUFBSSxtQkFBb0IsWUFBWTtBQUNoQyxhQUFTLGdCQUFULENBQTBCLFdBQTFCLEVBQXVDO0FBQ25DLGFBQUssV0FBTCxHQUFtQixXQUFuQjtBQUNIO0FBQ0QscUJBQWlCLFNBQWpCLENBQTJCLElBQTNCLEdBQWtDLFVBQVUsVUFBVixFQUFzQixNQUF0QixFQUE4QjtBQUM1RCxZQUFJLGNBQWMsS0FBSyxXQUF2QjtBQUNBLG9CQUFZLFNBQVo7QUFDQSxZQUFJLGFBQWEsSUFBSSxrQkFBSixDQUF1QixVQUF2QixFQUFtQyxXQUFuQyxDQUFqQjtBQUNBLFlBQUksZUFBZSxPQUFPLFNBQVAsQ0FBaUIsVUFBakIsQ0FBbkI7QUFDQSxZQUFJLENBQUMsV0FBVyxNQUFoQixFQUF3QjtBQUNwQix1QkFBVyxVQUFYLEdBQXdCLFlBQVksT0FBWixFQUF4QjtBQUNIO0FBQ0QsZUFBTyxZQUFQO0FBQ0gsS0FURDtBQVVBLFdBQU8sZ0JBQVA7QUFDSCxDQWZ1QixFQUF4QjtBQWdCQSxJQUFJLHFCQUFzQixVQUFVLE1BQVYsRUFBa0I7QUFDeEMsY0FBVSxrQkFBVixFQUE4QixNQUE5QjtBQUNBLGFBQVMsa0JBQVQsQ0FBNEIsV0FBNUIsRUFBeUMsV0FBekMsRUFBc0Q7QUFDbEQsZUFBTyxJQUFQLENBQVksSUFBWixFQUFrQixXQUFsQjtBQUNBLGFBQUssV0FBTCxHQUFtQixXQUFuQjtBQUNIO0FBQ0QsdUJBQW1CLFNBQW5CLENBQTZCLFlBQTdCLEdBQTRDLFlBQVk7QUFDcEQsWUFBSSxjQUFjLEtBQUssV0FBdkI7QUFDQSxZQUFJLENBQUMsV0FBTCxFQUFrQjtBQUNkLGlCQUFLLFVBQUwsR0FBa0IsSUFBbEI7QUFDQTtBQUNIO0FBQ0QsYUFBSyxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsWUFBSSxXQUFXLFlBQVksU0FBM0I7QUFDQSxZQUFJLFlBQVksQ0FBaEIsRUFBbUI7QUFDZixpQkFBSyxVQUFMLEdBQWtCLElBQWxCO0FBQ0E7QUFDSDtBQUNELG9CQUFZLFNBQVosR0FBd0IsV0FBVyxDQUFuQztBQUNBLFlBQUksV0FBVyxDQUFmLEVBQWtCO0FBQ2QsaUJBQUssVUFBTCxHQUFrQixJQUFsQjtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSSxhQUFhLEtBQUssVUFBdEI7QUFDQSxZQUFJLG1CQUFtQixZQUFZLFdBQW5DO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsWUFBSSxxQkFBcUIsQ0FBQyxVQUFELElBQWUscUJBQXFCLFVBQXpELENBQUosRUFBMEU7QUFDdEUsNkJBQWlCLFdBQWpCO0FBQ0g7QUFDSixLQTlDRDtBQStDQSxXQUFPLGtCQUFQO0FBQ0gsQ0F0RHlCLENBc0R4QixhQUFhLFVBdERXLENBQTFCO0FBdURBOzs7QUNqS0E7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0EsSUFBSSxzQkFBc0IsUUFBUSwyQkFBUixDQUExQjtBQUNBLElBQUksb0JBQW9CLFFBQVEsb0JBQVIsQ0FBeEI7QUFDQTs7Ozs7QUFLQSxJQUFJLGtCQUFtQixVQUFVLE1BQVYsRUFBa0I7QUFDckMsY0FBVSxlQUFWLEVBQTJCLE1BQTNCO0FBQ0EsYUFBUyxlQUFULENBQXlCLGlCQUF6QixFQUE0QztBQUN4QyxlQUFPLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBSyxpQkFBTCxHQUF5QixpQkFBekI7QUFDSDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOENBLG9CQUFnQixNQUFoQixHQUF5QixVQUFVLGlCQUFWLEVBQTZCO0FBQ2xELGVBQU8sSUFBSSxlQUFKLENBQW9CLGlCQUFwQixDQUFQO0FBQ0gsS0FGRDtBQUdBLG9CQUFnQixTQUFoQixDQUEwQixVQUExQixHQUF1QyxVQUFVLFVBQVYsRUFBc0I7QUFDekQsZUFBTyxJQUFJLGVBQUosQ0FBb0IsVUFBcEIsRUFBZ0MsS0FBSyxpQkFBckMsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPLGVBQVA7QUFDSCxDQTNEc0IsQ0EyRHJCLGFBQWEsVUEzRFEsQ0FBdkI7QUE0REEsUUFBUSxlQUFSLEdBQTBCLGVBQTFCO0FBQ0EsSUFBSSxrQkFBbUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3JDLGNBQVUsZUFBVixFQUEyQixNQUEzQjtBQUNBLGFBQVMsZUFBVCxDQUF5QixXQUF6QixFQUFzQyxPQUF0QyxFQUErQztBQUMzQyxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsYUFBSyxPQUFMLEdBQWUsT0FBZjtBQUNBLGFBQUssUUFBTDtBQUNIO0FBQ0Qsb0JBQWdCLFNBQWhCLENBQTBCLFFBQTFCLEdBQXFDLFlBQVk7QUFDN0MsWUFBSTtBQUNBLGlCQUFLLFlBQUw7QUFDSCxTQUZELENBR0EsT0FBTyxHQUFQLEVBQVk7QUFDUixpQkFBSyxNQUFMLENBQVksR0FBWjtBQUNIO0FBQ0osS0FQRDtBQVFBLG9CQUFnQixTQUFoQixDQUEwQixZQUExQixHQUF5QyxZQUFZO0FBQ2pELFlBQUksU0FBUyxLQUFLLE9BQUwsRUFBYjtBQUNBLFlBQUksTUFBSixFQUFZO0FBQ1IsaUJBQUssR0FBTCxDQUFTLG9CQUFvQixpQkFBcEIsQ0FBc0MsSUFBdEMsRUFBNEMsTUFBNUMsQ0FBVDtBQUNIO0FBQ0osS0FMRDtBQU1BLFdBQU8sZUFBUDtBQUNILENBdEJzQixDQXNCckIsa0JBQWtCLGVBdEJHLENBQXZCO0FBdUJBOzs7QUNsR0E7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0E7Ozs7O0FBS0EsSUFBSSxrQkFBbUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3JDLGNBQVUsZUFBVixFQUEyQixNQUEzQjtBQUNBLGFBQVMsZUFBVCxDQUF5QixTQUF6QixFQUFvQztBQUNoQyxlQUFPLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0g7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJDQSxvQkFBZ0IsTUFBaEIsR0FBeUIsVUFBVSxTQUFWLEVBQXFCO0FBQzFDLGVBQU8sSUFBSSxlQUFKLENBQW9CLFNBQXBCLENBQVA7QUFDSCxLQUZEO0FBR0Esb0JBQWdCLFFBQWhCLEdBQTJCLFVBQVUsR0FBVixFQUFlO0FBQ3RDLFlBQUksYUFBYSxJQUFJLFVBQXJCO0FBQ0EsbUJBQVcsUUFBWDtBQUNILEtBSEQ7QUFJQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsVUFBMUIsR0FBdUMsVUFBVSxVQUFWLEVBQXNCO0FBQ3pELFlBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0EsWUFBSSxTQUFKLEVBQWU7QUFDWCxtQkFBTyxVQUFVLFFBQVYsQ0FBbUIsZ0JBQWdCLFFBQW5DLEVBQTZDLENBQTdDLEVBQWdELEVBQUUsWUFBWSxVQUFkLEVBQWhELENBQVA7QUFDSCxTQUZELE1BR0s7QUFDRCx1QkFBVyxRQUFYO0FBQ0g7QUFDSixLQVJEO0FBU0EsV0FBTyxlQUFQO0FBQ0gsQ0FsRXNCLENBa0VyQixhQUFhLFVBbEVRLENBQXZCO0FBbUVBLFFBQVEsZUFBUixHQUEwQixlQUExQjtBQUNBOzs7QUNoRkE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0E7Ozs7O0FBS0EsSUFBSSxrQkFBbUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3JDLGNBQVUsZUFBVixFQUEyQixNQUEzQjtBQUNBLGFBQVMsZUFBVCxDQUF5QixLQUF6QixFQUFnQyxTQUFoQyxFQUEyQztBQUN2QyxlQUFPLElBQVAsQ0FBWSxJQUFaO0FBQ0EsYUFBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLGFBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNIO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3Q0Esb0JBQWdCLE1BQWhCLEdBQXlCLFVBQVUsS0FBVixFQUFpQixTQUFqQixFQUE0QjtBQUNqRCxlQUFPLElBQUksZUFBSixDQUFvQixLQUFwQixFQUEyQixTQUEzQixDQUFQO0FBQ0gsS0FGRDtBQUdBLG9CQUFnQixRQUFoQixHQUEyQixVQUFVLEdBQVYsRUFBZTtBQUN0QyxZQUFJLFFBQVEsSUFBSSxLQUFoQjtBQUFBLFlBQXVCLGFBQWEsSUFBSSxVQUF4QztBQUNBLG1CQUFXLEtBQVgsQ0FBaUIsS0FBakI7QUFDSCxLQUhEO0FBSUEsb0JBQWdCLFNBQWhCLENBQTBCLFVBQTFCLEdBQXVDLFVBQVUsVUFBVixFQUFzQjtBQUN6RCxZQUFJLFFBQVEsS0FBSyxLQUFqQjtBQUNBLFlBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0EsWUFBSSxTQUFKLEVBQWU7QUFDWCxtQkFBTyxVQUFVLFFBQVYsQ0FBbUIsZ0JBQWdCLFFBQW5DLEVBQTZDLENBQTdDLEVBQWdEO0FBQ25ELHVCQUFPLEtBRDRDLEVBQ3JDLFlBQVk7QUFEeUIsYUFBaEQsQ0FBUDtBQUdILFNBSkQsTUFLSztBQUNELHVCQUFXLEtBQVgsQ0FBaUIsS0FBakI7QUFDSDtBQUNKLEtBWEQ7QUFZQSxXQUFPLGVBQVA7QUFDSCxDQW5Fc0IsQ0FtRXJCLGFBQWEsVUFuRVEsQ0FBdkI7QUFvRUEsUUFBUSxlQUFSLEdBQTBCLGVBQTFCO0FBQ0E7OztBQ2pGQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQ7QUFBaUIsWUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksZUFBZSxRQUFRLGVBQVIsQ0FBbkI7QUFDQSxJQUFJLGFBQWEsUUFBUSxrQkFBUixDQUFqQjtBQUNBLElBQUksZUFBZSxRQUFRLG9CQUFSLENBQW5CO0FBQ0EsSUFBSSxnQkFBZ0IsUUFBUSxxQkFBUixDQUFwQjtBQUNBLElBQUksaUJBQWlCLFFBQVEsaUJBQVIsQ0FBckI7QUFDQSxJQUFJLFdBQVcsT0FBTyxTQUFQLENBQWlCLFFBQWhDO0FBQ0EsU0FBUyx1QkFBVCxDQUFpQyxTQUFqQyxFQUE0QztBQUN4QyxXQUFPLENBQUMsQ0FBQyxTQUFGLElBQWUsT0FBTyxVQUFVLFdBQWpCLEtBQWlDLFVBQWhELElBQThELE9BQU8sVUFBVSxjQUFqQixLQUFvQyxVQUF6RztBQUNIO0FBQ0QsU0FBUyx5QkFBVCxDQUFtQyxTQUFuQyxFQUE4QztBQUMxQyxXQUFPLENBQUMsQ0FBQyxTQUFGLElBQWUsT0FBTyxVQUFVLEVBQWpCLEtBQXdCLFVBQXZDLElBQXFELE9BQU8sVUFBVSxHQUFqQixLQUF5QixVQUFyRjtBQUNIO0FBQ0QsU0FBUyxVQUFULENBQW9CLFNBQXBCLEVBQStCO0FBQzNCLFdBQU8sQ0FBQyxDQUFDLFNBQUYsSUFBZSxTQUFTLElBQVQsQ0FBYyxTQUFkLE1BQTZCLG1CQUFuRDtBQUNIO0FBQ0QsU0FBUyxnQkFBVCxDQUEwQixTQUExQixFQUFxQztBQUNqQyxXQUFPLENBQUMsQ0FBQyxTQUFGLElBQWUsU0FBUyxJQUFULENBQWMsU0FBZCxNQUE2Qix5QkFBbkQ7QUFDSDtBQUNELFNBQVMsYUFBVCxDQUF1QixTQUF2QixFQUFrQztBQUM5QixXQUFPLENBQUMsQ0FBQyxTQUFGLElBQWUsT0FBTyxVQUFVLGdCQUFqQixLQUFzQyxVQUFyRCxJQUFtRSxPQUFPLFVBQVUsbUJBQWpCLEtBQXlDLFVBQW5IO0FBQ0g7QUFDRDs7Ozs7QUFLQSxJQUFJLHNCQUF1QixVQUFVLE1BQVYsRUFBa0I7QUFDekMsY0FBVSxtQkFBVixFQUErQixNQUEvQjtBQUNBLGFBQVMsbUJBQVQsQ0FBNkIsU0FBN0IsRUFBd0MsU0FBeEMsRUFBbUQsUUFBbkQsRUFBNkQsT0FBN0QsRUFBc0U7QUFDbEUsZUFBTyxJQUFQLENBQVksSUFBWjtBQUNBLGFBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNBLGFBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNBLGFBQUssUUFBTCxHQUFnQixRQUFoQjtBQUNBLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDSDtBQUNEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF3Q0Esd0JBQW9CLE1BQXBCLEdBQTZCLFVBQVUsTUFBVixFQUFrQixTQUFsQixFQUE2QixPQUE3QixFQUFzQyxRQUF0QyxFQUFnRDtBQUN6RSxZQUFJLGFBQWEsVUFBYixDQUF3QixPQUF4QixDQUFKLEVBQXNDO0FBQ2xDLHVCQUFXLE9BQVg7QUFDQSxzQkFBVSxTQUFWO0FBQ0g7QUFDRCxlQUFPLElBQUksbUJBQUosQ0FBd0IsTUFBeEIsRUFBZ0MsU0FBaEMsRUFBMkMsUUFBM0MsRUFBcUQsT0FBckQsQ0FBUDtBQUNILEtBTkQ7QUFPQSx3QkFBb0IsaUJBQXBCLEdBQXdDLFVBQVUsU0FBVixFQUFxQixTQUFyQixFQUFnQyxPQUFoQyxFQUF5QyxVQUF6QyxFQUFxRCxPQUFyRCxFQUE4RDtBQUNsRyxZQUFJLFdBQUo7QUFDQSxZQUFJLFdBQVcsU0FBWCxLQUF5QixpQkFBaUIsU0FBakIsQ0FBN0IsRUFBMEQ7QUFDdEQsaUJBQUssSUFBSSxJQUFJLENBQVIsRUFBVyxNQUFNLFVBQVUsTUFBaEMsRUFBd0MsSUFBSSxHQUE1QyxFQUFpRCxHQUFqRCxFQUFzRDtBQUNsRCxvQ0FBb0IsaUJBQXBCLENBQXNDLFVBQVUsQ0FBVixDQUF0QyxFQUFvRCxTQUFwRCxFQUErRCxPQUEvRCxFQUF3RSxVQUF4RSxFQUFvRixPQUFwRjtBQUNIO0FBQ0osU0FKRCxNQUtLLElBQUksY0FBYyxTQUFkLENBQUosRUFBOEI7QUFDL0IsZ0JBQUksV0FBVyxTQUFmO0FBQ0Esc0JBQVUsZ0JBQVYsQ0FBMkIsU0FBM0IsRUFBc0MsT0FBdEMsRUFBK0MsT0FBL0M7QUFDQSwwQkFBYyx1QkFBWTtBQUFFLHVCQUFPLFNBQVMsbUJBQVQsQ0FBNkIsU0FBN0IsRUFBd0MsT0FBeEMsQ0FBUDtBQUEwRCxhQUF0RjtBQUNILFNBSkksTUFLQSxJQUFJLDBCQUEwQixTQUExQixDQUFKLEVBQTBDO0FBQzNDLGdCQUFJLFdBQVcsU0FBZjtBQUNBLHNCQUFVLEVBQVYsQ0FBYSxTQUFiLEVBQXdCLE9BQXhCO0FBQ0EsMEJBQWMsdUJBQVk7QUFBRSx1QkFBTyxTQUFTLEdBQVQsQ0FBYSxTQUFiLEVBQXdCLE9BQXhCLENBQVA7QUFBMEMsYUFBdEU7QUFDSCxTQUpJLE1BS0EsSUFBSSx3QkFBd0IsU0FBeEIsQ0FBSixFQUF3QztBQUN6QyxnQkFBSSxXQUFXLFNBQWY7QUFDQSxzQkFBVSxXQUFWLENBQXNCLFNBQXRCLEVBQWlDLE9BQWpDO0FBQ0EsMEJBQWMsdUJBQVk7QUFBRSx1QkFBTyxTQUFTLGNBQVQsQ0FBd0IsU0FBeEIsRUFBbUMsT0FBbkMsQ0FBUDtBQUFxRCxhQUFqRjtBQUNILFNBSkksTUFLQTtBQUNELGtCQUFNLElBQUksU0FBSixDQUFjLHNCQUFkLENBQU47QUFDSDtBQUNELG1CQUFXLEdBQVgsQ0FBZSxJQUFJLGVBQWUsWUFBbkIsQ0FBZ0MsV0FBaEMsQ0FBZjtBQUNILEtBMUJEO0FBMkJBLHdCQUFvQixTQUFwQixDQUE4QixVQUE5QixHQUEyQyxVQUFVLFVBQVYsRUFBc0I7QUFDN0QsWUFBSSxZQUFZLEtBQUssU0FBckI7QUFDQSxZQUFJLFlBQVksS0FBSyxTQUFyQjtBQUNBLFlBQUksVUFBVSxLQUFLLE9BQW5CO0FBQ0EsWUFBSSxXQUFXLEtBQUssUUFBcEI7QUFDQSxZQUFJLFVBQVUsV0FBVyxZQUFZO0FBQ2pDLGdCQUFJLE9BQU8sRUFBWDtBQUNBLGlCQUFLLElBQUksS0FBSyxDQUFkLEVBQWlCLEtBQUssVUFBVSxNQUFoQyxFQUF3QyxJQUF4QyxFQUE4QztBQUMxQyxxQkFBSyxLQUFLLENBQVYsSUFBZSxVQUFVLEVBQVYsQ0FBZjtBQUNIO0FBQ0QsZ0JBQUksU0FBUyxXQUFXLFFBQVgsQ0FBb0IsUUFBcEIsRUFBOEIsS0FBOUIsQ0FBb0MsS0FBSyxDQUF6QyxFQUE0QyxJQUE1QyxDQUFiO0FBQ0EsZ0JBQUksV0FBVyxjQUFjLFdBQTdCLEVBQTBDO0FBQ3RDLDJCQUFXLEtBQVgsQ0FBaUIsY0FBYyxXQUFkLENBQTBCLENBQTNDO0FBQ0gsYUFGRCxNQUdLO0FBQ0QsMkJBQVcsSUFBWCxDQUFnQixNQUFoQjtBQUNIO0FBQ0osU0FaYSxHQVlWLFVBQVUsQ0FBVixFQUFhO0FBQUUsbUJBQU8sV0FBVyxJQUFYLENBQWdCLENBQWhCLENBQVA7QUFBNEIsU0FaL0M7QUFhQSw0QkFBb0IsaUJBQXBCLENBQXNDLFNBQXRDLEVBQWlELFNBQWpELEVBQTRELE9BQTVELEVBQXFFLFVBQXJFLEVBQWlGLE9BQWpGO0FBQ0gsS0FuQkQ7QUFvQkEsV0FBTyxtQkFBUDtBQUNILENBekcwQixDQXlHekIsYUFBYSxVQXpHWSxDQUEzQjtBQTBHQSxRQUFRLG1CQUFSLEdBQThCLG1CQUE5QjtBQUNBOzs7QUMzSUE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0E7Ozs7O0FBS0EsSUFBSSxtQkFBb0IsVUFBVSxNQUFWLEVBQWtCO0FBQ3RDLGNBQVUsZ0JBQVYsRUFBNEIsTUFBNUI7QUFDQSxhQUFTLGdCQUFULENBQTBCLEtBQTFCLEVBQWlDLFNBQWpDLEVBQTRDO0FBQ3hDLGVBQU8sSUFBUCxDQUFZLElBQVo7QUFDQSxhQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsWUFBSSxTQUFKLEVBQWU7QUFDWCxpQkFBSyxTQUFMLEdBQWlCLEtBQWpCO0FBQ0g7QUFDSjtBQUNELHFCQUFpQixNQUFqQixHQUEwQixVQUFVLEtBQVYsRUFBaUIsU0FBakIsRUFBNEI7QUFDbEQsZUFBTyxJQUFJLGdCQUFKLENBQXFCLEtBQXJCLEVBQTRCLFNBQTVCLENBQVA7QUFDSCxLQUZEO0FBR0EscUJBQWlCLFFBQWpCLEdBQTRCLFVBQVUsS0FBVixFQUFpQjtBQUN6QyxZQUFJLE9BQU8sTUFBTSxJQUFqQjtBQUFBLFlBQXVCLFFBQVEsTUFBTSxLQUFyQztBQUFBLFlBQTRDLGFBQWEsTUFBTSxVQUEvRDtBQUNBLFlBQUksSUFBSixFQUFVO0FBQ04sdUJBQVcsUUFBWDtBQUNBO0FBQ0g7QUFDRCxtQkFBVyxJQUFYLENBQWdCLEtBQWhCO0FBQ0EsWUFBSSxXQUFXLE1BQWYsRUFBdUI7QUFDbkI7QUFDSDtBQUNELGNBQU0sSUFBTixHQUFhLElBQWI7QUFDQSxhQUFLLFFBQUwsQ0FBYyxLQUFkO0FBQ0gsS0FaRDtBQWFBLHFCQUFpQixTQUFqQixDQUEyQixVQUEzQixHQUF3QyxVQUFVLFVBQVYsRUFBc0I7QUFDMUQsWUFBSSxRQUFRLEtBQUssS0FBakI7QUFDQSxZQUFJLFlBQVksS0FBSyxTQUFyQjtBQUNBLFlBQUksU0FBSixFQUFlO0FBQ1gsbUJBQU8sVUFBVSxRQUFWLENBQW1CLGlCQUFpQixRQUFwQyxFQUE4QyxDQUE5QyxFQUFpRDtBQUNwRCxzQkFBTSxLQUQ4QyxFQUN2QyxPQUFPLEtBRGdDLEVBQ3pCLFlBQVk7QUFEYSxhQUFqRCxDQUFQO0FBR0gsU0FKRCxNQUtLO0FBQ0QsdUJBQVcsSUFBWCxDQUFnQixLQUFoQjtBQUNBLGdCQUFJLENBQUMsV0FBVyxNQUFoQixFQUF3QjtBQUNwQiwyQkFBVyxRQUFYO0FBQ0g7QUFDSjtBQUNKLEtBZEQ7QUFlQSxXQUFPLGdCQUFQO0FBQ0gsQ0EzQ3VCLENBMkN0QixhQUFhLFVBM0NTLENBQXhCO0FBNENBLFFBQVEsZ0JBQVIsR0FBMkIsZ0JBQTNCO0FBQ0E7OztBQ3pEQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQ7QUFBaUIsWUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksY0FBYyxRQUFRLG1CQUFSLENBQWxCO0FBQ0EsSUFBSSxlQUFlLFFBQVEsZUFBUixDQUFuQjtBQUNBLElBQUksVUFBVSxRQUFRLG9CQUFSLENBQWQ7QUFDQSxJQUFJLGdCQUFnQixRQUFRLHFCQUFSLENBQXBCO0FBQ0EsSUFBSSxXQUFXLFFBQVEsZ0JBQVIsQ0FBZjtBQUNBOzs7OztBQUtBLElBQUksa0JBQW1CLFVBQVUsTUFBVixFQUFrQjtBQUNyQyxjQUFVLGVBQVYsRUFBMkIsTUFBM0I7QUFDQSxhQUFTLGVBQVQsQ0FBeUIsT0FBekIsRUFBa0MsTUFBbEMsRUFBMEMsU0FBMUMsRUFBcUQ7QUFDakQsWUFBSSxZQUFZLEtBQUssQ0FBckIsRUFBd0I7QUFBRSxzQkFBVSxDQUFWO0FBQWM7QUFDeEMsZUFBTyxJQUFQLENBQVksSUFBWjtBQUNBLGFBQUssTUFBTCxHQUFjLENBQUMsQ0FBZjtBQUNBLGFBQUssT0FBTCxHQUFlLENBQWY7QUFDQSxZQUFJLFlBQVksU0FBWixDQUFzQixNQUF0QixDQUFKLEVBQW1DO0FBQy9CLGlCQUFLLE1BQUwsR0FBYyxPQUFPLE1BQVAsSUFBaUIsQ0FBakIsSUFBc0IsQ0FBdEIsSUFBMkIsT0FBTyxNQUFQLENBQXpDO0FBQ0gsU0FGRCxNQUdLLElBQUksY0FBYyxXQUFkLENBQTBCLE1BQTFCLENBQUosRUFBdUM7QUFDeEMsd0JBQVksTUFBWjtBQUNIO0FBQ0QsWUFBSSxDQUFDLGNBQWMsV0FBZCxDQUEwQixTQUExQixDQUFMLEVBQTJDO0FBQ3ZDLHdCQUFZLFFBQVEsS0FBcEI7QUFDSDtBQUNELGFBQUssU0FBTCxHQUFpQixTQUFqQjtBQUNBLGFBQUssT0FBTCxHQUFlLFNBQVMsTUFBVCxDQUFnQixPQUFoQixJQUNWLENBQUMsT0FBRCxHQUFXLEtBQUssU0FBTCxDQUFlLEdBQWYsRUFERCxHQUVYLE9BRko7QUFHSDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEwQ0Esb0JBQWdCLE1BQWhCLEdBQXlCLFVBQVUsWUFBVixFQUF3QixNQUF4QixFQUFnQyxTQUFoQyxFQUEyQztBQUNoRSxZQUFJLGlCQUFpQixLQUFLLENBQTFCLEVBQTZCO0FBQUUsMkJBQWUsQ0FBZjtBQUFtQjtBQUNsRCxlQUFPLElBQUksZUFBSixDQUFvQixZQUFwQixFQUFrQyxNQUFsQyxFQUEwQyxTQUExQyxDQUFQO0FBQ0gsS0FIRDtBQUlBLG9CQUFnQixRQUFoQixHQUEyQixVQUFVLEtBQVYsRUFBaUI7QUFDeEMsWUFBSSxRQUFRLE1BQU0sS0FBbEI7QUFBQSxZQUF5QixTQUFTLE1BQU0sTUFBeEM7QUFBQSxZQUFnRCxhQUFhLE1BQU0sVUFBbkU7QUFDQSxZQUFJLFNBQVMsSUFBYjtBQUNBLG1CQUFXLElBQVgsQ0FBZ0IsS0FBaEI7QUFDQSxZQUFJLFdBQVcsTUFBZixFQUF1QjtBQUNuQjtBQUNILFNBRkQsTUFHSyxJQUFJLFdBQVcsQ0FBQyxDQUFoQixFQUFtQjtBQUNwQixtQkFBTyxXQUFXLFFBQVgsRUFBUDtBQUNIO0FBQ0QsY0FBTSxLQUFOLEdBQWMsUUFBUSxDQUF0QjtBQUNBLGVBQU8sUUFBUCxDQUFnQixLQUFoQixFQUF1QixNQUF2QjtBQUNILEtBWkQ7QUFhQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsVUFBMUIsR0FBdUMsVUFBVSxVQUFWLEVBQXNCO0FBQ3pELFlBQUksUUFBUSxDQUFaO0FBQ0EsWUFBSSxLQUFLLElBQVQ7QUFBQSxZQUFlLFNBQVMsR0FBRyxNQUEzQjtBQUFBLFlBQW1DLFVBQVUsR0FBRyxPQUFoRDtBQUFBLFlBQXlELFlBQVksR0FBRyxTQUF4RTtBQUNBLGVBQU8sVUFBVSxRQUFWLENBQW1CLGdCQUFnQixRQUFuQyxFQUE2QyxPQUE3QyxFQUFzRDtBQUN6RCxtQkFBTyxLQURrRCxFQUMzQyxRQUFRLE1BRG1DLEVBQzNCLFlBQVk7QUFEZSxTQUF0RCxDQUFQO0FBR0gsS0FORDtBQU9BLFdBQU8sZUFBUDtBQUNILENBeEZzQixDQXdGckIsYUFBYSxVQXhGUSxDQUF2QjtBQXlGQSxRQUFRLGVBQVIsR0FBMEIsZUFBMUI7QUFDQTs7O0FDMUdBOztBQUNBLElBQUksb0JBQW9CLFFBQVEsbUJBQVIsQ0FBeEI7QUFDQSxRQUFRLEtBQVIsR0FBZ0Isa0JBQWtCLGVBQWxCLENBQWtDLE1BQWxEO0FBQ0E7OztBQ0hBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZDtBQUFpQixZQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxTQUFTLFFBQVEsaUJBQVIsQ0FBYjtBQUNBLElBQUksYUFBYSxRQUFRLHFCQUFSLENBQWpCO0FBQ0EsSUFBSSxnQkFBZ0IsUUFBUSx3QkFBUixDQUFwQjtBQUNBLElBQUksZUFBZSxRQUFRLGtCQUFSLENBQW5CO0FBQ0EsSUFBSSxlQUFlLFFBQVEsa0JBQVIsQ0FBbkI7QUFDQSxJQUFJLFFBQVEsUUFBUSxvQkFBUixDQUFaO0FBQ0EsU0FBUyxjQUFULEdBQTBCO0FBQ3RCLFFBQUksT0FBTyxJQUFQLENBQVksY0FBaEIsRUFBZ0M7QUFDNUIsZUFBTyxJQUFJLE9BQU8sSUFBUCxDQUFZLGNBQWhCLEVBQVA7QUFDSCxLQUZELE1BR0ssSUFBSSxDQUFDLENBQUMsT0FBTyxJQUFQLENBQVksY0FBbEIsRUFBa0M7QUFDbkMsZUFBTyxJQUFJLE9BQU8sSUFBUCxDQUFZLGNBQWhCLEVBQVA7QUFDSCxLQUZJLE1BR0E7QUFDRCxjQUFNLElBQUksS0FBSixDQUFVLHVDQUFWLENBQU47QUFDSDtBQUNKO0FBQ0QsU0FBUyxpQkFBVCxHQUE2QjtBQUN6QixRQUFJLE9BQU8sSUFBUCxDQUFZLGNBQWhCLEVBQWdDO0FBQzVCLGVBQU8sSUFBSSxPQUFPLElBQVAsQ0FBWSxjQUFoQixFQUFQO0FBQ0gsS0FGRCxNQUdLO0FBQ0QsWUFBSSxTQUFTLEtBQUssQ0FBbEI7QUFDQSxZQUFJO0FBQ0EsZ0JBQUksVUFBVSxDQUFDLGdCQUFELEVBQW1CLG1CQUFuQixFQUF3QyxvQkFBeEMsQ0FBZDtBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsb0JBQUk7QUFDQSw2QkFBUyxRQUFRLENBQVIsQ0FBVDtBQUNBLHdCQUFJLElBQUksT0FBTyxJQUFQLENBQVksYUFBaEIsQ0FBOEIsTUFBOUIsQ0FBSixFQUEyQztBQUN2QztBQUNIO0FBQ0osaUJBTEQsQ0FNQSxPQUFPLENBQVAsRUFBVSxDQUNUO0FBQ0o7QUFDRCxtQkFBTyxJQUFJLE9BQU8sSUFBUCxDQUFZLGFBQWhCLENBQThCLE1BQTlCLENBQVA7QUFDSCxTQWJELENBY0EsT0FBTyxDQUFQLEVBQVU7QUFDTixrQkFBTSxJQUFJLEtBQUosQ0FBVSxpREFBVixDQUFOO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsU0FBUyxPQUFULENBQWlCLEdBQWpCLEVBQXNCLE9BQXRCLEVBQStCO0FBQzNCLFFBQUksWUFBWSxLQUFLLENBQXJCLEVBQXdCO0FBQUUsa0JBQVUsSUFBVjtBQUFpQjtBQUMzQyxXQUFPLElBQUksY0FBSixDQUFtQixFQUFFLFFBQVEsS0FBVixFQUFpQixLQUFLLEdBQXRCLEVBQTJCLFNBQVMsT0FBcEMsRUFBbkIsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxPQUFSLEdBQWtCLE9BQWxCO0FBQ0E7QUFDQSxTQUFTLFFBQVQsQ0FBa0IsR0FBbEIsRUFBdUIsSUFBdkIsRUFBNkIsT0FBN0IsRUFBc0M7QUFDbEMsV0FBTyxJQUFJLGNBQUosQ0FBbUIsRUFBRSxRQUFRLE1BQVYsRUFBa0IsS0FBSyxHQUF2QixFQUE0QixNQUFNLElBQWxDLEVBQXdDLFNBQVMsT0FBakQsRUFBbkIsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxRQUFSLEdBQW1CLFFBQW5CO0FBQ0E7QUFDQSxTQUFTLFVBQVQsQ0FBb0IsR0FBcEIsRUFBeUIsT0FBekIsRUFBa0M7QUFDOUIsV0FBTyxJQUFJLGNBQUosQ0FBbUIsRUFBRSxRQUFRLFFBQVYsRUFBb0IsS0FBSyxHQUF6QixFQUE4QixTQUFTLE9BQXZDLEVBQW5CLENBQVA7QUFDSDtBQUNELFFBQVEsVUFBUixHQUFxQixVQUFyQjtBQUNBO0FBQ0EsU0FBUyxPQUFULENBQWlCLEdBQWpCLEVBQXNCLElBQXRCLEVBQTRCLE9BQTVCLEVBQXFDO0FBQ2pDLFdBQU8sSUFBSSxjQUFKLENBQW1CLEVBQUUsUUFBUSxLQUFWLEVBQWlCLEtBQUssR0FBdEIsRUFBMkIsTUFBTSxJQUFqQyxFQUF1QyxTQUFTLE9BQWhELEVBQW5CLENBQVA7QUFDSDtBQUNELFFBQVEsT0FBUixHQUFrQixPQUFsQjtBQUNBO0FBQ0EsU0FBUyxTQUFULENBQW1CLEdBQW5CLEVBQXdCLElBQXhCLEVBQThCLE9BQTlCLEVBQXVDO0FBQ25DLFdBQU8sSUFBSSxjQUFKLENBQW1CLEVBQUUsUUFBUSxPQUFWLEVBQW1CLEtBQUssR0FBeEIsRUFBNkIsTUFBTSxJQUFuQyxFQUF5QyxTQUFTLE9BQWxELEVBQW5CLENBQVA7QUFDSDtBQUNELFFBQVEsU0FBUixHQUFvQixTQUFwQjtBQUNBO0FBQ0EsU0FBUyxXQUFULENBQXFCLEdBQXJCLEVBQTBCLE9BQTFCLEVBQW1DO0FBQy9CLFdBQU8sSUFBSSxjQUFKLENBQW1CLEVBQUUsUUFBUSxLQUFWLEVBQWlCLEtBQUssR0FBdEIsRUFBMkIsY0FBYyxNQUF6QyxFQUFpRCxTQUFTLE9BQTFELEVBQW5CLEVBQ0YsSUFERSxDQUNHLElBQUksTUFBTSxXQUFWLENBQXNCLFVBQVUsQ0FBVixFQUFhLEtBQWIsRUFBb0I7QUFBRSxlQUFPLEVBQUUsUUFBVDtBQUFvQixLQUFoRSxFQUFrRSxJQUFsRSxDQURILENBQVA7QUFFSDtBQUNELFFBQVEsV0FBUixHQUFzQixXQUF0QjtBQUNBO0FBQ0E7Ozs7O0FBS0EsSUFBSSxpQkFBa0IsVUFBVSxNQUFWLEVBQWtCO0FBQ3BDLGNBQVUsY0FBVixFQUEwQixNQUExQjtBQUNBLGFBQVMsY0FBVCxDQUF3QixZQUF4QixFQUFzQztBQUNsQyxlQUFPLElBQVAsQ0FBWSxJQUFaO0FBQ0EsWUFBSSxVQUFVO0FBQ1YsbUJBQU8sSUFERztBQUVWLHVCQUFXLHFCQUFZO0FBQ25CLHVCQUFPLEtBQUssV0FBTCxHQUFtQixlQUFlLElBQWYsQ0FBb0IsSUFBcEIsQ0FBbkIsR0FBK0MsbUJBQXREO0FBQ0gsYUFKUztBQUtWLHlCQUFhLEtBTEg7QUFNViw2QkFBaUIsS0FOUDtBQU9WLHFCQUFTLEVBUEM7QUFRVixvQkFBUSxLQVJFO0FBU1YsMEJBQWMsTUFUSjtBQVVWLHFCQUFTO0FBVkMsU0FBZDtBQVlBLFlBQUksT0FBTyxZQUFQLEtBQXdCLFFBQTVCLEVBQXNDO0FBQ2xDLG9CQUFRLEdBQVIsR0FBYyxZQUFkO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsaUJBQUssSUFBSSxJQUFULElBQWlCLFlBQWpCLEVBQStCO0FBQzNCLG9CQUFJLGFBQWEsY0FBYixDQUE0QixJQUE1QixDQUFKLEVBQXVDO0FBQ25DLDRCQUFRLElBQVIsSUFBZ0IsYUFBYSxJQUFiLENBQWhCO0FBQ0g7QUFDSjtBQUNKO0FBQ0QsYUFBSyxPQUFMLEdBQWUsT0FBZjtBQUNIO0FBQ0QsbUJBQWUsU0FBZixDQUF5QixVQUF6QixHQUFzQyxVQUFVLFVBQVYsRUFBc0I7QUFDeEQsZUFBTyxJQUFJLGNBQUosQ0FBbUIsVUFBbkIsRUFBK0IsS0FBSyxPQUFwQyxDQUFQO0FBQ0gsS0FGRDtBQUdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCQSxtQkFBZSxNQUFmLEdBQXlCLFlBQVk7QUFDakMsWUFBSSxTQUFTLFNBQVQsTUFBUyxDQUFVLFlBQVYsRUFBd0I7QUFDakMsbUJBQU8sSUFBSSxjQUFKLENBQW1CLFlBQW5CLENBQVA7QUFDSCxTQUZEO0FBR0EsZUFBTyxHQUFQLEdBQWEsT0FBYjtBQUNBLGVBQU8sSUFBUCxHQUFjLFFBQWQ7QUFDQSxlQUFPLE1BQVAsR0FBZ0IsVUFBaEI7QUFDQSxlQUFPLEdBQVAsR0FBYSxPQUFiO0FBQ0EsZUFBTyxLQUFQLEdBQWUsU0FBZjtBQUNBLGVBQU8sT0FBUCxHQUFpQixXQUFqQjtBQUNBLGVBQU8sTUFBUDtBQUNILEtBWHVCLEVBQXhCO0FBWUEsV0FBTyxjQUFQO0FBQ0gsQ0F0RXFCLENBc0VwQixhQUFhLFVBdEVPLENBQXRCO0FBdUVBLFFBQVEsY0FBUixHQUF5QixjQUF6QjtBQUNBOzs7OztBQUtBLElBQUksaUJBQWtCLFVBQVUsTUFBVixFQUFrQjtBQUNwQyxjQUFVLGNBQVYsRUFBMEIsTUFBMUI7QUFDQSxhQUFTLGNBQVQsQ0FBd0IsV0FBeEIsRUFBcUMsT0FBckMsRUFBOEM7QUFDMUMsZUFBTyxJQUFQLENBQVksSUFBWixFQUFrQixXQUFsQjtBQUNBLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxhQUFLLElBQUwsR0FBWSxLQUFaO0FBQ0EsWUFBSSxVQUFVLFFBQVEsT0FBUixHQUFrQixRQUFRLE9BQVIsSUFBbUIsRUFBbkQ7QUFDQTtBQUNBLFlBQUksQ0FBQyxRQUFRLFdBQVQsSUFBd0IsQ0FBQyxRQUFRLGtCQUFSLENBQTdCLEVBQTBEO0FBQ3RELG9CQUFRLGtCQUFSLElBQThCLGdCQUE5QjtBQUNIO0FBQ0Q7QUFDQSxZQUFJLEVBQUUsa0JBQWtCLE9BQXBCLEtBQWdDLEVBQUUsT0FBTyxJQUFQLENBQVksUUFBWixJQUF3QixRQUFRLElBQVIsWUFBd0IsT0FBTyxJQUFQLENBQVksUUFBOUQsQ0FBaEMsSUFBMkcsT0FBTyxRQUFRLElBQWYsS0FBd0IsV0FBdkksRUFBb0o7QUFDaEosb0JBQVEsY0FBUixJQUEwQixrREFBMUI7QUFDSDtBQUNEO0FBQ0EsZ0JBQVEsSUFBUixHQUFlLEtBQUssYUFBTCxDQUFtQixRQUFRLElBQTNCLEVBQWlDLFFBQVEsT0FBUixDQUFnQixjQUFoQixDQUFqQyxDQUFmO0FBQ0EsYUFBSyxJQUFMO0FBQ0g7QUFDRCxtQkFBZSxTQUFmLENBQXlCLElBQXpCLEdBQWdDLFVBQVUsQ0FBVixFQUFhO0FBQ3pDLGFBQUssSUFBTCxHQUFZLElBQVo7QUFDQSxZQUFJLEtBQUssSUFBVDtBQUFBLFlBQWUsTUFBTSxHQUFHLEdBQXhCO0FBQUEsWUFBNkIsVUFBVSxHQUFHLE9BQTFDO0FBQUEsWUFBbUQsY0FBYyxHQUFHLFdBQXBFO0FBQ0EsWUFBSSxXQUFXLElBQUksWUFBSixDQUFpQixDQUFqQixFQUFvQixHQUFwQixFQUF5QixPQUF6QixDQUFmO0FBQ0Esb0JBQVksSUFBWixDQUFpQixRQUFqQjtBQUNILEtBTEQ7QUFNQSxtQkFBZSxTQUFmLENBQXlCLElBQXpCLEdBQWdDLFlBQVk7QUFDeEMsWUFBSSxLQUFLLElBQVQ7QUFBQSxZQUFlLFVBQVUsR0FBRyxPQUE1QjtBQUFBLFlBQXFDLEtBQUssR0FBRyxPQUE3QztBQUFBLFlBQXNELE9BQU8sR0FBRyxJQUFoRTtBQUFBLFlBQXNFLFNBQVMsR0FBRyxNQUFsRjtBQUFBLFlBQTBGLE1BQU0sR0FBRyxHQUFuRztBQUFBLFlBQXdHLFFBQVEsR0FBRyxLQUFuSDtBQUFBLFlBQTBILFdBQVcsR0FBRyxRQUF4STtBQUFBLFlBQWtKLFVBQVUsR0FBRyxPQUEvSjtBQUFBLFlBQXdLLE9BQU8sR0FBRyxJQUFsTDtBQUNBLFlBQUksWUFBWSxRQUFRLFNBQXhCO0FBQ0EsWUFBSSxNQUFNLFdBQVcsUUFBWCxDQUFvQixTQUFwQixFQUErQixJQUEvQixDQUFvQyxPQUFwQyxDQUFWO0FBQ0EsWUFBSSxRQUFRLGNBQWMsV0FBMUIsRUFBdUM7QUFDbkMsaUJBQUssS0FBTCxDQUFXLGNBQWMsV0FBZCxDQUEwQixDQUFyQztBQUNILFNBRkQsTUFHSztBQUNELGlCQUFLLEdBQUwsR0FBVyxHQUFYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBSyxXQUFMLENBQWlCLEdBQWpCLEVBQXNCLE9BQXRCO0FBQ0E7QUFDQSxnQkFBSSxTQUFTLEtBQUssQ0FBbEI7QUFDQSxnQkFBSSxJQUFKLEVBQVU7QUFDTix5QkFBUyxXQUFXLFFBQVgsQ0FBb0IsSUFBSSxJQUF4QixFQUE4QixJQUE5QixDQUFtQyxHQUFuQyxFQUF3QyxNQUF4QyxFQUFnRCxHQUFoRCxFQUFxRCxLQUFyRCxFQUE0RCxJQUE1RCxFQUFrRSxRQUFsRSxDQUFUO0FBQ0gsYUFGRCxNQUdLO0FBQ0QseUJBQVMsV0FBVyxRQUFYLENBQW9CLElBQUksSUFBeEIsRUFBOEIsSUFBOUIsQ0FBbUMsR0FBbkMsRUFBd0MsTUFBeEMsRUFBZ0QsR0FBaEQsRUFBcUQsS0FBckQsQ0FBVDtBQUNIO0FBQ0QsZ0JBQUksV0FBVyxjQUFjLFdBQTdCLEVBQTBDO0FBQ3RDLHFCQUFLLEtBQUwsQ0FBVyxjQUFjLFdBQWQsQ0FBMEIsQ0FBckM7QUFDQSx1QkFBTyxJQUFQO0FBQ0g7QUFDRDtBQUNBLGdCQUFJLE9BQUosR0FBYyxRQUFRLE9BQXRCO0FBQ0EsZ0JBQUksWUFBSixHQUFtQixRQUFRLFlBQTNCO0FBQ0EsZ0JBQUkscUJBQXFCLEdBQXpCLEVBQThCO0FBQzFCLG9CQUFJLGVBQUosR0FBc0IsQ0FBQyxDQUFDLFFBQVEsZUFBaEM7QUFDSDtBQUNEO0FBQ0EsaUJBQUssVUFBTCxDQUFnQixHQUFoQixFQUFxQixPQUFyQjtBQUNBO0FBQ0EscUJBQVMsT0FBTyxXQUFXLFFBQVgsQ0FBb0IsSUFBSSxJQUF4QixFQUE4QixJQUE5QixDQUFtQyxHQUFuQyxFQUF3QyxJQUF4QyxDQUFQLEdBQXVELFdBQVcsUUFBWCxDQUFvQixJQUFJLElBQXhCLEVBQThCLElBQTlCLENBQW1DLEdBQW5DLENBQWhFO0FBQ0EsZ0JBQUksV0FBVyxjQUFjLFdBQTdCLEVBQTBDO0FBQ3RDLHFCQUFLLEtBQUwsQ0FBVyxjQUFjLFdBQWQsQ0FBMEIsQ0FBckM7QUFDQSx1QkFBTyxJQUFQO0FBQ0g7QUFDSjtBQUNELGVBQU8sR0FBUDtBQUNILEtBMUNEO0FBMkNBLG1CQUFlLFNBQWYsQ0FBeUIsYUFBekIsR0FBeUMsVUFBVSxJQUFWLEVBQWdCLFdBQWhCLEVBQTZCO0FBQ2xFLFlBQUksQ0FBQyxJQUFELElBQVMsT0FBTyxJQUFQLEtBQWdCLFFBQTdCLEVBQXVDO0FBQ25DLG1CQUFPLElBQVA7QUFDSCxTQUZELE1BR0ssSUFBSSxPQUFPLElBQVAsQ0FBWSxRQUFaLElBQXdCLGdCQUFnQixPQUFPLElBQVAsQ0FBWSxRQUF4RCxFQUFrRTtBQUNuRSxtQkFBTyxJQUFQO0FBQ0g7QUFDRCxZQUFJLFdBQUosRUFBaUI7QUFDYixnQkFBSSxhQUFhLFlBQVksT0FBWixDQUFvQixHQUFwQixDQUFqQjtBQUNBLGdCQUFJLGVBQWUsQ0FBQyxDQUFwQixFQUF1QjtBQUNuQiw4QkFBYyxZQUFZLFNBQVosQ0FBc0IsQ0FBdEIsRUFBeUIsVUFBekIsQ0FBZDtBQUNIO0FBQ0o7QUFDRCxnQkFBUSxXQUFSO0FBQ0ksaUJBQUssbUNBQUw7QUFDSSx1QkFBTyxPQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLEdBQWxCLENBQXNCLFVBQVUsR0FBVixFQUFlO0FBQUUsMkJBQVEsVUFBVSxHQUFWLElBQWlCLEdBQWpCLEdBQXVCLFVBQVUsS0FBSyxHQUFMLENBQVYsQ0FBL0I7QUFBdUQsaUJBQTlGLEVBQWdHLElBQWhHLENBQXFHLEdBQXJHLENBQVA7QUFDSixpQkFBSyxrQkFBTDtBQUNJLHVCQUFPLEtBQUssU0FBTCxDQUFlLElBQWYsQ0FBUDtBQUNKO0FBQ0ksdUJBQU8sSUFBUDtBQU5SO0FBUUgsS0FyQkQ7QUFzQkEsbUJBQWUsU0FBZixDQUF5QixVQUF6QixHQUFzQyxVQUFVLEdBQVYsRUFBZSxPQUFmLEVBQXdCO0FBQzFELGFBQUssSUFBSSxHQUFULElBQWdCLE9BQWhCLEVBQXlCO0FBQ3JCLGdCQUFJLFFBQVEsY0FBUixDQUF1QixHQUF2QixDQUFKLEVBQWlDO0FBQzdCLG9CQUFJLGdCQUFKLENBQXFCLEdBQXJCLEVBQTBCLFFBQVEsR0FBUixDQUExQjtBQUNIO0FBQ0o7QUFDSixLQU5EO0FBT0EsbUJBQWUsU0FBZixDQUF5QixXQUF6QixHQUF1QyxVQUFVLEdBQVYsRUFBZSxPQUFmLEVBQXdCO0FBQzNELFlBQUkscUJBQXFCLFFBQVEsa0JBQWpDO0FBQ0EsaUJBQVMsVUFBVCxDQUFvQixDQUFwQixFQUF1QjtBQUNuQixnQkFBSSxLQUFLLFVBQVQ7QUFBQSxnQkFBcUIsYUFBYSxHQUFHLFVBQXJDO0FBQUEsZ0JBQWlELHFCQUFxQixHQUFHLGtCQUF6RTtBQUFBLGdCQUE2RixVQUFVLEdBQUcsT0FBMUc7QUFDQSxnQkFBSSxrQkFBSixFQUF3QjtBQUNwQixtQ0FBbUIsS0FBbkIsQ0FBeUIsQ0FBekI7QUFDSDtBQUNELHVCQUFXLEtBQVgsQ0FBaUIsSUFBSSxnQkFBSixDQUFxQixJQUFyQixFQUEyQixPQUEzQixDQUFqQixFQUxtQixDQUtvQztBQUMxRDtBQUNEO0FBQ0EsWUFBSSxTQUFKLEdBQWdCLFVBQWhCO0FBQ0EsbUJBQVcsT0FBWCxHQUFxQixPQUFyQjtBQUNBLG1CQUFXLFVBQVgsR0FBd0IsSUFBeEI7QUFDQSxtQkFBVyxrQkFBWCxHQUFnQyxrQkFBaEM7QUFDQSxZQUFJLElBQUksTUFBSixJQUFjLHFCQUFxQixHQUF2QyxFQUE0QztBQUN4QyxnQkFBSSxrQkFBSixFQUF3QjtBQUNwQixvQkFBSSxhQUFKO0FBQ0EsZ0NBQWdCLHVCQUFVLENBQVYsRUFBYTtBQUN6Qix3QkFBSSxxQkFBcUIsY0FBYyxrQkFBdkM7QUFDQSx1Q0FBbUIsSUFBbkIsQ0FBd0IsQ0FBeEI7QUFDSCxpQkFIRDtBQUlBLG9CQUFJLE9BQU8sSUFBUCxDQUFZLGNBQWhCLEVBQWdDO0FBQzVCLHdCQUFJLFVBQUosR0FBaUIsYUFBakI7QUFDSCxpQkFGRCxNQUdLO0FBQ0Qsd0JBQUksTUFBSixDQUFXLFVBQVgsR0FBd0IsYUFBeEI7QUFDSDtBQUNELDhCQUFjLGtCQUFkLEdBQW1DLGtCQUFuQztBQUNIO0FBQ0QsZ0JBQUksVUFBSjtBQUNBLHlCQUFhLG9CQUFVLENBQVYsRUFBYTtBQUN0QixvQkFBSSxLQUFLLFVBQVQ7QUFBQSxvQkFBcUIscUJBQXFCLEdBQUcsa0JBQTdDO0FBQUEsb0JBQWlFLGFBQWEsR0FBRyxVQUFqRjtBQUFBLG9CQUE2RixVQUFVLEdBQUcsT0FBMUc7QUFDQSxvQkFBSSxrQkFBSixFQUF3QjtBQUNwQix1Q0FBbUIsS0FBbkIsQ0FBeUIsQ0FBekI7QUFDSDtBQUNELDJCQUFXLEtBQVgsQ0FBaUIsSUFBSSxTQUFKLENBQWMsWUFBZCxFQUE0QixJQUE1QixFQUFrQyxPQUFsQyxDQUFqQjtBQUNILGFBTkQ7QUFPQSxnQkFBSSxPQUFKLEdBQWMsVUFBZDtBQUNBLHVCQUFXLE9BQVgsR0FBcUIsT0FBckI7QUFDQSx1QkFBVyxVQUFYLEdBQXdCLElBQXhCO0FBQ0EsdUJBQVcsa0JBQVgsR0FBZ0Msa0JBQWhDO0FBQ0g7QUFDRCxpQkFBUyxtQkFBVCxDQUE2QixDQUE3QixFQUFnQztBQUM1QixnQkFBSSxLQUFLLG1CQUFUO0FBQUEsZ0JBQThCLGFBQWEsR0FBRyxVQUE5QztBQUFBLGdCQUEwRCxxQkFBcUIsR0FBRyxrQkFBbEY7QUFBQSxnQkFBc0csVUFBVSxHQUFHLE9BQW5IO0FBQ0EsZ0JBQUksS0FBSyxVQUFMLEtBQW9CLENBQXhCLEVBQTJCO0FBQ3ZCO0FBQ0Esb0JBQUksV0FBVyxLQUFLLE1BQUwsS0FBZ0IsSUFBaEIsR0FBdUIsR0FBdkIsR0FBNkIsS0FBSyxNQUFqRDtBQUNBLG9CQUFJLFdBQVksS0FBSyxZQUFMLEtBQXNCLE1BQXRCLEdBQWdDLEtBQUssUUFBTCxJQUFpQixLQUFLLFlBQXRELEdBQXNFLEtBQUssUUFBM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBSSxhQUFhLENBQWpCLEVBQW9CO0FBQ2hCLCtCQUFXLFdBQVcsR0FBWCxHQUFpQixDQUE1QjtBQUNIO0FBQ0Qsb0JBQUksT0FBTyxRQUFQLElBQW1CLFdBQVcsR0FBbEMsRUFBdUM7QUFDbkMsd0JBQUksa0JBQUosRUFBd0I7QUFDcEIsMkNBQW1CLFFBQW5CO0FBQ0g7QUFDRCwrQkFBVyxJQUFYLENBQWdCLENBQWhCO0FBQ0EsK0JBQVcsUUFBWDtBQUNILGlCQU5ELE1BT0s7QUFDRCx3QkFBSSxrQkFBSixFQUF3QjtBQUNwQiwyQ0FBbUIsS0FBbkIsQ0FBeUIsQ0FBekI7QUFDSDtBQUNELCtCQUFXLEtBQVgsQ0FBaUIsSUFBSSxTQUFKLENBQWMsZ0JBQWdCLFFBQTlCLEVBQXdDLElBQXhDLEVBQThDLE9BQTlDLENBQWpCO0FBQ0g7QUFDSjtBQUNKO0FBQ0Q7QUFDQSxZQUFJLGtCQUFKLEdBQXlCLG1CQUF6QjtBQUNBLDRCQUFvQixVQUFwQixHQUFpQyxJQUFqQztBQUNBLDRCQUFvQixrQkFBcEIsR0FBeUMsa0JBQXpDO0FBQ0EsNEJBQW9CLE9BQXBCLEdBQThCLE9BQTlCO0FBQ0gsS0ExRUQ7QUEyRUEsbUJBQWUsU0FBZixDQUF5QixXQUF6QixHQUF1QyxZQUFZO0FBQy9DLFlBQUksS0FBSyxJQUFUO0FBQUEsWUFBZSxPQUFPLEdBQUcsSUFBekI7QUFBQSxZQUErQixNQUFNLEdBQUcsR0FBeEM7QUFDQSxZQUFJLENBQUMsSUFBRCxJQUFTLEdBQVQsSUFBZ0IsSUFBSSxVQUFKLEtBQW1CLENBQW5DLElBQXdDLE9BQU8sSUFBSSxLQUFYLEtBQXFCLFVBQWpFLEVBQTZFO0FBQ3pFLGdCQUFJLEtBQUo7QUFDSDtBQUNELGVBQU8sU0FBUCxDQUFpQixXQUFqQixDQUE2QixJQUE3QixDQUFrQyxJQUFsQztBQUNILEtBTkQ7QUFPQSxXQUFPLGNBQVA7QUFDSCxDQXBMcUIsQ0FvTHBCLGFBQWEsVUFwTE8sQ0FBdEI7QUFxTEEsUUFBUSxjQUFSLEdBQXlCLGNBQXpCO0FBQ0E7Ozs7Ozs7QUFPQSxJQUFJLGVBQWdCLFlBQVk7QUFDNUIsYUFBUyxZQUFULENBQXNCLGFBQXRCLEVBQXFDLEdBQXJDLEVBQTBDLE9BQTFDLEVBQW1EO0FBQy9DLGFBQUssYUFBTCxHQUFxQixhQUFyQjtBQUNBLGFBQUssR0FBTCxHQUFXLEdBQVg7QUFDQSxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsYUFBSyxNQUFMLEdBQWMsSUFBSSxNQUFsQjtBQUNBLGFBQUssWUFBTCxHQUFvQixJQUFJLFlBQUosSUFBb0IsUUFBUSxZQUFoRDtBQUNBLGdCQUFRLEtBQUssWUFBYjtBQUNJLGlCQUFLLE1BQUw7QUFDSSxvQkFBSSxjQUFjLEdBQWxCLEVBQXVCO0FBQ25CO0FBQ0EseUJBQUssUUFBTCxHQUFnQixJQUFJLFlBQUosR0FBbUIsSUFBSSxRQUF2QixHQUFrQyxLQUFLLEtBQUwsQ0FBVyxJQUFJLFFBQUosSUFBZ0IsSUFBSSxZQUFwQixJQUFvQyxNQUEvQyxDQUFsRDtBQUNILGlCQUhELE1BSUs7QUFDRCx5QkFBSyxRQUFMLEdBQWdCLEtBQUssS0FBTCxDQUFXLElBQUksWUFBSixJQUFvQixNQUEvQixDQUFoQjtBQUNIO0FBQ0Q7QUFDSixpQkFBSyxLQUFMO0FBQ0kscUJBQUssUUFBTCxHQUFnQixJQUFJLFdBQXBCO0FBQ0E7QUFDSixpQkFBSyxNQUFMO0FBQ0E7QUFDSSxxQkFBSyxRQUFMLEdBQWlCLGNBQWMsR0FBZixHQUFzQixJQUFJLFFBQTFCLEdBQXFDLElBQUksWUFBekQ7QUFDQTtBQWhCUjtBQWtCSDtBQUNELFdBQU8sWUFBUDtBQUNILENBM0JtQixFQUFwQjtBQTRCQSxRQUFRLFlBQVIsR0FBdUIsWUFBdkI7QUFDQTs7Ozs7OztBQU9BLElBQUksWUFBYSxVQUFVLE1BQVYsRUFBa0I7QUFDL0IsY0FBVSxTQUFWLEVBQXFCLE1BQXJCO0FBQ0EsYUFBUyxTQUFULENBQW1CLE9BQW5CLEVBQTRCLEdBQTVCLEVBQWlDLE9BQWpDLEVBQTBDO0FBQ3RDLGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsT0FBbEI7QUFDQSxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsYUFBSyxHQUFMLEdBQVcsR0FBWDtBQUNBLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxhQUFLLE1BQUwsR0FBYyxJQUFJLE1BQWxCO0FBQ0g7QUFDRCxXQUFPLFNBQVA7QUFDSCxDQVZnQixDQVVmLEtBVmUsQ0FBakI7QUFXQSxRQUFRLFNBQVIsR0FBb0IsU0FBcEI7QUFDQTs7Ozs7QUFLQSxJQUFJLG1CQUFvQixVQUFVLE1BQVYsRUFBa0I7QUFDdEMsY0FBVSxnQkFBVixFQUE0QixNQUE1QjtBQUNBLGFBQVMsZ0JBQVQsQ0FBMEIsR0FBMUIsRUFBK0IsT0FBL0IsRUFBd0M7QUFDcEMsZUFBTyxJQUFQLENBQVksSUFBWixFQUFrQixjQUFsQixFQUFrQyxHQUFsQyxFQUF1QyxPQUF2QztBQUNIO0FBQ0QsV0FBTyxnQkFBUDtBQUNILENBTnVCLENBTXRCLFNBTnNCLENBQXhCO0FBT0EsUUFBUSxnQkFBUixHQUEyQixnQkFBM0I7QUFDQTs7O0FDNVpBOztBQUNBLElBQUksbUJBQW1CLFFBQVEsa0JBQVIsQ0FBdkI7QUFDQSxRQUFRLElBQVIsR0FBZSxpQkFBaUIsY0FBakIsQ0FBZ0MsTUFBL0M7QUFDQTs7Ozs7QUNIQTs7QUFDQSxJQUFJLFVBQVUsUUFBUSxtQkFBUixDQUFkO0FBQ0EsUUFBUSxLQUFSLEdBQWdCLFFBQVEsV0FBeEI7QUFDQTs7Ozs7QUNIQTs7QUFDQSxJQUFJLG9CQUFvQixRQUFRLG1CQUFSLENBQXhCO0FBQ0EsUUFBUSxNQUFSLEdBQWlCLGtCQUFrQixlQUFsQixDQUFrQyxNQUFuRDtBQUNBOzs7OztBQ0hBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZDtBQUFpQixZQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxvQkFBb0IsUUFBUSxvQkFBUixDQUF4QjtBQUNBLElBQUksc0JBQXNCLFFBQVEsMkJBQVIsQ0FBMUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyREEsU0FBUyxNQUFULENBQWdCLFFBQWhCLEVBQTBCO0FBQ3RCLFFBQUksV0FBVyxJQUFJLGFBQUosQ0FBa0IsUUFBbEIsQ0FBZjtBQUNBLFFBQUksU0FBUyxLQUFLLElBQUwsQ0FBVSxRQUFWLENBQWI7QUFDQSxXQUFRLFNBQVMsTUFBVCxHQUFrQixNQUExQjtBQUNIO0FBQ0QsUUFBUSxNQUFSLEdBQWlCLE1BQWpCO0FBQ0EsSUFBSSxnQkFBaUIsWUFBWTtBQUM3QixhQUFTLGFBQVQsQ0FBdUIsUUFBdkIsRUFBaUM7QUFDN0IsYUFBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0g7QUFDRCxrQkFBYyxTQUFkLENBQXdCLElBQXhCLEdBQStCLFVBQVUsVUFBVixFQUFzQixNQUF0QixFQUE4QjtBQUN6RCxlQUFPLE9BQU8sU0FBUCxDQUFpQixJQUFJLGVBQUosQ0FBb0IsVUFBcEIsRUFBZ0MsS0FBSyxRQUFyQyxFQUErQyxLQUFLLE1BQXBELENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxhQUFQO0FBQ0gsQ0FSb0IsRUFBckI7QUFTQTs7Ozs7QUFLQSxJQUFJLGtCQUFtQixVQUFVLE1BQVYsRUFBa0I7QUFDckMsY0FBVSxlQUFWLEVBQTJCLE1BQTNCO0FBQ0EsYUFBUyxlQUFULENBQXlCLFdBQXpCLEVBQXNDLFFBQXRDLEVBQWdELE1BQWhELEVBQXdEO0FBQ3BELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxhQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQWdCLFNBQWhCLENBQTBCLEtBQTFCLEdBQWtDLFVBQVUsR0FBVixFQUFlO0FBQzdDLFlBQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUI7QUFDakIsZ0JBQUksU0FBUyxLQUFLLENBQWxCO0FBQ0EsZ0JBQUk7QUFDQSx5QkFBUyxLQUFLLFFBQUwsQ0FBYyxHQUFkLEVBQW1CLEtBQUssTUFBeEIsQ0FBVDtBQUNILGFBRkQsQ0FHQSxPQUFPLElBQVAsRUFBYTtBQUNULHVCQUFPLFNBQVAsQ0FBaUIsS0FBakIsQ0FBdUIsSUFBdkIsQ0FBNEIsSUFBNUIsRUFBa0MsSUFBbEM7QUFDQTtBQUNIO0FBQ0QsaUJBQUssc0JBQUw7QUFDQSxpQkFBSyxHQUFMLENBQVMsb0JBQW9CLGlCQUFwQixDQUFzQyxJQUF0QyxFQUE0QyxNQUE1QyxDQUFUO0FBQ0g7QUFDSixLQWJEO0FBY0EsV0FBTyxlQUFQO0FBQ0gsQ0EzQnNCLENBMkJyQixrQkFBa0IsZUEzQkcsQ0FBdkI7QUE0QkE7Ozs7O0FDbkhBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZDtBQUFpQixZQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxlQUFlLFFBQVEsZUFBUixDQUFuQjtBQUNBLElBQUksVUFBVSxRQUFRLG9CQUFSLENBQWQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThDQSxTQUFTLFlBQVQsQ0FBc0IsT0FBdEIsRUFBK0IsU0FBL0IsRUFBMEM7QUFDdEMsUUFBSSxjQUFjLEtBQUssQ0FBdkIsRUFBMEI7QUFBRSxvQkFBWSxRQUFRLEtBQXBCO0FBQTRCO0FBQ3hELFdBQU8sS0FBSyxJQUFMLENBQVUsSUFBSSxvQkFBSixDQUF5QixPQUF6QixFQUFrQyxTQUFsQyxDQUFWLENBQVA7QUFDSDtBQUNELFFBQVEsWUFBUixHQUF1QixZQUF2QjtBQUNBLElBQUksdUJBQXdCLFlBQVk7QUFDcEMsYUFBUyxvQkFBVCxDQUE4QixPQUE5QixFQUF1QyxTQUF2QyxFQUFrRDtBQUM5QyxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0g7QUFDRCx5QkFBcUIsU0FBckIsQ0FBK0IsSUFBL0IsR0FBc0MsVUFBVSxVQUFWLEVBQXNCLE1BQXRCLEVBQThCO0FBQ2hFLGVBQU8sT0FBTyxTQUFQLENBQWlCLElBQUksc0JBQUosQ0FBMkIsVUFBM0IsRUFBdUMsS0FBSyxPQUE1QyxFQUFxRCxLQUFLLFNBQTFELENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxvQkFBUDtBQUNILENBVDJCLEVBQTVCO0FBVUE7Ozs7O0FBS0EsSUFBSSx5QkFBMEIsVUFBVSxNQUFWLEVBQWtCO0FBQzVDLGNBQVUsc0JBQVYsRUFBa0MsTUFBbEM7QUFDQSxhQUFTLHNCQUFULENBQWdDLFdBQWhDLEVBQTZDLE9BQTdDLEVBQXNELFNBQXRELEVBQWlFO0FBQzdELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0EsYUFBSyxxQkFBTCxHQUE2QixJQUE3QjtBQUNBLGFBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNBLGFBQUssUUFBTCxHQUFnQixLQUFoQjtBQUNIO0FBQ0QsMkJBQXVCLFNBQXZCLENBQWlDLEtBQWpDLEdBQXlDLFVBQVUsS0FBVixFQUFpQjtBQUN0RCxhQUFLLGFBQUw7QUFDQSxhQUFLLFNBQUwsR0FBaUIsS0FBakI7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsSUFBaEI7QUFDQSxhQUFLLEdBQUwsQ0FBUyxLQUFLLHFCQUFMLEdBQTZCLEtBQUssU0FBTCxDQUFlLFFBQWYsQ0FBd0IsWUFBeEIsRUFBc0MsS0FBSyxPQUEzQyxFQUFvRCxJQUFwRCxDQUF0QztBQUNILEtBTEQ7QUFNQSwyQkFBdUIsU0FBdkIsQ0FBaUMsU0FBakMsR0FBNkMsWUFBWTtBQUNyRCxhQUFLLGFBQUw7QUFDQSxhQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDSCxLQUhEO0FBSUEsMkJBQXVCLFNBQXZCLENBQWlDLGFBQWpDLEdBQWlELFlBQVk7QUFDekQsYUFBSyxhQUFMO0FBQ0EsWUFBSSxLQUFLLFFBQVQsRUFBbUI7QUFDZixpQkFBSyxXQUFMLENBQWlCLElBQWpCLENBQXNCLEtBQUssU0FBM0I7QUFDQSxpQkFBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsaUJBQUssUUFBTCxHQUFnQixLQUFoQjtBQUNIO0FBQ0osS0FQRDtBQVFBLDJCQUF1QixTQUF2QixDQUFpQyxhQUFqQyxHQUFpRCxZQUFZO0FBQ3pELFlBQUksd0JBQXdCLEtBQUsscUJBQWpDO0FBQ0EsWUFBSSwwQkFBMEIsSUFBOUIsRUFBb0M7QUFDaEMsaUJBQUssTUFBTCxDQUFZLHFCQUFaO0FBQ0Esa0NBQXNCLFdBQXRCO0FBQ0EsaUJBQUsscUJBQUwsR0FBNkIsSUFBN0I7QUFDSDtBQUNKLEtBUEQ7QUFRQSxXQUFPLHNCQUFQO0FBQ0gsQ0FyQzZCLENBcUM1QixhQUFhLFVBckNlLENBQTlCO0FBc0NBLFNBQVMsWUFBVCxDQUFzQixVQUF0QixFQUFrQztBQUM5QixlQUFXLGFBQVg7QUFDSDtBQUNEOzs7QUNuSEE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLFVBQVUsUUFBUSxvQkFBUixDQUFkO0FBQ0EsSUFBSSxXQUFXLFFBQVEsZ0JBQVIsQ0FBZjtBQUNBLElBQUksZUFBZSxRQUFRLGVBQVIsQ0FBbkI7QUFDQSxJQUFJLGlCQUFpQixRQUFRLGlCQUFSLENBQXJCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVDQSxTQUFTLEtBQVQsQ0FBZSxLQUFmLEVBQXNCLFNBQXRCLEVBQWlDO0FBQzdCLFFBQUksY0FBYyxLQUFLLENBQXZCLEVBQTBCO0FBQUUsb0JBQVksUUFBUSxLQUFwQjtBQUE0QjtBQUN4RCxRQUFJLGdCQUFnQixTQUFTLE1BQVQsQ0FBZ0IsS0FBaEIsQ0FBcEI7QUFDQSxRQUFJLFdBQVcsZ0JBQWlCLENBQUMsS0FBRCxHQUFTLFVBQVUsR0FBVixFQUExQixHQUE2QyxLQUFLLEdBQUwsQ0FBUyxLQUFULENBQTVEO0FBQ0EsV0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFJLGFBQUosQ0FBa0IsUUFBbEIsRUFBNEIsU0FBNUIsQ0FBVixDQUFQO0FBQ0g7QUFDRCxRQUFRLEtBQVIsR0FBZ0IsS0FBaEI7QUFDQSxJQUFJLGdCQUFpQixZQUFZO0FBQzdCLGFBQVMsYUFBVCxDQUF1QixLQUF2QixFQUE4QixTQUE5QixFQUF5QztBQUNyQyxhQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0g7QUFDRCxrQkFBYyxTQUFkLENBQXdCLElBQXhCLEdBQStCLFVBQVUsVUFBVixFQUFzQixNQUF0QixFQUE4QjtBQUN6RCxlQUFPLE9BQU8sU0FBUCxDQUFpQixJQUFJLGVBQUosQ0FBb0IsVUFBcEIsRUFBZ0MsS0FBSyxLQUFyQyxFQUE0QyxLQUFLLFNBQWpELENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxhQUFQO0FBQ0gsQ0FUb0IsRUFBckI7QUFVQTs7Ozs7QUFLQSxJQUFJLGtCQUFtQixVQUFVLE1BQVYsRUFBa0I7QUFDckMsY0FBVSxlQUFWLEVBQTJCLE1BQTNCO0FBQ0EsYUFBUyxlQUFULENBQXlCLFdBQXpCLEVBQXNDLEtBQXRDLEVBQTZDLFNBQTdDLEVBQXdEO0FBQ3BELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsRUFBYjtBQUNBLGFBQUssTUFBTCxHQUFjLEtBQWQ7QUFDQSxhQUFLLE9BQUwsR0FBZSxLQUFmO0FBQ0g7QUFDRCxvQkFBZ0IsUUFBaEIsR0FBMkIsVUFBVSxLQUFWLEVBQWlCO0FBQ3hDLFlBQUksU0FBUyxNQUFNLE1BQW5CO0FBQ0EsWUFBSSxRQUFRLE9BQU8sS0FBbkI7QUFDQSxZQUFJLFlBQVksTUFBTSxTQUF0QjtBQUNBLFlBQUksY0FBYyxNQUFNLFdBQXhCO0FBQ0EsZUFBTyxNQUFNLE1BQU4sR0FBZSxDQUFmLElBQXFCLE1BQU0sQ0FBTixFQUFTLElBQVQsR0FBZ0IsVUFBVSxHQUFWLEVBQWpCLElBQXFDLENBQWhFLEVBQW1FO0FBQy9ELGtCQUFNLEtBQU4sR0FBYyxZQUFkLENBQTJCLE9BQTNCLENBQW1DLFdBQW5DO0FBQ0g7QUFDRCxZQUFJLE1BQU0sTUFBTixHQUFlLENBQW5CLEVBQXNCO0FBQ2xCLGdCQUFJLFVBQVUsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLE1BQU0sQ0FBTixFQUFTLElBQVQsR0FBZ0IsVUFBVSxHQUFWLEVBQTVCLENBQWQ7QUFDQSxpQkFBSyxRQUFMLENBQWMsS0FBZCxFQUFxQixPQUFyQjtBQUNILFNBSEQsTUFJSztBQUNELG1CQUFPLE1BQVAsR0FBZ0IsS0FBaEI7QUFDSDtBQUNKLEtBZkQ7QUFnQkEsb0JBQWdCLFNBQWhCLENBQTBCLFNBQTFCLEdBQXNDLFVBQVUsU0FBVixFQUFxQjtBQUN2RCxhQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0EsYUFBSyxHQUFMLENBQVMsVUFBVSxRQUFWLENBQW1CLGdCQUFnQixRQUFuQyxFQUE2QyxLQUFLLEtBQWxELEVBQXlEO0FBQzlELG9CQUFRLElBRHNELEVBQ2hELGFBQWEsS0FBSyxXQUQ4QixFQUNqQixXQUFXO0FBRE0sU0FBekQsQ0FBVDtBQUdILEtBTEQ7QUFNQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsb0JBQTFCLEdBQWlELFVBQVUsWUFBVixFQUF3QjtBQUNyRSxZQUFJLEtBQUssT0FBTCxLQUFpQixJQUFyQixFQUEyQjtBQUN2QjtBQUNIO0FBQ0QsWUFBSSxZQUFZLEtBQUssU0FBckI7QUFDQSxZQUFJLFVBQVUsSUFBSSxZQUFKLENBQWlCLFVBQVUsR0FBVixLQUFrQixLQUFLLEtBQXhDLEVBQStDLFlBQS9DLENBQWQ7QUFDQSxhQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLE9BQWhCO0FBQ0EsWUFBSSxLQUFLLE1BQUwsS0FBZ0IsS0FBcEIsRUFBMkI7QUFDdkIsaUJBQUssU0FBTCxDQUFlLFNBQWY7QUFDSDtBQUNKLEtBVkQ7QUFXQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsS0FBMUIsR0FBa0MsVUFBVSxLQUFWLEVBQWlCO0FBQy9DLGFBQUssb0JBQUwsQ0FBMEIsZUFBZSxZQUFmLENBQTRCLFVBQTVCLENBQXVDLEtBQXZDLENBQTFCO0FBQ0gsS0FGRDtBQUdBLG9CQUFnQixTQUFoQixDQUEwQixNQUExQixHQUFtQyxVQUFVLEdBQVYsRUFBZTtBQUM5QyxhQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0EsYUFBSyxLQUFMLEdBQWEsRUFBYjtBQUNBLGFBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixHQUF2QjtBQUNILEtBSkQ7QUFLQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsU0FBMUIsR0FBc0MsWUFBWTtBQUM5QyxhQUFLLG9CQUFMLENBQTBCLGVBQWUsWUFBZixDQUE0QixjQUE1QixFQUExQjtBQUNILEtBRkQ7QUFHQSxXQUFPLGVBQVA7QUFDSCxDQXZEc0IsQ0F1RHJCLGFBQWEsVUF2RFEsQ0FBdkI7QUF3REEsSUFBSSxlQUFnQixZQUFZO0FBQzVCLGFBQVMsWUFBVCxDQUFzQixJQUF0QixFQUE0QixZQUE1QixFQUEwQztBQUN0QyxhQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsYUFBSyxZQUFMLEdBQW9CLFlBQXBCO0FBQ0g7QUFDRCxXQUFPLFlBQVA7QUFDSCxDQU5tQixFQUFwQjtBQU9BOzs7QUN0SUE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0EsSUFBSSxhQUFhLFFBQVEsa0JBQVIsQ0FBakI7QUFDQSxJQUFJLGdCQUFnQixRQUFRLHFCQUFSLENBQXBCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBdUNBLFNBQVMsb0JBQVQsQ0FBOEIsT0FBOUIsRUFBdUMsV0FBdkMsRUFBb0Q7QUFDaEQsV0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFJLDRCQUFKLENBQWlDLE9BQWpDLEVBQTBDLFdBQTFDLENBQVYsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxvQkFBUixHQUErQixvQkFBL0I7QUFDQSxJQUFJLCtCQUFnQyxZQUFZO0FBQzVDLGFBQVMsNEJBQVQsQ0FBc0MsT0FBdEMsRUFBK0MsV0FBL0MsRUFBNEQ7QUFDeEQsYUFBSyxPQUFMLEdBQWUsT0FBZjtBQUNBLGFBQUssV0FBTCxHQUFtQixXQUFuQjtBQUNIO0FBQ0QsaUNBQTZCLFNBQTdCLENBQXVDLElBQXZDLEdBQThDLFVBQVUsVUFBVixFQUFzQixNQUF0QixFQUE4QjtBQUN4RSxlQUFPLE9BQU8sU0FBUCxDQUFpQixJQUFJLDhCQUFKLENBQW1DLFVBQW5DLEVBQStDLEtBQUssT0FBcEQsRUFBNkQsS0FBSyxXQUFsRSxDQUFqQixDQUFQO0FBQ0gsS0FGRDtBQUdBLFdBQU8sNEJBQVA7QUFDSCxDQVRtQyxFQUFwQztBQVVBOzs7OztBQUtBLElBQUksaUNBQWtDLFVBQVUsTUFBVixFQUFrQjtBQUNwRCxjQUFVLDhCQUFWLEVBQTBDLE1BQTFDO0FBQ0EsYUFBUyw4QkFBVCxDQUF3QyxXQUF4QyxFQUFxRCxPQUFyRCxFQUE4RCxXQUE5RCxFQUEyRTtBQUN2RSxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0EsYUFBSyxNQUFMLEdBQWMsS0FBZDtBQUNBLFlBQUksT0FBTyxPQUFQLEtBQW1CLFVBQXZCLEVBQW1DO0FBQy9CLGlCQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0g7QUFDSjtBQUNELG1DQUErQixTQUEvQixDQUF5QyxPQUF6QyxHQUFtRCxVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQy9ELGVBQU8sTUFBTSxDQUFiO0FBQ0gsS0FGRDtBQUdBLG1DQUErQixTQUEvQixDQUF5QyxLQUF6QyxHQUFpRCxVQUFVLEtBQVYsRUFBaUI7QUFDOUQsWUFBSSxjQUFjLEtBQUssV0FBdkI7QUFDQSxZQUFJLE1BQU0sS0FBVjtBQUNBLFlBQUksV0FBSixFQUFpQjtBQUNiLGtCQUFNLFdBQVcsUUFBWCxDQUFvQixLQUFLLFdBQXpCLEVBQXNDLEtBQXRDLENBQU47QUFDQSxnQkFBSSxRQUFRLGNBQWMsV0FBMUIsRUFBdUM7QUFDbkMsdUJBQU8sS0FBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLGNBQWMsV0FBZCxDQUEwQixDQUFqRCxDQUFQO0FBQ0g7QUFDSjtBQUNELFlBQUksU0FBUyxLQUFiO0FBQ0EsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYixxQkFBUyxXQUFXLFFBQVgsQ0FBb0IsS0FBSyxPQUF6QixFQUFrQyxLQUFLLEdBQXZDLEVBQTRDLEdBQTVDLENBQVQ7QUFDQSxnQkFBSSxXQUFXLGNBQWMsV0FBN0IsRUFBMEM7QUFDdEMsdUJBQU8sS0FBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLGNBQWMsV0FBZCxDQUEwQixDQUFqRCxDQUFQO0FBQ0g7QUFDSixTQUxELE1BTUs7QUFDRCxpQkFBSyxNQUFMLEdBQWMsSUFBZDtBQUNIO0FBQ0QsWUFBSSxRQUFRLE1BQVIsTUFBb0IsS0FBeEIsRUFBK0I7QUFDM0IsaUJBQUssR0FBTCxHQUFXLEdBQVg7QUFDQSxpQkFBSyxXQUFMLENBQWlCLElBQWpCLENBQXNCLEtBQXRCO0FBQ0g7QUFDSixLQXZCRDtBQXdCQSxXQUFPLDhCQUFQO0FBQ0gsQ0F0Q3FDLENBc0NwQyxhQUFhLFVBdEN1QixDQUF0QztBQXVDQTs7O0FDM0dBOztBQUNBLElBQUkseUJBQXlCLFFBQVEsd0JBQVIsQ0FBN0I7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5REEsU0FBUyx1QkFBVCxDQUFpQyxHQUFqQyxFQUFzQyxPQUF0QyxFQUErQztBQUMzQyxXQUFPLHVCQUF1QixvQkFBdkIsQ0FBNEMsSUFBNUMsQ0FBaUQsSUFBakQsRUFBdUQsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUMxRSxZQUFJLE9BQUosRUFBYTtBQUNULG1CQUFPLFFBQVEsRUFBRSxHQUFGLENBQVIsRUFBZ0IsRUFBRSxHQUFGLENBQWhCLENBQVA7QUFDSDtBQUNELGVBQU8sRUFBRSxHQUFGLE1BQVcsRUFBRSxHQUFGLENBQWxCO0FBQ0gsS0FMTSxDQUFQO0FBTUg7QUFDRCxRQUFRLHVCQUFSLEdBQWtDLHVCQUFsQztBQUNBOzs7QUNyRUE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJDQSxTQUFTLEdBQVQsQ0FBYSxjQUFiLEVBQTZCLEtBQTdCLEVBQW9DLFFBQXBDLEVBQThDO0FBQzFDLFdBQU8sS0FBSyxJQUFMLENBQVUsSUFBSSxVQUFKLENBQWUsY0FBZixFQUErQixLQUEvQixFQUFzQyxRQUF0QyxDQUFWLENBQVA7QUFDSDtBQUNELFFBQVEsR0FBUixHQUFjLEdBQWQ7QUFDQSxJQUFJLGFBQWMsWUFBWTtBQUMxQixhQUFTLFVBQVQsQ0FBb0IsY0FBcEIsRUFBb0MsS0FBcEMsRUFBMkMsUUFBM0MsRUFBcUQ7QUFDakQsYUFBSyxjQUFMLEdBQXNCLGNBQXRCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLGFBQUssUUFBTCxHQUFnQixRQUFoQjtBQUNIO0FBQ0QsZUFBVyxTQUFYLENBQXFCLElBQXJCLEdBQTRCLFVBQVUsVUFBVixFQUFzQixNQUF0QixFQUE4QjtBQUN0RCxlQUFPLE9BQU8sU0FBUCxDQUFpQixJQUFJLFlBQUosQ0FBaUIsVUFBakIsRUFBNkIsS0FBSyxjQUFsQyxFQUFrRCxLQUFLLEtBQXZELEVBQThELEtBQUssUUFBbkUsQ0FBakIsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPLFVBQVA7QUFDSCxDQVZpQixFQUFsQjtBQVdBOzs7OztBQUtBLElBQUksZUFBZ0IsVUFBVSxNQUFWLEVBQWtCO0FBQ2xDLGNBQVUsWUFBVixFQUF3QixNQUF4QjtBQUNBLGFBQVMsWUFBVCxDQUFzQixXQUF0QixFQUFtQyxjQUFuQyxFQUFtRCxLQUFuRCxFQUEwRCxRQUExRCxFQUFvRTtBQUNoRSxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsWUFBSSxpQkFBaUIsSUFBSSxhQUFhLFVBQWpCLENBQTRCLGNBQTVCLEVBQTRDLEtBQTVDLEVBQW1ELFFBQW5ELENBQXJCO0FBQ0EsdUJBQWUsa0JBQWYsR0FBb0MsSUFBcEM7QUFDQSxhQUFLLEdBQUwsQ0FBUyxjQUFUO0FBQ0EsYUFBSyxjQUFMLEdBQXNCLGNBQXRCO0FBQ0g7QUFDRCxpQkFBYSxTQUFiLENBQXVCLEtBQXZCLEdBQStCLFVBQVUsS0FBVixFQUFpQjtBQUM1QyxZQUFJLGlCQUFpQixLQUFLLGNBQTFCO0FBQ0EsdUJBQWUsSUFBZixDQUFvQixLQUFwQjtBQUNBLFlBQUksZUFBZSxlQUFuQixFQUFvQztBQUNoQyxpQkFBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLGVBQWUsY0FBdEM7QUFDSCxTQUZELE1BR0s7QUFDRCxpQkFBSyxXQUFMLENBQWlCLElBQWpCLENBQXNCLEtBQXRCO0FBQ0g7QUFDSixLQVREO0FBVUEsaUJBQWEsU0FBYixDQUF1QixNQUF2QixHQUFnQyxVQUFVLEdBQVYsRUFBZTtBQUMzQyxZQUFJLGlCQUFpQixLQUFLLGNBQTFCO0FBQ0EsdUJBQWUsS0FBZixDQUFxQixHQUFyQjtBQUNBLFlBQUksZUFBZSxlQUFuQixFQUFvQztBQUNoQyxpQkFBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLGVBQWUsY0FBdEM7QUFDSCxTQUZELE1BR0s7QUFDRCxpQkFBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLEdBQXZCO0FBQ0g7QUFDSixLQVREO0FBVUEsaUJBQWEsU0FBYixDQUF1QixTQUF2QixHQUFtQyxZQUFZO0FBQzNDLFlBQUksaUJBQWlCLEtBQUssY0FBMUI7QUFDQSx1QkFBZSxRQUFmO0FBQ0EsWUFBSSxlQUFlLGVBQW5CLEVBQW9DO0FBQ2hDLGlCQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBdUIsZUFBZSxjQUF0QztBQUNILFNBRkQsTUFHSztBQUNELGlCQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDSDtBQUNKLEtBVEQ7QUFVQSxXQUFPLFlBQVA7QUFDSCxDQXhDbUIsQ0F3Q2xCLGFBQWEsVUF4Q0ssQ0FBcEI7QUF5Q0E7OztBQ2hIQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQ7QUFBaUIsWUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksZUFBZSxRQUFRLGVBQVIsQ0FBbkI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q0EsU0FBUyxNQUFULENBQWdCLFNBQWhCLEVBQTJCLE9BQTNCLEVBQW9DO0FBQ2hDLFdBQU8sS0FBSyxJQUFMLENBQVUsSUFBSSxjQUFKLENBQW1CLFNBQW5CLEVBQThCLE9BQTlCLENBQVYsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxNQUFSLEdBQWlCLE1BQWpCO0FBQ0EsSUFBSSxpQkFBa0IsWUFBWTtBQUM5QixhQUFTLGNBQVQsQ0FBd0IsU0FBeEIsRUFBbUMsT0FBbkMsRUFBNEM7QUFDeEMsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0EsYUFBSyxPQUFMLEdBQWUsT0FBZjtBQUNIO0FBQ0QsbUJBQWUsU0FBZixDQUF5QixJQUF6QixHQUFnQyxVQUFVLFVBQVYsRUFBc0IsTUFBdEIsRUFBOEI7QUFDMUQsZUFBTyxPQUFPLFNBQVAsQ0FBaUIsSUFBSSxnQkFBSixDQUFxQixVQUFyQixFQUFpQyxLQUFLLFNBQXRDLEVBQWlELEtBQUssT0FBdEQsQ0FBakIsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPLGNBQVA7QUFDSCxDQVRxQixFQUF0QjtBQVVBOzs7OztBQUtBLElBQUksbUJBQW9CLFVBQVUsTUFBVixFQUFrQjtBQUN0QyxjQUFVLGdCQUFWLEVBQTRCLE1BQTVCO0FBQ0EsYUFBUyxnQkFBVCxDQUEwQixXQUExQixFQUF1QyxTQUF2QyxFQUFrRCxPQUFsRCxFQUEyRDtBQUN2RCxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0EsYUFBSyxPQUFMLEdBQWUsT0FBZjtBQUNBLGFBQUssS0FBTCxHQUFhLENBQWI7QUFDQSxhQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDSDtBQUNEO0FBQ0E7QUFDQSxxQkFBaUIsU0FBakIsQ0FBMkIsS0FBM0IsR0FBbUMsVUFBVSxLQUFWLEVBQWlCO0FBQ2hELFlBQUksTUFBSjtBQUNBLFlBQUk7QUFDQSxxQkFBUyxLQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLEtBQUssT0FBekIsRUFBa0MsS0FBbEMsRUFBeUMsS0FBSyxLQUFMLEVBQXpDLENBQVQ7QUFDSCxTQUZELENBR0EsT0FBTyxHQUFQLEVBQVk7QUFDUixpQkFBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLEdBQXZCO0FBQ0E7QUFDSDtBQUNELFlBQUksTUFBSixFQUFZO0FBQ1IsaUJBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixLQUF0QjtBQUNIO0FBQ0osS0FaRDtBQWFBLFdBQU8sZ0JBQVA7QUFDSCxDQXpCdUIsQ0F5QnRCLGFBQWEsVUF6QlMsQ0FBeEI7QUEwQkE7OztBQzVGQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQ7QUFBaUIsWUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksZUFBZSxRQUFRLGVBQVIsQ0FBbkI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUNBLFNBQVMsR0FBVCxDQUFhLE9BQWIsRUFBc0IsT0FBdEIsRUFBK0I7QUFDM0IsUUFBSSxPQUFPLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDL0IsY0FBTSxJQUFJLFNBQUosQ0FBYyw0REFBZCxDQUFOO0FBQ0g7QUFDRCxXQUFPLEtBQUssSUFBTCxDQUFVLElBQUksV0FBSixDQUFnQixPQUFoQixFQUF5QixPQUF6QixDQUFWLENBQVA7QUFDSDtBQUNELFFBQVEsR0FBUixHQUFjLEdBQWQ7QUFDQSxJQUFJLGNBQWUsWUFBWTtBQUMzQixhQUFTLFdBQVQsQ0FBcUIsT0FBckIsRUFBOEIsT0FBOUIsRUFBdUM7QUFDbkMsYUFBSyxPQUFMLEdBQWUsT0FBZjtBQUNBLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDSDtBQUNELGdCQUFZLFNBQVosQ0FBc0IsSUFBdEIsR0FBNkIsVUFBVSxVQUFWLEVBQXNCLE1BQXRCLEVBQThCO0FBQ3ZELGVBQU8sT0FBTyxTQUFQLENBQWlCLElBQUksYUFBSixDQUFrQixVQUFsQixFQUE4QixLQUFLLE9BQW5DLEVBQTRDLEtBQUssT0FBakQsQ0FBakIsQ0FBUDtBQUNILEtBRkQ7QUFHQSxXQUFPLFdBQVA7QUFDSCxDQVRrQixFQUFuQjtBQVVBLFFBQVEsV0FBUixHQUFzQixXQUF0QjtBQUNBOzs7OztBQUtBLElBQUksZ0JBQWlCLFVBQVUsTUFBVixFQUFrQjtBQUNuQyxjQUFVLGFBQVYsRUFBeUIsTUFBekI7QUFDQSxhQUFTLGFBQVQsQ0FBdUIsV0FBdkIsRUFBb0MsT0FBcEMsRUFBNkMsT0FBN0MsRUFBc0Q7QUFDbEQsZUFBTyxJQUFQLENBQVksSUFBWixFQUFrQixXQUFsQjtBQUNBLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxhQUFLLEtBQUwsR0FBYSxDQUFiO0FBQ0EsYUFBSyxPQUFMLEdBQWUsV0FBVyxJQUExQjtBQUNIO0FBQ0Q7QUFDQTtBQUNBLGtCQUFjLFNBQWQsQ0FBd0IsS0FBeEIsR0FBZ0MsVUFBVSxLQUFWLEVBQWlCO0FBQzdDLFlBQUksTUFBSjtBQUNBLFlBQUk7QUFDQSxxQkFBUyxLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLEtBQUssT0FBdkIsRUFBZ0MsS0FBaEMsRUFBdUMsS0FBSyxLQUFMLEVBQXZDLENBQVQ7QUFDSCxTQUZELENBR0EsT0FBTyxHQUFQLEVBQVk7QUFDUixpQkFBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLEdBQXZCO0FBQ0E7QUFDSDtBQUNELGFBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixNQUF0QjtBQUNILEtBVkQ7QUFXQSxXQUFPLGFBQVA7QUFDSCxDQXRCb0IsQ0FzQm5CLGFBQWEsVUF0Qk0sQ0FBckI7QUF1QkE7OztBQ3RGQTs7QUFDQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0EsSUFBSSxvQkFBb0IsUUFBUSwrQkFBUixDQUF4QjtBQUNBLElBQUksYUFBYSxRQUFRLFlBQVIsQ0FBakI7QUFDQSxJQUFJLGdCQUFnQixRQUFRLHFCQUFSLENBQXBCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThDQSxTQUFTLEtBQVQsR0FBaUI7QUFDYixRQUFJLGNBQWMsRUFBbEI7QUFDQSxTQUFLLElBQUksS0FBSyxDQUFkLEVBQWlCLEtBQUssVUFBVSxNQUFoQyxFQUF3QyxJQUF4QyxFQUE4QztBQUMxQyxvQkFBWSxLQUFLLENBQWpCLElBQXNCLFVBQVUsRUFBVixDQUF0QjtBQUNIO0FBQ0QsV0FBTyxLQUFLLElBQUwsQ0FBVSxJQUFWLENBQWUsWUFBWSxLQUFaLENBQWtCLEtBQUssQ0FBdkIsRUFBMEIsQ0FBQyxJQUFELEVBQU8sTUFBUCxDQUFjLFdBQWQsQ0FBMUIsQ0FBZixDQUFQO0FBQ0g7QUFDRCxRQUFRLEtBQVIsR0FBZ0IsS0FBaEI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0REEsU0FBUyxXQUFULEdBQXVCO0FBQ25CLFFBQUksY0FBYyxFQUFsQjtBQUNBLFNBQUssSUFBSSxLQUFLLENBQWQsRUFBaUIsS0FBSyxVQUFVLE1BQWhDLEVBQXdDLElBQXhDLEVBQThDO0FBQzFDLG9CQUFZLEtBQUssQ0FBakIsSUFBc0IsVUFBVSxFQUFWLENBQXRCO0FBQ0g7QUFDRCxRQUFJLGFBQWEsT0FBTyxpQkFBeEI7QUFDQSxRQUFJLFlBQVksSUFBaEI7QUFDQSxRQUFJLE9BQU8sWUFBWSxZQUFZLE1BQVosR0FBcUIsQ0FBakMsQ0FBWDtBQUNBLFFBQUksY0FBYyxXQUFkLENBQTBCLElBQTFCLENBQUosRUFBcUM7QUFDakMsb0JBQVksWUFBWSxHQUFaLEVBQVo7QUFDQSxZQUFJLFlBQVksTUFBWixHQUFxQixDQUFyQixJQUEwQixPQUFPLFlBQVksWUFBWSxNQUFaLEdBQXFCLENBQWpDLENBQVAsS0FBK0MsUUFBN0UsRUFBdUY7QUFDbkYseUJBQWEsWUFBWSxHQUFaLEVBQWI7QUFDSDtBQUNKLEtBTEQsTUFNSyxJQUFJLE9BQU8sSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUMvQixxQkFBYSxZQUFZLEdBQVosRUFBYjtBQUNIO0FBQ0QsUUFBSSxjQUFjLElBQWQsSUFBc0IsWUFBWSxNQUFaLEtBQXVCLENBQTdDLElBQWtELFlBQVksQ0FBWixhQUEwQixhQUFhLFVBQTdGLEVBQXlHO0FBQ3JHLGVBQU8sWUFBWSxDQUFaLENBQVA7QUFDSDtBQUNELFdBQU8sSUFBSSxrQkFBa0IsZUFBdEIsQ0FBc0MsV0FBdEMsRUFBbUQsU0FBbkQsRUFBOEQsSUFBOUQsQ0FBbUUsSUFBSSxXQUFXLGdCQUFmLENBQWdDLFVBQWhDLENBQW5FLENBQVA7QUFDSDtBQUNELFFBQVEsV0FBUixHQUFzQixXQUF0QjtBQUNBOzs7QUNoSkE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLG9CQUFvQixRQUFRLG9CQUFSLENBQXhCO0FBQ0EsSUFBSSxzQkFBc0IsUUFBUSwyQkFBUixDQUExQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTRDQSxTQUFTLFFBQVQsQ0FBa0IsVUFBbEIsRUFBOEI7QUFDMUIsUUFBSSxlQUFlLEtBQUssQ0FBeEIsRUFBMkI7QUFBRSxxQkFBYSxPQUFPLGlCQUFwQjtBQUF3QztBQUNyRSxXQUFPLEtBQUssSUFBTCxDQUFVLElBQUksZ0JBQUosQ0FBcUIsVUFBckIsQ0FBVixDQUFQO0FBQ0g7QUFDRCxRQUFRLFFBQVIsR0FBbUIsUUFBbkI7QUFDQSxJQUFJLG1CQUFvQixZQUFZO0FBQ2hDLGFBQVMsZ0JBQVQsQ0FBMEIsVUFBMUIsRUFBc0M7QUFDbEMsYUFBSyxVQUFMLEdBQWtCLFVBQWxCO0FBQ0g7QUFDRCxxQkFBaUIsU0FBakIsQ0FBMkIsSUFBM0IsR0FBa0MsVUFBVSxRQUFWLEVBQW9CLE1BQXBCLEVBQTRCO0FBQzFELGVBQU8sT0FBTyxTQUFQLENBQWlCLElBQUksa0JBQUosQ0FBdUIsUUFBdkIsRUFBaUMsS0FBSyxVQUF0QyxDQUFqQixDQUFQO0FBQ0gsS0FGRDtBQUdBLFdBQU8sZ0JBQVA7QUFDSCxDQVJ1QixFQUF4QjtBQVNBLFFBQVEsZ0JBQVIsR0FBMkIsZ0JBQTNCO0FBQ0E7Ozs7O0FBS0EsSUFBSSxxQkFBc0IsVUFBVSxNQUFWLEVBQWtCO0FBQ3hDLGNBQVUsa0JBQVYsRUFBOEIsTUFBOUI7QUFDQSxhQUFTLGtCQUFULENBQTRCLFdBQTVCLEVBQXlDLFVBQXpDLEVBQXFEO0FBQ2pELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLFVBQUwsR0FBa0IsVUFBbEI7QUFDQSxhQUFLLFlBQUwsR0FBb0IsS0FBcEI7QUFDQSxhQUFLLE1BQUwsR0FBYyxFQUFkO0FBQ0EsYUFBSyxNQUFMLEdBQWMsQ0FBZDtBQUNIO0FBQ0QsdUJBQW1CLFNBQW5CLENBQTZCLEtBQTdCLEdBQXFDLFVBQVUsVUFBVixFQUFzQjtBQUN2RCxZQUFJLEtBQUssTUFBTCxHQUFjLEtBQUssVUFBdkIsRUFBbUM7QUFDL0IsaUJBQUssTUFBTDtBQUNBLGlCQUFLLEdBQUwsQ0FBUyxvQkFBb0IsaUJBQXBCLENBQXNDLElBQXRDLEVBQTRDLFVBQTVDLENBQVQ7QUFDSCxTQUhELE1BSUs7QUFDRCxpQkFBSyxNQUFMLENBQVksSUFBWixDQUFpQixVQUFqQjtBQUNIO0FBQ0osS0FSRDtBQVNBLHVCQUFtQixTQUFuQixDQUE2QixTQUE3QixHQUF5QyxZQUFZO0FBQ2pELGFBQUssWUFBTCxHQUFvQixJQUFwQjtBQUNBLFlBQUksS0FBSyxNQUFMLEtBQWdCLENBQWhCLElBQXFCLEtBQUssTUFBTCxDQUFZLE1BQVosS0FBdUIsQ0FBaEQsRUFBbUQ7QUFDL0MsaUJBQUssV0FBTCxDQUFpQixRQUFqQjtBQUNIO0FBQ0osS0FMRDtBQU1BLHVCQUFtQixTQUFuQixDQUE2QixjQUE3QixHQUE4QyxVQUFVLFFBQVYsRUFBb0I7QUFDOUQsWUFBSSxTQUFTLEtBQUssTUFBbEI7QUFDQSxhQUFLLE1BQUwsQ0FBWSxRQUFaO0FBQ0EsYUFBSyxNQUFMO0FBQ0EsWUFBSSxPQUFPLE1BQVAsR0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkIsaUJBQUssS0FBTCxDQUFXLE9BQU8sS0FBUCxFQUFYO0FBQ0gsU0FGRCxNQUdLLElBQUksS0FBSyxNQUFMLEtBQWdCLENBQWhCLElBQXFCLEtBQUssWUFBOUIsRUFBNEM7QUFDN0MsaUJBQUssV0FBTCxDQUFpQixRQUFqQjtBQUNIO0FBQ0osS0FWRDtBQVdBLFdBQU8sa0JBQVA7QUFDSCxDQXBDeUIsQ0FvQ3hCLGtCQUFrQixlQXBDTSxDQUExQjtBQXFDQSxRQUFRLGtCQUFSLEdBQTZCLGtCQUE3QjtBQUNBOzs7OztBQzlHQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQ7QUFBaUIsWUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksWUFBWSxRQUFRLFlBQVIsQ0FBaEI7QUFDQSxJQUFJLGFBQWEsUUFBUSxrQkFBUixDQUFqQjtBQUNBLElBQUksZ0JBQWdCLFFBQVEscUJBQVIsQ0FBcEI7QUFDQSxJQUFJLG9CQUFvQixRQUFRLG9CQUFSLENBQXhCO0FBQ0EsSUFBSSxzQkFBc0IsUUFBUSwyQkFBUixDQUExQjtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBLFNBQVMsU0FBVCxDQUFtQixRQUFuQixFQUE2QjtBQUN6QixXQUFPLEtBQUssSUFBTCxDQUFVLElBQUksaUJBQUosQ0FBc0IsUUFBdEIsRUFBZ0MsSUFBaEMsQ0FBVixDQUFQO0FBQ0g7QUFDRCxRQUFRLFNBQVIsR0FBb0IsU0FBcEI7QUFDQSxJQUFJLG9CQUFxQixZQUFZO0FBQ2pDLGFBQVMsaUJBQVQsQ0FBMkIsUUFBM0IsRUFBcUMsTUFBckMsRUFBNkM7QUFDekMsYUFBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNIO0FBQ0Qsc0JBQWtCLFNBQWxCLENBQTRCLElBQTVCLEdBQW1DLFVBQVUsVUFBVixFQUFzQixNQUF0QixFQUE4QjtBQUM3RCxlQUFPLE9BQU8sU0FBUCxDQUFpQixJQUFJLG1CQUFKLENBQXdCLFVBQXhCLEVBQW9DLEtBQUssUUFBekMsRUFBbUQsS0FBSyxNQUF4RCxDQUFqQixDQUFQO0FBQ0gsS0FGRDtBQUdBLFdBQU8saUJBQVA7QUFDSCxDQVR3QixFQUF6QjtBQVVBOzs7OztBQUtBLElBQUksc0JBQXVCLFVBQVUsTUFBVixFQUFrQjtBQUN6QyxjQUFVLG1CQUFWLEVBQStCLE1BQS9CO0FBQ0EsYUFBUyxtQkFBVCxDQUE2QixXQUE3QixFQUEwQyxRQUExQyxFQUFvRCxNQUFwRCxFQUE0RDtBQUN4RCxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNIO0FBQ0Qsd0JBQW9CLFNBQXBCLENBQThCLEtBQTlCLEdBQXNDLFVBQVUsR0FBVixFQUFlO0FBQ2pELFlBQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUI7QUFDakIsZ0JBQUksU0FBUyxLQUFLLE1BQWxCO0FBQ0EsZ0JBQUksVUFBVSxLQUFLLE9BQW5CO0FBQ0EsZ0JBQUksc0JBQXNCLEtBQUssbUJBQS9CO0FBQ0EsZ0JBQUksQ0FBQyxPQUFMLEVBQWM7QUFDVix5QkFBUyxJQUFJLFVBQVUsT0FBZCxFQUFUO0FBQ0EsMEJBQVUsV0FBVyxRQUFYLENBQW9CLEtBQUssUUFBekIsRUFBbUMsTUFBbkMsQ0FBVjtBQUNBLG9CQUFJLFlBQVksY0FBYyxXQUE5QixFQUEyQztBQUN2QywyQkFBTyxPQUFPLFNBQVAsQ0FBaUIsS0FBakIsQ0FBdUIsSUFBdkIsQ0FBNEIsSUFBNUIsRUFBa0MsY0FBYyxXQUFkLENBQTBCLENBQTVELENBQVA7QUFDSDtBQUNELHNDQUFzQixvQkFBb0IsaUJBQXBCLENBQXNDLElBQXRDLEVBQTRDLE9BQTVDLENBQXRCO0FBQ0gsYUFQRCxNQVFLO0FBQ0QscUJBQUssTUFBTCxHQUFjLElBQWQ7QUFDQSxxQkFBSyxtQkFBTCxHQUEyQixJQUEzQjtBQUNIO0FBQ0QsaUJBQUssc0JBQUw7QUFDQSxpQkFBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLGlCQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsaUJBQUssbUJBQUwsR0FBMkIsbUJBQTNCO0FBQ0EsbUJBQU8sSUFBUCxDQUFZLEdBQVo7QUFDSDtBQUNKLEtBdkJEO0FBd0JBLHdCQUFvQixTQUFwQixDQUE4QixZQUE5QixHQUE2QyxZQUFZO0FBQ3JELFlBQUksS0FBSyxJQUFUO0FBQUEsWUFBZSxTQUFTLEdBQUcsTUFBM0I7QUFBQSxZQUFtQyxzQkFBc0IsR0FBRyxtQkFBNUQ7QUFDQSxZQUFJLE1BQUosRUFBWTtBQUNSLG1CQUFPLFdBQVA7QUFDQSxpQkFBSyxNQUFMLEdBQWMsSUFBZDtBQUNIO0FBQ0QsWUFBSSxtQkFBSixFQUF5QjtBQUNyQixnQ0FBb0IsV0FBcEI7QUFDQSxpQkFBSyxtQkFBTCxHQUEyQixJQUEzQjtBQUNIO0FBQ0QsYUFBSyxPQUFMLEdBQWUsSUFBZjtBQUNILEtBWEQ7QUFZQSx3QkFBb0IsU0FBcEIsQ0FBOEIsVUFBOUIsR0FBMkMsVUFBVSxVQUFWLEVBQXNCLFVBQXRCLEVBQWtDLFVBQWxDLEVBQThDLFVBQTlDLEVBQTBELFFBQTFELEVBQW9FO0FBQzNHLFlBQUksS0FBSyxJQUFUO0FBQUEsWUFBZSxTQUFTLEdBQUcsTUFBM0I7QUFBQSxZQUFtQyxVQUFVLEdBQUcsT0FBaEQ7QUFBQSxZQUF5RCxzQkFBc0IsR0FBRyxtQkFBbEY7QUFDQSxhQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0EsYUFBSyxPQUFMLEdBQWUsSUFBZjtBQUNBLGFBQUssbUJBQUwsR0FBMkIsSUFBM0I7QUFDQSxhQUFLLHNCQUFMO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDQSxhQUFLLG1CQUFMLEdBQTJCLG1CQUEzQjtBQUNBLGFBQUssTUFBTCxDQUFZLFNBQVosQ0FBc0IsSUFBdEI7QUFDSCxLQVZEO0FBV0EsV0FBTyxtQkFBUDtBQUNILENBdkQwQixDQXVEekIsa0JBQWtCLGVBdkRPLENBQTNCO0FBd0RBOzs7Ozs7O0FDcEdBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZDtBQUFpQixZQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxvQkFBb0IsUUFBUSxvQkFBUixDQUF4QjtBQUNBLElBQUksc0JBQXNCLFFBQVEsMkJBQVIsQ0FBMUI7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMENBLFNBQVMsT0FBVCxHQUFtQjtBQUNmLFdBQU8sS0FBSyxJQUFMLENBQVUsSUFBSSxjQUFKLEVBQVYsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxPQUFSLEdBQWtCLE9BQWxCO0FBQ0EsSUFBSSxpQkFBa0IsWUFBWTtBQUM5QixhQUFTLGNBQVQsR0FBMEIsQ0FDekI7QUFDRCxtQkFBZSxTQUFmLENBQXlCLElBQXpCLEdBQWdDLFVBQVUsVUFBVixFQUFzQixNQUF0QixFQUE4QjtBQUMxRCxlQUFPLE9BQU8sU0FBUCxDQUFpQixJQUFJLGdCQUFKLENBQXFCLFVBQXJCLENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxjQUFQO0FBQ0gsQ0FQcUIsRUFBdEI7QUFRQTs7Ozs7QUFLQSxJQUFJLG1CQUFvQixVQUFVLE1BQVYsRUFBa0I7QUFDdEMsY0FBVSxnQkFBVixFQUE0QixNQUE1QjtBQUNBLGFBQVMsZ0JBQVQsQ0FBMEIsV0FBMUIsRUFBdUM7QUFDbkMsZUFBTyxJQUFQLENBQVksSUFBWixFQUFrQixXQUFsQjtBQUNBLGFBQUssTUFBTCxHQUFjLENBQWQ7QUFDQSxhQUFLLFlBQUwsR0FBb0IsS0FBcEI7QUFDSDtBQUNELHFCQUFpQixTQUFqQixDQUEyQixLQUEzQixHQUFtQyxVQUFVLEtBQVYsRUFBaUI7QUFDaEQsYUFBSyxnQkFBTDtBQUNBLGFBQUssTUFBTDtBQUNBLGFBQUssR0FBTCxDQUFTLEtBQUssaUJBQUwsR0FBeUIsb0JBQW9CLGlCQUFwQixDQUFzQyxJQUF0QyxFQUE0QyxLQUE1QyxDQUFsQztBQUNILEtBSkQ7QUFLQSxxQkFBaUIsU0FBakIsQ0FBMkIsU0FBM0IsR0FBdUMsWUFBWTtBQUMvQyxhQUFLLFlBQUwsR0FBb0IsSUFBcEI7QUFDQSxZQUFJLEtBQUssTUFBTCxLQUFnQixDQUFwQixFQUF1QjtBQUNuQixpQkFBSyxXQUFMLENBQWlCLFFBQWpCO0FBQ0g7QUFDSixLQUxEO0FBTUEscUJBQWlCLFNBQWpCLENBQTJCLGdCQUEzQixHQUE4QyxZQUFZO0FBQ3RELGFBQUssTUFBTCxHQUFjLEtBQUssTUFBTCxHQUFjLENBQWQsR0FBa0IsS0FBSyxNQUFMLEdBQWMsQ0FBaEMsR0FBb0MsQ0FBbEQ7QUFDQSxZQUFJLG9CQUFvQixLQUFLLGlCQUE3QjtBQUNBLFlBQUksaUJBQUosRUFBdUI7QUFDbkIsOEJBQWtCLFdBQWxCO0FBQ0EsaUJBQUssTUFBTCxDQUFZLGlCQUFaO0FBQ0g7QUFDSixLQVBEO0FBUUEscUJBQWlCLFNBQWpCLENBQTJCLFVBQTNCLEdBQXdDLFVBQVUsVUFBVixFQUFzQixVQUF0QixFQUFrQyxVQUFsQyxFQUE4QyxVQUE5QyxFQUEwRCxRQUExRCxFQUFvRTtBQUN4RyxhQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsVUFBdEI7QUFDSCxLQUZEO0FBR0EscUJBQWlCLFNBQWpCLENBQTJCLFdBQTNCLEdBQXlDLFVBQVUsR0FBVixFQUFlO0FBQ3BELGFBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixHQUF2QjtBQUNILEtBRkQ7QUFHQSxxQkFBaUIsU0FBakIsQ0FBMkIsY0FBM0IsR0FBNEMsWUFBWTtBQUNwRCxhQUFLLGdCQUFMO0FBQ0EsWUFBSSxLQUFLLFlBQUwsSUFBcUIsS0FBSyxNQUFMLEtBQWdCLENBQXpDLEVBQTRDO0FBQ3hDLGlCQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDSDtBQUNKLEtBTEQ7QUFNQSxXQUFPLGdCQUFQO0FBQ0gsQ0F2Q3VCLENBdUN0QixrQkFBa0IsZUF2Q0ksQ0FBeEI7QUF3Q0E7OztBQzNHQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQ7QUFBaUIsWUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBLElBQUksb0JBQW9CLFFBQVEsb0JBQVIsQ0FBeEI7QUFDQSxJQUFJLHNCQUFzQixRQUFRLDJCQUFSLENBQTFCO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQ0EsU0FBUyxTQUFULENBQW1CLE9BQW5CLEVBQTRCLGNBQTVCLEVBQTRDO0FBQ3hDLFdBQU8sS0FBSyxJQUFMLENBQVUsSUFBSSxpQkFBSixDQUFzQixPQUF0QixFQUErQixjQUEvQixDQUFWLENBQVA7QUFDSDtBQUNELFFBQVEsU0FBUixHQUFvQixTQUFwQjtBQUNBLElBQUksb0JBQXFCLFlBQVk7QUFDakMsYUFBUyxpQkFBVCxDQUEyQixPQUEzQixFQUFvQyxjQUFwQyxFQUFvRDtBQUNoRCxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsYUFBSyxjQUFMLEdBQXNCLGNBQXRCO0FBQ0g7QUFDRCxzQkFBa0IsU0FBbEIsQ0FBNEIsSUFBNUIsR0FBbUMsVUFBVSxVQUFWLEVBQXNCLE1BQXRCLEVBQThCO0FBQzdELGVBQU8sT0FBTyxTQUFQLENBQWlCLElBQUksbUJBQUosQ0FBd0IsVUFBeEIsRUFBb0MsS0FBSyxPQUF6QyxFQUFrRCxLQUFLLGNBQXZELENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxpQkFBUDtBQUNILENBVHdCLEVBQXpCO0FBVUE7Ozs7O0FBS0EsSUFBSSxzQkFBdUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3pDLGNBQVUsbUJBQVYsRUFBK0IsTUFBL0I7QUFDQSxhQUFTLG1CQUFULENBQTZCLFdBQTdCLEVBQTBDLE9BQTFDLEVBQW1ELGNBQW5ELEVBQW1FO0FBQy9ELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0EsYUFBSyxjQUFMLEdBQXNCLGNBQXRCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsQ0FBYjtBQUNIO0FBQ0Qsd0JBQW9CLFNBQXBCLENBQThCLEtBQTlCLEdBQXNDLFVBQVUsS0FBVixFQUFpQjtBQUNuRCxZQUFJLE1BQUo7QUFDQSxZQUFJLFFBQVEsS0FBSyxLQUFMLEVBQVo7QUFDQSxZQUFJO0FBQ0EscUJBQVMsS0FBSyxPQUFMLENBQWEsS0FBYixFQUFvQixLQUFwQixDQUFUO0FBQ0gsU0FGRCxDQUdBLE9BQU8sS0FBUCxFQUFjO0FBQ1YsaUJBQUssV0FBTCxDQUFpQixLQUFqQixDQUF1QixLQUF2QjtBQUNBO0FBQ0g7QUFDRCxhQUFLLFNBQUwsQ0FBZSxNQUFmLEVBQXVCLEtBQXZCLEVBQThCLEtBQTlCO0FBQ0gsS0FYRDtBQVlBLHdCQUFvQixTQUFwQixDQUE4QixTQUE5QixHQUEwQyxVQUFVLE1BQVYsRUFBa0IsS0FBbEIsRUFBeUIsS0FBekIsRUFBZ0M7QUFDdEUsWUFBSSxvQkFBb0IsS0FBSyxpQkFBN0I7QUFDQSxZQUFJLGlCQUFKLEVBQXVCO0FBQ25CLDhCQUFrQixXQUFsQjtBQUNIO0FBQ0QsYUFBSyxHQUFMLENBQVMsS0FBSyxpQkFBTCxHQUF5QixvQkFBb0IsaUJBQXBCLENBQXNDLElBQXRDLEVBQTRDLE1BQTVDLEVBQW9ELEtBQXBELEVBQTJELEtBQTNELENBQWxDO0FBQ0gsS0FORDtBQU9BLHdCQUFvQixTQUFwQixDQUE4QixTQUE5QixHQUEwQyxZQUFZO0FBQ2xELFlBQUksb0JBQW9CLEtBQUssaUJBQTdCO0FBQ0EsWUFBSSxDQUFDLGlCQUFELElBQXNCLGtCQUFrQixNQUE1QyxFQUFvRDtBQUNoRCxtQkFBTyxTQUFQLENBQWlCLFNBQWpCLENBQTJCLElBQTNCLENBQWdDLElBQWhDO0FBQ0g7QUFDSixLQUxEO0FBTUEsd0JBQW9CLFNBQXBCLENBQThCLFlBQTlCLEdBQTZDLFlBQVk7QUFDckQsYUFBSyxpQkFBTCxHQUF5QixJQUF6QjtBQUNILEtBRkQ7QUFHQSx3QkFBb0IsU0FBcEIsQ0FBOEIsY0FBOUIsR0FBK0MsVUFBVSxRQUFWLEVBQW9CO0FBQy9ELGFBQUssTUFBTCxDQUFZLFFBQVo7QUFDQSxhQUFLLGlCQUFMLEdBQXlCLElBQXpCO0FBQ0EsWUFBSSxLQUFLLFNBQVQsRUFBb0I7QUFDaEIsbUJBQU8sU0FBUCxDQUFpQixTQUFqQixDQUEyQixJQUEzQixDQUFnQyxJQUFoQztBQUNIO0FBQ0osS0FORDtBQU9BLHdCQUFvQixTQUFwQixDQUE4QixVQUE5QixHQUEyQyxVQUFVLFVBQVYsRUFBc0IsVUFBdEIsRUFBa0MsVUFBbEMsRUFBOEMsVUFBOUMsRUFBMEQsUUFBMUQsRUFBb0U7QUFDM0csWUFBSSxLQUFLLGNBQVQsRUFBeUI7QUFDckIsaUJBQUssY0FBTCxDQUFvQixVQUFwQixFQUFnQyxVQUFoQyxFQUE0QyxVQUE1QyxFQUF3RCxVQUF4RDtBQUNILFNBRkQsTUFHSztBQUNELGlCQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsVUFBdEI7QUFDSDtBQUNKLEtBUEQ7QUFRQSx3QkFBb0IsU0FBcEIsQ0FBOEIsY0FBOUIsR0FBK0MsVUFBVSxVQUFWLEVBQXNCLFVBQXRCLEVBQWtDLFVBQWxDLEVBQThDLFVBQTlDLEVBQTBEO0FBQ3JHLFlBQUksTUFBSjtBQUNBLFlBQUk7QUFDQSxxQkFBUyxLQUFLLGNBQUwsQ0FBb0IsVUFBcEIsRUFBZ0MsVUFBaEMsRUFBNEMsVUFBNUMsRUFBd0QsVUFBeEQsQ0FBVDtBQUNILFNBRkQsQ0FHQSxPQUFPLEdBQVAsRUFBWTtBQUNSLGlCQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBdUIsR0FBdkI7QUFDQTtBQUNIO0FBQ0QsYUFBSyxXQUFMLENBQWlCLElBQWpCLENBQXNCLE1BQXRCO0FBQ0gsS0FWRDtBQVdBLFdBQU8sbUJBQVA7QUFDSCxDQS9EMEIsQ0ErRHpCLGtCQUFrQixlQS9ETyxDQUEzQjtBQWdFQTs7O0FDM0lBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZDtBQUFpQixZQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxlQUFlLFFBQVEsZUFBUixDQUFuQjtBQUNBLElBQUksNEJBQTRCLFFBQVEsaUNBQVIsQ0FBaEM7QUFDQSxJQUFJLG9CQUFvQixRQUFRLCtCQUFSLENBQXhCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlDQSxTQUFTLElBQVQsQ0FBYyxLQUFkLEVBQXFCO0FBQ2pCLFFBQUksVUFBVSxDQUFkLEVBQWlCO0FBQ2IsZUFBTyxJQUFJLGtCQUFrQixlQUF0QixFQUFQO0FBQ0gsS0FGRCxNQUdLO0FBQ0QsZUFBTyxLQUFLLElBQUwsQ0FBVSxJQUFJLFlBQUosQ0FBaUIsS0FBakIsQ0FBVixDQUFQO0FBQ0g7QUFDSjtBQUNELFFBQVEsSUFBUixHQUFlLElBQWY7QUFDQSxJQUFJLGVBQWdCLFlBQVk7QUFDNUIsYUFBUyxZQUFULENBQXNCLEtBQXRCLEVBQTZCO0FBQ3pCLGFBQUssS0FBTCxHQUFhLEtBQWI7QUFDQSxZQUFJLEtBQUssS0FBTCxHQUFhLENBQWpCLEVBQW9CO0FBQ2hCLGtCQUFNLElBQUksMEJBQTBCLHVCQUE5QixFQUFOO0FBQ0g7QUFDSjtBQUNELGlCQUFhLFNBQWIsQ0FBdUIsSUFBdkIsR0FBOEIsVUFBVSxVQUFWLEVBQXNCLE1BQXRCLEVBQThCO0FBQ3hELGVBQU8sT0FBTyxTQUFQLENBQWlCLElBQUksY0FBSixDQUFtQixVQUFuQixFQUErQixLQUFLLEtBQXBDLENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxZQUFQO0FBQ0gsQ0FYbUIsRUFBcEI7QUFZQTs7Ozs7QUFLQSxJQUFJLGlCQUFrQixVQUFVLE1BQVYsRUFBa0I7QUFDcEMsY0FBVSxjQUFWLEVBQTBCLE1BQTFCO0FBQ0EsYUFBUyxjQUFULENBQXdCLFdBQXhCLEVBQXFDLEtBQXJDLEVBQTRDO0FBQ3hDLGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0EsYUFBSyxLQUFMLEdBQWEsQ0FBYjtBQUNIO0FBQ0QsbUJBQWUsU0FBZixDQUF5QixLQUF6QixHQUFpQyxVQUFVLEtBQVYsRUFBaUI7QUFDOUMsWUFBSSxRQUFRLEtBQUssS0FBakI7QUFDQSxZQUFJLFFBQVEsRUFBRSxLQUFLLEtBQW5CO0FBQ0EsWUFBSSxTQUFTLEtBQWIsRUFBb0I7QUFDaEIsaUJBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixLQUF0QjtBQUNBLGdCQUFJLFVBQVUsS0FBZCxFQUFxQjtBQUNqQixxQkFBSyxXQUFMLENBQWlCLFFBQWpCO0FBQ0EscUJBQUssV0FBTDtBQUNIO0FBQ0o7QUFDSixLQVZEO0FBV0EsV0FBTyxjQUFQO0FBQ0gsQ0FuQnFCLENBbUJwQixhQUFhLFVBbkJPLENBQXRCO0FBb0JBOzs7QUN4RkE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLG9CQUFvQixRQUFRLG9CQUFSLENBQXhCO0FBQ0EsSUFBSSxzQkFBc0IsUUFBUSwyQkFBUixDQUExQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQ0EsU0FBUyxTQUFULENBQW1CLFFBQW5CLEVBQTZCO0FBQ3pCLFdBQU8sS0FBSyxJQUFMLENBQVUsSUFBSSxpQkFBSixDQUFzQixRQUF0QixDQUFWLENBQVA7QUFDSDtBQUNELFFBQVEsU0FBUixHQUFvQixTQUFwQjtBQUNBLElBQUksb0JBQXFCLFlBQVk7QUFDakMsYUFBUyxpQkFBVCxDQUEyQixRQUEzQixFQUFxQztBQUNqQyxhQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDSDtBQUNELHNCQUFrQixTQUFsQixDQUE0QixJQUE1QixHQUFtQyxVQUFVLFVBQVYsRUFBc0IsTUFBdEIsRUFBOEI7QUFDN0QsZUFBTyxPQUFPLFNBQVAsQ0FBaUIsSUFBSSxtQkFBSixDQUF3QixVQUF4QixFQUFvQyxLQUFLLFFBQXpDLENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxpQkFBUDtBQUNILENBUndCLEVBQXpCO0FBU0E7Ozs7O0FBS0EsSUFBSSxzQkFBdUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3pDLGNBQVUsbUJBQVYsRUFBK0IsTUFBL0I7QUFDQSxhQUFTLG1CQUFULENBQTZCLFdBQTdCLEVBQTBDLFFBQTFDLEVBQW9EO0FBQ2hELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxhQUFLLEdBQUwsQ0FBUyxvQkFBb0IsaUJBQXBCLENBQXNDLElBQXRDLEVBQTRDLFFBQTVDLENBQVQ7QUFDSDtBQUNELHdCQUFvQixTQUFwQixDQUE4QixVQUE5QixHQUEyQyxVQUFVLFVBQVYsRUFBc0IsVUFBdEIsRUFBa0MsVUFBbEMsRUFBOEMsVUFBOUMsRUFBMEQsUUFBMUQsRUFBb0U7QUFDM0csYUFBSyxRQUFMO0FBQ0gsS0FGRDtBQUdBLHdCQUFvQixTQUFwQixDQUE4QixjQUE5QixHQUErQyxZQUFZO0FBQ3ZEO0FBQ0gsS0FGRDtBQUdBLFdBQU8sbUJBQVA7QUFDSCxDQWQwQixDQWN6QixrQkFBa0IsZUFkTyxDQUEzQjtBQWVBOzs7QUMxRUE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0EsSUFBSSxVQUFVLFFBQVEsb0JBQVIsQ0FBZDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF1Q0EsU0FBUyxZQUFULENBQXNCLFFBQXRCLEVBQWdDLFNBQWhDLEVBQTJDO0FBQ3ZDLFFBQUksY0FBYyxLQUFLLENBQXZCLEVBQTBCO0FBQUUsb0JBQVksUUFBUSxLQUFwQjtBQUE0QjtBQUN4RCxXQUFPLEtBQUssSUFBTCxDQUFVLElBQUksb0JBQUosQ0FBeUIsUUFBekIsRUFBbUMsU0FBbkMsQ0FBVixDQUFQO0FBQ0g7QUFDRCxRQUFRLFlBQVIsR0FBdUIsWUFBdkI7QUFDQSxJQUFJLHVCQUF3QixZQUFZO0FBQ3BDLGFBQVMsb0JBQVQsQ0FBOEIsUUFBOUIsRUFBd0MsU0FBeEMsRUFBbUQ7QUFDL0MsYUFBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0g7QUFDRCx5QkFBcUIsU0FBckIsQ0FBK0IsSUFBL0IsR0FBc0MsVUFBVSxVQUFWLEVBQXNCLE1BQXRCLEVBQThCO0FBQ2hFLGVBQU8sT0FBTyxTQUFQLENBQWlCLElBQUksc0JBQUosQ0FBMkIsVUFBM0IsRUFBdUMsS0FBSyxRQUE1QyxFQUFzRCxLQUFLLFNBQTNELENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxvQkFBUDtBQUNILENBVDJCLEVBQTVCO0FBVUE7Ozs7O0FBS0EsSUFBSSx5QkFBMEIsVUFBVSxNQUFWLEVBQWtCO0FBQzVDLGNBQVUsc0JBQVYsRUFBa0MsTUFBbEM7QUFDQSxhQUFTLHNCQUFULENBQWdDLFdBQWhDLEVBQTZDLFFBQTdDLEVBQXVELFNBQXZELEVBQWtFO0FBQzlELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDQSxhQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDSDtBQUNELDJCQUF1QixTQUF2QixDQUFpQyxLQUFqQyxHQUF5QyxVQUFVLEtBQVYsRUFBaUI7QUFDdEQsWUFBSSxDQUFDLEtBQUssU0FBVixFQUFxQjtBQUNqQixpQkFBSyxHQUFMLENBQVMsS0FBSyxTQUFMLEdBQWlCLEtBQUssU0FBTCxDQUFlLFFBQWYsQ0FBd0IsWUFBeEIsRUFBc0MsS0FBSyxRQUEzQyxFQUFxRCxFQUFFLFlBQVksSUFBZCxFQUFyRCxDQUExQjtBQUNBLGlCQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsS0FBdEI7QUFDSDtBQUNKLEtBTEQ7QUFNQSwyQkFBdUIsU0FBdkIsQ0FBaUMsYUFBakMsR0FBaUQsWUFBWTtBQUN6RCxZQUFJLFlBQVksS0FBSyxTQUFyQjtBQUNBLFlBQUksU0FBSixFQUFlO0FBQ1gsc0JBQVUsV0FBVjtBQUNBLGlCQUFLLE1BQUwsQ0FBWSxTQUFaO0FBQ0EsaUJBQUssU0FBTCxHQUFpQixJQUFqQjtBQUNIO0FBQ0osS0FQRDtBQVFBLFdBQU8sc0JBQVA7QUFDSCxDQXRCNkIsQ0FzQjVCLGFBQWEsVUF0QmUsQ0FBOUI7QUF1QkEsU0FBUyxZQUFULENBQXNCLEdBQXRCLEVBQTJCO0FBQ3ZCLFFBQUksYUFBYSxJQUFJLFVBQXJCO0FBQ0EsZUFBVyxhQUFYO0FBQ0g7QUFDRDs7O0FDOUZBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZDtBQUFpQixZQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxvQkFBb0IsUUFBUSxvQkFBUixDQUF4QjtBQUNBLElBQUksc0JBQXNCLFFBQVEsMkJBQVIsQ0FBMUI7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDQSxTQUFTLGNBQVQsR0FBMEI7QUFDdEIsUUFBSSxPQUFPLEVBQVg7QUFDQSxTQUFLLElBQUksS0FBSyxDQUFkLEVBQWlCLEtBQUssVUFBVSxNQUFoQyxFQUF3QyxJQUF4QyxFQUE4QztBQUMxQyxhQUFLLEtBQUssQ0FBVixJQUFlLFVBQVUsRUFBVixDQUFmO0FBQ0g7QUFDRCxRQUFJLE9BQUo7QUFDQSxRQUFJLE9BQU8sS0FBSyxLQUFLLE1BQUwsR0FBYyxDQUFuQixDQUFQLEtBQWlDLFVBQXJDLEVBQWlEO0FBQzdDLGtCQUFVLEtBQUssR0FBTCxFQUFWO0FBQ0g7QUFDRCxRQUFJLGNBQWMsSUFBbEI7QUFDQSxXQUFPLEtBQUssSUFBTCxDQUFVLElBQUksc0JBQUosQ0FBMkIsV0FBM0IsRUFBd0MsT0FBeEMsQ0FBVixDQUFQO0FBQ0g7QUFDRCxRQUFRLGNBQVIsR0FBeUIsY0FBekI7QUFDQSxJQUFJLHlCQUEwQixZQUFZO0FBQ3RDLGFBQVMsc0JBQVQsQ0FBZ0MsV0FBaEMsRUFBNkMsT0FBN0MsRUFBc0Q7QUFDbEQsYUFBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0EsYUFBSyxPQUFMLEdBQWUsT0FBZjtBQUNIO0FBQ0QsMkJBQXVCLFNBQXZCLENBQWlDLElBQWpDLEdBQXdDLFVBQVUsVUFBVixFQUFzQixNQUF0QixFQUE4QjtBQUNsRSxlQUFPLE9BQU8sU0FBUCxDQUFpQixJQUFJLHdCQUFKLENBQTZCLFVBQTdCLEVBQXlDLEtBQUssV0FBOUMsRUFBMkQsS0FBSyxPQUFoRSxDQUFqQixDQUFQO0FBQ0gsS0FGRDtBQUdBLFdBQU8sc0JBQVA7QUFDSCxDQVQ2QixFQUE5QjtBQVVBOzs7OztBQUtBLElBQUksMkJBQTRCLFVBQVUsTUFBVixFQUFrQjtBQUM5QyxjQUFVLHdCQUFWLEVBQW9DLE1BQXBDO0FBQ0EsYUFBUyx3QkFBVCxDQUFrQyxXQUFsQyxFQUErQyxXQUEvQyxFQUE0RCxPQUE1RCxFQUFxRTtBQUNqRSxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsYUFBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0EsYUFBSyxPQUFMLEdBQWUsT0FBZjtBQUNBLGFBQUssU0FBTCxHQUFpQixFQUFqQjtBQUNBLFlBQUksTUFBTSxZQUFZLE1BQXRCO0FBQ0EsYUFBSyxNQUFMLEdBQWMsSUFBSSxLQUFKLENBQVUsR0FBVixDQUFkO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLGlCQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLENBQXBCO0FBQ0g7QUFDRCxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIsZ0JBQUksYUFBYSxZQUFZLENBQVosQ0FBakI7QUFDQSxpQkFBSyxHQUFMLENBQVMsb0JBQW9CLGlCQUFwQixDQUFzQyxJQUF0QyxFQUE0QyxVQUE1QyxFQUF3RCxVQUF4RCxFQUFvRSxDQUFwRSxDQUFUO0FBQ0g7QUFDSjtBQUNELDZCQUF5QixTQUF6QixDQUFtQyxVQUFuQyxHQUFnRCxVQUFVLFVBQVYsRUFBc0IsVUFBdEIsRUFBa0MsVUFBbEMsRUFBOEMsVUFBOUMsRUFBMEQsUUFBMUQsRUFBb0U7QUFDaEgsYUFBSyxNQUFMLENBQVksVUFBWixJQUEwQixVQUExQjtBQUNBLFlBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0EsWUFBSSxVQUFVLE1BQVYsR0FBbUIsQ0FBdkIsRUFBMEI7QUFDdEIsZ0JBQUksUUFBUSxVQUFVLE9BQVYsQ0FBa0IsVUFBbEIsQ0FBWjtBQUNBLGdCQUFJLFVBQVUsQ0FBQyxDQUFmLEVBQWtCO0FBQ2QsMEJBQVUsTUFBVixDQUFpQixLQUFqQixFQUF3QixDQUF4QjtBQUNIO0FBQ0o7QUFDSixLQVREO0FBVUEsNkJBQXlCLFNBQXpCLENBQW1DLGNBQW5DLEdBQW9ELFlBQVk7QUFDNUQ7QUFDSCxLQUZEO0FBR0EsNkJBQXlCLFNBQXpCLENBQW1DLEtBQW5DLEdBQTJDLFVBQVUsS0FBVixFQUFpQjtBQUN4RCxZQUFJLEtBQUssU0FBTCxDQUFlLE1BQWYsS0FBMEIsQ0FBOUIsRUFBaUM7QUFDN0IsZ0JBQUksT0FBTyxDQUFDLEtBQUQsRUFBUSxNQUFSLENBQWUsS0FBSyxNQUFwQixDQUFYO0FBQ0EsZ0JBQUksS0FBSyxPQUFULEVBQWtCO0FBQ2QscUJBQUssV0FBTCxDQUFpQixJQUFqQjtBQUNILGFBRkQsTUFHSztBQUNELHFCQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsSUFBdEI7QUFDSDtBQUNKO0FBQ0osS0FWRDtBQVdBLDZCQUF5QixTQUF6QixDQUFtQyxXQUFuQyxHQUFpRCxVQUFVLElBQVYsRUFBZ0I7QUFDN0QsWUFBSSxNQUFKO0FBQ0EsWUFBSTtBQUNBLHFCQUFTLEtBQUssT0FBTCxDQUFhLEtBQWIsQ0FBbUIsSUFBbkIsRUFBeUIsSUFBekIsQ0FBVDtBQUNILFNBRkQsQ0FHQSxPQUFPLEdBQVAsRUFBWTtBQUNSLGlCQUFLLFdBQUwsQ0FBaUIsS0FBakIsQ0FBdUIsR0FBdkI7QUFDQTtBQUNIO0FBQ0QsYUFBSyxXQUFMLENBQWlCLElBQWpCLENBQXNCLE1BQXRCO0FBQ0gsS0FWRDtBQVdBLFdBQU8sd0JBQVA7QUFDSCxDQXJEK0IsQ0FxRDlCLGtCQUFrQixlQXJEWSxDQUFoQztBQXNEQTs7O0FDaklBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZDtBQUFpQixZQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxvQkFBb0IsUUFBUSwrQkFBUixDQUF4QjtBQUNBLElBQUksWUFBWSxRQUFRLGlCQUFSLENBQWhCO0FBQ0EsSUFBSSxlQUFlLFFBQVEsZUFBUixDQUFuQjtBQUNBLElBQUksb0JBQW9CLFFBQVEsb0JBQVIsQ0FBeEI7QUFDQSxJQUFJLHNCQUFzQixRQUFRLDJCQUFSLENBQTFCO0FBQ0EsSUFBSSxhQUFhLFFBQVEsb0JBQVIsQ0FBakI7QUFDQTtBQUNBOzs7Ozs7QUFNQSxTQUFTLFFBQVQsR0FBb0I7QUFDaEIsUUFBSSxjQUFjLEVBQWxCO0FBQ0EsU0FBSyxJQUFJLEtBQUssQ0FBZCxFQUFpQixLQUFLLFVBQVUsTUFBaEMsRUFBd0MsSUFBeEMsRUFBOEM7QUFDMUMsb0JBQVksS0FBSyxDQUFqQixJQUFzQixVQUFVLEVBQVYsQ0FBdEI7QUFDSDtBQUNELFdBQU8sS0FBSyxJQUFMLENBQVUsSUFBVixDQUFlLFVBQVUsS0FBVixDQUFnQixLQUFLLENBQXJCLEVBQXdCLENBQUMsSUFBRCxFQUFPLE1BQVAsQ0FBYyxXQUFkLENBQXhCLENBQWYsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxRQUFSLEdBQW1CLFFBQW5CO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStCQSxTQUFTLFNBQVQsR0FBcUI7QUFDakIsUUFBSSxjQUFjLEVBQWxCO0FBQ0EsU0FBSyxJQUFJLEtBQUssQ0FBZCxFQUFpQixLQUFLLFVBQVUsTUFBaEMsRUFBd0MsSUFBeEMsRUFBOEM7QUFDMUMsb0JBQVksS0FBSyxDQUFqQixJQUFzQixVQUFVLEVBQVYsQ0FBdEI7QUFDSDtBQUNELFFBQUksVUFBVSxZQUFZLFlBQVksTUFBWixHQUFxQixDQUFqQyxDQUFkO0FBQ0EsUUFBSSxPQUFPLE9BQVAsS0FBbUIsVUFBdkIsRUFBbUM7QUFDL0Isb0JBQVksR0FBWjtBQUNIO0FBQ0QsV0FBTyxJQUFJLGtCQUFrQixlQUF0QixDQUFzQyxXQUF0QyxFQUFtRCxJQUFuRCxDQUF3RCxJQUFJLFdBQUosQ0FBZ0IsT0FBaEIsQ0FBeEQsQ0FBUDtBQUNIO0FBQ0QsUUFBUSxTQUFSLEdBQW9CLFNBQXBCO0FBQ0EsSUFBSSxjQUFlLFlBQVk7QUFDM0IsYUFBUyxXQUFULENBQXFCLE9BQXJCLEVBQThCO0FBQzFCLGFBQUssT0FBTCxHQUFlLE9BQWY7QUFDSDtBQUNELGdCQUFZLFNBQVosQ0FBc0IsSUFBdEIsR0FBNkIsVUFBVSxVQUFWLEVBQXNCLE1BQXRCLEVBQThCO0FBQ3ZELGVBQU8sT0FBTyxTQUFQLENBQWlCLElBQUksYUFBSixDQUFrQixVQUFsQixFQUE4QixLQUFLLE9BQW5DLENBQWpCLENBQVA7QUFDSCxLQUZEO0FBR0EsV0FBTyxXQUFQO0FBQ0gsQ0FSa0IsRUFBbkI7QUFTQSxRQUFRLFdBQVIsR0FBc0IsV0FBdEI7QUFDQTs7Ozs7QUFLQSxJQUFJLGdCQUFpQixVQUFVLE1BQVYsRUFBa0I7QUFDbkMsY0FBVSxhQUFWLEVBQXlCLE1BQXpCO0FBQ0EsYUFBUyxhQUFULENBQXVCLFdBQXZCLEVBQW9DLE9BQXBDLEVBQTZDLE1BQTdDLEVBQXFEO0FBQ2pELFlBQUksV0FBVyxLQUFLLENBQXBCLEVBQXVCO0FBQUUscUJBQVMsT0FBTyxNQUFQLENBQWMsSUFBZCxDQUFUO0FBQStCO0FBQ3hELGVBQU8sSUFBUCxDQUFZLElBQVosRUFBa0IsV0FBbEI7QUFDQSxhQUFLLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxhQUFLLE1BQUwsR0FBYyxDQUFkO0FBQ0EsYUFBSyxPQUFMLEdBQWdCLE9BQU8sT0FBUCxLQUFtQixVQUFwQixHQUFrQyxPQUFsQyxHQUE0QyxJQUEzRDtBQUNBLGFBQUssTUFBTCxHQUFjLE1BQWQ7QUFDSDtBQUNELGtCQUFjLFNBQWQsQ0FBd0IsS0FBeEIsR0FBZ0MsVUFBVSxLQUFWLEVBQWlCO0FBQzdDLFlBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0EsWUFBSSxVQUFVLE9BQVYsQ0FBa0IsS0FBbEIsQ0FBSixFQUE4QjtBQUMxQixzQkFBVSxJQUFWLENBQWUsSUFBSSxtQkFBSixDQUF3QixLQUF4QixDQUFmO0FBQ0gsU0FGRCxNQUdLLElBQUksT0FBTyxNQUFNLFdBQVcsVUFBakIsQ0FBUCxLQUF3QyxVQUE1QyxFQUF3RDtBQUN6RCxzQkFBVSxJQUFWLENBQWUsSUFBSSxjQUFKLENBQW1CLE1BQU0sV0FBVyxVQUFqQixHQUFuQixDQUFmO0FBQ0gsU0FGSSxNQUdBO0FBQ0Qsc0JBQVUsSUFBVixDQUFlLElBQUksaUJBQUosQ0FBc0IsS0FBSyxXQUEzQixFQUF3QyxJQUF4QyxFQUE4QyxLQUE5QyxDQUFmO0FBQ0g7QUFDSixLQVhEO0FBWUEsa0JBQWMsU0FBZCxDQUF3QixTQUF4QixHQUFvQyxZQUFZO0FBQzVDLFlBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0EsWUFBSSxNQUFNLFVBQVUsTUFBcEI7QUFDQSxhQUFLLE1BQUwsR0FBYyxHQUFkO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLGdCQUFJLFdBQVcsVUFBVSxDQUFWLENBQWY7QUFDQSxnQkFBSSxTQUFTLGlCQUFiLEVBQWdDO0FBQzVCLHFCQUFLLEdBQUwsQ0FBUyxTQUFTLFNBQVQsQ0FBbUIsUUFBbkIsRUFBNkIsQ0FBN0IsQ0FBVDtBQUNILGFBRkQsTUFHSztBQUNELHFCQUFLLE1BQUwsR0FEQyxDQUNjO0FBQ2xCO0FBQ0o7QUFDSixLQWJEO0FBY0Esa0JBQWMsU0FBZCxDQUF3QixjQUF4QixHQUF5QyxZQUFZO0FBQ2pELGFBQUssTUFBTDtBQUNBLFlBQUksS0FBSyxNQUFMLEtBQWdCLENBQXBCLEVBQXVCO0FBQ25CLGlCQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDSDtBQUNKLEtBTEQ7QUFNQSxrQkFBYyxTQUFkLENBQXdCLGNBQXhCLEdBQXlDLFlBQVk7QUFDakQsWUFBSSxZQUFZLEtBQUssU0FBckI7QUFDQSxZQUFJLE1BQU0sVUFBVSxNQUFwQjtBQUNBLFlBQUksY0FBYyxLQUFLLFdBQXZCO0FBQ0E7QUFDQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIsZ0JBQUksV0FBVyxVQUFVLENBQVYsQ0FBZjtBQUNBLGdCQUFJLE9BQU8sU0FBUyxRQUFoQixLQUE2QixVQUE3QixJQUEyQyxDQUFDLFNBQVMsUUFBVCxFQUFoRCxFQUFxRTtBQUNqRTtBQUNIO0FBQ0o7QUFDRCxZQUFJLGlCQUFpQixLQUFyQjtBQUNBLFlBQUksT0FBTyxFQUFYO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLGdCQUFJLFdBQVcsVUFBVSxDQUFWLENBQWY7QUFDQSxnQkFBSSxTQUFTLFNBQVMsSUFBVCxFQUFiO0FBQ0E7QUFDQTtBQUNBLGdCQUFJLFNBQVMsWUFBVCxFQUFKLEVBQTZCO0FBQ3pCLGlDQUFpQixJQUFqQjtBQUNIO0FBQ0QsZ0JBQUksT0FBTyxJQUFYLEVBQWlCO0FBQ2IsNEJBQVksUUFBWjtBQUNBO0FBQ0g7QUFDRCxpQkFBSyxJQUFMLENBQVUsT0FBTyxLQUFqQjtBQUNIO0FBQ0QsWUFBSSxLQUFLLE9BQVQsRUFBa0I7QUFDZCxpQkFBSyxXQUFMLENBQWlCLElBQWpCO0FBQ0gsU0FGRCxNQUdLO0FBQ0Qsd0JBQVksSUFBWixDQUFpQixJQUFqQjtBQUNIO0FBQ0QsWUFBSSxjQUFKLEVBQW9CO0FBQ2hCLHdCQUFZLFFBQVo7QUFDSDtBQUNKLEtBcENEO0FBcUNBLGtCQUFjLFNBQWQsQ0FBd0IsV0FBeEIsR0FBc0MsVUFBVSxJQUFWLEVBQWdCO0FBQ2xELFlBQUksTUFBSjtBQUNBLFlBQUk7QUFDQSxxQkFBUyxLQUFLLE9BQUwsQ0FBYSxLQUFiLENBQW1CLElBQW5CLEVBQXlCLElBQXpCLENBQVQ7QUFDSCxTQUZELENBR0EsT0FBTyxHQUFQLEVBQVk7QUFDUixpQkFBSyxXQUFMLENBQWlCLEtBQWpCLENBQXVCLEdBQXZCO0FBQ0E7QUFDSDtBQUNELGFBQUssV0FBTCxDQUFpQixJQUFqQixDQUFzQixNQUF0QjtBQUNILEtBVkQ7QUFXQSxXQUFPLGFBQVA7QUFDSCxDQTNGb0IsQ0EyRm5CLGFBQWEsVUEzRk0sQ0FBckI7QUE0RkEsUUFBUSxhQUFSLEdBQXdCLGFBQXhCO0FBQ0EsSUFBSSxpQkFBa0IsWUFBWTtBQUM5QixhQUFTLGNBQVQsQ0FBd0IsUUFBeEIsRUFBa0M7QUFDOUIsYUFBSyxRQUFMLEdBQWdCLFFBQWhCO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLFNBQVMsSUFBVCxFQUFsQjtBQUNIO0FBQ0QsbUJBQWUsU0FBZixDQUF5QixRQUF6QixHQUFvQyxZQUFZO0FBQzVDLGVBQU8sSUFBUDtBQUNILEtBRkQ7QUFHQSxtQkFBZSxTQUFmLENBQXlCLElBQXpCLEdBQWdDLFlBQVk7QUFDeEMsWUFBSSxTQUFTLEtBQUssVUFBbEI7QUFDQSxhQUFLLFVBQUwsR0FBa0IsS0FBSyxRQUFMLENBQWMsSUFBZCxFQUFsQjtBQUNBLGVBQU8sTUFBUDtBQUNILEtBSkQ7QUFLQSxtQkFBZSxTQUFmLENBQXlCLFlBQXpCLEdBQXdDLFlBQVk7QUFDaEQsWUFBSSxhQUFhLEtBQUssVUFBdEI7QUFDQSxlQUFPLGNBQWMsV0FBVyxJQUFoQztBQUNILEtBSEQ7QUFJQSxXQUFPLGNBQVA7QUFDSCxDQWxCcUIsRUFBdEI7QUFtQkEsSUFBSSxzQkFBdUIsWUFBWTtBQUNuQyxhQUFTLG1CQUFULENBQTZCLEtBQTdCLEVBQW9DO0FBQ2hDLGFBQUssS0FBTCxHQUFhLEtBQWI7QUFDQSxhQUFLLEtBQUwsR0FBYSxDQUFiO0FBQ0EsYUFBSyxNQUFMLEdBQWMsQ0FBZDtBQUNBLGFBQUssTUFBTCxHQUFjLE1BQU0sTUFBcEI7QUFDSDtBQUNELHdCQUFvQixTQUFwQixDQUE4QixXQUFXLFVBQXpDLElBQXVELFlBQVk7QUFDL0QsZUFBTyxJQUFQO0FBQ0gsS0FGRDtBQUdBLHdCQUFvQixTQUFwQixDQUE4QixJQUE5QixHQUFxQyxVQUFVLEtBQVYsRUFBaUI7QUFDbEQsWUFBSSxJQUFJLEtBQUssS0FBTCxFQUFSO0FBQ0EsWUFBSSxRQUFRLEtBQUssS0FBakI7QUFDQSxlQUFPLElBQUksS0FBSyxNQUFULEdBQWtCLEVBQUUsT0FBTyxNQUFNLENBQU4sQ0FBVCxFQUFtQixNQUFNLEtBQXpCLEVBQWxCLEdBQXFELEVBQUUsT0FBTyxJQUFULEVBQWUsTUFBTSxJQUFyQixFQUE1RDtBQUNILEtBSkQ7QUFLQSx3QkFBb0IsU0FBcEIsQ0FBOEIsUUFBOUIsR0FBeUMsWUFBWTtBQUNqRCxlQUFPLEtBQUssS0FBTCxDQUFXLE1BQVgsR0FBb0IsS0FBSyxLQUFoQztBQUNILEtBRkQ7QUFHQSx3QkFBb0IsU0FBcEIsQ0FBOEIsWUFBOUIsR0FBNkMsWUFBWTtBQUNyRCxlQUFPLEtBQUssS0FBTCxDQUFXLE1BQVgsS0FBc0IsS0FBSyxLQUFsQztBQUNILEtBRkQ7QUFHQSxXQUFPLG1CQUFQO0FBQ0gsQ0F0QjBCLEVBQTNCO0FBdUJBOzs7OztBQUtBLElBQUksb0JBQXFCLFVBQVUsTUFBVixFQUFrQjtBQUN2QyxjQUFVLGlCQUFWLEVBQTZCLE1BQTdCO0FBQ0EsYUFBUyxpQkFBVCxDQUEyQixXQUEzQixFQUF3QyxNQUF4QyxFQUFnRCxVQUFoRCxFQUE0RDtBQUN4RCxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFdBQWxCO0FBQ0EsYUFBSyxNQUFMLEdBQWMsTUFBZDtBQUNBLGFBQUssVUFBTCxHQUFrQixVQUFsQjtBQUNBLGFBQUssaUJBQUwsR0FBeUIsSUFBekI7QUFDQSxhQUFLLE1BQUwsR0FBYyxFQUFkO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLEtBQWxCO0FBQ0g7QUFDRCxzQkFBa0IsU0FBbEIsQ0FBNEIsV0FBVyxVQUF2QyxJQUFxRCxZQUFZO0FBQzdELGVBQU8sSUFBUDtBQUNILEtBRkQ7QUFHQTtBQUNBO0FBQ0Esc0JBQWtCLFNBQWxCLENBQTRCLElBQTVCLEdBQW1DLFlBQVk7QUFDM0MsWUFBSSxTQUFTLEtBQUssTUFBbEI7QUFDQSxZQUFJLE9BQU8sTUFBUCxLQUFrQixDQUFsQixJQUF1QixLQUFLLFVBQWhDLEVBQTRDO0FBQ3hDLG1CQUFPLEVBQUUsT0FBTyxJQUFULEVBQWUsTUFBTSxJQUFyQixFQUFQO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsbUJBQU8sRUFBRSxPQUFPLE9BQU8sS0FBUCxFQUFULEVBQXlCLE1BQU0sS0FBL0IsRUFBUDtBQUNIO0FBQ0osS0FSRDtBQVNBLHNCQUFrQixTQUFsQixDQUE0QixRQUE1QixHQUF1QyxZQUFZO0FBQy9DLGVBQU8sS0FBSyxNQUFMLENBQVksTUFBWixHQUFxQixDQUE1QjtBQUNILEtBRkQ7QUFHQSxzQkFBa0IsU0FBbEIsQ0FBNEIsWUFBNUIsR0FBMkMsWUFBWTtBQUNuRCxlQUFPLEtBQUssTUFBTCxDQUFZLE1BQVosS0FBdUIsQ0FBdkIsSUFBNEIsS0FBSyxVQUF4QztBQUNILEtBRkQ7QUFHQSxzQkFBa0IsU0FBbEIsQ0FBNEIsY0FBNUIsR0FBNkMsWUFBWTtBQUNyRCxZQUFJLEtBQUssTUFBTCxDQUFZLE1BQVosR0FBcUIsQ0FBekIsRUFBNEI7QUFDeEIsaUJBQUssVUFBTCxHQUFrQixJQUFsQjtBQUNBLGlCQUFLLE1BQUwsQ0FBWSxjQUFaO0FBQ0gsU0FIRCxNQUlLO0FBQ0QsaUJBQUssV0FBTCxDQUFpQixRQUFqQjtBQUNIO0FBQ0osS0FSRDtBQVNBLHNCQUFrQixTQUFsQixDQUE0QixVQUE1QixHQUF5QyxVQUFVLFVBQVYsRUFBc0IsVUFBdEIsRUFBa0MsVUFBbEMsRUFBOEMsVUFBOUMsRUFBMEQsUUFBMUQsRUFBb0U7QUFDekcsYUFBSyxNQUFMLENBQVksSUFBWixDQUFpQixVQUFqQjtBQUNBLGFBQUssTUFBTCxDQUFZLGNBQVo7QUFDSCxLQUhEO0FBSUEsc0JBQWtCLFNBQWxCLENBQTRCLFNBQTVCLEdBQXdDLFVBQVUsS0FBVixFQUFpQixLQUFqQixFQUF3QjtBQUM1RCxlQUFPLG9CQUFvQixpQkFBcEIsQ0FBc0MsSUFBdEMsRUFBNEMsS0FBSyxVQUFqRCxFQUE2RCxJQUE3RCxFQUFtRSxLQUFuRSxDQUFQO0FBQ0gsS0FGRDtBQUdBLFdBQU8saUJBQVA7QUFDSCxDQS9Dd0IsQ0ErQ3ZCLGtCQUFrQixlQS9DSyxDQUF6QjtBQWdEQTs7O0FDbFJBOztBQUNBLElBQUksWUFBYSxhQUFRLFVBQUssU0FBZCxJQUE0QixVQUFVLENBQVYsRUFBYSxDQUFiLEVBQWdCO0FBQ3hELFNBQUssSUFBSSxDQUFULElBQWMsQ0FBZDtBQUFpQixZQUFJLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFKLEVBQXlCLEVBQUUsQ0FBRixJQUFPLEVBQUUsQ0FBRixDQUFQO0FBQTFDLEtBQ0EsU0FBUyxFQUFULEdBQWM7QUFBRSxhQUFLLFdBQUwsR0FBbUIsQ0FBbkI7QUFBdUI7QUFDdkMsTUFBRSxTQUFGLEdBQWMsTUFBTSxJQUFOLEdBQWEsT0FBTyxNQUFQLENBQWMsQ0FBZCxDQUFiLElBQWlDLEdBQUcsU0FBSCxHQUFlLEVBQUUsU0FBakIsRUFBNEIsSUFBSSxFQUFKLEVBQTdELENBQWQ7QUFDSCxDQUpEO0FBS0EsSUFBSSxpQkFBaUIsUUFBUSxpQkFBUixDQUFyQjtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBLElBQUksU0FBVSxVQUFVLE1BQVYsRUFBa0I7QUFDNUIsY0FBVSxNQUFWLEVBQWtCLE1BQWxCO0FBQ0EsYUFBUyxNQUFULENBQWdCLFNBQWhCLEVBQTJCLElBQTNCLEVBQWlDO0FBQzdCLGVBQU8sSUFBUCxDQUFZLElBQVo7QUFDSDtBQUNEOzs7Ozs7Ozs7O0FBVUEsV0FBTyxTQUFQLENBQWlCLFFBQWpCLEdBQTRCLFVBQVUsS0FBVixFQUFpQixLQUFqQixFQUF3QjtBQUNoRCxZQUFJLFVBQVUsS0FBSyxDQUFuQixFQUFzQjtBQUFFLG9CQUFRLENBQVI7QUFBWTtBQUNwQyxlQUFPLElBQVA7QUFDSCxLQUhEO0FBSUEsV0FBTyxNQUFQO0FBQ0gsQ0FwQmEsQ0FvQlosZUFBZSxZQXBCSCxDQUFkO0FBcUJBLFFBQVEsTUFBUixHQUFpQixNQUFqQjtBQUNBOzs7QUMzQ0E7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLFNBQVMsUUFBUSxjQUFSLENBQWI7QUFDQSxJQUFJLFdBQVcsUUFBUSxVQUFSLENBQWY7QUFDQTs7Ozs7QUFLQSxJQUFJLGNBQWUsVUFBVSxNQUFWLEVBQWtCO0FBQ2pDLGNBQVUsV0FBVixFQUF1QixNQUF2QjtBQUNBLGFBQVMsV0FBVCxDQUFxQixTQUFyQixFQUFnQyxJQUFoQyxFQUFzQztBQUNsQyxlQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLFNBQWxCLEVBQTZCLElBQTdCO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0EsYUFBSyxJQUFMLEdBQVksSUFBWjtBQUNBLGFBQUssT0FBTCxHQUFlLEtBQWY7QUFDSDtBQUNELGdCQUFZLFNBQVosQ0FBc0IsUUFBdEIsR0FBaUMsVUFBVSxLQUFWLEVBQWlCLEtBQWpCLEVBQXdCO0FBQ3JELFlBQUksVUFBVSxLQUFLLENBQW5CLEVBQXNCO0FBQUUsb0JBQVEsQ0FBUjtBQUFZO0FBQ3BDLFlBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2IsbUJBQU8sSUFBUDtBQUNIO0FBQ0Q7QUFDQSxhQUFLLEtBQUwsR0FBYSxLQUFiO0FBQ0E7QUFDQTtBQUNBLGFBQUssT0FBTCxHQUFlLElBQWY7QUFDQSxZQUFJLEtBQUssS0FBSyxFQUFkO0FBQ0EsWUFBSSxZQUFZLEtBQUssU0FBckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJLE1BQU0sSUFBVixFQUFnQjtBQUNaLGlCQUFLLEVBQUwsR0FBVSxLQUFLLGNBQUwsQ0FBb0IsU0FBcEIsRUFBK0IsRUFBL0IsRUFBbUMsS0FBbkMsQ0FBVjtBQUNIO0FBQ0QsYUFBSyxLQUFMLEdBQWEsS0FBYjtBQUNBO0FBQ0EsYUFBSyxFQUFMLEdBQVUsS0FBSyxFQUFMLElBQVcsS0FBSyxjQUFMLENBQW9CLFNBQXBCLEVBQStCLEtBQUssRUFBcEMsRUFBd0MsS0FBeEMsQ0FBckI7QUFDQSxlQUFPLElBQVA7QUFDSCxLQXhDRDtBQXlDQSxnQkFBWSxTQUFaLENBQXNCLGNBQXRCLEdBQXVDLFVBQVUsU0FBVixFQUFxQixFQUFyQixFQUF5QixLQUF6QixFQUFnQztBQUNuRSxZQUFJLFVBQVUsS0FBSyxDQUFuQixFQUFzQjtBQUFFLG9CQUFRLENBQVI7QUFBWTtBQUNwQyxlQUFPLE9BQU8sSUFBUCxDQUFZLFdBQVosQ0FBd0IsVUFBVSxLQUFWLENBQWdCLElBQWhCLENBQXFCLFNBQXJCLEVBQWdDLElBQWhDLENBQXhCLEVBQStELEtBQS9ELENBQVA7QUFDSCxLQUhEO0FBSUEsZ0JBQVksU0FBWixDQUFzQixjQUF0QixHQUF1QyxVQUFVLFNBQVYsRUFBcUIsRUFBckIsRUFBeUIsS0FBekIsRUFBZ0M7QUFDbkUsWUFBSSxVQUFVLEtBQUssQ0FBbkIsRUFBc0I7QUFBRSxvQkFBUSxDQUFSO0FBQVk7QUFDcEM7QUFDQSxZQUFJLFVBQVUsSUFBVixJQUFrQixLQUFLLEtBQUwsS0FBZSxLQUFyQyxFQUE0QztBQUN4QyxtQkFBTyxFQUFQO0FBQ0g7QUFDRDtBQUNBO0FBQ0EsZUFBTyxPQUFPLElBQVAsQ0FBWSxhQUFaLENBQTBCLEVBQTFCLEtBQWlDLFNBQWpDLElBQThDLFNBQXJEO0FBQ0gsS0FURDtBQVVBOzs7O0FBSUEsZ0JBQVksU0FBWixDQUFzQixPQUF0QixHQUFnQyxVQUFVLEtBQVYsRUFBaUIsS0FBakIsRUFBd0I7QUFDcEQsWUFBSSxLQUFLLE1BQVQsRUFBaUI7QUFDYixtQkFBTyxJQUFJLEtBQUosQ0FBVSw4QkFBVixDQUFQO0FBQ0g7QUFDRCxhQUFLLE9BQUwsR0FBZSxLQUFmO0FBQ0EsWUFBSSxRQUFRLEtBQUssUUFBTCxDQUFjLEtBQWQsRUFBcUIsS0FBckIsQ0FBWjtBQUNBLFlBQUksS0FBSixFQUFXO0FBQ1AsbUJBQU8sS0FBUDtBQUNILFNBRkQsTUFHSyxJQUFJLEtBQUssT0FBTCxLQUFpQixLQUFqQixJQUEwQixLQUFLLEVBQUwsSUFBVyxJQUF6QyxFQUErQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFLLEVBQUwsR0FBVSxLQUFLLGNBQUwsQ0FBb0IsS0FBSyxTQUF6QixFQUFvQyxLQUFLLEVBQXpDLEVBQTZDLElBQTdDLENBQVY7QUFDSDtBQUNKLEtBekJEO0FBMEJBLGdCQUFZLFNBQVosQ0FBc0IsUUFBdEIsR0FBaUMsVUFBVSxLQUFWLEVBQWlCLEtBQWpCLEVBQXdCO0FBQ3JELFlBQUksVUFBVSxLQUFkO0FBQ0EsWUFBSSxhQUFhLFNBQWpCO0FBQ0EsWUFBSTtBQUNBLGlCQUFLLElBQUwsQ0FBVSxLQUFWO0FBQ0gsU0FGRCxDQUdBLE9BQU8sQ0FBUCxFQUFVO0FBQ04sc0JBQVUsSUFBVjtBQUNBLHlCQUFhLENBQUMsQ0FBQyxDQUFGLElBQU8sQ0FBUCxJQUFZLElBQUksS0FBSixDQUFVLENBQVYsQ0FBekI7QUFDSDtBQUNELFlBQUksT0FBSixFQUFhO0FBQ1QsaUJBQUssV0FBTDtBQUNBLG1CQUFPLFVBQVA7QUFDSDtBQUNKLEtBZEQ7QUFlQSxnQkFBWSxTQUFaLENBQXNCLFlBQXRCLEdBQXFDLFlBQVk7QUFDN0MsWUFBSSxLQUFLLEtBQUssRUFBZDtBQUNBLFlBQUksWUFBWSxLQUFLLFNBQXJCO0FBQ0EsWUFBSSxVQUFVLFVBQVUsT0FBeEI7QUFDQSxZQUFJLFFBQVEsUUFBUSxPQUFSLENBQWdCLElBQWhCLENBQVo7QUFDQSxhQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsYUFBSyxLQUFMLEdBQWEsSUFBYjtBQUNBLGFBQUssS0FBTCxHQUFhLElBQWI7QUFDQSxhQUFLLE9BQUwsR0FBZSxLQUFmO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsWUFBSSxVQUFVLENBQUMsQ0FBZixFQUFrQjtBQUNkLG9CQUFRLE1BQVIsQ0FBZSxLQUFmLEVBQXNCLENBQXRCO0FBQ0g7QUFDRCxZQUFJLE1BQU0sSUFBVixFQUFnQjtBQUNaLGlCQUFLLEVBQUwsR0FBVSxLQUFLLGNBQUwsQ0FBb0IsU0FBcEIsRUFBK0IsRUFBL0IsRUFBbUMsSUFBbkMsQ0FBVjtBQUNIO0FBQ0osS0FoQkQ7QUFpQkEsV0FBTyxXQUFQO0FBQ0gsQ0E5SGtCLENBOEhqQixTQUFTLE1BOUhRLENBQW5CO0FBK0hBLFFBQVEsV0FBUixHQUFzQixXQUF0QjtBQUNBOzs7QUM3SUE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQSxJQUFJLGNBQWMsUUFBUSxjQUFSLENBQWxCO0FBQ0EsSUFBSSxpQkFBa0IsVUFBVSxNQUFWLEVBQWtCO0FBQ3BDLGNBQVUsY0FBVixFQUEwQixNQUExQjtBQUNBLGFBQVMsY0FBVCxHQUEwQjtBQUN0QixlQUFPLEtBQVAsQ0FBYSxJQUFiLEVBQW1CLFNBQW5CO0FBQ0EsYUFBSyxPQUFMLEdBQWUsRUFBZjtBQUNBOzs7OztBQUtBLGFBQUssTUFBTCxHQUFjLEtBQWQ7QUFDQTs7Ozs7O0FBTUEsYUFBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0g7QUFDRCxtQkFBZSxTQUFmLENBQXlCLEtBQXpCLEdBQWlDLFVBQVUsTUFBVixFQUFrQjtBQUMvQyxZQUFJLFVBQVUsS0FBSyxPQUFuQjtBQUNBLFlBQUksS0FBSyxNQUFULEVBQWlCO0FBQ2Isb0JBQVEsSUFBUixDQUFhLE1BQWI7QUFDQTtBQUNIO0FBQ0QsWUFBSSxLQUFKO0FBQ0EsYUFBSyxNQUFMLEdBQWMsSUFBZDtBQUNBLFdBQUc7QUFDQyxnQkFBSSxRQUFRLE9BQU8sT0FBUCxDQUFlLE9BQU8sS0FBdEIsRUFBNkIsT0FBTyxLQUFwQyxDQUFaLEVBQXdEO0FBQ3BEO0FBQ0g7QUFDSixTQUpELFFBSVMsU0FBUyxRQUFRLEtBQVIsRUFKbEIsRUFSK0MsQ0FZWDtBQUNwQyxhQUFLLE1BQUwsR0FBYyxLQUFkO0FBQ0EsWUFBSSxLQUFKLEVBQVc7QUFDUCxtQkFBTyxTQUFTLFFBQVEsS0FBUixFQUFoQixFQUFpQztBQUM3Qix1QkFBTyxXQUFQO0FBQ0g7QUFDRCxrQkFBTSxLQUFOO0FBQ0g7QUFDSixLQXBCRDtBQXFCQSxXQUFPLGNBQVA7QUFDSCxDQXpDcUIsQ0F5Q3BCLFlBQVksU0F6Q1EsQ0FBdEI7QUEwQ0EsUUFBUSxjQUFSLEdBQXlCLGNBQXpCO0FBQ0E7Ozs7O0FDbERBOztBQUNBLElBQUksU0FBUyxRQUFRLGNBQVIsQ0FBYjtBQUNBLFNBQVMsc0JBQVQsQ0FBZ0MsSUFBaEMsRUFBc0M7QUFDbEMsUUFBSSxVQUFTLEtBQUssTUFBbEI7QUFDQSxRQUFJLE9BQU8sT0FBUCxLQUFrQixVQUF0QixFQUFrQztBQUM5QixZQUFJLENBQUMsUUFBTyxRQUFaLEVBQXNCO0FBQ2xCLG9CQUFPLFFBQVAsR0FBa0IsUUFBTyxtQkFBUCxDQUFsQjtBQUNIO0FBQ0QsZUFBTyxRQUFPLFFBQWQ7QUFDSCxLQUxELE1BTUs7QUFDRDtBQUNBLFlBQUksUUFBUSxLQUFLLEdBQWpCO0FBQ0EsWUFBSSxTQUFTLE9BQU8sSUFBSSxLQUFKLEdBQVksWUFBWixDQUFQLEtBQXFDLFVBQWxELEVBQThEO0FBQzFELG1CQUFPLFlBQVA7QUFDSDtBQUNELFlBQUksUUFBUSxLQUFLLEdBQWpCO0FBQ0E7QUFDQSxZQUFJLEtBQUosRUFBVztBQUNQLGdCQUFJLE9BQU8sT0FBTyxtQkFBUCxDQUEyQixNQUFNLFNBQWpDLENBQVg7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssTUFBekIsRUFBaUMsRUFBRSxDQUFuQyxFQUFzQztBQUNsQyxvQkFBSSxNQUFNLEtBQUssQ0FBTCxDQUFWO0FBQ0E7QUFDQSxvQkFBSSxRQUFRLFNBQVIsSUFBcUIsUUFBUSxNQUE3QixJQUF1QyxNQUFNLFNBQU4sQ0FBZ0IsR0FBaEIsTUFBeUIsTUFBTSxTQUFOLENBQWdCLFNBQWhCLENBQXBFLEVBQWdHO0FBQzVGLDJCQUFPLEdBQVA7QUFDSDtBQUNKO0FBQ0o7QUFDRCxlQUFPLFlBQVA7QUFDSDtBQUNKO0FBQ0QsUUFBUSxzQkFBUixHQUFpQyxzQkFBakM7QUFDQSxRQUFRLFVBQVIsR0FBcUIsdUJBQXVCLE9BQU8sSUFBOUIsQ0FBckI7QUFDQTs7O0FDakNBOztBQUNBLElBQUksU0FBUyxRQUFRLGNBQVIsQ0FBYjtBQUNBLFNBQVMsbUJBQVQsQ0FBNkIsT0FBN0IsRUFBc0M7QUFDbEMsUUFBSSxZQUFKO0FBQ0EsUUFBSSxVQUFTLFFBQVEsTUFBckI7QUFDQSxRQUFJLE9BQU8sT0FBUCxLQUFrQixVQUF0QixFQUFrQztBQUM5QixZQUFJLFFBQU8sVUFBWCxFQUF1QjtBQUNuQiwyQkFBZSxRQUFPLFVBQXRCO0FBQ0gsU0FGRCxNQUdLO0FBQ0QsMkJBQWUsUUFBTyxZQUFQLENBQWY7QUFDQSxvQkFBTyxVQUFQLEdBQW9CLFlBQXBCO0FBQ0g7QUFDSixLQVJELE1BU0s7QUFDRCx1QkFBZSxjQUFmO0FBQ0g7QUFDRCxXQUFPLFlBQVA7QUFDSDtBQUNELFFBQVEsbUJBQVIsR0FBOEIsbUJBQTlCO0FBQ0EsUUFBUSxZQUFSLEdBQXVCLG9CQUFvQixPQUFPLElBQTNCLENBQXZCO0FBQ0E7OztBQ3JCQTs7QUFDQSxJQUFJLFNBQVMsUUFBUSxjQUFSLENBQWI7QUFDQSxJQUFJLFVBQVMsT0FBTyxJQUFQLENBQVksTUFBekI7QUFDQSxRQUFRLGNBQVIsR0FBMEIsT0FBTyxPQUFQLEtBQWtCLFVBQWxCLElBQWdDLE9BQU8sUUFBTyxHQUFkLEtBQXNCLFVBQXZELEdBQ3JCLFFBQU8sR0FBUCxDQUFXLGNBQVgsQ0FEcUIsR0FDUSxnQkFEakM7QUFFQTs7O0FDTEE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQTs7Ozs7Ozs7OztBQVVBLElBQUksMEJBQTJCLFVBQVUsTUFBVixFQUFrQjtBQUM3QyxjQUFVLHVCQUFWLEVBQW1DLE1BQW5DO0FBQ0EsYUFBUyx1QkFBVCxHQUFtQztBQUMvQixZQUFJLE1BQU0sT0FBTyxJQUFQLENBQVksSUFBWixFQUFrQix1QkFBbEIsQ0FBVjtBQUNBLGFBQUssSUFBTCxHQUFZLElBQUksSUFBSixHQUFXLHlCQUF2QjtBQUNBLGFBQUssS0FBTCxHQUFhLElBQUksS0FBakI7QUFDQSxhQUFLLE9BQUwsR0FBZSxJQUFJLE9BQW5CO0FBQ0g7QUFDRCxXQUFPLHVCQUFQO0FBQ0gsQ0FUOEIsQ0FTN0IsS0FUNkIsQ0FBL0I7QUFVQSxRQUFRLHVCQUFSLEdBQWtDLHVCQUFsQztBQUNBOzs7QUMzQkE7O0FBQ0EsSUFBSSxZQUFhLGFBQVEsVUFBSyxTQUFkLElBQTRCLFVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0I7QUFDeEQsU0FBSyxJQUFJLENBQVQsSUFBYyxDQUFkO0FBQWlCLFlBQUksRUFBRSxjQUFGLENBQWlCLENBQWpCLENBQUosRUFBeUIsRUFBRSxDQUFGLElBQU8sRUFBRSxDQUFGLENBQVA7QUFBMUMsS0FDQSxTQUFTLEVBQVQsR0FBYztBQUFFLGFBQUssV0FBTCxHQUFtQixDQUFuQjtBQUF1QjtBQUN2QyxNQUFFLFNBQUYsR0FBYyxNQUFNLElBQU4sR0FBYSxPQUFPLE1BQVAsQ0FBYyxDQUFkLENBQWIsSUFBaUMsR0FBRyxTQUFILEdBQWUsRUFBRSxTQUFqQixFQUE0QixJQUFJLEVBQUosRUFBN0QsQ0FBZDtBQUNILENBSkQ7QUFLQTs7Ozs7Ozs7O0FBU0EsSUFBSSwwQkFBMkIsVUFBVSxNQUFWLEVBQWtCO0FBQzdDLGNBQVUsdUJBQVYsRUFBbUMsTUFBbkM7QUFDQSxhQUFTLHVCQUFULEdBQW1DO0FBQy9CLFlBQUksTUFBTSxPQUFPLElBQVAsQ0FBWSxJQUFaLEVBQWtCLHFCQUFsQixDQUFWO0FBQ0EsYUFBSyxJQUFMLEdBQVksSUFBSSxJQUFKLEdBQVcseUJBQXZCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsSUFBSSxLQUFqQjtBQUNBLGFBQUssT0FBTCxHQUFlLElBQUksT0FBbkI7QUFDSDtBQUNELFdBQU8sdUJBQVA7QUFDSCxDQVQ4QixDQVM3QixLQVQ2QixDQUEvQjtBQVVBLFFBQVEsdUJBQVIsR0FBa0MsdUJBQWxDO0FBQ0E7OztBQzFCQTs7QUFDQSxJQUFJLFlBQWEsYUFBUSxVQUFLLFNBQWQsSUFBNEIsVUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQjtBQUN4RCxTQUFLLElBQUksQ0FBVCxJQUFjLENBQWQ7QUFBaUIsWUFBSSxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSixFQUF5QixFQUFFLENBQUYsSUFBTyxFQUFFLENBQUYsQ0FBUDtBQUExQyxLQUNBLFNBQVMsRUFBVCxHQUFjO0FBQUUsYUFBSyxXQUFMLEdBQW1CLENBQW5CO0FBQXVCO0FBQ3ZDLE1BQUUsU0FBRixHQUFjLE1BQU0sSUFBTixHQUFhLE9BQU8sTUFBUCxDQUFjLENBQWQsQ0FBYixJQUFpQyxHQUFHLFNBQUgsR0FBZSxFQUFFLFNBQWpCLEVBQTRCLElBQUksRUFBSixFQUE3RCxDQUFkO0FBQ0gsQ0FKRDtBQUtBOzs7O0FBSUEsSUFBSSxzQkFBdUIsVUFBVSxNQUFWLEVBQWtCO0FBQ3pDLGNBQVUsbUJBQVYsRUFBK0IsTUFBL0I7QUFDQSxhQUFTLG1CQUFULENBQTZCLE1BQTdCLEVBQXFDO0FBQ2pDLGVBQU8sSUFBUCxDQUFZLElBQVo7QUFDQSxhQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0EsWUFBSSxNQUFNLE1BQU0sSUFBTixDQUFXLElBQVgsRUFBaUIsU0FDdkIsT0FBTyxNQUFQLEdBQWdCLDZDQUFoQixHQUFnRSxPQUFPLEdBQVAsQ0FBVyxVQUFVLEdBQVYsRUFBZSxDQUFmLEVBQWtCO0FBQUUsbUJBQVMsSUFBSSxDQUFMLEdBQVUsSUFBVixHQUFpQixJQUFJLFFBQUosRUFBekI7QUFBMkMsU0FBMUUsRUFBNEUsSUFBNUUsQ0FBaUYsTUFBakYsQ0FEekMsR0FDb0ksRUFEckosQ0FBVjtBQUVBLGFBQUssSUFBTCxHQUFZLElBQUksSUFBSixHQUFXLHFCQUF2QjtBQUNBLGFBQUssS0FBTCxHQUFhLElBQUksS0FBakI7QUFDQSxhQUFLLE9BQUwsR0FBZSxJQUFJLE9BQW5CO0FBQ0g7QUFDRCxXQUFPLG1CQUFQO0FBQ0gsQ0FaMEIsQ0FZekIsS0FaeUIsQ0FBM0I7QUFhQSxRQUFRLG1CQUFSLEdBQThCLG1CQUE5QjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUN4QkE7Ozs7QUFDQSxTQUFTLFFBQVQsQ0FBa0IsQ0FBbEIsRUFBcUI7QUFDakIsV0FBTyxLQUFLLElBQUwsSUFBYSxRQUFPLENBQVAseUNBQU8sQ0FBUCxPQUFhLFFBQWpDO0FBQ0g7QUFDRCxRQUFRLFFBQVIsR0FBbUIsUUFBbkI7QUFDQTs7Ozs7Ozs7QUNMQTtBQUNBOzs7Ozs7OztBQUtBLFFBQVEsSUFBUixHQUFnQixRQUFPLE1BQVAseUNBQU8sTUFBUCxNQUFpQixRQUFqQixJQUE2QixPQUFPLE1BQVAsS0FBa0IsTUFBL0MsSUFBeUQsTUFBekQsSUFDVCxRQUFPLElBQVAseUNBQU8sSUFBUCxNQUFlLFFBQWYsSUFBMkIsS0FBSyxJQUFMLEtBQWMsSUFBekMsSUFBaUQsSUFEeEMsSUFFVCxRQUFPLE1BQVAseUNBQU8sTUFBUCxNQUFpQixRQUFqQixJQUE2QixPQUFPLE1BQVAsS0FBa0IsTUFBL0MsSUFBeUQsTUFGaEU7QUFHQSxJQUFJLENBQUMsUUFBUSxJQUFiLEVBQW1CO0FBQ2YsVUFBTSxJQUFJLEtBQUosQ0FBVSwrREFBVixDQUFOO0FBQ0g7QUFDRDs7Ozs7QUNaQTs7QUFDQSxJQUFJLFNBQVMsUUFBUSxRQUFSLENBQWI7QUFDQSxJQUFJLGdCQUFnQixRQUFRLGVBQVIsQ0FBcEI7QUFDQSxJQUFJLGNBQWMsUUFBUSxhQUFSLENBQWxCO0FBQ0EsSUFBSSxhQUFhLFFBQVEsWUFBUixDQUFqQjtBQUNBLElBQUksZUFBZSxRQUFRLGVBQVIsQ0FBbkI7QUFDQSxJQUFJLGFBQWEsUUFBUSxvQkFBUixDQUFqQjtBQUNBLElBQUksb0JBQW9CLFFBQVEsb0JBQVIsQ0FBeEI7QUFDQSxJQUFJLGVBQWUsUUFBUSxzQkFBUixDQUFuQjtBQUNBLFNBQVMsaUJBQVQsQ0FBMkIsZUFBM0IsRUFBNEMsTUFBNUMsRUFBb0QsVUFBcEQsRUFBZ0UsVUFBaEUsRUFBNEU7QUFDeEUsUUFBSSxjQUFjLElBQUksa0JBQWtCLGVBQXRCLENBQXNDLGVBQXRDLEVBQXVELFVBQXZELEVBQW1FLFVBQW5FLENBQWxCO0FBQ0EsUUFBSSxZQUFZLE1BQWhCLEVBQXdCO0FBQ3BCLGVBQU8sSUFBUDtBQUNIO0FBQ0QsUUFBSSxrQkFBa0IsYUFBYSxVQUFuQyxFQUErQztBQUMzQyxZQUFJLE9BQU8sU0FBWCxFQUFzQjtBQUNsQix3QkFBWSxJQUFaLENBQWlCLE9BQU8sS0FBeEI7QUFDQSx3QkFBWSxRQUFaO0FBQ0EsbUJBQU8sSUFBUDtBQUNILFNBSkQsTUFLSztBQUNELG1CQUFPLE9BQU8sU0FBUCxDQUFpQixXQUFqQixDQUFQO0FBQ0g7QUFDSixLQVRELE1BVUssSUFBSSxjQUFjLFdBQWQsQ0FBMEIsTUFBMUIsQ0FBSixFQUF1QztBQUN4QyxhQUFLLElBQUksSUFBSSxDQUFSLEVBQVcsTUFBTSxPQUFPLE1BQTdCLEVBQXFDLElBQUksR0FBSixJQUFXLENBQUMsWUFBWSxNQUE3RCxFQUFxRSxHQUFyRSxFQUEwRTtBQUN0RSx3QkFBWSxJQUFaLENBQWlCLE9BQU8sQ0FBUCxDQUFqQjtBQUNIO0FBQ0QsWUFBSSxDQUFDLFlBQVksTUFBakIsRUFBeUI7QUFDckIsd0JBQVksUUFBWjtBQUNIO0FBQ0osS0FQSSxNQVFBLElBQUksWUFBWSxTQUFaLENBQXNCLE1BQXRCLENBQUosRUFBbUM7QUFDcEMsZUFBTyxJQUFQLENBQVksVUFBVSxLQUFWLEVBQWlCO0FBQ3pCLGdCQUFJLENBQUMsWUFBWSxNQUFqQixFQUF5QjtBQUNyQiw0QkFBWSxJQUFaLENBQWlCLEtBQWpCO0FBQ0EsNEJBQVksUUFBWjtBQUNIO0FBQ0osU0FMRCxFQUtHLFVBQVUsR0FBVixFQUFlO0FBQUUsbUJBQU8sWUFBWSxLQUFaLENBQWtCLEdBQWxCLENBQVA7QUFBZ0MsU0FMcEQsRUFNSyxJQU5MLENBTVUsSUFOVixFQU1nQixVQUFVLEdBQVYsRUFBZTtBQUMzQjtBQUNBLG1CQUFPLElBQVAsQ0FBWSxVQUFaLENBQXVCLFlBQVk7QUFBRSxzQkFBTSxHQUFOO0FBQVksYUFBakQ7QUFDSCxTQVREO0FBVUEsZUFBTyxXQUFQO0FBQ0gsS0FaSSxNQWFBLElBQUksVUFBVSxPQUFPLE9BQU8sV0FBVyxVQUFsQixDQUFQLEtBQXlDLFVBQXZELEVBQW1FO0FBQ3BFLFlBQUksV0FBVyxPQUFPLFdBQVcsVUFBbEIsR0FBZjtBQUNBLFdBQUc7QUFDQyxnQkFBSSxPQUFPLFNBQVMsSUFBVCxFQUFYO0FBQ0EsZ0JBQUksS0FBSyxJQUFULEVBQWU7QUFDWCw0QkFBWSxRQUFaO0FBQ0E7QUFDSDtBQUNELHdCQUFZLElBQVosQ0FBaUIsS0FBSyxLQUF0QjtBQUNBLGdCQUFJLFlBQVksTUFBaEIsRUFBd0I7QUFDcEI7QUFDSDtBQUNKLFNBVkQsUUFVUyxJQVZUO0FBV0gsS0FiSSxNQWNBLElBQUksVUFBVSxPQUFPLE9BQU8sYUFBYSxZQUFwQixDQUFQLEtBQTZDLFVBQTNELEVBQXVFO0FBQ3hFLFlBQUksTUFBTSxPQUFPLGFBQWEsWUFBcEIsR0FBVjtBQUNBLFlBQUksT0FBTyxJQUFJLFNBQVgsS0FBeUIsVUFBN0IsRUFBeUM7QUFDckMsd0JBQVksS0FBWixDQUFrQixJQUFJLFNBQUosQ0FBYyxnRUFBZCxDQUFsQjtBQUNILFNBRkQsTUFHSztBQUNELG1CQUFPLElBQUksU0FBSixDQUFjLElBQUksa0JBQWtCLGVBQXRCLENBQXNDLGVBQXRDLEVBQXVELFVBQXZELEVBQW1FLFVBQW5FLENBQWQsQ0FBUDtBQUNIO0FBQ0osS0FSSSxNQVNBO0FBQ0QsWUFBSSxRQUFRLFdBQVcsUUFBWCxDQUFvQixNQUFwQixJQUE4QixtQkFBOUIsR0FBb0QsTUFBTSxNQUFOLEdBQWUsR0FBL0U7QUFDQSxZQUFJLE1BQU8sa0JBQWtCLEtBQWxCLEdBQTBCLCtCQUEzQixHQUNKLDhEQUROO0FBRUEsb0JBQVksS0FBWixDQUFrQixJQUFJLFNBQUosQ0FBYyxHQUFkLENBQWxCO0FBQ0g7QUFDRCxXQUFPLElBQVA7QUFDSDtBQUNELFFBQVEsaUJBQVIsR0FBNEIsaUJBQTVCO0FBQ0E7OztBQzdFQTs7QUFDQSxJQUFJLGVBQWUsUUFBUSxlQUFSLENBQW5CO0FBQ0EsSUFBSSxpQkFBaUIsUUFBUSx3QkFBUixDQUFyQjtBQUNBLElBQUksYUFBYSxRQUFRLGFBQVIsQ0FBakI7QUFDQSxTQUFTLFlBQVQsQ0FBc0IsY0FBdEIsRUFBc0MsS0FBdEMsRUFBNkMsUUFBN0MsRUFBdUQ7QUFDbkQsUUFBSSxjQUFKLEVBQW9CO0FBQ2hCLFlBQUksMEJBQTBCLGFBQWEsVUFBM0MsRUFBdUQ7QUFDbkQsbUJBQU8sY0FBUDtBQUNIO0FBQ0QsWUFBSSxlQUFlLGVBQWUsY0FBOUIsQ0FBSixFQUFtRDtBQUMvQyxtQkFBTyxlQUFlLGVBQWUsY0FBOUIsR0FBUDtBQUNIO0FBQ0o7QUFDRCxRQUFJLENBQUMsY0FBRCxJQUFtQixDQUFDLEtBQXBCLElBQTZCLENBQUMsUUFBbEMsRUFBNEM7QUFDeEMsZUFBTyxJQUFJLGFBQWEsVUFBakIsQ0FBNEIsV0FBVyxLQUF2QyxDQUFQO0FBQ0g7QUFDRCxXQUFPLElBQUksYUFBYSxVQUFqQixDQUE0QixjQUE1QixFQUE0QyxLQUE1QyxFQUFtRCxRQUFuRCxDQUFQO0FBQ0g7QUFDRCxRQUFRLFlBQVIsR0FBdUIsWUFBdkI7QUFDQTs7Ozs7Ozs7OztRLEFDUmdCLGEsQUFBQTtRLEFBMEJBLFksQUFBQTtRLEFBVUEsUyxBQUFBO1EsQUFTQSxVLEFBQUE7USxBQWVBLG1CLEFBQUE7USxBQWVBLG1CLEFBQUE7USxBQWVBLGtCLEFBQUE7USxBQU9BLGdCLEFBQUE7USxBQUlBLGUsQUFBQTtRLEFBSUEsYyxBQUFBO1EsQUFtQkEscUIsQUFBQTs7QUFwSWhCOztBQUVBOzs7Ozs7QUFNTyxTQUFBLEFBQVMsV0FBVCxBQUFvQixLQUFLLEFBQzlCO01BQU0sUUFBUSxJQUFBLEFBQUksTUFEWSxBQUM5QixBQUFjLEFBQVUsK0RBQStELEFBRXZGOztNQUFJLE9BQU8sTUFBUCxBQUFPLEFBQU0sT0FBYixBQUFvQixZQUNwQixNQUFBLEFBQU0sR0FBTixBQUFTLFNBRFQsQUFDa0IsS0FDbEIsTUFBQSxBQUFNLEdBQU4sQUFBUyxrQkFBa0IsT0FBQSxBQUFPLFNBRnRDLEFBRStDLFVBQzNDLEFBQ0Y7V0FBQSxBQUFPLEFBQ1I7QUFFRDs7TUFBTSxPQUFPLEVBQUUsTUFBRixBQUFRLElBQUksT0FBWixBQUFtQixNQUFNLE9BQUEsQUFBTyxTQUE3QyxBQUFhLEFBQXlDLEFBRXREOztNQUFJLE9BQU8sTUFBUCxBQUFPLEFBQU0sT0FBYixBQUFvQixZQUN0QixNQUFBLEFBQU0sR0FBTixBQUFTLFNBRFAsQUFDZ0IsS0FDbEIsTUFBQSxBQUFNLEdBQU4sQUFBUyxRQUFRLElBQUEsQUFBSSxjQUFKLEFBQWdCLE9BQWpDLFFBQUEsQUFBNkMsUUFBUSxPQUFBLEFBQU8sU0FGOUQsQUFFdUUsTUFBTSxBQUMzRTtXQUFBLEFBQU8sQUFDUjtBQUVEOztTQUFBLEFBQU8sQUFDUjs7O0FBRUQ7Ozs7O0FBaENBO0FBQ0E7O0FBb0NPLFNBQUEsQUFBUyxVQUFULEFBQW1CLE1BQU0sQUFDOUI7U0FBTyxLQUFBLEFBQUssUUFBTCxBQUFhLE9BQXBCLEFBQU8sQUFBb0IsQUFDNUI7OztBQUVEOzs7Ozs7QUFNTyxTQUFBLEFBQVMsT0FBVCxBQUFnQixNQUFoQixBQUFzQixNQUFNLEFBQ2pDO01BQU0sSUFBSSxRQUFRLE9BQUEsQUFBTyxTQUF6QixBQUFrQyxBQUVsQzs7TUFBTSxVQUFVLEtBQUEsQUFBSyxRQUFMLEFBQWEsT0FBTyxDQUFwQyxBQUFxQyxBQUNyQztNQUFNLFdBQVcsVUFBQSxBQUFVLFVBQVUsVUFBckMsQUFBcUMsQUFBVSxBQUUvQzs7U0FBUSxXQUFSLEFBQW1CLEFBQ3BCOzs7QUFFTSxTQUFBLEFBQVMsUUFBVCxBQUFpQixJQUFqQixBQUFxQixVQUFVLEFBQ3BDO1NBQU8sQ0FBQyxHQUFBLEFBQUcsV0FBVyxHQUFkLEFBQWlCLG1CQUFtQixHQUFwQyxBQUF1QyxxQkFBcUIsR0FBNUQsQUFBK0Qsc0JBQ3JFLEdBRE0sQUFDSCx5QkFBeUIsR0FEdkIsQUFDMEIsa0JBRDFCLEFBQzRDLEtBRDVDLEFBQ2lELElBRHhELEFBQU8sQUFDcUQsQUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7O0FBRU0sU0FBQSxBQUFTLGlCQUFULEFBQTBCLElBQTFCLEFBQThCLFVBQVUsQUFDN0M7TUFBSSxPQUFKLEFBQVcsQUFDWDtTQUFPLFNBQUEsQUFBUyxZQUFZLFNBQVMsU0FBckMsQUFBOEMsaUJBQWlCLEFBQzdEO1FBQUksUUFBQSxBQUFRLE1BQVosQUFBSSxBQUFjLFdBQVcsT0FBQSxBQUFPLEFBQ3BDO1dBQU8sS0FBUCxBQUFZLEFBQ2I7QUFDRDtTQUFBLEFBQU8sQUFDUjs7O0FBRUQ7Ozs7OztBQU1PLFNBQUEsQUFBUyxpQkFBVCxBQUEwQixRQUExQixBQUFrQyxXQUFsQyxBQUE2QyxXQUFXLEFBQzdEO01BQU0sT0FBTyxPQUFiLEFBQW9CLEFBQ3BCO0FBQ0E7QUFDQTtTQUNFLENBQUMsV0FBRCxBQUFDLEFBQVcsU0FDWixDQUFDLE9BREQsQUFDQyxBQUFPLFNBQ1IsQ0FBQyxRQUFBLEFBQVEsUUFGVCxBQUVDLEFBQWdCLGNBQ2pCLE9BQUEsQUFBTyxXQUhQLEFBR2tCLE9BQ2hCLGNBQUEsQUFBYyxRQUNkLEtBQUEsQUFBSyxPQUFMLEFBQVksZUFBZSxDQU4vQixBQUNFLEFBSzhCLEFBR2pDOzs7QUFFTSxTQUFBLEFBQVMsa0JBQWtCLEFBQ2hDO01BQU0sSUFBSSxTQUFWLEFBQW1CLEFBQ25CO01BQU0sSUFBSSxTQUFWLEFBQW1CLEFBQ25CO01BQU0sS0FBTixBQUFXLEFBQ1g7U0FBTyxFQUFBLEFBQUUsT0FBTyxFQUFoQixBQUFnQixBQUFFLEFBQ25COzs7QUFFTSxTQUFBLEFBQVMsZ0JBQWdCLEFBQzlCO1NBQU8sT0FBQSxBQUFPLGVBQWUsU0FBQSxBQUFTLEtBQXRDLEFBQTJDLEFBQzVDOzs7QUFFTSxTQUFBLEFBQVMsZUFBZSxBQUM3QjtTQUFPLE9BQUEsQUFBTyxlQUFlLFNBQUEsQUFBUyxLQUF0QyxBQUEyQyxBQUM1Qzs7O0FBRU0sU0FBQSxBQUFTLFlBQVQsQUFBcUIsTUFBckIsQUFBMkIsS0FBSyxBQUNyQztnQ0FBTyxBQUFXLE9BQU8sVUFBQSxBQUFDLFVBQWEsQUFDckM7UUFBSSxJQUFKLEFBQVEsQUFDUjtRQUFJLFVBQUosQUFFQTs7YUFBQSxBQUFTLE9BQU8sQUFDZDtlQUFBLEFBQVMsS0FBVCxBQUFjLEFBQ2Q7V0FBQSxBQUFLLEFBQ0w7V0FBSyxXQUFBLEFBQVcsTUFBaEIsQUFBSyxBQUFpQixBQUN2QjtBQUVEOztTQUFLLFdBQUEsQUFBVyxNQUFoQixBQUFLLEFBQWlCLEFBRXRCOztXQUFPLFlBQU0sQUFDWDttQkFBQSxBQUFhLEFBQ2Q7QUFGRCxBQUdEO0FBZkQsQUFBTyxBQWdCUixHQWhCUTs7O0FBa0JGLFNBQUEsQUFBUyxtQkFBVCxBQUE0QixTQUFTLEFBQzFDO1NBQU8sU0FBQSxBQUFTLGNBQVQsQUFBdUIseUJBQTlCLEFBQU8sQUFBZ0QsQUFDeEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVHRDs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7OztBQUVBOztBQVFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBdEVBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUE2Q0E7a0JBQ2UsYUFBQTttQ0FBQTtzQkFBQTs7c0JBQUE7NEJBQUE7OzhHQUFBO0FBQUE7OztXQUViOztBQUZhO3lDQUdNLEFBQ2pCO2VBQUEsQUFBTyxBQUNSO0FBRUQ7O0FBUGE7O0FBQUE7V0FBQTtpQ0FRRixBQUNUOztzQkFBTyxBQUNPLEFBQ1o7d0JBRkssQUFFUyxBQUNkOzZCQUhLLEFBR2MsQUFDbkI7cUJBSkssQUFJTSxBQUNYO3FCQUxLLEFBS00sQUFDWDtvQkFOSyxBQU1LLEFBQ1Y7eUJBUEYsQUFBTyxBQU9VLEFBRWxCO0FBVFEsQUFDTDtBQVVKOztBQXBCYTs7QUFBQTtXQUFBO29DQXFCQyxBQUNaO2VBQUEsQUFBTyxBQUNSO0FBRUQ7O0FBekJhOztBQUFBO1dBQUE7cUNBMEJFLEFBQ2I7YUFBQSxBQUFLLEFBQ0w7YUFBQSxBQUFLLEFBQ0w7YUFBQSxBQUFLLEFBQ0w7YUFBQSxBQUFLLEFBQ0w7ZUFBQSxBQUFPLEFBQ1I7QUFoQ1k7QUFBQTtXQUFBOzBDQWtDTyxBQUNsQjtZQUFJLEtBQUEsQUFBSyxXQUFMLEFBQWdCLFdBQXBCLEFBQStCLEdBQUcsQUFDaEM7Y0FBTSxLQUFLLEtBQUEsQUFBSyxHQUFoQixBQUFtQixBQUNuQjtjQUFBLEFBQUksSUFBSSxBQUNOO29CQUFBLEFBQVEsbUVBQVIsQUFBeUUsQUFDMUU7QUFGRCxpQkFFTyxBQUNMO2tCQUFNLE1BQU4sQUFBTSxBQUFNLEFBQ2I7QUFDRjtBQUNGO0FBM0NZO0FBQUE7V0FBQTsrQ0E2Q1ksQUFDdkI7WUFBSSx1QkFBSixBQUEyQixTQUFTLEFBQ2xDO2tCQUFBLEFBQVEsb0JBQW9CLEtBQUEsQUFBSyxvQkFBTCxBQUF5QixXQUFyRCxBQUFnRSxBQUNqRTtBQUVEOzthQUFBLEFBQUssQUFDTDtlQUFBLEFBQU8saUJBQVAsQUFBd0IsZ0JBQWdCLEtBQUEsQUFBSyxtQkFBTCxBQUF3QixLQUFoRSxBQUF3QyxBQUE2QixBQUN0RTtBQXBEWTtBQUFBO1dBQUE7MENBc0RPLEFBQ2xCO2FBQUEsQUFBSyxlQUFlLFNBQUEsQUFBUyxjQUFULEFBQXVCLFlBQTNDLEFBQXVELEFBQ3hEO0FBeERZO0FBQUE7V0FBQTtxQ0FBQSxBQTBERSxPQUFPO3FCQUNwQjs7b0JBQU8sQUFBSyxXQUFMLEFBQWdCLE9BQWhCLEFBQXVCLFNBQXZCLEFBQ0osSUFBSSxpQkFBQTtpQkFBUyxlQUFULEFBQVMsQUFBUztBQURsQixTQUFBLEVBQUEsQUFFSixPQUFPLGdCQUFBO2lCQUFRLE9BQUEsQUFBSyxrQkFBYixBQUFRLEFBQXVCO0FBRmxDLFdBQUEsQUFHSixHQUFHLGdCQUFlO2NBQVosQUFBWSxhQUFaLEFBQVksQUFDakI7O2lCQUFBLEFBQUssQUFDTDtnQkFBQSxBQUFNLEFBQ1A7QUFOSCxBQUFPLEFBT1I7QUFsRVk7QUFBQTtXQUFBO3FDQUFBLEFBb0VFLE9BQU87cUJBQ3BCOztzQ0FBTyxBQUFXLE1BQ2QsS0FBQSxBQUFLLFdBQUwsQUFBZ0IsT0FEYixBQUNILEFBQXVCLGVBQ3ZCLEtBQUEsQUFBSyxXQUFMLEFBQWdCLE9BRmIsQUFFSCxBQUF1QixlQUN2QixLQUFBLEFBQUssV0FBTCxBQUFnQixPQUhiLEFBR0gsQUFBdUIsVUFIcEIsQUFLSixJQUFJLGlCQUFBO2lCQUFTLGVBQVQsQUFBUyxBQUFTO0FBTGxCLFNBQUEsRUFBQSxBQU1KLE9BQU8sZ0JBQUE7aUJBQVEsT0FBQSxBQUFLLG1CQUFiLEFBQVEsQUFBd0I7QUFOMUMsQUFBTyxBQU9SO0FBNUVZO0FBQUE7V0FBQTswQ0E4RU8sQUFDbEI7c0NBQU8sQUFBVyxVQUFYLEFBQXFCLFFBQXJCLEFBQTZCLFlBQTdCLEFBQ0osSUFBSSxpQkFBQTtpQkFBUyxjQUFULEFBQVMsQUFBUTtBQURqQixTQUFBLEVBQUEsQUFFSixPQUFPLFlBQUE7aUJBQU0sT0FBQSxBQUFPLFFBQVAsQUFBZSxTQUFyQixBQUE4QjtBQUZ4QyxBQUFPLEFBR1I7QUFsRlk7QUFBQTtXQUFBO3VDQW9GSSxBQUNmO2VBQU8sdUJBQUEsQUFBVyxHQUFHLEtBQUEsQUFBSyxHQUFMLEFBQVEsaUJBQWlCLEtBQTlDLEFBQU8sQUFBYyxBQUE4QixBQUNwRDtBQXRGWTtBQUFBO1dBQUE7aUNBQUEsQUF3RkYsT0F4RkUsQUF3RkssT0FBTyxBQUN2QjtxQkFBTyxBQUFNLElBQUksZ0JBQUE7aUJBQVEsdUJBQUEsQUFBVyxVQUFYLEFBQXFCLE1BQTdCLEFBQVEsQUFBMkI7QUFBN0MsU0FBQSxFQUFQLEFBQU8sQUFBcUQsQUFDN0Q7QUExRlk7QUFBQTtXQUFBO2dDQUFBLEFBNEZILE1BQU07cUJBQ2Q7O3NDQUFPLEFBQ0osS0FBSyxLQUFBLEFBQUssV0FETixBQUNDLEFBQWdCLE9BRGpCLEFBRUosSUFBSSxpQkFBQTtjQUFBLEFBQUcsaUJBQUgsQUFBRztpQkFBZSxPQUFBLEFBQU8sT0FBUCxBQUFjLE1BQU0sRUFBRSxVQUF4QyxBQUFrQixBQUFvQjtBQUZ0QyxTQUFBLEVBQUEsQUFHSixNQUFNLGlCQUFBO2lCQUFTLE9BQUEsQUFBSyxrQkFBTCxBQUF1QixNQUFoQyxBQUFTLEFBQTZCO0FBSHhDLFdBQUEsQUFJSixVQUFVLFlBQUE7aUJBQU0sdUJBQUEsQUFBVyxNQUN4Qix1QkFBQSxBQUFXLFVBQVgsQUFBcUIsUUFEUixBQUNiLEFBQTZCLFdBQzdCLHlCQUFBLEFBQVksTUFGQyxBQUViLEFBQWtCLElBRkwsQUFHZCxHQUFHLE9BQUEsQUFBSyxRQUFMLEFBQWEsYUFIUixBQUFNLEFBR1gsQUFBd0I7QUFQaEMsQUFBTyxBQVFSO0FBckdZO0FBQUE7V0FBQTt3Q0F1R1E7WUFBUixBQUFRLGFBQVIsQUFBUSxBQUNuQjs7O2tCQUFPLEFBQ0csQUFDUjtlQUZLLEFBRUEsQUFDTDt3QkFIRixBQUFPLEFBR1MsQUFFakI7QUFMUSxBQUNMO0FBekdTO0FBQUE7V0FBQTt3Q0FBQSxBQStHSyxNQS9HTCxBQStHVyxPQUFPO1lBQUEsQUFDckIsU0FEcUIsQUFDTCxNQURLLEFBQ3JCO1lBRHFCLEFBQ2IsTUFEYSxBQUNMLE1BREssQUFDYixBQUVoQjs7WUFBSSxPQUFBLEFBQU8sVUFBVSxTQUFyQixBQUE4QixLQUFLLEFBQ2pDO0FBQ0E7QUFDQTtpQkFBTyx1QkFBQSxBQUFXLEdBQUcsT0FBQSxBQUFPLE9BQVAsQUFBYyxNQUFNLEVBQUUsVUFBVSxJQUFyRCxBQUFPLEFBQWMsQUFBb0IsQUFBZ0IsQUFDMUQ7QUFFRDs7QUFDQTthQUFBLEFBQUssUUFBUSxPQUFBLEFBQU8sT0FBUCxBQUFjLE1BQTNCLEFBQWEsQUFBb0IsQUFDakM7ZUFBTyx1QkFBQSxBQUFXLE1BQWxCLEFBQU8sQUFBaUIsQUFDekI7QUEzSFk7QUFBQTtXQUFBO3lDQTZITTtxQkFDakI7O0FBQ0E7QUFDQTthQUFBLEFBQUssU0FBUyxhQUFkLEFBQ0E7YUFBQSxBQUFLLFNBQVMsYUFBZCxBQUVBOztZQUFNLGFBQVEsQUFBSyxPQUFMLEFBQVksQUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFKWTtBQUFBLFNBQUEsQUFLWCxhQUFhLEtBQUEsQUFBSyxXQUxyQixBQUFjLEFBS2tCLEFBRWhDOztZQUFNLE9BQU8sS0FBYixBQUFhLEFBQUssQUFFbEI7O0FBQ0E7YUFBQSxBQUFLLFFBQVEsdUJBQUEsQUFBVyxNQUFYLEFBQWlCLE9BQWpCLEFBQXdCLE1BQXJDLEFBQWEsQUFBOEIsQUFFM0M7O0FBQ0E7QUFDQTtBQUNBO1lBQU0saUNBQVUsQUFBVyxNQUFNLFlBQUE7d0NBQy9CLEFBQVcsQUFDVDtBQUNBO2lCQUFBLEFBQUssTUFBTCxBQUFXLElBQUksWUFBQTttQkFBQSxBQUFNO0FBRnZCLEFBRUUsQUFDQTtBQUNBO2lCQUFBLEFBQUssUUFBTCxBQUFhLElBQUksWUFBQTttQkFBQSxBQUFNO0FBSnpCLEFBSUUsQUFFQTtBQU5GO0FBQUEsV0FBQSxBQU9HLFVBUjRCLEFBQy9CLEFBT2E7QUFSZixBQUFnQixBQVdoQixTQVhnQjs7QUFZaEI7QUFDQTthQUFBLEFBQUssYUFBUSxBQUFLLE9BQUwsQUFBWSxTQUFaLEFBQ1YsZUFEVSxBQUNLLFNBREwsQUFFVixPQUFPLGlCQUFBOzRDQUFBO2NBQUEsQUFBSSxlQUFKOztpQkFBZ0IsV0FBaEIsQUFBMkI7QUFGeEIsU0FBQSxFQUFBLEFBR1YsSUFBSSxpQkFBQTs0Q0FBQTtjQUFBLEFBQUUsVUFBRjs7aUJBQUEsQUFBUztBQUhoQixBQUFhLEFBS2I7O0FBQ0E7QUFDQTthQUFBLEFBQUssbUNBQVksQUFBVyxNQUFNLEtBQWpCLEFBQXNCLE9BQU8sS0FBN0IsQUFBa0MsT0FBbEMsQUFDZCx3QkFEYyxBQUNVLFFBRFYsQUFDa0I7QUFEbEIsU0FBQSxBQUVkLFVBQVUsZ0JBQUE7aUJBQVEsT0FBQSxBQUFLLFVBQWIsQUFBUSxBQUFlO0FBRm5CLFdBQUEsQUFHZCxNQUFNLFVBQUEsQUFBQyxLQUFELEFBQU0sUUFBTjtpQkFBQSxBQUFpQjtBQUhULFdBQUEsQUFJZCxVQUpjLEFBSUosSUFKSSxBQUlBO1NBSmpCLEFBQWlCLEFBS2QsQUFFSDs7YUFBQSxBQUFLLGVBQVUsQUFBSyxNQUFMLEFBQ1osR0FBRyxLQUFBLEFBQUssUUFBTCxBQUFhLEtBREosQUFDVCxBQUFrQixPQURULEFBRVosZUFBZSxLQUZILEFBRVEsV0FGUixBQUdaLFVBQVUsS0FBQSxBQUFLLFlBQUwsQUFBaUIsS0FIZixBQUdGLEFBQXNCLE9BSHBCLEFBSVosSUFBSSxLQUFBLEFBQUssa0JBQUwsQUFBdUIsS0FKZixBQUlSLEFBQTRCLE9BSnBCLEFBS1osR0FBRyxLQUFBLEFBQUssUUFBTCxBQUFhLEtBTEosQUFLVCxBQUFrQixPQUxULEFBTVosR0FBRyxLQUFBLEFBQUssVUFBTCxBQUFlLEtBTk4sQUFNVCxBQUFvQixPQU5YLEFBT1osR0FBRyxLQUFBLEFBQUssbUJBQUwsQUFBd0IsS0FQZixBQU9ULEFBQTZCLE9BUHBCLEFBUVosR0FBRyxLQUFBLEFBQUssUUFBTCxBQUFhLEtBUkosQUFRVCxBQUFrQixPQVJULEFBU1osTUFBTSxVQUFBLEFBQUMsT0FBRCxBQUFRLFFBQVcsQUFDeEI7aUJBQUEsQUFBSyxRQUFMLEFBQWEsQUFDYjtpQkFBQSxBQUFPLEFBQ1I7QUFaWSxBQWFiO0FBYmE7QUFBQSxTQUFmLEFBQWUsQUFjWixBQUVIOzthQUFLLEFBQ0g7QUFDQTtBQUZGO1NBQUEsQUFHRyxhQUFhLEtBSGhCLEFBR3FCLFVBSHJCLEFBSUcsR0FBRyxLQUFBLEFBQUssb0JBQUwsQUFBeUIsS0FKL0IsQUFJTSxBQUE4QixPQUpwQyxBQUtHLEFBRUg7O0FBQ0E7YUFBSyxBQUNIO0FBREY7U0FBQSxBQUVHLFVBQVUsWUFBQTtpQkFBTSx1QkFBQSxBQUFXLE1BQU0sT0FBQSxBQUFLLFdBQXRCLEFBQWlDLEtBQWpDLEFBQXNDLFVBQVUsT0FBdEQsQUFBTSxBQUFxRDtBQUZ4RSxXQUFBLEFBR0csVUFBVSxLQUFBLEFBQUssV0FBTCxBQUFnQixLQUg3QixBQUdhLEFBQXFCLEFBRWxDOztBQUNBO2FBQUEsQUFBSyxRQUFMLEFBQWEsQUFFYjs7QUFDQTthQUFBLEFBQUssQUFDTjtBQS9NWTtBQUFBO1dBQUE7eUNBaU5pQjswQ0FBQTtZQUFqQixBQUFpQixhQUFBO1lBQVgsQUFBVyxpQkFDNUI7O1lBQUksV0FBSixBQUVBOztBQUNBO1lBQUksS0FBQSxBQUFLLFNBQVMsU0FBbEIsQUFBMkIsTUFBTSxBQUMvQjtnQkFBTSx1QkFBQSxBQUFXLEdBQUcsT0FBQSxBQUFPLE9BQVAsQUFBYyxNQUFNLEVBQUUsVUFBVSxTQUFwRCxBQUFNLEFBQWMsQUFBb0IsQUFBcUIsQUFFN0Q7O2NBQUksOEJBQXdCLENBQUMsS0FBN0IsQUFBa0MsZUFBZSxBQUMvQztBQUNBO0FBQ0E7a0JBQU0sSUFBQSxBQUFJLE1BQU0sS0FBQSxBQUFLLFdBQXJCLEFBQU0sQUFBMEIsQUFDakM7QUFDSDtBQUNDO0FBVEQsZUFTTyxBQUNMO3FCQUFNLEFBQUssVUFBTCxBQUFlLEtBQWYsQUFBb0IsR0FBcEIsQUFDSCxJQUFJLGlCQUFBO21CQUFTLE9BQUEsQUFBTyxPQUFQLEFBQWMsTUFBTSxFQUFFLFVBQVUsTUFBekMsQUFBUyxBQUFvQixBQUFrQjtBQUR0RCxBQUFNLEFBR04sV0FITTs7Y0FHRiw4QkFBd0IsQ0FBQyxLQUE3QixBQUFrQyxlQUFlLEFBQy9DO0FBQ0E7QUFDQTtzQkFBTSxBQUFJLElBQUksdUJBQUEsQUFBVyxNQUFNLEtBQUEsQUFBSyxXQUE5QixBQUFRLEFBQWlDLE1BQU0sYUFBQTtxQkFBQSxBQUFLO0FBQTFELEFBQU0sQUFDUCxhQURPO0FBRVQ7QUFFRDs7ZUFBQSxBQUFPLEFBQ1I7QUExT1k7QUFBQTtXQUFBOzhCQUFBLEFBNE9MLFFBQVE7WUFBQSxBQUNOLE9BRE0sQUFDRyxPQURILEFBQ04sQUFFUjs7WUFBSSx3QkFBSixNQUE0QixBQUMxQjtpQkFBQSxBQUFPLFFBQVAsQUFBZSxVQUFVLEVBQUUsSUFBSSxLQUEvQixBQUF5QixBQUFXLGlCQUFwQyxBQUFxRCxJQUFyRCxBQUF5RCxBQUMxRDtBQUVEOzthQUFBLEFBQUssVUFBTCxBQUFlLFNBQVMsRUFBRSxRQUExQixBQUF3QixBQUFVLEFBQ25DO0FBcFBZO0FBQUE7V0FBQTtpQ0FBQSxBQXNQRixRQUFRLEFBQ2pCO2FBQUEsQUFBSyxVQUFMLEFBQWUsWUFBWSxFQUFFLFFBQTdCLEFBQTJCLEFBQVUsQUFDdEM7QUF4UFk7QUFBQTtXQUFBO3dDQUFBLEFBMFBLLFFBQVE7WUFBQSxBQUNoQixXQURnQixBQUNILE9BREcsQUFDaEIsQUFFUjs7WUFBTSxtQkFBbUIsZ0NBQXpCLEFBQXlCLEFBQW1CLEFBQzVDO1lBQU0sUUFBUSxLQUFBLEFBQUssNkJBQW5CLEFBQWMsQUFBa0MsQUFDaEQ7WUFBTSxVQUFVLEtBQUEsQUFBSywrQkFBckIsQUFBZ0IsQUFBb0MsQUFFcEQ7O2VBQU8sT0FBQSxBQUFPLE9BQVAsQUFBYyxRQUFRLEVBQUUsT0FBRixPQUFTLFNBQXRDLEFBQU8sQUFBc0IsQUFDOUI7QUFsUVk7QUFBQTtXQUFBOzhCQUFBLEFBb1FMLFFBQVEsQUFDZDthQUFBLEFBQUssVUFBTCxBQUFlLFNBQVMsRUFBRSxRQUExQixBQUF3QixBQUFVLEFBQ25DO0FBdFFZO0FBQUE7V0FBQTtnQ0FBQSxBQXdRSCxRQUFRLEFBQ2hCO1lBQUk7Y0FBQSxBQUNNLE9BRE4sQUFDK0IsT0FEL0IsQUFDTTtjQUROLEFBQ1ksUUFEWixBQUMrQixPQUQvQixBQUNZO2NBRFosQUFDbUIsVUFEbkIsQUFDK0IsT0FEL0IsQUFDbUIsQUFFckI7O2NBQUksd0JBQUosTUFBNEIsQUFDMUI7bUJBQUEsQUFBTyxRQUFQLEFBQWUsYUFBYSxFQUFFLElBQUksS0FBbEMsQUFBNEIsQUFBVyxpQkFBdkMsQUFBd0QsT0FBeEQsQUFBK0QsQUFDaEU7QUFFRDs7ZUFBQSxBQUFLLGFBQUwsQUFBa0IsY0FBbEIsQUFBZ0MsQUFDaEM7ZUFBQSxBQUFLLGVBQUwsQUFBb0IsQUFDckI7QUFURCxVQVNFLE9BQUEsQUFBTyxPQUFPLEFBQ2Q7Z0JBQU0sT0FBQSxBQUFPLE9BQVAsQUFBYyxRQUFRLEVBQUUsT0FBOUIsQUFBTSxBQUFzQixBQUM3QjtBQUNGO0FBclJZO0FBQUE7V0FBQTs4QkFBQSxBQXVSTCxRQUFRLEFBQ2Q7YUFBQSxBQUFLLFVBQUwsQUFBZSxTQUFTLEVBQUUsUUFBMUIsQUFBd0IsQUFBVSxBQUNuQztBQXpSWTtBQUFBO1dBQUE7NENBMlJTLEFBQ3BCO1lBQU0sUUFBUSxLQUFkLEFBQWMsQUFBSyxBQUNuQjthQUFBLEFBQUssT0FBTCxBQUFZLEtBQUssS0FBQSxBQUFLLGVBQXRCLEFBQWlCLEFBQW9CLEFBQ3JDO2FBQUEsQUFBSyxPQUFMLEFBQVksS0FBSyxLQUFBLEFBQUssZUFBdEIsQUFBaUIsQUFBb0IsQUFDdEM7QUEvUlk7QUFBQTtXQUFBOzhCQUFBLEFBaVNMLEtBQUssQUFDWDthQUFBLEFBQUssR0FBTCxBQUFRLE1BQVIsQUFBYyxhQUFkLEFBQTJCLEFBQzNCO2FBQUEsQUFBSyxVQUFMLEFBQWUsU0FBUyxFQUFFLFFBQTFCLEFBQXdCLEFBQVUsQUFDbkM7QUFwU1k7QUFBQTtXQUFBOzhCQUFBLEFBc1NMLE1BQU0sQUFDWjthQUFBLEFBQUssVUFBTCxBQUFlLFNBQVMsRUFBRSxRQUExQixBQUF3QixBQUFVLEFBQ25DO0FBeFNZO0FBQUE7V0FBQTt3Q0FBQSxBQTBTSyxNQUFNO1lBQUEsQUFDZCxRQURjLEFBQ0osS0FESSxBQUNkLEFBQ1I7O2VBQ0UsQ0FBQyxNQUFELEFBQU8sV0FDUCxDQUFDLE1BREQsQUFDTyxXQUNQLEtBQUEsQUFBSyxtQkFIUCxBQUdFLEFBQXdCLEFBRTNCO0FBalRZO0FBQUE7V0FBQTtpREFtVDRDO1lBQVosQUFBWSxnQkFBcEMsQUFBb0MsTUFBM0IsQUFBMkIsQUFDdkQ7O2VBQ0UsVUFBQSxBQUFVLFFBQ1YsOEJBQUEsQUFBaUIsUUFBUSxLQUF6QixBQUE4QixXQUFXLEtBRjNDLEFBRUUsQUFBOEMsQUFFakQ7QUF4VFk7QUFBQTtXQUFBO21EQUFBLEFBMFRnQixrQkFBa0IsQUFDN0M7ZUFBTyxDQUFDLGlCQUFBLEFBQWlCLGNBQWpCLEFBQStCLFlBQWhDLEFBQTRDLElBQW5ELEFBQXVELEFBQ3hEO0FBNVRZO0FBQUE7V0FBQTtxREFBQSxBQThUa0Isa0JBQWtCLEFBQy9DO1lBQUksS0FBQSxBQUFLLFdBQUwsQUFBZ0IsU0FBcEIsQUFBNkIsR0FBRyxBQUM5QjtzQkFBTyxBQUFLLFdBQUwsQUFBZ0IsSUFBSSxjQUFBO21CQUFNLGlCQUFBLEFBQWlCLG9CQUF2QixBQUFNLEFBQW1DO0FBQXBFLEFBQU8sQUFDUixXQURRO0FBR1Q7O2VBQU8saUJBQUEsQUFBaUIsb0JBQWtCLEtBQUEsQUFBSyxHQUEvQyxBQUFPLEFBQTJDLEFBQ25EO0FBcFVZO0FBQUE7V0FBQTtxQ0FBQSxBQXNVRSxTQUFTLEFBQ3RCO1lBQUksS0FBQSxBQUFLLFdBQUwsQUFBZ0IsU0FBcEIsQUFBNkIsR0FBRyxBQUM5QjtlQUFBLEFBQUssb0JBQUwsQUFBeUIsQUFDMUI7QUFGRCxlQUVPLEFBQ0w7ZUFBQSxBQUFLLHdCQUFMLEFBQTZCLEFBQzlCO0FBQ0Y7QUE1VVk7QUFBQTtXQUFBOzBDQUFBLEFBOFVPLFVBQVUsQUFDNUI7WUFBTSxtQkFBYyxBQUFLLFdBQUwsQUFDakIsSUFBSSxjQUFBO2lCQUFNLFNBQUEsQUFBUyxlQUFmLEFBQU0sQUFBd0I7QUFEckMsQUFBb0IsQUFHcEIsU0FIb0I7O2NBR3BCLEFBQU0sVUFBTixBQUFnQixRQUFoQixBQUF3QixLQUF4QixBQUE2QixhQUFhLFVBQUEsQUFBQyxZQUFlLEFBQ3hEO3FCQUFBLEFBQVcsV0FBWCxBQUFzQixhQUFhLFNBQW5DLEFBQW1DLEFBQVMsU0FBNUMsQUFBcUQsQUFDdEQ7QUFGRCxBQUdEO0FBclZZO0FBQUE7V0FBQTs4Q0FBQSxBQXVWVyxTQUFTLEFBQy9CO2FBQUEsQUFBSyxHQUFMLEFBQVEsWUFBWSxRQUFwQixBQUE0QixBQUM3QjtBQXpWWTtBQUFBO1dBQUE7eUNBQUEsQUEyVk0sT0FBTyxBQUN4QjtzQkFBTyxBQUFPLE9BQVAsQUFBYztxQkFDUixZQURlLEFBRTFCO3dCQUFjLFlBRmhCLEFBQU8sQUFBcUIsQUFJN0I7QUFKNkIsQUFDMUIsU0FESztBQTVWSTtBQUFBO1dBQUE7MkNBa1dRLEFBQ25CO1lBQUksUUFBUSxRQUFBLEFBQVEsU0FBUyxFQUFFLElBQUksS0FBbkMsQUFBNkIsQUFBVyxBQUN4QztnQkFBUSxLQUFBLEFBQUssb0JBQW9CLEtBQUEsQUFBSyxtQkFBOUIsQUFBeUIsQUFBd0IsU0FBekQsQUFBa0UsQUFDbEU7Z0JBQUEsQUFBUSxhQUFSLEFBQXFCLE9BQU8sU0FBNUIsQUFBcUMsT0FBTyxPQUFBLEFBQU8sU0FBbkQsQUFBNEQsQUFDN0Q7QUF0V1k7QUFBQTtXQUFBOzBDQXdXTyxBQUNsQjtZQUFNLFFBQVEsUUFBQSxBQUFRLFNBQXRCLEFBQStCLEFBQy9CO2lCQUFBLEFBQVMsS0FBVCxBQUFjLE1BQWQsQUFBb0IsYUFBZSxNQUFBLEFBQU0sZ0JBQXpDLEFBQXlELEtBQ3pEO1lBQUksTUFBQSxBQUFNLGFBQVYsQUFBdUIsTUFBTSxPQUFBLEFBQU8sT0FBTyxPQUFkLEFBQXFCLGFBQWEsTUFBbEMsQUFBd0MsQUFDckU7aUJBQUEsQUFBUyxLQUFULEFBQWMsTUFBZCxBQUFvQixZQUFwQixBQUFnQyxBQUNqQztBQTdXWTtBQUFBO1dBQUE7eUNBQUEsQUErV00sUUFBUSxBQUN6QjtZQUFJLEtBQUosQUFBUyxtQkFBbUIsQUFDMUI7Y0FBSSx3QkFBSixLQUEyQixBQUN6QjtpQkFBQSxBQUFLLEFBQ047QUFDRjtBQUNGO0FBclhZO0FBQUE7O1dBQUE7SUFBbUIsNkJBQW5CLEFBQW1CLEFBQWM7QTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekVoRDtBQUNBOztJLEFBRWEsZSxBQUFBLE9BQ1gsY0FBQSxBQUFZLE9BQU87d0JBQ2pCOztPQUFBLEFBQUssUUFBTCxBQUFhLEFBQ2Q7QTs7SSxBQUdVLGUsQUFBQTtrQkFDWDs7Z0JBQUEsQUFBWSxPQUFPOzBCQUFBOzs0R0FBQSxBQUNYLEFBQ047O1VBQUEsQUFBSyxPQUFPLE1BQUEsQUFBTSxjQUZELEFBRWpCLEFBQWdDO1dBQ2pDOzs7Ozt3QkFFVSxBQUFFO2FBQUEsQUFBTyxBQUFTOzs7OztFLEFBTkw7O0ksQUFTYixlLEFBQUE7a0JBQ1g7O2dCQUFBLEFBQVksT0FBTzswQkFBQTs7NkdBQUEsQUFDWCxBQUNOOztXQUFBLEFBQUssT0FBTyxNQUFBLEFBQU0sY0FGRCxBQUVqQixBQUFnQztXQUNqQzs7Ozs7d0JBRVUsQUFBRTthQUFBLEFBQU8sQUFBUzs7Ozs7RSxBQU5MOztJLEFBU2IsYyxBQUFBO2lCQUNYOztlQUFBLEFBQVksT0FBTzswQkFBQTs7MkdBQUEsQUFDWCxBQUNOOztXQUFBLEFBQUssT0FBTyxPQUFBLEFBQU8sU0FGRixBQUVqQixBQUE0QjtXQUM3Qjs7Ozs7d0JBRVUsQUFBRTthQUFBLEFBQU8sQUFBUTs7Ozs7RSxBQU5MOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4QnpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFIQTtBQUNBOztJLEFBSXFCO3VCQUNuQjs7cUJBQUEsQUFBWSxJQUFaLEFBQWdCLE9BQU87MEJBQUE7O2dIQUVyQjs7VUFBQSxBQUFLLGVBQUwsQUFBb0IsSUFGQyxBQUVyQixBQUF3QjtXQUN6QjtBQUVEOzs7Ozs7OzZCLEFBQ1MsSUFBSSxBQUNYO1VBQUksQ0FBSixBQUFLLElBQUksTUFBTSxNQUFOLEFBQU0sQUFBTSxBQUNyQjthQUFBLEFBQU8sQUFDUjs7Ozs7RUFWb0MsVzs7a0IsQUFBbEIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyohIG1vZGVybml6ciAzLjQuMCAoQ3VzdG9tIEJ1aWxkKSB8IE1JVCAqXG4gKiBodHRwczovL21vZGVybml6ci5jb20vZG93bmxvYWQvPy1jbGFzc2xpc3QtY3NzYW5pbWF0aW9ucy1jc3Nwb2ludGVyZXZlbnRzLWNzc3JlbXVuaXQtY3NzdHJhbnNmb3Jtcy1kb2N1bWVudGZyYWdtZW50LWV2ZW50bGlzdGVuZXItaGlzdG9yeS1tYXRjaG1lZGlhLW9wYWNpdHktcXVlcnlzZWxlY3Rvci1yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtdG91Y2hldmVudHMgISovXG4hZnVuY3Rpb24oZSx0LG4pe2Z1bmN0aW9uIHIoZSx0KXtyZXR1cm4gdHlwZW9mIGU9PT10fWZ1bmN0aW9uIG8oKXt2YXIgZSx0LG4sbyxpLHMsYTtmb3IodmFyIHUgaW4gZylpZihnLmhhc093blByb3BlcnR5KHUpKXtpZihlPVtdLHQ9Z1t1XSx0Lm5hbWUmJihlLnB1c2godC5uYW1lLnRvTG93ZXJDYXNlKCkpLHQub3B0aW9ucyYmdC5vcHRpb25zLmFsaWFzZXMmJnQub3B0aW9ucy5hbGlhc2VzLmxlbmd0aCkpZm9yKG49MDtuPHQub3B0aW9ucy5hbGlhc2VzLmxlbmd0aDtuKyspZS5wdXNoKHQub3B0aW9ucy5hbGlhc2VzW25dLnRvTG93ZXJDYXNlKCkpO2ZvcihvPXIodC5mbixcImZ1bmN0aW9uXCIpP3QuZm4oKTp0LmZuLGk9MDtpPGUubGVuZ3RoO2krKylzPWVbaV0sYT1zLnNwbGl0KFwiLlwiKSwxPT09YS5sZW5ndGg/TW9kZXJuaXpyW2FbMF1dPW86KCFNb2Rlcm5penJbYVswXV18fE1vZGVybml6clthWzBdXWluc3RhbmNlb2YgQm9vbGVhbnx8KE1vZGVybml6clthWzBdXT1uZXcgQm9vbGVhbihNb2Rlcm5penJbYVswXV0pKSxNb2Rlcm5penJbYVswXV1bYVsxXV09byksUy5wdXNoKChvP1wiXCI6XCJuby1cIikrYS5qb2luKFwiLVwiKSl9fWZ1bmN0aW9uIGkoZSl7cmV0dXJuIGUucmVwbGFjZSgvKFthLXpdKS0oW2Etel0pL2csZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0K24udG9VcHBlckNhc2UoKX0pLnJlcGxhY2UoL14tLyxcIlwiKX1mdW5jdGlvbiBzKCl7cmV0dXJuXCJmdW5jdGlvblwiIT10eXBlb2YgdC5jcmVhdGVFbGVtZW50P3QuY3JlYXRlRWxlbWVudChhcmd1bWVudHNbMF0pOnc/dC5jcmVhdGVFbGVtZW50TlMuY2FsbCh0LFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixhcmd1bWVudHNbMF0pOnQuY3JlYXRlRWxlbWVudC5hcHBseSh0LGFyZ3VtZW50cyl9ZnVuY3Rpb24gYSgpe3ZhciBlPXQuYm9keTtyZXR1cm4gZXx8KGU9cyh3P1wic3ZnXCI6XCJib2R5XCIpLGUuZmFrZT0hMCksZX1mdW5jdGlvbiB1KGUsbixyLG8pe3ZhciBpLHUsbCxmLGQ9XCJtb2Rlcm5penJcIixjPXMoXCJkaXZcIikscD1hKCk7aWYocGFyc2VJbnQociwxMCkpZm9yKDtyLS07KWw9cyhcImRpdlwiKSxsLmlkPW8/b1tyXTpkKyhyKzEpLGMuYXBwZW5kQ2hpbGQobCk7cmV0dXJuIGk9cyhcInN0eWxlXCIpLGkudHlwZT1cInRleHQvY3NzXCIsaS5pZD1cInNcIitkLChwLmZha2U/cDpjKS5hcHBlbmRDaGlsZChpKSxwLmFwcGVuZENoaWxkKGMpLGkuc3R5bGVTaGVldD9pLnN0eWxlU2hlZXQuY3NzVGV4dD1lOmkuYXBwZW5kQ2hpbGQodC5jcmVhdGVUZXh0Tm9kZShlKSksYy5pZD1kLHAuZmFrZSYmKHAuc3R5bGUuYmFja2dyb3VuZD1cIlwiLHAuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIixmPVQuc3R5bGUub3ZlcmZsb3csVC5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwiLFQuYXBwZW5kQ2hpbGQocCkpLHU9bihjLGUpLHAuZmFrZT8ocC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHApLFQuc3R5bGUub3ZlcmZsb3c9ZixULm9mZnNldEhlaWdodCk6Yy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpLCEhdX1mdW5jdGlvbiBsKGUsdCl7cmV0dXJuISF+KFwiXCIrZSkuaW5kZXhPZih0KX1mdW5jdGlvbiBmKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUuYXBwbHkodCxhcmd1bWVudHMpfX1mdW5jdGlvbiBkKGUsdCxuKXt2YXIgbztmb3IodmFyIGkgaW4gZSlpZihlW2ldaW4gdClyZXR1cm4gbj09PSExP2VbaV06KG89dFtlW2ldXSxyKG8sXCJmdW5jdGlvblwiKT9mKG8sbnx8dCk6byk7cmV0dXJuITF9ZnVuY3Rpb24gYyhlKXtyZXR1cm4gZS5yZXBsYWNlKC8oW0EtWl0pL2csZnVuY3Rpb24oZSx0KXtyZXR1cm5cIi1cIit0LnRvTG93ZXJDYXNlKCl9KS5yZXBsYWNlKC9ebXMtLyxcIi1tcy1cIil9ZnVuY3Rpb24gcCh0LG4scil7dmFyIG87aWYoXCJnZXRDb21wdXRlZFN0eWxlXCJpbiBlKXtvPWdldENvbXB1dGVkU3R5bGUuY2FsbChlLHQsbik7dmFyIGk9ZS5jb25zb2xlO2lmKG51bGwhPT1vKXImJihvPW8uZ2V0UHJvcGVydHlWYWx1ZShyKSk7ZWxzZSBpZihpKXt2YXIgcz1pLmVycm9yP1wiZXJyb3JcIjpcImxvZ1wiO2lbc10uY2FsbChpLFwiZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5pbmcgbnVsbCwgaXRzIHBvc3NpYmxlIG1vZGVybml6ciB0ZXN0IHJlc3VsdHMgYXJlIGluYWNjdXJhdGVcIil9fWVsc2Ugbz0hbiYmdC5jdXJyZW50U3R5bGUmJnQuY3VycmVudFN0eWxlW3JdO3JldHVybiBvfWZ1bmN0aW9uIG0odCxyKXt2YXIgbz10Lmxlbmd0aDtpZihcIkNTU1wiaW4gZSYmXCJzdXBwb3J0c1wiaW4gZS5DU1Mpe2Zvcig7by0tOylpZihlLkNTUy5zdXBwb3J0cyhjKHRbb10pLHIpKXJldHVybiEwO3JldHVybiExfWlmKFwiQ1NTU3VwcG9ydHNSdWxlXCJpbiBlKXtmb3IodmFyIGk9W107by0tOylpLnB1c2goXCIoXCIrYyh0W29dKStcIjpcIityK1wiKVwiKTtyZXR1cm4gaT1pLmpvaW4oXCIgb3IgXCIpLHUoXCJAc3VwcG9ydHMgKFwiK2krXCIpIHsgI21vZGVybml6ciB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgfSB9XCIsZnVuY3Rpb24oZSl7cmV0dXJuXCJhYnNvbHV0ZVwiPT1wKGUsbnVsbCxcInBvc2l0aW9uXCIpfSl9cmV0dXJuIG59ZnVuY3Rpb24gdihlLHQsbyxhKXtmdW5jdGlvbiB1KCl7ZCYmKGRlbGV0ZSBQLnN0eWxlLGRlbGV0ZSBQLm1vZEVsZW0pfWlmKGE9cihhLFwidW5kZWZpbmVkXCIpPyExOmEsIXIobyxcInVuZGVmaW5lZFwiKSl7dmFyIGY9bShlLG8pO2lmKCFyKGYsXCJ1bmRlZmluZWRcIikpcmV0dXJuIGZ9Zm9yKHZhciBkLGMscCx2LHksaD1bXCJtb2Rlcm5penJcIixcInRzcGFuXCIsXCJzYW1wXCJdOyFQLnN0eWxlJiZoLmxlbmd0aDspZD0hMCxQLm1vZEVsZW09cyhoLnNoaWZ0KCkpLFAuc3R5bGU9UC5tb2RFbGVtLnN0eWxlO2ZvcihwPWUubGVuZ3RoLGM9MDtwPmM7YysrKWlmKHY9ZVtjXSx5PVAuc3R5bGVbdl0sbCh2LFwiLVwiKSYmKHY9aSh2KSksUC5zdHlsZVt2XSE9PW4pe2lmKGF8fHIobyxcInVuZGVmaW5lZFwiKSlyZXR1cm4gdSgpLFwicGZ4XCI9PXQ/djohMDt0cnl7UC5zdHlsZVt2XT1vfWNhdGNoKGcpe31pZihQLnN0eWxlW3ZdIT15KXJldHVybiB1KCksXCJwZnhcIj09dD92OiEwfXJldHVybiB1KCksITF9ZnVuY3Rpb24geShlLHQsbixvLGkpe3ZhciBzPWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxhPShlK1wiIFwiK2Iuam9pbihzK1wiIFwiKStzKS5zcGxpdChcIiBcIik7cmV0dXJuIHIodCxcInN0cmluZ1wiKXx8cih0LFwidW5kZWZpbmVkXCIpP3YoYSx0LG8saSk6KGE9KGUrXCIgXCIrRS5qb2luKHMrXCIgXCIpK3MpLnNwbGl0KFwiIFwiKSxkKGEsdCxuKSl9ZnVuY3Rpb24gaChlLHQscil7cmV0dXJuIHkoZSxuLG4sdCxyKX12YXIgZz1bXSxDPXtfdmVyc2lvbjpcIjMuNC4wXCIsX2NvbmZpZzp7Y2xhc3NQcmVmaXg6XCJcIixlbmFibGVDbGFzc2VzOiEwLGVuYWJsZUpTQ2xhc3M6ITAsdXNlUHJlZml4ZXM6ITB9LF9xOltdLG9uOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dChuW2VdKX0sMCl9LGFkZFRlc3Q6ZnVuY3Rpb24oZSx0LG4pe2cucHVzaCh7bmFtZTplLGZuOnQsb3B0aW9uczpufSl9LGFkZEFzeW5jVGVzdDpmdW5jdGlvbihlKXtnLnB1c2goe25hbWU6bnVsbCxmbjplfSl9fSxNb2Rlcm5penI9ZnVuY3Rpb24oKXt9O01vZGVybml6ci5wcm90b3R5cGU9QyxNb2Rlcm5penI9bmV3IE1vZGVybml6cixNb2Rlcm5penIuYWRkVGVzdChcImV2ZW50bGlzdGVuZXJcIixcImFkZEV2ZW50TGlzdGVuZXJcImluIGUpLE1vZGVybml6ci5hZGRUZXN0KFwiaGlzdG9yeVwiLGZ1bmN0aW9uKCl7dmFyIHQ9bmF2aWdhdG9yLnVzZXJBZ2VudDtyZXR1cm4tMT09PXQuaW5kZXhPZihcIkFuZHJvaWQgMi5cIikmJi0xPT09dC5pbmRleE9mKFwiQW5kcm9pZCA0LjBcIil8fC0xPT09dC5pbmRleE9mKFwiTW9iaWxlIFNhZmFyaVwiKXx8LTEhPT10LmluZGV4T2YoXCJDaHJvbWVcIil8fC0xIT09dC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKXx8XCJmaWxlOlwiPT09bG9jYXRpb24ucHJvdG9jb2w/ZS5oaXN0b3J5JiZcInB1c2hTdGF0ZVwiaW4gZS5oaXN0b3J5OiExfSksTW9kZXJuaXpyLmFkZFRlc3QoXCJxdWVyeXNlbGVjdG9yXCIsXCJxdWVyeVNlbGVjdG9yXCJpbiB0JiZcInF1ZXJ5U2VsZWN0b3JBbGxcImluIHQpO3ZhciBTPVtdLHg9Qy5fY29uZmlnLnVzZVByZWZpeGVzP1wiIC13ZWJraXQtIC1tb3otIC1vLSAtbXMtIFwiLnNwbGl0KFwiIFwiKTpbXCJcIixcIlwiXTtDLl9wcmVmaXhlcz14O3ZhciBUPXQuZG9jdW1lbnRFbGVtZW50O01vZGVybml6ci5hZGRUZXN0KFwiY2xhc3NsaXN0XCIsXCJjbGFzc0xpc3RcImluIFQpLE1vZGVybml6ci5hZGRUZXN0KFwiZG9jdW1lbnRmcmFnbWVudFwiLGZ1bmN0aW9uKCl7cmV0dXJuXCJjcmVhdGVEb2N1bWVudEZyYWdtZW50XCJpbiB0JiZcImFwcGVuZENoaWxkXCJpbiBUfSk7dmFyIHc9XCJzdmdcIj09PVQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtNb2Rlcm5penIuYWRkVGVzdChcIm9wYWNpdHlcIixmdW5jdGlvbigpe3ZhciBlPXMoXCJhXCIpLnN0eWxlO3JldHVybiBlLmNzc1RleHQ9eC5qb2luKFwib3BhY2l0eTouNTU7XCIpLC9eMC41NSQvLnRlc3QoZS5vcGFjaXR5KX0pLE1vZGVybml6ci5hZGRUZXN0KFwiY3NzcG9pbnRlcmV2ZW50c1wiLGZ1bmN0aW9uKCl7dmFyIGU9cyhcImFcIikuc3R5bGU7cmV0dXJuIGUuY3NzVGV4dD1cInBvaW50ZXItZXZlbnRzOmF1dG9cIixcImF1dG9cIj09PWUucG9pbnRlckV2ZW50c30pLE1vZGVybml6ci5hZGRUZXN0KFwiY3NzcmVtdW5pdFwiLGZ1bmN0aW9uKCl7dmFyIGU9cyhcImFcIikuc3R5bGU7dHJ5e2UuZm9udFNpemU9XCIzcmVtXCJ9Y2F0Y2godCl7fXJldHVybi9yZW0vLnRlc3QoZS5mb250U2l6ZSl9KTt2YXIgXz1DLnRlc3RTdHlsZXM9dTtNb2Rlcm5penIuYWRkVGVzdChcInRvdWNoZXZlbnRzXCIsZnVuY3Rpb24oKXt2YXIgbjtpZihcIm9udG91Y2hzdGFydFwiaW4gZXx8ZS5Eb2N1bWVudFRvdWNoJiZ0IGluc3RhbmNlb2YgRG9jdW1lbnRUb3VjaCluPSEwO2Vsc2V7dmFyIHI9W1wiQG1lZGlhIChcIix4LmpvaW4oXCJ0b3VjaC1lbmFibGVkKSwoXCIpLFwiaGVhcnR6XCIsXCIpXCIsXCJ7I21vZGVybml6cnt0b3A6OXB4O3Bvc2l0aW9uOmFic29sdXRlfX1cIl0uam9pbihcIlwiKTtfKHIsZnVuY3Rpb24oZSl7bj05PT09ZS5vZmZzZXRUb3B9KX1yZXR1cm4gbn0pO3ZhciB6PVwiTW96IE8gbXMgV2Via2l0XCIsYj1DLl9jb25maWcudXNlUHJlZml4ZXM/ei5zcGxpdChcIiBcIik6W107Qy5fY3Nzb21QcmVmaXhlcz1iO3ZhciBBPWZ1bmN0aW9uKHQpe3ZhciByLG89eC5sZW5ndGgsaT1lLkNTU1J1bGU7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGkpcmV0dXJuIG47aWYoIXQpcmV0dXJuITE7aWYodD10LnJlcGxhY2UoL15ALyxcIlwiKSxyPXQucmVwbGFjZSgvLS9nLFwiX1wiKS50b1VwcGVyQ2FzZSgpK1wiX1JVTEVcIixyIGluIGkpcmV0dXJuXCJAXCIrdDtmb3IodmFyIHM9MDtvPnM7cysrKXt2YXIgYT14W3NdLHU9YS50b1VwcGVyQ2FzZSgpK1wiX1wiK3I7aWYodSBpbiBpKXJldHVyblwiQC1cIithLnRvTG93ZXJDYXNlKCkrXCItXCIrdH1yZXR1cm4hMX07Qy5hdFJ1bGU9QTt2YXIgRT1DLl9jb25maWcudXNlUHJlZml4ZXM/ei50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiIFwiKTpbXTtDLl9kb21QcmVmaXhlcz1FO3ZhciBPPXtlbGVtOnMoXCJtb2Rlcm5penJcIil9O01vZGVybml6ci5fcS5wdXNoKGZ1bmN0aW9uKCl7ZGVsZXRlIE8uZWxlbX0pO3ZhciBQPXtzdHlsZTpPLmVsZW0uc3R5bGV9O01vZGVybml6ci5fcS51bnNoaWZ0KGZ1bmN0aW9uKCl7ZGVsZXRlIFAuc3R5bGV9KSxDLnRlc3RBbGxQcm9wcz15O3ZhciBxPUMucHJlZml4ZWQ9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiAwPT09ZS5pbmRleE9mKFwiQFwiKT9BKGUpOigtMSE9ZS5pbmRleE9mKFwiLVwiKSYmKGU9aShlKSksdD95KGUsdCxuKTp5KGUsXCJwZnhcIikpfTtNb2Rlcm5penIuYWRkVGVzdChcInJlcXVlc3RhbmltYXRpb25mcmFtZVwiLCEhcShcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiLGUpLHthbGlhc2VzOltcInJhZlwiXX0pLE1vZGVybml6ci5hZGRUZXN0KFwibWF0Y2htZWRpYVwiLCEhcShcIm1hdGNoTWVkaWFcIixlKSksQy50ZXN0QWxsUHJvcHM9aCxNb2Rlcm5penIuYWRkVGVzdChcImNzc2FuaW1hdGlvbnNcIixoKFwiYW5pbWF0aW9uTmFtZVwiLFwiYVwiLCEwKSksTW9kZXJuaXpyLmFkZFRlc3QoXCJjc3N0cmFuc2Zvcm1zXCIsZnVuY3Rpb24oKXtyZXR1cm4tMT09PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkFuZHJvaWQgMi5cIikmJmgoXCJ0cmFuc2Zvcm1cIixcInNjYWxlKDEpXCIsITApfSksbygpLGRlbGV0ZSBDLmFkZFRlc3QsZGVsZXRlIEMuYWRkQXN5bmNUZXN0O2Zvcih2YXIgTD0wO0w8TW9kZXJuaXpyLl9xLmxlbmd0aDtMKyspTW9kZXJuaXpyLl9xW0xdKCk7ZS5Nb2Rlcm5penI9TW9kZXJuaXpyfSh3aW5kb3csZG9jdW1lbnQpO1xuIiwiY29uc29sZS5sb2coJyBfXyAgX18gICAgICAgICAgICAgICAgX18gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX18gICAgICAgICBcXHJcXG5cXC9cXFxcIFxcXFxcXC9cXFxcIFxcXFwgICAgICAgICAgICAgIFxcL1xcXFwgXFxcXCAgICAgICAgICAgICBfXyAgICAgICAgICAgICAgICAgICAgXFwvXFxcXCBcXFxcICAgICAgICBcXHJcXG5cXFxcIFxcXFwgXFxcXF9cXFxcIFxcXFwgICBfXyAgX18gICAgXFxcXF9cXFxcIFxcXFwgICAgICBfXyAgIFxcL1xcXFxfXFxcXCAgICAgIF9fICAgICAgIF9fXyBcXFxcIFxcXFwgXFxcXFxcL1xcJ1xcXFwgICAgXFxyXFxuIFxcXFwgXFxcXCAgXyAgXFxcXCBcXC9cXFxcIFxcXFxcXC9cXFxcIFxcXFwgICBcXC9cXCdfYCBcXFxcICAgXFwvXFwnX19gXFxcXCBcXFxcXFwvXFxcXCBcXFxcICAgXFwvXFwnX19gXFxcXCAgICBcXC9cXCdfX19cXFxcXFxcXCBcXFxcICwgPCAgICBcXHJcXG4gIFxcXFwgXFxcXCBcXFxcIFxcXFwgXFxcXFxcXFwgXFxcXCBcXFxcX1xcXFwgXFxcXCBcXC9cXFxcIFxcXFxMXFxcXCBcXFxcIFxcL1xcXFwgIF9fXFwvICBcXFxcIFxcXFwgXFxcXCBcXC9cXFxcIFxcXFxMXFxcXC5cXFxcXyBcXC9cXFxcIFxcXFxfX1xcLyBcXFxcIFxcXFwgXFxcXFxcXFxgXFxcXCAgXFxyXFxuICAgXFxcXCBcXFxcX1xcXFwgXFxcXF9cXFxcXFxcXFxcL2BfX19fIFxcXFxcXFxcIFxcXFxfX18sX1xcXFxcXFxcIFxcXFxfX19fXFxcXCBfXFxcXCBcXFxcIFxcXFxcXFxcIFxcXFxfX1xcLy5cXFxcX1xcXFxcXFxcIFxcXFxfX19fXFxcXCBcXFxcIFxcXFxfXFxcXCBcXFxcX1xcXFxcXHJcXG4gICAgXFxcXFxcL19cXC9cXFxcXFwvX1xcLyBgXFwvX19fXFwvPiBcXFxcXFxcXFxcL19fLF8gXFwvIFxcXFxcXC9fX19fXFwvXFwvXFxcXCBcXFxcX1xcXFwgXFxcXFxcXFxcXC9fX1xcL1xcXFxcXC9fXFwvIFxcXFxcXC9fX19fXFwvICBcXFxcXFwvX1xcL1xcXFxcXC9fXFwvXFxyXFxuICAgICAgICAgICAgICAgIFxcL1xcXFxfX19cXC8gICAgICAgICAgICAgICAgXFxcXCBcXFxcX19fX1xcLyAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcclxcbiAgICAgICAgICAgICAgICBcXFxcXFwvX19cXC8gICAgICAgICAgICAgICAgICBcXFxcXFwvX19fXFwvICAgICAgICAgICAgICAgICAgICAgICAgICAgICcpO1xuY29uc29sZS5sb2coJ0NvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyLicpO1xuY29uc29sZS5sb2coJ0xpY2Vuc2VkIHVuZGVyIE1JVC4nKTtcbmNvbnNvbGUubG9nKCdEZXNpZ246IEh5ZGVqYWNrIGJ5IEBxd3RlbC4gR2V0IGl0IGF0OiBodHRwczovL3F3dGVsLmNvbS9oeWRlamFjaycpO1xuY29uc29sZS5sb2coYFZlcnNpb246ICR7d2luZG93Ll92ZXJzaW9ufWApO1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE3IEZsb3JpYW4gS2xhbXBmZXJcbi8vIExpY2Vuc2VkIHVuZGVyIE1JVFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ZlYXR1cmVzKGZlYXR1cmVzKSB7XG4gIGxldCBhY2MgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgIGNvbnN0IGhhc0ZlYXR1cmUgPSB3aW5kb3cuTW9kZXJuaXpyW2ZlYXR1cmVdO1xuICAgIC8vIGlmICghaGFzRmVhdHVyZSkgY29uc29sZS53YXJuKCdGZWF0dXJlIFwiJyArIGZlYXR1cmUgKyAnXCIgbWlzc2luZyEnKTtcbiAgICBhY2MgPSBhY2MgJiYgaGFzRmVhdHVyZTtcbiAgfVxuICByZXR1cm4gYWNjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdyhlbCkge1xuICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgZWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhpZGUoZWwpIHtcbiAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5zaG93KGVsKSB7XG4gIGVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgZWwuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xufVxuXG5leHBvcnQgY29uc3QgdW5oaWRlID0gdW5zaG93O1xuXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIChlbC5tYXRjaGVzIHx8IGVsLm1hdGNoZXNTZWxlY3RvciB8fCBlbC5tc01hdGNoZXNTZWxlY3RvciB8fCBlbC5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWwub01hdGNoZXNTZWxlY3RvcikuY2FsbChlbCwgc2VsZWN0b3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYW5pbWF0ZShlbCwga2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXIpID0+IHtcbiAgICBjb25zdCBhbmltID0gZWwuYW5pbWF0ZShrZXlmcmFtZXMsIG9wdGlvbnMpO1xuXG4gICAgYW5pbS5hZGRFdmVudExpc3RlbmVyKCdmaW5pc2gnLCAoZSkgPT4ge1xuICAgICAgb2JzZXJ2ZXIubmV4dChlKTtcbiAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gaWYgKGFuaW0ucGxheVN0YXRlICE9PSAnZmluaXNoZWQnKSBhbmltLmNhbmNlbCgpO1xuICAgIH07XG4gIH0pO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE3IEZsb3JpYW4gS2xhbXBmZXJcbi8vIExpY2Vuc2VkIHVuZGVyIE1JVFxuXG4vKlxuZXNsaW50LWRpc2FibGVcbm5vLXBhcmFtLXJlYXNzaWduLFxuaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzLFxuaW1wb3J0L25vLXVucmVzb2x2ZWQsXG5pbXBvcnQvZXh0ZW5zaW9ucyxcbmNsYXNzLW1ldGhvZHMtdXNlLXRoaXMsXG4qL1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGVtcHR5IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2VtcHR5JztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgdGltZXIgfSBmcm9tICdyeGpzL29ic2VydmFibGUvdGltZXInO1xuaW1wb3J0IENvbG9yIGZyb20gJ2NvbG9yJztcblxuaW1wb3J0IHsgX2RvIGFzIGVmZmVjdCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvZG8nO1xuaW1wb3J0IHsgX2ZpbmFsbHkgYXMgY2xlYW51cCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvZmluYWxseSc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9yL21hcCc7XG5pbXBvcnQgeyB6aXBQcm90byBhcyB6aXBXaXRoIH0gZnJvbSAncnhqcy9vcGVyYXRvci96aXAnO1xuXG5pbXBvcnQgeyBhbmltYXRlIH0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB7IGZpbmQgfSA9IEFycmF5LnByb3RvdHlwZTtcblxuY29uc3QgQk9SREVSX0NPTE9SX0ZBREUgPSAwLjg7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlKHsgY29sb3IgPSAnIzAwZicgfSA9IHt9KSB7XG4gIHRoaXMucnVsZXNbMF0uc3R5bGUuY29sb3IgPSBjb2xvcjsgLy8gLmNvbnRlbnQgYVxuICB0aGlzLnJ1bGVzWzBdLnN0eWxlLmJvcmRlckNvbG9yID0gQ29sb3IoY29sb3IpLmZhZGUoQk9SREVSX0NPTE9SX0ZBREUpLnN0cmluZygpO1xuICB0aGlzLnJ1bGVzWzFdLnN0eWxlLmJvcmRlckNvbG9yID0gY29sb3I7XG4gIHRoaXMucnVsZXNbMl0uc3R5bGUub3V0bGluZUNvbG9yID0gY29sb3I7IC8vIDpmb2N1c1xuICB0aGlzLnJ1bGVzWzNdLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yOyAvLyA6OnNlbGVjdGlvblxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDcm9zc0ZhZGVyIHtcbiAgY29uc3RydWN0b3IoeyBkdXJhdGlvbiB9KSB7XG4gICAgdGhpcy5zaWRlYmFyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19zaWRlYmFyJyk7XG4gICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuXG4gICAgY29uc3QgcGFnZVN0eWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19wYWdlU3R5bGUnKTtcbiAgICBjb25zdCBzdHlsZVNoZWV0ID0gZG9jdW1lbnQuc3R5bGVTaGVldHM6OmZpbmQoc3MgPT4gc3Mub3duZXJOb2RlID09PSBwYWdlU3R5bGUpO1xuICAgIHRoaXMucnVsZXMgPSBzdHlsZVNoZWV0LmNzc1J1bGVzIHx8IHN0eWxlU2hlZXQucnVsZXM7XG4gICAgdGhpcy5sYXN0SW1hZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX21haW4nKS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW1hZ2UnKTtcbiAgfVxuXG4gIGZldGNoSW1hZ2UoZGF0YXNldCkge1xuICAgIGNvbnN0IHsgY29sb3IsIGltYWdlIH0gPSBkYXRhc2V0O1xuXG4gICAgaWYgKGltYWdlID09PSB0aGlzLmxhc3RJbWFnZSkge1xuICAgICAgcmV0dXJuIE9ic2VydmFibGU6OmVtcHR5KCk7XG4gICAgfVxuXG4gICAgbGV0IHJlcyQ7XG4gICAgaWYgKGltYWdlID09PSAnJykge1xuICAgICAgcmVzJCA9IE9ic2VydmFibGU6OnRpbWVyKHRoaXMuZHVyYXRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpbWdPYmogPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgcmVzJCA9IE9ic2VydmFibGU6OmZyb21FdmVudChpbWdPYmosICdsb2FkJylcbiAgICAgICAgOjp6aXBXaXRoKE9ic2VydmFibGU6OnRpbWVyKHRoaXMuZHVyYXRpb24pLCB4ID0+IHgpXG4gICAgICAgIDo6Y2xlYW51cCgoKSA9PiB7IGltZ09iai5zcmMgPSAnJzsgfSk7XG5cbiAgICAgIGltZ09iai5zcmMgPSBpbWFnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzJFxuICAgICAgOjplZmZlY3QoKCkgPT4ge1xuICAgICAgICB0aGlzOjp1cGRhdGVTdHlsZShkYXRhc2V0KTtcbiAgICAgICAgdGhpcy5sYXN0SW1hZ2UgPSBpbWFnZTtcbiAgICAgIH0pXG4gICAgICA6Om1hcCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkaXYuY2xhc3NMaXN0LmFkZCgnc2lkZWJhci1iZycpO1xuICAgICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7XG4gICAgICAgIGlmIChpbWFnZSAhPT0gJycpIGRpdi5zdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBgdXJsKCR7aW1hZ2V9KWA7XG4gICAgICAgIHJldHVybiBkaXY7XG4gICAgICB9KTtcbiAgfVxuXG4gIGNyb3NzRmFkZShbcHJldkRpdiwgZGl2XSkge1xuICAgIHByZXZEaXYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZGl2LCBwcmV2RGl2Lm5leHRFbGVtZW50U2libGluZyk7XG5cbiAgICByZXR1cm4gYW5pbWF0ZShkaXYsIFtcbiAgICAgIHsgb3BhY2l0eTogMCB9LFxuICAgICAgeyBvcGFjaXR5OiAxIH0sXG4gICAgXSwge1xuICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAvLyBlYXNpbmc6ICdjdWJpYy1iZXppZXIoMCwwLDAuMzIsMSknLFxuICAgIH0pXG4gICAgOjpjbGVhbnVwKCgpID0+IHByZXZEaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwcmV2RGl2KSk7XG4gIH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyXG4vLyBMaWNlbnNlZCB1bmRlciBNSVRcblxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzLCBpbXBvcnQvbm8tdW5yZXNvbHZlZCwgaW1wb3J0L2V4dGVuc2lvbnMgKi9cblxuaW1wb3J0IFlEcmF3ZXIgZnJvbSAneS1kcmF3ZXIvc3JjL3ZhbmlsbGEnO1xuXG5pbXBvcnQgeyBoYXNGZWF0dXJlcyB9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgUkVRVUlSRU1FTlRTID0gW1xuICAnZXZlbnRsaXN0ZW5lcicsXG4gICdxdWVyeXNlbGVjdG9yJyxcbiAgJ21hdGNobWVkaWEnLFxuICAncmVxdWVzdGFuaW1hdGlvbmZyYW1lJyxcbiAgJ2NsYXNzbGlzdCcsXG4gICdvcGFjaXR5JyxcbiAgJ2Nzc3RyYW5zZm9ybXMnLFxuICAnY3NzcG9pbnRlcmV2ZW50cycsXG4gICdjc3NyZW11bml0Jyxcbl07XG5cbmNvbnN0IE1FRElBX1FVRVJZID0gJyhtaW4td2lkdGg6IDgwMXB4KSc7XG5cbmZ1bmN0aW9uIHJlc2l6ZUNhbGxiYWNrKCkge1xuICBjb25zdCBoYXNDaGFuZ2VkID0gd2luZG93LmlzRGVza3RvcCAhPT0gd2luZG93Lm1hdGNoTWVkaWEoTUVESUFfUVVFUlkpLm1hdGNoZXM7XG4gIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgd2luZG93LmlzRGVza3RvcCA9ICF3aW5kb3cuaXNEZXNrdG9wO1xuICAgIHdpbmRvdy5kcmF3ZXIucGVyc2lzdGVudCA9IHdpbmRvdy5pc0Rlc2t0b3A7XG4gICAgd2luZG93LmRyYXdlci5qdW1wVG8od2luZG93LmlzRGVza3RvcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVudUNsaWNrQ2xhbGxiYWNrKGUpIHtcbiAgaWYgKCF3aW5kb3cuaXNEZXNrdG9wKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHdpbmRvdy5kcmF3ZXIudG9nZ2xlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoZHJhd2VyKSB7XG4gIHdpbmRvdy5kcmF3ZXIgPSBkcmF3ZXI7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVDYWxsYmFjayk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfbWVudScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgbWVudUNsaWNrQ2xhbGxiYWNrKTtcbn1cblxuaWYgKGhhc0ZlYXR1cmVzKFJFUVVJUkVNRU5UUykpIHtcbiAgd2luZG93LmlzRGVza3RvcCA9IHdpbmRvdy5tYXRjaE1lZGlhKE1FRElBX1FVRVJZKS5tYXRjaGVzO1xuICBjb25zdCBkcmF3ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX3lEcmF3ZXInKTtcblxuICBhZGRFdmVudExpc3RlbmVycyhuZXcgWURyYXdlcihkcmF3ZXIsIHtcbiAgICBvcGVuZWQ6IHdpbmRvdy5pc0Rlc2t0b3AsXG4gICAgcGVyc2lzdGVudDogd2luZG93LmlzRGVza3RvcCxcbiAgICB0cmFuc2l0aW9uRHVyYXRpb246IDE1MCxcbiAgfSkpO1xuXG4gIGRyYXdlci5jbGFzc0xpc3QuYWRkKCdsb2FkZWQnKTtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyXG4vLyBMaWNlbnNlZCB1bmRlciBNSVRcblxuLypcbmVzbGludC1kaXNhYmxlXG5jbGFzcy1tZXRob2RzLXVzZS10aGlzXG4qL1xuXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGVtcHR5IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2VtcHR5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmxpcCB7XG4gIHN0YXRpYyBjcmVhdGUodHlwZSwgLi4uYXJncykge1xuICAgIHJldHVybiBGbGlwLnR5cGVzW3R5cGVdICE9IG51bGwgP1xuICAgICAgbmV3IEZsaXAudHlwZXNbdHlwZV0oLi4uYXJncykgOlxuICAgICAgbmV3IEZsaXAoLi4uYXJncyk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih7IHNoYWRvd01haW4sIGR1cmF0aW9uIH0pIHtcbiAgICB0aGlzLnNoYWRvd01haW4gPSBzaGFkb3dNYWluO1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIC8vIEhBQ0s6IHVzZSBwcm9wZXIgY2xlYW51cCBpbnN0ZWFkXG4gICAgdGhpcy5zaGFkb3dNYWluLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuc2hhZG93TWFpbi5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG5cbiAgICByZXR1cm4gT2JzZXJ2YWJsZTo6ZW1wdHkoKTtcbiAgfVxuXG4gIHJlYWR5KCkge1xuICAgIHJldHVybiBPYnNlcnZhYmxlOjplbXB0eSgpO1xuICB9XG59XG5cbkZsaXAudHlwZXMgPSB7fTtcbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyXG4vLyBMaWNlbnNlZCB1bmRlciBNSVRcblxuLypcbmVzbGludC1kaXNhYmxlXG5uby1wYXJhbS1yZWFzc2lnbixcbmltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcyxcbmltcG9ydC9uby11bnJlc29sdmVkLFxuaW1wb3J0L2V4dGVuc2lvbnMsXG5jbGFzcy1tZXRob2RzLXVzZS10aGlzLFxuKi9cblxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9vZic7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCB7IHRpbWVyIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL3RpbWVyJztcblxuaW1wb3J0IHsgX2RvIGFzIGVmZmVjdCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvZG8nO1xuaW1wb3J0IHsgX2ZpbmFsbHkgYXMgY2xlYW51cCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvZmluYWxseSc7XG5pbXBvcnQgeyB6aXBQcm90byBhcyB6aXBXaXRoIH0gZnJvbSAncnhqcy9vcGVyYXRvci96aXAnO1xuXG5pbXBvcnQgeyBhbmltYXRlIH0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCBGbGlwIGZyb20gJy4vZmxpcCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2plY3RGbGlwIGV4dGVuZHMgRmxpcCB7XG4gIHN0YXJ0KGN1cnJlbnRUYXJnZXQpIHtcbiAgICBjb25zdCBpbWcgPSBjdXJyZW50VGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJy5pbWcnKTtcblxuICAgIHRoaXMuc2hhZG93TWFpbi5xdWVyeVNlbGVjdG9yKCcucGFnZScpLmlubmVySFRNTCA9IGBcbiAgICAgIDxoMSBjbGFzcz1cInBhZ2UtdGl0bGVcIiBzdHlsZT1cIm9wYWNpdHk6MFwiPnw8L2gxPlxuICAgICAgPGRpdiBjbGFzcz1cInBvc3QtZGF0ZSBoZWFkaW5nXCIgc3R5bGU9XCJvcGFjaXR5OjBcIj58PC9kaXY+XG4gICAgYDtcblxuICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcGxhY2Vob2xkZXIuY2xhc3NMaXN0LmFkZCgnc2l4dGVlbi1uaW5lJyk7XG5cbiAgICBpbWcucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUocGxhY2Vob2xkZXIsIGltZyk7XG4gICAgaW1nLmNsYXNzTGlzdC5hZGQoJ2xlYWQnKTtcbiAgICBpbWcuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJ2xlZnQgdG9wJztcblxuICAgIHRoaXMuc2hhZG93TWFpbi5xdWVyeVNlbGVjdG9yKCcucGFnZScpLmFwcGVuZENoaWxkKGltZyk7XG4gICAgdGhpcy5zaGFkb3dNYWluLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICB0aGlzLnNoYWRvd01haW4uc3R5bGUub3BhY2l0eSA9IDE7XG5cbiAgICBjb25zdCBmaXJzdCA9IHBsYWNlaG9sZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGxhc3QgPSBpbWcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBjb25zdCBpbnZlcnRYID0gZmlyc3QubGVmdCAtIGxhc3QubGVmdDtcbiAgICBjb25zdCBpbnZlcnRZID0gZmlyc3QudG9wIC0gbGFzdC50b3A7XG4gICAgY29uc3QgaW52ZXJ0U2NhbGUgPSBmaXJzdC53aWR0aCAvIGxhc3Qud2lkdGg7XG5cbiAgICByZXR1cm4gYW5pbWF0ZShpbWcsIFtcbiAgICAgIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtpbnZlcnRYfXB4LCAke2ludmVydFl9cHgsIDApIHNjYWxlKCR7aW52ZXJ0U2NhbGV9KWAgfSxcbiAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlM2QoMCwgMCwgMCkgc2NhbGUoMSknIH0sXG4gICAgXSwge1xuICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAvLyBlYXNpbmc6ICdlYXNlJyxcbiAgICAgIGVhc2luZzogJ2N1YmljLWJlemllcigwLDAsMC4zMiwxKScsXG4gICAgfSlcbiAgICAgIDo6ZWZmZWN0KCgpID0+IHsgdGhpcy5zaGFkb3dNYWluLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJzsgfSk7XG4gIH1cblxuICByZWFkeShtYWluKSB7XG4gICAgdGhpcy5zaGFkb3dNYWluLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG5cbiAgICBjb25zdCBpbWcgPSBtYWluLnF1ZXJ5U2VsZWN0b3IoJy5pbWcnKTtcblxuICAgIGlmIChpbWcgIT0gbnVsbCkge1xuICAgICAgaW1nLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgaW1nLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgfVxuXG4gICAgY29uc3QgcmVhbEltZyA9IGltZy5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgICByZXR1cm4gKHJlYWxJbWcgPT0gbnVsbCA/XG4gICAgICBPYnNlcnZhYmxlOjpvZih0cnVlKSA6XG4gICAgICBPYnNlcnZhYmxlOjpmcm9tRXZlbnQocmVhbEltZywgJ2xvYWQnKVxuICAgIClcbiAgICAgIC8vIEhBQ0s6IGFkZCBzb21lIGV4dHJhIHRpbWUgdG8gcHJldmVudCBoaWNjdXBzXG4gICAgICA6OnppcFdpdGgoT2JzZXJ2YWJsZTo6dGltZXIodGhpcy5kdXJhdGlvbiArIDEwMCkpXG4gICAgICA6OmVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpbWcgIT0gbnVsbCkge1xuICAgICAgICAgIGltZy5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICBpbWcuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgOjpjbGVhbnVwKCgpID0+IHtcbiAgICAgICAgdGhpcy5zaGFkb3dNYWluLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB0aGlzLnNoYWRvd01haW4uc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgICAgfSk7XG4gIH1cbn1cblxuRmxpcC50eXBlcy5wcm9qZWN0ID0gUHJvamVjdEZsaXA7XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgRmxvcmlhbiBLbGFtcGZlclxuLy8gTGljZW5zZWQgdW5kZXIgTUlUXG5cbi8qXG5lc2xpbnQtZGlzYWJsZVxubm8tcGFyYW0tcmVhc3NpZ24sXG5pbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXMsXG5pbXBvcnQvbm8tdW5yZXNvbHZlZCxcbmltcG9ydC9leHRlbnNpb25zLFxuY2xhc3MtbWV0aG9kcy11c2UtdGhpcyxcbiovXG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgdGltZXIgfSBmcm9tICdyeGpzL29ic2VydmFibGUvdGltZXInO1xuXG5pbXBvcnQgeyBfZG8gYXMgZWZmZWN0IH0gZnJvbSAncnhqcy9vcGVyYXRvci9kbyc7XG5pbXBvcnQgeyBfZmluYWxseSBhcyBjbGVhbnVwIH0gZnJvbSAncnhqcy9vcGVyYXRvci9maW5hbGx5JztcblxuaW1wb3J0IHsgYW5pbWF0ZSB9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgRmxpcCBmcm9tICcuL2ZsaXAnO1xuXG5jb25zdCBUSVRMRV9TRUxFQ1RPUiA9ICcucGFnZS10aXRsZSwgLnBvc3QtdGl0bGUnO1xuXG5jbGFzcyBUaXRsZUZsaXAgZXh0ZW5kcyBGbGlwIHtcbiAgc3RhcnQoY3VycmVudFRhcmdldCkge1xuICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDEnKTtcblxuICAgIHRpdGxlLmNsYXNzTGlzdC5hZGQoJ3BhZ2UtdGl0bGUnKTtcbiAgICB0aXRsZS50ZXh0Q29udGVudCA9IGN1cnJlbnRUYXJnZXQudGV4dENvbnRlbnQ7XG4gICAgdGl0bGUuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJ2xlZnQgdG9wJztcblxuICAgIHRoaXMuc2hhZG93TWFpbi5xdWVyeVNlbGVjdG9yKCcucGFnZScpLmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMuc2hhZG93TWFpbi5xdWVyeVNlbGVjdG9yKCcucGFnZScpLmFwcGVuZENoaWxkKHRpdGxlKTtcbiAgICB0aGlzLnNoYWRvd01haW4uc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIHRoaXMuc2hhZG93TWFpbi5zdHlsZS5vcGFjaXR5ID0gMTtcblxuICAgIGNvbnN0IGZpcnN0ID0gY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBmaXJzdEZvbnRTaXplID0gcGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50VGFyZ2V0KS5mb250U2l6ZSwgMTApO1xuICAgIGNvbnN0IGxhc3QgPSB0aXRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBsYXN0Rm9udFNpemUgPSBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKHRpdGxlKS5mb250U2l6ZSwgMTApO1xuXG4gICAgY29uc3QgaW52ZXJ0WCA9IGZpcnN0LmxlZnQgLSBsYXN0LmxlZnQ7XG4gICAgY29uc3QgaW52ZXJ0WSA9IGZpcnN0LnRvcCAtIGxhc3QudG9wO1xuICAgIGNvbnN0IGludmVydFNjYWxlID0gZmlyc3RGb250U2l6ZSAvIGxhc3RGb250U2l6ZTtcblxuICAgIGN1cnJlbnRUYXJnZXQuc3R5bGUub3BhY2l0eSA9IDA7XG5cbiAgICByZXR1cm4gYW5pbWF0ZSh0aXRsZSwgW1xuICAgICAgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUzZCgke2ludmVydFh9cHgsICR7aW52ZXJ0WX1weCwgMCkgc2NhbGUoJHtpbnZlcnRTY2FsZX0pYCB9LFxuICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgwLCAwLCAwKSBzY2FsZSgxKScgfSxcbiAgICBdLCB7XG4gICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgIC8vIGVhc2luZzogJ2Vhc2UnLFxuICAgICAgZWFzaW5nOiAnY3ViaWMtYmV6aWVyKDAsMCwwLjMyLDEpJyxcbiAgICB9KVxuICAgICAgOjplZmZlY3QoKCkgPT4geyB0aGlzLnNoYWRvd01haW4uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnOyB9KTtcbiAgfVxuXG4gIHJlYWR5KG1haW4pIHtcbiAgICB0aGlzLnNoYWRvd01haW4uc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcblxuICAgIGNvbnN0IHRpdGxlID0gbWFpbi5xdWVyeVNlbGVjdG9yKFRJVExFX1NFTEVDVE9SKTtcblxuICAgIGlmICh0aXRsZSAhPSBudWxsKSB7XG4gICAgICB0aXRsZS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIHRpdGxlLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgfVxuXG4gICAgLy8gSEFDSzogYWRkIHNvbWUgZXh0cmEgdGltZSB0byBwcmV2ZW50IGhpY2N1cHNcbiAgICByZXR1cm4gT2JzZXJ2YWJsZTo6dGltZXIodGhpcy5kdXJhdGlvbiArIDEwMClcbiAgICAgIDo6ZWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgICB0aXRsZS5zdHlsZS5vcGFjaXR5ID0gMTtcbiAgICAgICAgICB0aXRsZS5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICA6OmNsZWFudXAoKCkgPT4ge1xuICAgICAgICB0aGlzLnNoYWRvd01haW4uc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIHRoaXMuc2hhZG93TWFpbi5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gICAgICB9KTtcbiAgfVxufVxuXG5GbGlwLnR5cGVzLnRpdGxlID0gVGl0bGVGbGlwO1xuIiwiLy8gIF9fICBfXyAgICAgICAgICAgICAgICBfXyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfX1xuLy8gL1xcIFxcL1xcIFxcICAgICAgICAgICAgICAvXFwgXFwgICAgICAgICAgICAgX18gICAgICAgICAgICAgICAgICAgIC9cXCBcXFxuLy8gXFwgXFwgXFxfXFwgXFwgICBfXyAgX18gICAgXFxfXFwgXFwgICAgICBfXyAgIC9cXF9cXCAgICAgIF9fICAgICAgIF9fXyBcXCBcXCBcXC8nXFxcbi8vICBcXCBcXCAgXyAgXFwgL1xcIFxcL1xcIFxcICAgLydfYCBcXCAgIC8nX19gXFwgXFwvXFwgXFwgICAvJ19fYFxcICAgIC8nX19fXFxcXCBcXCAsIDxcbi8vICAgXFwgXFwgXFwgXFwgXFxcXCBcXCBcXF9cXCBcXCAvXFwgXFxMXFwgXFwgL1xcICBfXy8gIFxcIFxcIFxcIC9cXCBcXExcXC5cXF8gL1xcIFxcX18vIFxcIFxcIFxcXFxgXFxcbi8vICAgIFxcIFxcX1xcIFxcX1xcXFwvYF9fX18gXFxcXCBcXF9fXyxfXFxcXCBcXF9fX19cXCBfXFwgXFwgXFxcXCBcXF9fLy5cXF9cXFxcIFxcX19fX1xcIFxcIFxcX1xcIFxcX1xcXG4vLyAgICAgXFwvXy9cXC9fLyBgL19fXy8+IFxcXFwvX18sXyAvIFxcL19fX18vL1xcIFxcX1xcIFxcXFwvX18vXFwvXy8gXFwvX19fXy8gIFxcL18vXFwvXy9cbi8vICAgICAgICAgICAgICAgICAvXFxfX18vICAgICAgICAgICAgICAgIFxcIFxcX19fXy9cbi8vICAgICAgICAgICAgICAgICBcXC9fXy8gICAgICAgICAgICAgICAgICBcXC9fX18vXG4vL1xuLy8gQ29weXJpZ2h0IChjKSAyMDE3IEZsb3JpYW4gS2xhbXBmZXJcbi8vIExpY2Vuc2VkIHVuZGVyIE1JVFxuLy8gRGVzaWduOiBIeWRlamFjayBieSBAcXd0ZWwuIEdldCBpdCBhdDogaHR0cHM6Ly9xd3RlbC5jb20vaHlkZWphY2tcblxuaW1wb3J0ICdjb3JlLWpzL2ZuL2FycmF5L2Zvci1lYWNoJztcbmltcG9ydCAnY29yZS1qcy9mbi9hcnJheS9maW5kJztcbmltcG9ydCAnY29yZS1qcy9mbi9mdW5jdGlvbi9iaW5kJztcbmltcG9ydCAnY29yZS1qcy9mbi9udW1iZXIvY29uc3RydWN0b3InO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL29iamVjdC9hc3NpZ24nO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHknO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL29iamVjdC9rZXlzJztcbmltcG9ydCAnY29yZS1qcy9mbi9hcnJheS9yZWR1Y2UnO1xuaW1wb3J0ICd3ZWItYW5pbWF0aW9ucy1qcyc7XG5cbmltcG9ydCAnLi4vbGliL21vZGVybml6cic7XG5pbXBvcnQgJy4uL2xpYi92ZXJzaW9uJztcblxuaW1wb3J0ICcuL2thdGV4JztcbmltcG9ydCAnLi9kcmF3ZXInO1xuaW1wb3J0ICcuL3B1c2gtc3RhdGUnO1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE3IEZsb3JpYW4gS2xhbXBmZXJcbi8vIExpY2Vuc2VkIHVuZGVyIE1JVFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuXG5pbXBvcnQga2F0ZXggZnJvbSAna2F0ZXgnO1xuXG5pbXBvcnQgeyBoYXNGZWF0dXJlcywgaGlkZSwgbWF0Y2hlcyB9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgUkVRVUlSRU1FTlRTID0gW1xuICAnZXZlbnRsaXN0ZW5lcicsXG4gICdxdWVyeXNlbGVjdG9yJyxcbl07XG5cbmZ1bmN0aW9uIHdpbGxDaGFuZ2VDb250ZW50KG1hdGhCbG9ja3MpIHtcbiAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChtYXRoQmxvY2tzLCAoZWwpID0+IHtcbiAgICBlbC5zdHlsZS53aWxsQ2hhbmdlID0gJ2NvbnRlbnQnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlTWF0aEJsb2NrKGVsLCB0ZXgpIHtcbiAgZWwub3V0ZXJIVE1MID0ga2F0ZXgucmVuZGVyVG9TdHJpbmcodGV4LCB7XG4gICAgZGlzcGxheU1vZGU6IGVsLnR5cGUgPT09ICdtYXRoL3RleDsgbW9kZT1kaXNwbGF5JyxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckthdGV4KGVsLCB0ZXgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwcmV2ID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICByZXBsYWNlTWF0aEJsb2NrKGVsLCB0ZXgpO1xuICAgIGlmIChwcmV2ICYmIG1hdGNoZXMocHJldiwgJy5NYXRoSmF4X1ByZXZpZXcnKSkgaGlkZShwcmV2KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBwcm9kdWN0aW9uIGJ1aWxkcz9cbiAgICBjb25zb2xlLmVycm9yKGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgfSBmaW5hbGx5IHtcbiAgICBlbC5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFRleFNvdXJjZShlbCkge1xuICByZXR1cm4gZWwudGV4dENvbnRlbnQucmVwbGFjZSgnJSA8IVtDREFUQVsnLCAnJykucmVwbGFjZSgnJV1dPicsICcnKTtcbn1cblxuZnVuY3Rpb24gY2hhbmdlQ29udGVudChtYXRoQmxvY2tzKSB7XG4gIC8vIGtyYW1kb3duIGdlbmVyYXRlcyBzY3JpcHQgdGFncyB3aXRoIHR5cGUgXCJtYXRoL3RleFwiXG4gIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobWF0aEJsb2NrcywgKHNjcmlwdCkgPT4ge1xuICAgIGNvbnN0IHRleCA9IHJlYWRUZXhTb3VyY2Uoc2NyaXB0KTtcbiAgICByZW5kZXJLYXRleChzY3JpcHQsIHRleCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cGdyYWRlTWF0aEJsb2NrcygpIHtcbiAgaWYgKGhhc0ZlYXR1cmVzKFJFUVVJUkVNRU5UUykpIHtcbiAgICBjb25zdCBtYXRoQmxvY2tzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0W3R5cGVePVwibWF0aC90ZXhcIl0nKTtcbiAgICBpZiAobWF0aEJsb2Nrcy5sZW5ndGgpIHtcbiAgICAgIHdpbGxDaGFuZ2VDb250ZW50KG1hdGhCbG9ja3MpO1xuICAgICAgY2hhbmdlQ29udGVudChtYXRoQmxvY2tzKTtcbiAgICB9XG4gIH1cbn1cblxuaWYgKGhhc0ZlYXR1cmVzKFJFUVVJUkVNRU5UUykpIHtcbiAgY29uc3QgcmVmID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N0eWxlJylbMF07XG4gIGNvbnN0IHN0eWxlID0gbG9hZENTUygnaHR0cHM6Ly91bnBrZy5jb20va2F0ZXhAMC42LjAvZGlzdC9rYXRleC5taW4uY3NzJywgcmVmKTtcbiAgc3R5bGUuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHVwZ3JhZGVNYXRoQmxvY2tzKTtcbn1cbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyXG4vLyBMaWNlbnNlZCB1bmRlciBNSVRcblxuLypcbmVzbGludC1kaXNhYmxlXG5uby1wYXJhbS1yZWFzc2lnbixcbmltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcyxcbmltcG9ydC9uby11bnJlc29sdmVkLFxuaW1wb3J0L2V4dGVuc2lvbnNcbiovXG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5cbmltcG9ydCB7IF9jYXRjaCBhcyByZWNvdmVyIH0gZnJvbSAncnhqcy9vcGVyYXRvci9jYXRjaCc7XG5pbXBvcnQgeyBfZG8gYXMgZWZmZWN0IH0gZnJvbSAncnhqcy9vcGVyYXRvci9kbyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9yL2RlYm91bmNlVGltZSc7XG5pbXBvcnQgeyBleGhhdXN0TWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvci9leGhhdXN0TWFwJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3IvZmlsdGVyJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvbWFwJztcbmltcG9ydCB7IG1lcmdlTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvci9tZXJnZU1hcCc7XG5pbXBvcnQgeyBwYWlyd2lzZSB9IGZyb20gJ3J4anMvb3BlcmF0b3IvcGFpcndpc2UnO1xuaW1wb3J0IHsgc2hhcmUgfSBmcm9tICdyeGpzL29wZXJhdG9yL3NoYXJlJztcbmltcG9ydCB7IHN0YXJ0V2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3Ivc3RhcnRXaXRoJztcbmltcG9ydCB7IHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3Ivc3dpdGNoTWFwJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvdGFrZVVudGlsJztcbmltcG9ydCB7IHppcFByb3RvIGFzIHppcFdpdGggfSBmcm9tICdyeGpzL29wZXJhdG9yL3ppcCc7XG5cbmltcG9ydCBQdXNoU3RhdGUgZnJvbSAneS1wdXNoLXN0YXRlL3NyYy92YW5pbGxhJztcbmltcG9ydCBlbGVtRGF0YXNldCBmcm9tICdlbGVtLWRhdGFzZXQnO1xuXG5pbXBvcnQgeyBoYXNGZWF0dXJlcywgYW5pbWF0ZSB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCBDcm9zc0ZhZGVyIGZyb20gJy4vY3Jvc3MtZmFkZXInO1xuaW1wb3J0IHVwZ3JhZGVNYXRoQmxvY2tzIGZyb20gJy4va2F0ZXgnO1xuXG5pbXBvcnQgRmxpcCBmcm9tICcuL2ZsaXAvZmxpcCc7XG5pbXBvcnQgJy4vZmxpcC90aXRsZSc7XG5pbXBvcnQgJy4vZmxpcC9wcm9qZWN0JztcblxuY29uc3QgUkVRVUlSRU1FTlRTID0gW1xuICAnZXZlbnRsaXN0ZW5lcicsXG4gICdxdWVyeXNlbGVjdG9yJyxcbiAgJ3JlcXVlc3RhbmltYXRpb25mcmFtZScsXG4gICdjbGFzc2xpc3QnLFxuICAnZG9jdW1lbnRmcmFnbWVudCcsXG4gICdoaXN0b3J5JyxcbiAgJ29wYWNpdHknLFxuICAnY3NzYW5pbWF0aW9ucycsXG5dO1xuXG5jb25zdCBEVVJBVElPTiA9IDI1MDtcbmNvbnN0IEZBREVfRFVSQVRJT04gPSA1MDA7XG5cbi8vIHdoZW5ldmVyIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSBlbmNvdW50ZXJzIGFuIGVycm9yLFxuLy8gd2UgbG9nIGl0IHRvIHRoZSBjb25zb2xlLCBidXQgY29udGludWUgYXMgaWYgaXQgbmV2ZXIgaGFwcGVuZFxuZnVuY3Rpb24gbWFrZVVuc3RvcHBhYmxlKCkge1xuICByZXR1cm4gdGhpczo6cmVjb3ZlcigoZXJyb3IsIGNhdWdodCkgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgcmV0dXJuIGNhdWdodDtcbiAgfSk7XG59XG5cbmlmIChoYXNGZWF0dXJlcyhSRVFVSVJFTUVOVFMpKSB7XG4gIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBpc1NhZmFyaSA9IHVhLmluZGV4T2YoJ3NhZmFyaScpID4gMCAmJiB1YS5pbmRleE9mKCdjaHJvbWUnKSA8IDA7XG5cbiAgY29uc3QgY3Jvc3NGYWRlciA9IG5ldyBDcm9zc0ZhZGVyKHsgZHVyYXRpb246IEZBREVfRFVSQVRJT04gfSk7XG5cbiAgY29uc3QgcHVzaFN0YXRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ195UHVzaFN0YXRlJyk7XG5cbiAgY29uc3Qgc2hhZG93TWFpbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzaGFkb3dNYWluLmNsYXNzTGlzdC5hZGQoJ3NoYWRvdy1tYWluJyk7XG4gIHNoYWRvd01haW4uaW5uZXJIVE1MID0gYFxuICAgIDxkaXYgY2xhc3M9XCJjb250ZW50IGNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzcz1cInBhZ2VcIj48L2Rpdj5cbiAgICA8L2Rpdj5gO1xuICBwdXNoU3RhdGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2hhZG93TWFpbiwgcHVzaFN0YXRlKTtcblxuICBjb25zdCBsb2FkaW5nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGxvYWRpbmcuY2xhc3NMaXN0LmFkZCgnbG9hZGluZycpO1xuICBsb2FkaW5nLmlubmVySFRNTCA9IGBcbiAgICA8c3BhbiBjbGFzcz1cInNyLW9ubHlcIj5Mb2FkaW5nLi4uPC9zcGFuPlxuICAgIDxkaXYgY2xhc3M9XCJzay1mb2xkaW5nLWN1YmVcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzay1jdWJlMSBzay1jdWJlXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwic2stY3ViZTIgc2stY3ViZVwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cInNrLWN1YmU0IHNrLWN1YmVcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzay1jdWJlMyBzay1jdWJlXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gIGA7XG4gIHB1c2hTdGF0ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShsb2FkaW5nLCBwdXNoU3RhdGUpO1xuXG4gIGNvbnN0IHN0YXJ0JCA9IE9ic2VydmFibGU6OmZyb21FdmVudChwdXNoU3RhdGUsICd5LXB1c2gtc3RhdGUtc3RhcnQnKVxuICAgIDo6bWFwKCh7IGRldGFpbCB9KSA9PiBkZXRhaWwpXG4gICAgOjptYXAoZGV0YWlsID0+IFtkZXRhaWwsIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfbWFpbicpXSlcbiAgICA6OmVmZmVjdCgoKSA9PiB7XG4gICAgICAvLyBJZiBhIGxpbmsgb24gdGhlIGRyYXdlciBoYXMgYmVlbiBjbGlja2VkLCBjbG9zZSBpdFxuICAgICAgaWYgKCF3aW5kb3cuaXNEZXNrdG9wICYmIHdpbmRvdy5kcmF3ZXIub3BlbmVkKSB7XG4gICAgICAgIHdpbmRvdy5kcmF3ZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KVxuICAgIDo6c2hhcmUoKTtcblxuICBjb25zdCByZWFkeSQgPSBPYnNlcnZhYmxlOjpmcm9tRXZlbnQocHVzaFN0YXRlLCAneS1wdXNoLXN0YXRlLXJlYWR5JylcbiAgICA6Om1hcCgoeyBkZXRhaWwgfSkgPT4gZGV0YWlsKVxuICAgIDo6c2hhcmUoKTtcblxuICBjb25zdCBwcm9ncmVzcyQgPSBPYnNlcnZhYmxlOjpmcm9tRXZlbnQocHVzaFN0YXRlLCAneS1wdXNoLXN0YXRlLXByb2dyZXNzJylcbiAgICA6Om1hcCgoeyBkZXRhaWwgfSkgPT4gZGV0YWlsKTtcbiAgICAvLyA6OnNoYXJlKCk7XG5cbiAgY29uc3QgYWZ0ZXIkID0gT2JzZXJ2YWJsZTo6ZnJvbUV2ZW50KHB1c2hTdGF0ZSwgJ3ktcHVzaC1zdGF0ZS1hZnRlcicpXG4gICAgOjptYXAoKHsgZGV0YWlsIH0pID0+IGRldGFpbClcbiAgICA6OnNoYXJlKCk7XG5cbiAgLy8gY29uc3QgZXJyb3IkID0gT2JzZXJ2YWJsZS5mcm9tRXZlbnQocHVzaFN0YXRlLCAneS1wdXNoLXN0YXRlLWVycm9yJyk7XG5cbiAgLy8gSEFDS1xuICBpZiAoaXNTYWZhcmkpIHtcbiAgICBPYnNlcnZhYmxlOjpmcm9tRXZlbnQod2luZG93LCAncG9wc3RhdGUnKVxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7IGRvY3VtZW50LmJvZHkuc3R5bGUubWluSGVpZ2h0ID0gJzk5OTk5OXB4JzsgfSk7XG5cbiAgICBhZnRlciRcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4geyBkb2N1bWVudC5ib2R5LnN0eWxlLm1pbkhlaWdodCA9ICcnOyB9KTtcbiAgfVxuXG4gIC8vIEZMSVAgYW5pbWF0aW9uICh3aGVuIGFwcGxpY2FibGUpXG4gIHN0YXJ0JFxuICAgIDo6c3dpdGNoTWFwKChbZGV0YWlsXSkgPT4ge1xuICAgICAgY29uc3QgeyBldmVudDogeyBjdXJyZW50VGFyZ2V0IH0gfSA9IGRldGFpbDtcblxuICAgICAgY29uc3QgZmxpcCA9IEZsaXAuY3JlYXRlKFxuICAgICAgICBjdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSAmJlxuICAgICAgICBjdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1mbGlwJyksIHtcbiAgICAgICAgICBzaGFkb3dNYWluLFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgZHVyYXRpb246IERVUkFUSU9OLFxuICAgICAgICB9KTtcblxuICAgICAgLy8gSEFDSzogVGhpcyBhc3N1bWVzIGtub3dsZWRnZSBvZiB0aGUgaW50ZXJuYWwgcnggcGlwZWxpbmUuXG4gICAgICAvLyBDb3VsZCBwb3NzaWJseSBiZSByZXBsYWNlZCB3aXRoIGB3aXRoTGF0ZXN0RnJvbWAgc2hpbmFuaWdhbnMsXG4gICAgICAvLyBidXQgaXQncyBtb3JlIGNvbnZlbmllbnQgbGlrZSB0aGF0LlxuICAgICAgZGV0YWlsLmZsaXAgPSBmbGlwO1xuXG4gICAgICByZXR1cm4gZmxpcC5zdGFydChjdXJyZW50VGFyZ2V0KTtcbiAgICB9KVxuICAgIDo6bWFrZVVuc3RvcHBhYmxlKClcbiAgICAuc3Vic2NyaWJlKCk7XG5cbiAgLy8gRmFkZSBtYWluIGNvbnRlbnQgb3V0XG4gIHN0YXJ0JFxuICAgIDo6ZWZmZWN0KChbLCBtYWluXSkgPT4geyBtYWluLnN0eWxlLm9wYWNpdHkgPSAwOyB9KVxuICAgIDo6ZmlsdGVyKChbeyB0eXBlIH1dKSA9PiB0eXBlID09PSAncHVzaCcgfHwgIWlzU2FmYXJpKVxuICAgIDo6ZXhoYXVzdE1hcCgoW3sgdHlwZSB9LCBtYWluXSkgPT5cbiAgICAgIGFuaW1hdGUobWFpbiwgW1xuICAgICAgICB7IG9wYWNpdHk6IDEgfSxcbiAgICAgICAgeyBvcGFjaXR5OiAwIH0sXG4gICAgICBdLCB7XG4gICAgICAgIGR1cmF0aW9uOiBEVVJBVElPTixcbiAgICAgICAgLy8gZWFzaW5nOiAnZWFzZScsXG4gICAgICAgIGVhc2luZzogJ2N1YmljLWJlemllcigwLDAsMC4zMiwxKScsXG4gICAgICB9KVxuICAgICAgICA6OmVmZmVjdCgoKSA9PiB7IGlmICh0eXBlID09PSAncHVzaCcpIHdpbmRvdy5zY3JvbGwoMCwgMCk7IH0pXG4gICAgICAgIDo6emlwV2l0aChhZnRlciQpKVxuICAgIDo6bWFrZVVuc3RvcHBhYmxlKClcbiAgICAuc3Vic2NyaWJlKCk7XG5cbiAgLy8gU2hvdyBsb2FkaW5nIGJhciB3aGVuIHRha2luZyBsb25nZXIgdGhhbiBleHBlY3RlZFxuICBwcm9ncmVzcyRcbiAgICA6OmVmZmVjdCgoKSA9PiB7IGxvYWRpbmcuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7IH0pXG4gICAgOjptYWtlVW5zdG9wcGFibGUoKVxuICAgIC5zdWJzY3JpYmUoKTtcblxuICAvLyBUT0RPOiBlcnJvciBtZXNzYWdlIT9cbiAgLy8gZXJyb3IkXG4gIC8vICAgLy8gLmRlbGF5KERVUkFUSU9OKSAvLyBIQUNLXG4gIC8vICAgLmRvKCgpID0+IHtcbiAgLy8gICAgIGxvYWRpbmcuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgLy8gICB9KVxuICAvLyAgIC5zdWJzY3JpYmUoKTtcblxuICAvLyBQcmVwYXJlIHNob3dpbmcgdGhlIG5ldyBjb250ZW50XG4gIHJlYWR5JFxuICAgIDo6ZWZmZWN0KCgpID0+IHsgbG9hZGluZy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyB9KVxuICAgIDo6ZmlsdGVyKCh7IHR5cGUgfSkgPT4gdHlwZSA9PT0gJ3B1c2gnIHx8ICFpc1NhZmFyaSlcbiAgICA6OnN3aXRjaE1hcCgoeyBmbGlwLCBjb250ZW50OiBbbWFpbl0gfSkgPT4gZmxpcC5yZWFkeShtYWluKTo6dGFrZVVudGlsKHN0YXJ0JCkpXG4gICAgOjptYWtlVW5zdG9wcGFibGUoKVxuICAgIC5zdWJzY3JpYmUoKTtcblxuICByZWFkeSRcbiAgICA6OnN3aXRjaE1hcCgoeyBjb250ZW50OiBbbWFpbl0gfSkgPT5cbiAgICAgIGNyb3NzRmFkZXIuZmV0Y2hJbWFnZShlbGVtRGF0YXNldChtYWluKSk6OnRha2VVbnRpbChzdGFydCQpKVxuICAgIDo6c3RhcnRXaXRoKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zaWRlYmFyLWJnJykpXG4gICAgOjpwYWlyd2lzZSgpXG4gICAgOjptZXJnZU1hcCg6OmNyb3NzRmFkZXIuY3Jvc3NGYWRlKVxuICAgIDo6bWFrZVVuc3RvcHBhYmxlKClcbiAgICAuc3Vic2NyaWJlKCk7XG5cbiAgLy8gQW5pbWF0ZSB0aGUgbmV3IGNvbnRlbnRcbiAgYWZ0ZXIkXG4gICAgOjpmaWx0ZXIoKHsgdHlwZSB9KSA9PiB0eXBlID09PSAncHVzaCcgfHwgIWlzU2FmYXJpKVxuICAgIDo6bWFwKGtpbmQgPT4gW2tpbmQsIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21haW4nKV0pXG4gICAgOjpzd2l0Y2hNYXAoKFssIG1haW5dKSA9PlxuICAgICAgYW5pbWF0ZShtYWluLCBbXG4gICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtMnJlbSknLCBvcGFjaXR5OiAwIH0sXG4gICAgICAgIHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgwKScsIG9wYWNpdHk6IDEgfSxcbiAgICAgIF0sIHtcbiAgICAgICAgZHVyYXRpb246IERVUkFUSU9OLFxuICAgICAgICAvLyBlYXNpbmc6ICdlYXNlJyxcbiAgICAgICAgZWFzaW5nOiAnY3ViaWMtYmV6aWVyKDAsMCwwLjMyLDEpJyxcbiAgICAgIH0pKVxuICAgIDo6bWFrZVVuc3RvcHBhYmxlKClcbiAgICAuc3Vic2NyaWJlKCk7XG5cbiAgYWZ0ZXIkXG4gICAgLy8gRG9uJ3Qgc2VuZCBhIHBhZ2V2aWV3IHdoZW4gdGhlIHVzZXIgYmxhc3RzIHRocm91Z2ggdGhlIGhpc3RvcnkuLlxuICAgIDo6ZGVib3VuY2VUaW1lKDIgKiBEVVJBVElPTilcbiAgICA6OmVmZmVjdCgoKSA9PiB7XG4gICAgICAvLyBTZW5kIGdvb2dsZSBhbmFseXRpY3MgcGFnZXZpZXdcbiAgICAgIGlmICh3aW5kb3cuZ2EpIHdpbmRvdy5nYSgnc2VuZCcsICdwYWdldmlldycpO1xuXG4gICAgICAvLyBVcGdyYWRlIG1hdGggYmxvY2tzXG4gICAgICB1cGdyYWRlTWF0aEJsb2NrcygpO1xuICAgIH0pXG4gICAgOjptYWtlVW5zdG9wcGFibGUoKVxuICAgIC5zdWJzY3JpYmUoKTtcblxuICBuZXcgUHVzaFN0YXRlKHB1c2hTdGF0ZSwge1xuICAgIHJlcGxhY2VJZHM6IFsnX21haW4nXSxcbiAgICBsaW5rU2VsZWN0b3I6ICdhW2hyZWZePVwiL1wiXScsXG4gICAgZHVyYXRpb246IERVUkFUSU9OLFxuICAgIG5vUG9wRHVyYXRpb246IGlzU2FmYXJpLFxuICAgIHNjcm9sbFJlc3RvcmF0aW9uOiAhaXNTYWZhcmksXG4gIH0pLnN0YXJ0SGlzdG9yeSgpO1xufVxuIiwiLyogTUlUIGxpY2Vuc2UgKi9cbnZhciBjc3NLZXl3b3JkcyA9IHJlcXVpcmUoJ2NvbG9yLW5hbWUnKTtcblxuLy8gTk9URTogY29udmVyc2lvbnMgc2hvdWxkIG9ubHkgcmV0dXJuIHByaW1pdGl2ZSB2YWx1ZXMgKGkuZS4gYXJyYXlzLCBvclxuLy8gICAgICAgdmFsdWVzIHRoYXQgZ2l2ZSBjb3JyZWN0IGB0eXBlb2ZgIHJlc3VsdHMpLlxuLy8gICAgICAgZG8gbm90IHVzZSBib3ggdmFsdWVzIHR5cGVzIChpLmUuIE51bWJlcigpLCBTdHJpbmcoKSwgZXRjLilcblxudmFyIHJldmVyc2VLZXl3b3JkcyA9IHt9O1xuZm9yICh2YXIga2V5IGluIGNzc0tleXdvcmRzKSB7XG5cdGlmIChjc3NLZXl3b3Jkcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0cmV2ZXJzZUtleXdvcmRzW2Nzc0tleXdvcmRzW2tleV1dID0ga2V5O1xuXHR9XG59XG5cbnZhciBjb252ZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSB7XG5cdHJnYjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdyZ2InfSxcblx0aHNsOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2hzbCd9LFxuXHRoc3Y6IHtjaGFubmVsczogMywgbGFiZWxzOiAnaHN2J30sXG5cdGh3Yjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdod2InfSxcblx0Y215azoge2NoYW5uZWxzOiA0LCBsYWJlbHM6ICdjbXlrJ30sXG5cdHh5ejoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICd4eXonfSxcblx0bGFiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2xhYid9LFxuXHRsY2g6IHtjaGFubmVsczogMywgbGFiZWxzOiAnbGNoJ30sXG5cdGhleDoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnaGV4J119LFxuXHRrZXl3b3JkOiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydrZXl3b3JkJ119LFxuXHRhbnNpMTY6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2Fuc2kxNiddfSxcblx0YW5zaTI1Njoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnYW5zaTI1NiddfSxcblx0aGNnOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogWydoJywgJ2MnLCAnZyddfSxcblx0YXBwbGU6IHtjaGFubmVsczogMywgbGFiZWxzOiBbJ3IxNicsICdnMTYnLCAnYjE2J119LFxuXHRncmF5OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydncmF5J119XG59O1xuXG4vLyBoaWRlIC5jaGFubmVscyBhbmQgLmxhYmVscyBwcm9wZXJ0aWVzXG5mb3IgKHZhciBtb2RlbCBpbiBjb252ZXJ0KSB7XG5cdGlmIChjb252ZXJ0Lmhhc093blByb3BlcnR5KG1vZGVsKSkge1xuXHRcdGlmICghKCdjaGFubmVscycgaW4gY29udmVydFttb2RlbF0pKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG5cdFx0fVxuXG5cdFx0aWYgKCEoJ2xhYmVscycgaW4gY29udmVydFttb2RlbF0pKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbCBsYWJlbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG5cdFx0fVxuXG5cdFx0aWYgKGNvbnZlcnRbbW9kZWxdLmxhYmVscy5sZW5ndGggIT09IGNvbnZlcnRbbW9kZWxdLmNoYW5uZWxzKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NoYW5uZWwgYW5kIGxhYmVsIGNvdW50cyBtaXNtYXRjaDogJyArIG1vZGVsKTtcblx0XHR9XG5cblx0XHR2YXIgY2hhbm5lbHMgPSBjb252ZXJ0W21vZGVsXS5jaGFubmVscztcblx0XHR2YXIgbGFiZWxzID0gY29udmVydFttb2RlbF0ubGFiZWxzO1xuXHRcdGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5jaGFubmVscztcblx0XHRkZWxldGUgY29udmVydFttb2RlbF0ubGFiZWxzO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W21vZGVsXSwgJ2NoYW5uZWxzJywge3ZhbHVlOiBjaGFubmVsc30pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W21vZGVsXSwgJ2xhYmVscycsIHt2YWx1ZTogbGFiZWxzfSk7XG5cdH1cbn1cblxuY29udmVydC5yZ2IuaHNsID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXHR2YXIgbWluID0gTWF0aC5taW4ociwgZywgYik7XG5cdHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcblx0dmFyIGRlbHRhID0gbWF4IC0gbWluO1xuXHR2YXIgaDtcblx0dmFyIHM7XG5cdHZhciBsO1xuXG5cdGlmIChtYXggPT09IG1pbikge1xuXHRcdGggPSAwO1xuXHR9IGVsc2UgaWYgKHIgPT09IG1heCkge1xuXHRcdGggPSAoZyAtIGIpIC8gZGVsdGE7XG5cdH0gZWxzZSBpZiAoZyA9PT0gbWF4KSB7XG5cdFx0aCA9IDIgKyAoYiAtIHIpIC8gZGVsdGE7XG5cdH0gZWxzZSBpZiAoYiA9PT0gbWF4KSB7XG5cdFx0aCA9IDQgKyAociAtIGcpIC8gZGVsdGE7XG5cdH1cblxuXHRoID0gTWF0aC5taW4oaCAqIDYwLCAzNjApO1xuXG5cdGlmIChoIDwgMCkge1xuXHRcdGggKz0gMzYwO1xuXHR9XG5cblx0bCA9IChtaW4gKyBtYXgpIC8gMjtcblxuXHRpZiAobWF4ID09PSBtaW4pIHtcblx0XHRzID0gMDtcblx0fSBlbHNlIGlmIChsIDw9IDAuNSkge1xuXHRcdHMgPSBkZWx0YSAvIChtYXggKyBtaW4pO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblx0fVxuXG5cdHJldHVybiBbaCwgcyAqIDEwMCwgbCAqIDEwMF07XG59O1xuXG5jb252ZXJ0LnJnYi5oc3YgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciByID0gcmdiWzBdO1xuXHR2YXIgZyA9IHJnYlsxXTtcblx0dmFyIGIgPSByZ2JbMl07XG5cdHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcblx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHR2YXIgZGVsdGEgPSBtYXggLSBtaW47XG5cdHZhciBoO1xuXHR2YXIgcztcblx0dmFyIHY7XG5cblx0aWYgKG1heCA9PT0gMCkge1xuXHRcdHMgPSAwO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSAoZGVsdGEgLyBtYXggKiAxMDAwKSAvIDEwO1xuXHR9XG5cblx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0aCA9IDA7XG5cdH0gZWxzZSBpZiAociA9PT0gbWF4KSB7XG5cdFx0aCA9IChnIC0gYikgLyBkZWx0YTtcblx0fSBlbHNlIGlmIChnID09PSBtYXgpIHtcblx0XHRoID0gMiArIChiIC0gcikgLyBkZWx0YTtcblx0fSBlbHNlIGlmIChiID09PSBtYXgpIHtcblx0XHRoID0gNCArIChyIC0gZykgLyBkZWx0YTtcblx0fVxuXG5cdGggPSBNYXRoLm1pbihoICogNjAsIDM2MCk7XG5cblx0aWYgKGggPCAwKSB7XG5cdFx0aCArPSAzNjA7XG5cdH1cblxuXHR2ID0gKChtYXggLyAyNTUpICogMTAwMCkgLyAxMDtcblxuXHRyZXR1cm4gW2gsIHMsIHZdO1xufTtcblxuY29udmVydC5yZ2IuaHdiID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXTtcblx0dmFyIGcgPSByZ2JbMV07XG5cdHZhciBiID0gcmdiWzJdO1xuXHR2YXIgaCA9IGNvbnZlcnQucmdiLmhzbChyZ2IpWzBdO1xuXHR2YXIgdyA9IDEgLyAyNTUgKiBNYXRoLm1pbihyLCBNYXRoLm1pbihnLCBiKSk7XG5cblx0YiA9IDEgLSAxIC8gMjU1ICogTWF0aC5tYXgociwgTWF0aC5tYXgoZywgYikpO1xuXG5cdHJldHVybiBbaCwgdyAqIDEwMCwgYiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LnJnYi5jbXlrID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXHR2YXIgYztcblx0dmFyIG07XG5cdHZhciB5O1xuXHR2YXIgaztcblxuXHRrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG5cdGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcblx0bSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuXHR5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG5cblx0cmV0dXJuIFtjICogMTAwLCBtICogMTAwLCB5ICogMTAwLCBrICogMTAwXTtcbn07XG5cbi8qKlxuICogU2VlIGh0dHBzOi8vZW4ubS53aWtpcGVkaWEub3JnL3dpa2kvRXVjbGlkZWFuX2Rpc3RhbmNlI1NxdWFyZWRfRXVjbGlkZWFuX2Rpc3RhbmNlXG4gKiAqL1xuZnVuY3Rpb24gY29tcGFyYXRpdmVEaXN0YW5jZSh4LCB5KSB7XG5cdHJldHVybiAoXG5cdFx0TWF0aC5wb3coeFswXSAtIHlbMF0sIDIpICtcblx0XHRNYXRoLnBvdyh4WzFdIC0geVsxXSwgMikgK1xuXHRcdE1hdGgucG93KHhbMl0gLSB5WzJdLCAyKVxuXHQpO1xufVxuXG5jb252ZXJ0LnJnYi5rZXl3b3JkID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgcmV2ZXJzZWQgPSByZXZlcnNlS2V5d29yZHNbcmdiXTtcblx0aWYgKHJldmVyc2VkKSB7XG5cdFx0cmV0dXJuIHJldmVyc2VkO1xuXHR9XG5cblx0dmFyIGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcblx0dmFyIGN1cnJlbnRDbG9zZXN0S2V5d29yZDtcblxuXHRmb3IgKHZhciBrZXl3b3JkIGluIGNzc0tleXdvcmRzKSB7XG5cdFx0aWYgKGNzc0tleXdvcmRzLmhhc093blByb3BlcnR5KGtleXdvcmQpKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBjc3NLZXl3b3Jkc1trZXl3b3JkXTtcblxuXHRcdFx0Ly8gQ29tcHV0ZSBjb21wYXJhdGl2ZSBkaXN0YW5jZVxuXHRcdFx0dmFyIGRpc3RhbmNlID0gY29tcGFyYXRpdmVEaXN0YW5jZShyZ2IsIHZhbHVlKTtcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgaXRzIGxlc3MsIGlmIHNvIHNldCBhcyBjbG9zZXN0XG5cdFx0XHRpZiAoZGlzdGFuY2UgPCBjdXJyZW50Q2xvc2VzdERpc3RhbmNlKSB7XG5cdFx0XHRcdGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHRcdFx0Y3VycmVudENsb3Nlc3RLZXl3b3JkID0ga2V5d29yZDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3VycmVudENsb3Nlc3RLZXl3b3JkO1xufTtcblxuY29udmVydC5rZXl3b3JkLnJnYiA9IGZ1bmN0aW9uIChrZXl3b3JkKSB7XG5cdHJldHVybiBjc3NLZXl3b3Jkc1trZXl3b3JkXTtcbn07XG5cbmNvbnZlcnQucmdiLnh5eiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHIgPSByZ2JbMF0gLyAyNTU7XG5cdHZhciBnID0gcmdiWzFdIC8gMjU1O1xuXHR2YXIgYiA9IHJnYlsyXSAvIDI1NTtcblxuXHQvLyBhc3N1bWUgc1JHQlxuXHRyID0gciA+IDAuMDQwNDUgPyBNYXRoLnBvdygoKHIgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCkgOiAociAvIDEyLjkyKTtcblx0ZyA9IGcgPiAwLjA0MDQ1ID8gTWF0aC5wb3coKChnICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpIDogKGcgLyAxMi45Mik7XG5cdGIgPSBiID4gMC4wNDA0NSA/IE1hdGgucG93KCgoYiArIDAuMDU1KSAvIDEuMDU1KSwgMi40KSA6IChiIC8gMTIuOTIpO1xuXG5cdHZhciB4ID0gKHIgKiAwLjQxMjQpICsgKGcgKiAwLjM1NzYpICsgKGIgKiAwLjE4MDUpO1xuXHR2YXIgeSA9IChyICogMC4yMTI2KSArIChnICogMC43MTUyKSArIChiICogMC4wNzIyKTtcblx0dmFyIHogPSAociAqIDAuMDE5MykgKyAoZyAqIDAuMTE5MikgKyAoYiAqIDAuOTUwNSk7XG5cblx0cmV0dXJuIFt4ICogMTAwLCB5ICogMTAwLCB6ICogMTAwXTtcbn07XG5cbmNvbnZlcnQucmdiLmxhYiA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0dmFyIHh5eiA9IGNvbnZlcnQucmdiLnh5eihyZ2IpO1xuXHR2YXIgeCA9IHh5elswXTtcblx0dmFyIHkgPSB4eXpbMV07XG5cdHZhciB6ID0geHl6WzJdO1xuXHR2YXIgbDtcblx0dmFyIGE7XG5cdHZhciBiO1xuXG5cdHggLz0gOTUuMDQ3O1xuXHR5IC89IDEwMDtcblx0eiAvPSAxMDguODgzO1xuXG5cdHggPSB4ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh4LCAxIC8gMykgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG5cdHkgPSB5ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh5LCAxIC8gMykgOiAoNy43ODcgKiB5KSArICgxNiAvIDExNik7XG5cdHogPSB6ID4gMC4wMDg4NTYgPyBNYXRoLnBvdyh6LCAxIC8gMykgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cblx0bCA9ICgxMTYgKiB5KSAtIDE2O1xuXHRhID0gNTAwICogKHggLSB5KTtcblx0YiA9IDIwMCAqICh5IC0geik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQuaHNsLnJnYiA9IGZ1bmN0aW9uIChoc2wpIHtcblx0dmFyIGggPSBoc2xbMF0gLyAzNjA7XG5cdHZhciBzID0gaHNsWzFdIC8gMTAwO1xuXHR2YXIgbCA9IGhzbFsyXSAvIDEwMDtcblx0dmFyIHQxO1xuXHR2YXIgdDI7XG5cdHZhciB0Mztcblx0dmFyIHJnYjtcblx0dmFyIHZhbDtcblxuXHRpZiAocyA9PT0gMCkge1xuXHRcdHZhbCA9IGwgKiAyNTU7XG5cdFx0cmV0dXJuIFt2YWwsIHZhbCwgdmFsXTtcblx0fVxuXG5cdGlmIChsIDwgMC41KSB7XG5cdFx0dDIgPSBsICogKDEgKyBzKTtcblx0fSBlbHNlIHtcblx0XHR0MiA9IGwgKyBzIC0gbCAqIHM7XG5cdH1cblxuXHR0MSA9IDIgKiBsIC0gdDI7XG5cblx0cmdiID0gWzAsIDAsIDBdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdHQzID0gaCArIDEgLyAzICogLShpIC0gMSk7XG5cdFx0aWYgKHQzIDwgMCkge1xuXHRcdFx0dDMrKztcblx0XHR9XG5cdFx0aWYgKHQzID4gMSkge1xuXHRcdFx0dDMtLTtcblx0XHR9XG5cblx0XHRpZiAoNiAqIHQzIDwgMSkge1xuXHRcdFx0dmFsID0gdDEgKyAodDIgLSB0MSkgKiA2ICogdDM7XG5cdFx0fSBlbHNlIGlmICgyICogdDMgPCAxKSB7XG5cdFx0XHR2YWwgPSB0Mjtcblx0XHR9IGVsc2UgaWYgKDMgKiB0MyA8IDIpIHtcblx0XHRcdHZhbCA9IHQxICsgKHQyIC0gdDEpICogKDIgLyAzIC0gdDMpICogNjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFsID0gdDE7XG5cdFx0fVxuXG5cdFx0cmdiW2ldID0gdmFsICogMjU1O1xuXHR9XG5cblx0cmV0dXJuIHJnYjtcbn07XG5cbmNvbnZlcnQuaHNsLmhzdiA9IGZ1bmN0aW9uIChoc2wpIHtcblx0dmFyIGggPSBoc2xbMF07XG5cdHZhciBzID0gaHNsWzFdIC8gMTAwO1xuXHR2YXIgbCA9IGhzbFsyXSAvIDEwMDtcblx0dmFyIHNtaW4gPSBzO1xuXHR2YXIgbG1pbiA9IE1hdGgubWF4KGwsIDAuMDEpO1xuXHR2YXIgc3Y7XG5cdHZhciB2O1xuXG5cdGwgKj0gMjtcblx0cyAqPSAobCA8PSAxKSA/IGwgOiAyIC0gbDtcblx0c21pbiAqPSBsbWluIDw9IDEgPyBsbWluIDogMiAtIGxtaW47XG5cdHYgPSAobCArIHMpIC8gMjtcblx0c3YgPSBsID09PSAwID8gKDIgKiBzbWluKSAvIChsbWluICsgc21pbikgOiAoMiAqIHMpIC8gKGwgKyBzKTtcblxuXHRyZXR1cm4gW2gsIHN2ICogMTAwLCB2ICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHN2LnJnYiA9IGZ1bmN0aW9uIChoc3YpIHtcblx0dmFyIGggPSBoc3ZbMF0gLyA2MDtcblx0dmFyIHMgPSBoc3ZbMV0gLyAxMDA7XG5cdHZhciB2ID0gaHN2WzJdIC8gMTAwO1xuXHR2YXIgaGkgPSBNYXRoLmZsb29yKGgpICUgNjtcblxuXHR2YXIgZiA9IGggLSBNYXRoLmZsb29yKGgpO1xuXHR2YXIgcCA9IDI1NSAqIHYgKiAoMSAtIHMpO1xuXHR2YXIgcSA9IDI1NSAqIHYgKiAoMSAtIChzICogZikpO1xuXHR2YXIgdCA9IDI1NSAqIHYgKiAoMSAtIChzICogKDEgLSBmKSkpO1xuXHR2ICo9IDI1NTtcblxuXHRzd2l0Y2ggKGhpKSB7XG5cdFx0Y2FzZSAwOlxuXHRcdFx0cmV0dXJuIFt2LCB0LCBwXTtcblx0XHRjYXNlIDE6XG5cdFx0XHRyZXR1cm4gW3EsIHYsIHBdO1xuXHRcdGNhc2UgMjpcblx0XHRcdHJldHVybiBbcCwgdiwgdF07XG5cdFx0Y2FzZSAzOlxuXHRcdFx0cmV0dXJuIFtwLCBxLCB2XTtcblx0XHRjYXNlIDQ6XG5cdFx0XHRyZXR1cm4gW3QsIHAsIHZdO1xuXHRcdGNhc2UgNTpcblx0XHRcdHJldHVybiBbdiwgcCwgcV07XG5cdH1cbn07XG5cbmNvbnZlcnQuaHN2LmhzbCA9IGZ1bmN0aW9uIChoc3YpIHtcblx0dmFyIGggPSBoc3ZbMF07XG5cdHZhciBzID0gaHN2WzFdIC8gMTAwO1xuXHR2YXIgdiA9IGhzdlsyXSAvIDEwMDtcblx0dmFyIHZtaW4gPSBNYXRoLm1heCh2LCAwLjAxKTtcblx0dmFyIGxtaW47XG5cdHZhciBzbDtcblx0dmFyIGw7XG5cblx0bCA9ICgyIC0gcykgKiB2O1xuXHRsbWluID0gKDIgLSBzKSAqIHZtaW47XG5cdHNsID0gcyAqIHZtaW47XG5cdHNsIC89IChsbWluIDw9IDEpID8gbG1pbiA6IDIgLSBsbWluO1xuXHRzbCA9IHNsIHx8IDA7XG5cdGwgLz0gMjtcblxuXHRyZXR1cm4gW2gsIHNsICogMTAwLCBsICogMTAwXTtcbn07XG5cbi8vIGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzcy1jb2xvci8jaHdiLXRvLXJnYlxuY29udmVydC5od2IucmdiID0gZnVuY3Rpb24gKGh3Yikge1xuXHR2YXIgaCA9IGh3YlswXSAvIDM2MDtcblx0dmFyIHdoID0gaHdiWzFdIC8gMTAwO1xuXHR2YXIgYmwgPSBod2JbMl0gLyAxMDA7XG5cdHZhciByYXRpbyA9IHdoICsgYmw7XG5cdHZhciBpO1xuXHR2YXIgdjtcblx0dmFyIGY7XG5cdHZhciBuO1xuXG5cdC8vIHdoICsgYmwgY2FudCBiZSA+IDFcblx0aWYgKHJhdGlvID4gMSkge1xuXHRcdHdoIC89IHJhdGlvO1xuXHRcdGJsIC89IHJhdGlvO1xuXHR9XG5cblx0aSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuXHR2ID0gMSAtIGJsO1xuXHRmID0gNiAqIGggLSBpO1xuXG5cdGlmICgoaSAmIDB4MDEpICE9PSAwKSB7XG5cdFx0ZiA9IDEgLSBmO1xuXHR9XG5cblx0biA9IHdoICsgZiAqICh2IC0gd2gpOyAvLyBsaW5lYXIgaW50ZXJwb2xhdGlvblxuXG5cdHZhciByO1xuXHR2YXIgZztcblx0dmFyIGI7XG5cdHN3aXRjaCAoaSkge1xuXHRcdGRlZmF1bHQ6XG5cdFx0Y2FzZSA2OlxuXHRcdGNhc2UgMDogciA9IHY7IGcgPSBuOyBiID0gd2g7IGJyZWFrO1xuXHRcdGNhc2UgMTogciA9IG47IGcgPSB2OyBiID0gd2g7IGJyZWFrO1xuXHRcdGNhc2UgMjogciA9IHdoOyBnID0gdjsgYiA9IG47IGJyZWFrO1xuXHRcdGNhc2UgMzogciA9IHdoOyBnID0gbjsgYiA9IHY7IGJyZWFrO1xuXHRcdGNhc2UgNDogciA9IG47IGcgPSB3aDsgYiA9IHY7IGJyZWFrO1xuXHRcdGNhc2UgNTogciA9IHY7IGcgPSB3aDsgYiA9IG47IGJyZWFrO1xuXHR9XG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5cbmNvbnZlcnQuY215ay5yZ2IgPSBmdW5jdGlvbiAoY215aykge1xuXHR2YXIgYyA9IGNteWtbMF0gLyAxMDA7XG5cdHZhciBtID0gY215a1sxXSAvIDEwMDtcblx0dmFyIHkgPSBjbXlrWzJdIC8gMTAwO1xuXHR2YXIgayA9IGNteWtbM10gLyAxMDA7XG5cdHZhciByO1xuXHR2YXIgZztcblx0dmFyIGI7XG5cblx0ciA9IDEgLSBNYXRoLm1pbigxLCBjICogKDEgLSBrKSArIGspO1xuXHRnID0gMSAtIE1hdGgubWluKDEsIG0gKiAoMSAtIGspICsgayk7XG5cdGIgPSAxIC0gTWF0aC5taW4oMSwgeSAqICgxIC0gaykgKyBrKTtcblxuXHRyZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufTtcblxuY29udmVydC54eXoucmdiID0gZnVuY3Rpb24gKHh5eikge1xuXHR2YXIgeCA9IHh5elswXSAvIDEwMDtcblx0dmFyIHkgPSB4eXpbMV0gLyAxMDA7XG5cdHZhciB6ID0geHl6WzJdIC8gMTAwO1xuXHR2YXIgcjtcblx0dmFyIGc7XG5cdHZhciBiO1xuXG5cdHIgPSAoeCAqIDMuMjQwNikgKyAoeSAqIC0xLjUzNzIpICsgKHogKiAtMC40OTg2KTtcblx0ZyA9ICh4ICogLTAuOTY4OSkgKyAoeSAqIDEuODc1OCkgKyAoeiAqIDAuMDQxNSk7XG5cdGIgPSAoeCAqIDAuMDU1NykgKyAoeSAqIC0wLjIwNDApICsgKHogKiAxLjA1NzApO1xuXG5cdC8vIGFzc3VtZSBzUkdCXG5cdHIgPSByID4gMC4wMDMxMzA4XG5cdFx0PyAoKDEuMDU1ICogTWF0aC5wb3cociwgMS4wIC8gMi40KSkgLSAwLjA1NSlcblx0XHQ6IHIgKiAxMi45MjtcblxuXHRnID0gZyA+IDAuMDAzMTMwOFxuXHRcdD8gKCgxLjA1NSAqIE1hdGgucG93KGcsIDEuMCAvIDIuNCkpIC0gMC4wNTUpXG5cdFx0OiBnICogMTIuOTI7XG5cblx0YiA9IGIgPiAwLjAwMzEzMDhcblx0XHQ/ICgoMS4wNTUgKiBNYXRoLnBvdyhiLCAxLjAgLyAyLjQpKSAtIDAuMDU1KVxuXHRcdDogYiAqIDEyLjkyO1xuXG5cdHIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCByKSwgMSk7XG5cdGcgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBnKSwgMSk7XG5cdGIgPSBNYXRoLm1pbihNYXRoLm1heCgwLCBiKSwgMSk7XG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5cbmNvbnZlcnQueHl6LmxhYiA9IGZ1bmN0aW9uICh4eXopIHtcblx0dmFyIHggPSB4eXpbMF07XG5cdHZhciB5ID0geHl6WzFdO1xuXHR2YXIgeiA9IHh5elsyXTtcblx0dmFyIGw7XG5cdHZhciBhO1xuXHR2YXIgYjtcblxuXHR4IC89IDk1LjA0Nztcblx0eSAvPSAxMDA7XG5cdHogLz0gMTA4Ljg4MztcblxuXHR4ID0geCA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeCwgMSAvIDMpIDogKDcuNzg3ICogeCkgKyAoMTYgLyAxMTYpO1xuXHR5ID0geSA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeSwgMSAvIDMpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuXHR6ID0geiA+IDAuMDA4ODU2ID8gTWF0aC5wb3coeiwgMSAvIDMpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG5cdGwgPSAoMTE2ICogeSkgLSAxNjtcblx0YSA9IDUwMCAqICh4IC0geSk7XG5cdGIgPSAyMDAgKiAoeSAtIHopO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0LmxhYi54eXogPSBmdW5jdGlvbiAobGFiKSB7XG5cdHZhciBsID0gbGFiWzBdO1xuXHR2YXIgYSA9IGxhYlsxXTtcblx0dmFyIGIgPSBsYWJbMl07XG5cdHZhciB4O1xuXHR2YXIgeTtcblx0dmFyIHo7XG5cblx0eSA9IChsICsgMTYpIC8gMTE2O1xuXHR4ID0gYSAvIDUwMCArIHk7XG5cdHogPSB5IC0gYiAvIDIwMDtcblxuXHR2YXIgeTIgPSBNYXRoLnBvdyh5LCAzKTtcblx0dmFyIHgyID0gTWF0aC5wb3coeCwgMyk7XG5cdHZhciB6MiA9IE1hdGgucG93KHosIDMpO1xuXHR5ID0geTIgPiAwLjAwODg1NiA/IHkyIDogKHkgLSAxNiAvIDExNikgLyA3Ljc4Nztcblx0eCA9IHgyID4gMC4wMDg4NTYgPyB4MiA6ICh4IC0gMTYgLyAxMTYpIC8gNy43ODc7XG5cdHogPSB6MiA+IDAuMDA4ODU2ID8gejIgOiAoeiAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuXG5cdHggKj0gOTUuMDQ3O1xuXHR5ICo9IDEwMDtcblx0eiAqPSAxMDguODgzO1xuXG5cdHJldHVybiBbeCwgeSwgel07XG59O1xuXG5jb252ZXJ0LmxhYi5sY2ggPSBmdW5jdGlvbiAobGFiKSB7XG5cdHZhciBsID0gbGFiWzBdO1xuXHR2YXIgYSA9IGxhYlsxXTtcblx0dmFyIGIgPSBsYWJbMl07XG5cdHZhciBocjtcblx0dmFyIGg7XG5cdHZhciBjO1xuXG5cdGhyID0gTWF0aC5hdGFuMihiLCBhKTtcblx0aCA9IGhyICogMzYwIC8gMiAvIE1hdGguUEk7XG5cblx0aWYgKGggPCAwKSB7XG5cdFx0aCArPSAzNjA7XG5cdH1cblxuXHRjID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXG5cdHJldHVybiBbbCwgYywgaF07XG59O1xuXG5jb252ZXJ0LmxjaC5sYWIgPSBmdW5jdGlvbiAobGNoKSB7XG5cdHZhciBsID0gbGNoWzBdO1xuXHR2YXIgYyA9IGxjaFsxXTtcblx0dmFyIGggPSBsY2hbMl07XG5cdHZhciBhO1xuXHR2YXIgYjtcblx0dmFyIGhyO1xuXG5cdGhyID0gaCAvIDM2MCAqIDIgKiBNYXRoLlBJO1xuXHRhID0gYyAqIE1hdGguY29zKGhyKTtcblx0YiA9IGMgKiBNYXRoLnNpbihocik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQucmdiLmFuc2kxNiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciByID0gYXJnc1swXTtcblx0dmFyIGcgPSBhcmdzWzFdO1xuXHR2YXIgYiA9IGFyZ3NbMl07XG5cdHZhciB2YWx1ZSA9IDEgaW4gYXJndW1lbnRzID8gYXJndW1lbnRzWzFdIDogY29udmVydC5yZ2IuaHN2KGFyZ3MpWzJdOyAvLyBoc3YgLT4gYW5zaTE2IG9wdGltaXphdGlvblxuXG5cdHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSAvIDUwKTtcblxuXHRpZiAodmFsdWUgPT09IDApIHtcblx0XHRyZXR1cm4gMzA7XG5cdH1cblxuXHR2YXIgYW5zaSA9IDMwXG5cdFx0KyAoKE1hdGgucm91bmQoYiAvIDI1NSkgPDwgMilcblx0XHR8IChNYXRoLnJvdW5kKGcgLyAyNTUpIDw8IDEpXG5cdFx0fCBNYXRoLnJvdW5kKHIgLyAyNTUpKTtcblxuXHRpZiAodmFsdWUgPT09IDIpIHtcblx0XHRhbnNpICs9IDYwO1xuXHR9XG5cblx0cmV0dXJuIGFuc2k7XG59O1xuXG5jb252ZXJ0Lmhzdi5hbnNpMTYgPSBmdW5jdGlvbiAoYXJncykge1xuXHQvLyBvcHRpbWl6YXRpb24gaGVyZTsgd2UgYWxyZWFkeSBrbm93IHRoZSB2YWx1ZSBhbmQgZG9uJ3QgbmVlZCB0byBnZXRcblx0Ly8gaXQgY29udmVydGVkIGZvciB1cy5cblx0cmV0dXJuIGNvbnZlcnQucmdiLmFuc2kxNihjb252ZXJ0Lmhzdi5yZ2IoYXJncyksIGFyZ3NbMl0pO1xufTtcblxuY29udmVydC5yZ2IuYW5zaTI1NiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciByID0gYXJnc1swXTtcblx0dmFyIGcgPSBhcmdzWzFdO1xuXHR2YXIgYiA9IGFyZ3NbMl07XG5cblx0Ly8gd2UgdXNlIHRoZSBleHRlbmRlZCBncmV5c2NhbGUgcGFsZXR0ZSBoZXJlLCB3aXRoIHRoZSBleGNlcHRpb24gb2Zcblx0Ly8gYmxhY2sgYW5kIHdoaXRlLiBub3JtYWwgcGFsZXR0ZSBvbmx5IGhhcyA0IGdyZXlzY2FsZSBzaGFkZXMuXG5cdGlmIChyID09PSBnICYmIGcgPT09IGIpIHtcblx0XHRpZiAociA8IDgpIHtcblx0XHRcdHJldHVybiAxNjtcblx0XHR9XG5cblx0XHRpZiAociA+IDI0OCkge1xuXHRcdFx0cmV0dXJuIDIzMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gTWF0aC5yb3VuZCgoKHIgLSA4KSAvIDI0NykgKiAyNCkgKyAyMzI7XG5cdH1cblxuXHR2YXIgYW5zaSA9IDE2XG5cdFx0KyAoMzYgKiBNYXRoLnJvdW5kKHIgLyAyNTUgKiA1KSlcblx0XHQrICg2ICogTWF0aC5yb3VuZChnIC8gMjU1ICogNSkpXG5cdFx0KyBNYXRoLnJvdW5kKGIgLyAyNTUgKiA1KTtcblxuXHRyZXR1cm4gYW5zaTtcbn07XG5cbmNvbnZlcnQuYW5zaTE2LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHZhciBjb2xvciA9IGFyZ3MgJSAxMDtcblxuXHQvLyBoYW5kbGUgZ3JleXNjYWxlXG5cdGlmIChjb2xvciA9PT0gMCB8fCBjb2xvciA9PT0gNykge1xuXHRcdGlmIChhcmdzID4gNTApIHtcblx0XHRcdGNvbG9yICs9IDMuNTtcblx0XHR9XG5cblx0XHRjb2xvciA9IGNvbG9yIC8gMTAuNSAqIDI1NTtcblxuXHRcdHJldHVybiBbY29sb3IsIGNvbG9yLCBjb2xvcl07XG5cdH1cblxuXHR2YXIgbXVsdCA9ICh+fihhcmdzID4gNTApICsgMSkgKiAwLjU7XG5cdHZhciByID0gKChjb2xvciAmIDEpICogbXVsdCkgKiAyNTU7XG5cdHZhciBnID0gKCgoY29sb3IgPj4gMSkgJiAxKSAqIG11bHQpICogMjU1O1xuXHR2YXIgYiA9ICgoKGNvbG9yID4+IDIpICYgMSkgKiBtdWx0KSAqIDI1NTtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydC5hbnNpMjU2LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdC8vIGhhbmRsZSBncmV5c2NhbGVcblx0aWYgKGFyZ3MgPj0gMjMyKSB7XG5cdFx0dmFyIGMgPSAoYXJncyAtIDIzMikgKiAxMCArIDg7XG5cdFx0cmV0dXJuIFtjLCBjLCBjXTtcblx0fVxuXG5cdGFyZ3MgLT0gMTY7XG5cblx0dmFyIHJlbTtcblx0dmFyIHIgPSBNYXRoLmZsb29yKGFyZ3MgLyAzNikgLyA1ICogMjU1O1xuXHR2YXIgZyA9IE1hdGguZmxvb3IoKHJlbSA9IGFyZ3MgJSAzNikgLyA2KSAvIDUgKiAyNTU7XG5cdHZhciBiID0gKHJlbSAlIDYpIC8gNSAqIDI1NTtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydC5yZ2IuaGV4ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIGludGVnZXIgPSAoKE1hdGgucm91bmQoYXJnc1swXSkgJiAweEZGKSA8PCAxNilcblx0XHQrICgoTWF0aC5yb3VuZChhcmdzWzFdKSAmIDB4RkYpIDw8IDgpXG5cdFx0KyAoTWF0aC5yb3VuZChhcmdzWzJdKSAmIDB4RkYpO1xuXG5cdHZhciBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRyZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufTtcblxuY29udmVydC5oZXgucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0dmFyIG1hdGNoID0gYXJncy50b1N0cmluZygxNikubWF0Y2goL1thLWYwLTldezZ9fFthLWYwLTldezN9L2kpO1xuXHRpZiAoIW1hdGNoKSB7XG5cdFx0cmV0dXJuIFswLCAwLCAwXTtcblx0fVxuXG5cdHZhciBjb2xvclN0cmluZyA9IG1hdGNoWzBdO1xuXG5cdGlmIChtYXRjaFswXS5sZW5ndGggPT09IDMpIHtcblx0XHRjb2xvclN0cmluZyA9IGNvbG9yU3RyaW5nLnNwbGl0KCcnKS5tYXAoZnVuY3Rpb24gKGNoYXIpIHtcblx0XHRcdHJldHVybiBjaGFyICsgY2hhcjtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdHZhciBpbnRlZ2VyID0gcGFyc2VJbnQoY29sb3JTdHJpbmcsIDE2KTtcblx0dmFyIHIgPSAoaW50ZWdlciA+PiAxNikgJiAweEZGO1xuXHR2YXIgZyA9IChpbnRlZ2VyID4+IDgpICYgMHhGRjtcblx0dmFyIGIgPSBpbnRlZ2VyICYgMHhGRjtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydC5yZ2IuaGNnID0gZnVuY3Rpb24gKHJnYikge1xuXHR2YXIgciA9IHJnYlswXSAvIDI1NTtcblx0dmFyIGcgPSByZ2JbMV0gLyAyNTU7XG5cdHZhciBiID0gcmdiWzJdIC8gMjU1O1xuXHR2YXIgbWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgociwgZyksIGIpO1xuXHR2YXIgbWluID0gTWF0aC5taW4oTWF0aC5taW4ociwgZyksIGIpO1xuXHR2YXIgY2hyb21hID0gKG1heCAtIG1pbik7XG5cdHZhciBncmF5c2NhbGU7XG5cdHZhciBodWU7XG5cblx0aWYgKGNocm9tYSA8IDEpIHtcblx0XHRncmF5c2NhbGUgPSBtaW4gLyAoMSAtIGNocm9tYSk7XG5cdH0gZWxzZSB7XG5cdFx0Z3JheXNjYWxlID0gMDtcblx0fVxuXG5cdGlmIChjaHJvbWEgPD0gMCkge1xuXHRcdGh1ZSA9IDA7XG5cdH0gZWxzZVxuXHRpZiAobWF4ID09PSByKSB7XG5cdFx0aHVlID0gKChnIC0gYikgLyBjaHJvbWEpICUgNjtcblx0fSBlbHNlXG5cdGlmIChtYXggPT09IGcpIHtcblx0XHRodWUgPSAyICsgKGIgLSByKSAvIGNocm9tYTtcblx0fSBlbHNlIHtcblx0XHRodWUgPSA0ICsgKHIgLSBnKSAvIGNocm9tYSArIDQ7XG5cdH1cblxuXHRodWUgLz0gNjtcblx0aHVlICU9IDE7XG5cblx0cmV0dXJuIFtodWUgKiAzNjAsIGNocm9tYSAqIDEwMCwgZ3JheXNjYWxlICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHNsLmhjZyA9IGZ1bmN0aW9uIChoc2wpIHtcblx0dmFyIHMgPSBoc2xbMV0gLyAxMDA7XG5cdHZhciBsID0gaHNsWzJdIC8gMTAwO1xuXHR2YXIgYyA9IDE7XG5cdHZhciBmID0gMDtcblxuXHRpZiAobCA8IDAuNSkge1xuXHRcdGMgPSAyLjAgKiBzICogbDtcblx0fSBlbHNlIHtcblx0XHRjID0gMi4wICogcyAqICgxLjAgLSBsKTtcblx0fVxuXG5cdGlmIChjIDwgMS4wKSB7XG5cdFx0ZiA9IChsIC0gMC41ICogYykgLyAoMS4wIC0gYyk7XG5cdH1cblxuXHRyZXR1cm4gW2hzbFswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG59O1xuXG5jb252ZXJ0Lmhzdi5oY2cgPSBmdW5jdGlvbiAoaHN2KSB7XG5cdHZhciBzID0gaHN2WzFdIC8gMTAwO1xuXHR2YXIgdiA9IGhzdlsyXSAvIDEwMDtcblxuXHR2YXIgYyA9IHMgKiB2O1xuXHR2YXIgZiA9IDA7XG5cblx0aWYgKGMgPCAxLjApIHtcblx0XHRmID0gKHYgLSBjKSAvICgxIC0gYyk7XG5cdH1cblxuXHRyZXR1cm4gW2hzdlswXSwgYyAqIDEwMCwgZiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhjZy5yZ2IgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBoID0gaGNnWzBdIC8gMzYwO1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cblx0aWYgKGMgPT09IDAuMCkge1xuXHRcdHJldHVybiBbZyAqIDI1NSwgZyAqIDI1NSwgZyAqIDI1NV07XG5cdH1cblxuXHR2YXIgcHVyZSA9IFswLCAwLCAwXTtcblx0dmFyIGhpID0gKGggJSAxKSAqIDY7XG5cdHZhciB2ID0gaGkgJSAxO1xuXHR2YXIgdyA9IDEgLSB2O1xuXHR2YXIgbWcgPSAwO1xuXG5cdHN3aXRjaCAoTWF0aC5mbG9vcihoaSkpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRwdXJlWzBdID0gMTsgcHVyZVsxXSA9IHY7IHB1cmVbMl0gPSAwOyBicmVhaztcblx0XHRjYXNlIDE6XG5cdFx0XHRwdXJlWzBdID0gdzsgcHVyZVsxXSA9IDE7IHB1cmVbMl0gPSAwOyBicmVhaztcblx0XHRjYXNlIDI6XG5cdFx0XHRwdXJlWzBdID0gMDsgcHVyZVsxXSA9IDE7IHB1cmVbMl0gPSB2OyBicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRwdXJlWzBdID0gMDsgcHVyZVsxXSA9IHc7IHB1cmVbMl0gPSAxOyBicmVhaztcblx0XHRjYXNlIDQ6XG5cdFx0XHRwdXJlWzBdID0gdjsgcHVyZVsxXSA9IDA7IHB1cmVbMl0gPSAxOyBicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0cHVyZVswXSA9IDE7IHB1cmVbMV0gPSAwOyBwdXJlWzJdID0gdztcblx0fVxuXG5cdG1nID0gKDEuMCAtIGMpICogZztcblxuXHRyZXR1cm4gW1xuXHRcdChjICogcHVyZVswXSArIG1nKSAqIDI1NSxcblx0XHQoYyAqIHB1cmVbMV0gKyBtZykgKiAyNTUsXG5cdFx0KGMgKiBwdXJlWzJdICsgbWcpICogMjU1XG5cdF07XG59O1xuXG5jb252ZXJ0LmhjZy5oc3YgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHR2YXIgdiA9IGMgKyBnICogKDEuMCAtIGMpO1xuXHR2YXIgZiA9IDA7XG5cblx0aWYgKHYgPiAwLjApIHtcblx0XHRmID0gYyAvIHY7XG5cdH1cblxuXHRyZXR1cm4gW2hjZ1swXSwgZiAqIDEwMCwgdiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhjZy5oc2wgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdHZhciBjID0gaGNnWzFdIC8gMTAwO1xuXHR2YXIgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHR2YXIgbCA9IGcgKiAoMS4wIC0gYykgKyAwLjUgKiBjO1xuXHR2YXIgcyA9IDA7XG5cblx0aWYgKGwgPiAwLjAgJiYgbCA8IDAuNSkge1xuXHRcdHMgPSBjIC8gKDIgKiBsKTtcblx0fSBlbHNlXG5cdGlmIChsID49IDAuNSAmJiBsIDwgMS4wKSB7XG5cdFx0cyA9IGMgLyAoMiAqICgxIC0gbCkpO1xuXHR9XG5cblx0cmV0dXJuIFtoY2dbMF0sIHMgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuY29udmVydC5oY2cuaHdiID0gZnVuY3Rpb24gKGhjZykge1xuXHR2YXIgYyA9IGhjZ1sxXSAvIDEwMDtcblx0dmFyIGcgPSBoY2dbMl0gLyAxMDA7XG5cdHZhciB2ID0gYyArIGcgKiAoMS4wIC0gYyk7XG5cdHJldHVybiBbaGNnWzBdLCAodiAtIGMpICogMTAwLCAoMSAtIHYpICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHdiLmhjZyA9IGZ1bmN0aW9uIChod2IpIHtcblx0dmFyIHcgPSBod2JbMV0gLyAxMDA7XG5cdHZhciBiID0gaHdiWzJdIC8gMTAwO1xuXHR2YXIgdiA9IDEgLSBiO1xuXHR2YXIgYyA9IHYgLSB3O1xuXHR2YXIgZyA9IDA7XG5cblx0aWYgKGMgPCAxKSB7XG5cdFx0ZyA9ICh2IC0gYykgLyAoMSAtIGMpO1xuXHR9XG5cblx0cmV0dXJuIFtod2JbMF0sIGMgKiAxMDAsIGcgKiAxMDBdO1xufTtcblxuY29udmVydC5hcHBsZS5yZ2IgPSBmdW5jdGlvbiAoYXBwbGUpIHtcblx0cmV0dXJuIFsoYXBwbGVbMF0gLyA2NTUzNSkgKiAyNTUsIChhcHBsZVsxXSAvIDY1NTM1KSAqIDI1NSwgKGFwcGxlWzJdIC8gNjU1MzUpICogMjU1XTtcbn07XG5cbmNvbnZlcnQucmdiLmFwcGxlID0gZnVuY3Rpb24gKHJnYikge1xuXHRyZXR1cm4gWyhyZ2JbMF0gLyAyNTUpICogNjU1MzUsIChyZ2JbMV0gLyAyNTUpICogNjU1MzUsIChyZ2JbMl0gLyAyNTUpICogNjU1MzVdO1xufTtcblxuY29udmVydC5ncmF5LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHJldHVybiBbYXJnc1swXSAvIDEwMCAqIDI1NSwgYXJnc1swXSAvIDEwMCAqIDI1NSwgYXJnc1swXSAvIDEwMCAqIDI1NV07XG59O1xuXG5jb252ZXJ0LmdyYXkuaHNsID0gY29udmVydC5ncmF5LmhzdiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdHJldHVybiBbMCwgMCwgYXJnc1swXV07XG59O1xuXG5jb252ZXJ0LmdyYXkuaHdiID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0cmV0dXJuIFswLCAxMDAsIGdyYXlbMF1dO1xufTtcblxuY29udmVydC5ncmF5LmNteWsgPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRyZXR1cm4gWzAsIDAsIDAsIGdyYXlbMF1dO1xufTtcblxuY29udmVydC5ncmF5LmxhYiA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHJldHVybiBbZ3JheVswXSwgMCwgMF07XG59O1xuXG5jb252ZXJ0LmdyYXkuaGV4ID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0dmFyIHZhbCA9IE1hdGgucm91bmQoZ3JheVswXSAvIDEwMCAqIDI1NSkgJiAweEZGO1xuXHR2YXIgaW50ZWdlciA9ICh2YWwgPDwgMTYpICsgKHZhbCA8PCA4KSArIHZhbDtcblxuXHR2YXIgc3RyaW5nID0gaW50ZWdlci50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0cmV0dXJuICcwMDAwMDAnLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKSArIHN0cmluZztcbn07XG5cbmNvbnZlcnQucmdiLmdyYXkgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHZhciB2YWwgPSAocmdiWzBdICsgcmdiWzFdICsgcmdiWzJdKSAvIDM7XG5cdHJldHVybiBbdmFsIC8gMjU1ICogMTAwXTtcbn07XG4iLCJ2YXIgY29udmVyc2lvbnMgPSByZXF1aXJlKCcuL2NvbnZlcnNpb25zJyk7XG52YXIgcm91dGUgPSByZXF1aXJlKCcuL3JvdXRlJyk7XG5cbnZhciBjb252ZXJ0ID0ge307XG5cbnZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG5cbmZ1bmN0aW9uIHdyYXBSYXcoZm4pIHtcblx0dmFyIHdyYXBwZWRGbiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdFx0aWYgKGFyZ3MgPT09IHVuZGVmaW5lZCB8fCBhcmdzID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gYXJncztcblx0XHR9XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiBmbihhcmdzKTtcblx0fTtcblxuXHQvLyBwcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblx0aWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuXHRcdHdyYXBwZWRGbi5jb252ZXJzaW9uID0gZm4uY29udmVyc2lvbjtcblx0fVxuXG5cdHJldHVybiB3cmFwcGVkRm47XG59XG5cbmZ1bmN0aW9uIHdyYXBSb3VuZGVkKGZuKSB7XG5cdHZhciB3cmFwcGVkRm4gPSBmdW5jdGlvbiAoYXJncykge1xuXHRcdGlmIChhcmdzID09PSB1bmRlZmluZWQgfHwgYXJncyA9PT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIGFyZ3M7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHR9XG5cblx0XHR2YXIgcmVzdWx0ID0gZm4oYXJncyk7XG5cblx0XHQvLyB3ZSdyZSBhc3N1bWluZyB0aGUgcmVzdWx0IGlzIGFuIGFycmF5IGhlcmUuXG5cdFx0Ly8gc2VlIG5vdGljZSBpbiBjb252ZXJzaW9ucy5qczsgZG9uJ3QgdXNlIGJveCB0eXBlc1xuXHRcdC8vIGluIGNvbnZlcnNpb24gZnVuY3Rpb25zLlxuXHRcdGlmICh0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Zm9yICh2YXIgbGVuID0gcmVzdWx0Lmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRyZXN1bHRbaV0gPSBNYXRoLnJvdW5kKHJlc3VsdFtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvLyBwcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblx0aWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuXHRcdHdyYXBwZWRGbi5jb252ZXJzaW9uID0gZm4uY29udmVyc2lvbjtcblx0fVxuXG5cdHJldHVybiB3cmFwcGVkRm47XG59XG5cbm1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uIChmcm9tTW9kZWwpIHtcblx0Y29udmVydFtmcm9tTW9kZWxdID0ge307XG5cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbZnJvbU1vZGVsXSwgJ2NoYW5uZWxzJywge3ZhbHVlOiBjb252ZXJzaW9uc1tmcm9tTW9kZWxdLmNoYW5uZWxzfSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W2Zyb21Nb2RlbF0sICdsYWJlbHMnLCB7dmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0ubGFiZWxzfSk7XG5cblx0dmFyIHJvdXRlcyA9IHJvdXRlKGZyb21Nb2RlbCk7XG5cdHZhciByb3V0ZU1vZGVscyA9IE9iamVjdC5rZXlzKHJvdXRlcyk7XG5cblx0cm91dGVNb2RlbHMuZm9yRWFjaChmdW5jdGlvbiAodG9Nb2RlbCkge1xuXHRcdHZhciBmbiA9IHJvdXRlc1t0b01vZGVsXTtcblxuXHRcdGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXSA9IHdyYXBSb3VuZGVkKGZuKTtcblx0XHRjb252ZXJ0W2Zyb21Nb2RlbF1bdG9Nb2RlbF0ucmF3ID0gd3JhcFJhdyhmbik7XG5cdH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydDtcbiIsInZhciBjb252ZXJzaW9ucyA9IHJlcXVpcmUoJy4vY29udmVyc2lvbnMnKTtcblxuLypcblx0dGhpcyBmdW5jdGlvbiByb3V0ZXMgYSBtb2RlbCB0byBhbGwgb3RoZXIgbW9kZWxzLlxuXG5cdGFsbCBmdW5jdGlvbnMgdGhhdCBhcmUgcm91dGVkIGhhdmUgYSBwcm9wZXJ0eSBgLmNvbnZlcnNpb25gIGF0dGFjaGVkXG5cdHRvIHRoZSByZXR1cm5lZCBzeW50aGV0aWMgZnVuY3Rpb24uIFRoaXMgcHJvcGVydHkgaXMgYW4gYXJyYXlcblx0b2Ygc3RyaW5ncywgZWFjaCB3aXRoIHRoZSBzdGVwcyBpbiBiZXR3ZWVuIHRoZSAnZnJvbScgYW5kICd0bydcblx0Y29sb3IgbW9kZWxzIChpbmNsdXNpdmUpLlxuXG5cdGNvbnZlcnNpb25zIHRoYXQgYXJlIG5vdCBwb3NzaWJsZSBzaW1wbHkgYXJlIG5vdCBpbmNsdWRlZC5cbiovXG5cbi8vIGh0dHBzOi8vanNwZXJmLmNvbS9vYmplY3Qta2V5cy12cy1mb3ItaW4td2l0aC1jbG9zdXJlLzNcbnZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG5cbmZ1bmN0aW9uIGJ1aWxkR3JhcGgoKSB7XG5cdHZhciBncmFwaCA9IHt9O1xuXG5cdGZvciAodmFyIGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRncmFwaFttb2RlbHNbaV1dID0ge1xuXHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vMS12cy1pbmZpbml0eVxuXHRcdFx0Ly8gbWljcm8tb3B0LCBidXQgdGhpcyBpcyBzaW1wbGUuXG5cdFx0XHRkaXN0YW5jZTogLTEsXG5cdFx0XHRwYXJlbnQ6IG51bGxcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIGdyYXBoO1xufVxuXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CcmVhZHRoLWZpcnN0X3NlYXJjaFxuZnVuY3Rpb24gZGVyaXZlQkZTKGZyb21Nb2RlbCkge1xuXHR2YXIgZ3JhcGggPSBidWlsZEdyYXBoKCk7XG5cdHZhciBxdWV1ZSA9IFtmcm9tTW9kZWxdOyAvLyB1bnNoaWZ0IC0+IHF1ZXVlIC0+IHBvcFxuXG5cdGdyYXBoW2Zyb21Nb2RlbF0uZGlzdGFuY2UgPSAwO1xuXG5cdHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcblx0XHR2YXIgY3VycmVudCA9IHF1ZXVlLnBvcCgpO1xuXHRcdHZhciBhZGphY2VudHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9uc1tjdXJyZW50XSk7XG5cblx0XHRmb3IgKHZhciBsZW4gPSBhZGphY2VudHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHR2YXIgYWRqYWNlbnQgPSBhZGphY2VudHNbaV07XG5cdFx0XHR2YXIgbm9kZSA9IGdyYXBoW2FkamFjZW50XTtcblxuXHRcdFx0aWYgKG5vZGUuZGlzdGFuY2UgPT09IC0xKSB7XG5cdFx0XHRcdG5vZGUuZGlzdGFuY2UgPSBncmFwaFtjdXJyZW50XS5kaXN0YW5jZSArIDE7XG5cdFx0XHRcdG5vZGUucGFyZW50ID0gY3VycmVudDtcblx0XHRcdFx0cXVldWUudW5zaGlmdChhZGphY2VudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGdyYXBoO1xufVxuXG5mdW5jdGlvbiBsaW5rKGZyb20sIHRvKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoYXJncykge1xuXHRcdHJldHVybiB0byhmcm9tKGFyZ3MpKTtcblx0fTtcbn1cblxuZnVuY3Rpb24gd3JhcENvbnZlcnNpb24odG9Nb2RlbCwgZ3JhcGgpIHtcblx0dmFyIHBhdGggPSBbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50LCB0b01vZGVsXTtcblx0dmFyIGZuID0gY29udmVyc2lvbnNbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50XVt0b01vZGVsXTtcblxuXHR2YXIgY3VyID0gZ3JhcGhbdG9Nb2RlbF0ucGFyZW50O1xuXHR3aGlsZSAoZ3JhcGhbY3VyXS5wYXJlbnQpIHtcblx0XHRwYXRoLnVuc2hpZnQoZ3JhcGhbY3VyXS5wYXJlbnQpO1xuXHRcdGZuID0gbGluayhjb252ZXJzaW9uc1tncmFwaFtjdXJdLnBhcmVudF1bY3VyXSwgZm4pO1xuXHRcdGN1ciA9IGdyYXBoW2N1cl0ucGFyZW50O1xuXHR9XG5cblx0Zm4uY29udmVyc2lvbiA9IHBhdGg7XG5cdHJldHVybiBmbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZnJvbU1vZGVsKSB7XG5cdHZhciBncmFwaCA9IGRlcml2ZUJGUyhmcm9tTW9kZWwpO1xuXHR2YXIgY29udmVyc2lvbiA9IHt9O1xuXG5cdHZhciBtb2RlbHMgPSBPYmplY3Qua2V5cyhncmFwaCk7XG5cdGZvciAodmFyIGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHR2YXIgdG9Nb2RlbCA9IG1vZGVsc1tpXTtcblx0XHR2YXIgbm9kZSA9IGdyYXBoW3RvTW9kZWxdO1xuXG5cdFx0aWYgKG5vZGUucGFyZW50ID09PSBudWxsKSB7XG5cdFx0XHQvLyBubyBwb3NzaWJsZSBjb252ZXJzaW9uLCBvciB0aGlzIG5vZGUgaXMgdGhlIHNvdXJjZSBtb2RlbC5cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnZlcnNpb25bdG9Nb2RlbF0gPSB3cmFwQ29udmVyc2lvbih0b01vZGVsLCBncmFwaCk7XG5cdH1cblxuXHRyZXR1cm4gY29udmVyc2lvbjtcbn07XG5cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xyXG5cdFwiYWxpY2VibHVlXCI6IFsyNDAsIDI0OCwgMjU1XSxcclxuXHRcImFudGlxdWV3aGl0ZVwiOiBbMjUwLCAyMzUsIDIxNV0sXHJcblx0XCJhcXVhXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJhcXVhbWFyaW5lXCI6IFsxMjcsIDI1NSwgMjEyXSxcclxuXHRcImF6dXJlXCI6IFsyNDAsIDI1NSwgMjU1XSxcclxuXHRcImJlaWdlXCI6IFsyNDUsIDI0NSwgMjIwXSxcclxuXHRcImJpc3F1ZVwiOiBbMjU1LCAyMjgsIDE5Nl0sXHJcblx0XCJibGFja1wiOiBbMCwgMCwgMF0sXHJcblx0XCJibGFuY2hlZGFsbW9uZFwiOiBbMjU1LCAyMzUsIDIwNV0sXHJcblx0XCJibHVlXCI6IFswLCAwLCAyNTVdLFxyXG5cdFwiYmx1ZXZpb2xldFwiOiBbMTM4LCA0MywgMjI2XSxcclxuXHRcImJyb3duXCI6IFsxNjUsIDQyLCA0Ml0sXHJcblx0XCJidXJseXdvb2RcIjogWzIyMiwgMTg0LCAxMzVdLFxyXG5cdFwiY2FkZXRibHVlXCI6IFs5NSwgMTU4LCAxNjBdLFxyXG5cdFwiY2hhcnRyZXVzZVwiOiBbMTI3LCAyNTUsIDBdLFxyXG5cdFwiY2hvY29sYXRlXCI6IFsyMTAsIDEwNSwgMzBdLFxyXG5cdFwiY29yYWxcIjogWzI1NSwgMTI3LCA4MF0sXHJcblx0XCJjb3JuZmxvd2VyYmx1ZVwiOiBbMTAwLCAxNDksIDIzN10sXHJcblx0XCJjb3Juc2lsa1wiOiBbMjU1LCAyNDgsIDIyMF0sXHJcblx0XCJjcmltc29uXCI6IFsyMjAsIDIwLCA2MF0sXHJcblx0XCJjeWFuXCI6IFswLCAyNTUsIDI1NV0sXHJcblx0XCJkYXJrYmx1ZVwiOiBbMCwgMCwgMTM5XSxcclxuXHRcImRhcmtjeWFuXCI6IFswLCAxMzksIDEzOV0sXHJcblx0XCJkYXJrZ29sZGVucm9kXCI6IFsxODQsIDEzNCwgMTFdLFxyXG5cdFwiZGFya2dyYXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2dyZWVuXCI6IFswLCAxMDAsIDBdLFxyXG5cdFwiZGFya2dyZXlcIjogWzE2OSwgMTY5LCAxNjldLFxyXG5cdFwiZGFya2toYWtpXCI6IFsxODksIDE4MywgMTA3XSxcclxuXHRcImRhcmttYWdlbnRhXCI6IFsxMzksIDAsIDEzOV0sXHJcblx0XCJkYXJrb2xpdmVncmVlblwiOiBbODUsIDEwNywgNDddLFxyXG5cdFwiZGFya29yYW5nZVwiOiBbMjU1LCAxNDAsIDBdLFxyXG5cdFwiZGFya29yY2hpZFwiOiBbMTUzLCA1MCwgMjA0XSxcclxuXHRcImRhcmtyZWRcIjogWzEzOSwgMCwgMF0sXHJcblx0XCJkYXJrc2FsbW9uXCI6IFsyMzMsIDE1MCwgMTIyXSxcclxuXHRcImRhcmtzZWFncmVlblwiOiBbMTQzLCAxODgsIDE0M10sXHJcblx0XCJkYXJrc2xhdGVibHVlXCI6IFs3MiwgNjEsIDEzOV0sXHJcblx0XCJkYXJrc2xhdGVncmF5XCI6IFs0NywgNzksIDc5XSxcclxuXHRcImRhcmtzbGF0ZWdyZXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3R1cnF1b2lzZVwiOiBbMCwgMjA2LCAyMDldLFxyXG5cdFwiZGFya3Zpb2xldFwiOiBbMTQ4LCAwLCAyMTFdLFxyXG5cdFwiZGVlcHBpbmtcIjogWzI1NSwgMjAsIDE0N10sXHJcblx0XCJkZWVwc2t5Ymx1ZVwiOiBbMCwgMTkxLCAyNTVdLFxyXG5cdFwiZGltZ3JheVwiOiBbMTA1LCAxMDUsIDEwNV0sXHJcblx0XCJkaW1ncmV5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRvZGdlcmJsdWVcIjogWzMwLCAxNDQsIDI1NV0sXHJcblx0XCJmaXJlYnJpY2tcIjogWzE3OCwgMzQsIDM0XSxcclxuXHRcImZsb3JhbHdoaXRlXCI6IFsyNTUsIDI1MCwgMjQwXSxcclxuXHRcImZvcmVzdGdyZWVuXCI6IFszNCwgMTM5LCAzNF0sXHJcblx0XCJmdWNoc2lhXCI6IFsyNTUsIDAsIDI1NV0sXHJcblx0XCJnYWluc2Jvcm9cIjogWzIyMCwgMjIwLCAyMjBdLFxyXG5cdFwiZ2hvc3R3aGl0ZVwiOiBbMjQ4LCAyNDgsIDI1NV0sXHJcblx0XCJnb2xkXCI6IFsyNTUsIDIxNSwgMF0sXHJcblx0XCJnb2xkZW5yb2RcIjogWzIxOCwgMTY1LCAzMl0sXHJcblx0XCJncmF5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImdyZWVuXCI6IFswLCAxMjgsIDBdLFxyXG5cdFwiZ3JlZW55ZWxsb3dcIjogWzE3MywgMjU1LCA0N10sXHJcblx0XCJncmV5XCI6IFsxMjgsIDEyOCwgMTI4XSxcclxuXHRcImhvbmV5ZGV3XCI6IFsyNDAsIDI1NSwgMjQwXSxcclxuXHRcImhvdHBpbmtcIjogWzI1NSwgMTA1LCAxODBdLFxyXG5cdFwiaW5kaWFucmVkXCI6IFsyMDUsIDkyLCA5Ml0sXHJcblx0XCJpbmRpZ29cIjogWzc1LCAwLCAxMzBdLFxyXG5cdFwiaXZvcnlcIjogWzI1NSwgMjU1LCAyNDBdLFxyXG5cdFwia2hha2lcIjogWzI0MCwgMjMwLCAxNDBdLFxyXG5cdFwibGF2ZW5kZXJcIjogWzIzMCwgMjMwLCAyNTBdLFxyXG5cdFwibGF2ZW5kZXJibHVzaFwiOiBbMjU1LCAyNDAsIDI0NV0sXHJcblx0XCJsYXduZ3JlZW5cIjogWzEyNCwgMjUyLCAwXSxcclxuXHRcImxlbW9uY2hpZmZvblwiOiBbMjU1LCAyNTAsIDIwNV0sXHJcblx0XCJsaWdodGJsdWVcIjogWzE3MywgMjE2LCAyMzBdLFxyXG5cdFwibGlnaHRjb3JhbFwiOiBbMjQwLCAxMjgsIDEyOF0sXHJcblx0XCJsaWdodGN5YW5cIjogWzIyNCwgMjU1LCAyNTVdLFxyXG5cdFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogWzI1MCwgMjUwLCAyMTBdLFxyXG5cdFwibGlnaHRncmF5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0Z3JlZW5cIjogWzE0NCwgMjM4LCAxNDRdLFxyXG5cdFwibGlnaHRncmV5XCI6IFsyMTEsIDIxMSwgMjExXSxcclxuXHRcImxpZ2h0cGlua1wiOiBbMjU1LCAxODIsIDE5M10sXHJcblx0XCJsaWdodHNhbG1vblwiOiBbMjU1LCAxNjAsIDEyMl0sXHJcblx0XCJsaWdodHNlYWdyZWVuXCI6IFszMiwgMTc4LCAxNzBdLFxyXG5cdFwibGlnaHRza3libHVlXCI6IFsxMzUsIDIwNiwgMjUwXSxcclxuXHRcImxpZ2h0c2xhdGVncmF5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c2xhdGVncmV5XCI6IFsxMTksIDEzNiwgMTUzXSxcclxuXHRcImxpZ2h0c3RlZWxibHVlXCI6IFsxNzYsIDE5NiwgMjIyXSxcclxuXHRcImxpZ2h0eWVsbG93XCI6IFsyNTUsIDI1NSwgMjI0XSxcclxuXHRcImxpbWVcIjogWzAsIDI1NSwgMF0sXHJcblx0XCJsaW1lZ3JlZW5cIjogWzUwLCAyMDUsIDUwXSxcclxuXHRcImxpbmVuXCI6IFsyNTAsIDI0MCwgMjMwXSxcclxuXHRcIm1hZ2VudGFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcIm1hcm9vblwiOiBbMTI4LCAwLCAwXSxcclxuXHRcIm1lZGl1bWFxdWFtYXJpbmVcIjogWzEwMiwgMjA1LCAxNzBdLFxyXG5cdFwibWVkaXVtYmx1ZVwiOiBbMCwgMCwgMjA1XSxcclxuXHRcIm1lZGl1bW9yY2hpZFwiOiBbMTg2LCA4NSwgMjExXSxcclxuXHRcIm1lZGl1bXB1cnBsZVwiOiBbMTQ3LCAxMTIsIDIxOV0sXHJcblx0XCJtZWRpdW1zZWFncmVlblwiOiBbNjAsIDE3OSwgMTEzXSxcclxuXHRcIm1lZGl1bXNsYXRlYmx1ZVwiOiBbMTIzLCAxMDQsIDIzOF0sXHJcblx0XCJtZWRpdW1zcHJpbmdncmVlblwiOiBbMCwgMjUwLCAxNTRdLFxyXG5cdFwibWVkaXVtdHVycXVvaXNlXCI6IFs3MiwgMjA5LCAyMDRdLFxyXG5cdFwibWVkaXVtdmlvbGV0cmVkXCI6IFsxOTksIDIxLCAxMzNdLFxyXG5cdFwibWlkbmlnaHRibHVlXCI6IFsyNSwgMjUsIDExMl0sXHJcblx0XCJtaW50Y3JlYW1cIjogWzI0NSwgMjU1LCAyNTBdLFxyXG5cdFwibWlzdHlyb3NlXCI6IFsyNTUsIDIyOCwgMjI1XSxcclxuXHRcIm1vY2Nhc2luXCI6IFsyNTUsIDIyOCwgMTgxXSxcclxuXHRcIm5hdmFqb3doaXRlXCI6IFsyNTUsIDIyMiwgMTczXSxcclxuXHRcIm5hdnlcIjogWzAsIDAsIDEyOF0sXHJcblx0XCJvbGRsYWNlXCI6IFsyNTMsIDI0NSwgMjMwXSxcclxuXHRcIm9saXZlXCI6IFsxMjgsIDEyOCwgMF0sXHJcblx0XCJvbGl2ZWRyYWJcIjogWzEwNywgMTQyLCAzNV0sXHJcblx0XCJvcmFuZ2VcIjogWzI1NSwgMTY1LCAwXSxcclxuXHRcIm9yYW5nZXJlZFwiOiBbMjU1LCA2OSwgMF0sXHJcblx0XCJvcmNoaWRcIjogWzIxOCwgMTEyLCAyMTRdLFxyXG5cdFwicGFsZWdvbGRlbnJvZFwiOiBbMjM4LCAyMzIsIDE3MF0sXHJcblx0XCJwYWxlZ3JlZW5cIjogWzE1MiwgMjUxLCAxNTJdLFxyXG5cdFwicGFsZXR1cnF1b2lzZVwiOiBbMTc1LCAyMzgsIDIzOF0sXHJcblx0XCJwYWxldmlvbGV0cmVkXCI6IFsyMTksIDExMiwgMTQ3XSxcclxuXHRcInBhcGF5YXdoaXBcIjogWzI1NSwgMjM5LCAyMTNdLFxyXG5cdFwicGVhY2hwdWZmXCI6IFsyNTUsIDIxOCwgMTg1XSxcclxuXHRcInBlcnVcIjogWzIwNSwgMTMzLCA2M10sXHJcblx0XCJwaW5rXCI6IFsyNTUsIDE5MiwgMjAzXSxcclxuXHRcInBsdW1cIjogWzIyMSwgMTYwLCAyMjFdLFxyXG5cdFwicG93ZGVyYmx1ZVwiOiBbMTc2LCAyMjQsIDIzMF0sXHJcblx0XCJwdXJwbGVcIjogWzEyOCwgMCwgMTI4XSxcclxuXHRcInJlYmVjY2FwdXJwbGVcIjogWzEwMiwgNTEsIDE1M10sXHJcblx0XCJyZWRcIjogWzI1NSwgMCwgMF0sXHJcblx0XCJyb3N5YnJvd25cIjogWzE4OCwgMTQzLCAxNDNdLFxyXG5cdFwicm95YWxibHVlXCI6IFs2NSwgMTA1LCAyMjVdLFxyXG5cdFwic2FkZGxlYnJvd25cIjogWzEzOSwgNjksIDE5XSxcclxuXHRcInNhbG1vblwiOiBbMjUwLCAxMjgsIDExNF0sXHJcblx0XCJzYW5keWJyb3duXCI6IFsyNDQsIDE2NCwgOTZdLFxyXG5cdFwic2VhZ3JlZW5cIjogWzQ2LCAxMzksIDg3XSxcclxuXHRcInNlYXNoZWxsXCI6IFsyNTUsIDI0NSwgMjM4XSxcclxuXHRcInNpZW5uYVwiOiBbMTYwLCA4MiwgNDVdLFxyXG5cdFwic2lsdmVyXCI6IFsxOTIsIDE5MiwgMTkyXSxcclxuXHRcInNreWJsdWVcIjogWzEzNSwgMjA2LCAyMzVdLFxyXG5cdFwic2xhdGVibHVlXCI6IFsxMDYsIDkwLCAyMDVdLFxyXG5cdFwic2xhdGVncmF5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNsYXRlZ3JleVwiOiBbMTEyLCAxMjgsIDE0NF0sXHJcblx0XCJzbm93XCI6IFsyNTUsIDI1MCwgMjUwXSxcclxuXHRcInNwcmluZ2dyZWVuXCI6IFswLCAyNTUsIDEyN10sXHJcblx0XCJzdGVlbGJsdWVcIjogWzcwLCAxMzAsIDE4MF0sXHJcblx0XCJ0YW5cIjogWzIxMCwgMTgwLCAxNDBdLFxyXG5cdFwidGVhbFwiOiBbMCwgMTI4LCAxMjhdLFxyXG5cdFwidGhpc3RsZVwiOiBbMjE2LCAxOTEsIDIxNl0sXHJcblx0XCJ0b21hdG9cIjogWzI1NSwgOTksIDcxXSxcclxuXHRcInR1cnF1b2lzZVwiOiBbNjQsIDIyNCwgMjA4XSxcclxuXHRcInZpb2xldFwiOiBbMjM4LCAxMzAsIDIzOF0sXHJcblx0XCJ3aGVhdFwiOiBbMjQ1LCAyMjIsIDE3OV0sXHJcblx0XCJ3aGl0ZVwiOiBbMjU1LCAyNTUsIDI1NV0sXHJcblx0XCJ3aGl0ZXNtb2tlXCI6IFsyNDUsIDI0NSwgMjQ1XSxcclxuXHRcInllbGxvd1wiOiBbMjU1LCAyNTUsIDBdLFxyXG5cdFwieWVsbG93Z3JlZW5cIjogWzE1NCwgMjA1LCA1MF1cclxufTsiLCIvKiBNSVQgbGljZW5zZSAqL1xudmFyIGNvbG9yTmFtZXMgPSByZXF1aXJlKCdjb2xvci1uYW1lJyk7XG52YXIgc3dpenpsZSA9IHJlcXVpcmUoJ3NpbXBsZS1zd2l6emxlJyk7XG5cbnZhciByZXZlcnNlTmFtZXMgPSB7fTtcblxuLy8gY3JlYXRlIGEgbGlzdCBvZiByZXZlcnNlIGNvbG9yIG5hbWVzXG5mb3IgKHZhciBuYW1lIGluIGNvbG9yTmFtZXMpIHtcblx0aWYgKGNvbG9yTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRyZXZlcnNlTmFtZXNbY29sb3JOYW1lc1tuYW1lXV0gPSBuYW1lO1xuXHR9XG59XG5cbnZhciBjcyA9IG1vZHVsZS5leHBvcnRzID0ge1xuXHR0bzoge31cbn07XG5cbmNzLmdldCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0dmFyIHByZWZpeCA9IHN0cmluZy5zdWJzdHJpbmcoMCwgMykudG9Mb3dlckNhc2UoKTtcblx0dmFyIHZhbDtcblx0dmFyIG1vZGVsO1xuXHRzd2l0Y2ggKHByZWZpeCkge1xuXHRcdGNhc2UgJ2hzbCc6XG5cdFx0XHR2YWwgPSBjcy5nZXQuaHNsKHN0cmluZyk7XG5cdFx0XHRtb2RlbCA9ICdoc2wnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnaHdiJzpcblx0XHRcdHZhbCA9IGNzLmdldC5od2Ioc3RyaW5nKTtcblx0XHRcdG1vZGVsID0gJ2h3Yic7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0dmFsID0gY3MuZ2V0LnJnYihzdHJpbmcpO1xuXHRcdFx0bW9kZWwgPSAncmdiJztcblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0aWYgKCF2YWwpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHJldHVybiB7bW9kZWw6IG1vZGVsLCB2YWx1ZTogdmFsfTtcbn07XG5cbmNzLmdldC5yZ2IgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG5cdGlmICghc3RyaW5nKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHR2YXIgYWJiciA9IC9eIyhbYS1mMC05XXszLDR9KSQvaTtcblx0dmFyIGhleCA9IC9eIyhbYS1mMC05XXs2fSkoW2EtZjAtOV17Mn0pPyQvaTtcblx0dmFyIHJnYmEgPSAvXnJnYmE/XFwoXFxzKihbKy1dP1xcZCspXFxzKixcXHMqKFsrLV0/XFxkKylcXHMqLFxccyooWystXT9cXGQrKVxccyooPzosXFxzKihbKy1dP1tcXGRcXC5dKylcXHMqKT9cXCkkLztcblx0dmFyIHBlciA9IC9ecmdiYT9cXChcXHMqKFsrLV0/W1xcZFxcLl0rKVxcJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKylcXCVcXHMqLFxccyooWystXT9bXFxkXFwuXSspXFwlXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvO1xuXHR2YXIga2V5d29yZCA9IC8oXFxEKykvO1xuXG5cdHZhciByZ2IgPSBbMCwgMCwgMCwgMV07XG5cdHZhciBtYXRjaDtcblx0dmFyIGk7XG5cdHZhciBoZXhBbHBoYTtcblxuXHRpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goaGV4KSkge1xuXHRcdGhleEFscGhhID0gbWF0Y2hbMl07XG5cdFx0bWF0Y2ggPSBtYXRjaFsxXTtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdC8vIGh0dHBzOi8vanNwZXJmLmNvbS9zbGljZS12cy1zdWJzdHItdnMtc3Vic3RyaW5nLW1ldGhvZHMtbG9uZy1zdHJpbmcvMTlcblx0XHRcdHZhciBpMiA9IGkgKiAyO1xuXHRcdFx0cmdiW2ldID0gcGFyc2VJbnQobWF0Y2guc2xpY2UoaTIsIGkyICsgMiksIDE2KTtcblx0XHR9XG5cblx0XHRpZiAoaGV4QWxwaGEpIHtcblx0XHRcdHJnYlszXSA9IE1hdGgucm91bmQoKHBhcnNlSW50KGhleEFscGhhLCAxNikgLyAyNTUpICogMTAwKSAvIDEwMDtcblx0XHR9XG5cdH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goYWJicikpIHtcblx0XHRtYXRjaCA9IG1hdGNoWzFdO1xuXHRcdGhleEFscGhhID0gbWF0Y2hbM107XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpXSArIG1hdGNoW2ldLCAxNik7XG5cdFx0fVxuXG5cdFx0aWYgKGhleEFscGhhKSB7XG5cdFx0XHRyZ2JbM10gPSBNYXRoLnJvdW5kKChwYXJzZUludChoZXhBbHBoYSArIGhleEFscGhhLCAxNikgLyAyNTUpICogMTAwKSAvIDEwMDtcblx0XHR9XG5cdH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYSkpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSBwYXJzZUludChtYXRjaFtpICsgMV0sIDApO1xuXHRcdH1cblxuXHRcdGlmIChtYXRjaFs0XSkge1xuXHRcdFx0cmdiWzNdID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKHBlcikpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRyZ2JbaV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQobWF0Y2hbaSArIDFdKSAqIDIuNTUpO1xuXHRcdH1cblxuXHRcdGlmIChtYXRjaFs0XSkge1xuXHRcdFx0cmdiWzNdID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKGtleXdvcmQpKSB7XG5cdFx0aWYgKG1hdGNoWzFdID09PSAndHJhbnNwYXJlbnQnKSB7XG5cdFx0XHRyZXR1cm4gWzAsIDAsIDAsIDBdO1xuXHRcdH1cblxuXHRcdHJnYiA9IGNvbG9yTmFtZXNbbWF0Y2hbMV1dO1xuXG5cdFx0aWYgKCFyZ2IpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJnYlszXSA9IDE7XG5cblx0XHRyZXR1cm4gcmdiO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Zm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdHJnYltpXSA9IGNsYW1wKHJnYltpXSwgMCwgMjU1KTtcblx0fVxuXHRyZ2JbM10gPSBjbGFtcChyZ2JbM10sIDAsIDEpO1xuXG5cdHJldHVybiByZ2I7XG59O1xuXG5jcy5nZXQuaHNsID0gZnVuY3Rpb24gKHN0cmluZykge1xuXHRpZiAoIXN0cmluZykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGhzbCA9IC9eaHNsYT9cXChcXHMqKFsrLV0/XFxkKltcXC5dP1xcZCspKD86ZGVnKT9cXHMqLFxccyooWystXT9bXFxkXFwuXSspJVxccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKig/OixcXHMqKFsrLV0/W1xcZFxcLl0rKVxccyopP1xcKSQvO1xuXHR2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goaHNsKTtcblxuXHRpZiAobWF0Y2gpIHtcblx0XHR2YXIgYWxwaGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcblx0XHR2YXIgaCA9ICgocGFyc2VGbG9hdChtYXRjaFsxXSkgJSAzNjApICsgMzYwKSAlIDM2MDtcblx0XHR2YXIgcyA9IGNsYW1wKHBhcnNlRmxvYXQobWF0Y2hbMl0pLCAwLCAxMDApO1xuXHRcdHZhciBsID0gY2xhbXAocGFyc2VGbG9hdChtYXRjaFszXSksIDAsIDEwMCk7XG5cdFx0dmFyIGEgPSBjbGFtcChpc05hTihhbHBoYSkgPyAxIDogYWxwaGEsIDAsIDEpO1xuXG5cdFx0cmV0dXJuIFtoLCBzLCBsLCBhXTtcblx0fVxuXG5cdHJldHVybiBudWxsO1xufTtcblxuY3MuZ2V0Lmh3YiA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcblx0aWYgKCFzdHJpbmcpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBod2IgPSAvXmh3YlxcKFxccyooWystXT9cXGQqW1xcLl0/XFxkKykoPzpkZWcpP1xccyosXFxzKihbKy1dP1tcXGRcXC5dKyklXFxzKixcXHMqKFsrLV0/W1xcZFxcLl0rKSVcXHMqKD86LFxccyooWystXT9bXFxkXFwuXSspXFxzKik/XFwpJC87XG5cdHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaChod2IpO1xuXG5cdGlmIChtYXRjaCkge1xuXHRcdHZhciBhbHBoYSA9IHBhcnNlRmxvYXQobWF0Y2hbNF0pO1xuXHRcdHZhciBoID0gKChwYXJzZUZsb2F0KG1hdGNoWzFdKSAlIDM2MCkgKyAzNjApICUgMzYwO1xuXHRcdHZhciB3ID0gY2xhbXAocGFyc2VGbG9hdChtYXRjaFsyXSksIDAsIDEwMCk7XG5cdFx0dmFyIGIgPSBjbGFtcChwYXJzZUZsb2F0KG1hdGNoWzNdKSwgMCwgMTAwKTtcblx0XHR2YXIgYSA9IGNsYW1wKGlzTmFOKGFscGhhKSA/IDEgOiBhbHBoYSwgMCwgMSk7XG5cdFx0cmV0dXJuIFtoLCB3LCBiLCBhXTtcblx0fVxuXG5cdHJldHVybiBudWxsO1xufTtcblxuY3MudG8uaGV4ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgcmdiYSA9IHN3aXp6bGUoYXJndW1lbnRzKTtcblxuXHRyZXR1cm4gKFxuXHRcdCcjJyArXG5cdFx0aGV4RG91YmxlKHJnYmFbMF0pICtcblx0XHRoZXhEb3VibGUocmdiYVsxXSkgK1xuXHRcdGhleERvdWJsZShyZ2JhWzJdKSArXG5cdFx0KHJnYmFbM10gPCAxXG5cdFx0XHQ/IChoZXhEb3VibGUoTWF0aC5yb3VuZChyZ2JhWzNdICogMjU1KSkpXG5cdFx0XHQ6ICcnKVxuXHQpO1xufTtcblxuY3MudG8ucmdiID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgcmdiYSA9IHN3aXp6bGUoYXJndW1lbnRzKTtcblxuXHRyZXR1cm4gcmdiYS5sZW5ndGggPCA0IHx8IHJnYmFbM10gPT09IDFcblx0XHQ/ICdyZ2IoJyArIE1hdGgucm91bmQocmdiYVswXSkgKyAnLCAnICsgTWF0aC5yb3VuZChyZ2JhWzFdKSArICcsICcgKyBNYXRoLnJvdW5kKHJnYmFbMl0pICsgJyknXG5cdFx0OiAncmdiYSgnICsgTWF0aC5yb3VuZChyZ2JhWzBdKSArICcsICcgKyBNYXRoLnJvdW5kKHJnYmFbMV0pICsgJywgJyArIE1hdGgucm91bmQocmdiYVsyXSkgKyAnLCAnICsgcmdiYVszXSArICcpJztcbn07XG5cbmNzLnRvLnJnYi5wZXJjZW50ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgcmdiYSA9IHN3aXp6bGUoYXJndW1lbnRzKTtcblxuXHR2YXIgciA9IE1hdGgucm91bmQocmdiYVswXSAvIDI1NSAqIDEwMCk7XG5cdHZhciBnID0gTWF0aC5yb3VuZChyZ2JhWzFdIC8gMjU1ICogMTAwKTtcblx0dmFyIGIgPSBNYXRoLnJvdW5kKHJnYmFbMl0gLyAyNTUgKiAxMDApO1xuXG5cdHJldHVybiByZ2JhLmxlbmd0aCA8IDQgfHwgcmdiYVszXSA9PT0gMVxuXHRcdD8gJ3JnYignICsgciArICclLCAnICsgZyArICclLCAnICsgYiArICclKSdcblx0XHQ6ICdyZ2JhKCcgKyByICsgJyUsICcgKyBnICsgJyUsICcgKyBiICsgJyUsICcgKyByZ2JhWzNdICsgJyknO1xufTtcblxuY3MudG8uaHNsID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaHNsYSA9IHN3aXp6bGUoYXJndW1lbnRzKTtcblx0cmV0dXJuIGhzbGEubGVuZ3RoIDwgNCB8fCBoc2xhWzNdID09PSAxXG5cdFx0PyAnaHNsKCcgKyBoc2xhWzBdICsgJywgJyArIGhzbGFbMV0gKyAnJSwgJyArIGhzbGFbMl0gKyAnJSknXG5cdFx0OiAnaHNsYSgnICsgaHNsYVswXSArICcsICcgKyBoc2xhWzFdICsgJyUsICcgKyBoc2xhWzJdICsgJyUsICcgKyBoc2xhWzNdICsgJyknO1xufTtcblxuLy8gaHdiIGlzIGEgYml0IGRpZmZlcmVudCB0aGFuIHJnYihhKSAmIGhzbChhKSBzaW5jZSB0aGVyZSBpcyBubyBhbHBoYSBzcGVjaWZpYyBzeW50YXhcbi8vIChod2IgaGF2ZSBhbHBoYSBvcHRpb25hbCAmIDEgaXMgZGVmYXVsdCB2YWx1ZSlcbmNzLnRvLmh3YiA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIGh3YmEgPSBzd2l6emxlKGFyZ3VtZW50cyk7XG5cblx0dmFyIGEgPSAnJztcblx0aWYgKGh3YmEubGVuZ3RoID49IDQgJiYgaHdiYVszXSAhPT0gMSkge1xuXHRcdGEgPSAnLCAnICsgaHdiYVszXTtcblx0fVxuXG5cdHJldHVybiAnaHdiKCcgKyBod2JhWzBdICsgJywgJyArIGh3YmFbMV0gKyAnJSwgJyArIGh3YmFbMl0gKyAnJScgKyBhICsgJyknO1xufTtcblxuY3MudG8ua2V5d29yZCA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0cmV0dXJuIHJldmVyc2VOYW1lc1tyZ2Iuc2xpY2UoMCwgMyldO1xufTtcblxuLy8gaGVscGVyc1xuZnVuY3Rpb24gY2xhbXAobnVtLCBtaW4sIG1heCkge1xuXHRyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCBudW0pLCBtYXgpO1xufVxuXG5mdW5jdGlvbiBoZXhEb3VibGUobnVtKSB7XG5cdHZhciBzdHIgPSBudW0udG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdHJldHVybiAoc3RyLmxlbmd0aCA8IDIpID8gJzAnICsgc3RyIDogc3RyO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29sb3JTdHJpbmcgPSByZXF1aXJlKCdjb2xvci1zdHJpbmcnKTtcbnZhciBjb252ZXJ0ID0gcmVxdWlyZSgnY29sb3ItY29udmVydCcpO1xuXG52YXIgX3NsaWNlID0gW10uc2xpY2U7XG5cbnZhciBza2lwcGVkTW9kZWxzID0gW1xuXHQvLyB0byBiZSBob25lc3QsIEkgZG9uJ3QgcmVhbGx5IGZlZWwgbGlrZSBrZXl3b3JkIGJlbG9uZ3MgaW4gY29sb3IgY29udmVydCwgYnV0IGVoLlxuXHQna2V5d29yZCcsXG5cblx0Ly8gZ3JheSBjb25mbGljdHMgd2l0aCBzb21lIG1ldGhvZCBuYW1lcywgYW5kIGhhcyBpdHMgb3duIG1ldGhvZCBkZWZpbmVkLlxuXHQnZ3JheScsXG5cblx0Ly8gc2hvdWxkbid0IHJlYWxseSBiZSBpbiBjb2xvci1jb252ZXJ0IGVpdGhlci4uLlxuXHQnaGV4J1xuXTtcblxudmFyIGhhc2hlZE1vZGVsS2V5cyA9IHt9O1xuT2JqZWN0LmtleXMoY29udmVydCkuZm9yRWFjaChmdW5jdGlvbiAobW9kZWwpIHtcblx0aGFzaGVkTW9kZWxLZXlzW19zbGljZS5jYWxsKGNvbnZlcnRbbW9kZWxdLmxhYmVscykuc29ydCgpLmpvaW4oJycpXSA9IG1vZGVsO1xufSk7XG5cbnZhciBsaW1pdGVycyA9IHt9O1xuXG5mdW5jdGlvbiBDb2xvcihvYmosIG1vZGVsKSB7XG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2xvcikpIHtcblx0XHRyZXR1cm4gbmV3IENvbG9yKG9iaiwgbW9kZWwpO1xuXHR9XG5cblx0aWYgKG1vZGVsICYmIG1vZGVsIGluIHNraXBwZWRNb2RlbHMpIHtcblx0XHRtb2RlbCA9IG51bGw7XG5cdH1cblxuXHRpZiAobW9kZWwgJiYgIShtb2RlbCBpbiBjb252ZXJ0KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBtb2RlbDogJyArIG1vZGVsKTtcblx0fVxuXG5cdHZhciBpO1xuXHR2YXIgY2hhbm5lbHM7XG5cblx0aWYgKCFvYmopIHtcblx0XHR0aGlzLm1vZGVsID0gJ3JnYic7XG5cdFx0dGhpcy5jb2xvciA9IFswLCAwLCAwXTtcblx0XHR0aGlzLnZhbHBoYSA9IDE7XG5cdH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgQ29sb3IpIHtcblx0XHR0aGlzLm1vZGVsID0gb2JqLm1vZGVsO1xuXHRcdHRoaXMuY29sb3IgPSBvYmouY29sb3Iuc2xpY2UoKTtcblx0XHR0aGlzLnZhbHBoYSA9IG9iai52YWxwaGE7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcblx0XHR2YXIgcmVzdWx0ID0gY29sb3JTdHJpbmcuZ2V0KG9iaik7XG5cdFx0aWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgY29sb3IgZnJvbSBzdHJpbmc6ICcgKyBvYmopO1xuXHRcdH1cblxuXHRcdHRoaXMubW9kZWwgPSByZXN1bHQubW9kZWw7XG5cdFx0Y2hhbm5lbHMgPSBjb252ZXJ0W3RoaXMubW9kZWxdLmNoYW5uZWxzO1xuXHRcdHRoaXMuY29sb3IgPSByZXN1bHQudmFsdWUuc2xpY2UoMCwgY2hhbm5lbHMpO1xuXHRcdHRoaXMudmFscGhhID0gdHlwZW9mIHJlc3VsdC52YWx1ZVtjaGFubmVsc10gPT09ICdudW1iZXInID8gcmVzdWx0LnZhbHVlW2NoYW5uZWxzXSA6IDE7XG5cdH0gZWxzZSBpZiAob2JqLmxlbmd0aCkge1xuXHRcdHRoaXMubW9kZWwgPSBtb2RlbCB8fCAncmdiJztcblx0XHRjaGFubmVscyA9IGNvbnZlcnRbdGhpcy5tb2RlbF0uY2hhbm5lbHM7XG5cdFx0dmFyIG5ld0FyciA9IF9zbGljZS5jYWxsKG9iaiwgMCwgY2hhbm5lbHMpO1xuXHRcdHRoaXMuY29sb3IgPSB6ZXJvQXJyYXkobmV3QXJyLCBjaGFubmVscyk7XG5cdFx0dGhpcy52YWxwaGEgPSB0eXBlb2Ygb2JqW2NoYW5uZWxzXSA9PT0gJ251bWJlcicgPyBvYmpbY2hhbm5lbHNdIDogMTtcblx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuXHRcdC8vIHRoaXMgaXMgYWx3YXlzIFJHQiAtIGNhbiBiZSBjb252ZXJ0ZWQgbGF0ZXIgb24uXG5cdFx0b2JqICY9IDB4RkZGRkZGO1xuXHRcdHRoaXMubW9kZWwgPSAncmdiJztcblx0XHR0aGlzLmNvbG9yID0gW1xuXHRcdFx0KG9iaiA+PiAxNikgJiAweEZGLFxuXHRcdFx0KG9iaiA+PiA4KSAmIDB4RkYsXG5cdFx0XHRvYmogJiAweEZGXG5cdFx0XTtcblx0XHR0aGlzLnZhbHBoYSA9IDE7XG5cdH0gZWxzZSB7XG5cdFx0dGhpcy52YWxwaGEgPSAxO1xuXG5cdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuXHRcdGlmICgnYWxwaGEnIGluIG9iaikge1xuXHRcdFx0a2V5cy5zcGxpY2Uoa2V5cy5pbmRleE9mKCdhbHBoYScpLCAxKTtcblx0XHRcdHRoaXMudmFscGhhID0gdHlwZW9mIG9iai5hbHBoYSA9PT0gJ251bWJlcicgPyBvYmouYWxwaGEgOiAwO1xuXHRcdH1cblxuXHRcdHZhciBoYXNoZWRLZXlzID0ga2V5cy5zb3J0KCkuam9pbignJyk7XG5cdFx0aWYgKCEoaGFzaGVkS2V5cyBpbiBoYXNoZWRNb2RlbEtleXMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBjb2xvciBmcm9tIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KG9iaikpO1xuXHRcdH1cblxuXHRcdHRoaXMubW9kZWwgPSBoYXNoZWRNb2RlbEtleXNbaGFzaGVkS2V5c107XG5cblx0XHR2YXIgbGFiZWxzID0gY29udmVydFt0aGlzLm1vZGVsXS5sYWJlbHM7XG5cdFx0dmFyIGNvbG9yID0gW107XG5cdFx0Zm9yIChpID0gMDsgaSA8IGxhYmVscy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29sb3IucHVzaChvYmpbbGFiZWxzW2ldXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jb2xvciA9IHplcm9BcnJheShjb2xvcik7XG5cdH1cblxuXHQvLyBwZXJmb3JtIGxpbWl0YXRpb25zIChjbGFtcGluZywgZXRjLilcblx0aWYgKGxpbWl0ZXJzW3RoaXMubW9kZWxdKSB7XG5cdFx0Y2hhbm5lbHMgPSBjb252ZXJ0W3RoaXMubW9kZWxdLmNoYW5uZWxzO1xuXHRcdGZvciAoaSA9IDA7IGkgPCBjaGFubmVsczsgaSsrKSB7XG5cdFx0XHR2YXIgbGltaXQgPSBsaW1pdGVyc1t0aGlzLm1vZGVsXVtpXTtcblx0XHRcdGlmIChsaW1pdCkge1xuXHRcdFx0XHR0aGlzLmNvbG9yW2ldID0gbGltaXQodGhpcy5jb2xvcltpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dGhpcy52YWxwaGEgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0aGlzLnZhbHBoYSkpO1xuXG5cdGlmIChPYmplY3QuZnJlZXplKSB7XG5cdFx0T2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0fVxufVxuXG5Db2xvci5wcm90b3R5cGUgPSB7XG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RyaW5nKCk7XG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXNbdGhpcy5tb2RlbF0oKTtcblx0fSxcblxuXHRzdHJpbmc6IGZ1bmN0aW9uIChwbGFjZXMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMubW9kZWwgaW4gY29sb3JTdHJpbmcudG8gPyB0aGlzIDogdGhpcy5yZ2IoKTtcblx0XHRzZWxmID0gc2VsZi5yb3VuZCh0eXBlb2YgcGxhY2VzID09PSAnbnVtYmVyJyA/IHBsYWNlcyA6IDEpO1xuXHRcdHZhciBhcmdzID0gc2VsZi52YWxwaGEgPT09IDEgPyBzZWxmLmNvbG9yIDogc2VsZi5jb2xvci5jb25jYXQodGhpcy52YWxwaGEpO1xuXHRcdHJldHVybiBjb2xvclN0cmluZy50b1tzZWxmLm1vZGVsXShhcmdzKTtcblx0fSxcblxuXHRwZXJjZW50U3RyaW5nOiBmdW5jdGlvbiAocGxhY2VzKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLnJnYigpLnJvdW5kKHR5cGVvZiBwbGFjZXMgPT09ICdudW1iZXInID8gcGxhY2VzIDogMSk7XG5cdFx0dmFyIGFyZ3MgPSBzZWxmLnZhbHBoYSA9PT0gMSA/IHNlbGYuY29sb3IgOiBzZWxmLmNvbG9yLmNvbmNhdCh0aGlzLnZhbHBoYSk7XG5cdFx0cmV0dXJuIGNvbG9yU3RyaW5nLnRvLnJnYi5wZXJjZW50KGFyZ3MpO1xuXHR9LFxuXG5cdGFycmF5OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFscGhhID09PSAxID8gdGhpcy5jb2xvci5zbGljZSgpIDogdGhpcy5jb2xvci5jb25jYXQodGhpcy52YWxwaGEpO1xuXHR9LFxuXG5cdG9iamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZXN1bHQgPSB7fTtcblx0XHR2YXIgY2hhbm5lbHMgPSBjb252ZXJ0W3RoaXMubW9kZWxdLmNoYW5uZWxzO1xuXHRcdHZhciBsYWJlbHMgPSBjb252ZXJ0W3RoaXMubW9kZWxdLmxhYmVscztcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbm5lbHM7IGkrKykge1xuXHRcdFx0cmVzdWx0W2xhYmVsc1tpXV0gPSB0aGlzLmNvbG9yW2ldO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLnZhbHBoYSAhPT0gMSkge1xuXHRcdFx0cmVzdWx0LmFscGhhID0gdGhpcy52YWxwaGE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblxuXHR1bml0QXJyYXk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcmdiID0gdGhpcy5yZ2IoKS5jb2xvcjtcblx0XHRyZ2JbMF0gLz0gMjU1O1xuXHRcdHJnYlsxXSAvPSAyNTU7XG5cdFx0cmdiWzJdIC89IDI1NTtcblxuXHRcdGlmICh0aGlzLnZhbHBoYSAhPT0gMSkge1xuXHRcdFx0cmdiLnB1c2godGhpcy52YWxwaGEpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZ2I7XG5cdH0sXG5cblx0dW5pdE9iamVjdDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpLm9iamVjdCgpO1xuXHRcdHJnYi5yIC89IDI1NTtcblx0XHRyZ2IuZyAvPSAyNTU7XG5cdFx0cmdiLmIgLz0gMjU1O1xuXG5cdFx0aWYgKHRoaXMudmFscGhhICE9PSAxKSB7XG5cdFx0XHRyZ2IuYWxwaGEgPSB0aGlzLnZhbHBoYTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmdiO1xuXHR9LFxuXG5cdHJvdW5kOiBmdW5jdGlvbiAocGxhY2VzKSB7XG5cdFx0cGxhY2VzID0gTWF0aC5tYXgocGxhY2VzIHx8IDAsIDApO1xuXHRcdHJldHVybiBuZXcgQ29sb3IodGhpcy5jb2xvci5tYXAocm91bmRUb1BsYWNlKHBsYWNlcykpLmNvbmNhdCh0aGlzLnZhbHBoYSksIHRoaXMubW9kZWwpO1xuXHR9LFxuXG5cdGFscGhhOiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodGhpcy5jb2xvci5jb25jYXQoTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdmFsKSkpLCB0aGlzLm1vZGVsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy52YWxwaGE7XG5cdH0sXG5cblx0Ly8gcmdiXG5cdHJlZDogZ2V0c2V0KCdyZ2InLCAwLCBtYXhmbigyNTUpKSxcblx0Z3JlZW46IGdldHNldCgncmdiJywgMSwgbWF4Zm4oMjU1KSksXG5cdGJsdWU6IGdldHNldCgncmdiJywgMiwgbWF4Zm4oMjU1KSksXG5cblx0aHVlOiBnZXRzZXQoWydoc2wnLCAnaHN2JywgJ2hzbCcsICdod2InLCAnaGNnJ10sIDAsIGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuICgodmFsICUgMzYwKSArIDM2MCkgJSAzNjA7IH0pLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJyYWNlLXN0eWxlXG5cblx0c2F0dXJhdGlvbmw6IGdldHNldCgnaHNsJywgMSwgbWF4Zm4oMTAwKSksXG5cdGxpZ2h0bmVzczogZ2V0c2V0KCdoc2wnLCAyLCBtYXhmbigxMDApKSxcblxuXHRzYXR1cmF0aW9udjogZ2V0c2V0KCdoc3YnLCAxLCBtYXhmbigxMDApKSxcblx0dmFsdWU6IGdldHNldCgnaHN2JywgMiwgbWF4Zm4oMTAwKSksXG5cblx0Y2hyb21hOiBnZXRzZXQoJ2hjZycsIDEsIG1heGZuKDEwMCkpLFxuXHRncmF5OiBnZXRzZXQoJ2hjZycsIDIsIG1heGZuKDEwMCkpLFxuXG5cdHdoaXRlOiBnZXRzZXQoJ2h3YicsIDEsIG1heGZuKDEwMCkpLFxuXHR3YmxhY2s6IGdldHNldCgnaHdiJywgMiwgbWF4Zm4oMTAwKSksXG5cblx0Y3lhbjogZ2V0c2V0KCdjbXlrJywgMCwgbWF4Zm4oMTAwKSksXG5cdG1hZ2VudGE6IGdldHNldCgnY215aycsIDEsIG1heGZuKDEwMCkpLFxuXHR5ZWxsb3c6IGdldHNldCgnY215aycsIDIsIG1heGZuKDEwMCkpLFxuXHRibGFjazogZ2V0c2V0KCdjbXlrJywgMywgbWF4Zm4oMTAwKSksXG5cblx0eDogZ2V0c2V0KCd4eXonLCAwLCBtYXhmbigxMDApKSxcblx0eTogZ2V0c2V0KCd4eXonLCAxLCBtYXhmbigxMDApKSxcblx0ejogZ2V0c2V0KCd4eXonLCAyLCBtYXhmbigxMDApKSxcblxuXHRsOiBnZXRzZXQoJ2xhYicsIDAsIG1heGZuKDEwMCkpLFxuXHRhOiBnZXRzZXQoJ2xhYicsIDEpLFxuXHRiOiBnZXRzZXQoJ2xhYicsIDIpLFxuXG5cdGtleXdvcmQ6IGZ1bmN0aW9uICh2YWwpIHtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih2YWwpO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb252ZXJ0W3RoaXMubW9kZWxdLmtleXdvcmQodGhpcy5jb2xvcik7XG5cdH0sXG5cblx0aGV4OiBmdW5jdGlvbiAodmFsKSB7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodmFsKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29sb3JTdHJpbmcudG8uaGV4KHRoaXMucmdiKCkucm91bmQoKS5jb2xvcik7XG5cdH0sXG5cblx0cmdiTnVtYmVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMucmdiKCkuY29sb3I7XG5cdFx0cmV0dXJuICgocmdiWzBdICYgMHhGRikgPDwgMTYpIHwgKChyZ2JbMV0gJiAweEZGKSA8PCA4KSB8IChyZ2JbMl0gJiAweEZGKTtcblx0fSxcblxuXHRsdW1pbm9zaXR5OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNyZWxhdGl2ZWx1bWluYW5jZWRlZlxuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXG5cdFx0dmFyIGx1bSA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcmdiLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hhbiA9IHJnYltpXSAvIDI1NTtcblx0XHRcdGx1bVtpXSA9IChjaGFuIDw9IDAuMDM5MjgpID8gY2hhbiAvIDEyLjkyIDogTWF0aC5wb3coKChjaGFuICsgMC4wNTUpIC8gMS4wNTUpLCAyLjQpO1xuXHRcdH1cblxuXHRcdHJldHVybiAwLjIxMjYgKiBsdW1bMF0gKyAwLjcxNTIgKiBsdW1bMV0gKyAwLjA3MjIgKiBsdW1bMl07XG5cdH0sXG5cblx0Y29udHJhc3Q6IGZ1bmN0aW9uIChjb2xvcjIpIHtcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9XQ0FHMjAvI2NvbnRyYXN0LXJhdGlvZGVmXG5cdFx0dmFyIGx1bTEgPSB0aGlzLmx1bWlub3NpdHkoKTtcblx0XHR2YXIgbHVtMiA9IGNvbG9yMi5sdW1pbm9zaXR5KCk7XG5cblx0XHRpZiAobHVtMSA+IGx1bTIpIHtcblx0XHRcdHJldHVybiAobHVtMSArIDAuMDUpIC8gKGx1bTIgKyAwLjA1KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gKGx1bTIgKyAwLjA1KSAvIChsdW0xICsgMC4wNSk7XG5cdH0sXG5cblx0bGV2ZWw6IGZ1bmN0aW9uIChjb2xvcjIpIHtcblx0XHR2YXIgY29udHJhc3RSYXRpbyA9IHRoaXMuY29udHJhc3QoY29sb3IyKTtcblx0XHRpZiAoY29udHJhc3RSYXRpbyA+PSA3LjEpIHtcblx0XHRcdHJldHVybiAnQUFBJztcblx0XHR9XG5cblx0XHRyZXR1cm4gKGNvbnRyYXN0UmF0aW8gPj0gNC41KSA/ICdBQScgOiAnJztcblx0fSxcblxuXHRkYXJrOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gWUlRIGVxdWF0aW9uIGZyb20gaHR0cDovLzI0d2F5cy5vcmcvMjAxMC9jYWxjdWxhdGluZy1jb2xvci1jb250cmFzdFxuXHRcdHZhciByZ2IgPSB0aGlzLnJnYigpLmNvbG9yO1xuXHRcdHZhciB5aXEgPSAocmdiWzBdICogMjk5ICsgcmdiWzFdICogNTg3ICsgcmdiWzJdICogMTE0KSAvIDEwMDA7XG5cdFx0cmV0dXJuIHlpcSA8IDEyODtcblx0fSxcblxuXHRsaWdodDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAhdGhpcy5kYXJrKCk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHJnYiA9IHRoaXMucmdiKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHJnYi5jb2xvcltpXSA9IDI1NSAtIHJnYi5jb2xvcltpXTtcblx0XHR9XG5cdFx0cmV0dXJuIHJnYjtcblx0fSxcblxuXHRsaWdodGVuOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy5oc2woKTtcblx0XHRoc2wuY29sb3JbMl0gKz0gaHNsLmNvbG9yWzJdICogcmF0aW87XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHRkYXJrZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBoc2wgPSB0aGlzLmhzbCgpO1xuXHRcdGhzbC5jb2xvclsyXSAtPSBoc2wuY29sb3JbMl0gKiByYXRpbztcblx0XHRyZXR1cm4gaHNsO1xuXHR9LFxuXG5cdHNhdHVyYXRlOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy5oc2woKTtcblx0XHRoc2wuY29sb3JbMV0gKz0gaHNsLmNvbG9yWzFdICogcmF0aW87XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHRkZXNhdHVyYXRlOiBmdW5jdGlvbiAocmF0aW8pIHtcblx0XHR2YXIgaHNsID0gdGhpcy5oc2woKTtcblx0XHRoc2wuY29sb3JbMV0gLT0gaHNsLmNvbG9yWzFdICogcmF0aW87XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHR3aGl0ZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBod2IgPSB0aGlzLmh3YigpO1xuXHRcdGh3Yi5jb2xvclsxXSArPSBod2IuY29sb3JbMV0gKiByYXRpbztcblx0XHRyZXR1cm4gaHdiO1xuXHR9LFxuXG5cdGJsYWNrZW46IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHZhciBod2IgPSB0aGlzLmh3YigpO1xuXHRcdGh3Yi5jb2xvclsyXSArPSBod2IuY29sb3JbMl0gKiByYXRpbztcblx0XHRyZXR1cm4gaHdiO1xuXHR9LFxuXG5cdGdyYXlzY2FsZTogZnVuY3Rpb24gKCkge1xuXHRcdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR3JheXNjYWxlI0NvbnZlcnRpbmdfY29sb3JfdG9fZ3JheXNjYWxlXG5cdFx0dmFyIHJnYiA9IHRoaXMucmdiKCkuY29sb3I7XG5cdFx0dmFyIHZhbCA9IHJnYlswXSAqIDAuMyArIHJnYlsxXSAqIDAuNTkgKyByZ2JbMl0gKiAwLjExO1xuXHRcdHJldHVybiBDb2xvci5yZ2IodmFsLCB2YWwsIHZhbCk7XG5cdH0sXG5cblx0ZmFkZTogZnVuY3Rpb24gKHJhdGlvKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWxwaGEodGhpcy52YWxwaGEgLSAodGhpcy52YWxwaGEgKiByYXRpbykpO1xuXHR9LFxuXG5cdG9wYXF1ZXI6IGZ1bmN0aW9uIChyYXRpbykge1xuXHRcdHJldHVybiB0aGlzLmFscGhhKHRoaXMudmFscGhhICsgKHRoaXMudmFscGhhICogcmF0aW8pKTtcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uIChkZWdyZWVzKSB7XG5cdFx0dmFyIGhzbCA9IHRoaXMuaHNsKCk7XG5cdFx0dmFyIGh1ZSA9IGhzbC5jb2xvclswXTtcblx0XHRodWUgPSAoaHVlICsgZGVncmVlcykgJSAzNjA7XG5cdFx0aHVlID0gaHVlIDwgMCA/IDM2MCArIGh1ZSA6IGh1ZTtcblx0XHRoc2wuY29sb3JbMF0gPSBodWU7XG5cdFx0cmV0dXJuIGhzbDtcblx0fSxcblxuXHRtaXg6IGZ1bmN0aW9uIChtaXhpbkNvbG9yLCB3ZWlnaHQpIHtcblx0XHQvLyBwb3J0ZWQgZnJvbSBzYXNzIGltcGxlbWVudGF0aW9uIGluIENcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vc2Fzcy9saWJzYXNzL2Jsb2IvMGU2YjRhMjg1MDA5MjM1NmFhM2VjZTA3YzZiMjQ5ZjAyMjFjYWNlZC9mdW5jdGlvbnMuY3BwI0wyMDlcblx0XHR2YXIgY29sb3IxID0gdGhpcy5yZ2IoKTtcblx0XHR2YXIgY29sb3IyID0gbWl4aW5Db2xvci5yZ2IoKTtcblx0XHR2YXIgcCA9IHdlaWdodCA9PT0gdW5kZWZpbmVkID8gMC41IDogd2VpZ2h0O1xuXG5cdFx0dmFyIHcgPSAyICogcCAtIDE7XG5cdFx0dmFyIGEgPSBjb2xvcjEuYWxwaGEoKSAtIGNvbG9yMi5hbHBoYSgpO1xuXG5cdFx0dmFyIHcxID0gKCgodyAqIGEgPT09IC0xKSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG5cdFx0dmFyIHcyID0gMSAtIHcxO1xuXG5cdFx0cmV0dXJuIENvbG9yLnJnYihcblx0XHRcdFx0dzEgKiBjb2xvcjEucmVkKCkgKyB3MiAqIGNvbG9yMi5yZWQoKSxcblx0XHRcdFx0dzEgKiBjb2xvcjEuZ3JlZW4oKSArIHcyICogY29sb3IyLmdyZWVuKCksXG5cdFx0XHRcdHcxICogY29sb3IxLmJsdWUoKSArIHcyICogY29sb3IyLmJsdWUoKSxcblx0XHRcdFx0Y29sb3IxLmFscGhhKCkgKiBwICsgY29sb3IyLmFscGhhKCkgKiAoMSAtIHApKTtcblx0fVxufTtcblxuLy8gbW9kZWwgY29udmVyc2lvbiBtZXRob2RzIGFuZCBzdGF0aWMgY29uc3RydWN0b3JzXG5PYmplY3Qua2V5cyhjb252ZXJ0KS5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xuXHRpZiAoc2tpcHBlZE1vZGVscy5pbmRleE9mKG1vZGVsKSAhPT0gLTEpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHR2YXIgY2hhbm5lbHMgPSBjb252ZXJ0W21vZGVsXS5jaGFubmVscztcblxuXHQvLyBjb252ZXJzaW9uIG1ldGhvZHNcblx0Q29sb3IucHJvdG90eXBlW21vZGVsXSA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5tb2RlbCA9PT0gbW9kZWwpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IoYXJndW1lbnRzLCBtb2RlbCk7XG5cdFx0fVxuXG5cdFx0dmFyIG5ld0FscGhhID0gdHlwZW9mIGFyZ3VtZW50c1tjaGFubmVsc10gPT09ICdudW1iZXInID8gY2hhbm5lbHMgOiB0aGlzLnZhbHBoYTtcblx0XHRyZXR1cm4gbmV3IENvbG9yKGFzc2VydEFycmF5KGNvbnZlcnRbdGhpcy5tb2RlbF1bbW9kZWxdLnJhdyh0aGlzLmNvbG9yKSkuY29uY2F0KG5ld0FscGhhKSwgbW9kZWwpO1xuXHR9O1xuXG5cdC8vICdzdGF0aWMnIGNvbnN0cnVjdGlvbiBtZXRob2RzXG5cdENvbG9yW21vZGVsXSA9IGZ1bmN0aW9uIChjb2xvcikge1xuXHRcdGlmICh0eXBlb2YgY29sb3IgPT09ICdudW1iZXInKSB7XG5cdFx0XHRjb2xvciA9IHplcm9BcnJheShfc2xpY2UuY2FsbChhcmd1bWVudHMpLCBjaGFubmVscyk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgQ29sb3IoY29sb3IsIG1vZGVsKTtcblx0fTtcbn0pO1xuXG5mdW5jdGlvbiByb3VuZFRvKG51bSwgcGxhY2VzKSB7XG5cdHJldHVybiBOdW1iZXIobnVtLnRvRml4ZWQocGxhY2VzKSk7XG59XG5cbmZ1bmN0aW9uIHJvdW5kVG9QbGFjZShwbGFjZXMpIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChudW0pIHtcblx0XHRyZXR1cm4gcm91bmRUbyhudW0sIHBsYWNlcyk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGdldHNldChtb2RlbCwgY2hhbm5lbCwgbW9kaWZpZXIpIHtcblx0bW9kZWwgPSBBcnJheS5pc0FycmF5KG1vZGVsKSA/IG1vZGVsIDogW21vZGVsXTtcblxuXHRtb2RlbC5mb3JFYWNoKGZ1bmN0aW9uIChtKSB7XG5cdFx0KGxpbWl0ZXJzW21dIHx8IChsaW1pdGVyc1ttXSA9IFtdKSlbY2hhbm5lbF0gPSBtb2RpZmllcjtcblx0fSk7XG5cblx0bW9kZWwgPSBtb2RlbFswXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKHZhbCkge1xuXHRcdHZhciByZXN1bHQ7XG5cblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdFx0aWYgKG1vZGlmaWVyKSB7XG5cdFx0XHRcdHZhbCA9IG1vZGlmaWVyKHZhbCk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3VsdCA9IHRoaXNbbW9kZWxdKCk7XG5cdFx0XHRyZXN1bHQuY29sb3JbY2hhbm5lbF0gPSB2YWw7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblxuXHRcdHJlc3VsdCA9IHRoaXNbbW9kZWxdKCkuY29sb3JbY2hhbm5lbF07XG5cdFx0aWYgKG1vZGlmaWVyKSB7XG5cdFx0XHRyZXN1bHQgPSBtb2RpZmllcihyZXN1bHQpO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG59XG5cbmZ1bmN0aW9uIG1heGZuKG1heCkge1xuXHRyZXR1cm4gZnVuY3Rpb24gKHYpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4LCB2KSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIGFzc2VydEFycmF5KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsIDogW3ZhbF07XG59XG5cbmZ1bmN0aW9uIHplcm9BcnJheShhcnIsIGxlbmd0aCkge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBhcnJbaV0gIT09ICdudW1iZXInKSB7XG5cdFx0XHRhcnJbaV0gPSAwO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhcnI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sb3I7XG4iLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5hcnJheS5maW5kJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5maW5kOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5mb3JFYWNoOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuQXJyYXkucmVkdWNlOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLkZ1bmN0aW9uLmJpbmQ7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYubnVtYmVyLmNvbnN0cnVjdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE51bWJlcjsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuYXNzaWduOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnZhciAkT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyl7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Qua2V5cycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmtleXM7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07IiwiLy8gMjIuMS4zLjMxIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxudmFyIFVOU0NPUEFCTEVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3Vuc2NvcGFibGVzJylcbiAgLCBBcnJheVByb3RvICA9IEFycmF5LnByb3RvdHlwZTtcbmlmKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZClyZXF1aXJlKCcuL19oaWRlJykoQXJyYXlQcm90bywgVU5TQ09QQUJMRVMsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIGlmKCFpc09iamVjdChpdCkpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCB0b0luZGV4ICAgPSByZXF1aXJlKCcuL190by1pbmRleCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihJU19JTkNMVURFUyl7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgZWwsIGZyb21JbmRleCl7XG4gICAgdmFyIE8gICAgICA9IHRvSU9iamVjdCgkdGhpcylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IHRvSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpXG4gICAgICAsIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICBpZihJU19JTkNMVURFUyAmJiBlbCAhPSBlbCl3aGlsZShsZW5ndGggPiBpbmRleCl7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICBpZih2YWx1ZSAhPSB2YWx1ZSlyZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSN0b0luZGV4IGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTyl7XG4gICAgICBpZihPW2luZGV4XSA9PT0gZWwpcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTsiLCIvLyAwIC0+IEFycmF5I2ZvckVhY2hcbi8vIDEgLT4gQXJyYXkjbWFwXG4vLyAyIC0+IEFycmF5I2ZpbHRlclxuLy8gMyAtPiBBcnJheSNzb21lXG4vLyA0IC0+IEFycmF5I2V2ZXJ5XG4vLyA1IC0+IEFycmF5I2ZpbmRcbi8vIDYgLT4gQXJyYXkjZmluZEluZGV4XG52YXIgY3R4ICAgICAgPSByZXF1aXJlKCcuL19jdHgnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJylcbiAgLCBhc2MgICAgICA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRZUEUsICRjcmVhdGUpe1xuICB2YXIgSVNfTUFQICAgICAgICA9IFRZUEUgPT0gMVxuICAgICwgSVNfRklMVEVSICAgICA9IFRZUEUgPT0gMlxuICAgICwgSVNfU09NRSAgICAgICA9IFRZUEUgPT0gM1xuICAgICwgSVNfRVZFUlkgICAgICA9IFRZUEUgPT0gNFxuICAgICwgSVNfRklORF9JTkRFWCA9IFRZUEUgPT0gNlxuICAgICwgTk9fSE9MRVMgICAgICA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYXG4gICAgLCBjcmVhdGUgICAgICAgID0gJGNyZWF0ZSB8fCBhc2M7XG4gIHJldHVybiBmdW5jdGlvbigkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCl7XG4gICAgdmFyIE8gICAgICA9IHRvT2JqZWN0KCR0aGlzKVxuICAgICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXG4gICAgICAsIGYgICAgICA9IGN0eChjYWxsYmFja2ZuLCB0aGF0LCAzKVxuICAgICAgLCBsZW5ndGggPSB0b0xlbmd0aChzZWxmLmxlbmd0aClcbiAgICAgICwgaW5kZXggID0gMFxuICAgICAgLCByZXN1bHQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgPyBjcmVhdGUoJHRoaXMsIDApIDogdW5kZWZpbmVkXG4gICAgICAsIHZhbCwgcmVzO1xuICAgIGZvcig7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspaWYoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZil7XG4gICAgICB2YWwgPSBzZWxmW2luZGV4XTtcbiAgICAgIHJlcyA9IGYodmFsLCBpbmRleCwgTyk7XG4gICAgICBpZihUWVBFKXtcbiAgICAgICAgaWYoSVNfTUFQKXJlc3VsdFtpbmRleF0gPSByZXM7ICAgICAgICAgICAgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYocmVzKXN3aXRjaChUWVBFKXtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiB0cnVlOyAgICAgICAgICAgICAgICAgICAgLy8gc29tZVxuICAgICAgICAgIGNhc2UgNTogcmV0dXJuIHZhbDsgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kXG4gICAgICAgICAgY2FzZSA2OiByZXR1cm4gaW5kZXg7ICAgICAgICAgICAgICAgICAgIC8vIGZpbmRJbmRleFxuICAgICAgICAgIGNhc2UgMjogcmVzdWx0LnB1c2godmFsKTsgICAgICAgICAgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIGlmKElTX0VWRVJZKXJldHVybiBmYWxzZTsgICAgICAgICAgLy8gZXZlcnlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIElTX0ZJTkRfSU5ERVggPyAtMSA6IElTX1NPTUUgfHwgSVNfRVZFUlkgPyBJU19FVkVSWSA6IHJlc3VsdDtcbiAgfTtcbn07IiwidmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIHRvT2JqZWN0ICA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgSU9iamVjdCAgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgdG9MZW5ndGggID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgY2FsbGJhY2tmbiwgYUxlbiwgbWVtbywgaXNSaWdodCl7XG4gIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgdmFyIE8gICAgICA9IHRvT2JqZWN0KHRoYXQpXG4gICAgLCBzZWxmICAgPSBJT2JqZWN0KE8pXG4gICAgLCBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aClcbiAgICAsIGluZGV4ICA9IGlzUmlnaHQgPyBsZW5ndGggLSAxIDogMFxuICAgICwgaSAgICAgID0gaXNSaWdodCA/IC0xIDogMTtcbiAgaWYoYUxlbiA8IDIpZm9yKDs7KXtcbiAgICBpZihpbmRleCBpbiBzZWxmKXtcbiAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaW5kZXggKz0gaTtcbiAgICBpZihpc1JpZ2h0ID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KXtcbiAgICAgIHRocm93IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgIH1cbiAgfVxuICBmb3IoO2lzUmlnaHQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpaWYoaW5kZXggaW4gc2VsZil7XG4gICAgbWVtbyA9IGNhbGxiYWNrZm4obWVtbywgc2VsZltpbmRleF0sIGluZGV4LCBPKTtcbiAgfVxuICByZXR1cm4gbWVtbztcbn07IiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpc0FycmF5ICA9IHJlcXVpcmUoJy4vX2lzLWFycmF5JylcbiAgLCBTUEVDSUVTICA9IHJlcXVpcmUoJy4vX3drcycpKCdzcGVjaWVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWwpe1xuICB2YXIgQztcbiAgaWYoaXNBcnJheShvcmlnaW5hbCkpe1xuICAgIEMgPSBvcmlnaW5hbC5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSlDID0gdW5kZWZpbmVkO1xuICAgIGlmKGlzT2JqZWN0KEMpKXtcbiAgICAgIEMgPSBDW1NQRUNJRVNdO1xuICAgICAgaWYoQyA9PT0gbnVsbClDID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSByZXR1cm4gQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDO1xufTsiLCIvLyA5LjQuMi4zIEFycmF5U3BlY2llc0NyZWF0ZShvcmlnaW5hbEFycmF5LCBsZW5ndGgpXG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsLCBsZW5ndGgpe1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWwpKShsZW5ndGgpO1xufTsiLCIndXNlIHN0cmljdCc7XG52YXIgYUZ1bmN0aW9uICA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKVxuICAsIGlzT2JqZWN0ICAgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGludm9rZSAgICAgPSByZXF1aXJlKCcuL19pbnZva2UnKVxuICAsIGFycmF5U2xpY2UgPSBbXS5zbGljZVxuICAsIGZhY3RvcmllcyAgPSB7fTtcblxudmFyIGNvbnN0cnVjdCA9IGZ1bmN0aW9uKEYsIGxlbiwgYXJncyl7XG4gIGlmKCEobGVuIGluIGZhY3Rvcmllcykpe1xuICAgIGZvcih2YXIgbiA9IFtdLCBpID0gMDsgaSA8IGxlbjsgaSsrKW5baV0gPSAnYVsnICsgaSArICddJztcbiAgICBmYWN0b3JpZXNbbGVuXSA9IEZ1bmN0aW9uKCdGLGEnLCAncmV0dXJuIG5ldyBGKCcgKyBuLmpvaW4oJywnKSArICcpJyk7XG4gIH0gcmV0dXJuIGZhY3Rvcmllc1tsZW5dKEYsIGFyZ3MpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5iaW5kIHx8IGZ1bmN0aW9uIGJpbmQodGhhdCAvKiwgYXJncy4uLiAqLyl7XG4gIHZhciBmbiAgICAgICA9IGFGdW5jdGlvbih0aGlzKVxuICAgICwgcGFydEFyZ3MgPSBhcnJheVNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGJvdW5kID0gZnVuY3Rpb24oLyogYXJncy4uLiAqLyl7XG4gICAgdmFyIGFyZ3MgPSBwYXJ0QXJncy5jb25jYXQoYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgYm91bmQgPyBjb25zdHJ1Y3QoZm4sIGFyZ3MubGVuZ3RoLCBhcmdzKSA6IGludm9rZShmbiwgYXJncywgdGhhdCk7XG4gIH07XG4gIGlmKGlzT2JqZWN0KGZuLnByb3RvdHlwZSkpYm91bmQucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmQ7XG59OyIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07IiwidmFyIGNvcmUgPSBtb2R1bGUuZXhwb3J0cyA9IHt2ZXJzaW9uOiAnMi40LjAnfTtcbmlmKHR5cGVvZiBfX2UgPT0gJ251bWJlcicpX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIHRoYXQsIGxlbmd0aCl7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmKHRoYXQgPT09IHVuZGVmaW5lZClyZXR1cm4gZm47XG4gIHN3aXRjaChsZW5ndGgpe1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKGEpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gICAgfTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24oYSwgYiwgYyl7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbigvKiAuLi5hcmdzICovKXtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgfTtcbn07IiwiLy8gNy4yLjEgUmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudClcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZihpdCA9PSB1bmRlZmluZWQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59OyIsIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudFxuICAvLyBpbiBvbGQgSUUgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCdcbiAgLCBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTsiLCIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTsiLCJ2YXIgZ2xvYmFsICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBjb3JlICAgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBoaWRlICAgICAgPSByZXF1aXJlKCcuL19oaWRlJylcbiAgLCByZWRlZmluZSAgPSByZXF1aXJlKCcuL19yZWRlZmluZScpXG4gICwgY3R4ICAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxudmFyICRleHBvcnQgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBzb3VyY2Upe1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRlxuICAgICwgSVNfR0xPQkFMID0gdHlwZSAmICRleHBvcnQuR1xuICAgICwgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuU1xuICAgICwgSVNfUFJPVE8gID0gdHlwZSAmICRleHBvcnQuUFxuICAgICwgSVNfQklORCAgID0gdHlwZSAmICRleHBvcnQuQlxuICAgICwgdGFyZ2V0ICAgID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdXG4gICAgLCBleHBvcnRzICAgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KVxuICAgICwgZXhwUHJvdG8gID0gZXhwb3J0c1tQUk9UT1RZUEVdIHx8IChleHBvcnRzW1BST1RPVFlQRV0gPSB7fSlcbiAgICAsIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYoSVNfR0xPQkFMKXNvdXJjZSA9IG5hbWU7XG4gIGZvcihrZXkgaW4gc291cmNlKXtcbiAgICAvLyBjb250YWlucyBpbiBuYXRpdmVcbiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgcGFzc2VkXG4gICAgb3V0ID0gKG93biA/IHRhcmdldCA6IHNvdXJjZSlba2V5XTtcbiAgICAvLyBiaW5kIHRpbWVycyB0byBnbG9iYWwgZm9yIGNhbGwgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGV4cCA9IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4dGVuZCBnbG9iYWxcbiAgICBpZih0YXJnZXQpcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYoZXhwb3J0c1trZXldICE9IG91dCloaWRlKGV4cG9ydHMsIGtleSwgZXhwKTtcbiAgICBpZihJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dClleHBQcm90b1trZXldID0gb3V0O1xuICB9XG59O1xuZ2xvYmFsLmNvcmUgPSBjb3JlO1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YCBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4ZWMpe1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaChlKXtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTsiLCIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbmlmKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmIiwidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0LCBrZXkpe1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07IiwidmFyIGRQICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGNyZWF0ZURlc2MgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uKG9iamVjdCwga2V5LCB2YWx1ZSl7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50OyIsIm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgJiYgIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHtnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiA3OyB9fSkuYSAhPSA3O1xufSk7IiwidmFyIGlzT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4vX3NldC1wcm90bycpLnNldDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGhhdCwgdGFyZ2V0LCBDKXtcbiAgdmFyIFAsIFMgPSB0YXJnZXQuY29uc3RydWN0b3I7XG4gIGlmKFMgIT09IEMgJiYgdHlwZW9mIFMgPT0gJ2Z1bmN0aW9uJyAmJiAoUCA9IFMucHJvdG90eXBlKSAhPT0gQy5wcm90b3R5cGUgJiYgaXNPYmplY3QoUCkgJiYgc2V0UHJvdG90eXBlT2Ype1xuICAgIHNldFByb3RvdHlwZU9mKHRoYXQsIFApO1xuICB9IHJldHVybiB0aGF0O1xufTsiLCIvLyBmYXN0IGFwcGx5LCBodHRwOi8vanNwZXJmLmxua2l0LmNvbS9mYXN0LWFwcGx5LzVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZm4sIGFyZ3MsIHRoYXQpe1xuICB2YXIgdW4gPSB0aGF0ID09PSB1bmRlZmluZWQ7XG4gIHN3aXRjaChhcmdzLmxlbmd0aCl7XG4gICAgY2FzZSAwOiByZXR1cm4gdW4gPyBmbigpXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQpO1xuICAgIGNhc2UgMTogcmV0dXJuIHVuID8gZm4oYXJnc1swXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgIGNhc2UgNDogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gIH0gcmV0dXJuICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbn07IiwiLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3NcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCkgPyBPYmplY3QgOiBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07IiwiLy8gNy4yLjIgSXNBcnJheShhcmd1bWVudClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZyl7XG4gIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKVxuICAsIGdPUFMgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcHMnKVxuICAsIHBJRSAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgID0gcmVxdWlyZSgnLi9faW9iamVjdCcpXG4gICwgJGFzc2lnbiAgPSBPYmplY3QuYXNzaWduO1xuXG4vLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1Zylcbm1vZHVsZS5leHBvcnRzID0gISRhc3NpZ24gfHwgcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbigpe1xuICB2YXIgQSA9IHt9XG4gICAgLCBCID0ge31cbiAgICAsIFMgPSBTeW1ib2woKVxuICAgICwgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gIEFbU10gPSA3O1xuICBLLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGspeyBCW2tdID0gazsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtTXSAhPSA3IHx8IE9iamVjdC5rZXlzKCRhc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBLO1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHZhciBUICAgICA9IHRvT2JqZWN0KHRhcmdldClcbiAgICAsIGFMZW4gID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgaW5kZXggPSAxXG4gICAgLCBnZXRTeW1ib2xzID0gZ09QUy5mXG4gICAgLCBpc0VudW0gICAgID0gcElFLmY7XG4gIHdoaWxlKGFMZW4gPiBpbmRleCl7XG4gICAgdmFyIFMgICAgICA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKVxuICAgICAgLCBrZXlzICAgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpXG4gICAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAsIGogICAgICA9IDBcbiAgICAgICwga2V5O1xuICAgIHdoaWxlKGxlbmd0aCA+IGopaWYoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSlUW2tleV0gPSBTW2tleV07XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjsiLCIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCAgICA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpXG4gICwgZFBzICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHBzJylcbiAgLCBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKVxuICAsIElFX1BST1RPICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpXG4gICwgRW1wdHkgICAgICAgPSBmdW5jdGlvbigpeyAvKiBlbXB0eSAqLyB9XG4gICwgUFJPVE9UWVBFICAgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbigpe1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gcmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdpZnJhbWUnKVxuICAgICwgaSAgICAgID0gZW51bUJ1Z0tleXMubGVuZ3RoXG4gICAgLCBsdCAgICAgPSAnPCdcbiAgICAsIGd0ICAgICA9ICc+J1xuICAgICwgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICByZXF1aXJlKCcuL19odG1sJykuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybFxuICAvLyBjcmVhdGVEaWN0ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuT2JqZWN0O1xuICAvLyBodG1sLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUobHQgKyAnc2NyaXB0JyArIGd0ICsgJ2RvY3VtZW50LkY9T2JqZWN0JyArIGx0ICsgJy9zY3JpcHQnICsgZ3QpO1xuICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICBjcmVhdGVEaWN0ID0gaWZyYW1lRG9jdW1lbnQuRjtcbiAgd2hpbGUoaS0tKWRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dO1xuICByZXR1cm4gY3JlYXRlRGljdCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKXtcbiAgdmFyIHJlc3VsdDtcbiAgaWYoTyAhPT0gbnVsbCl7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IGFuT2JqZWN0KE8pO1xuICAgIHJlc3VsdCA9IG5ldyBFbXB0eTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgICAgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBkUCAgICAgICAgICAgICA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpe1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2goZSl7IC8qIGVtcHR5ICovIH1cbiAgaWYoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKXRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmKCd2YWx1ZScgaW4gQXR0cmlidXRlcylPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59OyIsInZhciBkUCAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGdldEtleXMgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpe1xuICBhbk9iamVjdChPKTtcbiAgdmFyIGtleXMgICA9IGdldEtleXMoUHJvcGVydGllcylcbiAgICAsIGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgUDtcbiAgd2hpbGUobGVuZ3RoID4gaSlkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pO1xuICByZXR1cm4gTztcbn07IiwidmFyIHBJRSAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpXG4gICwgY3JlYXRlRGVzYyAgICAgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJylcbiAgLCB0b0lPYmplY3QgICAgICA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvUHJpbWl0aXZlICAgID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJylcbiAgLCBoYXMgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpXG4gICwgZ09QRCAgICAgICAgICAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QRCA6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKXtcbiAgTyA9IHRvSU9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZihJRThfRE9NX0RFRklORSl0cnkge1xuICAgIHJldHVybiBnT1BEKE8sIFApO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKGhhcyhPLCBQKSlyZXR1cm4gY3JlYXRlRGVzYyghcElFLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59OyIsIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGhpZGRlbktleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJykuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07IiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sczsiLCJ2YXIgaGFzICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCB0b0lPYmplY3QgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKVxuICAsIElFX1BST1RPICAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmplY3QsIG5hbWVzKXtcbiAgdmFyIE8gICAgICA9IHRvSU9iamVjdChvYmplY3QpXG4gICAgLCBpICAgICAgPSAwXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwga2V5O1xuICBmb3Ioa2V5IGluIE8paWYoa2V5ICE9IElFX1BST1RPKWhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUobmFtZXMubGVuZ3RoID4gaSlpZihoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpe1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07IiwiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKXtcbiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07IiwiZXhwb3J0cy5mID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7IiwiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgY29yZSAgICA9IHJlcXVpcmUoJy4vX2NvcmUnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihLRVksIGV4ZWMpe1xuICB2YXIgZm4gID0gKGNvcmUuT2JqZWN0IHx8IHt9KVtLRVldIHx8IE9iamVjdFtLRVldXG4gICAgLCBleHAgPSB7fTtcbiAgZXhwW0tFWV0gPSBleGVjKGZuKTtcbiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbigpeyBmbigxKTsgfSksICdPYmplY3QnLCBleHApO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGJpdG1hcCwgdmFsdWUpe1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGUgIDogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGUgICAgOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlICAgICAgIDogdmFsdWVcbiAgfTtcbn07IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgaGFzICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBTUkMgICAgICAgPSByZXF1aXJlKCcuL191aWQnKSgnc3JjJylcbiAgLCBUT19TVFJJTkcgPSAndG9TdHJpbmcnXG4gICwgJHRvU3RyaW5nID0gRnVuY3Rpb25bVE9fU1RSSU5HXVxuICAsIFRQTCAgICAgICA9ICgnJyArICR0b1N0cmluZykuc3BsaXQoVE9fU1RSSU5HKTtcblxucmVxdWlyZSgnLi9fY29yZScpLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiAkdG9TdHJpbmcuY2FsbChpdCk7XG59O1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihPLCBrZXksIHZhbCwgc2FmZSl7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsICduYW1lJykgfHwgaGlkZSh2YWwsICduYW1lJywga2V5KTtcbiAgaWYoT1trZXldID09PSB2YWwpcmV0dXJuO1xuICBpZihpc0Z1bmN0aW9uKWhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZihPID09PSBnbG9iYWwpe1xuICAgIE9ba2V5XSA9IHZhbDtcbiAgfSBlbHNlIHtcbiAgICBpZighc2FmZSl7XG4gICAgICBkZWxldGUgT1trZXldO1xuICAgICAgaGlkZShPLCBrZXksIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKE9ba2V5XSlPW2tleV0gPSB2YWw7XG4gICAgICBlbHNlIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH1cbiAgfVxuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKXtcbiAgcmV0dXJuIHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgJiYgdGhpc1tTUkNdIHx8ICR0b1N0cmluZy5jYWxsKHRoaXMpO1xufSk7IiwiLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24oTywgcHJvdG8pe1xuICBhbk9iamVjdChPKTtcbiAgaWYoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCl0aHJvdyBUeXBlRXJyb3IocHJvdG8gKyBcIjogY2FuJ3Qgc2V0IGFzIHByb3RvdHlwZSFcIik7XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBmdW5jdGlvbih0ZXN0LCBidWdneSwgc2V0KXtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoKGUpeyBidWdneSA9IHRydWU7IH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90byl7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYoYnVnZ3kpTy5fX3Byb3RvX18gPSBwcm90bztcbiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pO1xuICAgICAgICByZXR1cm4gTztcbiAgICAgIH07XG4gICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSxcbiAgY2hlY2s6IGNoZWNrXG59OyIsInZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgna2V5cycpXG4gICwgdWlkICAgID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7XG59OyIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nXG4gICwgc3RvcmUgID0gZ2xvYmFsW1NIQVJFRF0gfHwgKGdsb2JhbFtTSEFSRURdID0ge30pO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07IiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIGFyZyl7XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbigpe1xuICAgIGFyZyA/IG1ldGhvZC5jYWxsKG51bGwsIGZ1bmN0aW9uKCl7fSwgMSkgOiBtZXRob2QuY2FsbChudWxsKTtcbiAgfSk7XG59OyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpXG4gICwgZmFpbHMgICA9IHJlcXVpcmUoJy4vX2ZhaWxzJylcbiAgLCBzcGFjZXMgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXdzJylcbiAgLCBzcGFjZSAgID0gJ1snICsgc3BhY2VzICsgJ10nXG4gICwgbm9uICAgICA9ICdcXHUyMDBiXFx1MDA4NSdcbiAgLCBsdHJpbSAgID0gUmVnRXhwKCdeJyArIHNwYWNlICsgc3BhY2UgKyAnKicpXG4gICwgcnRyaW0gICA9IFJlZ0V4cChzcGFjZSArIHNwYWNlICsgJyokJyk7XG5cbnZhciBleHBvcnRlciA9IGZ1bmN0aW9uKEtFWSwgZXhlYywgQUxJQVMpe1xuICB2YXIgZXhwICAgPSB7fTtcbiAgdmFyIEZPUkNFID0gZmFpbHMoZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gISFzcGFjZXNbS0VZXSgpIHx8IG5vbltLRVldKCkgIT0gbm9uO1xuICB9KTtcbiAgdmFyIGZuID0gZXhwW0tFWV0gPSBGT1JDRSA/IGV4ZWModHJpbSkgOiBzcGFjZXNbS0VZXTtcbiAgaWYoQUxJQVMpZXhwW0FMSUFTXSA9IGZuO1xuICAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIEZPUkNFLCAnU3RyaW5nJywgZXhwKTtcbn07XG5cbi8vIDEgLT4gU3RyaW5nI3RyaW1MZWZ0XG4vLyAyIC0+IFN0cmluZyN0cmltUmlnaHRcbi8vIDMgLT4gU3RyaW5nI3RyaW1cbnZhciB0cmltID0gZXhwb3J0ZXIudHJpbSA9IGZ1bmN0aW9uKHN0cmluZywgVFlQRSl7XG4gIHN0cmluZyA9IFN0cmluZyhkZWZpbmVkKHN0cmluZykpO1xuICBpZihUWVBFICYgMSlzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShsdHJpbSwgJycpO1xuICBpZihUWVBFICYgMilzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShydHJpbSwgJycpO1xuICByZXR1cm4gc3RyaW5nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRlcjsiLCJtb2R1bGUuZXhwb3J0cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7IiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKVxuICAsIG1heCAgICAgICA9IE1hdGgubWF4XG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGluZGV4LCBsZW5ndGgpe1xuICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbmRleCA8IDAgPyBtYXgoaW5kZXggKyBsZW5ndGgsIDApIDogbWluKGluZGV4LCBsZW5ndGgpO1xufTsiLCIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07IiwiLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSU9iamVjdCA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIElPYmplY3QoZGVmaW5lZChpdCkpO1xufTsiLCIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtaW4gICAgICAgPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTsiLCIvLyA3LjEuMTMgVG9PYmplY3QoYXJndW1lbnQpXG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwgUyl7XG4gIGlmKCFpc09iamVjdChpdCkpcmV0dXJuIGl0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZih0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIGlmKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKXJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07IiwidmFyIGlkID0gMFxuICAsIHB4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07IiwidmFyIHN0b3JlICAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnd2tzJylcbiAgLCB1aWQgICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJylcbiAgLCBTeW1ib2wgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuU3ltYm9sXG4gICwgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHN0b3JlW25hbWVdIHx8IChzdG9yZVtuYW1lXSA9XG4gICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTtcbn07XG5cbiRleHBvcnRzLnN0b3JlID0gc3RvcmU7IiwiJ3VzZSBzdHJpY3QnO1xuLy8gMjIuMS4zLjggQXJyYXkucHJvdG90eXBlLmZpbmQocHJlZGljYXRlLCB0aGlzQXJnID0gdW5kZWZpbmVkKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmaW5kICAgPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoNSlcbiAgLCBLRVkgICAgID0gJ2ZpbmQnXG4gICwgZm9yY2VkICA9IHRydWU7XG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYoS0VZIGluIFtdKUFycmF5KDEpW0tFWV0oZnVuY3Rpb24oKXsgZm9yY2VkID0gZmFsc2U7IH0pO1xuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBmb3JjZWQsICdBcnJheScsIHtcbiAgZmluZDogZnVuY3Rpb24gZmluZChjYWxsYmFja2ZuLyosIHRoYXQgPSB1bmRlZmluZWQgKi8pe1xuICAgIHJldHVybiAkZmluZCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xucmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJykoS0VZKTsiLCIndXNlIHN0cmljdCc7XG52YXIgJGV4cG9ydCAgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRmb3JFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXktbWV0aG9kcycpKDApXG4gICwgU1RSSUNUICAgPSByZXF1aXJlKCcuL19zdHJpY3QtbWV0aG9kJykoW10uZm9yRWFjaCwgdHJ1ZSk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIVNUUklDVCwgJ0FycmF5Jywge1xuICAvLyAyMi4xLjMuMTAgLyAxNS40LjQuMTggQXJyYXkucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiBbLCB0aGlzQXJnXSlcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLyl7XG4gICAgcmV0dXJuICRmb3JFYWNoKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c1sxXSk7XG4gIH1cbn0pOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0JylcbiAgLCAkcmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXktcmVkdWNlJyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5yZWR1Y2UsIHRydWUpLCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xOCAvIDE1LjQuNC4yMSBBcnJheS5wcm90b3R5cGUucmVkdWNlKGNhbGxiYWNrZm4gWywgaW5pdGlhbFZhbHVlXSlcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLyl7XG4gICAgcmV0dXJuICRyZWR1Y2UodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzWzFdLCBmYWxzZSk7XG4gIH1cbn0pOyIsIi8vIDE5LjIuMy4yIC8gMTUuMy40LjUgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQodGhpc0FyZywgYXJncy4uLilcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5QLCAnRnVuY3Rpb24nLCB7YmluZDogcmVxdWlyZSgnLi9fYmluZCcpfSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBoYXMgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgY29mICAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19jb2YnKVxuICAsIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi9faW5oZXJpdC1pZi1yZXF1aXJlZCcpXG4gICwgdG9QcmltaXRpdmUgICAgICAgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKVxuICAsIGZhaWxzICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKVxuICAsIGdPUE4gICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mXG4gICwgZ09QRCAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmZcbiAgLCBkUCAgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZcbiAgLCAkdHJpbSAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX3N0cmluZy10cmltJykudHJpbVxuICAsIE5VTUJFUiAgICAgICAgICAgID0gJ051bWJlcidcbiAgLCAkTnVtYmVyICAgICAgICAgICA9IGdsb2JhbFtOVU1CRVJdXG4gICwgQmFzZSAgICAgICAgICAgICAgPSAkTnVtYmVyXG4gICwgcHJvdG8gICAgICAgICAgICAgPSAkTnVtYmVyLnByb3RvdHlwZVxuICAvLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbiAgLCBCUk9LRU5fQ09GICAgICAgICA9IGNvZihyZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJykocHJvdG8pKSA9PSBOVU1CRVJcbiAgLCBUUklNICAgICAgICAgICAgICA9ICd0cmltJyBpbiBTdHJpbmcucHJvdG90eXBlO1xuXG4vLyA3LjEuMyBUb051bWJlcihhcmd1bWVudClcbnZhciB0b051bWJlciA9IGZ1bmN0aW9uKGFyZ3VtZW50KXtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgaWYodHlwZW9mIGl0ID09ICdzdHJpbmcnICYmIGl0Lmxlbmd0aCA+IDIpe1xuICAgIGl0ID0gVFJJTSA/IGl0LnRyaW0oKSA6ICR0cmltKGl0LCAzKTtcbiAgICB2YXIgZmlyc3QgPSBpdC5jaGFyQ29kZUF0KDApXG4gICAgICAsIHRoaXJkLCByYWRpeCwgbWF4Q29kZTtcbiAgICBpZihmaXJzdCA9PT0gNDMgfHwgZmlyc3QgPT09IDQ1KXtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmKHRoaXJkID09PSA4OCB8fCB0aGlyZCA9PT0gMTIwKXJldHVybiBOYU47IC8vIE51bWJlcignKzB4MScpIHNob3VsZCBiZSBOYU4sIG9sZCBWOCBmaXhcbiAgICB9IGVsc2UgaWYoZmlyc3QgPT09IDQ4KXtcbiAgICAgIHN3aXRjaChpdC5jaGFyQ29kZUF0KDEpKXtcbiAgICAgICAgY2FzZSA2NiA6IGNhc2UgOTggIDogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5IDogY2FzZSAxMTEgOiByYWRpeCA9IDg7IG1heENvZGUgPSA1NTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wb1swLTddKyQvaVxuICAgICAgICBkZWZhdWx0IDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGZvcih2YXIgZGlnaXRzID0gaXQuc2xpY2UoMiksIGkgPSAwLCBsID0gZGlnaXRzLmxlbmd0aCwgY29kZTsgaSA8IGw7IGkrKyl7XG4gICAgICAgIGNvZGUgPSBkaWdpdHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgLy8gcGFyc2VJbnQgcGFyc2VzIGEgc3RyaW5nIHRvIGEgZmlyc3QgdW5hdmFpbGFibGUgc3ltYm9sXG4gICAgICAgIC8vIGJ1dCBUb051bWJlciBzaG91bGQgcmV0dXJuIE5hTiBpZiBhIHN0cmluZyBjb250YWlucyB1bmF2YWlsYWJsZSBzeW1ib2xzXG4gICAgICAgIGlmKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSlyZXR1cm4gTmFOO1xuICAgICAgfSByZXR1cm4gcGFyc2VJbnQoZGlnaXRzLCByYWRpeCk7XG4gICAgfVxuICB9IHJldHVybiAraXQ7XG59O1xuXG5pZighJE51bWJlcignIDBvMScpIHx8ICEkTnVtYmVyKCcwYjEnKSB8fCAkTnVtYmVyKCcrMHgxJykpe1xuICAkTnVtYmVyID0gZnVuY3Rpb24gTnVtYmVyKHZhbHVlKXtcbiAgICB2YXIgaXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMSA/IDAgOiB2YWx1ZVxuICAgICAgLCB0aGF0ID0gdGhpcztcbiAgICByZXR1cm4gdGhhdCBpbnN0YW5jZW9mICROdW1iZXJcbiAgICAgIC8vIGNoZWNrIG9uIDEuLmNvbnN0cnVjdG9yKGZvbykgY2FzZVxuICAgICAgJiYgKEJST0tFTl9DT0YgPyBmYWlscyhmdW5jdGlvbigpeyBwcm90by52YWx1ZU9mLmNhbGwodGhhdCk7IH0pIDogY29mKHRoYXQpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgQmFzZSh0b051bWJlcihpdCkpLCB0aGF0LCAkTnVtYmVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yKHZhciBrZXlzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUE4oQmFzZSkgOiAoXG4gICAgLy8gRVMzOlxuICAgICdNQVhfVkFMVUUsTUlOX1ZBTFVFLE5hTixORUdBVElWRV9JTkZJTklUWSxQT1NJVElWRV9JTkZJTklUWSwnICtcbiAgICAvLyBFUzYgKGluIGNhc2UsIGlmIG1vZHVsZXMgd2l0aCBFUzYgTnVtYmVyIHN0YXRpY3MgcmVxdWlyZWQgYmVmb3JlKTpcbiAgICAnRVBTSUxPTixpc0Zpbml0ZSxpc0ludGVnZXIsaXNOYU4saXNTYWZlSW50ZWdlcixNQVhfU0FGRV9JTlRFR0VSLCcgK1xuICAgICdNSU5fU0FGRV9JTlRFR0VSLHBhcnNlRmxvYXQscGFyc2VJbnQsaXNJbnRlZ2VyJ1xuICApLnNwbGl0KCcsJyksIGogPSAwLCBrZXk7IGtleXMubGVuZ3RoID4gajsgaisrKXtcbiAgICBpZihoYXMoQmFzZSwga2V5ID0ga2V5c1tqXSkgJiYgIWhhcygkTnVtYmVyLCBrZXkpKXtcbiAgICAgIGRQKCROdW1iZXIsIGtleSwgZ09QRChCYXNlLCBrZXkpKTtcbiAgICB9XG4gIH1cbiAgJE51bWJlci5wcm90b3R5cGUgPSBwcm90bztcbiAgcHJvdG8uY29uc3RydWN0b3IgPSAkTnVtYmVyO1xuICByZXF1aXJlKCcuL19yZWRlZmluZScpKGdsb2JhbCwgTlVNQkVSLCAkTnVtYmVyKTtcbn0iLCIvLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7YXNzaWduOiByZXF1aXJlKCcuL19vYmplY3QtYXNzaWduJyl9KTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuLy8gMTkuMS4yLjQgLyAxNS4yLjMuNiBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcylcbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIXJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJyksICdPYmplY3QnLCB7ZGVmaW5lUHJvcGVydHk6IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmZ9KTsiLCIvLyAxOS4xLjIuMTQgT2JqZWN0LmtleXMoTylcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpXG4gICwgJGtleXMgICAgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2tleXMnLCBmdW5jdGlvbigpe1xuICByZXR1cm4gZnVuY3Rpb24ga2V5cyhpdCl7XG4gICAgcmV0dXJuICRrZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTsiLCIndXNlIHN0cmljdCc7XG5cbi8vIDwzIE1vZGVybml6clxuLy8gaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL01vZGVybml6ci9Nb2Rlcm5penIvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9kb20vZGF0YXNldC5qc1xuXG5mdW5jdGlvbiB1c2VOYXRpdmUoKSB7XG5cdHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdGVsZW0uc2V0QXR0cmlidXRlKCdkYXRhLWEtYicsICdjJyk7XG5cblx0cmV0dXJuIEJvb2xlYW4oZWxlbS5kYXRhc2V0ICYmIGVsZW0uZGF0YXNldC5hQiA9PT0gJ2MnKTtcbn1cblxuZnVuY3Rpb24gbmF0aXZlRGF0YXNldChlbGVtZW50KSB7XG5cdHJldHVybiBlbGVtZW50LmRhdGFzZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdXNlTmF0aXZlKCkgPyBuYXRpdmVEYXRhc2V0IDogZnVuY3Rpb24gKGVsZW1lbnQpIHtcblx0dmFyIG1hcCA9IHt9O1xuXHR2YXIgYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcztcblxuXHRmdW5jdGlvbiBnZXR0ZXIoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXR0ZXIobmFtZSwgdmFsdWUpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKHZhciBpID0gMCwgaiA9IGF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG5cdFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG5cblx0XHRpZiAoYXR0cmlidXRlKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGF0dHJpYnV0ZS5uYW1lO1xuXG5cdFx0XHRpZiAobmFtZS5pbmRleE9mKCdkYXRhLScpID09PSAwKSB7XG5cdFx0XHRcdHZhciBwcm9wID0gbmFtZS5zbGljZSg1KS5yZXBsYWNlKC8tLi9nLCBmdW5jdGlvbiAodSkge1xuXHRcdFx0XHRcdHJldHVybiB1LmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHR2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWU7XG5cblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcCwgcHJvcCwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Z2V0OiBnZXR0ZXIuYmluZCh7IHZhbHVlOiB2YWx1ZSB8fCAnJyB9KSxcblx0XHRcdFx0XHRzZXQ6IHNldHRlci5iaW5kKGVsZW1lbnQsIG5hbWUpXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXA7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBcnJheWlzaChvYmopIHtcblx0aWYgKCFvYmogfHwgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXkgfHwgQXJyYXkuaXNBcnJheShvYmopIHx8XG5cdFx0KG9iai5sZW5ndGggPj0gMCAmJiAob2JqLnNwbGljZSBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XG5cdFx0XHQoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIChvYmoubGVuZ3RoIC0gMSkpICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnU3RyaW5nJykpKTtcbn07XG4iLCIvKiBlc2xpbnQgbm8tY29uc29sZTowICovXG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIEthVGVYLiBIZXJlLCB3ZSBleHBvc2UgZnVuY3Rpb25zIGZvclxuICogcmVuZGVyaW5nIGV4cHJlc3Npb25zIGVpdGhlciB0byBET00gbm9kZXMgb3IgdG8gbWFya3VwIHN0cmluZ3MuXG4gKlxuICogV2UgYWxzbyBleHBvc2UgdGhlIFBhcnNlRXJyb3IgY2xhc3MgdG8gY2hlY2sgaWYgZXJyb3JzIHRocm93biBmcm9tIEthVGVYIGFyZVxuICogZXJyb3JzIGluIHRoZSBleHByZXNzaW9uLCBvciBlcnJvcnMgaW4gamF2YXNjcmlwdCBoYW5kbGluZy5cbiAqL1xuXG52YXIgUGFyc2VFcnJvciA9IHJlcXVpcmUoXCIuL3NyYy9QYXJzZUVycm9yXCIpO1xudmFyIFNldHRpbmdzID0gcmVxdWlyZShcIi4vc3JjL1NldHRpbmdzXCIpO1xuXG52YXIgYnVpbGRUcmVlID0gcmVxdWlyZShcIi4vc3JjL2J1aWxkVHJlZVwiKTtcbnZhciBwYXJzZVRyZWUgPSByZXF1aXJlKFwiLi9zcmMvcGFyc2VUcmVlXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vc3JjL3V0aWxzXCIpO1xuXG4vKipcbiAqIFBhcnNlIGFuZCBidWlsZCBhbiBleHByZXNzaW9uLCBhbmQgcGxhY2UgdGhhdCBleHByZXNzaW9uIGluIHRoZSBET00gbm9kZVxuICogZ2l2ZW4uXG4gKi9cbnZhciByZW5kZXIgPSBmdW5jdGlvbihleHByZXNzaW9uLCBiYXNlTm9kZSwgb3B0aW9ucykge1xuICAgIHV0aWxzLmNsZWFyTm9kZShiYXNlTm9kZSk7XG5cbiAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3Mob3B0aW9ucyk7XG5cbiAgICB2YXIgdHJlZSA9IHBhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gICAgdmFyIG5vZGUgPSBidWlsZFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpLnRvTm9kZSgpO1xuXG4gICAgYmFzZU5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG59O1xuXG4vLyBLYVRlWCdzIHN0eWxlcyBkb24ndCB3b3JrIHByb3Blcmx5IGluIHF1aXJrcyBtb2RlLiBQcmludCBvdXQgYW4gZXJyb3IsIGFuZFxuLy8gZGlzYWJsZSByZW5kZXJpbmcuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKGRvY3VtZW50LmNvbXBhdE1vZGUgIT09IFwiQ1NTMUNvbXBhdFwiKSB7XG4gICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiV2FybmluZzogS2FUZVggZG9lc24ndCB3b3JrIGluIHF1aXJrcyBtb2RlLiBNYWtlIHN1cmUgeW91ciBcIiArXG4gICAgICAgICAgICAgICAgXCJ3ZWJzaXRlIGhhcyBhIHN1aXRhYmxlIGRvY3R5cGUuXCIpO1xuXG4gICAgICAgIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJLYVRlWCBkb2Vzbid0IHdvcmsgaW4gcXVpcmtzIG1vZGUuXCIpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbmQgYnVpbGQgYW4gZXhwcmVzc2lvbiwgYW5kIHJldHVybiB0aGUgbWFya3VwIGZvciB0aGF0LlxuICovXG52YXIgcmVuZGVyVG9TdHJpbmcgPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpO1xuXG4gICAgdmFyIHRyZWUgPSBwYXJzZVRyZWUoZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICAgIHJldHVybiBidWlsZFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpLnRvTWFya3VwKCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gYW5kIHJldHVybiB0aGUgcGFyc2UgdHJlZS5cbiAqL1xudmFyIGdlbmVyYXRlUGFyc2VUcmVlID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhvcHRpb25zKTtcbiAgICByZXR1cm4gcGFyc2VUcmVlKGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlbmRlcjogcmVuZGVyLFxuICAgIHJlbmRlclRvU3RyaW5nOiByZW5kZXJUb1N0cmluZyxcbiAgICAvKipcbiAgICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgICAqIFRoZSBpbnRlcm5hbCB0cmVlIHJlcHJlc2VudGF0aW9uIGlzIHVuc3RhYmxlIGFuZCBpcyB2ZXJ5IGxpa2VseVxuICAgICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAgICovXG4gICAgX19wYXJzZTogZ2VuZXJhdGVQYXJzZVRyZWUsXG4gICAgUGFyc2VFcnJvcjogUGFyc2VFcnJvclxufTtcbiIsIi8qKlxuICogVGhlIExleGVyIGNsYXNzIGhhbmRsZXMgdG9rZW5pemluZyB0aGUgaW5wdXQgaW4gdmFyaW91cyB3YXlzLiBTaW5jZSBvdXJcbiAqIHBhcnNlciBleHBlY3RzIHVzIHRvIGJlIGFibGUgdG8gYmFja3RyYWNrLCB0aGUgbGV4ZXIgYWxsb3dzIGxleGluZyBmcm9tIGFueVxuICogZ2l2ZW4gc3RhcnRpbmcgcG9pbnQuXG4gKlxuICogSXRzIG1haW4gZXhwb3NlZCBmdW5jdGlvbiBpcyB0aGUgYGxleGAgZnVuY3Rpb24sIHdoaWNoIHRha2VzIGEgcG9zaXRpb24gdG9cbiAqIGxleCBmcm9tIGFuZCBhIHR5cGUgb2YgdG9rZW4gdG8gbGV4LiBJdCBkZWZlcnMgdG8gdGhlIGFwcHJvcHJpYXRlIGBfaW5uZXJMZXhgXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgdmFyaW91cyBgX2lubmVyTGV4YCBmdW5jdGlvbnMgcGVyZm9ybSB0aGUgYWN0dWFsIGxleGluZyBvZiBkaWZmZXJlbnRcbiAqIGtpbmRzLlxuICovXG5cbnZhciBtYXRjaEF0ID0gcmVxdWlyZShcIm1hdGNoLWF0XCIpO1xuXG52YXIgUGFyc2VFcnJvciA9IHJlcXVpcmUoXCIuL1BhcnNlRXJyb3JcIik7XG5cbi8vIFRoZSBtYWluIGxleGVyIGNsYXNzXG5mdW5jdGlvbiBMZXhlcihpbnB1dCkge1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLnBvcyA9IDA7XG59XG5cbi8qKlxuICogVGhlIHJlc3VsdGluZyB0b2tlbiByZXR1cm5lZCBmcm9tIGBsZXhgLlxuICpcbiAqIEl0IGNvbnNpc3RzIG9mIHRoZSB0b2tlbiB0ZXh0IHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqIFRoZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpcyBlc3NlbnRpYWxseSBhIHJhbmdlIGluIGFuIGlucHV0IHN0cmluZyxcbiAqIGJ1dCBpbnN0ZWFkIG9mIHJlZmVyZW5jaW5nIHRoZSBiYXJlIGlucHV0IHN0cmluZywgd2UgcmVmZXIgdG8gdGhlIGxleGVyLlxuICogVGhhdCB3YXkgaXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGV4dHJhIG1ldGFkYXRhIHRvIHRoZSBpbnB1dCBzdHJpbmcsXG4gKiBsaWtlIGZvciBleGFtcGxlIGEgZmlsZSBuYW1lIG9yIHNpbWlsYXIuXG4gKlxuICogVGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIChhbGwgdGhyZWUgcGFyYW1ldGVycykgaXMgb3B0aW9uYWwsXG4gKiBzbyBpdCBpcyBPSyB0byBjb25zdHJ1Y3Qgc3ludGhldGljIHRva2VucyBpZiBhcHByb3ByaWF0ZS5cbiAqIE5vdCBwcm92aWRpbmcgYXZhaWxhYmxlIHBvc2l0aW9uIGluZm9ybWF0aW9uIG1heSBsZWFkIHRvXG4gKiBkZWdyYWRlZCBlcnJvciByZXBvcnRpbmcsIHRob3VnaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gIHRleHQgICB0aGUgdGV4dCBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0ge251bWJlcj19IHN0YXJ0ICB0aGUgc3RhcnQgb2Zmc2V0LCB6ZXJvLWJhc2VkIGluY2x1c2l2ZVxuICogQHBhcmFtIHtudW1iZXI9fSBlbmQgICAgdGhlIGVuZCBvZmZzZXQsIHplcm8tYmFzZWQgZXhjbHVzaXZlXG4gKiBAcGFyYW0ge0xleGVyPX0gIGxleGVyICB0aGUgbGV4ZXIgd2hpY2ggaW4gdHVybiBob2xkcyB0aGUgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIFRva2VuKHRleHQsIHN0YXJ0LCBlbmQsIGxleGVyKSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgdGhpcy5sZXhlciA9IGxleGVyO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgcGFpciBvZiB0b2tlbnMgKHRoaXMgYW5kIGVuZFRva2VuKSwgY29tcHV0ZSBhIOKAnFRva2Vu4oCdIGVuY29tcGFzc2luZ1xuICogdGhlIHdob2xlIGlucHV0IHJhbmdlIGVuY2xvc2VkIGJ5IHRoZXNlIHR3by5cbiAqXG4gKiBAcGFyYW0ge1Rva2VufSAgZW5kVG9rZW4gIGxhc3QgdG9rZW4gb2YgdGhlIHJhbmdlLCBpbmNsdXNpdmVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICAgICAgdGhlIHRleHQgb2YgdGhlIG5ld2x5IGNvbnN0cnVjdGVkIHRva2VuXG4gKi9cblRva2VuLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uKGVuZFRva2VuLCB0ZXh0KSB7XG4gICAgaWYgKGVuZFRva2VuLmxleGVyICE9PSB0aGlzLmxleGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW4odGV4dCk7IC8vIHNvcnJ5LCBubyBwb3NpdGlvbiBpbmZvcm1hdGlvbiBhdmFpbGFibGVcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUb2tlbih0ZXh0LCB0aGlzLnN0YXJ0LCBlbmRUb2tlbi5lbmQsIHRoaXMubGV4ZXIpO1xufTtcblxuLyogVGhlIGZvbGxvd2luZyB0b2tlblJlZ2V4XG4gKiAtIG1hdGNoZXMgdHlwaWNhbCB3aGl0ZXNwYWNlIChidXQgbm90IE5CU1AgZXRjLikgdXNpbmcgaXRzIGZpcnN0IGdyb3VwXG4gKiAtIGRvZXMgbm90IG1hdGNoIGFueSBjb250cm9sIGNoYXJhY3RlciBcXHgwMC1cXHgxZiBleGNlcHQgd2hpdGVzcGFjZVxuICogLSBkb2VzIG5vdCBtYXRjaCBhIGJhcmUgYmFja3NsYXNoXG4gKiAtIG1hdGNoZXMgYW55IEFTQ0lJIGNoYXJhY3RlciBleGNlcHQgdGhvc2UganVzdCBtZW50aW9uZWRcbiAqIC0gZG9lcyBub3QgbWF0Y2ggdGhlIEJNUCBwcml2YXRlIHVzZSBhcmVhIFxcdUUwMDAtXFx1RjhGRlxuICogLSBkb2VzIG5vdCBtYXRjaCBiYXJlIHN1cnJvZ2F0ZSBjb2RlIHVuaXRzXG4gKiAtIG1hdGNoZXMgYW55IEJNUCBjaGFyYWN0ZXIgZXhjZXB0IGZvciB0aG9zZSBqdXN0IGRlc2NyaWJlZFxuICogLSBtYXRjaGVzIGFueSB2YWxpZCBVbmljb2RlIHN1cnJvZ2F0ZSBwYWlyXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgbGV0dGVyc1xuICogLSBtYXRjaGVzIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IGFueSBCTVAgY2hhcmFjdGVyLCBpbmNsdWRpbmcgbmV3bGluZVxuICogSnVzdCBiZWNhdXNlIHRoZSBMZXhlciBtYXRjaGVzIHNvbWV0aGluZyBkb2Vzbid0IG1lYW4gaXQncyB2YWxpZCBpbnB1dDpcbiAqIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIGZ1bmN0aW9uIG9yIHN5bWJvbCBkZWZpbml0aW9uLCB0aGUgUGFyc2VyIHdpbGxcbiAqIHN0aWxsIHJlamVjdCB0aGUgaW5wdXQuXG4gKi9cbnZhciB0b2tlblJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICBcIihbIFxcclxcblxcdF0rKXxcIiArICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpdGVzcGFjZVxuICAgIFwiKFshLVxcXFxbXFxcXF0tXFx1MjAyN1xcdTIwMkEtXFx1RDdGRlxcdUY5MDAtXFx1RkZGRl1cIiArICAvLyBzaW5nbGUgY29kZXBvaW50XG4gICAgXCJ8W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXVwiICsgICAgICAgICAgICAgICAvLyBzdXJyb2dhdGUgcGFpclxuICAgIFwifFxcXFxcXFxcKD86W2EtekEtWl0rfFteXFx1RDgwMC1cXHVERkZGXSlcIiArICAgICAgICAgICAvLyBmdW5jdGlvbiBuYW1lXG4gICAgXCIpXCJcbik7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBsZXhlcyBhIHNpbmdsZSB0b2tlbi5cbiAqL1xuTGV4ZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICAgIGlmIChwb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuKFwiRU9GXCIsIHBvcywgcG9zLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gbWF0Y2hBdCh0b2tlblJlZ2V4LCBpbnB1dCwgcG9zKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAnXCIgKyBpbnB1dFtwb3NdICsgXCInXCIsXG4gICAgICAgICAgICBuZXcgVG9rZW4oaW5wdXRbcG9zXSwgcG9zLCBwb3MgKyAxLCB0aGlzKSk7XG4gICAgfVxuICAgIHZhciB0ZXh0ID0gbWF0Y2hbMl0gfHwgXCIgXCI7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIHZhciBlbmQgPSB0aGlzLnBvcztcbiAgICByZXR1cm4gbmV3IFRva2VuKHRleHQsIHN0YXJ0LCBlbmQsIHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZXhlcjtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSDigJxndWxsZXTigJ0gd2hlcmUgbWFjcm9zIGFyZSBleHBhbmRlZFxuICogdW50aWwgb25seSBub24tbWFjcm8gdG9rZW5zIHJlbWFpbi5cbiAqL1xuXG52YXIgTGV4ZXIgPSByZXF1aXJlKFwiLi9MZXhlclwiKTtcblxuZnVuY3Rpb24gTWFjcm9FeHBhbmRlcihpbnB1dCwgbWFjcm9zKSB7XG4gICAgdGhpcy5sZXhlciA9IG5ldyBMZXhlcihpbnB1dCk7XG4gICAgdGhpcy5tYWNyb3MgPSBtYWNyb3M7XG4gICAgdGhpcy5zdGFjayA9IFtdOyAvLyBjb250YWlucyB0b2tlbnMgaW4gUkVWRVJTRSBvcmRlclxuICAgIHRoaXMuZGlzY2FyZGVkV2hpdGVTcGFjZSA9IFtdO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGV4cGFuZCBmaXJzdCB0b2tlbiwgdGhlbiByZXR1cm4gZmlyc3Qgbm9uLWV4cGFuZGFibGUgdG9rZW4uXG4gKi9cbk1hY3JvRXhwYW5kZXIucHJvdG90eXBlLm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5sZXhlci5sZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvcFRva2VuID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0b3BUb2tlbi50ZXh0O1xuICAgICAgICBpZiAoIShuYW1lLmNoYXJBdCgwKSA9PT0gXCJcXFxcXCIgJiYgdGhpcy5tYWNyb3MuaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9wVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IHRoaXMubWFjcm9zW25hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIGV4cGFuc2lvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGJvZHlMZXhlciA9IG5ldyBMZXhlcihleHBhbnNpb24pO1xuICAgICAgICAgICAgZXhwYW5zaW9uID0gW107XG4gICAgICAgICAgICB2YXIgdG9rID0gYm9keUxleGVyLmxleCgpO1xuICAgICAgICAgICAgd2hpbGUgKHRvay50ZXh0ICE9PSBcIkVPRlwiKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5zaW9uLnB1c2godG9rKTtcbiAgICAgICAgICAgICAgICB0b2sgPSBib2R5TGV4ZXIubGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBhbnNpb24ucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayB1c2luZyBwdXNoIGFuZCBwb3BcbiAgICAgICAgICAgIHRoaXMubWFjcm9zW25hbWVdID0gZXhwYW5zaW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLmNvbmNhdChleHBhbnNpb24pO1xuICAgIH1cbn07XG5cbk1hY3JvRXhwYW5kZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGlnbm9yZVNwYWNlKSB7XG4gICAgdGhpcy5kaXNjYXJkZWRXaGl0ZVNwYWNlID0gW107XG4gICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICBpZiAoaWdub3JlU3BhY2UpIHtcbiAgICAgICAgd2hpbGUgKHRva2VuLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2NhcmRlZFdoaXRlU3BhY2UucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2VuO1xufTtcblxuLyoqXG4gKiBVbmRvIHRoZSBlZmZlY3Qgb2YgdGhlIHByZWNlZGluZyBjYWxsIHRvIHRoZSBnZXQgbWV0aG9kLlxuICogQSBjYWxsIHRvIHRoaXMgbWV0aG9kIE1VU1QgYmUgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYW5kIGltbWVkaWF0ZWx5IGZvbGxvd2VkXG4gKiBieSBhIGNhbGwgdG8gZ2V0LiAgT25seSB1c2VkIGR1cmluZyBtb2RlIHN3aXRjaGluZywgaS5lLiBhZnRlciBvbmUgdG9rZW5cbiAqIHdhcyBnb3QgaW4gdGhlIG9sZCBtb2RlIGJ1dCBzaG91bGQgZ2V0IGdvdCBhZ2FpbiBpbiBhIG5ldyBtb2RlXG4gKiB3aXRoIHBvc3NpYmx5IGRpZmZlcmVudCB3aGl0ZXNwYWNlIGhhbmRsaW5nLlxuICovXG5NYWNyb0V4cGFuZGVyLnByb3RvdHlwZS51bmdldCA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHRva2VuKTtcbiAgICB3aGlsZSAodGhpcy5kaXNjYXJkZWRXaGl0ZVNwYWNlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5kaXNjYXJkZWRXaGl0ZVNwYWNlLnBvcCgpKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hY3JvRXhwYW5kZXI7XG4iLCIvKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3B0aW9ucyB0aGF0IHRoZSBQYXJzZXIgY2Fycmllc1xuICogYXJvdW5kIHdpdGggaXQgd2hpbGUgcGFyc2luZy4gRGF0YSBpcyBoZWxkIGluIGFuIGBPcHRpb25zYCBvYmplY3QsIGFuZCB3aGVuXG4gKiByZWN1cnNpbmcsIGEgbmV3IGBPcHRpb25zYCBvYmplY3QgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGUgYC53aXRoKmAgYW5kXG4gKiBgLnJlc2V0YCBmdW5jdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIG9wdGlvbnMgY2xhc3MuIEl0IGNvbnRhaW5zIHRoZSBzdHlsZSwgc2l6ZSwgY29sb3IsIGFuZCBmb250XG4gKiBvZiB0aGUgY3VycmVudCBwYXJzZSBsZXZlbC4gSXQgYWxzbyBjb250YWlucyB0aGUgc3R5bGUgYW5kIHNpemUgb2YgdGhlIHBhcmVudFxuICogcGFyc2UgbGV2ZWwsIHNvIHNpemUgY2hhbmdlcyBjYW4gYmUgaGFuZGxlZCBlZmZpY2llbnRseS5cbiAqXG4gKiBFYWNoIG9mIHRoZSBgLndpdGgqYCBhbmQgYC5yZXNldGAgZnVuY3Rpb25zIHBhc3NlcyBpdHMgY3VycmVudCBzdHlsZSBhbmQgc2l6ZVxuICogYXMgdGhlIHBhcmVudFN0eWxlIGFuZCBwYXJlbnRTaXplIG9mIHRoZSBuZXcgb3B0aW9ucyBjbGFzcywgc28gcGFyZW50XG4gKiBoYW5kbGluZyBpcyB0YWtlbiBjYXJlIG9mIGF1dG9tYXRpY2FsbHkuXG4gKi9cbmZ1bmN0aW9uIE9wdGlvbnMoZGF0YSkge1xuICAgIHRoaXMuc3R5bGUgPSBkYXRhLnN0eWxlO1xuICAgIHRoaXMuY29sb3IgPSBkYXRhLmNvbG9yO1xuICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB0aGlzLnBoYW50b20gPSBkYXRhLnBoYW50b207XG4gICAgdGhpcy5mb250ID0gZGF0YS5mb250O1xuXG4gICAgaWYgKGRhdGEucGFyZW50U3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBhcmVudFN0eWxlID0gZGF0YS5zdHlsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudFN0eWxlID0gZGF0YS5wYXJlbnRTdHlsZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5wYXJlbnRTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRTaXplID0gZGF0YS5zaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50U2l6ZSA9IGRhdGEucGFyZW50U2l6ZTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgXCJ0aGlzXCIuICBQcm9wZXJ0aWVzXG4gKiBmcm9tIFwiZXh0ZW5zaW9uXCIgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBvcHRpb25zIG9iamVjdC5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24oZXh0ZW5zaW9uKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLFxuICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBwYXJlbnRTdHlsZTogdGhpcy5zdHlsZSxcbiAgICAgICAgcGFyZW50U2l6ZTogdGhpcy5zaXplLFxuICAgICAgICBwaGFudG9tOiB0aGlzLnBoYW50b20sXG4gICAgICAgIGZvbnQ6IHRoaXMuZm9udFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZXh0ZW5zaW9uKSB7XG4gICAgICAgIGlmIChleHRlbnNpb24uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgZGF0YVtrZXldID0gZXh0ZW5zaW9uW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE9wdGlvbnMoZGF0YSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBzdHlsZS5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUud2l0aFN0eWxlID0gZnVuY3Rpb24oc3R5bGUpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBzdHlsZTogc3R5bGVcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIHNpemUuXG4gKi9cbk9wdGlvbnMucHJvdG90eXBlLndpdGhTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIHNpemU6IHNpemVcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvbG9yLlxuICovXG5PcHRpb25zLnByb3RvdHlwZS53aXRoQ29sb3IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIGNvbG9yOiBjb2xvclxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCBcInBoYW50b21cIiBzZXQgdG8gdHJ1ZS5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUud2l0aFBoYW50b20gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBwaGFudG9tOiB0cnVlXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdHMgd2l0aCB0aGUgZ2l2ZSBmb250LlxuICovXG5PcHRpb25zLnByb3RvdHlwZS53aXRoRm9udCA9IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBmb250OiBmb250IHx8IHRoaXMuZm9udFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzdHlsZSwgc2l6ZSwgYW5kIGNvbG9yLiBUaGlzIGlzXG4gKiB1c2VkIHNvIHRoYXQgcGFyZW50IHN0eWxlIGFuZCBzaXplIGNoYW5nZXMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICovXG5PcHRpb25zLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7fSk7XG59O1xuXG4vKipcbiAqIEEgbWFwIG9mIGNvbG9yIG5hbWVzIHRvIENTUyBjb2xvcnMuXG4gKiBUT0RPKGVtaWx5KTogUmVtb3ZlIHRoaXMgd2hlbiB3ZSBoYXZlIHJlYWwgbWFjcm9zXG4gKi9cbnZhciBjb2xvck1hcCA9IHtcbiAgICBcImthdGV4LWJsdWVcIjogXCIjNjQ5NWVkXCIsXG4gICAgXCJrYXRleC1vcmFuZ2VcIjogXCIjZmZhNTAwXCIsXG4gICAgXCJrYXRleC1waW5rXCI6IFwiI2ZmMDBhZlwiLFxuICAgIFwia2F0ZXgtcmVkXCI6IFwiI2RmMDAzMFwiLFxuICAgIFwia2F0ZXgtZ3JlZW5cIjogXCIjMjhhZTdiXCIsXG4gICAgXCJrYXRleC1ncmF5XCI6IFwiZ3JheVwiLFxuICAgIFwia2F0ZXgtcHVycGxlXCI6IFwiIzlkMzhiZFwiLFxuICAgIFwia2F0ZXgtYmx1ZUFcIjogXCIjY2NmYWZmXCIsXG4gICAgXCJrYXRleC1ibHVlQlwiOiBcIiM4MGY2ZmZcIixcbiAgICBcImthdGV4LWJsdWVDXCI6IFwiIzYzZDllYVwiLFxuICAgIFwia2F0ZXgtYmx1ZURcIjogXCIjMTFhY2NkXCIsXG4gICAgXCJrYXRleC1ibHVlRVwiOiBcIiMwYzdmOTlcIixcbiAgICBcImthdGV4LXRlYWxBXCI6IFwiIzk0ZmZmNVwiLFxuICAgIFwia2F0ZXgtdGVhbEJcIjogXCIjMjZlZGQ1XCIsXG4gICAgXCJrYXRleC10ZWFsQ1wiOiBcIiMwMWQxYzFcIixcbiAgICBcImthdGV4LXRlYWxEXCI6IFwiIzAxYTk5NVwiLFxuICAgIFwia2F0ZXgtdGVhbEVcIjogXCIjMjA4MTcwXCIsXG4gICAgXCJrYXRleC1ncmVlbkFcIjogXCIjYjZmZmIwXCIsXG4gICAgXCJrYXRleC1ncmVlbkJcIjogXCIjOGFmMjgxXCIsXG4gICAgXCJrYXRleC1ncmVlbkNcIjogXCIjNzRjZjcwXCIsXG4gICAgXCJrYXRleC1ncmVlbkRcIjogXCIjMWZhYjU0XCIsXG4gICAgXCJrYXRleC1ncmVlbkVcIjogXCIjMGQ5MjNmXCIsXG4gICAgXCJrYXRleC1nb2xkQVwiOiBcIiNmZmQwYTlcIixcbiAgICBcImthdGV4LWdvbGRCXCI6IFwiI2ZmYmI3MVwiLFxuICAgIFwia2F0ZXgtZ29sZENcIjogXCIjZmY5YzM5XCIsXG4gICAgXCJrYXRleC1nb2xkRFwiOiBcIiNlMDdkMTBcIixcbiAgICBcImthdGV4LWdvbGRFXCI6IFwiI2E3NWEwNVwiLFxuICAgIFwia2F0ZXgtcmVkQVwiOiBcIiNmY2E5YTlcIixcbiAgICBcImthdGV4LXJlZEJcIjogXCIjZmY4NDgyXCIsXG4gICAgXCJrYXRleC1yZWRDXCI6IFwiI2Y5Njg1ZFwiLFxuICAgIFwia2F0ZXgtcmVkRFwiOiBcIiNlODRkMzlcIixcbiAgICBcImthdGV4LXJlZEVcIjogXCIjYmMyNjEyXCIsXG4gICAgXCJrYXRleC1tYXJvb25BXCI6IFwiI2ZmYmRlMFwiLFxuICAgIFwia2F0ZXgtbWFyb29uQlwiOiBcIiNmZjkyYzZcIixcbiAgICBcImthdGV4LW1hcm9vbkNcIjogXCIjZWQ1ZmE2XCIsXG4gICAgXCJrYXRleC1tYXJvb25EXCI6IFwiI2NhMzM3Y1wiLFxuICAgIFwia2F0ZXgtbWFyb29uRVwiOiBcIiM5ZTAzNGVcIixcbiAgICBcImthdGV4LXB1cnBsZUFcIjogXCIjZGRkN2ZmXCIsXG4gICAgXCJrYXRleC1wdXJwbGVCXCI6IFwiI2M2YjlmY1wiLFxuICAgIFwia2F0ZXgtcHVycGxlQ1wiOiBcIiNhYTg3ZmZcIixcbiAgICBcImthdGV4LXB1cnBsZURcIjogXCIjNzg1NGFiXCIsXG4gICAgXCJrYXRleC1wdXJwbGVFXCI6IFwiIzU0M2I3OFwiLFxuICAgIFwia2F0ZXgtbWludEFcIjogXCIjZjVmOWU4XCIsXG4gICAgXCJrYXRleC1taW50QlwiOiBcIiNlZGYyZGZcIixcbiAgICBcImthdGV4LW1pbnRDXCI6IFwiI2UwZTVjY1wiLFxuICAgIFwia2F0ZXgtZ3JheUFcIjogXCIjZjZmN2Y3XCIsXG4gICAgXCJrYXRleC1ncmF5QlwiOiBcIiNmMGYxZjJcIixcbiAgICBcImthdGV4LWdyYXlDXCI6IFwiI2UzZTVlNlwiLFxuICAgIFwia2F0ZXgtZ3JheURcIjogXCIjZDZkOGRhXCIsXG4gICAgXCJrYXRleC1ncmF5RVwiOiBcIiNiYWJlYzJcIixcbiAgICBcImthdGV4LWdyYXlGXCI6IFwiIzg4OGQ5M1wiLFxuICAgIFwia2F0ZXgtZ3JheUdcIjogXCIjNjI2NTY5XCIsXG4gICAgXCJrYXRleC1ncmF5SFwiOiBcIiMzYjNlNDBcIixcbiAgICBcImthdGV4LWdyYXlJXCI6IFwiIzIxMjQyY1wiLFxuICAgIFwia2F0ZXgta2FCbHVlXCI6IFwiIzMxNDQ1M1wiLFxuICAgIFwia2F0ZXgta2FHcmVlblwiOiBcIiM3MUIzMDdcIlxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBDU1MgY29sb3Igb2YgdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QsIGFjY291bnRpbmcgZm9yIHRoZVxuICogYGNvbG9yTWFwYC5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5waGFudG9tKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zcGFyZW50XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yTWFwW3RoaXMuY29sb3JdIHx8IHRoaXMuY29sb3I7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcHRpb25zO1xuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSBQYXJzZUVycm9yIGNsYXNzLCB3aGljaCBpcyB0aGUgbWFpbiBlcnJvciB0aHJvd24gYnkgS2FUZVhcbiAqIGZ1bmN0aW9ucyB3aGVuIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZy4gVGhpcyBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGludGVybmFsXG4gKiBlcnJvcnMgZnJvbSBlcnJvcnMgaW4gdGhlIGV4cHJlc3Npb24gdGhhdCB0aGUgdXNlciBwcm92aWRlZC5cbiAqXG4gKiBJZiBwb3NzaWJsZSwgYSBjYWxsZXIgc2hvdWxkIHByb3ZpZGUgYSBUb2tlbiBvciBQYXJzZU5vZGUgd2l0aCBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hlcmUgaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlIHByb2JsZW0gb2NjdXJyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0geyhUb2tlbnxQYXJzZU5vZGUpPX0gdG9rZW4gIEFuIG9iamVjdCBwcm92aWRpbmcgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAqL1xuZnVuY3Rpb24gUGFyc2VFcnJvcihtZXNzYWdlLCB0b2tlbikge1xuICAgIHZhciBlcnJvciA9IFwiS2FUZVggcGFyc2UgZXJyb3I6IFwiICsgbWVzc2FnZTtcbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIGVuZDtcblxuICAgIGlmICh0b2tlbiAmJiB0b2tlbi5sZXhlciAmJiB0b2tlbi5zdGFydCA8PSB0b2tlbi5lbmQpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSB0aGUgaW5wdXQgYW5kIGEgcG9zaXRpb24sIG1ha2UgdGhlIGVycm9yIGEgYml0IGZhbmNpZXJcblxuICAgICAgICAvLyBHZXQgdGhlIGlucHV0XG4gICAgICAgIHZhciBpbnB1dCA9IHRva2VuLmxleGVyLmlucHV0O1xuXG4gICAgICAgIC8vIFByZXBlbmQgc29tZSBpbmZvcm1hdGlvblxuICAgICAgICBzdGFydCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICBlbmQgPSB0b2tlbi5lbmQ7XG4gICAgICAgIGlmIChzdGFydCA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBlcnJvciArPSBcIiBhdCBlbmQgb2YgaW5wdXQ6IFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgKz0gXCIgYXQgcG9zaXRpb24gXCIgKyAoc3RhcnQgKyAxKSArIFwiOiBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuZGVybGluZSB0b2tlbiBpbiBxdWVzdGlvbiB1c2luZyBjb21iaW5pbmcgdW5kZXJzY29yZXNcbiAgICAgICAgdmFyIHVuZGVybGluZWQgPSBpbnB1dC5zbGljZShzdGFydCwgZW5kKS5yZXBsYWNlKC9bXl0vZywgXCIkJlxcdTAzMzJcIik7XG5cbiAgICAgICAgLy8gRXh0cmFjdCBzb21lIGNvbnRleHQgZnJvbSB0aGUgaW5wdXQgYW5kIGFkZCBpdCB0byB0aGUgZXJyb3JcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIGlmIChzdGFydCA+IDE1KSB7XG4gICAgICAgICAgICBsZWZ0ID0gXCLigKZcIiArIGlucHV0LnNsaWNlKHN0YXJ0IC0gMTUsIHN0YXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBpbnB1dC5zbGljZSgwLCBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJpZ2h0O1xuICAgICAgICBpZiAoZW5kICsgMTUgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gaW5wdXQuc2xpY2UoZW5kLCBlbmQgKyAxNSkgKyBcIuKAplwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmlnaHQgPSBpbnB1dC5zbGljZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yICs9IGxlZnQgKyB1bmRlcmxpbmVkICsgcmlnaHQ7XG4gICAgfVxuXG4gICAgLy8gU29tZSBoYWNrZXJ5IHRvIG1ha2UgUGFyc2VFcnJvciBhIHByb3RvdHlwZSBvZiBFcnJvclxuICAgIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84NDYwNzUzXG4gICAgdmFyIHNlbGYgPSBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIHNlbGYubmFtZSA9IFwiUGFyc2VFcnJvclwiO1xuICAgIHNlbGYuX19wcm90b19fID0gUGFyc2VFcnJvci5wcm90b3R5cGU7XG5cbiAgICBzZWxmLnBvc2l0aW9uID0gc3RhcnQ7XG4gICAgcmV0dXJuIHNlbGY7XG59XG5cbi8vIE1vcmUgaGFja2VyeVxuUGFyc2VFcnJvci5wcm90b3R5cGUuX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlRXJyb3I7XG4iLCIvKiBlc2xpbnQgbm8tY29uc3RhbnQtY29uZGl0aW9uOjAgKi9cbnZhciBmdW5jdGlvbnMgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnNcIik7XG52YXIgZW52aXJvbm1lbnRzID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRzXCIpO1xudmFyIE1hY3JvRXhwYW5kZXIgPSByZXF1aXJlKFwiLi9NYWNyb0V4cGFuZGVyXCIpO1xudmFyIHN5bWJvbHMgPSByZXF1aXJlKFwiLi9zeW1ib2xzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgY2prUmVnZXggPSByZXF1aXJlKFwiLi91bmljb2RlUmVnZXhlc1wiKS5jamtSZWdleDtcblxudmFyIHBhcnNlRGF0YSA9IHJlcXVpcmUoXCIuL3BhcnNlRGF0YVwiKTtcbnZhciBQYXJzZUVycm9yID0gcmVxdWlyZShcIi4vUGFyc2VFcnJvclwiKTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIHBhcnNlciB1c2VkIHRvIHBhcnNlIG91dCBhIFRlWCBleHByZXNzaW9uIGZyb20gdGhlXG4gKiBpbnB1dC4gU2luY2UgVGVYIGlzbid0IGNvbnRleHQtZnJlZSwgc3RhbmRhcmQgcGFyc2VycyBkb24ndCB3b3JrIHBhcnRpY3VsYXJseVxuICogd2VsbC5cbiAqXG4gKiBUaGUgc3RyYXRlZ3kgb2YgdGhpcyBwYXJzZXIgaXMgYXMgc3VjaDpcbiAqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbnMgKHRoZSBgLnBhcnNlLi4uYCBvbmVzKSB0YWtlIGEgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcbiAqIHBhcnNlIHN0cmluZyB0byBwYXJzZSB0b2tlbnMgZnJvbS4gVGhlIGxleGVyIChmb3VuZCBpbiBMZXhlci5qcywgc3RvcmVkIGF0XG4gKiB0aGlzLmxleGVyKSBhbHNvIHN1cHBvcnRzIHB1bGxpbmcgb3V0IHRva2VucyBhdCBhcmJpdHJhcnkgcGxhY2VzLiBXaGVuXG4gKiBpbmRpdmlkdWFsIHRva2VucyBhcmUgbmVlZGVkIGF0IGEgcG9zaXRpb24sIHRoZSBsZXhlciBpcyBjYWxsZWQgdG8gcHVsbCBvdXQgYVxuICogdG9rZW4sIHdoaWNoIGlzIHRoZW4gdXNlZC5cbiAqXG4gKiBUaGUgcGFyc2VyIGhhcyBhIHByb3BlcnR5IGNhbGxlZCBcIm1vZGVcIiBpbmRpY2F0aW5nIHRoZSBtb2RlIHRoYXRcbiAqIHRoZSBwYXJzZXIgaXMgY3VycmVudGx5IGluLiBDdXJyZW50bHkgaXQgaGFzIHRvIGJlIG9uZSBvZiBcIm1hdGhcIiBvclxuICogXCJ0ZXh0XCIsIHdoaWNoIGRlbm90ZXMgd2hldGhlciB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBhIG1hdGgteVxuICogb25lIG9yIGEgdGV4dC15IG9uZSAoZS5nLiBpbnNpZGUgXFx0ZXh0KS4gQ3VycmVudGx5LCB0aGlzIHNlcnZlcyB0b1xuICogbGltaXQgdGhlIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgdXNlZCBpbiB0ZXh0IG1vZGUuXG4gKlxuICogVGhlIG1haW4gZnVuY3Rpb25zIHRoZW4gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgdXNlZnVsIGRhdGEgdGhhdFxuICogd2FzIHBhcnNlZCBhdCBpdHMgZ2l2ZW4gcG9pbnQsIGFuZCBhIG5ldyBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJzZWRcbiAqIGRhdGEuIFRoZSBtYWluIGZ1bmN0aW9ucyBjYW4gY2FsbCBlYWNoIG90aGVyIGFuZCBjb250aW51ZSB0aGUgcGFyc2luZyBieVxuICogdXNpbmcgdGhlIHJldHVybmVkIHBvc2l0aW9uIGFzIGEgbmV3IHN0YXJ0aW5nIHBvaW50LlxuICpcbiAqIFRoZXJlIGFyZSBhbHNvIGV4dHJhIGAuaGFuZGxlLi4uYCBmdW5jdGlvbnMsIHdoaWNoIHB1bGwgb3V0IHNvbWUgcmV1c2VkXG4gKiBmdW5jdGlvbmFsaXR5IGludG8gc2VsZi1jb250YWluZWQgZnVuY3Rpb25zLlxuICpcbiAqIFRoZSBlYXJsaWVyIGZ1bmN0aW9ucyByZXR1cm4gUGFyc2VOb2Rlcy5cbiAqIFRoZSBsYXRlciBmdW5jdGlvbnMgKHdoaWNoIGFyZSBjYWxsZWQgZGVlcGVyIGluIHRoZSBwYXJzZSkgc29tZXRpbWVzIHJldHVyblxuICogUGFyc2VGdW5jT3JBcmd1bWVudCwgd2hpY2ggY29udGFpbiBhIFBhcnNlTm9kZSBhcyB3ZWxsIGFzIHNvbWUgZGF0YSBhYm91dFxuICogd2hldGhlciB0aGUgcGFyc2VkIG9iamVjdCBpcyBhIGZ1bmN0aW9uIHdoaWNoIGlzIG1pc3Npbmcgc29tZSBhcmd1bWVudHMsIG9yIGFcbiAqIHN0YW5kYWxvbmUgb2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIGFzIGFuIGFyZ3VtZW50IHRvIGFub3RoZXIgZnVuY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBNYWluIFBhcnNlciBjbGFzc1xuICovXG5mdW5jdGlvbiBQYXJzZXIoaW5wdXQsIHNldHRpbmdzKSB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IG1hY3JvIGV4cGFuZGVyIChndWxsZXQpIGFuZCAoaW5kaXJlY3RseSB2aWEgdGhhdCkgYWxzbyBhXG4gICAgLy8gbmV3IGxleGVyIChtb3V0aCkgZm9yIHRoaXMgcGFyc2VyIChzdG9tYWNoLCBpbiB0aGUgbGFuZ3VhZ2Ugb2YgVGVYKVxuICAgIHRoaXMuZ3VsbGV0ID0gbmV3IE1hY3JvRXhwYW5kZXIoaW5wdXQsIHNldHRpbmdzLm1hY3Jvcyk7XG4gICAgLy8gU3RvcmUgdGhlIHNldHRpbmdzIGZvciB1c2UgaW4gcGFyc2luZ1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAvLyBDb3VudCBsZWZ0cmlnaHQgZGVwdGggKGZvciBcXG1pZGRsZSBlcnJvcnMpXG4gICAgdGhpcy5sZWZ0cmlnaHREZXB0aCA9IDA7XG59XG5cbnZhciBQYXJzZU5vZGUgPSBwYXJzZURhdGEuUGFyc2VOb2RlO1xuXG4vKipcbiAqIEFuIGluaXRpYWwgZnVuY3Rpb24gKHdpdGhvdXQgaXRzIGFyZ3VtZW50cyksIG9yIGFuIGFyZ3VtZW50IHRvIGEgZnVuY3Rpb24uXG4gKiBUaGUgYHJlc3VsdGAgYXJndW1lbnQgc2hvdWxkIGJlIGEgUGFyc2VOb2RlLlxuICovXG5mdW5jdGlvbiBQYXJzZUZ1bmNPckFyZ3VtZW50KHJlc3VsdCwgaXNGdW5jdGlvbiwgdG9rZW4pIHtcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAvLyBJcyB0aGlzIGEgZnVuY3Rpb24gKGkuZS4gaXMgaXQgc29tZXRoaW5nIGRlZmluZWQgaW4gZnVuY3Rpb25zLmpzKT9cbiAgICB0aGlzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSByZXN1bHQgdG8gbWFrZSBzdXJlIGl0IGhhcyB0aGUgcmlnaHQgdHlwZSwgYW5kIHRocm93cyBhblxuICogYXBwcm9wcmlhdGUgZXJyb3Igb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGNvbnN1bWUgd2hldGhlciB0byBjb25zdW1lIHRoZSBleHBlY3RlZCB0b2tlbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG5QYXJzZXIucHJvdG90eXBlLmV4cGVjdCA9IGZ1bmN0aW9uKHRleHQsIGNvbnN1bWUpIHtcbiAgICBpZiAodGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gdGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgJ1wiICsgdGV4dCArIFwiJywgZ290ICdcIiArIHRoaXMubmV4dFRva2VuLnRleHQgKyBcIidcIixcbiAgICAgICAgICAgIHRoaXMubmV4dFRva2VuXG4gICAgICAgICk7XG4gICAgfVxuICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnNpZGVycyB0aGUgY3VycmVudCBsb29rIGFoZWFkIHRva2VuIGFzIGNvbnN1bWVkLFxuICogYW5kIGZldGNoZXMgdGhlIG9uZSBhZnRlciB0aGF0IGFzIHRoZSBuZXcgbG9vayBhaGVhZC5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5uZXh0VG9rZW4gPSB0aGlzLmd1bGxldC5nZXQodGhpcy5tb2RlID09PSBcIm1hdGhcIik7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnN3aXRjaE1vZGUgPSBmdW5jdGlvbihuZXdNb2RlKSB7XG4gICAgdGhpcy5ndWxsZXQudW5nZXQodGhpcy5uZXh0VG9rZW4pO1xuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgdGhpcy5jb25zdW1lKCk7XG59O1xuXG4vKipcbiAqIE1haW4gcGFyc2luZyBmdW5jdGlvbiwgd2hpY2ggcGFyc2VzIGFuIGVudGlyZSBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHs/QXJyYXkuPFBhcnNlTm9kZT59XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUcnkgdG8gcGFyc2UgdGhlIGlucHV0XG4gICAgdGhpcy5tb2RlID0gXCJtYXRoXCI7XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgdmFyIHBhcnNlID0gdGhpcy5wYXJzZUlucHV0KCk7XG4gICAgcmV0dXJuIHBhcnNlO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYW4gZW50aXJlIGlucHV0IHRyZWUuXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VJbnB1dCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFBhcnNlIGFuIGV4cHJlc3Npb25cbiAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcbiAgICAvLyBJZiB3ZSBzdWNjZWVkZWQsIG1ha2Ugc3VyZSB0aGVyZSdzIGFuIEVPRiBhdCB0aGUgZW5kXG4gICAgdGhpcy5leHBlY3QoXCJFT0ZcIiwgZmFsc2UpO1xuICAgIHJldHVybiBleHByZXNzaW9uO1xufTtcblxudmFyIGVuZE9mRXhwcmVzc2lvbiA9IFtcIn1cIiwgXCJcXFxcZW5kXCIsIFwiXFxcXHJpZ2h0XCIsIFwiJlwiLCBcIlxcXFxcXFxcXCIsIFwiXFxcXGNyXCJdO1xuXG4vKipcbiAqIFBhcnNlcyBhbiBcImV4cHJlc3Npb25cIiwgd2hpY2ggaXMgYSBsaXN0IG9mIGF0b21zLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYnJlYWtPbkluZml4ICBTaG91bGQgdGhlIHBhcnNpbmcgc3RvcCB3aGVuIHdlIGhpdCBpbmZpeFxuICogICAgICAgICAgICAgICAgICBub2Rlcz8gVGhpcyBoYXBwZW5zIHdoZW4gZnVuY3Rpb25zIGhhdmUgaGlnaGVyIHByZWNlbmRlbmNlXG4gKiAgICAgICAgICAgICAgICAgIHRoYW4gaW5maXggbm9kZXMgaW4gaW1wbGljaXQgcGFyc2VzLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gYnJlYWtPblRva2VuVGV4dCAgVGhlIHRleHQgb2YgdGhlIHRva2VuIHRoYXQgdGhlIGV4cHJlc3Npb25cbiAqICAgICAgICAgICAgICAgICAgc2hvdWxkIGVuZCB3aXRoLCBvciBgbnVsbGAgaWYgc29tZXRoaW5nIGVsc2Ugc2hvdWxkIGVuZCB0aGVcbiAqICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcmV0dXJuIHtQYXJzZU5vZGV9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24oYnJlYWtPbkluZml4LCBicmVha09uVG9rZW5UZXh0KSB7XG4gICAgdmFyIGJvZHkgPSBbXTtcbiAgICAvLyBLZWVwIGFkZGluZyBhdG9tcyB0byB0aGUgYm9keSB1bnRpbCB3ZSBjYW4ndCBwYXJzZSBhbnkgbW9yZSBhdG9tcyAoZWl0aGVyXG4gICAgLy8gd2UgcmVhY2hlZCB0aGUgZW5kLCBhIH0sIG9yIGEgXFxyaWdodClcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgbGV4ID0gdGhpcy5uZXh0VG9rZW47XG4gICAgICAgIGlmIChlbmRPZkV4cHJlc3Npb24uaW5kZXhPZihsZXgudGV4dCkgIT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJlYWtPblRva2VuVGV4dCAmJiBsZXgudGV4dCA9PT0gYnJlYWtPblRva2VuVGV4dCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJyZWFrT25JbmZpeCAmJiBmdW5jdGlvbnNbbGV4LnRleHRdICYmIGZ1bmN0aW9uc1tsZXgudGV4dF0uaW5maXgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdG9tID0gdGhpcy5wYXJzZUF0b20oKTtcbiAgICAgICAgaWYgKCFhdG9tKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MudGhyb3dPbkVycm9yICYmIGxleC50ZXh0WzBdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvck5vZGUgPSB0aGlzLmhhbmRsZVVuc3VwcG9ydGVkQ21kKCk7XG4gICAgICAgICAgICAgICAgYm9keS5wdXNoKGVycm9yTm9kZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJvZHkucHVzaChhdG9tKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlSW5maXhOb2Rlcyhib2R5KTtcbn07XG5cbi8qKlxuICogUmV3cml0ZXMgaW5maXggb3BlcmF0b3JzIHN1Y2ggYXMgXFxvdmVyIHdpdGggY29ycmVzcG9uZGluZyBjb21tYW5kcyBzdWNoXG4gKiBhcyBcXGZyYWMuXG4gKlxuICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGluZml4IG9wZXJhdG9yIHBlciBncm91cC4gIElmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZVxuICogdGhlbiB0aGUgZXhwcmVzc2lvbiBpcyBhbWJpZ3VvdXMuICBUaGlzIGNhbiBiZSByZXNvbHZlZCBieSBhZGRpbmcge30uXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICovXG5QYXJzZXIucHJvdG90eXBlLmhhbmRsZUluZml4Tm9kZXMgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgdmFyIG92ZXJJbmRleCA9IC0xO1xuICAgIHZhciBmdW5jTmFtZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGJvZHlbaV07XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiaW5maXhcIikge1xuICAgICAgICAgICAgaWYgKG92ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJvbmx5IG9uZSBpbmZpeCBvcGVyYXRvciBwZXIgZ3JvdXBcIixcbiAgICAgICAgICAgICAgICAgICAgbm9kZS52YWx1ZS50b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdmVySW5kZXggPSBpO1xuICAgICAgICAgICAgZnVuY05hbWUgPSBub2RlLnZhbHVlLnJlcGxhY2VXaXRoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG92ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdmFyIG51bWVyTm9kZTtcbiAgICAgICAgdmFyIGRlbm9tTm9kZTtcblxuICAgICAgICB2YXIgbnVtZXJCb2R5ID0gYm9keS5zbGljZSgwLCBvdmVySW5kZXgpO1xuICAgICAgICB2YXIgZGVub21Cb2R5ID0gYm9keS5zbGljZShvdmVySW5kZXggKyAxKTtcblxuICAgICAgICBpZiAobnVtZXJCb2R5Lmxlbmd0aCA9PT0gMSAmJiBudW1lckJvZHlbMF0udHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICAgICAgICBudW1lck5vZGUgPSBudW1lckJvZHlbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1lck5vZGUgPSBuZXcgUGFyc2VOb2RlKFwib3JkZ3JvdXBcIiwgbnVtZXJCb2R5LCB0aGlzLm1vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbm9tQm9keS5sZW5ndGggPT09IDEgJiYgZGVub21Cb2R5WzBdLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgICAgICAgZGVub21Ob2RlID0gZGVub21Cb2R5WzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVub21Ob2RlID0gbmV3IFBhcnNlTm9kZShcIm9yZGdyb3VwXCIsIGRlbm9tQm9keSwgdGhpcy5tb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY2FsbEZ1bmN0aW9uKFxuICAgICAgICAgICAgZnVuY05hbWUsIFtudW1lck5vZGUsIGRlbm9tTm9kZV0sIG51bGwpO1xuICAgICAgICByZXR1cm4gW25ldyBQYXJzZU5vZGUodmFsdWUudHlwZSwgdmFsdWUsIHRoaXMubW9kZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH1cbn07XG5cbi8vIFRoZSBncmVlZGluZXNzIG9mIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0XG52YXIgU1VQU1VCX0dSRUVESU5FU1MgPSAxO1xuXG4vKipcbiAqIEhhbmRsZSBhIHN1YnNjcmlwdCBvciBzdXBlcnNjcmlwdCB3aXRoIG5pY2UgZXJyb3JzLlxuICovXG5QYXJzZXIucHJvdG90eXBlLmhhbmRsZVN1cFN1YnNjcmlwdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgc3ltYm9sVG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB2YXIgc3ltYm9sID0gc3ltYm9sVG9rZW4udGV4dDtcbiAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLnBhcnNlR3JvdXAoKTtcblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnRocm93T25FcnJvciAmJiB0aGlzLm5leHRUb2tlbi50ZXh0WzBdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlVW5zdXBwb3J0ZWRDbWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgZ3JvdXAgYWZ0ZXIgJ1wiICsgc3ltYm9sICsgXCInXCIsXG4gICAgICAgICAgICAgICAgc3ltYm9sVG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLmlzRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gXiBhbmQgXyBoYXZlIGEgZ3JlZWRpbmVzcywgc28gaGFuZGxlIGludGVyYWN0aW9ucyB3aXRoIGZ1bmN0aW9ucydcbiAgICAgICAgLy8gZ3JlZWRpbmVzc1xuICAgICAgICB2YXIgZnVuY0dyZWVkaW5lc3MgPSBmdW5jdGlvbnNbZ3JvdXAucmVzdWx0XS5ncmVlZGluZXNzO1xuICAgICAgICBpZiAoZnVuY0dyZWVkaW5lc3MgPiBTVVBTVUJfR1JFRURJTkVTUykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihncm91cCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICBcIkdvdCBmdW5jdGlvbiAnXCIgKyBncm91cC5yZXN1bHQgKyBcIicgd2l0aCBubyBhcmd1bWVudHMgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImFzIFwiICsgbmFtZSwgc3ltYm9sVG9rZW4pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwLnJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSB0ZXh0dWFsIGlucHV0IG9mIGFuIHVuc3VwcG9ydGVkIGNvbW1hbmQgaW50byBhIHRleHQgbm9kZVxuICogY29udGFpbmVkIHdpdGhpbiBhIGNvbG9yIG5vZGUgd2hvc2UgY29sb3IgaXMgZGV0ZXJtaW5lZCBieSBlcnJvckNvbG9yXG4gKi9cblBhcnNlci5wcm90b3R5cGUuaGFuZGxlVW5zdXBwb3J0ZWRDbWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGV4dCA9IHRoaXMubmV4dFRva2VuLnRleHQ7XG4gICAgdmFyIHRleHRvcmRBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRleHRvcmRBcnJheS5wdXNoKG5ldyBQYXJzZU5vZGUoXCJ0ZXh0b3JkXCIsIHRleHRbaV0sIFwidGV4dFwiKSk7XG4gICAgfVxuXG4gICAgdmFyIHRleHROb2RlID0gbmV3IFBhcnNlTm9kZShcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJvZHk6IHRleHRvcmRBcnJheSxcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMubW9kZSk7XG5cbiAgICB2YXIgY29sb3JOb2RlID0gbmV3IFBhcnNlTm9kZShcbiAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICB7XG4gICAgICAgICAgICBjb2xvcjogdGhpcy5zZXR0aW5ncy5lcnJvckNvbG9yLFxuICAgICAgICAgICAgdmFsdWU6IFt0ZXh0Tm9kZV0sXG4gICAgICAgICAgICB0eXBlOiBcImNvbG9yXCJcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy5tb2RlKTtcblxuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHJldHVybiBjb2xvck5vZGU7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIGdyb3VwIHdpdGggb3B0aW9uYWwgc3VwZXIvc3Vic2NyaXB0cy5cbiAqXG4gKiBAcmV0dXJuIHs/UGFyc2VOb2RlfVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRoZSBib2R5IG9mIGFuIGF0b20gaXMgYW4gaW1wbGljaXQgZ3JvdXAsIHNvIHRoYXQgdGhpbmdzIGxpa2VcbiAgICAvLyBcXGxlZnQoeFxccmlnaHQpXjIgd29yayBjb3JyZWN0bHkuXG4gICAgdmFyIGJhc2UgPSB0aGlzLnBhcnNlSW1wbGljaXRHcm91cCgpO1xuXG4gICAgLy8gSW4gdGV4dCBtb2RlLCB3ZSBkb24ndCBoYXZlIHN1cGVyc2NyaXB0cyBvciBzdWJzY3JpcHRzXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuXG4gICAgLy8gTm90ZSB0aGF0IGJhc2UgbWF5IGJlIGVtcHR5IChpLmUuIG51bGwpIGF0IHRoaXMgcG9pbnQuXG5cbiAgICB2YXIgc3VwZXJzY3JpcHQ7XG4gICAgdmFyIHN1YnNjcmlwdDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyBMZXggdGhlIGZpcnN0IHRva2VuXG4gICAgICAgIHZhciBsZXggPSB0aGlzLm5leHRUb2tlbjtcblxuICAgICAgICBpZiAobGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiIHx8IGxleC50ZXh0ID09PSBcIlxcXFxub2xpbWl0c1wiKSB7XG4gICAgICAgICAgICAvLyBXZSBnb3QgYSBsaW1pdCBjb250cm9sXG4gICAgICAgICAgICBpZiAoIWJhc2UgfHwgYmFzZS50eXBlICE9PSBcIm9wXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJMaW1pdCBjb250cm9scyBtdXN0IGZvbGxvdyBhIG1hdGggb3BlcmF0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgbGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbWl0cyA9IGxleC50ZXh0ID09PSBcIlxcXFxsaW1pdHNcIjtcbiAgICAgICAgICAgICAgICBiYXNlLnZhbHVlLmxpbWl0cyA9IGxpbWl0cztcbiAgICAgICAgICAgICAgICBiYXNlLnZhbHVlLmFsd2F5c0hhbmRsZVN1cFN1YiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCJeXCIpIHtcbiAgICAgICAgICAgIC8vIFdlIGdvdCBhIHN1cGVyc2NyaXB0IHN0YXJ0XG4gICAgICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkRvdWJsZSBzdXBlcnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VwZXJzY3JpcHQgPSB0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1cGVyc2NyaXB0XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIl9cIikge1xuICAgICAgICAgICAgLy8gV2UgZ290IGEgc3Vic2NyaXB0IHN0YXJ0XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJEb3VibGUgc3Vic2NyaXB0XCIsIGxleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpcHQgPSB0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1YnNjcmlwdFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIC8vIFdlIGdvdCBhIHByaW1lXG4gICAgICAgICAgICB2YXIgcHJpbWUgPSBuZXcgUGFyc2VOb2RlKFwidGV4dG9yZFwiLCBcIlxcXFxwcmltZVwiLCB0aGlzLm1vZGUpO1xuXG4gICAgICAgICAgICAvLyBNYW55IHByaW1lcyBjYW4gYmUgZ3JvdXBlZCB0b2dldGhlciwgc28gd2UgaGFuZGxlIHRoaXMgaGVyZVxuICAgICAgICAgICAgdmFyIHByaW1lcyA9IFtwcmltZV07XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgIC8vIEtlZXAgbGV4aW5nIHRva2VucyB1bnRpbCB3ZSBnZXQgc29tZXRoaW5nIHRoYXQncyBub3QgYSBwcmltZVxuICAgICAgICAgICAgd2hpbGUgKHRoaXMubmV4dFRva2VuLnRleHQgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggb25lLCBhZGQgYW5vdGhlciBwcmltZSB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIHByaW1lcy5wdXNoKHByaW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFB1dCB0aGVtIGludG8gYW4gb3JkZ3JvdXAgYXMgdGhlIHN1cGVyc2NyaXB0XG4gICAgICAgICAgICBzdXBlcnNjcmlwdCA9IG5ldyBQYXJzZU5vZGUoXCJvcmRncm91cFwiLCBwcmltZXMsIHRoaXMubW9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBpdCB3YXNuJ3QgXiwgXywgb3IgJywgc3RvcCBwYXJzaW5nIHN1cGVyL3N1YnNjcmlwdHNcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cGVyc2NyaXB0IHx8IHN1YnNjcmlwdCkge1xuICAgICAgICAvLyBJZiB3ZSBnb3QgZWl0aGVyIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0LCBjcmVhdGUgYSBzdXBzdWJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZU5vZGUoXCJzdXBzdWJcIiwge1xuICAgICAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgICAgIHN1cDogc3VwZXJzY3JpcHQsXG4gICAgICAgICAgICBzdWI6IHN1YnNjcmlwdFxuICAgICAgICB9LCB0aGlzLm1vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIG9yaWdpbmFsIGJvZHlcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufTtcblxuLy8gQSBsaXN0IG9mIHRoZSBzaXplLWNoYW5naW5nIGZ1bmN0aW9ucywgZm9yIHVzZSBpbiBwYXJzZUltcGxpY2l0R3JvdXBcbnZhciBzaXplRnVuY3MgPSBbXG4gICAgXCJcXFxcdGlueVwiLCBcIlxcXFxzY3JpcHRzaXplXCIsIFwiXFxcXGZvb3Rub3Rlc2l6ZVwiLCBcIlxcXFxzbWFsbFwiLCBcIlxcXFxub3JtYWxzaXplXCIsXG4gICAgXCJcXFxcbGFyZ2VcIiwgXCJcXFxcTGFyZ2VcIiwgXCJcXFxcTEFSR0VcIiwgXCJcXFxcaHVnZVwiLCBcIlxcXFxIdWdlXCJcbl07XG5cbi8vIEEgbGlzdCBvZiB0aGUgc3R5bGUtY2hhbmdpbmcgZnVuY3Rpb25zLCBmb3IgdXNlIGluIHBhcnNlSW1wbGljaXRHcm91cFxudmFyIHN0eWxlRnVuY3MgPSBbXG4gICAgXCJcXFxcZGlzcGxheXN0eWxlXCIsIFwiXFxcXHRleHRzdHlsZVwiLCBcIlxcXFxzY3JpcHRzdHlsZVwiLCBcIlxcXFxzY3JpcHRzY3JpcHRzdHlsZVwiXG5dO1xuXG4vKipcbiAqIFBhcnNlcyBhbiBpbXBsaWNpdCBncm91cCwgd2hpY2ggaXMgYSBncm91cCB0aGF0IHN0YXJ0cyBhdCB0aGUgZW5kIG9mIGFcbiAqIHNwZWNpZmllZCwgYW5kIGVuZHMgcmlnaHQgYmVmb3JlIGEgaGlnaGVyIGV4cGxpY2l0IGdyb3VwIGVuZHMsIG9yIGF0IEVPTC4gSXRcbiAqIGlzIHVzZWQgZm9yIGZ1bmN0aW9ucyB0aGF0IGFwcGVhciB0byBhZmZlY3QgdGhlIGN1cnJlbnQgc3R5bGUsIGxpa2UgXFxMYXJnZSBvclxuICogXFx0ZXh0cm0sIHdoZXJlIGluc3RlYWQgb2Yga2VlcGluZyBhIHN0eWxlIHdlIGp1c3QgcHJldGVuZCB0aGF0IHRoZXJlIGlzIGFuXG4gKiBpbXBsaWNpdCBncm91cGluZyBhZnRlciBpdCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBncm91cC4gRS5nLlxuICogICBzbWFsbCB0ZXh0IHtcXExhcmdlIGxhcmdlIHRleHR9IHNtYWxsIHRleHQgYWdhaW5cbiAqIEl0IGlzIGFsc28gdXNlZCBmb3IgXFxsZWZ0IGFuZCBcXHJpZ2h0IHRvIGdldCB0aGUgY29ycmVjdCBncm91cGluZy5cbiAqXG4gKiBAcmV0dXJuIHs/UGFyc2VOb2RlfVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wbGljaXRHcm91cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucGFyc2VTeW1ib2woKTtcblxuICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHdlIGRpZG4ndCBnZXQgYW55dGhpbmcgd2UgaGFuZGxlLCBmYWxsIGJhY2sgdG8gcGFyc2VGdW5jdGlvblxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bmMgPSBzdGFydC5yZXN1bHQ7XG4gICAgdmFyIGJvZHk7XG5cbiAgICBpZiAoZnVuYyA9PT0gXCJcXFxcbGVmdFwiKSB7XG4gICAgICAgIC8vIElmIHdlIHNlZSBhIGxlZnQ6XG4gICAgICAgIC8vIFBhcnNlIHRoZSBlbnRpcmUgbGVmdCBmdW5jdGlvbiAoaW5jbHVkaW5nIHRoZSBkZWxpbWl0ZXIpXG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5wYXJzZUZ1bmN0aW9uKHN0YXJ0KTtcbiAgICAgICAgLy8gUGFyc2Ugb3V0IHRoZSBpbXBsaWNpdCBib2R5XG4gICAgICAgICsrdGhpcy5sZWZ0cmlnaHREZXB0aDtcbiAgICAgICAgYm9keSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcbiAgICAgICAgLS10aGlzLmxlZnRyaWdodERlcHRoO1xuICAgICAgICAvLyBDaGVjayB0aGUgbmV4dCB0b2tlblxuICAgICAgICB0aGlzLmV4cGVjdChcIlxcXFxyaWdodFwiLCBmYWxzZSk7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VGdW5jdGlvbigpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlTm9kZShcImxlZnRyaWdodFwiLCB7XG4gICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgbGVmdDogbGVmdC52YWx1ZS52YWx1ZSxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodC52YWx1ZS52YWx1ZVxuICAgICAgICB9LCB0aGlzLm1vZGUpO1xuICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gXCJcXFxcYmVnaW5cIikge1xuICAgICAgICAvLyBiZWdpbi4uLmVuZCBpcyBzaW1pbGFyIHRvIGxlZnQuLi5yaWdodFxuICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLnBhcnNlRnVuY3Rpb24oc3RhcnQpO1xuICAgICAgICB2YXIgZW52TmFtZSA9IGJlZ2luLnZhbHVlLm5hbWU7XG4gICAgICAgIGlmICghZW52aXJvbm1lbnRzLmhhc093blByb3BlcnR5KGVudk5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICBcIk5vIHN1Y2ggZW52aXJvbm1lbnQ6IFwiICsgZW52TmFtZSwgYmVnaW4udmFsdWUubmFtZUdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgZW52aXJvbm1lbnQgb2JqZWN0LiBBcmd1bWVudHMgYW5kIG90aGVyIGluZm9ybWF0aW9uIHdpbGxcbiAgICAgICAgLy8gYmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGJlZ2luIGFuZCBlbmQgbWV0aG9kcyB1c2luZyBwcm9wZXJ0aWVzLlxuICAgICAgICB2YXIgZW52ID0gZW52aXJvbm1lbnRzW2Vudk5hbWVdO1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VBcmd1bWVudHMoXCJcXFxcYmVnaW57XCIgKyBlbnZOYW1lICsgXCJ9XCIsIGVudik7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgICAgZW52TmFtZTogZW52TmFtZSxcbiAgICAgICAgICAgIHBhcnNlcjogdGhpcyxcbiAgICAgICAgICAgIHBvc2l0aW9uczogYXJncy5wb3AoKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gZW52LmhhbmRsZXIoY29udGV4dCwgYXJncyk7XG4gICAgICAgIHRoaXMuZXhwZWN0KFwiXFxcXGVuZFwiLCBmYWxzZSk7XG4gICAgICAgIHZhciBlbmROYW1lVG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucGFyc2VGdW5jdGlvbigpO1xuICAgICAgICBpZiAoZW5kLnZhbHVlLm5hbWUgIT09IGVudk5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiTWlzbWF0Y2g6IFxcXFxiZWdpbntcIiArIGVudk5hbWUgKyBcIn0gbWF0Y2hlZCBcIiArXG4gICAgICAgICAgICAgICAgXCJieSBcXFxcZW5ke1wiICsgZW5kLnZhbHVlLm5hbWUgKyBcIn1cIixcbiAgICAgICAgICAgICAgICBlbmROYW1lVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wb3NpdGlvbiA9IGVuZC5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmNvbnRhaW5zKHNpemVGdW5jcywgZnVuYykpIHtcbiAgICAgICAgLy8gSWYgd2Ugc2VlIGEgc2l6aW5nIGZ1bmN0aW9uLCBwYXJzZSBvdXQgdGhlIGltcGxpY3QgYm9keVxuICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlTm9kZShcInNpemluZ1wiLCB7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc2l6ZSB0byB1c2UgYmFzZWQgb24gdGhlIGxpc3Qgb2YgZnVuY3Rpb25zIGFib3ZlXG4gICAgICAgICAgICBzaXplOiBcInNpemVcIiArICh1dGlscy5pbmRleE9mKHNpemVGdW5jcywgZnVuYykgKyAxKSxcbiAgICAgICAgICAgIHZhbHVlOiBib2R5XG4gICAgICAgIH0sIHRoaXMubW9kZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyhzdHlsZUZ1bmNzLCBmdW5jKSkge1xuICAgICAgICAvLyBJZiB3ZSBzZWUgYSBzdHlsaW5nIGZ1bmN0aW9uLCBwYXJzZSBvdXQgdGhlIGltcGxpY3QgYm9keVxuICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VOb2RlKFwic3R5bGluZ1wiLCB7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc3R5bGUgdG8gdXNlIGJ5IHB1bGxpbmcgb3V0IHRoZSBzdHlsZSBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgZnVuY3Rpb24gbmFtZVxuICAgICAgICAgICAgc3R5bGU6IGZ1bmMuc2xpY2UoMSwgZnVuYy5sZW5ndGggLSA1KSxcbiAgICAgICAgICAgIHZhbHVlOiBib2R5XG4gICAgICAgIH0sIHRoaXMubW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGVmZXIgdG8gcGFyc2VGdW5jdGlvbiBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uIHdlIGhhbmRsZVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKHN0YXJ0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhbiBlbnRpcmUgZnVuY3Rpb24sIGluY2x1ZGluZyBpdHMgYmFzZSBhbmQgYWxsIG9mIGl0cyBhcmd1bWVudHMuXG4gKiBUaGUgYmFzZSBtaWdodCBlaXRoZXIgaGF2ZSBiZWVuIHBhcnNlZCBhbHJlYWR5LCBpbiB3aGljaCBjYXNlXG4gKiBpdCBpcyBwcm92aWRlZCBhcyBhbiBhcmd1bWVudCwgb3IgaXQncyB0aGUgbmV4dCBncm91cCBpbiB0aGUgaW5wdXQuXG4gKlxuICogQHBhcmFtIHtQYXJzZUZ1bmNPckFyZ3VtZW50PX0gYmFzZUdyb3VwIG9wdGlvbmFsIGFzIGRlc2NyaWJlZCBhYm92ZVxuICogQHJldHVybiB7P1BhcnNlTm9kZX1cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZ1bmN0aW9uID0gZnVuY3Rpb24oYmFzZUdyb3VwKSB7XG4gICAgaWYgKCFiYXNlR3JvdXApIHtcbiAgICAgICAgYmFzZUdyb3VwID0gdGhpcy5wYXJzZUdyb3VwKCk7XG4gICAgfVxuXG4gICAgaWYgKGJhc2VHcm91cCkge1xuICAgICAgICBpZiAoYmFzZUdyb3VwLmlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBmdW5jID0gYmFzZUdyb3VwLnJlc3VsdDtcbiAgICAgICAgICAgIHZhciBmdW5jRGF0YSA9IGZ1bmN0aW9uc1tmdW5jXTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiICYmICFmdW5jRGF0YS5hbGxvd2VkSW5UZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiQ2FuJ3QgdXNlIGZ1bmN0aW9uICdcIiArIGZ1bmMgKyBcIicgaW4gdGV4dCBtb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VHcm91cC50b2tlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZUFyZ3VtZW50cyhmdW5jLCBmdW5jRGF0YSk7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBiYXNlR3JvdXAudG9rZW47XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jYWxsRnVuY3Rpb24oZnVuYywgYXJncywgYXJncy5wb3AoKSwgdG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZU5vZGUocmVzdWx0LnR5cGUsIHJlc3VsdCwgdGhpcy5tb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlR3JvdXAucmVzdWx0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gaGFuZGxlciB3aXRoIGEgc3VpdGFibGUgY29udGV4dCBhbmQgYXJndW1lbnRzLlxuICovXG5QYXJzZXIucHJvdG90eXBlLmNhbGxGdW5jdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3MsIHBvc2l0aW9ucywgdG9rZW4pIHtcbiAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgZnVuY05hbWU6IG5hbWUsXG4gICAgICAgIHBhcnNlcjogdGhpcyxcbiAgICAgICAgcG9zaXRpb25zOiBwb3NpdGlvbnMsXG4gICAgICAgIHRva2VuOiB0b2tlblxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uc1tuYW1lXS5oYW5kbGVyKGNvbnRleHQsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIG9yIGVudmlyb25tZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZ1bmMgIFwiXFxuYW1lXCIgb3IgXCJcXGJlZ2lue25hbWV9XCJcbiAqIEBwYXJhbSB7e251bUFyZ3M6bnVtYmVyLG51bU9wdGlvbmFsQXJnczpudW1iZXJ8dW5kZWZpbmVkfX0gZnVuY0RhdGFcbiAqIEByZXR1cm4gdGhlIGFycmF5IG9mIGFyZ3VtZW50cywgd2l0aCB0aGUgbGlzdCBvZiBwb3NpdGlvbnMgYXMgbGFzdCBlbGVtZW50XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VBcmd1bWVudHMgPSBmdW5jdGlvbihmdW5jLCBmdW5jRGF0YSkge1xuICAgIHZhciB0b3RhbEFyZ3MgPSBmdW5jRGF0YS5udW1BcmdzICsgZnVuY0RhdGEubnVtT3B0aW9uYWxBcmdzO1xuICAgIGlmICh0b3RhbEFyZ3MgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtbdGhpcy5wb3NdXTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZUdyZWVkaW5lc3MgPSBmdW5jRGF0YS5ncmVlZGluZXNzO1xuICAgIHZhciBwb3NpdGlvbnMgPSBbdGhpcy5wb3NdO1xuICAgIHZhciBhcmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsQXJnczsgaSsrKSB7XG4gICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICAgICAgdmFyIGFyZ1R5cGUgPSBmdW5jRGF0YS5hcmdUeXBlcyAmJiBmdW5jRGF0YS5hcmdUeXBlc1tpXTtcbiAgICAgICAgdmFyIGFyZztcbiAgICAgICAgaWYgKGkgPCBmdW5jRGF0YS5udW1PcHRpb25hbEFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChhcmdUeXBlKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gdGhpcy5wYXJzZUdyb3VwT2ZUeXBlKGFyZ1R5cGUsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmcgPSB0aGlzLnBhcnNlR3JvdXAodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaCh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnVHlwZSkge1xuICAgICAgICAgICAgICAgIGFyZyA9IHRoaXMucGFyc2VHcm91cE9mVHlwZShhcmdUeXBlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJnID0gdGhpcy5wYXJzZUdyb3VwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy50aHJvd09uRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4udGV4dFswXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gbmV3IFBhcnNlRnVuY09yQXJndW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVVuc3VwcG9ydGVkQ21kKHRoaXMubmV4dFRva2VuLnRleHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCBncm91cCBhZnRlciAnXCIgKyBmdW5jICsgXCInXCIsIG5leHRUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdOb2RlO1xuICAgICAgICBpZiAoYXJnLmlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBhcmdHcmVlZGluZXNzID1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbnNbYXJnLnJlc3VsdF0uZ3JlZWRpbmVzcztcbiAgICAgICAgICAgIGlmIChhcmdHcmVlZGluZXNzID4gYmFzZUdyZWVkaW5lc3MpIHtcbiAgICAgICAgICAgICAgICBhcmdOb2RlID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGFyZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkdvdCBmdW5jdGlvbiAnXCIgKyBhcmcucmVzdWx0ICsgXCInIGFzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJhcmd1bWVudCB0byAnXCIgKyBmdW5jICsgXCInXCIsIG5leHRUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdOb2RlID0gYXJnLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnB1c2goYXJnTm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHRoaXMucG9zKTtcbiAgICB9XG5cbiAgICBhcmdzLnB1c2gocG9zaXRpb25zKTtcblxuICAgIHJldHVybiBhcmdzO1xufTtcblxuXG4vKipcbiAqIFBhcnNlcyBhIGdyb3VwIHdoZW4gdGhlIG1vZGUgaXMgY2hhbmdpbmcuXG4gKlxuICogQHJldHVybiB7P1BhcnNlRnVuY09yQXJndW1lbnR9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VHcm91cE9mVHlwZSA9IGZ1bmN0aW9uKGlubmVyTW9kZSwgb3B0aW9uYWwpIHtcbiAgICB2YXIgb3V0ZXJNb2RlID0gdGhpcy5tb2RlO1xuICAgIC8vIEhhbmRsZSBgb3JpZ2luYWxgIGFyZ1R5cGVzXG4gICAgaWYgKGlubmVyTW9kZSA9PT0gXCJvcmlnaW5hbFwiKSB7XG4gICAgICAgIGlubmVyTW9kZSA9IG91dGVyTW9kZTtcbiAgICB9XG5cbiAgICBpZiAoaW5uZXJNb2RlID09PSBcImNvbG9yXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb2xvckdyb3VwKG9wdGlvbmFsKTtcbiAgICB9XG4gICAgaWYgKGlubmVyTW9kZSA9PT0gXCJzaXplXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTaXplR3JvdXAob3B0aW9uYWwpO1xuICAgIH1cblxuICAgIHRoaXMuc3dpdGNoTW9kZShpbm5lck1vZGUpO1xuICAgIGlmIChpbm5lck1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIC8vIHRleHQgbW9kZSBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgc2hvdWxkIGlnbm9yZSB0aGUgd2hpdGVzcGFjZSBiZWZvcmVcbiAgICAgICAgLy8gaXRcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dFRva2VuLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCeSB0aGUgdGltZSB3ZSBnZXQgaGVyZSwgaW5uZXJNb2RlIGlzIG9uZSBvZiBcInRleHRcIiBvciBcIm1hdGhcIi5cbiAgICAvLyBXZSBzd2l0Y2ggdGhlIG1vZGUgb2YgdGhlIHBhcnNlciwgcmVjdXJzZSwgdGhlbiByZXN0b3JlIHRoZSBvbGQgbW9kZS5cbiAgICB2YXIgcmVzID0gdGhpcy5wYXJzZUdyb3VwKG9wdGlvbmFsKTtcbiAgICB0aGlzLnN3aXRjaE1vZGUob3V0ZXJNb2RlKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBncm91cCwgZXNzZW50aWFsbHkgcmV0dXJuaW5nIHRoZSBzdHJpbmcgZm9ybWVkIGJ5IHRoZVxuICogYnJhY2UtZW5jbG9zZWQgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kZU5hbWUgIFVzZWQgdG8gZGVzY3JpYmUgdGhlIG1vZGUgaW4gZXJyb3IgbWVzc2FnZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdGlvbmFsICBXaGV0aGVyIHRoZSBncm91cCBpcyBvcHRpb25hbCBvciByZXF1aXJlZFxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nR3JvdXAgPSBmdW5jdGlvbihtb2RlTmFtZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgdGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gXCJbXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvdXRlck1vZGUgPSB0aGlzLm1vZGU7XG4gICAgdGhpcy5tb2RlID0gXCJ0ZXh0XCI7XG4gICAgdGhpcy5leHBlY3Qob3B0aW9uYWwgPyBcIltcIiA6IFwie1wiKTtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgZmlyc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgIHZhciBsYXN0VG9rZW4gPSBmaXJzdFRva2VuO1xuICAgIHdoaWxlICh0aGlzLm5leHRUb2tlbi50ZXh0ICE9PSAob3B0aW9uYWwgPyBcIl1cIiA6IFwifVwiKSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0VG9rZW4udGV4dCA9PT0gXCJFT0ZcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCBpbiBcIiArIG1vZGVOYW1lLFxuICAgICAgICAgICAgICAgIGZpcnN0VG9rZW4ucmFuZ2UodGhpcy5uZXh0VG9rZW4sIHN0cikpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgICAgICBzdHIgKz0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgICB0aGlzLm1vZGUgPSBvdXRlck1vZGU7XG4gICAgdGhpcy5leHBlY3Qob3B0aW9uYWwgPyBcIl1cIiA6IFwifVwiKTtcbiAgICByZXR1cm4gZmlyc3RUb2tlbi5yYW5nZShsYXN0VG9rZW4sIHN0cik7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHJlZ2V4LWRlbGltaXRlZCBncm91cDogdGhlIGxhcmdlc3Qgc2VxdWVuY2Ugb2YgdG9rZW5zXG4gKiB3aG9zZSBjb25jYXRlbmF0ZWQgc3RyaW5ncyBtYXRjaCBgcmVnZXhgLiBSZXR1cm5zIHRoZSBzdHJpbmdcbiAqIGZvcm1lZCBieSB0aGUgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlTmFtZSAgVXNlZCB0byBkZXNjcmliZSB0aGUgbW9kZSBpbiBlcnJvciBtZXNzYWdlc1xuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlUmVnZXhHcm91cCA9IGZ1bmN0aW9uKHJlZ2V4LCBtb2RlTmFtZSkge1xuICAgIHZhciBvdXRlck1vZGUgPSB0aGlzLm1vZGU7XG4gICAgdGhpcy5tb2RlID0gXCJ0ZXh0XCI7XG4gICAgdmFyIGZpcnN0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB2YXIgbGFzdFRva2VuID0gZmlyc3RUb2tlbjtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB3aGlsZSAodGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gXCJFT0ZcIlxuICAgICAgICAgICAmJiByZWdleC50ZXN0KHN0ciArIHRoaXMubmV4dFRva2VuLnRleHQpKSB7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgICAgICBzdHIgKz0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIFwiICsgbW9kZU5hbWUgKyBcIjogJ1wiICsgZmlyc3RUb2tlbi50ZXh0ICsgXCInXCIsXG4gICAgICAgICAgICBmaXJzdFRva2VuKTtcbiAgICB9XG4gICAgdGhpcy5tb2RlID0gb3V0ZXJNb2RlO1xuICAgIHJldHVybiBmaXJzdFRva2VuLnJhbmdlKGxhc3RUb2tlbiwgc3RyKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgY29sb3IgZGVzY3JpcHRpb24uXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VDb2xvckdyb3VwID0gZnVuY3Rpb24ob3B0aW9uYWwpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwiY29sb3JcIiwgb3B0aW9uYWwpO1xuICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSAoL14oI1thLXowLTldK3xbYS16XSspJC9pKS5leGVjKHJlcy50ZXh0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBjb2xvcjogJ1wiICsgcmVzLnRleHQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICBuZXcgUGFyc2VOb2RlKFwiY29sb3JcIiwgbWF0Y2hbMF0sIHRoaXMubW9kZSksXG4gICAgICAgIGZhbHNlKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2l6ZSBzcGVjaWZpY2F0aW9uLCBjb25zaXN0aW5nIG9mIG1hZ25pdHVkZSBhbmQgdW5pdC5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNpemVHcm91cCA9IGZ1bmN0aW9uKG9wdGlvbmFsKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAoIW9wdGlvbmFsICYmIHRoaXMubmV4dFRva2VuLnRleHQgIT09IFwie1wiKSB7XG4gICAgICAgIHJlcyA9IHRoaXMucGFyc2VSZWdleEdyb3VwKFxuICAgICAgICAgICAgL15bLStdPyAqKD86JHxcXGQrfFxcZCtcXC5cXGQqfFxcLlxcZCopICpbYS16XXswLDJ9JC8sIFwic2l6ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJzaXplXCIsIG9wdGlvbmFsKTtcbiAgICB9XG4gICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBtYXRjaCA9ICgvKFstK10/KSAqKFxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykgKihbYS16XXsyfSkvKS5leGVjKHJlcy50ZXh0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBzaXplOiAnXCIgKyByZXMudGV4dCArIFwiJ1wiLCByZXMpO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgbnVtYmVyOiArKG1hdGNoWzFdICsgbWF0Y2hbMl0pLCAvLyBzaWduICsgbWFnbml0dWRlLCBjYXN0IHRvIG51bWJlclxuICAgICAgICB1bml0OiBtYXRjaFszXVxuICAgIH07XG4gICAgaWYgKGRhdGEudW5pdCAhPT0gXCJlbVwiICYmIGRhdGEudW5pdCAhPT0gXCJleFwiICYmIGRhdGEudW5pdCAhPT0gXCJtdVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyBkYXRhLnVuaXQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICBuZXcgUGFyc2VOb2RlKFwiY29sb3JcIiwgZGF0YSwgdGhpcy5tb2RlKSxcbiAgICAgICAgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgZmFsc2Ugb3IgYWJzZW50LCB0aGlzIHBhcnNlcyBhbiBvcmRpbmFyeSBncm91cCxcbiAqIHdoaWNoIGlzIGVpdGhlciBhIHNpbmdsZSBudWNsZXVzIChsaWtlIFwieFwiKSBvciBhbiBleHByZXNzaW9uXG4gKiBpbiBicmFjZXMgKGxpa2UgXCJ7eCt5fVwiKS5cbiAqIElmIHRoZSBhcmd1bWVudCBpcyB0cnVlLCBpdCBwYXJzZXMgZWl0aGVyIGEgYnJhY2tldC1kZWxpbWl0ZWQgZXhwcmVzc2lvblxuICogKGxpa2UgXCJbeCt5XVwiKSBvciByZXR1cm5zIG51bGwgdG8gaW5kaWNhdGUgdGhlIGFic2VuY2Ugb2YgYVxuICogYnJhY2tldC1lbmNsb3NlZCBncm91cC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRpb25hbCAgV2hldGhlciB0aGUgZ3JvdXAgaXMgb3B0aW9uYWwgb3IgcmVxdWlyZWRcbiAqIEByZXR1cm4gez9QYXJzZUZ1bmNPckFyZ3VtZW50fVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlR3JvdXAgPSBmdW5jdGlvbihvcHRpb25hbCkge1xuICAgIHZhciBmaXJzdFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG4gICAgLy8gVHJ5IHRvIHBhcnNlIGFuIG9wZW4gYnJhY2VcbiAgICBpZiAodGhpcy5uZXh0VG9rZW4udGV4dCA9PT0gKG9wdGlvbmFsID8gXCJbXCIgOiBcIntcIikpIHtcbiAgICAgICAgLy8gSWYgd2UgZ2V0IGEgYnJhY2UsIHBhcnNlIGFuIGV4cHJlc3Npb25cbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIG9wdGlvbmFsID8gXCJdXCIgOiBudWxsKTtcbiAgICAgICAgdmFyIGxhc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZ2V0IGEgY2xvc2UgYnJhY2VcbiAgICAgICAgdGhpcy5leHBlY3Qob3B0aW9uYWwgPyBcIl1cIiA6IFwifVwiKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUxpZ2F0dXJlcyhleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlRnVuY09yQXJndW1lbnQoXG4gICAgICAgICAgICBuZXcgUGFyc2VOb2RlKFwib3JkZ3JvdXBcIiwgZXhwcmVzc2lvbiwgdGhpcy5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFRva2VuLCBsYXN0VG9rZW4pLFxuICAgICAgICAgICAgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwganVzdCByZXR1cm4gYSBudWNsZXVzLCBvciBub3RoaW5nIGZvciBhbiBvcHRpb25hbCBncm91cFxuICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyBudWxsIDogdGhpcy5wYXJzZVN5bWJvbCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRm9ybSBsaWdhdHVyZS1saWtlIGNvbWJpbmF0aW9ucyBvZiBjaGFyYWN0ZXJzIGZvciB0ZXh0IG1vZGUuXG4gKiBUaGlzIGluY2x1ZGVzIGlucHV0cyBsaWtlIFwiLS1cIiwgXCItLS1cIiwgXCJgYFwiIGFuZCBcIicnXCIuXG4gKiBUaGUgcmVzdWx0IHdpbGwgc2ltcGx5IHJlcGxhY2UgbXVsdGlwbGUgdGV4dG9yZCBub2RlcyB3aXRoIGEgc2luZ2xlXG4gKiBjaGFyYWN0ZXIgaW4gZWFjaCB2YWx1ZSBieSBhIHNpbmdsZSB0ZXh0b3JkIG5vZGUgaGF2aW5nIG11bHRpcGxlXG4gKiBjaGFyYWN0ZXJzIGluIGl0cyB2YWx1ZS4gIFRoZSByZXByZXNlbnRhdGlvbiBpcyBzdGlsbCBBU0NJSSBzb3VyY2UuXG4gKlxuICogQHBhcmFtIHtBcnJheS48UGFyc2VOb2RlPn0gZ3JvdXAgIHRoZSBub2RlcyBvZiB0aGlzIGdyb3VwLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Qgd2lsbCBiZSBtb2lmaWVkIGluIHBsYWNlXG4gKi9cblBhcnNlci5wcm90b3R5cGUuZm9ybUxpZ2F0dXJlcyA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIG4gPSBncm91cC5sZW5ndGggLSAxO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdmFyIGEgPSBncm91cFtpXTtcbiAgICAgICAgdmFyIHYgPSBhLnZhbHVlO1xuICAgICAgICBpZiAodiA9PT0gXCItXCIgJiYgZ3JvdXBbaSArIDFdLnZhbHVlID09PSBcIi1cIikge1xuICAgICAgICAgICAgaWYgKGkgKyAxIDwgbiAmJiBncm91cFtpICsgMl0udmFsdWUgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDMsIG5ldyBQYXJzZU5vZGUoXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dG9yZFwiLCBcIi0tLVwiLCBcInRleHRcIiwgYSwgZ3JvdXBbaSArIDJdKSk7XG4gICAgICAgICAgICAgICAgbiAtPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncm91cC5zcGxpY2UoaSwgMiwgbmV3IFBhcnNlTm9kZShcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0b3JkXCIsIFwiLS1cIiwgXCJ0ZXh0XCIsIGEsIGdyb3VwW2kgKyAxXSkpO1xuICAgICAgICAgICAgICAgIG4gLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHYgPT09IFwiJ1wiIHx8IHYgPT09IFwiYFwiKSAmJiBncm91cFtpICsgMV0udmFsdWUgPT09IHYpIHtcbiAgICAgICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCBuZXcgUGFyc2VOb2RlKFxuICAgICAgICAgICAgICAgIFwidGV4dG9yZFwiLCB2ICsgdiwgXCJ0ZXh0XCIsIGEsIGdyb3VwW2kgKyAxXSkpO1xuICAgICAgICAgICAgbiAtPSAxO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBQYXJzZSBhIHNpbmdsZSBzeW1ib2wgb3V0IG9mIHRoZSBzdHJpbmcuIEhlcmUsIHdlIGhhbmRsZSBib3RoIHRoZSBmdW5jdGlvbnNcbiAqIHdlIGhhdmUgZGVmaW5lZCwgYXMgd2VsbCBhcyB0aGUgc2luZ2xlIGNoYXJhY3RlciBzeW1ib2xzXG4gKlxuICogQHJldHVybiB7P1BhcnNlRnVuY09yQXJndW1lbnR9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VTeW1ib2wgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbnVjbGV1cyA9IHRoaXMubmV4dFRva2VuO1xuXG4gICAgaWYgKGZ1bmN0aW9uc1tudWNsZXVzLnRleHRdKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAvLyBJZiB0aGVyZSBleGlzdHMgYSBmdW5jdGlvbiB3aXRoIHRoaXMgbmFtZSwgd2UgcmV0dXJuIHRoZSBmdW5jdGlvbiBhbmRcbiAgICAgICAgLy8gc2F5IHRoYXQgaXQgaXMgYSBmdW5jdGlvbi5cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICAgICAgbnVjbGV1cy50ZXh0LFxuICAgICAgICAgICAgdHJ1ZSwgbnVjbGV1cyk7XG4gICAgfSBlbHNlIGlmIChzeW1ib2xzW3RoaXMubW9kZV1bbnVjbGV1cy50ZXh0XSkge1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIHRoaXMgaXMgYSBuby1hcmd1bWVudCBmdW5jdGlvbiwgZmluZCB0aGUgdHlwZSBpdFxuICAgICAgICAvLyBjb3JyZXNwb25kcyB0byBpbiB0aGUgc3ltYm9scyBtYXBcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICAgICAgbmV3IFBhcnNlTm9kZShzeW1ib2xzW3RoaXMubW9kZV1bbnVjbGV1cy50ZXh0XS5ncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVjbGV1cy50ZXh0LCB0aGlzLm1vZGUsIG51Y2xldXMpLFxuICAgICAgICAgICAgZmFsc2UsIG51Y2xldXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIiAmJiBjamtSZWdleC50ZXN0KG51Y2xldXMudGV4dCkpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VGdW5jT3JBcmd1bWVudChcbiAgICAgICAgICAgIG5ldyBQYXJzZU5vZGUoXCJ0ZXh0b3JkXCIsIG51Y2xldXMudGV4dCwgdGhpcy5tb2RlLCBudWNsZXVzKSxcbiAgICAgICAgICAgIGZhbHNlLCBudWNsZXVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLlBhcnNlTm9kZSA9IFBhcnNlTm9kZTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXI7XG4iLCIvKipcbiAqIFRoaXMgaXMgYSBtb2R1bGUgZm9yIHN0b3Jpbmcgc2V0dGluZ3MgcGFzc2VkIGludG8gS2FUZVguIEl0IGNvcnJlY3RseSBoYW5kbGVzXG4gKiBkZWZhdWx0IHNldHRpbmdzLlxuICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIGEgZGVmYXVsdCB2YWx1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGdldChvcHRpb24sIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBvcHRpb24gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IG9wdGlvbjtcbn1cblxuLyoqXG4gKiBUaGUgbWFpbiBTZXR0aW5ncyBvYmplY3RcbiAqXG4gKiBUaGUgY3VycmVudCBvcHRpb25zIHN0b3JlZCBhcmU6XG4gKiAgLSBkaXNwbGF5TW9kZTogV2hldGhlciB0aGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgdHlwZXNldCBieSBkZWZhdWx0IGluXG4gKiAgICAgICAgICAgICAgICAgdGV4dHN0eWxlIG9yIGRpc3BsYXlzdHlsZSAoZGVmYXVsdCBmYWxzZSlcbiAqL1xuZnVuY3Rpb24gU2V0dGluZ3Mob3B0aW9ucykge1xuICAgIC8vIGFsbG93IG51bGwgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZGlzcGxheU1vZGUgPSBnZXQob3B0aW9ucy5kaXNwbGF5TW9kZSwgZmFsc2UpO1xuICAgIHRoaXMudGhyb3dPbkVycm9yID0gZ2V0KG9wdGlvbnMudGhyb3dPbkVycm9yLCB0cnVlKTtcbiAgICB0aGlzLmVycm9yQ29sb3IgPSBnZXQob3B0aW9ucy5lcnJvckNvbG9yLCBcIiNjYzAwMDBcIik7XG4gICAgdGhpcy5tYWNyb3MgPSBvcHRpb25zLm1hY3JvcyB8fCB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXR0aW5ncztcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFuZCBjbGFzc2VzIGZvciB0aGUgdmFyaW91cyBraW5kcyBvZiBzdHlsZXNcbiAqIHVzZWQgaW4gVGVYLiBJdCBwcm92aWRlcyBhIGdlbmVyaWMgYFN0eWxlYCBjbGFzcywgd2hpY2ggaG9sZHMgaW5mb3JtYXRpb25cbiAqIGFib3V0IGEgc3BlY2lmaWMgc3R5bGUuIEl0IHRoZW4gcHJvdmlkZXMgaW5zdGFuY2VzIG9mIGFsbCB0aGUgZGlmZmVyZW50IGtpbmRzXG4gKiBvZiBzdHlsZXMgcG9zc2libGUsIGFuZCBwcm92aWRlcyBmdW5jdGlvbnMgdG8gbW92ZSBiZXR3ZWVuIHRoZW0gYW5kIGdldFxuICogaW5mb3JtYXRpb24gYWJvdXQgdGhlbS5cbiAqL1xuXG52YXIgc2lnbWFzID0gcmVxdWlyZShcIi4vZm9udE1ldHJpY3MuanNcIikuc2lnbWFzO1xuXG52YXIgbWV0cmljcyA9IFt7fSwge30sIHt9XTtcbnZhciBpO1xuZm9yICh2YXIga2V5IGluIHNpZ21hcykge1xuICAgIGlmIChzaWdtYXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICBtZXRyaWNzW2ldW2tleV0gPSBzaWdtYXNba2V5XVtpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBtZXRyaWNzW2ldLmVtUGVyRXggPSBzaWdtYXMueEhlaWdodFtpXSAvIHNpZ21hcy5xdWFkW2ldO1xufVxuXG4vKipcbiAqIFRoZSBtYWluIHN0eWxlIGNsYXNzLiBDb250YWlucyBhIHVuaXF1ZSBpZCBmb3IgdGhlIHN0eWxlLCBhIHNpemUgKHdoaWNoIGlzXG4gKiB0aGUgc2FtZSBmb3IgY3JhbXBlZCBhbmQgdW5jcmFtcGVkIHZlcnNpb24gb2YgYSBzdHlsZSksIGEgY3JhbXBlZCBmbGFnLCBhbmQgYVxuICogc2l6ZSBtdWx0aXBsaWVyLCB3aGljaCBnaXZlcyB0aGUgc2l6ZSBkaWZmZXJlbmNlIGJldHdlZW4gYSBzdHlsZSBhbmRcbiAqIHRleHRzdHlsZS5cbiAqL1xuZnVuY3Rpb24gU3R5bGUoaWQsIHNpemUsIG11bHRpcGxpZXIsIGNyYW1wZWQpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmNyYW1wZWQgPSBjcmFtcGVkO1xuICAgIHRoaXMuc2l6ZU11bHRpcGxpZXIgPSBtdWx0aXBsaWVyO1xuICAgIHRoaXMubWV0cmljcyA9IG1ldHJpY3Nbc2l6ZSA+IDAgPyBzaXplIC0gMSA6IDBdO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3R5bGUgb2YgYSBzdXBlcnNjcmlwdCBnaXZlbiBhIGJhc2UgaW4gdGhlIGN1cnJlbnQgc3R5bGUuXG4gKi9cblN0eWxlLnByb3RvdHlwZS5zdXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3R5bGVzW3N1cFt0aGlzLmlkXV07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3R5bGUgb2YgYSBzdWJzY3JpcHQgZ2l2ZW4gYSBiYXNlIGluIHRoZSBjdXJyZW50IHN0eWxlLlxuICovXG5TdHlsZS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tzdWJbdGhpcy5pZF1dO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHN0eWxlIG9mIGEgZnJhY3Rpb24gbnVtZXJhdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudFxuICogc3R5bGUuXG4gKi9cblN0eWxlLnByb3RvdHlwZS5mcmFjTnVtID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tmcmFjTnVtW3RoaXMuaWRdXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzdHlsZSBvZiBhIGZyYWN0aW9uIGRlbm9taW5hdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudFxuICogc3R5bGUuXG4gKi9cblN0eWxlLnByb3RvdHlwZS5mcmFjRGVuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tmcmFjRGVuW3RoaXMuaWRdXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjcmFtcGVkIHZlcnNpb24gb2YgYSBzdHlsZSAoaW4gcGFydGljdWxhciwgY3JhbXBpbmcgYSBjcmFtcGVkIHN0eWxlXG4gKiBkb2Vzbid0IGNoYW5nZSB0aGUgc3R5bGUpLlxuICovXG5TdHlsZS5wcm90b3R5cGUuY3JhbXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3R5bGVzW2NyYW1wW3RoaXMuaWRdXTtcbn07XG5cbi8qKlxuICogSFRNTCBjbGFzcyBuYW1lLCBsaWtlIFwiZGlzcGxheXN0eWxlIGNyYW1wZWRcIlxuICovXG5TdHlsZS5wcm90b3R5cGUuY2xzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNpemVOYW1lc1t0aGlzLnNpemVdICsgKHRoaXMuY3JhbXBlZCA/IFwiIGNyYW1wZWRcIiA6IFwiIHVuY3JhbXBlZFwiKTtcbn07XG5cbi8qKlxuICogSFRNTCBSZXNldCBjbGFzcyBuYW1lLCBsaWtlIFwicmVzZXQtdGV4dHN0eWxlXCJcbiAqL1xuU3R5bGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHJlc2V0TmFtZXNbdGhpcy5zaXplXTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGlmIHRoaXMgc3R5bGUgaXMgdGlnaHRseSBzcGFjZWQgKHNjcmlwdHN0eWxlL3NjcmlwdHNjcmlwdHN0eWxlKVxuICovXG5TdHlsZS5wcm90b3R5cGUuaXNUaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUgPj0gMjtcbn07XG5cbi8vIElEcyBvZiB0aGUgZGlmZmVyZW50IHN0eWxlc1xudmFyIEQgPSAwO1xudmFyIERjID0gMTtcbnZhciBUID0gMjtcbnZhciBUYyA9IDM7XG52YXIgUyA9IDQ7XG52YXIgU2MgPSA1O1xudmFyIFNTID0gNjtcbnZhciBTU2MgPSA3O1xuXG4vLyBTdHJpbmcgbmFtZXMgZm9yIHRoZSBkaWZmZXJlbnQgc2l6ZXNcbnZhciBzaXplTmFtZXMgPSBbXG4gICAgXCJkaXNwbGF5c3R5bGUgdGV4dHN0eWxlXCIsXG4gICAgXCJ0ZXh0c3R5bGVcIixcbiAgICBcInNjcmlwdHN0eWxlXCIsXG4gICAgXCJzY3JpcHRzY3JpcHRzdHlsZVwiXG5dO1xuXG4vLyBSZXNldCBuYW1lcyBmb3IgdGhlIGRpZmZlcmVudCBzaXplc1xudmFyIHJlc2V0TmFtZXMgPSBbXG4gICAgXCJyZXNldC10ZXh0c3R5bGVcIixcbiAgICBcInJlc2V0LXRleHRzdHlsZVwiLFxuICAgIFwicmVzZXQtc2NyaXB0c3R5bGVcIixcbiAgICBcInJlc2V0LXNjcmlwdHNjcmlwdHN0eWxlXCJcbl07XG5cbi8vIEluc3RhbmNlcyBvZiB0aGUgZGlmZmVyZW50IHN0eWxlc1xudmFyIHN0eWxlcyA9IFtcbiAgICBuZXcgU3R5bGUoRCwgMCwgMS4wLCBmYWxzZSksXG4gICAgbmV3IFN0eWxlKERjLCAwLCAxLjAsIHRydWUpLFxuICAgIG5ldyBTdHlsZShULCAxLCAxLjAsIGZhbHNlKSxcbiAgICBuZXcgU3R5bGUoVGMsIDEsIDEuMCwgdHJ1ZSksXG4gICAgbmV3IFN0eWxlKFMsIDIsIDAuNywgZmFsc2UpLFxuICAgIG5ldyBTdHlsZShTYywgMiwgMC43LCB0cnVlKSxcbiAgICBuZXcgU3R5bGUoU1MsIDMsIDAuNSwgZmFsc2UpLFxuICAgIG5ldyBTdHlsZShTU2MsIDMsIDAuNSwgdHJ1ZSlcbl07XG5cbi8vIExvb2t1cCB0YWJsZXMgZm9yIHN3aXRjaGluZyBmcm9tIG9uZSBzdHlsZSB0byBhbm90aGVyXG52YXIgc3VwID0gW1MsIFNjLCBTLCBTYywgU1MsIFNTYywgU1MsIFNTY107XG52YXIgc3ViID0gW1NjLCBTYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xudmFyIGZyYWNOdW0gPSBbVCwgVGMsIFMsIFNjLCBTUywgU1NjLCBTUywgU1NjXTtcbnZhciBmcmFjRGVuID0gW1RjLCBUYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xudmFyIGNyYW1wID0gW0RjLCBEYywgVGMsIFRjLCBTYywgU2MsIFNTYywgU1NjXTtcblxuLy8gV2Ugb25seSBleHBvcnQgc29tZSBvZiB0aGUgc3R5bGVzLiBBbHNvLCB3ZSBkb24ndCBleHBvcnQgdGhlIGBTdHlsZWAgY2xhc3Mgc29cbi8vIG5vIG1vcmUgc3R5bGVzIGNhbiBiZSBnZW5lcmF0ZWQuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBESVNQTEFZOiBzdHlsZXNbRF0sXG4gICAgVEVYVDogc3R5bGVzW1RdLFxuICAgIFNDUklQVDogc3R5bGVzW1NdLFxuICAgIFNDUklQVFNDUklQVDogc3R5bGVzW1NTXVxufTtcbiIsIi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbi8qKlxuICogVGhpcyBtb2R1bGUgY29udGFpbnMgZ2VuZXJhbCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYnVpbGRpbmdcbiAqIGRpZmZlcmVudCBraW5kcyBvZiBkb21UcmVlIG5vZGVzIGluIGEgY29uc2lzdGVudCBtYW5uZXIuXG4gKi9cblxudmFyIGRvbVRyZWUgPSByZXF1aXJlKFwiLi9kb21UcmVlXCIpO1xudmFyIGZvbnRNZXRyaWNzID0gcmVxdWlyZShcIi4vZm9udE1ldHJpY3NcIik7XG52YXIgc3ltYm9scyA9IHJlcXVpcmUoXCIuL3N5bWJvbHNcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxudmFyIGdyZWVrQ2FwaXRhbHMgPSBbXG4gICAgXCJcXFxcR2FtbWFcIixcbiAgICBcIlxcXFxEZWx0YVwiLFxuICAgIFwiXFxcXFRoZXRhXCIsXG4gICAgXCJcXFxcTGFtYmRhXCIsXG4gICAgXCJcXFxcWGlcIixcbiAgICBcIlxcXFxQaVwiLFxuICAgIFwiXFxcXFNpZ21hXCIsXG4gICAgXCJcXFxcVXBzaWxvblwiLFxuICAgIFwiXFxcXFBoaVwiLFxuICAgIFwiXFxcXFBzaVwiLFxuICAgIFwiXFxcXE9tZWdhXCJcbl07XG5cbi8vIFRoZSBmb2xsb3dpbmcgaGF2ZSB0byBiZSBsb2FkZWQgZnJvbSBNYWluLUl0YWxpYyBmb250LCB1c2luZyBjbGFzcyBtYWluaXRcbnZhciBtYWluaXRMZXR0ZXJzID0gW1xuICAgIFwiXFx1MDEzMVwiLCAgIC8vIGRvdGxlc3MgaSwgXFxpbWF0aFxuICAgIFwiXFx1MDIzN1wiLCAgIC8vIGRvdGxlc3MgaiwgXFxqbWF0aFxuICAgIFwiXFx1MDBhM1wiICAgLy8gXFxwb3VuZHNcbl07XG5cbi8qKlxuICogTWFrZXMgYSBzeW1ib2xOb2RlIGFmdGVyIHRyYW5zbGF0aW9uIHZpYSB0aGUgbGlzdCBvZiBzeW1ib2xzIGluIHN5bWJvbHMuanMuXG4gKiBDb3JyZWN0bHkgcHVsbHMgb3V0IG1ldHJpY3MgZm9yIHRoZSBjaGFyYWN0ZXIsIGFuZCBvcHRpb25hbGx5IHRha2VzIGEgbGlzdCBvZlxuICogY2xhc3NlcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbm9kZS5cbiAqXG4gKiBUT0RPOiBtYWtlIGFyZ3VtZW50IG9yZGVyIGNsb3NlciB0byBtYWtlU3BhblxuICogVE9ETzogYWRkIGEgc2VwYXJhdGUgYXJndW1lbnQgZm9yIG1hdGggY2xhc3MgKGUuZy4gYG1vcGAsIGBtYmluYCksIHdoaWNoXG4gKiBzaG91bGQgaWYgcHJlc2VudCBjb21lIGZpcnN0IGluIGBjbGFzc2VzYC5cbiAqL1xudmFyIG1ha2VTeW1ib2wgPSBmdW5jdGlvbih2YWx1ZSwgZm9udEZhbWlseSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICAgIC8vIFJlcGxhY2UgdGhlIHZhbHVlIHdpdGggaXRzIHJlcGxhY2VkIHZhbHVlIGZyb20gc3ltYm9sLmpzXG4gICAgaWYgKHN5bWJvbHNbbW9kZV1bdmFsdWVdICYmIHN5bWJvbHNbbW9kZV1bdmFsdWVdLnJlcGxhY2UpIHtcbiAgICAgICAgdmFsdWUgPSBzeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlO1xuICAgIH1cblxuICAgIHZhciBtZXRyaWNzID0gZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljcyh2YWx1ZSwgZm9udEZhbWlseSk7XG5cbiAgICB2YXIgc3ltYm9sTm9kZTtcbiAgICBpZiAobWV0cmljcykge1xuICAgICAgICB2YXIgaXRhbGljID0gbWV0cmljcy5pdGFsaWM7XG4gICAgICAgIGlmIChtb2RlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgaXRhbGljID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2xOb2RlID0gbmV3IGRvbVRyZWUuc3ltYm9sTm9kZShcbiAgICAgICAgICAgIHZhbHVlLCBtZXRyaWNzLmhlaWdodCwgbWV0cmljcy5kZXB0aCwgaXRhbGljLCBtZXRyaWNzLnNrZXcsXG4gICAgICAgICAgICBjbGFzc2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPKGVtaWx5KTogRmlndXJlIG91dCBhIGdvb2Qgd2F5IHRvIG9ubHkgcHJpbnQgdGhpcyBpbiBkZXZlbG9wbWVudFxuICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIk5vIGNoYXJhY3RlciBtZXRyaWNzIGZvciAnXCIgKyB2YWx1ZSArIFwiJyBpbiBzdHlsZSAnXCIgK1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgKyBcIidcIik7XG4gICAgICAgIHN5bWJvbE5vZGUgPSBuZXcgZG9tVHJlZS5zeW1ib2xOb2RlKHZhbHVlLCAwLCAwLCAwLCAwLCBjbGFzc2VzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5zdHlsZS5pc1RpZ2h0KCkpIHtcbiAgICAgICAgICAgIHN5bWJvbE5vZGUuY2xhc3Nlcy5wdXNoKFwibXRpZ2h0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmdldENvbG9yKCkpIHtcbiAgICAgICAgICAgIHN5bWJvbE5vZGUuc3R5bGUuY29sb3IgPSBvcHRpb25zLmdldENvbG9yKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3ltYm9sTm9kZTtcbn07XG5cbi8qKlxuICogTWFrZXMgYSBzeW1ib2wgaW4gTWFpbi1SZWd1bGFyIG9yIEFNUy1SZWd1bGFyLlxuICogVXNlZCBmb3IgcmVsLCBiaW4sIG9wZW4sIGNsb3NlLCBpbm5lciwgYW5kIHB1bmN0LlxuICovXG52YXIgbWF0aHN5bSA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gICAgLy8gRGVjaWRlIHdoYXQgZm9udCB0byByZW5kZXIgdGhlIHN5bWJvbCBpbiBieSBpdHMgZW50cnkgaW4gdGhlIHN5bWJvbHNcbiAgICAvLyB0YWJsZS5cbiAgICAvLyBIYXZlIGEgc3BlY2lhbCBjYXNlIGZvciB3aGVuIHRoZSB2YWx1ZSA9IFxcIGJlY2F1c2UgdGhlIFxcIGlzIHVzZWQgYXMgYVxuICAgIC8vIHRleHRvcmQgaW4gdW5zdXBwb3J0ZWQgY29tbWFuZCBlcnJvcnMgYnV0IGNhbm5vdCBiZSBwYXJzZWQgYXMgYSByZWd1bGFyXG4gICAgLy8gdGV4dCBvcmRpbmFsIGFuZCBpcyB0aGVyZWZvcmUgbm90IHByZXNlbnQgYXMgYSBzeW1ib2wgaW4gdGhlIHN5bWJvbHNcbiAgICAvLyB0YWJsZSBmb3IgdGV4dFxuICAgIGlmICh2YWx1ZSA9PT0gXCJcXFxcXCIgfHwgc3ltYm9sc1ttb2RlXVt2YWx1ZV0uZm9udCA9PT0gXCJtYWluXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTeW1ib2wodmFsdWUsIFwiTWFpbi1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYWtlU3ltYm9sKFxuICAgICAgICAgICAgdmFsdWUsIFwiQU1TLVJlZ3VsYXJcIiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoW1wiYW1zcm1cIl0pKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2VzIGEgc3ltYm9sIGluIHRoZSBkZWZhdWx0IGZvbnQgZm9yIG1hdGhvcmRzIGFuZCB0ZXh0b3Jkcy5cbiAqL1xudmFyIG1hdGhEZWZhdWx0ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJtYXRob3JkXCIpIHtcbiAgICAgICAgcmV0dXJuIG1hdGhpdCh2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcInRleHRvcmRcIikge1xuICAgICAgICByZXR1cm4gbWFrZVN5bWJvbChcbiAgICAgICAgICAgIHZhbHVlLCBcIk1haW4tUmVndWxhclwiLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbXCJtYXRocm1cIl0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIHR5cGU6IFwiICsgdHlwZSArIFwiIGluIG1hdGhEZWZhdWx0XCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTWFrZXMgYSBzeW1ib2wgaW4gdGhlIGl0YWxpYyBtYXRoIGZvbnQuXG4gKi9cbnZhciBtYXRoaXQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICAgIGlmICgvWzAtOV0vLnRlc3QodmFsdWUuY2hhckF0KDApKSB8fFxuICAgICAgICAgICAgLy8gZ2x5cGhzIGZvciBcXGltYXRoIGFuZCBcXGptYXRoIGRvIG5vdCBleGlzdCBpbiBNYXRoLUl0YWxpYyBzbyB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byB1c2UgTWFpbi1JdGFsaWMgaW5zdGVhZFxuICAgICAgICAgICAgdXRpbHMuY29udGFpbnMobWFpbml0TGV0dGVycywgdmFsdWUpIHx8XG4gICAgICAgICAgICB1dGlscy5jb250YWlucyhncmVla0NhcGl0YWxzLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTeW1ib2woXG4gICAgICAgICAgICB2YWx1ZSwgXCJNYWluLUl0YWxpY1wiLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbXCJtYWluaXRcIl0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWFrZVN5bWJvbChcbiAgICAgICAgICAgIHZhbHVlLCBcIk1hdGgtSXRhbGljXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFtcIm1hdGhpdFwiXSkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTWFrZXMgZWl0aGVyIGEgbWF0aG9yZCBvciB0ZXh0b3JkIGluIHRoZSBjb3JyZWN0IGZvbnQgYW5kIGNvbG9yLlxuICovXG52YXIgbWFrZU9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zLCB0eXBlKSB7XG4gICAgdmFyIG1vZGUgPSBncm91cC5tb2RlO1xuICAgIHZhciB2YWx1ZSA9IGdyb3VwLnZhbHVlO1xuICAgIGlmIChzeW1ib2xzW21vZGVdW3ZhbHVlXSAmJiBzeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlKSB7XG4gICAgICAgIHZhbHVlID0gc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZTtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NlcyA9IFtcIm1vcmRcIl07XG5cbiAgICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgICBpZiAoZm9udCkge1xuICAgICAgICBpZiAoZm9udCA9PT0gXCJtYXRoaXRcIiB8fCB1dGlscy5jb250YWlucyhtYWluaXRMZXR0ZXJzLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoaXQodmFsdWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZvbnROYW1lID0gZm9udE1hcFtmb250XS5mb250TmFtZTtcbiAgICAgICAgICAgIGlmIChmb250TWV0cmljcy5nZXRDaGFyYWN0ZXJNZXRyaWNzKHZhbHVlLCBmb250TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVN5bWJvbChcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsIGZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbZm9udF0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGhEZWZhdWx0KHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYXRoRGVmYXVsdCh2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3NlcywgdHlwZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGhlaWdodCwgZGVwdGgsIGFuZCBtYXhGb250U2l6ZSBvZiBhbiBlbGVtZW50IGJhc2VkIG9uIGl0c1xuICogY2hpbGRyZW4uXG4gKi9cbnZhciBzaXplRWxlbWVudEZyb21DaGlsZHJlbiA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHZhciBtYXhGb250U2l6ZSA9IDA7XG5cbiAgICBpZiAoZWxlbS5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW0uY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlbGVtLmNoaWxkcmVuW2ldLmhlaWdodCA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGVsZW0uY2hpbGRyZW5baV0uaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW0uY2hpbGRyZW5baV0uZGVwdGggPiBkZXB0aCkge1xuICAgICAgICAgICAgICAgIGRlcHRoID0gZWxlbS5jaGlsZHJlbltpXS5kZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtLmNoaWxkcmVuW2ldLm1heEZvbnRTaXplID4gbWF4Rm9udFNpemUpIHtcbiAgICAgICAgICAgICAgICBtYXhGb250U2l6ZSA9IGVsZW0uY2hpbGRyZW5baV0ubWF4Rm9udFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtLmhlaWdodCA9IGhlaWdodDtcbiAgICBlbGVtLmRlcHRoID0gZGVwdGg7XG4gICAgZWxlbS5tYXhGb250U2l6ZSA9IG1heEZvbnRTaXplO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIHNwYW4gd2l0aCB0aGUgZ2l2ZW4gbGlzdCBvZiBjbGFzc2VzLCBsaXN0IG9mIGNoaWxkcmVuLCBhbmQgb3B0aW9ucy5cbiAqXG4gKiBUT0RPOiBFbnN1cmUgdGhhdCBgb3B0aW9uc2AgaXMgYWx3YXlzIHByb3ZpZGVkIChjdXJyZW50bHkgc29tZSBjYWxsIHNpdGVzXG4gKiBkb24ndCBwYXNzIGl0KS5cbiAqIFRPRE86IGFkZCBhIHNlcGFyYXRlIGFyZ3VtZW50IGZvciBtYXRoIGNsYXNzIChlLmcuIGBtb3BgLCBgbWJpbmApLCB3aGljaFxuICogc2hvdWxkIGlmIHByZXNlbnQgY29tZSBmaXJzdCBpbiBgY2xhc3Nlc2AuXG4gKi9cbnZhciBtYWtlU3BhbiA9IGZ1bmN0aW9uKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gICAgdmFyIHNwYW4gPSBuZXcgZG9tVHJlZS5zcGFuKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKTtcblxuICAgIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKHNwYW4pO1xuXG4gICAgcmV0dXJuIHNwYW47XG59O1xuXG4vKipcbiAqIFByZXBlbmRzIHRoZSBnaXZlbiBjaGlsZHJlbiB0byB0aGUgZ2l2ZW4gc3BhbiwgdXBkYXRpbmcgaGVpZ2h0LCBkZXB0aCwgYW5kXG4gKiBtYXhGb250U2l6ZS5cbiAqL1xudmFyIHByZXBlbmRDaGlsZHJlbiA9IGZ1bmN0aW9uKHNwYW4sIGNoaWxkcmVuKSB7XG4gICAgc3Bhbi5jaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdChzcGFuLmNoaWxkcmVuKTtcblxuICAgIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKHNwYW4pO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIGRvY3VtZW50IGZyYWdtZW50IHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgY2hpbGRyZW4uXG4gKi9cbnZhciBtYWtlRnJhZ21lbnQgPSBmdW5jdGlvbihjaGlsZHJlbikge1xuICAgIHZhciBmcmFnbWVudCA9IG5ldyBkb21UcmVlLmRvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pO1xuXG4gICAgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oZnJhZ21lbnQpO1xuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xufTtcblxuLyoqXG4gKiBNYWtlcyBhbiBlbGVtZW50IHBsYWNlZCBpbiBlYWNoIG9mIHRoZSB2bGlzdCBlbGVtZW50cyB0byBlbnN1cmUgdGhhdCBlYWNoXG4gKiBlbGVtZW50IGhhcyB0aGUgc2FtZSBtYXggZm9udCBzaXplLiBUbyBkbyB0aGlzLCB3ZSBjcmVhdGUgYSB6ZXJvLXdpZHRoIHNwYWNlXG4gKiB3aXRoIHRoZSBjb3JyZWN0IGZvbnQgc2l6ZS5cbiAqL1xudmFyIG1ha2VGb250U2l6ZXIgPSBmdW5jdGlvbihvcHRpb25zLCBmb250U2l6ZSkge1xuICAgIHZhciBmb250U2l6ZUlubmVyID0gbWFrZVNwYW4oW10sIFtuZXcgZG9tVHJlZS5zeW1ib2xOb2RlKFwiXFx1MjAwYlwiKV0pO1xuICAgIGZvbnRTaXplSW5uZXIuc3R5bGUuZm9udFNpemUgPVxuICAgICAgICAoZm9udFNpemUgLyBvcHRpb25zLnN0eWxlLnNpemVNdWx0aXBsaWVyKSArIFwiZW1cIjtcblxuICAgIHZhciBmb250U2l6ZXIgPSBtYWtlU3BhbihcbiAgICAgICAgW1wiZm9udHNpemUtZW5zdXJlclwiLCBcInJlc2V0LVwiICsgb3B0aW9ucy5zaXplLCBcInNpemU1XCJdLFxuICAgICAgICBbZm9udFNpemVJbm5lcl0pO1xuXG4gICAgcmV0dXJuIGZvbnRTaXplcjtcbn07XG5cbi8qKlxuICogTWFrZXMgYSB2ZXJ0aWNhbCBsaXN0IGJ5IHN0YWNraW5nIGVsZW1lbnRzIGFuZCBrZXJucyBvbiB0b3Agb2YgZWFjaCBvdGhlci5cbiAqIEFsbG93cyBmb3IgbWFueSBkaWZmZXJlbnQgd2F5cyBvZiBzcGVjaWZ5aW5nIHRoZSBwb3NpdGlvbmluZyBtZXRob2QuXG4gKlxuICogQXJndW1lbnRzOlxuICogIC0gY2hpbGRyZW46IEEgbGlzdCBvZiBjaGlsZCBvciBrZXJuIG5vZGVzIHRvIGJlIHN0YWNrZWQgb24gdG9wIG9mIGVhY2ggb3RoZXJcbiAqICAgICAgICAgICAgICAoaS5lLiB0aGUgZmlyc3QgZWxlbWVudCB3aWxsIGJlIGF0IHRoZSBib3R0b20sIGFuZCB0aGUgbGFzdCBhdFxuICogICAgICAgICAgICAgIHRoZSB0b3ApLiBFbGVtZW50IG5vZGVzIGFyZSBzcGVjaWZpZWQgYXNcbiAqICAgICAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogbm9kZX1cbiAqICAgICAgICAgICAgICB3aGlsZSBrZXJuIG5vZGVzIGFyZSBzcGVjaWZpZWQgYXNcbiAqICAgICAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogc2l6ZX1cbiAqICAtIHBvc2l0aW9uVHlwZTogVGhlIG1ldGhvZCBieSB3aGljaCB0aGUgdmxpc3Qgc2hvdWxkIGJlIHBvc2l0aW9uZWQuIFZhbGlkXG4gKiAgICAgICAgICAgICAgICAgIHZhbHVlcyBhcmU6XG4gKiAgICAgICAgICAgICAgICAgICAtIFwiaW5kaXZpZHVhbFNoaWZ0XCI6IFRoZSBjaGlsZHJlbiBsaXN0IG9ubHkgY29udGFpbnMgZWxlbVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMsIGFuZCBlYWNoIG5vZGUgY29udGFpbnMgYW4gZXh0cmFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2hpZnRcIiB2YWx1ZSBvZiBob3cgbXVjaCBpdCBzaG91bGQgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ZWQgKG5vdGUgdGhhdCBzaGlmdGluZyBpcyBhbHdheXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmluZyBkb3dud2FyZHMpLiBwb3NpdGlvbkRhdGEgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZWQuXG4gKiAgICAgICAgICAgICAgICAgICAtIFwidG9wXCI6IFRoZSBwb3NpdGlvbkRhdGEgc3BlY2lmaWVzIHRoZSB0b3Btb3N0IHBvaW50IG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdmxpc3QgKG5vdGUgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhIGhlaWdodCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvIHBvc2l0aXZlIHZhbHVlcyBtb3ZlIHVwKVxuICogICAgICAgICAgICAgICAgICAgLSBcImJvdHRvbVwiOiBUaGUgcG9zaXRpb25EYXRhIHNwZWNpZmllcyB0aGUgYm90dG9tbW9zdCBwb2ludFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIHZsaXN0IChub3RlIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgsIHNvIHBvc2l0aXZlIHZhbHVlcyBtb3ZlIGRvd25cbiAqICAgICAgICAgICAgICAgICAgIC0gXCJzaGlmdFwiOiBUaGUgdmxpc3Qgd2lsbCBiZSBwb3NpdGlvbmVkIHN1Y2ggdGhhdCBpdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmUgaXMgcG9zaXRpb25EYXRhIGF3YXkgZnJvbSB0aGUgYmFzZWxpbmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGZpcnN0IGNoaWxkLiBQb3NpdGl2ZSB2YWx1ZXMgbW92ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3dud2FyZHMuXG4gKiAgICAgICAgICAgICAgICAgICAtIFwiZmlyc3RCYXNlbGluZVwiOiBUaGUgdmxpc3Qgd2lsbCBiZSBwb3NpdGlvbmVkIHN1Y2ggdGhhdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0cyBiYXNlbGluZSBpcyBhbGlnbmVkIHdpdGggdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmUgb2YgdGhlIGZpcnN0IGNoaWxkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uRGF0YSBpcyBpZ25vcmVkLiAodGhpcyBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gXCJzaGlmdFwiIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkRhdGE9MClcbiAqICAtIHBvc2l0aW9uRGF0YTogRGF0YSB1c2VkIGluIGRpZmZlcmVudCB3YXlzIGRlcGVuZGluZyBvbiBwb3NpdGlvblR5cGVcbiAqICAtIG9wdGlvbnM6IEFuIE9wdGlvbnMgb2JqZWN0XG4gKlxuICovXG52YXIgbWFrZVZMaXN0ID0gZnVuY3Rpb24oY2hpbGRyZW4sIHBvc2l0aW9uVHlwZSwgcG9zaXRpb25EYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIGRlcHRoO1xuICAgIHZhciBjdXJyUG9zO1xuICAgIHZhciBpO1xuICAgIGlmIChwb3NpdGlvblR5cGUgPT09IFwiaW5kaXZpZHVhbFNoaWZ0XCIpIHtcbiAgICAgICAgdmFyIG9sZENoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIGNoaWxkcmVuID0gW29sZENoaWxkcmVuWzBdXTtcblxuICAgICAgICAvLyBBZGQgaW4ga2VybnMgdG8gdGhlIGxpc3Qgb2YgY2hpbGRyZW4gdG8gZ2V0IGVhY2ggZWxlbWVudCB0byBiZVxuICAgICAgICAvLyBzaGlmdGVkIHRvIHRoZSBjb3JyZWN0IHNwZWNpZmllZCBzaGlmdFxuICAgICAgICBkZXB0aCA9IC1vbGRDaGlsZHJlblswXS5zaGlmdCAtIG9sZENoaWxkcmVuWzBdLmVsZW0uZGVwdGg7XG4gICAgICAgIGN1cnJQb3MgPSBkZXB0aDtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IC1vbGRDaGlsZHJlbltpXS5zaGlmdCAtIGN1cnJQb3MgLVxuICAgICAgICAgICAgICAgIG9sZENoaWxkcmVuW2ldLmVsZW0uZGVwdGg7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGRpZmYgLVxuICAgICAgICAgICAgICAgIChvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5oZWlnaHQgK1xuICAgICAgICAgICAgICAgICBvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5kZXB0aCk7XG5cbiAgICAgICAgICAgIGN1cnJQb3MgPSBjdXJyUG9zICsgZGlmZjtcblxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh7dHlwZTogXCJrZXJuXCIsIHNpemU6IHNpemV9KTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gob2xkQ2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblR5cGUgPT09IFwidG9wXCIpIHtcbiAgICAgICAgLy8gV2UgYWx3YXlzIHN0YXJ0IGF0IHRoZSBib3R0b20sIHNvIGNhbGN1bGF0ZSB0aGUgYm90dG9tIGJ5IGFkZGluZyB1cFxuICAgICAgICAvLyBhbGwgdGhlIHNpemVzXG4gICAgICAgIHZhciBib3R0b20gPSBwb3NpdGlvbkRhdGE7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IFwia2VyblwiKSB7XG4gICAgICAgICAgICAgICAgYm90dG9tIC09IGNoaWxkcmVuW2ldLnNpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvdHRvbSAtPSBjaGlsZHJlbltpXS5lbGVtLmhlaWdodCArIGNoaWxkcmVuW2ldLmVsZW0uZGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVwdGggPSBib3R0b207XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblR5cGUgPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgZGVwdGggPSAtcG9zaXRpb25EYXRhO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb25UeXBlID09PSBcInNoaWZ0XCIpIHtcbiAgICAgICAgZGVwdGggPSAtY2hpbGRyZW5bMF0uZWxlbS5kZXB0aCAtIHBvc2l0aW9uRGF0YTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uVHlwZSA9PT0gXCJmaXJzdEJhc2VsaW5lXCIpIHtcbiAgICAgICAgZGVwdGggPSAtY2hpbGRyZW5bMF0uZWxlbS5kZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgfVxuXG4gICAgLy8gTWFrZSB0aGUgZm9udFNpemVyXG4gICAgdmFyIG1heEZvbnRTaXplID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IFwiZWxlbVwiKSB7XG4gICAgICAgICAgICBtYXhGb250U2l6ZSA9IE1hdGgubWF4KG1heEZvbnRTaXplLCBjaGlsZHJlbltpXS5lbGVtLm1heEZvbnRTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZm9udFNpemVyID0gbWFrZUZvbnRTaXplcihvcHRpb25zLCBtYXhGb250U2l6ZSk7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgbGlzdCBvZiBhY3R1YWwgY2hpbGRyZW4gYXQgdGhlIGNvcnJlY3Qgb2Zmc2V0c1xuICAgIHZhciByZWFsQ2hpbGRyZW4gPSBbXTtcbiAgICBjdXJyUG9zID0gZGVwdGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSBcImtlcm5cIikge1xuICAgICAgICAgICAgY3VyclBvcyArPSBjaGlsZHJlbltpXS5zaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV0uZWxlbTtcblxuICAgICAgICAgICAgdmFyIHNoaWZ0ID0gLWNoaWxkLmRlcHRoIC0gY3VyclBvcztcbiAgICAgICAgICAgIGN1cnJQb3MgKz0gY2hpbGQuaGVpZ2h0ICsgY2hpbGQuZGVwdGg7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZFdyYXAgPSBtYWtlU3BhbihbXSwgW2ZvbnRTaXplciwgY2hpbGRdKTtcbiAgICAgICAgICAgIGNoaWxkV3JhcC5oZWlnaHQgLT0gc2hpZnQ7XG4gICAgICAgICAgICBjaGlsZFdyYXAuZGVwdGggKz0gc2hpZnQ7XG4gICAgICAgICAgICBjaGlsZFdyYXAuc3R5bGUudG9wID0gc2hpZnQgKyBcImVtXCI7XG5cbiAgICAgICAgICAgIHJlYWxDaGlsZHJlbi5wdXNoKGNoaWxkV3JhcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaW4gYW4gZWxlbWVudCBhdCB0aGUgZW5kIHdpdGggbm8gb2Zmc2V0IHRvIGZpeCB0aGUgY2FsY3VsYXRpb24gb2ZcbiAgICAvLyBiYXNlbGluZXMgaW4gc29tZSBicm93c2VycyAobmFtZWx5IElFLCBzb21ldGltZXMgc2FmYXJpKVxuICAgIHZhciBiYXNlbGluZUZpeCA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJiYXNlbGluZS1maXhcIl0sIFtmb250U2l6ZXIsIG5ldyBkb21UcmVlLnN5bWJvbE5vZGUoXCJcXHUyMDBiXCIpXSk7XG4gICAgcmVhbENoaWxkcmVuLnB1c2goYmFzZWxpbmVGaXgpO1xuXG4gICAgdmFyIHZsaXN0ID0gbWFrZVNwYW4oW1widmxpc3RcIl0sIHJlYWxDaGlsZHJlbik7XG4gICAgLy8gRml4IHRoZSBmaW5hbCBoZWlnaHQgYW5kIGRlcHRoLCBpbiBjYXNlIHRoZXJlIHdlcmUga2VybnMgYXQgdGhlIGVuZHNcbiAgICAvLyBzaW5jZSB0aGUgbWFrZVNwYW4gY2FsY3VsYXRpb24gd29uJ3QgdGFrZSB0aGF0IGluIHRvIGFjY291bnQuXG4gICAgdmxpc3QuaGVpZ2h0ID0gTWF0aC5tYXgoY3VyclBvcywgdmxpc3QuaGVpZ2h0KTtcbiAgICB2bGlzdC5kZXB0aCA9IE1hdGgubWF4KC1kZXB0aCwgdmxpc3QuZGVwdGgpO1xuICAgIHJldHVybiB2bGlzdDtcbn07XG5cbi8vIEEgdGFibGUgb2Ygc2l6ZSAtPiBmb250IHNpemUgZm9yIHRoZSBkaWZmZXJlbnQgc2l6aW5nIGZ1bmN0aW9uc1xudmFyIHNpemluZ011bHRpcGxpZXIgPSB7XG4gICAgc2l6ZTE6IDAuNSxcbiAgICBzaXplMjogMC43LFxuICAgIHNpemUzOiAwLjgsXG4gICAgc2l6ZTQ6IDAuOSxcbiAgICBzaXplNTogMS4wLFxuICAgIHNpemU2OiAxLjIsXG4gICAgc2l6ZTc6IDEuNDQsXG4gICAgc2l6ZTg6IDEuNzMsXG4gICAgc2l6ZTk6IDIuMDcsXG4gICAgc2l6ZTEwOiAyLjQ5XG59O1xuXG4vLyBBIG1hcCBvZiBzcGFjaW5nIGZ1bmN0aW9ucyB0byB0aGVpciBhdHRyaWJ1dGVzLCBsaWtlIHNpemUgYW5kIGNvcnJlc3BvbmRpbmdcbi8vIENTUyBjbGFzc1xudmFyIHNwYWNpbmdGdW5jdGlvbnMgPSB7XG4gICAgXCJcXFxccXF1YWRcIjoge1xuICAgICAgICBzaXplOiBcIjJlbVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwicXF1YWRcIlxuICAgIH0sXG4gICAgXCJcXFxccXVhZFwiOiB7XG4gICAgICAgIHNpemU6IFwiMWVtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJxdWFkXCJcbiAgICB9LFxuICAgIFwiXFxcXGVuc3BhY2VcIjoge1xuICAgICAgICBzaXplOiBcIjAuNWVtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJlbnNwYWNlXCJcbiAgICB9LFxuICAgIFwiXFxcXDtcIjoge1xuICAgICAgICBzaXplOiBcIjAuMjc3Nzc4ZW1cIixcbiAgICAgICAgY2xhc3NOYW1lOiBcInRoaWNrc3BhY2VcIlxuICAgIH0sXG4gICAgXCJcXFxcOlwiOiB7XG4gICAgICAgIHNpemU6IFwiMC4yMjIyMmVtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJtZWRpdW1zcGFjZVwiXG4gICAgfSxcbiAgICBcIlxcXFwsXCI6IHtcbiAgICAgICAgc2l6ZTogXCIwLjE2NjY3ZW1cIixcbiAgICAgICAgY2xhc3NOYW1lOiBcInRoaW5zcGFjZVwiXG4gICAgfSxcbiAgICBcIlxcXFwhXCI6IHtcbiAgICAgICAgc2l6ZTogXCItMC4xNjY2N2VtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJuZWdhdGl2ZXRoaW5zcGFjZVwiXG4gICAgfVxufTtcblxuLyoqXG4gKiBNYXBzIFRlWCBmb250IGNvbW1hbmRzIHRvIG9iamVjdHMgY29udGFpbmluZzpcbiAqIC0gdmFyaWFudDogc3RyaW5nIHVzZWQgZm9yIFwibWF0aHZhcmlhbnRcIiBhdHRyaWJ1dGUgaW4gYnVpbGRNYXRoTUwuanNcbiAqIC0gZm9udE5hbWU6IHRoZSBcInN0eWxlXCIgcGFyYW1ldGVyIHRvIGZvbnRNZXRyaWNzLmdldENoYXJhY3Rlck1ldHJpY3NcbiAqL1xuLy8gQSBtYXAgYmV0d2VlbiB0ZXggZm9udCBjb21tYW5kcyBhbiBNYXRoTUwgbWF0aHZhcmlhbnQgYXR0cmlidXRlIHZhbHVlc1xudmFyIGZvbnRNYXAgPSB7XG4gICAgLy8gc3R5bGVzXG4gICAgXCJtYXRoYmZcIjoge1xuICAgICAgICB2YXJpYW50OiBcImJvbGRcIixcbiAgICAgICAgZm9udE5hbWU6IFwiTWFpbi1Cb2xkXCJcbiAgICB9LFxuICAgIFwibWF0aHJtXCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJub3JtYWxcIixcbiAgICAgICAgZm9udE5hbWU6IFwiTWFpbi1SZWd1bGFyXCJcbiAgICB9LFxuICAgIFwidGV4dGl0XCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJpdGFsaWNcIixcbiAgICAgICAgZm9udE5hbWU6IFwiTWFpbi1JdGFsaWNcIlxuICAgIH0sXG5cbiAgICAvLyBcIm1hdGhpdFwiIGlzIG1pc3NpbmcgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgdXNlIG9mIHR3byBmb250czogTWFpbi1JdGFsaWNcbiAgICAvLyBhbmQgTWF0aC1JdGFsaWMuICBUaGlzIGlzIGhhbmRsZWQgYnkgYSBzcGVjaWFsIGNhc2UgaW4gbWFrZU9yZCB3aGljaCBlbmRzXG4gICAgLy8gdXAgY2FsbGluZyBtYXRoaXQuXG5cbiAgICAvLyBmYW1pbGllc1xuICAgIFwibWF0aGJiXCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJkb3VibGUtc3RydWNrXCIsXG4gICAgICAgIGZvbnROYW1lOiBcIkFNUy1SZWd1bGFyXCJcbiAgICB9LFxuICAgIFwibWF0aGNhbFwiOiB7XG4gICAgICAgIHZhcmlhbnQ6IFwic2NyaXB0XCIsXG4gICAgICAgIGZvbnROYW1lOiBcIkNhbGlncmFwaGljLVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRoZnJha1wiOiB7XG4gICAgICAgIHZhcmlhbnQ6IFwiZnJha3R1clwiLFxuICAgICAgICBmb250TmFtZTogXCJGcmFrdHVyLVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRoc2NyXCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJzY3JpcHRcIixcbiAgICAgICAgZm9udE5hbWU6IFwiU2NyaXB0LVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRoc2ZcIjoge1xuICAgICAgICB2YXJpYW50OiBcInNhbnMtc2VyaWZcIixcbiAgICAgICAgZm9udE5hbWU6IFwiU2Fuc1NlcmlmLVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRodHRcIjoge1xuICAgICAgICB2YXJpYW50OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICBmb250TmFtZTogXCJUeXBld3JpdGVyLVJlZ3VsYXJcIlxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvbnRNYXA6IGZvbnRNYXAsXG4gICAgbWFrZVN5bWJvbDogbWFrZVN5bWJvbCxcbiAgICBtYXRoc3ltOiBtYXRoc3ltLFxuICAgIG1ha2VTcGFuOiBtYWtlU3BhbixcbiAgICBtYWtlRnJhZ21lbnQ6IG1ha2VGcmFnbWVudCxcbiAgICBtYWtlVkxpc3Q6IG1ha2VWTGlzdCxcbiAgICBtYWtlT3JkOiBtYWtlT3JkLFxuICAgIHByZXBlbmRDaGlsZHJlbjogcHJlcGVuZENoaWxkcmVuLFxuICAgIHNpemluZ011bHRpcGxpZXI6IHNpemluZ011bHRpcGxpZXIsXG4gICAgc3BhY2luZ0Z1bmN0aW9uczogc3BhY2luZ0Z1bmN0aW9uc1xufTtcbiIsIi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbi8qKlxuICogVGhpcyBmaWxlIGRvZXMgdGhlIG1haW4gd29yayBvZiBidWlsZGluZyBhIGRvbVRyZWUgc3RydWN0dXJlIGZyb20gYSBwYXJzZVxuICogdHJlZS4gVGhlIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRIVE1MYCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwYXJzZSB0cmVlLlxuICogVGhlbiwgdGhlIGJ1aWxkRXhwcmVzc2lvbiwgYnVpbGRHcm91cCwgYW5kIHZhcmlvdXMgZ3JvdXBUeXBlcyBmdW5jdGlvbnMgYXJlXG4gKiBjYWxsZWQsIHRvIHByb2R1Y2UgYSBmaW5hbCBIVE1MIHRyZWUuXG4gKi9cblxudmFyIFBhcnNlRXJyb3IgPSByZXF1aXJlKFwiLi9QYXJzZUVycm9yXCIpO1xudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vU3R5bGVcIik7XG5cbnZhciBidWlsZENvbW1vbiA9IHJlcXVpcmUoXCIuL2J1aWxkQ29tbW9uXCIpO1xudmFyIGRlbGltaXRlciA9IHJlcXVpcmUoXCIuL2RlbGltaXRlclwiKTtcbnZhciBkb21UcmVlID0gcmVxdWlyZShcIi4vZG9tVHJlZVwiKTtcbnZhciBmb250TWV0cmljcyA9IHJlcXVpcmUoXCIuL2ZvbnRNZXRyaWNzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbnZhciBtYWtlU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuO1xuXG52YXIgaXNTcGFjZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIGRvbVRyZWUuc3BhbiAmJiBub2RlLmNsYXNzZXNbMF0gPT09IFwibXNwYWNlXCI7XG59O1xuXG4vLyBCaW5hcnkgYXRvbXMgKGZpcnN0IGNsYXNzIGBtYmluYCkgY2hhbmdlIGludG8gb3JkaW5hcnkgYXRvbXMgKGBtb3JkYClcbi8vIGRlcGVuZGluZyBvbiB0aGVpciBzdXJyb3VuZGluZ3MuIFNlZSBUZVhib29rIHBnLiA0NDItNDQ2LCBSdWxlcyA1IGFuZCA2LFxuLy8gYW5kIHRoZSB0ZXh0IGJlZm9yZSBSdWxlIDE5LlxuXG52YXIgaXNCaW4gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5jbGFzc2VzWzBdID09PSBcIm1iaW5cIjtcbn07XG5cbnZhciBpc0JpbkxlZnRDYW5jZWxsZXIgPSBmdW5jdGlvbihub2RlLCBpc1JlYWxHcm91cCkge1xuICAgIC8vIFRPRE86IFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgYSBub2RlJ3MgbWF0aCBjbGFzcyBpcyB0aGUgZmlyc3QgZWxlbWVudFxuICAgIC8vIG9mIGl0cyBgY2xhc3Nlc2AgYXJyYXkuIEEgbGF0ZXIgY2xlYW51cCBzaG91bGQgZW5zdXJlIHRoaXMsIGZvclxuICAgIC8vIGluc3RhbmNlIGJ5IGNoYW5naW5nIHRoZSBzaWduYXR1cmUgb2YgYG1ha2VTcGFuYC5cbiAgICBpZiAobm9kZSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuY29udGFpbnMoW1wibWJpblwiLCBcIm1vcGVuXCIsIFwibXJlbFwiLCBcIm1vcFwiLCBcIm1wdW5jdFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3Nlc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzUmVhbEdyb3VwO1xuICAgIH1cbn07XG5cbnZhciBpc0JpblJpZ2h0Q2FuY2VsbGVyID0gZnVuY3Rpb24obm9kZSwgaXNSZWFsR3JvdXApIHtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuY29udGFpbnMoW1wibXJlbFwiLCBcIm1jbG9zZVwiLCBcIm1wdW5jdFwiXSwgbm9kZS5jbGFzc2VzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNSZWFsR3JvdXA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUYWtlIGEgbGlzdCBvZiBub2RlcywgYnVpbGQgdGhlbSBpbiBvcmRlciwgYW5kIHJldHVybiBhIGxpc3Qgb2YgdGhlIGJ1aWx0XG4gKiBub2Rlcy4gZG9jdW1lbnRGcmFnbWVudHMgYXJlIGZsYXR0ZW5lZCBpbnRvIHRoZWlyIGNvbnRlbnRzLCBzbyB0aGVcbiAqIHJldHVybmVkIGxpc3QgY29udGFpbnMgbm8gZnJhZ21lbnRzLiBgaXNSZWFsR3JvdXBgIGlzIHRydWUgaWYgYGV4cHJlc3Npb25gXG4gKiBpcyBhIHJlYWwgZ3JvdXAgKG5vIGF0b21zIHdpbGwgYmUgYWRkZWQgb24gZWl0aGVyIHNpZGUpLCBhcyBvcHBvc2VkIHRvXG4gKiBhIHBhcnRpYWwgZ3JvdXAgKGUuZy4gb25lIGNyZWF0ZWQgYnkgXFxjb2xvcikuXG4gKi9cbnZhciBidWlsZEV4cHJlc3Npb24gPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zLCBpc1JlYWxHcm91cCkge1xuICAgIC8vIFBhcnNlIGV4cHJlc3Npb25zIGludG8gYGdyb3Vwc2AuXG4gICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBleHByZXNzaW9uW2ldO1xuICAgICAgICB2YXIgb3V0cHV0ID0gYnVpbGRHcm91cChncm91cCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvdXRwdXQgaW5zdGFuY2VvZiBkb21UcmVlLmRvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGdyb3Vwcywgb3V0cHV0LmNoaWxkcmVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCBgZ3JvdXBzYCBjb25zaXN0cyBlbnRpcmVseSBvZiBgc3ltYm9sTm9kZWBzIGFuZCBgc3BhbmBzLlxuXG4gICAgLy8gRXhwbGljaXQgc3BhY2VzIChlLmcuLCBcXDssIFxcLCkgc2hvdWxkIGJlIGlnbm9yZWQgd2l0aCByZXNwZWN0IHRvIGF0b21cbiAgICAvLyBzcGFjaW5nIChlLmcuLCBcImFkZCB0aGljayBzcGFjZSBiZXR3ZWVuIG1vcmQgYW5kIG1yZWxcIikuIFNpbmNlIENTU1xuICAgIC8vIGFkamFjZW5jeSBydWxlcyBpbXBsZW1lbnQgYXRvbSBzcGFjaW5nLCBzcGFjZXMgc2hvdWxkIGJlIGludmlzaWJsZSB0b1xuICAgIC8vIENTUy4gU28gd2Ugc3BsaWNlIHRoZW0gb3V0IG9mIGBncm91cHNgIGFuZCBpbnRvIHRoZSBhdG9tcyB0aGVtc2VsdmVzLlxuICAgIHZhciBzcGFjZXMgPSBudWxsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzU3BhY2UoZ3JvdXBzW2ldKSkge1xuICAgICAgICAgICAgc3BhY2VzID0gc3BhY2VzIHx8IFtdO1xuICAgICAgICAgICAgc3BhY2VzLnB1c2goZ3JvdXBzW2ldKTtcbiAgICAgICAgICAgIGdyb3Vwcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH0gZWxzZSBpZiAoc3BhY2VzKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXBzW2ldIGluc3RhbmNlb2YgZG9tVHJlZS5zeW1ib2xOb2RlKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW2ldID0gbWFrZVNwYW4oW10uY29uY2F0KGdyb3Vwc1tpXS5jbGFzc2VzKSwgW2dyb3Vwc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVpbGRDb21tb24ucHJlcGVuZENoaWxkcmVuKGdyb3Vwc1tpXSwgc3BhY2VzKTtcbiAgICAgICAgICAgIHNwYWNlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNwYWNlcykge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShncm91cHMsIHNwYWNlcyk7XG4gICAgfVxuXG4gICAgLy8gQmluYXJ5IG9wZXJhdG9ycyBjaGFuZ2UgdG8gb3JkaW5hcnkgc3ltYm9scyBpbiBzb21lIGNvbnRleHRzLlxuICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzQmluKGdyb3Vwc1tpXSlcbiAgICAgICAgICAgICYmIChpc0JpbkxlZnRDYW5jZWxsZXIoZ3JvdXBzW2kgLSAxXSwgaXNSZWFsR3JvdXApXG4gICAgICAgICAgICAgICAgfHwgaXNCaW5SaWdodENhbmNlbGxlcihncm91cHNbaSArIDFdLCBpc1JlYWxHcm91cCkpKSB7XG4gICAgICAgICAgICBncm91cHNbaV0uY2xhc3Nlc1swXSA9IFwibW9yZFwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3Vwcztcbn07XG5cbi8vIFJldHVybiBtYXRoIGF0b20gY2xhc3MgKG1jbGFzcykgb2YgYSBkb21UcmVlLlxudmFyIGdldFR5cGVPZkRvbVRyZWUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBkb21UcmVlLmRvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VHlwZU9mRG9tVHJlZShcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHV0aWxzLmNvbnRhaW5zKFtcIm1vcmRcIiwgXCJtb3BcIiwgXCJtYmluXCIsIFwibXJlbFwiLCBcIm1vcGVuXCIsIFwibWNsb3NlXCIsXG4gICAgICAgICAgICBcIm1wdW5jdFwiLCBcIm1pbm5lclwiXSwgbm9kZS5jbGFzc2VzWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2xhc3Nlc1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogc3Vic2NyaXB0cyBhdHRhY2hlZCB0byB0aGVtLiBUaGlzIGZ1bmN0aW9uIGxldHMgdGhlIGBzdXBzdWJgIGdyb3VwIGtub3cgdGhhdFxuICogaXRzIGlubmVyIGVsZW1lbnQgc2hvdWxkIGhhbmRsZSB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGluc3RlYWQgb2ZcbiAqIGhhbmRsaW5nIHRoZW0gaXRzZWxmLlxuICovXG52YXIgc2hvdWxkSGFuZGxlU3VwU3ViID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwib3BcIikge1xuICAgICAgICAvLyBPcGVyYXRvcnMgaGFuZGxlIHN1cHN1YnMgZGlmZmVyZW50bHkgd2hlbiB0aGV5IGhhdmUgbGltaXRzXG4gICAgICAgIC8vIChlLmcuIGBcXGRpc3BsYXlzdHlsZVxcc3VtXzJeM2ApXG4gICAgICAgIHJldHVybiBncm91cC52YWx1ZS5saW1pdHMgJiZcbiAgICAgICAgICAgIChvcHRpb25zLnN0eWxlLnNpemUgPT09IFN0eWxlLkRJU1BMQVkuc2l6ZSB8fFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUuYWx3YXlzSGFuZGxlU3VwU3ViKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiYWNjZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIGlzQ2hhcmFjdGVyQm94KGdyb3VwLnZhbHVlLmJhc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogU29tZXRpbWVzIHdlIHdhbnQgdG8gcHVsbCBvdXQgdGhlIGlubmVybW9zdCBlbGVtZW50IG9mIGEgZ3JvdXAuIEluIG1vc3RcbiAqIGNhc2VzLCB0aGlzIHdpbGwganVzdCBiZSB0aGUgZ3JvdXAgaXRzZWxmLCBidXQgd2hlbiBvcmRncm91cHMgYW5kIGNvbG9ycyBoYXZlXG4gKiBhIHNpbmdsZSBlbGVtZW50LCB3ZSB3YW50IHRvIHB1bGwgdGhhdCBvdXQuXG4gKi9cbnZhciBnZXRCYXNlRWxlbSA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgaWYgKGdyb3VwLnZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJhc2VFbGVtKGdyb3VwLnZhbHVlWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgIGlmIChncm91cC52YWx1ZS52YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC52YWx1ZS52YWx1ZVswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiZm9udFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC52YWx1ZS5ib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUZVhib29rIGFsZ29yaXRobXMgb2Z0ZW4gcmVmZXJlbmNlIFwiY2hhcmFjdGVyIGJveGVzXCIsIHdoaWNoIGFyZSBzaW1wbHkgZ3JvdXBzXG4gKiB3aXRoIGEgc2luZ2xlIGNoYXJhY3RlciBpbiB0aGVtLiBUbyBkZWNpZGUgaWYgc29tZXRoaW5nIGlzIGEgY2hhcmFjdGVyIGJveCxcbiAqIHdlIGZpbmQgaXRzIGlubmVybW9zdCBncm91cCwgYW5kIHNlZSBpZiBpdCBpcyBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gKi9cbnZhciBpc0NoYXJhY3RlckJveCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIGJhc2VFbGVtID0gZ2V0QmFzZUVsZW0oZ3JvdXApO1xuXG4gICAgLy8gVGhlc2UgYXJlIGFsbCB0aGV5IHR5cGVzIG9mIGdyb3VwcyB3aGljaCBob2xkIHNpbmdsZSBjaGFyYWN0ZXJzXG4gICAgcmV0dXJuIGJhc2VFbGVtLnR5cGUgPT09IFwibWF0aG9yZFwiIHx8XG4gICAgICAgIGJhc2VFbGVtLnR5cGUgPT09IFwidGV4dG9yZFwiIHx8XG4gICAgICAgIGJhc2VFbGVtLnR5cGUgPT09IFwiYmluXCIgfHxcbiAgICAgICAgYmFzZUVsZW0udHlwZSA9PT0gXCJyZWxcIiB8fFxuICAgICAgICBiYXNlRWxlbS50eXBlID09PSBcImlubmVyXCIgfHxcbiAgICAgICAgYmFzZUVsZW0udHlwZSA9PT0gXCJvcGVuXCIgfHxcbiAgICAgICAgYmFzZUVsZW0udHlwZSA9PT0gXCJjbG9zZVwiIHx8XG4gICAgICAgIGJhc2VFbGVtLnR5cGUgPT09IFwicHVuY3RcIjtcbn07XG5cbnZhciBtYWtlTnVsbERlbGltaXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNsYXNzZXMpIHtcbiAgICByZXR1cm4gbWFrZVNwYW4oY2xhc3Nlcy5jb25jYXQoW1xuICAgICAgICBcInNpemluZ1wiLCBcInJlc2V0LVwiICsgb3B0aW9ucy5zaXplLCBcInNpemU1XCIsXG4gICAgICAgIG9wdGlvbnMuc3R5bGUucmVzZXQoKSwgU3R5bGUuVEVYVC5jbHMoKSxcbiAgICAgICAgXCJudWxsZGVsaW1pdGVyXCJdKSk7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSBtYXAgb2YgZ3JvdXAgdHlwZXMgdG8gdGhlIGZ1bmN0aW9uIHVzZWQgdG8gaGFuZGxlIHRoYXQgdHlwZS5cbiAqIFNpbXBsZXIgdHlwZXMgY29tZSBhdCB0aGUgYmVnaW5uaW5nLCB3aGlsZSBjb21wbGljYXRlZCB0eXBlcyBjb21lIGFmdGVyd2FyZHMuXG4gKi9cbnZhciBncm91cFR5cGVzID0ge307XG5cbmdyb3VwVHlwZXMubWF0aG9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwibWF0aG9yZFwiKTtcbn07XG5cbmdyb3VwVHlwZXMudGV4dG9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwidGV4dG9yZFwiKTtcbn07XG5cbmdyb3VwVHlwZXMuYmluID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWF0aHN5bShcbiAgICAgICAgZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUsIG9wdGlvbnMsIFtcIm1iaW5cIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5yZWwgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYXRoc3ltKFxuICAgICAgICBncm91cC52YWx1ZSwgZ3JvdXAubW9kZSwgb3B0aW9ucywgW1wibXJlbFwiXSk7XG59O1xuXG5ncm91cFR5cGVzLm9wZW4gPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYXRoc3ltKFxuICAgICAgICBncm91cC52YWx1ZSwgZ3JvdXAubW9kZSwgb3B0aW9ucywgW1wibW9wZW5cIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5jbG9zZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXG4gICAgICAgIGdyb3VwLnZhbHVlLCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtY2xvc2VcIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5pbm5lciA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXG4gICAgICAgIGdyb3VwLnZhbHVlLCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtaW5uZXJcIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5wdW5jdCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXG4gICAgICAgIGdyb3VwLnZhbHVlLCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtcHVuY3RcIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5vcmRncm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1ha2VTcGFuKFxuICAgICAgICBbXCJtb3JkXCIsIG9wdGlvbnMuc3R5bGUuY2xzKCldLFxuICAgICAgICBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUsIG9wdGlvbnMucmVzZXQoKSwgdHJ1ZSksXG4gICAgICAgIG9wdGlvbnNcbiAgICApO1xufTtcblxuZ3JvdXBUeXBlcy50ZXh0ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aEZvbnQoZ3JvdXAudmFsdWUuc3R5bGUpO1xuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC52YWx1ZS5ib2R5LCBuZXdPcHRpb25zLCB0cnVlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoaW5uZXJbaV0udHJ5Q29tYmluZShpbm5lcltpICsgMV0pKSB7XG4gICAgICAgICAgICBpbm5lci5zcGxpY2UoaSArIDEsIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwidGV4dFwiLCBuZXdPcHRpb25zLnN0eWxlLmNscygpXSxcbiAgICAgICAgaW5uZXIsIG5ld09wdGlvbnMpO1xufTtcblxuZ3JvdXBUeXBlcy5jb2xvciA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKFxuICAgICAgICBncm91cC52YWx1ZS52YWx1ZSxcbiAgICAgICAgb3B0aW9ucy53aXRoQ29sb3IoZ3JvdXAudmFsdWUuY29sb3IpLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICAvLyBcXGNvbG9yIGlzbid0IHN1cHBvc2VkIHRvIGFmZmVjdCB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudHMgaXQgY29udGFpbnMuXG4gICAgLy8gVG8gYWNjb21wbGlzaCB0aGlzLCB3ZSB3cmFwIHRoZSByZXN1bHRzIGluIGEgZnJhZ21lbnQsIHNvIHRoZSBpbm5lclxuICAgIC8vIGVsZW1lbnRzIHdpbGwgYmUgYWJsZSB0byBkaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZWlyIG5laWdoYm9ycy4gRm9yXG4gICAgLy8gZXhhbXBsZSwgYFxcY29sb3J7cmVkfXsyICt9IDNgIGhhcyB0aGUgc2FtZSBzcGFjaW5nIGFzIGAyICsgM2BcbiAgICByZXR1cm4gbmV3IGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG59O1xuXG5ncm91cFR5cGVzLnN1cHN1YiA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3VwZXJzY3JpcHQgYW5kIHN1YnNjcmlwdHMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGFnZVxuICAgIC8vIDQ0NS00NDYsIHJ1bGVzIDE4KGEtZikuXG5cbiAgICAvLyBIZXJlIGlzIHdoZXJlIHdlIGRlZmVyIHRvIHRoZSBpbm5lciBncm91cCBpZiBpdCBzaG91bGQgaGFuZGxlXG4gICAgLy8gc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGl0c2VsZi5cbiAgICBpZiAoc2hvdWxkSGFuZGxlU3VwU3ViKGdyb3VwLnZhbHVlLmJhc2UsIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBncm91cFR5cGVzW2dyb3VwLnZhbHVlLmJhc2UudHlwZV0oZ3JvdXAsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBiYXNlID0gYnVpbGRHcm91cChncm91cC52YWx1ZS5iYXNlLCBvcHRpb25zLnJlc2V0KCkpO1xuICAgIHZhciBzdXBtaWQ7XG4gICAgdmFyIHN1Ym1pZDtcbiAgICB2YXIgc3VwO1xuICAgIHZhciBzdWI7XG5cbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBuZXdPcHRpb25zO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnN1cCkge1xuICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuc3VwKCkpO1xuICAgICAgICBzdXAgPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLnN1cCwgbmV3T3B0aW9ucyk7XG4gICAgICAgIHN1cG1pZCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBzdHlsZS5zdXAoKS5jbHMoKV0sXG4gICAgICAgICAgICBbc3VwXSwgbmV3T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnN1Yikge1xuICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuc3ViKCkpO1xuICAgICAgICBzdWIgPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLnN1YiwgbmV3T3B0aW9ucyk7XG4gICAgICAgIHN1Ym1pZCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBzdHlsZS5zdWIoKS5jbHMoKV0sXG4gICAgICAgICAgICBbc3ViXSwgbmV3T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gUnVsZSAxOGFcbiAgICB2YXIgc3VwU2hpZnQ7XG4gICAgdmFyIHN1YlNoaWZ0O1xuICAgIGlmIChpc0NoYXJhY3RlckJveChncm91cC52YWx1ZS5iYXNlKSkge1xuICAgICAgICBzdXBTaGlmdCA9IDA7XG4gICAgICAgIHN1YlNoaWZ0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdXBTaGlmdCA9IGJhc2UuaGVpZ2h0IC0gc3R5bGUubWV0cmljcy5zdXBEcm9wO1xuICAgICAgICBzdWJTaGlmdCA9IGJhc2UuZGVwdGggKyBzdHlsZS5tZXRyaWNzLnN1YkRyb3A7XG4gICAgfVxuXG4gICAgLy8gUnVsZSAxOGNcbiAgICB2YXIgbWluU3VwU2hpZnQ7XG4gICAgaWYgKHN0eWxlID09PSBTdHlsZS5ESVNQTEFZKSB7XG4gICAgICAgIG1pblN1cFNoaWZ0ID0gc3R5bGUubWV0cmljcy5zdXAxO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuY3JhbXBlZCkge1xuICAgICAgICBtaW5TdXBTaGlmdCA9IHN0eWxlLm1ldHJpY3Muc3VwMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TdXBTaGlmdCA9IHN0eWxlLm1ldHJpY3Muc3VwMjtcbiAgICB9XG5cbiAgICAvLyBzY3JpcHRzcGFjZSBpcyBhIGZvbnQtc2l6ZS1pbmRlcGVuZGVudCBzaXplLCBzbyBzY2FsZSBpdFxuICAgIC8vIGFwcHJvcHJpYXRlbHlcbiAgICB2YXIgbXVsdGlwbGllciA9IFN0eWxlLlRFWFQuc2l6ZU11bHRpcGxpZXIgKlxuICAgICAgICAgICAgc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIHNjcmlwdHNwYWNlID1cbiAgICAgICAgKDAuNSAvIGZvbnRNZXRyaWNzLm1ldHJpY3MucHRQZXJFbSkgLyBtdWx0aXBsaWVyICsgXCJlbVwiO1xuXG4gICAgdmFyIHN1cHN1YjtcbiAgICBpZiAoIWdyb3VwLnZhbHVlLnN1cCkge1xuICAgICAgICAvLyBSdWxlIDE4YlxuICAgICAgICBzdWJTaGlmdCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgc3ViU2hpZnQsIHN0eWxlLm1ldHJpY3Muc3ViMSxcbiAgICAgICAgICAgIHN1Yi5oZWlnaHQgLSAwLjggKiBzdHlsZS5tZXRyaWNzLnhIZWlnaHQpO1xuXG4gICAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IHN1Ym1pZH1cbiAgICAgICAgXSwgXCJzaGlmdFwiLCBzdWJTaGlmdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgc3Vwc3ViLmNoaWxkcmVuWzBdLnN0eWxlLm1hcmdpblJpZ2h0ID0gc2NyaXB0c3BhY2U7XG5cbiAgICAgICAgLy8gU3Vic2NyaXB0cyBzaG91bGRuJ3QgYmUgc2hpZnRlZCBieSB0aGUgYmFzZSdzIGl0YWxpYyBjb3JyZWN0aW9uLlxuICAgICAgICAvLyBBY2NvdW50IGZvciB0aGF0IGJ5IHNoaWZ0aW5nIHRoZSBzdWJzY3JpcHQgYmFjayB0aGUgYXBwcm9wcmlhdGVcbiAgICAgICAgLy8gYW1vdW50LiBOb3RlIHdlIG9ubHkgZG8gdGhpcyB3aGVuIHRoZSBiYXNlIGlzIGEgc2luZ2xlIHN5bWJvbC5cbiAgICAgICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBkb21UcmVlLnN5bWJvbE5vZGUpIHtcbiAgICAgICAgICAgIHN1cHN1Yi5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5MZWZ0ID0gLWJhc2UuaXRhbGljICsgXCJlbVwiO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghZ3JvdXAudmFsdWUuc3ViKSB7XG4gICAgICAgIC8vIFJ1bGUgMThjLCBkXG4gICAgICAgIHN1cFNoaWZ0ID0gTWF0aC5tYXgoc3VwU2hpZnQsIG1pblN1cFNoaWZ0LFxuICAgICAgICAgICAgc3VwLmRlcHRoICsgMC4yNSAqIHN0eWxlLm1ldHJpY3MueEhlaWdodCk7XG5cbiAgICAgICAgc3Vwc3ViID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkfVxuICAgICAgICBdLCBcInNoaWZ0XCIsIC1zdXBTaGlmdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgc3Vwc3ViLmNoaWxkcmVuWzBdLnN0eWxlLm1hcmdpblJpZ2h0ID0gc2NyaXB0c3BhY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3VwU2hpZnQgPSBNYXRoLm1heChcbiAgICAgICAgICAgIHN1cFNoaWZ0LCBtaW5TdXBTaGlmdCwgc3VwLmRlcHRoICsgMC4yNSAqIHN0eWxlLm1ldHJpY3MueEhlaWdodCk7XG4gICAgICAgIHN1YlNoaWZ0ID0gTWF0aC5tYXgoc3ViU2hpZnQsIHN0eWxlLm1ldHJpY3Muc3ViMik7XG5cbiAgICAgICAgdmFyIHJ1bGVXaWR0aCA9IGZvbnRNZXRyaWNzLm1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3M7XG5cbiAgICAgICAgLy8gUnVsZSAxOGVcbiAgICAgICAgaWYgKChzdXBTaGlmdCAtIHN1cC5kZXB0aCkgLSAoc3ViLmhlaWdodCAtIHN1YlNoaWZ0KSA8XG4gICAgICAgICAgICAgICAgNCAqIHJ1bGVXaWR0aCkge1xuICAgICAgICAgICAgc3ViU2hpZnQgPSA0ICogcnVsZVdpZHRoIC0gKHN1cFNoaWZ0IC0gc3VwLmRlcHRoKSArIHN1Yi5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgcHNpID0gMC44ICogc3R5bGUubWV0cmljcy54SGVpZ2h0IC0gKHN1cFNoaWZ0IC0gc3VwLmRlcHRoKTtcbiAgICAgICAgICAgIGlmIChwc2kgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3VwU2hpZnQgKz0gcHNpO1xuICAgICAgICAgICAgICAgIHN1YlNoaWZ0IC09IHBzaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IHN1Ym1pZCwgc2hpZnQ6IHN1YlNoaWZ0fSxcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkLCBzaGlmdDogLXN1cFNoaWZ0fVxuICAgICAgICBdLCBcImluZGl2aWR1YWxTaGlmdFwiLCBudWxsLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBTZWUgY29tbWVudCBhYm92ZSBhYm91dCBzdWJzY3JpcHRzIG5vdCBiZWluZyBzaGlmdGVkXG4gICAgICAgIGlmIChiYXNlIGluc3RhbmNlb2YgZG9tVHJlZS5zeW1ib2xOb2RlKSB7XG4gICAgICAgICAgICBzdXBzdWIuY2hpbGRyZW5bMF0uc3R5bGUubWFyZ2luTGVmdCA9IC1iYXNlLml0YWxpYyArIFwiZW1cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cHN1Yi5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5SaWdodCA9IHNjcmlwdHNwYWNlO1xuICAgICAgICBzdXBzdWIuY2hpbGRyZW5bMV0uc3R5bGUubWFyZ2luUmlnaHQgPSBzY3JpcHRzcGFjZTtcbiAgICB9XG5cbiAgICAvLyBXZSBlbnN1cmUgdG8gd3JhcCB0aGUgc3Vwc3ViIHZsaXN0IGluIGEgc3Bhbi5tc3Vwc3ViIHRvIHJlc2V0IHRleHQtYWxpZ25cbiAgICB2YXIgbWNsYXNzID0gZ2V0VHlwZU9mRG9tVHJlZShiYXNlKSB8fCBcIm1vcmRcIjtcbiAgICByZXR1cm4gbWFrZVNwYW4oW21jbGFzc10sXG4gICAgICAgIFtiYXNlLCBtYWtlU3BhbihbXCJtc3Vwc3ViXCJdLCBbc3Vwc3ViXSldLFxuICAgICAgICBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMuZ2VuZnJhYyA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gRnJhY3Rpb25zIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIG9uIHBhZ2VzIDQ0NC00NDUsIHJ1bGVzIDE1KGEtZSkuXG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHRoaXMgZnJhY3Rpb24gc2hvdWxkIGJlIGluIGJhc2VkIG9uIHRoZVxuICAgIC8vIGZ1bmN0aW9uIHVzZWRcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGlmIChncm91cC52YWx1ZS5zaXplID09PSBcImRpc3BsYXlcIikge1xuICAgICAgICBzdHlsZSA9IFN0eWxlLkRJU1BMQVk7XG4gICAgfSBlbHNlIGlmIChncm91cC52YWx1ZS5zaXplID09PSBcInRleHRcIikge1xuICAgICAgICBzdHlsZSA9IFN0eWxlLlRFWFQ7XG4gICAgfVxuXG4gICAgdmFyIG5zdHlsZSA9IHN0eWxlLmZyYWNOdW0oKTtcbiAgICB2YXIgZHN0eWxlID0gc3R5bGUuZnJhY0RlbigpO1xuICAgIHZhciBuZXdPcHRpb25zO1xuXG4gICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aFN0eWxlKG5zdHlsZSk7XG4gICAgdmFyIG51bWVyID0gYnVpbGRHcm91cChncm91cC52YWx1ZS5udW1lciwgbmV3T3B0aW9ucyk7XG4gICAgdmFyIG51bWVycmVzZXQgPSBtYWtlU3Bhbihbc3R5bGUucmVzZXQoKSwgbnN0eWxlLmNscygpXSxcbiAgICAgICAgW251bWVyXSwgbmV3T3B0aW9ucyk7XG5cbiAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoZHN0eWxlKTtcbiAgICB2YXIgZGVub20gPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmRlbm9tLCBuZXdPcHRpb25zKTtcbiAgICB2YXIgZGVub21yZXNldCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBkc3R5bGUuY2xzKCldLFxuICAgICAgICBbZGVub21dLCBuZXdPcHRpb25zKTtcblxuICAgIHZhciBydWxlV2lkdGg7XG4gICAgaWYgKGdyb3VwLnZhbHVlLmhhc0JhckxpbmUpIHtcbiAgICAgICAgcnVsZVdpZHRoID0gZm9udE1ldHJpY3MubWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzcyAvXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlLnNpemVNdWx0aXBsaWVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJ1bGVXaWR0aCA9IDA7XG4gICAgfVxuXG4gICAgLy8gUnVsZSAxNWJcbiAgICB2YXIgbnVtU2hpZnQ7XG4gICAgdmFyIGNsZWFyYW5jZTtcbiAgICB2YXIgZGVub21TaGlmdDtcbiAgICBpZiAoc3R5bGUuc2l6ZSA9PT0gU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgICAgIG51bVNoaWZ0ID0gc3R5bGUubWV0cmljcy5udW0xO1xuICAgICAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgY2xlYXJhbmNlID0gMyAqIHJ1bGVXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyYW5jZSA9IDcgKiBmb250TWV0cmljcy5tZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGRlbm9tU2hpZnQgPSBzdHlsZS5tZXRyaWNzLmRlbm9tMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgbnVtU2hpZnQgPSBzdHlsZS5tZXRyaWNzLm51bTI7XG4gICAgICAgICAgICBjbGVhcmFuY2UgPSBydWxlV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1TaGlmdCA9IHN0eWxlLm1ldHJpY3MubnVtMztcbiAgICAgICAgICAgIGNsZWFyYW5jZSA9IDMgKiBmb250TWV0cmljcy5tZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGRlbm9tU2hpZnQgPSBzdHlsZS5tZXRyaWNzLmRlbm9tMjtcbiAgICB9XG5cbiAgICB2YXIgZnJhYztcbiAgICBpZiAocnVsZVdpZHRoID09PSAwKSB7XG4gICAgICAgIC8vIFJ1bGUgMTVjXG4gICAgICAgIHZhciBjYW5kaWRhdGVDbGVhcmFuY2UgPVxuICAgICAgICAgICAgKG51bVNoaWZ0IC0gbnVtZXIuZGVwdGgpIC0gKGRlbm9tLmhlaWdodCAtIGRlbm9tU2hpZnQpO1xuICAgICAgICBpZiAoY2FuZGlkYXRlQ2xlYXJhbmNlIDwgY2xlYXJhbmNlKSB7XG4gICAgICAgICAgICBudW1TaGlmdCArPSAwLjUgKiAoY2xlYXJhbmNlIC0gY2FuZGlkYXRlQ2xlYXJhbmNlKTtcbiAgICAgICAgICAgIGRlbm9tU2hpZnQgKz0gMC41ICogKGNsZWFyYW5jZSAtIGNhbmRpZGF0ZUNsZWFyYW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFjID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogZGVub21yZXNldCwgc2hpZnQ6IGRlbm9tU2hpZnR9LFxuICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBudW1lcnJlc2V0LCBzaGlmdDogLW51bVNoaWZ0fVxuICAgICAgICBdLCBcImluZGl2aWR1YWxTaGlmdFwiLCBudWxsLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSdWxlIDE1ZFxuICAgICAgICB2YXIgYXhpc0hlaWdodCA9IHN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodDtcblxuICAgICAgICBpZiAoKG51bVNoaWZ0IC0gbnVtZXIuZGVwdGgpIC0gKGF4aXNIZWlnaHQgKyAwLjUgKiBydWxlV2lkdGgpIDxcbiAgICAgICAgICAgICAgICBjbGVhcmFuY2UpIHtcbiAgICAgICAgICAgIG51bVNoaWZ0ICs9XG4gICAgICAgICAgICAgICAgY2xlYXJhbmNlIC0gKChudW1TaGlmdCAtIG51bWVyLmRlcHRoKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChheGlzSGVpZ2h0ICsgMC41ICogcnVsZVdpZHRoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGgpIC0gKGRlbm9tLmhlaWdodCAtIGRlbm9tU2hpZnQpIDxcbiAgICAgICAgICAgICAgICBjbGVhcmFuY2UpIHtcbiAgICAgICAgICAgIGRlbm9tU2hpZnQgKz1cbiAgICAgICAgICAgICAgICBjbGVhcmFuY2UgLSAoKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRlbm9tLmhlaWdodCAtIGRlbm9tU2hpZnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaWQgPSBtYWtlU3BhbihcbiAgICAgICAgICAgIFtvcHRpb25zLnN0eWxlLnJlc2V0KCksIFN0eWxlLlRFWFQuY2xzKCksIFwiZnJhYy1saW5lXCJdKTtcbiAgICAgICAgLy8gTWFudWFsbHkgc2V0IHRoZSBoZWlnaHQgb2YgdGhlIGxpbmUgYmVjYXVzZSBpdHMgaGVpZ2h0IGlzXG4gICAgICAgIC8vIGNyZWF0ZWQgaW4gQ1NTXG4gICAgICAgIG1pZC5oZWlnaHQgPSBydWxlV2lkdGg7XG5cbiAgICAgICAgdmFyIG1pZFNoaWZ0ID0gLShheGlzSGVpZ2h0IC0gMC41ICogcnVsZVdpZHRoKTtcblxuICAgICAgICBmcmFjID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogZGVub21yZXNldCwgc2hpZnQ6IGRlbm9tU2hpZnR9LFxuICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBtaWQsICAgICAgICBzaGlmdDogbWlkU2hpZnR9LFxuICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBudW1lcnJlc2V0LCBzaGlmdDogLW51bVNoaWZ0fVxuICAgICAgICBdLCBcImluZGl2aWR1YWxTaGlmdFwiLCBudWxsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBTaW5jZSB3ZSBtYW51YWxseSBjaGFuZ2UgdGhlIHN0eWxlIHNvbWV0aW1lcyAod2l0aCBcXGRmcmFjIG9yIFxcdGZyYWMpLFxuICAgIC8vIGFjY291bnQgZm9yIHRoZSBwb3NzaWJsZSBzaXplIGNoYW5nZSBoZXJlLlxuICAgIGZyYWMuaGVpZ2h0ICo9IHN0eWxlLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICBmcmFjLmRlcHRoICo9IHN0eWxlLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIC8vIFJ1bGUgMTVlXG4gICAgdmFyIGRlbGltU2l6ZTtcbiAgICBpZiAoc3R5bGUuc2l6ZSA9PT0gU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgICAgIGRlbGltU2l6ZSA9IHN0eWxlLm1ldHJpY3MuZGVsaW0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGltU2l6ZSA9IHN0eWxlLm1ldHJpY3MuZGVsaW0yO1xuICAgIH1cblxuICAgIHZhciBsZWZ0RGVsaW07XG4gICAgdmFyIHJpZ2h0RGVsaW07XG4gICAgaWYgKGdyb3VwLnZhbHVlLmxlZnREZWxpbSA9PSBudWxsKSB7XG4gICAgICAgIGxlZnREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1vcGVuXCJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0RGVsaW0gPSBkZWxpbWl0ZXIuY3VzdG9tU2l6ZWREZWxpbShcbiAgICAgICAgICAgIGdyb3VwLnZhbHVlLmxlZnREZWxpbSwgZGVsaW1TaXplLCB0cnVlLFxuICAgICAgICAgICAgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUpLCBncm91cC5tb2RlLCBbXCJtb3BlblwiXSk7XG4gICAgfVxuICAgIGlmIChncm91cC52YWx1ZS5yaWdodERlbGltID09IG51bGwpIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1jbG9zZVwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IGRlbGltaXRlci5jdXN0b21TaXplZERlbGltKFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUucmlnaHREZWxpbSwgZGVsaW1TaXplLCB0cnVlLFxuICAgICAgICAgICAgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUpLCBncm91cC5tb2RlLCBbXCJtY2xvc2VcIl0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlU3BhbihcbiAgICAgICAgW1wibW9yZFwiLCBvcHRpb25zLnN0eWxlLnJlc2V0KCksIHN0eWxlLmNscygpXSxcbiAgICAgICAgW2xlZnREZWxpbSwgbWFrZVNwYW4oW1wibWZyYWNcIl0sIFtmcmFjXSksIHJpZ2h0RGVsaW1dLFxuICAgICAgICBvcHRpb25zKTtcbn07XG5cbnZhciBjYWxjdWxhdGVTaXplID0gZnVuY3Rpb24oc2l6ZVZhbHVlLCBzdHlsZSkge1xuICAgIHZhciB4ID0gc2l6ZVZhbHVlLm51bWJlcjtcbiAgICBpZiAoc2l6ZVZhbHVlLnVuaXQgPT09IFwiZXhcIikge1xuICAgICAgICB4ICo9IHN0eWxlLm1ldHJpY3MuZW1QZXJFeDtcbiAgICB9IGVsc2UgaWYgKHNpemVWYWx1ZS51bml0ID09PSBcIm11XCIpIHtcbiAgICAgICAgeCAvPSAxODtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59O1xuXG5ncm91cFR5cGVzLmFycmF5ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgcjtcbiAgICB2YXIgYztcbiAgICB2YXIgbnIgPSBncm91cC52YWx1ZS5ib2R5Lmxlbmd0aDtcbiAgICB2YXIgbmMgPSAwO1xuICAgIHZhciBib2R5ID0gbmV3IEFycmF5KG5yKTtcblxuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgICAvLyBIb3Jpem9udGFsIHNwYWNpbmdcbiAgICB2YXIgcHQgPSAxIC8gZm9udE1ldHJpY3MubWV0cmljcy5wdFBlckVtO1xuICAgIHZhciBhcnJheWNvbHNlcCA9IDUgKiBwdDsgLy8gXFxhcnJheWNvbHNlcCBpbiBhcnRpY2xlLmNsc1xuXG4gICAgLy8gVmVydGljYWwgc3BhY2luZ1xuICAgIHZhciBiYXNlbGluZXNraXAgPSAxMiAqIHB0OyAvLyBzZWUgc2l6ZTEwLmNsb1xuICAgIC8vIERlZmF1bHQgXFxhcnJheXN0cmV0Y2ggZnJvbSBsdHRhYi5kdHhcbiAgICAvLyBUT0RPKGdhZ2Vybik6IG1heSBnZXQgcmVkZWZpbmVkIG9uY2Ugd2UgaGF2ZSB1c2VyLWRlZmluZWQgbWFjcm9zXG4gICAgdmFyIGFycmF5c3RyZXRjaCA9IHV0aWxzLmRlZmx0KGdyb3VwLnZhbHVlLmFycmF5c3RyZXRjaCwgMSk7XG4gICAgdmFyIGFycmF5c2tpcCA9IGFycmF5c3RyZXRjaCAqIGJhc2VsaW5lc2tpcDtcbiAgICB2YXIgYXJzdHJ1dEhlaWdodCA9IDAuNyAqIGFycmF5c2tpcDsgLy8gXFxzdHJ1dGJveCBpbiBsdGZzc3RyYy5kdHggYW5kXG4gICAgdmFyIGFyc3RydXREZXB0aCA9IDAuMyAqIGFycmF5c2tpcDsgIC8vIFxcQGFyc3RydXRib3ggaW4gbHR0YWIuZHR4XG5cbiAgICB2YXIgdG90YWxIZWlnaHQgPSAwO1xuICAgIGZvciAociA9IDA7IHIgPCBncm91cC52YWx1ZS5ib2R5Lmxlbmd0aDsgKytyKSB7XG4gICAgICAgIHZhciBpbnJvdyA9IGdyb3VwLnZhbHVlLmJvZHlbcl07XG4gICAgICAgIHZhciBoZWlnaHQgPSBhcnN0cnV0SGVpZ2h0OyAvLyBcXEBhcnJheSBhZGRzIGFuIFxcQGFyc3RydXRcbiAgICAgICAgdmFyIGRlcHRoID0gYXJzdHJ1dERlcHRoOyAgIC8vIHRvIGVhY2ggdG93ICh2aWEgdGhlIHRlbXBsYXRlKVxuXG4gICAgICAgIGlmIChuYyA8IGlucm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgbmMgPSBpbnJvdy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cm93ID0gbmV3IEFycmF5KGlucm93Lmxlbmd0aCk7XG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCBpbnJvdy5sZW5ndGg7ICsrYykge1xuICAgICAgICAgICAgdmFyIGVsdCA9IGJ1aWxkR3JvdXAoaW5yb3dbY10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGRlcHRoIDwgZWx0LmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgZGVwdGggPSBlbHQuZGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgZWx0LmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGVsdC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRyb3dbY10gPSBlbHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2FwID0gMDtcbiAgICAgICAgaWYgKGdyb3VwLnZhbHVlLnJvd0dhcHNbcl0pIHtcbiAgICAgICAgICAgIGdhcCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAudmFsdWUucm93R2Fwc1tyXS52YWx1ZSwgc3R5bGUpO1xuICAgICAgICAgICAgaWYgKGdhcCA+IDApIHsgLy8gXFxAYXJnYXJyYXljclxuICAgICAgICAgICAgICAgIGdhcCArPSBhcnN0cnV0RGVwdGg7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDwgZ2FwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZ2FwOyAvLyBcXEB4YXJnYXJyYXljclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnYXAgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cm93LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgb3V0cm93LmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGhlaWdodDtcbiAgICAgICAgb3V0cm93LnBvcyA9IHRvdGFsSGVpZ2h0O1xuICAgICAgICB0b3RhbEhlaWdodCArPSBkZXB0aCArIGdhcDsgLy8gXFxAeWFyZ2FycmF5Y3JcbiAgICAgICAgYm9keVtyXSA9IG91dHJvdztcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gdG90YWxIZWlnaHQgLyAyICsgc3R5bGUubWV0cmljcy5heGlzSGVpZ2h0O1xuICAgIHZhciBjb2xEZXNjcmlwdGlvbnMgPSBncm91cC52YWx1ZS5jb2xzIHx8IFtdO1xuICAgIHZhciBjb2xzID0gW107XG4gICAgdmFyIGNvbFNlcDtcbiAgICB2YXIgY29sRGVzY3JOdW07XG4gICAgZm9yIChjID0gMCwgY29sRGVzY3JOdW0gPSAwO1xuICAgICAgICAgLy8gQ29udGludWUgd2hpbGUgZWl0aGVyIHRoZXJlIGFyZSBtb3JlIGNvbHVtbnMgb3IgbW9yZSBjb2x1bW5cbiAgICAgICAgIC8vIGRlc2NyaXB0aW9ucywgc28gdHJhaWxpbmcgc2VwYXJhdG9ycyBkb24ndCBnZXQgbG9zdC5cbiAgICAgICAgIGMgPCBuYyB8fCBjb2xEZXNjck51bSA8IGNvbERlc2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgICArK2MsICsrY29sRGVzY3JOdW0pIHtcblxuICAgICAgICB2YXIgY29sRGVzY3IgPSBjb2xEZXNjcmlwdGlvbnNbY29sRGVzY3JOdW1dIHx8IHt9O1xuXG4gICAgICAgIHZhciBmaXJzdFNlcGFyYXRvciA9IHRydWU7XG4gICAgICAgIHdoaWxlIChjb2xEZXNjci50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHNlcGFyYXRvciBpbiBhIHJvdywgYWRkIGEgc3BhY2VcbiAgICAgICAgICAgIC8vIGJldHdlZW4gdGhlbS5cbiAgICAgICAgICAgIGlmICghZmlyc3RTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb2xTZXAgPSBtYWtlU3BhbihbXCJhcnJheWNvbHNlcFwiXSwgW10pO1xuICAgICAgICAgICAgICAgIGNvbFNlcC5zdHlsZS53aWR0aCA9XG4gICAgICAgICAgICAgICAgICAgIGZvbnRNZXRyaWNzLm1ldHJpY3MuZG91YmxlUnVsZVNlcCArIFwiZW1cIjtcbiAgICAgICAgICAgICAgICBjb2xzLnB1c2goY29sU2VwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbERlc2NyLnNlcGFyYXRvciA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gbWFrZVNwYW4oXG4gICAgICAgICAgICAgICAgICAgIFtcInZlcnRpY2FsLXNlcGFyYXRvclwiXSxcbiAgICAgICAgICAgICAgICAgICAgW10pO1xuICAgICAgICAgICAgICAgIHNlcGFyYXRvci5zdHlsZS5oZWlnaHQgPSB0b3RhbEhlaWdodCArIFwiZW1cIjtcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3Iuc3R5bGUudmVydGljYWxBbGlnbiA9XG4gICAgICAgICAgICAgICAgICAgIC0odG90YWxIZWlnaHQgLSBvZmZzZXQpICsgXCJlbVwiO1xuXG4gICAgICAgICAgICAgICAgY29scy5wdXNoKHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkludmFsaWQgc2VwYXJhdG9yIHR5cGU6IFwiICsgY29sRGVzY3Iuc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sRGVzY3JOdW0rKztcbiAgICAgICAgICAgIGNvbERlc2NyID0gY29sRGVzY3JpcHRpb25zW2NvbERlc2NyTnVtXSB8fCB7fTtcbiAgICAgICAgICAgIGZpcnN0U2VwYXJhdG9yID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA+PSBuYykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Vwd2lkdGg7XG4gICAgICAgIGlmIChjID4gMCB8fCBncm91cC52YWx1ZS5oc2tpcEJlZm9yZUFuZEFmdGVyKSB7XG4gICAgICAgICAgICBzZXB3aWR0aCA9IHV0aWxzLmRlZmx0KGNvbERlc2NyLnByZWdhcCwgYXJyYXljb2xzZXApO1xuICAgICAgICAgICAgaWYgKHNlcHdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29sU2VwID0gbWFrZVNwYW4oW1wiYXJyYXljb2xzZXBcIl0sIFtdKTtcbiAgICAgICAgICAgICAgICBjb2xTZXAuc3R5bGUud2lkdGggPSBzZXB3aWR0aCArIFwiZW1cIjtcbiAgICAgICAgICAgICAgICBjb2xzLnB1c2goY29sU2VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2wgPSBbXTtcbiAgICAgICAgZm9yIChyID0gMDsgciA8IG5yOyArK3IpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBib2R5W3JdO1xuICAgICAgICAgICAgdmFyIGVsZW0gPSByb3dbY107XG4gICAgICAgICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaGlmdCA9IHJvdy5wb3MgLSBvZmZzZXQ7XG4gICAgICAgICAgICBlbGVtLmRlcHRoID0gcm93LmRlcHRoO1xuICAgICAgICAgICAgZWxlbS5oZWlnaHQgPSByb3cuaGVpZ2h0O1xuICAgICAgICAgICAgY29sLnB1c2goe3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBlbGVtLCBzaGlmdDogc2hpZnR9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChjb2wsIFwiaW5kaXZpZHVhbFNoaWZ0XCIsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICBjb2wgPSBtYWtlU3BhbihcbiAgICAgICAgICAgIFtcImNvbC1hbGlnbi1cIiArIChjb2xEZXNjci5hbGlnbiB8fCBcImNcIildLFxuICAgICAgICAgICAgW2NvbF0pO1xuICAgICAgICBjb2xzLnB1c2goY29sKTtcblxuICAgICAgICBpZiAoYyA8IG5jIC0gMSB8fCBncm91cC52YWx1ZS5oc2tpcEJlZm9yZUFuZEFmdGVyKSB7XG4gICAgICAgICAgICBzZXB3aWR0aCA9IHV0aWxzLmRlZmx0KGNvbERlc2NyLnBvc3RnYXAsIGFycmF5Y29sc2VwKTtcbiAgICAgICAgICAgIGlmIChzZXB3aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbFNlcCA9IG1ha2VTcGFuKFtcImFycmF5Y29sc2VwXCJdLCBbXSk7XG4gICAgICAgICAgICAgICAgY29sU2VwLnN0eWxlLndpZHRoID0gc2Vwd2lkdGggKyBcImVtXCI7XG4gICAgICAgICAgICAgICAgY29scy5wdXNoKGNvbFNlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYm9keSA9IG1ha2VTcGFuKFtcIm10YWJsZVwiXSwgY29scyk7XG4gICAgcmV0dXJuIG1ha2VTcGFuKFtcIm1vcmRcIl0sIFtib2R5XSwgb3B0aW9ucyk7XG59O1xuXG5ncm91cFR5cGVzLnNwYWNpbmcgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIGlmIChncm91cC52YWx1ZSA9PT0gXCJcXFxcIFwiIHx8IGdyb3VwLnZhbHVlID09PSBcIlxcXFxzcGFjZVwiIHx8XG4gICAgICAgIGdyb3VwLnZhbHVlID09PSBcIiBcIiB8fCBncm91cC52YWx1ZSA9PT0gXCJ+XCIpIHtcbiAgICAgICAgLy8gU3BhY2VzIGFyZSBnZW5lcmF0ZWQgYnkgYWRkaW5nIGFuIGFjdHVhbCBzcGFjZS4gRWFjaCBvZiB0aGVzZVxuICAgICAgICAvLyB0aGluZ3MgaGFzIGFuIGVudHJ5IGluIHRoZSBzeW1ib2xzIHRhYmxlLCBzbyB0aGVzZSB3aWxsIGJlIHR1cm5lZFxuICAgICAgICAvLyBpbnRvIGFwcHJvcHJpYXRlIG91dHB1dHMuXG4gICAgICAgIGlmIChncm91cC5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwidGV4dG9yZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlU3BhbihbXCJtc3BhY2VcIl0sXG4gICAgICAgICAgICAgICAgW2J1aWxkQ29tbW9uLm1hdGhzeW0oZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUsIG9wdGlvbnMpXSxcbiAgICAgICAgICAgICAgICBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyIGtpbmRzIG9mIHNwYWNlcyBhcmUgb2YgYXJiaXRyYXJ5IHdpZHRoLiBXZSB1c2UgQ1NTIHRvXG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZXNlLlxuICAgICAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgICAgICBbXCJtc3BhY2VcIixcbiAgICAgICAgICAgICAgICBidWlsZENvbW1vbi5zcGFjaW5nRnVuY3Rpb25zW2dyb3VwLnZhbHVlXS5jbGFzc05hbWVdLFxuICAgICAgICAgICAgW10sIG9wdGlvbnMpO1xuICAgIH1cbn07XG5cbmdyb3VwVHlwZXMubGxhcCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImlubmVyXCJdLCBbYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zLnJlc2V0KCkpXSk7XG4gICAgdmFyIGZpeCA9IG1ha2VTcGFuKFtcImZpeFwiXSwgW10pO1xuICAgIHJldHVybiBtYWtlU3BhbihcbiAgICAgICAgW1wibW9yZFwiLCBcImxsYXBcIiwgb3B0aW9ucy5zdHlsZS5jbHMoKV0sIFtpbm5lciwgZml4XSwgb3B0aW9ucyk7XG59O1xuXG5ncm91cFR5cGVzLnJsYXAgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBpbm5lciA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJpbm5lclwiXSwgW2J1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy5yZXNldCgpKV0pO1xuICAgIHZhciBmaXggPSBtYWtlU3BhbihbXCJmaXhcIl0sIFtdKTtcbiAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgIFtcIm1vcmRcIiwgXCJybGFwXCIsIG9wdGlvbnMuc3R5bGUuY2xzKCldLCBbaW5uZXIsIGZpeF0sIG9wdGlvbnMpO1xufTtcblxuZ3JvdXBUeXBlcy5vcCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gT3BlcmF0b3JzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMtNDQ0LCBydWxlIDEzKGEpLlxuICAgIHZhciBzdXBHcm91cDtcbiAgICB2YXIgc3ViR3JvdXA7XG4gICAgdmFyIGhhc0xpbWl0cyA9IGZhbHNlO1xuICAgIGlmIChncm91cC50eXBlID09PSBcInN1cHN1YlwiKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbGltaXRzLCBzdXBzdWIgd2lsbCBwYXNzIHVzIGl0cyBncm91cCB0byBoYW5kbGUuIFB1bGxcbiAgICAgICAgLy8gb3V0IHRoZSBzdXBlcnNjcmlwdCBhbmQgc3Vic2NyaXB0IGFuZCBzZXQgdGhlIGdyb3VwIHRvIHRoZSBvcCBpblxuICAgICAgICAvLyBpdHMgYmFzZS5cbiAgICAgICAgc3VwR3JvdXAgPSBncm91cC52YWx1ZS5zdXA7XG4gICAgICAgIHN1Ykdyb3VwID0gZ3JvdXAudmFsdWUuc3ViO1xuICAgICAgICBncm91cCA9IGdyb3VwLnZhbHVlLmJhc2U7XG4gICAgICAgIGhhc0xpbWl0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIC8vIE1vc3Qgb3BlcmF0b3JzIGhhdmUgYSBsYXJnZSBzdWNjZXNzb3Igc3ltYm9sLCBidXQgdGhlc2UgZG9uJ3QuXG4gICAgdmFyIG5vU3VjY2Vzc29yID0gW1xuICAgICAgICBcIlxcXFxzbWFsbGludFwiXG4gICAgXTtcblxuICAgIHZhciBsYXJnZSA9IGZhbHNlO1xuICAgIGlmIChzdHlsZS5zaXplID09PSBTdHlsZS5ESVNQTEFZLnNpemUgJiZcbiAgICAgICAgZ3JvdXAudmFsdWUuc3ltYm9sICYmXG4gICAgICAgICF1dGlscy5jb250YWlucyhub1N1Y2Nlc3NvciwgZ3JvdXAudmFsdWUuYm9keSkpIHtcblxuICAgICAgICAvLyBNb3N0IHN5bWJvbCBvcGVyYXRvcnMgZ2V0IGxhcmdlciBpbiBkaXNwbGF5c3R5bGUgKHJ1bGUgMTMpXG4gICAgICAgIGxhcmdlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZTtcbiAgICB2YXIgYmFzZVNoaWZ0ID0gMDtcbiAgICB2YXIgc2xhbnQgPSAwO1xuICAgIGlmIChncm91cC52YWx1ZS5zeW1ib2wpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN5bWJvbCwgY3JlYXRlIHRoZSBzeW1ib2wuXG4gICAgICAgIHZhciBmb250TmFtZSA9IGxhcmdlID8gXCJTaXplMi1SZWd1bGFyXCIgOiBcIlNpemUxLVJlZ3VsYXJcIjtcbiAgICAgICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woXG4gICAgICAgICAgICBncm91cC52YWx1ZS5ib2R5LCBmb250TmFtZSwgXCJtYXRoXCIsIG9wdGlvbnMsXG4gICAgICAgICAgICBbXCJtb3BcIiwgXCJvcC1zeW1ib2xcIiwgbGFyZ2UgPyBcImxhcmdlLW9wXCIgOiBcInNtYWxsLW9wXCJdKTtcblxuICAgICAgICAvLyBTaGlmdCB0aGUgc3ltYm9sIHNvIGl0cyBjZW50ZXIgbGllcyBvbiB0aGUgYXhpcyAocnVsZSAxMykuIEl0XG4gICAgICAgIC8vIGFwcGVhcnMgdGhhdCBvdXIgZm9udHMgaGF2ZSB0aGUgY2VudGVycyBvZiB0aGUgc3ltYm9scyBhbHJlYWR5XG4gICAgICAgIC8vIGFsbW9zdCBvbiB0aGUgYXhpcywgc28gdGhlc2UgbnVtYmVycyBhcmUgdmVyeSBzbWFsbC4gTm90ZSB3ZVxuICAgICAgICAvLyBkb24ndCBhY3R1YWxseSBhcHBseSB0aGlzIGhlcmUsIGJ1dCBpbnN0ZWFkIGl0IGlzIHVzZWQgZWl0aGVyIGluXG4gICAgICAgIC8vIHRoZSB2bGlzdCBjcmVhdGlvbiBvciBzZXBhcmF0ZWx5IHdoZW4gdGhlcmUgYXJlIG5vIGxpbWl0cy5cbiAgICAgICAgYmFzZVNoaWZ0ID0gKGJhc2UuaGVpZ2h0IC0gYmFzZS5kZXB0aCkgLyAyIC1cbiAgICAgICAgICAgIHN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodCAqIHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgICAgIC8vIFRoZSBzbGFudCBvZiB0aGUgc3ltYm9sIGlzIGp1c3QgaXRzIGl0YWxpYyBjb3JyZWN0aW9uLlxuICAgICAgICBzbGFudCA9IGJhc2UuaXRhbGljO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudmFsdWUudmFsdWUpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGxpc3QsIGNvbXBvc2UgdGhhdCBsaXN0LlxuICAgICAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgIGJhc2UgPSBtYWtlU3BhbihbXCJtb3BcIl0sIGlubmVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgaXMgYSB0ZXh0IG9wZXJhdG9yLiBCdWlsZCB0aGUgdGV4dCBmcm9tIHRoZVxuICAgICAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgICAgIC8vIFRPRE8oZW1pbHkpOiBBZGQgYSBzcGFjZSBpbiB0aGUgbWlkZGxlIG9mIHNvbWUgb2YgdGhlc2VcbiAgICAgICAgLy8gb3BlcmF0b3JzLCBsaWtlIFxcbGltc3VwXG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBncm91cC52YWx1ZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChidWlsZENvbW1vbi5tYXRoc3ltKGdyb3VwLnZhbHVlLmJvZHlbaV0sIGdyb3VwLm1vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBiYXNlID0gbWFrZVNwYW4oW1wibW9wXCJdLCBvdXRwdXQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChoYXNMaW1pdHMpIHtcbiAgICAgICAgLy8gSUUgOCBjbGlwcyBcXGludCBpZiBpdCBpcyBpbiBhIGRpc3BsYXk6IGlubGluZS1ibG9jay4gV2Ugd3JhcCBpdFxuICAgICAgICAvLyBpbiBhIG5ldyBzcGFuIHNvIGl0IGlzIGFuIGlubGluZSwgYW5kIHdvcmtzLlxuICAgICAgICBiYXNlID0gbWFrZVNwYW4oW10sIFtiYXNlXSk7XG5cbiAgICAgICAgdmFyIHN1cG1pZDtcbiAgICAgICAgdmFyIHN1cEtlcm47XG4gICAgICAgIHZhciBzdWJtaWQ7XG4gICAgICAgIHZhciBzdWJLZXJuO1xuICAgICAgICB2YXIgbmV3T3B0aW9ucztcbiAgICAgICAgLy8gV2UgbWFudWFsbHkgaGF2ZSB0byBoYW5kbGUgdGhlIHN1cGVyc2NyaXB0cyBhbmQgc3Vic2NyaXB0cy4gVGhpcyxcbiAgICAgICAgLy8gYXNpZGUgZnJvbSB0aGUga2VybiBjYWxjdWxhdGlvbnMsIGlzIGNvcGllZCBmcm9tIHN1cHN1Yi5cbiAgICAgICAgaWYgKHN1cEdyb3VwKSB7XG4gICAgICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuc3VwKCkpO1xuICAgICAgICAgICAgdmFyIHN1cCA9IGJ1aWxkR3JvdXAoc3VwR3JvdXAsIG5ld09wdGlvbnMpO1xuICAgICAgICAgICAgc3VwbWlkID0gbWFrZVNwYW4oW3N0eWxlLnJlc2V0KCksIHN0eWxlLnN1cCgpLmNscygpXSxcbiAgICAgICAgICAgICAgICBbc3VwXSwgbmV3T3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHN1cEtlcm4gPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBmb250TWV0cmljcy5tZXRyaWNzLmJpZ09wU3BhY2luZzEsXG4gICAgICAgICAgICAgICAgZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmczIC0gc3VwLmRlcHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWJHcm91cCkge1xuICAgICAgICAgICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aFN0eWxlKHN0eWxlLnN1YigpKTtcbiAgICAgICAgICAgIHZhciBzdWIgPSBidWlsZEdyb3VwKHN1Ykdyb3VwLCBuZXdPcHRpb25zKTtcbiAgICAgICAgICAgIHN1Ym1pZCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBzdHlsZS5zdWIoKS5jbHMoKV0sXG4gICAgICAgICAgICAgICAgW3N1Yl0sIG5ld09wdGlvbnMpO1xuXG4gICAgICAgICAgICBzdWJLZXJuID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmcyLFxuICAgICAgICAgICAgICAgIGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNCAtIHN1Yi5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgdGhlIGZpbmFsIGdyb3VwIGFzIGEgdmxpc3Qgb2YgdGhlIHBvc3NpYmxlIHN1YnNjcmlwdCwgYmFzZSxcbiAgICAgICAgLy8gYW5kIHBvc3NpYmxlIHN1cGVyc2NyaXB0LlxuICAgICAgICB2YXIgZmluYWxHcm91cDtcbiAgICAgICAgdmFyIHRvcDtcbiAgICAgICAgdmFyIGJvdHRvbTtcbiAgICAgICAgaWYgKCFzdXBHcm91cCkge1xuICAgICAgICAgICAgdG9wID0gYmFzZS5oZWlnaHQgLSBiYXNlU2hpZnQ7XG5cbiAgICAgICAgICAgIGZpbmFsR3JvdXAgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoW1xuICAgICAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmc1fSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IHN1Ym1pZH0sXG4gICAgICAgICAgICAgICAge3R5cGU6IFwia2VyblwiLCBzaXplOiBzdWJLZXJufSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGJhc2V9XG4gICAgICAgICAgICBdLCBcInRvcFwiLCB0b3AsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBIZXJlLCB3ZSBzaGlmdCB0aGUgbGltaXRzIGJ5IHRoZSBzbGFudCBvZiB0aGUgc3ltYm9sLiBOb3RlXG4gICAgICAgICAgICAvLyB0aGF0IHdlIGFyZSBzdXBwb3NlZCB0byBzaGlmdCB0aGUgbGltaXRzIGJ5IDEvMiBvZiB0aGUgc2xhbnQsXG4gICAgICAgICAgICAvLyBidXQgc2luY2Ugd2UgYXJlIGNlbnRlcmluZyB0aGUgbGltaXRzIGFkZGluZyBhIGZ1bGwgc2xhbnQgb2ZcbiAgICAgICAgICAgIC8vIG1hcmdpbiB3aWxsIHNoaWZ0IGJ5IDEvMiB0aGF0LlxuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5MZWZ0ID0gLXNsYW50ICsgXCJlbVwiO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdWJHcm91cCkge1xuICAgICAgICAgICAgYm90dG9tID0gYmFzZS5kZXB0aCArIGJhc2VTaGlmdDtcblxuICAgICAgICAgICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBiYXNlfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IHN1cEtlcm59LFxuICAgICAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNX1cbiAgICAgICAgICAgIF0sIFwiYm90dG9tXCIsIGJvdHRvbSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIGFib3V0IHNsYW50c1xuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblsxXS5zdHlsZS5tYXJnaW5MZWZ0ID0gc2xhbnQgKyBcImVtXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN1cEdyb3VwICYmICFzdWJHcm91cCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYXNlIHByb2JhYmx5IHNob3VsZG4ndCBvY2N1ciAodGhpcyB3b3VsZCBtZWFuIHRoZVxuICAgICAgICAgICAgLy8gc3Vwc3ViIHdhcyBzZW5kaW5nIHVzIGEgZ3JvdXAgd2l0aCBubyBzdXBlcnNjcmlwdCBvclxuICAgICAgICAgICAgLy8gc3Vic2NyaXB0KSBidXQgYmUgc2FmZS5cbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm90dG9tID0gZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmc1ICtcbiAgICAgICAgICAgICAgICBzdWJtaWQuaGVpZ2h0ICsgc3VibWlkLmRlcHRoICtcbiAgICAgICAgICAgICAgICBzdWJLZXJuICtcbiAgICAgICAgICAgICAgICBiYXNlLmRlcHRoICsgYmFzZVNoaWZ0O1xuXG4gICAgICAgICAgICBmaW5hbEdyb3VwID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNX0sXG4gICAgICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBzdWJtaWR9LFxuICAgICAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogc3ViS2Vybn0sXG4gICAgICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBiYXNlfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IHN1cEtlcm59LFxuICAgICAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNX1cbiAgICAgICAgICAgIF0sIFwiYm90dG9tXCIsIGJvdHRvbSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIGFib3V0IHNsYW50c1xuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5MZWZ0ID0gLXNsYW50ICsgXCJlbVwiO1xuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblsyXS5zdHlsZS5tYXJnaW5MZWZ0ID0gc2xhbnQgKyBcImVtXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFrZVNwYW4oW1wibW9wXCIsIFwib3AtbGltaXRzXCJdLCBbZmluYWxHcm91cF0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChncm91cC52YWx1ZS5zeW1ib2wpIHtcbiAgICAgICAgICAgIGJhc2Uuc3R5bGUudG9wID0gYmFzZVNoaWZ0ICsgXCJlbVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufTtcblxuZ3JvdXBUeXBlcy5tb2QgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBpbm5lciA9IFtdO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwiYm1vZFwiKSB7XG4gICAgICAgIC8vIOKAnFxcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcFxcbWtlcm41bXXigJ1cbiAgICAgICAgaWYgKCFvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihcbiAgICAgICAgICAgICAgICBbXCJtc3BhY2VcIiwgXCJuZWdhdGl2ZW1lZGl1bXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oW1wibXNwYWNlXCIsIFwidGhpY2tzcGFjZVwiXSwgW10sIG9wdGlvbnMpKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3R5bGUuc2l6ZSA9PT0gU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oW1wibXNwYWNlXCIsIFwicXVhZFwiXSwgW10sIG9wdGlvbnMpKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwibW9kXCIpIHtcbiAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtc3BhY2VcIiwgXCJ0d2VsdmVtdXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oW1wibXNwYWNlXCIsIFwiZWlnaHRtdXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlID09PSBcInBvZFwiIHx8IGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwicG1vZFwiKSB7XG4gICAgICAgIGlubmVyLnB1c2goYnVpbGRDb21tb24ubWF0aHN5bShcIihcIiwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlICE9PSBcInBvZFwiKSB7XG4gICAgICAgIHZhciBtb2RJbm5lciA9IFtcbiAgICAgICAgICAgIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXCJtXCIsIGdyb3VwLm1vZGUpLFxuICAgICAgICAgICAgYnVpbGRDb21tb24ubWF0aHN5bShcIm9cIiwgZ3JvdXAubW9kZSksXG4gICAgICAgICAgICBidWlsZENvbW1vbi5tYXRoc3ltKFwiZFwiLCBncm91cC5tb2RlKV07XG4gICAgICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlID09PSBcImJtb2RcIikge1xuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtYmluXCJdLCBtb2RJbm5lciwgb3B0aW9ucykpO1xuICAgICAgICAgICAgLy8g4oCcXFxta2VybjVtdVxcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcOKAnVxuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtc3BhY2VcIiwgXCJ0aGlja3NwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgICAgICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oXG4gICAgICAgICAgICAgICAgICAgIFtcIm1zcGFjZVwiLCBcIm5lZ2F0aXZlbWVkaXVtc3BhY2VcIl0sIFtdLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpbm5lciwgbW9kSW5uZXIpO1xuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtc3BhY2VcIiwgXCJzaXhtdXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnZhbHVlKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGlubmVyLFxuICAgICAgICAgICAgYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLnZhbHVlLCBvcHRpb25zLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlID09PSBcInBvZFwiIHx8IGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwicG1vZFwiKSB7XG4gICAgICAgIGlubmVyLnB1c2goYnVpbGRDb21tb24ubWF0aHN5bShcIilcIiwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoaW5uZXIpO1xufTtcblxuZ3JvdXBUeXBlcy5rYXRleCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gVGhlIEthVGVYIGxvZ28uIFRoZSBvZmZzZXRzIGZvciB0aGUgSyBhbmQgYSB3ZXJlIGNob3NlbiB0byBsb29rXG4gICAgLy8gZ29vZCwgYnV0IHRoZSBvZmZzZXRzIGZvciB0aGUgVCwgRSwgYW5kIFggd2VyZSB0YWtlbiBmcm9tIHRoZVxuICAgIC8vIGRlZmluaXRpb24gb2YgXFxUZVggaW4gVGVYIChzZWUgVGVYYm9vayBwZy4gMzU2KVxuICAgIHZhciBrID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImtcIl0sIFtidWlsZENvbW1vbi5tYXRoc3ltKFwiS1wiLCBncm91cC5tb2RlKV0sIG9wdGlvbnMpO1xuICAgIHZhciBhID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImFcIl0sIFtidWlsZENvbW1vbi5tYXRoc3ltKFwiQVwiLCBncm91cC5tb2RlKV0sIG9wdGlvbnMpO1xuXG4gICAgYS5oZWlnaHQgPSAoYS5oZWlnaHQgKyAwLjIpICogMC43NTtcbiAgICBhLmRlcHRoID0gKGEuaGVpZ2h0IC0gMC4yKSAqIDAuNzU7XG5cbiAgICB2YXIgdCA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJ0XCJdLCBbYnVpbGRDb21tb24ubWF0aHN5bShcIlRcIiwgZ3JvdXAubW9kZSldLCBvcHRpb25zKTtcbiAgICB2YXIgZSA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJlXCJdLCBbYnVpbGRDb21tb24ubWF0aHN5bShcIkVcIiwgZ3JvdXAubW9kZSldLCBvcHRpb25zKTtcblxuICAgIGUuaGVpZ2h0ID0gKGUuaGVpZ2h0IC0gMC4yMTU1KTtcbiAgICBlLmRlcHRoID0gKGUuZGVwdGggKyAwLjIxNTUpO1xuXG4gICAgdmFyIHggPSBtYWtlU3BhbihcbiAgICAgICAgW1wieFwiXSwgW2J1aWxkQ29tbW9uLm1hdGhzeW0oXCJYXCIsIGdyb3VwLm1vZGUpXSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgIFtcIm1vcmRcIiwgXCJrYXRleC1sb2dvXCJdLCBbaywgYSwgdCwgZSwgeF0sIG9wdGlvbnMpO1xufTtcblxuZ3JvdXBUeXBlcy5vdmVybGluZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gT3ZlcmxpbmVzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnIDQ0MywgUnVsZSA5LlxuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgICAvLyBCdWlsZCB0aGUgaW5uZXIgZ3JvdXAgaW4gdGhlIGNyYW1wZWQgc3R5bGUuXG4gICAgdmFyIGlubmVyR3JvdXAgPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksXG4gICAgICAgICAgICBvcHRpb25zLndpdGhTdHlsZShzdHlsZS5jcmFtcCgpKSk7XG5cbiAgICB2YXIgcnVsZVdpZHRoID0gZm9udE1ldHJpY3MubWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzcyAvXG4gICAgICAgIHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBsaW5lIGFib3ZlIHRoZSBib2R5XG4gICAgdmFyIGxpbmUgPSBtYWtlU3BhbihcbiAgICAgICAgW3N0eWxlLnJlc2V0KCksIFN0eWxlLlRFWFQuY2xzKCksIFwib3ZlcmxpbmUtbGluZVwiXSk7XG4gICAgbGluZS5oZWlnaHQgPSBydWxlV2lkdGg7XG4gICAgbGluZS5tYXhGb250U2l6ZSA9IDEuMDtcblxuICAgIC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnNcbiAgICB2YXIgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoW1xuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGlubmVyR3JvdXB9LFxuICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IDMgKiBydWxlV2lkdGh9LFxuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGxpbmV9LFxuICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IHJ1bGVXaWR0aH1cbiAgICBdLCBcImZpcnN0QmFzZWxpbmVcIiwgbnVsbCwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oW1wibW9yZFwiLCBcIm92ZXJsaW5lXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMudW5kZXJsaW5lID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBVbmRlcmxpbmVzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnIDQ0MywgUnVsZSAxMC5cbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgLy8gQnVpbGQgdGhlIGlubmVyIGdyb3VwLlxuICAgIHZhciBpbm5lckdyb3VwID0gYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zKTtcblxuICAgIHZhciBydWxlV2lkdGggPSBmb250TWV0cmljcy5tZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzIC9cbiAgICAgICAgc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGxpbmUgYWJvdmUgdGhlIGJvZHlcbiAgICB2YXIgbGluZSA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBTdHlsZS5URVhULmNscygpLCBcInVuZGVybGluZS1saW5lXCJdKTtcbiAgICBsaW5lLmhlaWdodCA9IHJ1bGVXaWR0aDtcbiAgICBsaW5lLm1heEZvbnRTaXplID0gMS4wO1xuXG4gICAgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJuc1xuICAgIHZhciB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogcnVsZVdpZHRofSxcbiAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBsaW5lfSxcbiAgICAgICAge3R5cGU6IFwia2VyblwiLCBzaXplOiAzICogcnVsZVdpZHRofSxcbiAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBpbm5lckdyb3VwfVxuICAgIF0sIFwidG9wXCIsIGlubmVyR3JvdXAuaGVpZ2h0LCBvcHRpb25zKTtcblxuICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwidW5kZXJsaW5lXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMuc3FydCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3F1YXJlIHJvb3RzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMsIFJ1bGUgMTEuXG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIC8vIEZpcnN0LCB3ZSBkbyB0aGUgc2FtZSBzdGVwcyBhcyBpbiBvdmVybGluZSB0byBidWlsZCB0aGUgaW5uZXIgZ3JvdXBcbiAgICAvLyBhbmQgbGluZVxuICAgIHZhciBpbm5lciA9IGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuY3JhbXAoKSkpO1xuXG4gICAgdmFyIHJ1bGVXaWR0aCA9IGZvbnRNZXRyaWNzLm1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3MgL1xuICAgICAgICBzdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIHZhciBsaW5lID0gbWFrZVNwYW4oXG4gICAgICAgIFtzdHlsZS5yZXNldCgpLCBTdHlsZS5URVhULmNscygpLCBcInNxcnQtbGluZVwiXSwgW10sXG4gICAgICAgIG9wdGlvbnMpO1xuICAgIGxpbmUuaGVpZ2h0ID0gcnVsZVdpZHRoO1xuICAgIGxpbmUubWF4Rm9udFNpemUgPSAxLjA7XG5cbiAgICB2YXIgcGhpID0gcnVsZVdpZHRoO1xuICAgIGlmIChzdHlsZS5pZCA8IFN0eWxlLlRFWFQuaWQpIHtcbiAgICAgICAgcGhpID0gc3R5bGUubWV0cmljcy54SGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY2xlYXJhbmNlIGJldHdlZW4gdGhlIGJvZHkgYW5kIGxpbmVcbiAgICB2YXIgbGluZUNsZWFyYW5jZSA9IHJ1bGVXaWR0aCArIHBoaSAvIDQ7XG5cbiAgICB2YXIgaW5uZXJIZWlnaHQgPSAoaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGgpICogc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIG1pbkRlbGltaXRlckhlaWdodCA9IGlubmVySGVpZ2h0ICsgbGluZUNsZWFyYW5jZSArIHJ1bGVXaWR0aDtcblxuICAgIC8vIENyZWF0ZSBhIFxcc3VyZCBkZWxpbWl0ZXIgb2YgdGhlIHJlcXVpcmVkIG1pbmltdW0gc2l6ZVxuICAgIHZhciBkZWxpbSA9IG1ha2VTcGFuKFtcInNxcnQtc2lnblwiXSwgW1xuICAgICAgICBkZWxpbWl0ZXIuY3VzdG9tU2l6ZWREZWxpbShcIlxcXFxzdXJkXCIsIG1pbkRlbGltaXRlckhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIG9wdGlvbnMsIGdyb3VwLm1vZGUpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zKTtcblxuICAgIHZhciBkZWxpbURlcHRoID0gKGRlbGltLmhlaWdodCArIGRlbGltLmRlcHRoKSAtIHJ1bGVXaWR0aDtcblxuICAgIC8vIEFkanVzdCB0aGUgY2xlYXJhbmNlIGJhc2VkIG9uIHRoZSBkZWxpbWl0ZXIgc2l6ZVxuICAgIGlmIChkZWxpbURlcHRoID4gaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGggKyBsaW5lQ2xlYXJhbmNlKSB7XG4gICAgICAgIGxpbmVDbGVhcmFuY2UgPVxuICAgICAgICAgICAgKGxpbmVDbGVhcmFuY2UgKyBkZWxpbURlcHRoIC0gaW5uZXIuaGVpZ2h0IC0gaW5uZXIuZGVwdGgpIC8gMjtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCB0aGUgZGVsaW1pdGVyIHNvIHRoYXQgaXRzIHRvcCBsaW5lcyB1cCB3aXRoIHRoZSB0b3Agb2YgdGhlIGxpbmVcbiAgICB2YXIgZGVsaW1TaGlmdCA9IC0oaW5uZXIuaGVpZ2h0ICsgbGluZUNsZWFyYW5jZSArIHJ1bGVXaWR0aCkgKyBkZWxpbS5oZWlnaHQ7XG4gICAgZGVsaW0uc3R5bGUudG9wID0gZGVsaW1TaGlmdCArIFwiZW1cIjtcbiAgICBkZWxpbS5oZWlnaHQgLT0gZGVsaW1TaGlmdDtcbiAgICBkZWxpbS5kZXB0aCArPSBkZWxpbVNoaWZ0O1xuXG4gICAgLy8gV2UgYWRkIGEgc3BlY2lhbCBjYXNlIGhlcmUsIGJlY2F1c2UgZXZlbiB3aGVuIGBpbm5lcmAgaXMgZW1wdHksIHdlXG4gICAgLy8gc3RpbGwgZ2V0IGEgbGluZS4gU28sIHdlIHVzZSBhIHNpbXBsZSBoZXVyaXN0aWMgdG8gZGVjaWRlIGlmIHdlXG4gICAgLy8gc2hvdWxkIG9taXQgdGhlIGJvZHkgZW50aXJlbHkuIChub3RlIHRoaXMgZG9lc24ndCB3b3JrIGZvciBzb21ldGhpbmdcbiAgICAvLyBsaWtlIGBcXHNxcnR7XFxybGFwe3h9fWAsIGJ1dCBpZiBzb21lb25lIGlzIGRvaW5nIHRoYXQgdGhleSBkZXNlcnZlIGZvclxuICAgIC8vIGl0IG5vdCB0byB3b3JrLlxuICAgIHZhciBib2R5O1xuICAgIGlmIChpbm5lci5oZWlnaHQgPT09IDAgJiYgaW5uZXIuZGVwdGggPT09IDApIHtcbiAgICAgICAgYm9keSA9IG1ha2VTcGFuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGlubmVyfSxcbiAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogbGluZUNsZWFyYW5jZX0sXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGxpbmV9LFxuICAgICAgICAgICAge3R5cGU6IFwia2VyblwiLCBzaXplOiBydWxlV2lkdGh9XG4gICAgICAgIF0sIFwiZmlyc3RCYXNlbGluZVwiLCBudWxsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoIWdyb3VwLnZhbHVlLmluZGV4KSB7XG4gICAgICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwic3FydFwiXSwgW2RlbGltLCBib2R5XSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBvcHRpb25hbCByb290IGluZGV4XG5cbiAgICAgICAgLy8gVGhlIGluZGV4IGlzIGFsd2F5cyBpbiBzY3JpcHRzY3JpcHQgc3R5bGVcbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLndpdGhTdHlsZShTdHlsZS5TQ1JJUFRTQ1JJUFQpO1xuICAgICAgICB2YXIgcm9vdCA9IGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuaW5kZXgsIG5ld09wdGlvbnMpO1xuICAgICAgICB2YXIgcm9vdFdyYXAgPSBtYWtlU3BhbihcbiAgICAgICAgICAgIFtzdHlsZS5yZXNldCgpLCBTdHlsZS5TQ1JJUFRTQ1JJUFQuY2xzKCldLFxuICAgICAgICAgICAgW3Jvb3RdLFxuICAgICAgICAgICAgbmV3T3B0aW9ucyk7XG5cbiAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgaGVpZ2h0IGFuZCBkZXB0aCBvZiB0aGUgaW5uZXIgcGFydFxuICAgICAgICB2YXIgaW5uZXJSb290SGVpZ2h0ID0gTWF0aC5tYXgoZGVsaW0uaGVpZ2h0LCBib2R5LmhlaWdodCk7XG4gICAgICAgIHZhciBpbm5lclJvb3REZXB0aCA9IE1hdGgubWF4KGRlbGltLmRlcHRoLCBib2R5LmRlcHRoKTtcblxuICAgICAgICAvLyBUaGUgYW1vdW50IHRoZSBpbmRleCBpcyBzaGlmdGVkIGJ5LiBUaGlzIGlzIHRha2VuIGZyb20gdGhlIFRlWFxuICAgICAgICAvLyBzb3VyY2UsIGluIHRoZSBkZWZpbml0aW9uIG9mIGBcXHJAQHRgLlxuICAgICAgICB2YXIgdG9TaGlmdCA9IDAuNiAqIChpbm5lclJvb3RIZWlnaHQgLSBpbm5lclJvb3REZXB0aCk7XG5cbiAgICAgICAgLy8gQnVpbGQgYSBWTGlzdCB3aXRoIHRoZSBzdXBlcnNjcmlwdCBzaGlmdGVkIHVwIGNvcnJlY3RseVxuICAgICAgICB2YXIgcm9vdFZMaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFxuICAgICAgICAgICAgW3t0eXBlOiBcImVsZW1cIiwgZWxlbTogcm9vdFdyYXB9XSxcbiAgICAgICAgICAgIFwic2hpZnRcIiwgLXRvU2hpZnQsIG9wdGlvbnMpO1xuICAgICAgICAvLyBBZGQgYSBjbGFzcyBzdXJyb3VuZGluZyBpdCBzbyB3ZSBjYW4gYWRkIG9uIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgICAvLyBrZXJuaW5nXG4gICAgICAgIHZhciByb290Vkxpc3RXcmFwID0gbWFrZVNwYW4oW1wicm9vdFwiXSwgW3Jvb3RWTGlzdF0pO1xuXG4gICAgICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwic3FydFwiXSxcbiAgICAgICAgICAgIFtyb290Vkxpc3RXcmFwLCBkZWxpbSwgYm9keV0sIG9wdGlvbnMpO1xuICAgIH1cbn07XG5cbmdyb3VwVHlwZXMuc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBIYW5kbGUgc2l6aW5nIG9wZXJhdG9ycyBsaWtlIFxcSHVnZS4gUmVhbCBUZVggZG9lc24ndCBhY3R1YWxseSBhbGxvd1xuICAgIC8vIHRoZXNlIGZ1bmN0aW9ucyBpbnNpZGUgb2YgbWF0aCBleHByZXNzaW9ucywgc28gd2UgZG8gc29tZSBzcGVjaWFsXG4gICAgLy8gaGFuZGxpbmcuXG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgb3B0aW9ucy53aXRoU2l6ZShncm91cC52YWx1ZS5zaXplKSwgZmFsc2UpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgY29ycmVjdCBtYXhGb250U2l6ZS5cbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBmb250U2l6ZSA9IGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbZ3JvdXAudmFsdWUuc2l6ZV07XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAqIHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgLy8gQWRkIHNpemUtcmVzZXR0aW5nIGNsYXNzZXMgdG8gdGhlIGlubmVyIGxpc3QgYW5kIHNldCBtYXhGb250U2l6ZVxuICAgIC8vIG1hbnVhbGx5LiBIYW5kbGUgbmVzdGVkIHNpemUgY2hhbmdlcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwb3MgPSB1dGlscy5pbmRleE9mKGlubmVyW2ldLmNsYXNzZXMsIFwic2l6aW5nXCIpO1xuICAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgICAgaW5uZXJbaV0uY2xhc3Nlcy5wdXNoKFwic2l6aW5nXCIsIFwicmVzZXQtXCIgKyBvcHRpb25zLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAudmFsdWUuc2l6ZSwgc3R5bGUuY2xzKCkpO1xuICAgICAgICAgICAgaW5uZXJbaV0ubWF4Rm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbm5lcltpXS5jbGFzc2VzW3BvcyArIDFdID09PSBcInJlc2V0LVwiICsgZ3JvdXAudmFsdWUuc2l6ZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5lc3RlZCBzaXplIGNoYW5nZTogZS5nLiwgaW5uZXJbaV0gaXMgdGhlIFwiYlwiIGluXG4gICAgICAgICAgICAvLyBgXFxIdWdlIGEgXFxzbWFsbCBiYC4gT3ZlcnJpZGUgdGhlIG9sZCBzaXplICh0aGUgYHJlc2V0LWAgY2xhc3MpXG4gICAgICAgICAgICAvLyBidXQgbm90IHRoZSBuZXcgc2l6ZS5cbiAgICAgICAgICAgIGlubmVyW2ldLmNsYXNzZXNbcG9zICsgMV0gPSBcInJlc2V0LVwiICsgb3B0aW9ucy5zaXplO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChpbm5lcik7XG59O1xuXG5ncm91cFR5cGVzLnN0eWxpbmcgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFN0eWxlIGNoYW5nZXMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGcuIDQ0MiwgUnVsZSAzLlxuXG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHdlJ3JlIGNoYW5naW5nIHRvLlxuICAgIHZhciBzdHlsZU1hcCA9IHtcbiAgICAgICAgXCJkaXNwbGF5XCI6IFN0eWxlLkRJU1BMQVksXG4gICAgICAgIFwidGV4dFwiOiBTdHlsZS5URVhULFxuICAgICAgICBcInNjcmlwdFwiOiBTdHlsZS5TQ1JJUFQsXG4gICAgICAgIFwic2NyaXB0c2NyaXB0XCI6IFN0eWxlLlNDUklQVFNDUklQVFxuICAgIH07XG5cbiAgICB2YXIgbmV3U3R5bGUgPSBzdHlsZU1hcFtncm91cC52YWx1ZS5zdHlsZV07XG4gICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLndpdGhTdHlsZShuZXdTdHlsZSk7XG5cbiAgICAvLyBCdWlsZCB0aGUgaW5uZXIgZXhwcmVzc2lvbiBpbiB0aGUgbmV3IHN0eWxlLlxuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihcbiAgICAgICAgZ3JvdXAudmFsdWUudmFsdWUsIG5ld09wdGlvbnMsIGZhbHNlKTtcblxuICAgIC8vIEFkZCBzdHlsZS1yZXNldHRpbmcgY2xhc3NlcyB0byB0aGUgaW5uZXIgbGlzdC4gSGFuZGxlIG5lc3RlZCBjaGFuZ2VzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBvcyA9IHV0aWxzLmluZGV4T2YoaW5uZXJbaV0uY2xhc3NlcywgbmV3U3R5bGUucmVzZXQoKSk7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgICBpbm5lcltpXS5jbGFzc2VzLnB1c2gob3B0aW9ucy5zdHlsZS5yZXNldCgpLCBuZXdTdHlsZS5jbHMoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbmVzdGVkIHN0eWxlIGNoYW5nZSwgYXMgYFxcdGV4dHN0eWxlIGFcXHNjcmlwdHN0eWxlIGJgLlxuICAgICAgICAgICAgLy8gT25seSBvdmVycmlkZSB0aGUgb2xkIHN0eWxlICh0aGUgcmVzZXQgY2xhc3MpLlxuICAgICAgICAgICAgaW5uZXJbaV0uY2xhc3Nlc1twb3NdID0gb3B0aW9ucy5zdHlsZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoaW5uZXIpO1xufTtcblxuZ3JvdXBUeXBlcy5mb250ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9udCA9IGdyb3VwLnZhbHVlLmZvbnQ7XG4gICAgcmV0dXJuIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy53aXRoRm9udChmb250KSk7XG59O1xuXG5ncm91cFR5cGVzLmRlbGltc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGVsaW0gPSBncm91cC52YWx1ZS52YWx1ZTtcblxuICAgIGlmIChkZWxpbSA9PT0gXCIuXCIpIHtcbiAgICAgICAgLy8gRW1wdHkgZGVsaW1pdGVycyBzdGlsbCBjb3VudCBhcyBlbGVtZW50cywgZXZlbiB0aG91Z2ggdGhleSBkb24ndFxuICAgICAgICAvLyBzaG93IGFueXRoaW5nLlxuICAgICAgICByZXR1cm4gbWFrZVNwYW4oW2dyb3VwLnZhbHVlLm1jbGFzc10pO1xuICAgIH1cblxuICAgIC8vIFVzZSBkZWxpbWl0ZXIuc2l6ZWREZWxpbSB0byBnZW5lcmF0ZSB0aGUgZGVsaW1pdGVyLlxuICAgIHJldHVybiBkZWxpbWl0ZXIuc2l6ZWREZWxpbShcbiAgICAgICAgICAgIGRlbGltLCBncm91cC52YWx1ZS5zaXplLCBvcHRpb25zLCBncm91cC5tb2RlLFxuICAgICAgICAgICAgW2dyb3VwLnZhbHVlLm1jbGFzc10pO1xufTtcblxuZ3JvdXBUeXBlcy5sZWZ0cmlnaHQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIEJ1aWxkIHRoZSBpbm5lciBleHByZXNzaW9uXG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMucmVzZXQoKSwgdHJ1ZSk7XG5cbiAgICB2YXIgaW5uZXJIZWlnaHQgPSAwO1xuICAgIHZhciBpbm5lckRlcHRoID0gMDtcbiAgICB2YXIgaGFkTWlkZGxlID0gZmFsc2U7XG5cbiAgICAvLyBDYWxjdWxhdGUgaXRzIGhlaWdodCBhbmQgZGVwdGhcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbm5lcltpXS5pc01pZGRsZSkge1xuICAgICAgICAgICAgaGFkTWlkZGxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlubmVySGVpZ2h0ID0gTWF0aC5tYXgoaW5uZXJbaV0uaGVpZ2h0LCBpbm5lckhlaWdodCk7XG4gICAgICAgICAgICBpbm5lckRlcHRoID0gTWF0aC5tYXgoaW5uZXJbaV0uZGVwdGgsIGlubmVyRGVwdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIC8vIFRoZSBzaXplIG9mIGRlbGltaXRlcnMgaXMgdGhlIHNhbWUsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBzdHlsZSB3ZSBhcmVcbiAgICAvLyBpbi4gVGh1cywgdG8gY29ycmVjdGx5IGNhbGN1bGF0ZSB0aGUgc2l6ZSBvZiBkZWxpbWl0ZXIgd2UgbmVlZCBhcm91bmRcbiAgICAvLyBhIGdyb3VwLCB3ZSBzY2FsZSBkb3duIHRoZSBpbm5lciBzaXplIGJhc2VkIG9uIHRoZSBzaXplLlxuICAgIGlubmVySGVpZ2h0ICo9IHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuICAgIGlubmVyRGVwdGggKj0gc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICB2YXIgbGVmdERlbGltO1xuICAgIGlmIChncm91cC52YWx1ZS5sZWZ0ID09PSBcIi5cIikge1xuICAgICAgICAvLyBFbXB0eSBkZWxpbWl0ZXJzIGluIFxcbGVmdCBhbmQgXFxyaWdodCBtYWtlIG51bGwgZGVsaW1pdGVyIHNwYWNlcy5cbiAgICAgICAgbGVmdERlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW1wibW9wZW5cIl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIGxlZnRSaWdodERlbGltIHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IHNpemVkXG4gICAgICAgIC8vIGRlbGltaXRlci5cbiAgICAgICAgbGVmdERlbGltID0gZGVsaW1pdGVyLmxlZnRSaWdodERlbGltKFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUubGVmdCwgaW5uZXJIZWlnaHQsIGlubmVyRGVwdGgsIG9wdGlvbnMsXG4gICAgICAgICAgICBncm91cC5tb2RlLCBbXCJtb3BlblwiXSk7XG4gICAgfVxuICAgIC8vIEFkZCBpdCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBleHByZXNzaW9uXG4gICAgaW5uZXIudW5zaGlmdChsZWZ0RGVsaW0pO1xuXG4gICAgLy8gSGFuZGxlIG1pZGRsZSBkZWxpbWl0ZXJzXG4gICAgaWYgKGhhZE1pZGRsZSkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbm5lcltpXS5pc01pZGRsZSkge1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBvcHRpb25zIHRoYXQgd2VyZSBhY3RpdmUgd2hlbiBcXG1pZGRsZSB3YXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgaW5uZXJbaV0gPSBkZWxpbWl0ZXIubGVmdFJpZ2h0RGVsaW0oXG4gICAgICAgICAgICAgICAgICAgIGlubmVyW2ldLmlzTWlkZGxlLnZhbHVlLCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCxcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJbaV0uaXNNaWRkbGUub3B0aW9ucywgZ3JvdXAubW9kZSwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJpZ2h0RGVsaW07XG4gICAgLy8gU2FtZSBmb3IgdGhlIHJpZ2h0IGRlbGltaXRlclxuICAgIGlmIChncm91cC52YWx1ZS5yaWdodCA9PT0gXCIuXCIpIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1jbG9zZVwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IGRlbGltaXRlci5sZWZ0UmlnaHREZWxpbShcbiAgICAgICAgICAgIGdyb3VwLnZhbHVlLnJpZ2h0LCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCwgb3B0aW9ucyxcbiAgICAgICAgICAgIGdyb3VwLm1vZGUsIFtcIm1jbG9zZVwiXSk7XG4gICAgfVxuICAgIC8vIEFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uLlxuICAgIGlubmVyLnB1c2gocmlnaHREZWxpbSk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgIFtcIm1pbm5lclwiLCBzdHlsZS5jbHMoKV0sIGlubmVyLCBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMubWlkZGxlID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbWlkZGxlRGVsaW07XG4gICAgaWYgKGdyb3VwLnZhbHVlLnZhbHVlID09PSBcIi5cIikge1xuICAgICAgICBtaWRkbGVEZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtaWRkbGVEZWxpbSA9IGRlbGltaXRlci5zaXplZERlbGltKFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUudmFsdWUsIDEsIG9wdGlvbnMsXG4gICAgICAgICAgICBncm91cC5tb2RlLCBbXSk7XG4gICAgICAgIG1pZGRsZURlbGltLmlzTWlkZGxlID0ge3ZhbHVlOiBncm91cC52YWx1ZS52YWx1ZSwgb3B0aW9uczogb3B0aW9uc307XG4gICAgfVxuICAgIHJldHVybiBtaWRkbGVEZWxpbTtcbn07XG5cbmdyb3VwVHlwZXMucnVsZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gTWFrZSBhbiBlbXB0eSBzcGFuIGZvciB0aGUgcnVsZVxuICAgIHZhciBydWxlID0gbWFrZVNwYW4oW1wibW9yZFwiLCBcInJ1bGVcIl0sIFtdLCBvcHRpb25zKTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzaGlmdCwgd2lkdGgsIGFuZCBoZWlnaHQgb2YgdGhlIHJ1bGUsIGFuZCBhY2NvdW50IGZvciB1bml0c1xuICAgIHZhciBzaGlmdCA9IDA7XG4gICAgaWYgKGdyb3VwLnZhbHVlLnNoaWZ0KSB7XG4gICAgICAgIHNoaWZ0ID0gY2FsY3VsYXRlU2l6ZShncm91cC52YWx1ZS5zaGlmdCwgc3R5bGUpO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAudmFsdWUud2lkdGgsIHN0eWxlKTtcbiAgICB2YXIgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC52YWx1ZS5oZWlnaHQsIHN0eWxlKTtcblxuICAgIC8vIFRoZSBzaXplcyBvZiBydWxlcyBhcmUgYWJzb2x1dGUsIHNvIG1ha2UgaXQgbGFyZ2VyIGlmIHdlIGFyZSBpbiBhXG4gICAgLy8gc21hbGxlciBzdHlsZS5cbiAgICBzaGlmdCAvPSBzdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICB3aWR0aCAvPSBzdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICBoZWlnaHQgLz0gc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICAvLyBTdHlsZSB0aGUgcnVsZSB0byB0aGUgcmlnaHQgc2l6ZVxuICAgIHJ1bGUuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IHdpZHRoICsgXCJlbVwiO1xuICAgIHJ1bGUuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBoZWlnaHQgKyBcImVtXCI7XG4gICAgcnVsZS5zdHlsZS5ib3R0b20gPSBzaGlmdCArIFwiZW1cIjtcblxuICAgIC8vIFJlY29yZCB0aGUgaGVpZ2h0IGFuZCB3aWR0aFxuICAgIHJ1bGUud2lkdGggPSB3aWR0aDtcbiAgICBydWxlLmhlaWdodCA9IGhlaWdodCArIHNoaWZ0O1xuICAgIHJ1bGUuZGVwdGggPSAtc2hpZnQ7XG5cbiAgICByZXR1cm4gcnVsZTtcbn07XG5cbmdyb3VwVHlwZXMua2VybiA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gTWFrZSBhbiBlbXB0eSBzcGFuIGZvciB0aGUgcnVsZVxuICAgIHZhciBydWxlID0gbWFrZVNwYW4oW1wibW9yZFwiLCBcInJ1bGVcIl0sIFtdLCBvcHRpb25zKTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgdmFyIGRpbWVuc2lvbiA9IDA7XG4gICAgaWYgKGdyb3VwLnZhbHVlLmRpbWVuc2lvbikge1xuICAgICAgICBkaW1lbnNpb24gPSBjYWxjdWxhdGVTaXplKGdyb3VwLnZhbHVlLmRpbWVuc2lvbiwgc3R5bGUpO1xuICAgIH1cblxuICAgIGRpbWVuc2lvbiAvPSBzdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIHJ1bGUuc3R5bGUubWFyZ2luTGVmdCA9IGRpbWVuc2lvbiArIFwiZW1cIjtcblxuICAgIHJldHVybiBydWxlO1xufTtcblxuZ3JvdXBUeXBlcy5hY2NlbnQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIEFjY2VudHMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcuIDQ0MywgcnVsZSAxMi5cbiAgICB2YXIgYmFzZSA9IGdyb3VwLnZhbHVlLmJhc2U7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIHZhciBzdXBzdWJHcm91cDtcbiAgICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJzdXBzdWJcIikge1xuICAgICAgICAvLyBJZiBvdXIgYmFzZSBpcyBhIGNoYXJhY3RlciBib3gsIGFuZCB3ZSBoYXZlIHN1cGVyc2NyaXB0cyBhbmRcbiAgICAgICAgLy8gc3Vic2NyaXB0cywgdGhlIHN1cHN1YiB3aWxsIGRlZmVyIHRvIHVzLiBJbiBwYXJ0aWN1bGFyLCB3ZSB3YW50XG4gICAgICAgIC8vIHRvIGF0dGFjaCB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIHRvIHRoZSBpbm5lciBib2R5IChzb1xuICAgICAgICAvLyB0aGF0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIHdvbid0IGJlXG4gICAgICAgIC8vIGFmZmVjdGVkIGJ5IHRoZSBoZWlnaHQgb2YgdGhlIGFjY2VudCkuIFdlIGFjY29tcGxpc2ggdGhpcyBieVxuICAgICAgICAvLyBzdGlja2luZyB0aGUgYmFzZSBvZiB0aGUgYWNjZW50IGludG8gdGhlIGJhc2Ugb2YgdGhlIHN1cHN1YiwgYW5kXG4gICAgICAgIC8vIHJlbmRlcmluZyB0aGF0LCB3aGlsZSBrZWVwaW5nIHRyYWNrIG9mIHdoZXJlIHRoZSBhY2NlbnQgaXMuXG5cbiAgICAgICAgLy8gVGhlIHN1cHN1YiBncm91cCBpcyB0aGUgZ3JvdXAgdGhhdCB3YXMgcGFzc2VkIGluXG4gICAgICAgIHZhciBzdXBzdWIgPSBncm91cDtcbiAgICAgICAgLy8gVGhlIHJlYWwgYWNjZW50IGdyb3VwIGlzIHRoZSBiYXNlIG9mIHRoZSBzdXBzdWIgZ3JvdXBcbiAgICAgICAgZ3JvdXAgPSBzdXBzdWIudmFsdWUuYmFzZTtcbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciBib3ggaXMgdGhlIGJhc2Ugb2YgdGhlIGFjY2VudCBncm91cFxuICAgICAgICBiYXNlID0gZ3JvdXAudmFsdWUuYmFzZTtcbiAgICAgICAgLy8gU3RpY2sgdGhlIGNoYXJhY3RlciBib3ggaW50byB0aGUgYmFzZSBvZiB0aGUgc3Vwc3ViIGdyb3VwXG4gICAgICAgIHN1cHN1Yi52YWx1ZS5iYXNlID0gYmFzZTtcblxuICAgICAgICAvLyBSZXJlbmRlciB0aGUgc3Vwc3ViIGdyb3VwIHdpdGggaXRzIG5ldyBiYXNlLCBhbmQgc3RvcmUgdGhhdFxuICAgICAgICAvLyByZXN1bHQuXG4gICAgICAgIHN1cHN1Ykdyb3VwID0gYnVpbGRHcm91cChcbiAgICAgICAgICAgIHN1cHN1Yiwgb3B0aW9ucy5yZXNldCgpKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmFzZSBncm91cFxuICAgIHZhciBib2R5ID0gYnVpbGRHcm91cChcbiAgICAgICAgYmFzZSwgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuY3JhbXAoKSkpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBza2V3IG9mIHRoZSBhY2NlbnQuIFRoaXMgaXMgYmFzZWQgb24gdGhlIGxpbmUgXCJJZiB0aGVcbiAgICAvLyBudWNsZXVzIGlzIG5vdCBhIHNpbmdsZSBjaGFyYWN0ZXIsIGxldCBzID0gMDsgb3RoZXJ3aXNlIHNldCBzIHRvIHRoZVxuICAgIC8vIGtlcm4gYW1vdW50IGZvciB0aGUgbnVjbGV1cyBmb2xsb3dlZCBieSB0aGUgXFxza2V3Y2hhciBvZiBpdHMgZm9udC5cIlxuICAgIC8vIE5vdGUgdGhhdCBvdXIgc2tldyBtZXRyaWNzIGFyZSBqdXN0IHRoZSBrZXJuIGJldHdlZW4gZWFjaCBjaGFyYWN0ZXJcbiAgICAvLyBhbmQgdGhlIHNrZXdjaGFyLlxuICAgIHZhciBza2V3O1xuICAgIGlmIChpc0NoYXJhY3RlckJveChiYXNlKSkge1xuICAgICAgICAvLyBJZiB0aGUgYmFzZSBpcyBhIGNoYXJhY3RlciBib3gsIHRoZW4gd2Ugd2FudCB0aGUgc2tldyBvZiB0aGVcbiAgICAgICAgLy8gaW5uZXJtb3N0IGNoYXJhY3Rlci4gVG8gZG8gdGhhdCwgd2UgZmluZCB0aGUgaW5uZXJtb3N0IGNoYXJhY3RlcjpcbiAgICAgICAgdmFyIGJhc2VDaGFyID0gZ2V0QmFzZUVsZW0oYmFzZSk7XG4gICAgICAgIC8vIFRoZW4sIHdlIHJlbmRlciBpdHMgZ3JvdXAgdG8gZ2V0IHRoZSBzeW1ib2wgaW5zaWRlIGl0XG4gICAgICAgIHZhciBiYXNlR3JvdXAgPSBidWlsZEdyb3VwKFxuICAgICAgICAgICAgYmFzZUNoYXIsIG9wdGlvbnMud2l0aFN0eWxlKHN0eWxlLmNyYW1wKCkpKTtcbiAgICAgICAgLy8gRmluYWxseSwgd2UgcHVsbCB0aGUgc2tldyBvZmYgb2YgdGhlIHN5bWJvbC5cbiAgICAgICAgc2tldyA9IGJhc2VHcm91cC5za2V3O1xuICAgICAgICAvLyBOb3RlIHRoYXQgd2Ugbm93IHRocm93IGF3YXkgYmFzZUdyb3VwLCBiZWNhdXNlIHRoZSBsYXllcnMgd2VcbiAgICAgICAgLy8gcmVtb3ZlZCB3aXRoIGdldEJhc2VFbGVtIG1pZ2h0IGNvbnRhaW4gdGhpbmdzIGxpa2UgXFxjb2xvciB3aGljaFxuICAgICAgICAvLyB3ZSBjYW4ndCBnZXQgcmlkIG9mLlxuICAgICAgICAvLyBUT0RPKGVtaWx5KTogRmluZCBhIGJldHRlciB3YXkgdG8gZ2V0IHRoZSBza2V3XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2tldyA9IDA7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiB0aGUgYm9keSBhbmQgdGhlIGFjY2VudFxuICAgIHZhciBjbGVhcmFuY2UgPSBNYXRoLm1pbihcbiAgICAgICAgYm9keS5oZWlnaHQsXG4gICAgICAgIHN0eWxlLm1ldHJpY3MueEhlaWdodCk7XG5cbiAgICAvLyBCdWlsZCB0aGUgYWNjZW50XG4gICAgdmFyIGFjY2VudCA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woXG4gICAgICAgIGdyb3VwLnZhbHVlLmFjY2VudCwgXCJNYWluLVJlZ3VsYXJcIiwgXCJtYXRoXCIsIG9wdGlvbnMpO1xuICAgIC8vIFJlbW92ZSB0aGUgaXRhbGljIGNvcnJlY3Rpb24gb2YgdGhlIGFjY2VudCwgYmVjYXVzZSBpdCBvbmx5IHNlcnZlcyB0b1xuICAgIC8vIHNoaWZ0IHRoZSBhY2NlbnQgb3ZlciB0byBhIHBsYWNlIHdlIGRvbid0IHdhbnQuXG4gICAgYWNjZW50Lml0YWxpYyA9IDA7XG5cbiAgICAvLyBUaGUgXFx2ZWMgY2hhcmFjdGVyIHRoYXQgdGhlIGZvbnRzIHVzZSBpcyBhIGNvbWJpbmluZyBjaGFyYWN0ZXIsIGFuZFxuICAgIC8vIHRodXMgc2hvd3MgdXAgbXVjaCB0b28gZmFyIHRvIHRoZSBsZWZ0LiBUbyBhY2NvdW50IGZvciB0aGlzLCB3ZSBhZGQgYVxuICAgIC8vIHNwZWNpZmljIGNsYXNzIHdoaWNoIHNoaWZ0cyB0aGUgYWNjZW50IG92ZXIgdG8gd2hlcmUgd2Ugd2FudCBpdC5cbiAgICAvLyBUT0RPKGVtaWx5KTogRml4IHRoaXMgaW4gYSBiZXR0ZXIgd2F5LCBsaWtlIGJ5IGNoYW5naW5nIHRoZSBmb250XG4gICAgdmFyIHZlY0NsYXNzID0gZ3JvdXAudmFsdWUuYWNjZW50ID09PSBcIlxcXFx2ZWNcIiA/IFwiYWNjZW50LXZlY1wiIDogbnVsbDtcblxuICAgIHZhciBhY2NlbnRCb2R5ID0gbWFrZVNwYW4oW1wiYWNjZW50LWJvZHlcIiwgdmVjQ2xhc3NdLCBbXG4gICAgICAgIG1ha2VTcGFuKFtdLCBbYWNjZW50XSldKTtcblxuICAgIGFjY2VudEJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoW1xuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGJvZHl9LFxuICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IC1jbGVhcmFuY2V9LFxuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGFjY2VudEJvZHl9XG4gICAgXSwgXCJmaXJzdEJhc2VsaW5lXCIsIG51bGwsIG9wdGlvbnMpO1xuXG4gICAgLy8gU2hpZnQgdGhlIGFjY2VudCBvdmVyIGJ5IHRoZSBza2V3LiBOb3RlIHdlIHNoaWZ0IGJ5IHR3aWNlIHRoZSBza2V3XG4gICAgLy8gYmVjYXVzZSB3ZSBhcmUgY2VudGVyaW5nIHRoZSBhY2NlbnQsIHNvIGJ5IGFkZGluZyAyKnNrZXcgdG8gdGhlIGxlZnQsXG4gICAgLy8gd2Ugc2hpZnQgaXQgdG8gdGhlIHJpZ2h0IGJ5IDEqc2tldy5cbiAgICBhY2NlbnRCb2R5LmNoaWxkcmVuWzFdLnN0eWxlLm1hcmdpbkxlZnQgPSAyICogc2tldyArIFwiZW1cIjtcblxuICAgIHZhciBhY2NlbnRXcmFwID0gbWFrZVNwYW4oW1wibW9yZFwiLCBcImFjY2VudFwiXSwgW2FjY2VudEJvZHldLCBvcHRpb25zKTtcblxuICAgIGlmIChzdXBzdWJHcm91cCkge1xuICAgICAgICAvLyBIZXJlLCB3ZSByZXBsYWNlIHRoZSBcImJhc2VcIiBjaGlsZCBvZiB0aGUgc3Vwc3ViIHdpdGggb3VyIG5ld2x5XG4gICAgICAgIC8vIGdlbmVyYXRlZCBhY2NlbnQuXG4gICAgICAgIHN1cHN1Ykdyb3VwLmNoaWxkcmVuWzBdID0gYWNjZW50V3JhcDtcblxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCByZXJ1biB0aGUgaGVpZ2h0IGNhbGN1bGF0aW9uIGFmdGVyIHJlcGxhY2luZyB0aGVcbiAgICAgICAgLy8gYWNjZW50LCB3ZSBtYW51YWxseSByZWNhbGN1bGF0ZSBoZWlnaHQuXG4gICAgICAgIHN1cHN1Ykdyb3VwLmhlaWdodCA9IE1hdGgubWF4KGFjY2VudFdyYXAuaGVpZ2h0LCBzdXBzdWJHcm91cC5oZWlnaHQpO1xuXG4gICAgICAgIC8vIEFjY2VudHMgc2hvdWxkIGFsd2F5cyBiZSBvcmRzLCBldmVuIHdoZW4gdGhlaXIgaW5uYXJkcyBhcmUgbm90LlxuICAgICAgICBzdXBzdWJHcm91cC5jbGFzc2VzWzBdID0gXCJtb3JkXCI7XG5cbiAgICAgICAgcmV0dXJuIHN1cHN1Ykdyb3VwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhY2NlbnRXcmFwO1xuICAgIH1cbn07XG5cbmdyb3VwVHlwZXMucGhhbnRvbSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKFxuICAgICAgICBncm91cC52YWx1ZS52YWx1ZSxcbiAgICAgICAgb3B0aW9ucy53aXRoUGhhbnRvbSgpLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICAvLyBcXHBoYW50b20gaXNuJ3Qgc3VwcG9zZWQgdG8gYWZmZWN0IHRoZSBlbGVtZW50cyBpdCBjb250YWlucy5cbiAgICAvLyBTZWUgXCJjb2xvclwiIGZvciBtb3JlIGRldGFpbHMuXG4gICAgcmV0dXJuIG5ldyBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xufTtcblxuZ3JvdXBUeXBlcy5tY2xhc3MgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC52YWx1ZS52YWx1ZSwgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oW2dyb3VwLnZhbHVlLm1jbGFzc10sIGVsZW1lbnRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogYnVpbGRHcm91cCBpcyB0aGUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGdyb3VwIGFuZCBjYWxscyB0aGUgY29ycmVjdCBncm91cFR5cGVcbiAqIGZ1bmN0aW9uIGZvciBpdC4gSXQgYWxzbyBoYW5kbGVzIHRoZSBpbnRlcmFjdGlvbiBvZiBzaXplIGFuZCBzdHlsZSBjaGFuZ2VzXG4gKiBiZXR3ZWVuIHBhcmVudHMgYW5kIGNoaWxkcmVuLlxuICovXG52YXIgYnVpbGRHcm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgICByZXR1cm4gbWFrZVNwYW4oKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXBUeXBlc1tncm91cC50eXBlXSkge1xuICAgICAgICAvLyBDYWxsIHRoZSBncm91cFR5cGVzIGZ1bmN0aW9uXG4gICAgICAgIHZhciBncm91cE5vZGUgPSBncm91cFR5cGVzW2dyb3VwLnR5cGVdKGdyb3VwLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG11bHRpcGxpZXI7XG5cbiAgICAgICAgLy8gSWYgdGhlIHN0eWxlIGNoYW5nZWQgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY3VycmVudCBncm91cCxcbiAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHNpemUgZGlmZmVyZW5jZVxuICAgICAgICBpZiAob3B0aW9ucy5zdHlsZSAhPT0gb3B0aW9ucy5wYXJlbnRTdHlsZSkge1xuICAgICAgICAgICAgbXVsdGlwbGllciA9IG9wdGlvbnMuc3R5bGUuc2l6ZU11bHRpcGxpZXIgL1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudFN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgICAgICAgICBncm91cE5vZGUuaGVpZ2h0ICo9IG11bHRpcGxpZXI7XG4gICAgICAgICAgICBncm91cE5vZGUuZGVwdGggKj0gbXVsdGlwbGllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBzaXplIGNoYW5nZWQgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY3VycmVudCBncm91cCwgYWNjb3VudFxuICAgICAgICAvLyBmb3IgdGhhdCBzaXplIGRpZmZlcmVuY2UuXG4gICAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IG9wdGlvbnMucGFyZW50U2l6ZSkge1xuICAgICAgICAgICAgbXVsdGlwbGllciA9IGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbb3B0aW9ucy5zaXplXSAvXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbb3B0aW9ucy5wYXJlbnRTaXplXTtcblxuICAgICAgICAgICAgZ3JvdXBOb2RlLmhlaWdodCAqPSBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgZ3JvdXBOb2RlLmRlcHRoICo9IG11bHRpcGxpZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXBOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgXCJHb3QgZ3JvdXAgb2YgdW5rbm93biB0eXBlOiAnXCIgKyBncm91cC50eXBlICsgXCInXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGFrZSBhbiBlbnRpcmUgcGFyc2UgdHJlZSwgYW5kIGJ1aWxkIGl0IGludG8gYW4gYXBwcm9wcmlhdGUgc2V0IG9mIEhUTUxcbiAqIG5vZGVzLlxuICovXG52YXIgYnVpbGRIVE1MID0gZnVuY3Rpb24odHJlZSwgb3B0aW9ucykge1xuICAgIC8vIGJ1aWxkRXhwcmVzc2lvbiBpcyBkZXN0cnVjdGl2ZSwgc28gd2UgbmVlZCB0byBtYWtlIGEgY2xvbmVcbiAgICAvLyBvZiB0aGUgaW5jb21pbmcgdHJlZSBzbyB0aGF0IGl0IGlzbid0IGFjY2lkZW50YWxseSBjaGFuZ2VkXG4gICAgdHJlZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodHJlZSkpO1xuXG4gICAgLy8gQnVpbGQgdGhlIGV4cHJlc3Npb24gY29udGFpbmVkIGluIHRoZSB0cmVlXG4gICAgdmFyIGV4cHJlc3Npb24gPSBidWlsZEV4cHJlc3Npb24odHJlZSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgdmFyIGJvZHkgPSBtYWtlU3BhbihbXCJiYXNlXCIsIG9wdGlvbnMuc3R5bGUuY2xzKCldLCBleHByZXNzaW9uLCBvcHRpb25zKTtcblxuICAgIC8vIEFkZCBzdHJ1dHMsIHdoaWNoIGVuc3VyZSB0aGF0IHRoZSB0b3Agb2YgdGhlIEhUTUwgZWxlbWVudCBmYWxscyBhdCB0aGVcbiAgICAvLyBoZWlnaHQgb2YgdGhlIGV4cHJlc3Npb24sIGFuZCB0aGUgYm90dG9tIG9mIHRoZSBIVE1MIGVsZW1lbnQgZmFsbHMgYXQgdGhlXG4gICAgLy8gZGVwdGggb2YgdGhlIGV4cHJlc3Npb24uXG4gICAgdmFyIHRvcFN0cnV0ID0gbWFrZVNwYW4oW1wic3RydXRcIl0pO1xuICAgIHZhciBib3R0b21TdHJ1dCA9IG1ha2VTcGFuKFtcInN0cnV0XCIsIFwiYm90dG9tXCJdKTtcblxuICAgIHRvcFN0cnV0LnN0eWxlLmhlaWdodCA9IGJvZHkuaGVpZ2h0ICsgXCJlbVwiO1xuICAgIGJvdHRvbVN0cnV0LnN0eWxlLmhlaWdodCA9IChib2R5LmhlaWdodCArIGJvZHkuZGVwdGgpICsgXCJlbVwiO1xuICAgIC8vIFdlJ2QgbGlrZSB0byB1c2UgYHZlcnRpY2FsLWFsaWduOiB0b3BgIGJ1dCBpbiBJRSA5IHRoaXMgbG93ZXJzIHRoZVxuICAgIC8vIGJhc2VsaW5lIG9mIHRoZSBib3ggdG8gdGhlIGJvdHRvbSBvZiB0aGlzIHN0cnV0IChpbnN0ZWFkIHN0YXlpbmcgaW4gdGhlXG4gICAgLy8gbm9ybWFsIHBsYWNlKSBzbyB3ZSB1c2UgYW4gYWJzb2x1dGUgdmFsdWUgZm9yIHZlcnRpY2FsLWFsaWduIGluc3RlYWRcbiAgICBib3R0b21TdHJ1dC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gLWJvZHkuZGVwdGggKyBcImVtXCI7XG5cbiAgICAvLyBXcmFwIHRoZSBzdHJ1dHMgYW5kIGJvZHkgdG9nZXRoZXJcbiAgICB2YXIgaHRtbE5vZGUgPSBtYWtlU3BhbihbXCJrYXRleC1odG1sXCJdLCBbdG9wU3RydXQsIGJvdHRvbVN0cnV0LCBib2R5XSk7XG5cbiAgICBodG1sTm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG5cbiAgICByZXR1cm4gaHRtbE5vZGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkSFRNTDtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnZlcnRzIGEgcGFyc2UgdHJlZSBpbnRvIGEgY29vcmVzcG9uZGluZyBNYXRoTUwgdHJlZS4gVGhlIG1haW5cbiAqIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRNYXRoTUxgIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhIHBhcnNlIHRyZWUgZnJvbSB0aGVcbiAqIHBhcnNlci5cbiAqL1xuXG52YXIgYnVpbGRDb21tb24gPSByZXF1aXJlKFwiLi9idWlsZENvbW1vblwiKTtcbnZhciBmb250TWV0cmljcyA9IHJlcXVpcmUoXCIuL2ZvbnRNZXRyaWNzXCIpO1xudmFyIG1hdGhNTFRyZWUgPSByZXF1aXJlKFwiLi9tYXRoTUxUcmVlXCIpO1xudmFyIFBhcnNlRXJyb3IgPSByZXF1aXJlKFwiLi9QYXJzZUVycm9yXCIpO1xudmFyIHN5bWJvbHMgPSByZXF1aXJlKFwiLi9zeW1ib2xzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbnZhciBtYWtlU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuO1xudmFyIGZvbnRNYXAgPSBidWlsZENvbW1vbi5mb250TWFwO1xuXG4vKipcbiAqIFRha2VzIGEgc3ltYm9sIGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgTWF0aE1MIHRleHQgbm9kZSBhZnRlciBwZXJmb3JtaW5nXG4gKiBvcHRpb25hbCByZXBsYWNlbWVudCBmcm9tIHN5bWJvbHMuanMuXG4gKi9cbnZhciBtYWtlVGV4dCA9IGZ1bmN0aW9uKHRleHQsIG1vZGUpIHtcbiAgICBpZiAoc3ltYm9sc1ttb2RlXVt0ZXh0XSAmJiBzeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2UpIHtcbiAgICAgICAgdGV4dCA9IHN5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4dCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1hdGggdmFyaWFudCBhcyBhIHN0cmluZyBvciBudWxsIGlmIG5vbmUgaXMgcmVxdWlyZWQuXG4gKi9cbnZhciBnZXRWYXJpYW50ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgICBpZiAoIWZvbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSBncm91cC5tb2RlO1xuICAgIGlmIChmb250ID09PSBcIm1hdGhpdFwiKSB7XG4gICAgICAgIHJldHVybiBcIml0YWxpY1wiO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IGdyb3VwLnZhbHVlO1xuICAgIGlmICh1dGlscy5jb250YWlucyhbXCJcXFxcaW1hdGhcIiwgXCJcXFxcam1hdGhcIl0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoc3ltYm9sc1ttb2RlXVt2YWx1ZV0gJiYgc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZSkge1xuICAgICAgICB2YWx1ZSA9IHN5bWJvbHNbbW9kZV1bdmFsdWVdLnJlcGxhY2U7XG4gICAgfVxuXG4gICAgdmFyIGZvbnROYW1lID0gZm9udE1hcFtmb250XS5mb250TmFtZTtcbiAgICBpZiAoZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljcyh2YWx1ZSwgZm9udE5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmb250TWFwW29wdGlvbnMuZm9udF0udmFyaWFudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogRnVuY3Rpb25zIGZvciBoYW5kbGluZyB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIGdyb3VwcyBmb3VuZCBpbiB0aGUgcGFyc2VcbiAqIHRyZWUuIEVhY2ggZnVuY3Rpb24gc2hvdWxkIHRha2UgYSBwYXJzZSBncm91cCBhbmQgcmV0dXJuIGEgTWF0aE1MIG5vZGUuXG4gKi9cbnZhciBncm91cFR5cGVzID0ge307XG5cbmdyb3VwVHlwZXMubWF0aG9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtaVwiLFxuICAgICAgICBbbWFrZVRleHQoZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICB2YXIgdmFyaWFudCA9IGdldFZhcmlhbnQoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIGlmICh2YXJpYW50KSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgdmFyaWFudCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy50ZXh0b3JkID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGV4dCA9IG1ha2VUZXh0KGdyb3VwLnZhbHVlLCBncm91cC5tb2RlKTtcblxuICAgIHZhciB2YXJpYW50ID0gZ2V0VmFyaWFudChncm91cCwgb3B0aW9ucykgfHwgXCJub3JtYWxcIjtcblxuICAgIHZhciBub2RlO1xuICAgIGlmICgvWzAtOV0vLnRlc3QoZ3JvdXAudmFsdWUpKSB7XG4gICAgICAgIC8vIFRPRE8oa2V2aW5iKSBtZXJnZSBhZGphY2VudCA8bW4+IG5vZGVzXG4gICAgICAgIC8vIGRvIGl0IGFzIGEgcG9zdCBwcm9jZXNzaW5nIHN0ZXBcbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW5cIiwgW3RleHRdKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9udCkge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCB2YXJpYW50KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIFt0ZXh0XSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgdmFyaWFudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLmJpbiA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMucmVsID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5vcGVuID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5jbG9zZSA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuaW5uZXIgPSBmdW5jdGlvbihncm91cCkge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnZhbHVlLCBncm91cC5tb2RlKV0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLnB1bmN0ID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2VwYXJhdG9yXCIsIFwidHJ1ZVwiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5vcmRncm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLCBvcHRpb25zKTtcblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGlubmVyKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy50ZXh0ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgaW5uZXIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLmNvbG9yID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhjb2xvclwiLCBncm91cC52YWx1ZS5jb2xvcik7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuc3Vwc3ViID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbYnVpbGRHcm91cChncm91cC52YWx1ZS5iYXNlLCBvcHRpb25zKV07XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUuc3ViKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRHcm91cChncm91cC52YWx1ZS5zdWIsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUuc3VwKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRHcm91cChncm91cC52YWx1ZS5zdXAsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZVR5cGU7XG4gICAgaWYgKCFncm91cC52YWx1ZS5zdWIpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdXBcIjtcbiAgICB9IGVsc2UgaWYgKCFncm91cC52YWx1ZS5zdXApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdWJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlVHlwZSA9IFwibXN1YnN1cFwiO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUobm9kZVR5cGUsIGNoaWxkcmVuKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5nZW5mcmFjID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1mcmFjXCIsXG4gICAgICAgIFtidWlsZEdyb3VwKGdyb3VwLnZhbHVlLm51bWVyLCBvcHRpb25zKSxcbiAgICAgICAgICAgIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuZGVub20sIG9wdGlvbnMpXSk7XG5cbiAgICBpZiAoIWdyb3VwLnZhbHVlLmhhc0JhckxpbmUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5ldGhpY2tuZXNzXCIsIFwiMHB4XCIpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5sZWZ0RGVsaW0gIT0gbnVsbCB8fCBncm91cC52YWx1ZS5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHdpdGhEZWxpbXMgPSBbXTtcblxuICAgICAgICBpZiAoZ3JvdXAudmFsdWUubGVmdERlbGltICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0T3AgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgICAgICBcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC52YWx1ZS5sZWZ0RGVsaW0pXSk7XG5cbiAgICAgICAgICAgIGxlZnRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG5cbiAgICAgICAgICAgIHdpdGhEZWxpbXMucHVzaChsZWZ0T3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgd2l0aERlbGltcy5wdXNoKG5vZGUpO1xuXG4gICAgICAgIGlmIChncm91cC52YWx1ZS5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByaWdodE9wID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICAgICAgXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoZ3JvdXAudmFsdWUucmlnaHREZWxpbSldKTtcblxuICAgICAgICAgICAgcmlnaHRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG5cbiAgICAgICAgICAgIHdpdGhEZWxpbXMucHVzaChyaWdodE9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRlck5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgd2l0aERlbGltcyk7XG5cbiAgICAgICAgcmV0dXJuIG91dGVyTm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuYXJyYXkgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtdGFibGVcIiwgZ3JvdXAudmFsdWUuYm9keS5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICAgICAgXCJtdHJcIiwgcm93Lm1hcChmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibXRkXCIsIFtidWlsZEdyb3VwKGNlbGwsIG9wdGlvbnMpXSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG59O1xuXG5ncm91cFR5cGVzLnNxcnQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlO1xuICAgIGlmIChncm91cC52YWx1ZS5pbmRleCkge1xuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1yb290XCIsIFtcbiAgICAgICAgICAgICAgICBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuaW5kZXgsIG9wdGlvbnMpXG4gICAgICAgICAgICBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1zcXJ0XCIsIFtidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLmxlZnRyaWdodCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLmxlZnQgIT09IFwiLlwiKSB7XG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUubGVmdCwgZ3JvdXAubW9kZSldKTtcblxuICAgICAgICBsZWZ0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG5cbiAgICAgICAgaW5uZXIudW5zaGlmdChsZWZ0Tm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnJpZ2h0ICE9PSBcIi5cIikge1xuICAgICAgICB2YXIgcmlnaHROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZS5yaWdodCwgZ3JvdXAubW9kZSldKTtcblxuICAgICAgICByaWdodE5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuXG4gICAgICAgIGlubmVyLnB1c2gocmlnaHROb2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0ZXJOb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGlubmVyKTtcblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59O1xuXG5ncm91cFR5cGVzLm1pZGRsZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG1pZGRsZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUubWlkZGxlLCBncm91cC5tb2RlKV0pO1xuICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIHJldHVybiBtaWRkbGVOb2RlO1xufTtcblxuZ3JvdXBUeXBlcy5hY2NlbnQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBhY2NlbnROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnZhbHVlLmFjY2VudCwgZ3JvdXAubW9kZSldKTtcblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW92ZXJcIixcbiAgICAgICAgW2J1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYmFzZSwgb3B0aW9ucyksXG4gICAgICAgICAgICBhY2NlbnROb2RlXSk7XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudFwiLCBcInRydWVcIik7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuc3BhY2luZyA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUgPT09IFwiXFxcXCBcIiB8fCBncm91cC52YWx1ZSA9PT0gXCJcXFxcc3BhY2VcIiB8fFxuICAgICAgICBncm91cC52YWx1ZSA9PT0gXCIgXCIgfHwgZ3JvdXAudmFsdWUgPT09IFwiflwiKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgIFwibXRleHRcIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MDBhMFwiKV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcblxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgIFwid2lkdGhcIiwgYnVpbGRDb21tb24uc3BhY2luZ0Z1bmN0aW9uc1tncm91cC52YWx1ZV0uc2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLm9wID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZTtcblxuICAgIC8vIFRPRE8oZW1pbHkpOiBoYW5kbGUgYmlnIG9wZXJhdG9ycyB1c2luZyB0aGUgYGxhcmdlb3BgIGF0dHJpYnV0ZVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnN5bWJvbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3ltYm9sLiBKdXN0IGFkZCB0aGUgc3ltYm9sLlxuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZS5ib2R5LCBncm91cC5tb2RlKV0pO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudmFsdWUudmFsdWUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBvcGVyYXRvciB3aXRoIGNoaWxkcmVuLiBBZGQgdGhlbS5cbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICAgICAgXCJtb1wiLCBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgdGV4dCBvcGVyYXRvci4gQWRkIGFsbCBvZiB0aGUgY2hhcmFjdGVycyBmcm9tIHRoZVxuICAgICAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgICAgIC8vIFRPRE8oZW1pbHkpOiBBZGQgYSBzcGFjZSBpbiB0aGUgbWlkZGxlIG9mIHNvbWUgb2YgdGhlc2VcbiAgICAgICAgLy8gb3BlcmF0b3JzLCBsaWtlIFxcbGltc3VwLlxuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1pXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC52YWx1ZS5ib2R5LnNsaWNlKDEpKV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5tb2QgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBpbm5lciA9IFtdO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwicG9kXCIgfHwgZ3JvdXAudmFsdWUubW9kVHlwZSA9PT0gXCJwbW9kXCIpIHtcbiAgICAgICAgaW5uZXIucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgIFwibW9cIiwgW21ha2VUZXh0KFwiKFwiLCBncm91cC5tb2RlKV0pKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgIT09IFwicG9kXCIpIHtcbiAgICAgICAgaW5uZXIucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgIFwibW9cIiwgW21ha2VUZXh0KFwibW9kXCIsIGdyb3VwLm1vZGUpXSkpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudmFsdWUudmFsdWUpIHtcbiAgICAgICAgdmFyIHNwYWNlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgICAgIHNwYWNlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMC4zMzMzMzNlbVwiKTtcbiAgICAgICAgaW5uZXIucHVzaChzcGFjZSk7XG4gICAgICAgIGlubmVyID0gaW5uZXIuY29uY2F0KGJ1aWxkRXhwcmVzc2lvbihncm91cC52YWx1ZS52YWx1ZSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudmFsdWUubW9kVHlwZSA9PT0gXCJwb2RcIiB8fCBncm91cC52YWx1ZS5tb2RUeXBlID09PSBcInBtb2RcIikge1xuICAgICAgICBpbm5lci5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoXCIpXCIsIGdyb3VwLm1vZGUpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIGlubmVyKTtcbn07XG5cbmdyb3VwVHlwZXMua2F0ZXggPSBmdW5jdGlvbihncm91cCkge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXRleHRcIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiS2FUZVhcIildKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5mb250ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9udCA9IGdyb3VwLnZhbHVlLmZvbnQ7XG4gICAgcmV0dXJuIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy53aXRoRm9udChmb250KSk7XG59O1xuXG5ncm91cFR5cGVzLmRlbGltc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgIGlmIChncm91cC52YWx1ZS52YWx1ZSAhPT0gXCIuXCIpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChtYWtlVGV4dChncm91cC52YWx1ZS52YWx1ZSwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBjaGlsZHJlbik7XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUubWNsYXNzID09PSBcIm1vcGVuXCIgfHxcbiAgICAgICAgZ3JvdXAudmFsdWUubWNsYXNzID09PSBcIm1jbG9zZVwiKSB7XG4gICAgICAgIC8vIE9ubHkgc29tZSBvZiB0aGUgZGVsaW1zaXppbmcgZnVuY3Rpb25zIGFjdCBhcyBmZW5jZXMsIGFuZCB0aGV5XG4gICAgICAgIC8vIHJldHVybiBcIm1vcGVuXCIgb3IgXCJtY2xvc2VcIiBtY2xhc3MuXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgZGlzYWJsZSBmZW5jaW5nIGlmIGl0J3Mgbm90IGEgZmVuY2UsIHRvIG92ZXJyaWRlIHRoZVxuICAgICAgICAvLyBkZWZhdWx0cy5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcImZhbHNlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5zdHlsaW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG5cbiAgICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0ge1xuICAgICAgICBcImRpc3BsYXlcIjogW1wiMFwiLCBcInRydWVcIl0sXG4gICAgICAgIFwidGV4dFwiOiBbXCIwXCIsIFwiZmFsc2VcIl0sXG4gICAgICAgIFwic2NyaXB0XCI6IFtcIjFcIiwgXCJmYWxzZVwiXSxcbiAgICAgICAgXCJzY3JpcHRzY3JpcHRcIjogW1wiMlwiLCBcImZhbHNlXCJdXG4gICAgfTtcblxuICAgIHZhciBhdHRyID0gc3R5bGVBdHRyaWJ1dGVzW2dyb3VwLnZhbHVlLnN0eWxlXTtcblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgYXR0clswXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgYXR0clsxXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG5cbiAgICAvLyBUT0RPKGVtaWx5KTogVGhpcyBkb2Vzbid0IHByb2R1Y2UgdGhlIGNvcnJlY3Qgc2l6ZSBmb3IgbmVzdGVkIHNpemVcbiAgICAvLyBjaGFuZ2VzLCBiZWNhdXNlIHdlIGRvbid0IGtlZXAgc3RhdGUgb2Ygd2hhdCBzdHlsZSB3ZSdyZSBjdXJyZW50bHlcbiAgICAvLyBpbiwgc28gd2UgY2FuJ3QgcmVzZXQgdGhlIHNpemUgdG8gbm9ybWFsIGJlZm9yZSBjaGFuZ2luZyBpdC4gIE5vd1xuICAgIC8vIHRoYXQgd2UncmUgcGFzc2luZyBhbiBvcHRpb25zIHBhcmFtZXRlciB3ZSBzaG91bGQgYmUgYWJsZSB0byBmaXhcbiAgICAvLyB0aGlzLlxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFxuICAgICAgICBcIm1hdGhzaXplXCIsIGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbZ3JvdXAudmFsdWUuc2l6ZV0gKyBcImVtXCIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLm92ZXJsaW5lID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUyMDNlXCIpXSk7XG4gICAgb3BlcmF0b3Iuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb3ZlclwiLFxuICAgICAgICBbYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zKSxcbiAgICAgICAgICAgIG9wZXJhdG9yXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhY2NlbnRcIiwgXCJ0cnVlXCIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLnVuZGVybGluZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MjAzZVwiKV0pO1xuICAgIG9wZXJhdG9yLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXVuZGVyXCIsXG4gICAgICAgIFtidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpLFxuICAgICAgICAgICAgb3BlcmF0b3JdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudHVuZGVyXCIsIFwidHJ1ZVwiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5ydWxlID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAvLyBUT0RPKGVtaWx5KTogRmlndXJlIG91dCBpZiB0aGVyZSdzIGFuIGFjdHVhbCB3YXkgdG8gZHJhdyBibGFjayBib3hlc1xuICAgIC8vIGluIE1hdGhNTC5cbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5rZXJuID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAvLyBUT0RPKGtldmluKTogRmlndXJlIG91dCBpZiB0aGVyZSdzIGEgd2F5IHRvIGFkZCBzcGFjZSBpbiBNYXRoTUxcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5sbGFwID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1wYWRkZWRcIiwgW2J1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucyldKTtcblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiLTF3aWR0aFwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMHB4XCIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLnJsYXAgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXBhZGRlZFwiLCBbYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zKV0pO1xuXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBweFwiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5waGFudG9tID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIGlubmVyKTtcbn07XG5cbmdyb3VwVHlwZXMubWNsYXNzID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBub2RlcywgYnVpbGRzIHRoZW0sIGFuZCByZXR1cm5zIGEgbGlzdCBvZiB0aGUgZ2VuZXJhdGVkXG4gKiBNYXRoTUwgbm9kZXMuIEEgbGl0dGxlIHNpbXBsZXIgdGhhbiB0aGUgSFRNTCB2ZXJzaW9uIGJlY2F1c2Ugd2UgZG9uJ3QgZG8gYW55XG4gKiBwcmV2aW91cy1ub2RlIGhhbmRsaW5nLlxuICovXG52YXIgYnVpbGRFeHByZXNzaW9uID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBncm91cHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZXhwcmVzc2lvbltpXTtcbiAgICAgICAgZ3JvdXBzLnB1c2goYnVpbGRHcm91cChncm91cCwgb3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBzO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIGdyb3VwIGZyb20gdGhlIHBhcnNlciBhbmQgY2FsbHMgdGhlIGFwcHJvcHJpYXRlIGdyb3VwVHlwZXMgZnVuY3Rpb25cbiAqIG9uIGl0IHRvIHByb2R1Y2UgYSBNYXRoTUwgbm9kZS5cbiAqL1xudmFyIGJ1aWxkR3JvdXAgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXBUeXBlc1tncm91cC50eXBlXSkge1xuICAgICAgICAvLyBDYWxsIHRoZSBncm91cFR5cGVzIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiBncm91cFR5cGVzW2dyb3VwLnR5cGVdKGdyb3VwLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgIFwiR290IGdyb3VwIG9mIHVua25vd24gdHlwZTogJ1wiICsgZ3JvdXAudHlwZSArIFwiJ1wiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRha2VzIGEgZnVsbCBwYXJzZSB0cmVlIGFuZCBzZXR0aW5ncyBhbmQgYnVpbGRzIGEgTWF0aE1MIHJlcHJlc2VudGF0aW9uIG9mXG4gKiBpdC4gSW4gcGFydGljdWxhciwgd2UgcHV0IHRoZSBlbGVtZW50cyBmcm9tIGJ1aWxkaW5nIHRoZSBwYXJzZSB0cmVlIGludG8gYVxuICogPHNlbWFudGljcz4gdGFnIHNvIHdlIGNhbiBhbHNvIGluY2x1ZGUgdGhhdCBUZVggc291cmNlIGFzIGFuIGFubm90YXRpb24uXG4gKlxuICogTm90ZSB0aGF0IHdlIGFjdHVhbGx5IHJldHVybiBhIGRvbVRyZWUgZWxlbWVudCB3aXRoIGEgYDxtYXRoPmAgaW5zaWRlIGl0IHNvXG4gKiB3ZSBjYW4gZG8gYXBwcm9wcmlhdGUgc3R5bGluZy5cbiAqL1xudmFyIGJ1aWxkTWF0aE1MID0gZnVuY3Rpb24odHJlZSwgdGV4RXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBleHByZXNzaW9uID0gYnVpbGRFeHByZXNzaW9uKHRyZWUsIG9wdGlvbnMpO1xuXG4gICAgLy8gV3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBpbiBhbiBtcm93IHNvIGl0IGlzIHByZXNlbnRlZCBpbiB0aGUgc2VtYW50aWNzXG4gICAgLy8gdGFnIGNvcnJlY3RseS5cbiAgICB2YXIgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBleHByZXNzaW9uKTtcblxuICAgIC8vIEJ1aWxkIGEgVGVYIGFubm90YXRpb24gb2YgdGhlIHNvdXJjZVxuICAgIHZhciBhbm5vdGF0aW9uID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwiYW5ub3RhdGlvblwiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4RXhwcmVzc2lvbildKTtcblxuICAgIGFubm90YXRpb24uc2V0QXR0cmlidXRlKFwiZW5jb2RpbmdcIiwgXCJhcHBsaWNhdGlvbi94LXRleFwiKTtcblxuICAgIHZhciBzZW1hbnRpY3MgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJzZW1hbnRpY3NcIiwgW3dyYXBwZXIsIGFubm90YXRpb25dKTtcblxuICAgIHZhciBtYXRoID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtYXRoXCIsIFtzZW1hbnRpY3NdKTtcblxuICAgIC8vIFlvdSBjYW4ndCBzdHlsZSA8bWF0aD4gbm9kZXMsIHNvIHdlIHdyYXAgdGhlIG5vZGUgaW4gYSBzcGFuLlxuICAgIHJldHVybiBtYWtlU3BhbihbXCJrYXRleC1tYXRobWxcIl0sIFttYXRoXSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkTWF0aE1MO1xuIiwidmFyIGJ1aWxkSFRNTCA9IHJlcXVpcmUoXCIuL2J1aWxkSFRNTFwiKTtcbnZhciBidWlsZE1hdGhNTCA9IHJlcXVpcmUoXCIuL2J1aWxkTWF0aE1MXCIpO1xudmFyIGJ1aWxkQ29tbW9uID0gcmVxdWlyZShcIi4vYnVpbGRDb21tb25cIik7XG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoXCIuL09wdGlvbnNcIik7XG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKFwiLi9TZXR0aW5nc1wiKTtcbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL1N0eWxlXCIpO1xuXG52YXIgbWFrZVNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbjtcblxudmFyIGJ1aWxkVHJlZSA9IGZ1bmN0aW9uKHRyZWUsIGV4cHJlc3Npb24sIHNldHRpbmdzKSB7XG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCBuZXcgU2V0dGluZ3Moe30pO1xuXG4gICAgdmFyIHN0YXJ0U3R5bGUgPSBTdHlsZS5URVhUO1xuICAgIGlmIChzZXR0aW5ncy5kaXNwbGF5TW9kZSkge1xuICAgICAgICBzdGFydFN0eWxlID0gU3R5bGUuRElTUExBWTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucyh7XG4gICAgICAgIHN0eWxlOiBzdGFydFN0eWxlLFxuICAgICAgICBzaXplOiBcInNpemU1XCJcbiAgICB9KTtcblxuICAgIC8vIGBidWlsZEhUTUxgIHNvbWV0aW1lcyBtZXNzZXMgd2l0aCB0aGUgcGFyc2UgdHJlZSAobGlrZSB0dXJuaW5nIGJpbnMgLT5cbiAgICAvLyBvcmRzKSwgc28gd2UgYnVpbGQgdGhlIE1hdGhNTCB2ZXJzaW9uIGZpcnN0LlxuICAgIHZhciBtYXRoTUxOb2RlID0gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgb3B0aW9ucyk7XG4gICAgdmFyIGh0bWxOb2RlID0gYnVpbGRIVE1MKHRyZWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIGthdGV4Tm9kZSA9IG1ha2VTcGFuKFtcImthdGV4XCJdLCBbXG4gICAgICAgIG1hdGhNTE5vZGUsIGh0bWxOb2RlXG4gICAgXSk7XG5cbiAgICBpZiAoc2V0dGluZ3MuZGlzcGxheU1vZGUpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTcGFuKFtcImthdGV4LWRpc3BsYXlcIl0sIFtrYXRleE5vZGVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga2F0ZXhOb2RlO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRUcmVlO1xuIiwiLyoqXG4gKiBUaGlzIGZpbGUgZGVhbHMgd2l0aCBjcmVhdGluZyBkZWxpbWl0ZXJzIG9mIHZhcmlvdXMgc2l6ZXMuIFRoZSBUZVhib29rXG4gKiBkaXNjdXNzZXMgdGhlc2Ugcm91dGluZXMgb24gcGFnZSA0NDEtNDQyLCBpbiB0aGUgXCJBbm90aGVyIHN1YnJvdXRpbmUgc2V0cyBib3hcbiAqIHggdG8gYSBzcGVjaWZpZWQgdmFyaWFibGUgZGVsaW1pdGVyXCIgcGFyYWdyYXBoLlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBtYWluIHJvdXRpbmVzIGhlcmUuIGBtYWtlU21hbGxEZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgaW4gdGhlXG4gKiBub3JtYWwgZm9udCwgYnV0IGluIGVpdGhlciB0ZXh0LCBzY3JpcHQsIG9yIHNjcmlwdHNjcmlwdCBzdHlsZS5cbiAqIGBtYWtlTGFyZ2VEZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgaW4gdGV4dHN0eWxlLCBidXQgaW4gb25lIG9mIHRoZSBTaXplMSxcbiAqIFNpemUyLCBTaXplMywgb3IgU2l6ZTQgZm9udHMuIGBtYWtlU3RhY2tlZERlbGltYCBtYWtlcyBhIGRlbGltaXRlciBvdXQgb2ZcbiAqIHNtYWxsZXIgcGllY2VzIHRoYXQgYXJlIHN0YWNrZWQgb24gdG9wIG9mIG9uZSBhbm90aGVyLlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgdGFrZSBhIHBhcmFtZXRlciBgY2VudGVyYCwgd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgZGVsaW1pdGVyXG4gKiBzaG91bGQgYmUgY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzLlxuICpcbiAqIFRoZW4sIHRoZXJlIGFyZSB0aHJlZSBleHBvc2VkIGZ1bmN0aW9ucy4gYHNpemVkRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIGluXG4gKiBvbmUgb2YgdGhlIGdpdmVuIHNpemVzLiBUaGlzIGlzIHVzZWQgZm9yIHRoaW5ncyBsaWtlIGBcXGJpZ2xgLlxuICogYGN1c3RvbVNpemVkRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIHdpdGggYSBnaXZlbiB0b3RhbCBoZWlnaHQrZGVwdGguIEl0IGlzXG4gKiBjYWxsZWQgaW4gcGxhY2VzIGxpa2UgYFxcc3FydGAuIGBsZWZ0UmlnaHREZWxpbWAgbWFrZXMgYW4gYXBwcm9wcmlhdGVcbiAqIGRlbGltaXRlciB3aGljaCBzdXJyb3VuZHMgYW4gZXhwcmVzc2lvbiBvZiBhIGdpdmVuIGhlaWdodCBhbiBkZXB0aC4gSXQgaXNcbiAqIHVzZWQgaW4gYFxcbGVmdGAgYW5kIGBcXHJpZ2h0YC5cbiAqL1xuXG52YXIgUGFyc2VFcnJvciA9IHJlcXVpcmUoXCIuL1BhcnNlRXJyb3JcIik7XG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9TdHlsZVwiKTtcblxudmFyIGJ1aWxkQ29tbW9uID0gcmVxdWlyZShcIi4vYnVpbGRDb21tb25cIik7XG52YXIgZm9udE1ldHJpY3MgPSByZXF1aXJlKFwiLi9mb250TWV0cmljc1wiKTtcbnZhciBzeW1ib2xzID0gcmVxdWlyZShcIi4vc3ltYm9sc1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG52YXIgbWFrZVNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbjtcblxuLyoqXG4gKiBHZXQgdGhlIG1ldHJpY3MgZm9yIGEgZ2l2ZW4gc3ltYm9sIGFuZCBmb250LCBhZnRlciB0cmFuc2Zvcm1hdGlvbiAoaS5lLlxuICogYWZ0ZXIgZm9sbG93aW5nIHJlcGxhY2VtZW50IGZyb20gc3ltYm9scy5qcylcbiAqL1xudmFyIGdldE1ldHJpY3MgPSBmdW5jdGlvbihzeW1ib2wsIGZvbnQpIHtcbiAgICBpZiAoc3ltYm9scy5tYXRoW3N5bWJvbF0gJiYgc3ltYm9scy5tYXRoW3N5bWJvbF0ucmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljcyhcbiAgICAgICAgICAgIHN5bWJvbHMubWF0aFtzeW1ib2xdLnJlcGxhY2UsIGZvbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmb250TWV0cmljcy5nZXRDaGFyYWN0ZXJNZXRyaWNzKFxuICAgICAgICAgICAgc3ltYm9sLCBmb250KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHN5bWJvbCBpbiB0aGUgZ2l2ZW4gZm9udCBzaXplIChub3RlIHNpemUgaXMgYW4gaW50ZWdlcilcbiAqL1xudmFyIG1hdGhybVNpemUgPSBmdW5jdGlvbih2YWx1ZSwgc2l6ZSwgbW9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3ltYm9sKHZhbHVlLCBcIlNpemVcIiArIHNpemUgKyBcIi1SZWd1bGFyXCIsXG4gICAgICAgIG1vZGUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgZGVsaW1pdGVyIHNwYW4gaW4gYSBnaXZlbiBzdHlsZSwgYW5kIGFkZHMgYXBwcm9wcmlhdGUgaGVpZ2h0LCBkZXB0aCxcbiAqIGFuZCBtYXhGb250U2l6ZXMuXG4gKi9cbnZhciBzdHlsZVdyYXAgPSBmdW5jdGlvbihkZWxpbSwgdG9TdHlsZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICAgIGNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICAgIHZhciBzcGFuID0gbWFrZVNwYW4oXG4gICAgICAgIGNsYXNzZXMuY29uY2F0KFtcInN0eWxlLXdyYXBcIiwgb3B0aW9ucy5zdHlsZS5yZXNldCgpLCB0b1N0eWxlLmNscygpXSksXG4gICAgICAgIFtkZWxpbV0sIG9wdGlvbnMpO1xuXG4gICAgdmFyIG11bHRpcGxpZXIgPSB0b1N0eWxlLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIHNwYW4uaGVpZ2h0ICo9IG11bHRpcGxpZXI7XG4gICAgc3Bhbi5kZXB0aCAqPSBtdWx0aXBsaWVyO1xuICAgIHNwYW4ubWF4Rm9udFNpemUgPSB0b1N0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgcmV0dXJuIHNwYW47XG59O1xuXG4vKipcbiAqIE1ha2VzIGEgc21hbGwgZGVsaW1pdGVyLiBUaGlzIGlzIGEgZGVsaW1pdGVyIHRoYXQgY29tZXMgaW4gdGhlIE1haW4tUmVndWxhclxuICogZm9udCwgYnV0IGlzIHJlc3R5bGVkIHRvIGVpdGhlciBiZSBpbiB0ZXh0c3R5bGUsIHNjcmlwdHN0eWxlLCBvclxuICogc2NyaXB0c2NyaXB0c3R5bGUuXG4gKi9cbnZhciBtYWtlU21hbGxEZWxpbSA9IGZ1bmN0aW9uKGRlbGltLCBzdHlsZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gICAgdmFyIHRleHQgPSBidWlsZENvbW1vbi5tYWtlU3ltYm9sKGRlbGltLCBcIk1haW4tUmVndWxhclwiLCBtb2RlLCBvcHRpb25zKTtcblxuICAgIHZhciBzcGFuID0gc3R5bGVXcmFwKHRleHQsIHN0eWxlLCBvcHRpb25zLCBjbGFzc2VzKTtcblxuICAgIGlmIChjZW50ZXIpIHtcbiAgICAgICAgdmFyIHNoaWZ0ID1cbiAgICAgICAgICAgICgxIC0gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllciAvIHN0eWxlLnNpemVNdWx0aXBsaWVyKSAqXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodDtcblxuICAgICAgICBzcGFuLnN0eWxlLnRvcCA9IHNoaWZ0ICsgXCJlbVwiO1xuICAgICAgICBzcGFuLmhlaWdodCAtPSBzaGlmdDtcbiAgICAgICAgc3Bhbi5kZXB0aCArPSBzaGlmdDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Bhbjtcbn07XG5cbi8qKlxuICogTWFrZXMgYSBsYXJnZSBkZWxpbWl0ZXIuIFRoaXMgaXMgYSBkZWxpbWl0ZXIgdGhhdCBjb21lcyBpbiB0aGUgU2l6ZTEsIFNpemUyLFxuICogU2l6ZTMsIG9yIFNpemU0IGZvbnRzLiBJdCBpcyBhbHdheXMgcmVuZGVyZWQgaW4gdGV4dHN0eWxlLlxuICovXG52YXIgbWFrZUxhcmdlRGVsaW0gPSBmdW5jdGlvbihkZWxpbSwgc2l6ZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gICAgdmFyIGlubmVyID0gbWF0aHJtU2l6ZShkZWxpbSwgc2l6ZSwgbW9kZSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgc3BhbiA9IHN0eWxlV3JhcChcbiAgICAgICAgbWFrZVNwYW4oW1wiZGVsaW1zaXppbmdcIiwgXCJzaXplXCIgKyBzaXplXSwgW2lubmVyXSwgb3B0aW9ucyksXG4gICAgICAgIFN0eWxlLlRFWFQsIG9wdGlvbnMsIGNsYXNzZXMpO1xuXG4gICAgaWYgKGNlbnRlcikge1xuICAgICAgICB2YXIgc2hpZnQgPSAoMSAtIG9wdGlvbnMuc3R5bGUuc2l6ZU11bHRpcGxpZXIpICpcbiAgICAgICAgICAgIG9wdGlvbnMuc3R5bGUubWV0cmljcy5heGlzSGVpZ2h0O1xuXG4gICAgICAgIHNwYW4uc3R5bGUudG9wID0gc2hpZnQgKyBcImVtXCI7XG4gICAgICAgIHNwYW4uaGVpZ2h0IC09IHNoaWZ0O1xuICAgICAgICBzcGFuLmRlcHRoICs9IHNoaWZ0O1xuICAgIH1cblxuICAgIHJldHVybiBzcGFuO1xufTtcblxuLyoqXG4gKiBNYWtlIGFuIGlubmVyIHNwYW4gd2l0aCB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCBpbiB0aGUgZ2l2ZW4gZm9udC4gVGhpcyBpcyB1c2VkXG4gKiBpbiBgbWFrZVN0YWNrZWREZWxpbWAgdG8gbWFrZSB0aGUgc3RhY2tpbmcgcGllY2VzIGZvciB0aGUgZGVsaW1pdGVyLlxuICovXG52YXIgbWFrZUlubmVyID0gZnVuY3Rpb24oc3ltYm9sLCBmb250LCBtb2RlKSB7XG4gICAgdmFyIHNpemVDbGFzcztcbiAgICAvLyBBcHBseSB0aGUgY29ycmVjdCBDU1MgY2xhc3MgdG8gY2hvb3NlIHRoZSByaWdodCBmb250LlxuICAgIGlmIChmb250ID09PSBcIlNpemUxLVJlZ3VsYXJcIikge1xuICAgICAgICBzaXplQ2xhc3MgPSBcImRlbGltLXNpemUxXCI7XG4gICAgfSBlbHNlIGlmIChmb250ID09PSBcIlNpemU0LVJlZ3VsYXJcIikge1xuICAgICAgICBzaXplQ2xhc3MgPSBcImRlbGltLXNpemU0XCI7XG4gICAgfVxuXG4gICAgdmFyIGlubmVyID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImRlbGltc2l6aW5naW5uZXJcIiwgc2l6ZUNsYXNzXSxcbiAgICAgICAgW21ha2VTcGFuKFtdLCBbYnVpbGRDb21tb24ubWFrZVN5bWJvbChzeW1ib2wsIGZvbnQsIG1vZGUpXSldKTtcblxuICAgIC8vIFNpbmNlIHRoaXMgd2lsbCBiZSBwYXNzZWQgaW50byBgbWFrZVZMaXN0YCBpbiB0aGUgZW5kLCB3cmFwIHRoZSBlbGVtZW50XG4gICAgLy8gaW4gdGhlIGFwcHJvcHJpYXRlIHRhZyB0aGF0IFZMaXN0IHVzZXMuXG4gICAgcmV0dXJuIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogaW5uZXJ9O1xufTtcblxuLyoqXG4gKiBNYWtlIGEgc3RhY2tlZCBkZWxpbWl0ZXIgb3V0IG9mIGEgZ2l2ZW4gZGVsaW1pdGVyLCB3aXRoIHRoZSB0b3RhbCBoZWlnaHQgYXRcbiAqIGxlYXN0IGBoZWlnaHRUb3RhbGAuIFRoaXMgcm91dGluZSBpcyBtZW50aW9uZWQgb24gcGFnZSA0NDIgb2YgdGhlIFRlWGJvb2suXG4gKi9cbnZhciBtYWtlU3RhY2tlZERlbGltID0gZnVuY3Rpb24oZGVsaW0sIGhlaWdodFRvdGFsLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpIHtcbiAgICAvLyBUaGVyZSBhcmUgZm91ciBwYXJ0cywgdGhlIHRvcCwgYW4gb3B0aW9uYWwgbWlkZGxlLCBhIHJlcGVhdGVkIHBhcnQsIGFuZCBhXG4gICAgLy8gYm90dG9tLlxuICAgIHZhciB0b3A7XG4gICAgdmFyIG1pZGRsZTtcbiAgICB2YXIgcmVwZWF0O1xuICAgIHZhciBib3R0b207XG4gICAgdG9wID0gcmVwZWF0ID0gYm90dG9tID0gZGVsaW07XG4gICAgbWlkZGxlID0gbnVsbDtcbiAgICAvLyBBbHNvIGtlZXAgdHJhY2sgb2Ygd2hhdCBmb250IHRoZSBkZWxpbWl0ZXJzIGFyZSBpblxuICAgIHZhciBmb250ID0gXCJTaXplMS1SZWd1bGFyXCI7XG5cbiAgICAvLyBXZSBzZXQgdGhlIHBhcnRzIGFuZCBmb250IGJhc2VkIG9uIHRoZSBzeW1ib2wuIE5vdGUgdGhhdCB3ZSB1c2VcbiAgICAvLyAnXFx1MjNkMCcgaW5zdGVhZCBvZiAnfCcgYW5kICdcXHUyMDE2JyBpbnN0ZWFkIG9mICdcXFxcfCcgZm9yIHRoZVxuICAgIC8vIHJlcGVhdHMgb2YgdGhlIGFycm93c1xuICAgIGlmIChkZWxpbSA9PT0gXCJcXFxcdXBhcnJvd1wiKSB7XG4gICAgICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNkMFwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXFVwYXJyb3dcIikge1xuICAgICAgICByZXBlYXQgPSBib3R0b20gPSBcIlxcdTIwMTZcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxkb3duYXJyb3dcIikge1xuICAgICAgICB0b3AgPSByZXBlYXQgPSBcIlxcdTIzZDBcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxEb3duYXJyb3dcIikge1xuICAgICAgICB0b3AgPSByZXBlYXQgPSBcIlxcdTIwMTZcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFx1cGRvd25hcnJvd1wiKSB7XG4gICAgICAgIHRvcCA9IFwiXFxcXHVwYXJyb3dcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyM2QwXCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFxcXGRvd25hcnJvd1wiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXFVwZG93bmFycm93XCIpIHtcbiAgICAgICAgdG9wID0gXCJcXFxcVXBhcnJvd1wiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIwMTZcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXFxcRG93bmFycm93XCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJbXCIgfHwgZGVsaW0gPT09IFwiXFxcXGxicmFja1wiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1MjNhMVwiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIzYTJcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXHUyM2EzXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIl1cIiB8fCBkZWxpbSA9PT0gXCJcXFxccmJyYWNrXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E0XCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjNhNVwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTZcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxmbG9vclwiKSB7XG4gICAgICAgIHJlcGVhdCA9IHRvcCA9IFwiXFx1MjNhMlwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTNcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxjZWlsXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2ExXCI7XG4gICAgICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNhMlwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccmZsb29yXCIpIHtcbiAgICAgICAgcmVwZWF0ID0gdG9wID0gXCJcXHUyM2E1XCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjNhNlwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccmNlaWxcIikge1xuICAgICAgICB0b3AgPSBcIlxcdTIzYTRcIjtcbiAgICAgICAgcmVwZWF0ID0gYm90dG9tID0gXCJcXHUyM2E1XCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIihcIikge1xuICAgICAgICB0b3AgPSBcIlxcdTIzOWJcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyMzljXCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjM5ZFwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCIpXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyMzllXCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjM5ZlwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTBcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHtcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbGJyYWNlXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgICAgIG1pZGRsZSA9IFwiXFx1MjNhOFwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTlcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFx9XCIgfHwgZGVsaW0gPT09IFwiXFxcXHJicmFjZVwiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1MjNhYlwiO1xuICAgICAgICBtaWRkbGUgPSBcIlxcdTIzYWNcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXHUyM2FkXCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcbGdyb3VwXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjNhOVwiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJncm91cFwiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1MjNhYlwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYWRcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxsbW91c3RhY2hlXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjNhZFwiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJtb3VzdGFjaGVcIikge1xuICAgICAgICB0b3AgPSBcIlxcdTIzYWJcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXHUyM2E5XCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcc3VyZFwiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1ZTAwMVwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYjdcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHVlMDAwXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIG1ldHJpY3Mgb2YgdGhlIGZvdXIgc2VjdGlvbnNcbiAgICB2YXIgdG9wTWV0cmljcyA9IGdldE1ldHJpY3ModG9wLCBmb250KTtcbiAgICB2YXIgdG9wSGVpZ2h0VG90YWwgPSB0b3BNZXRyaWNzLmhlaWdodCArIHRvcE1ldHJpY3MuZGVwdGg7XG4gICAgdmFyIHJlcGVhdE1ldHJpY3MgPSBnZXRNZXRyaWNzKHJlcGVhdCwgZm9udCk7XG4gICAgdmFyIHJlcGVhdEhlaWdodFRvdGFsID0gcmVwZWF0TWV0cmljcy5oZWlnaHQgKyByZXBlYXRNZXRyaWNzLmRlcHRoO1xuICAgIHZhciBib3R0b21NZXRyaWNzID0gZ2V0TWV0cmljcyhib3R0b20sIGZvbnQpO1xuICAgIHZhciBib3R0b21IZWlnaHRUb3RhbCA9IGJvdHRvbU1ldHJpY3MuaGVpZ2h0ICsgYm90dG9tTWV0cmljcy5kZXB0aDtcbiAgICB2YXIgbWlkZGxlSGVpZ2h0VG90YWwgPSAwO1xuICAgIHZhciBtaWRkbGVGYWN0b3IgPSAxO1xuICAgIGlmIChtaWRkbGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG1pZGRsZU1ldHJpY3MgPSBnZXRNZXRyaWNzKG1pZGRsZSwgZm9udCk7XG4gICAgICAgIG1pZGRsZUhlaWdodFRvdGFsID0gbWlkZGxlTWV0cmljcy5oZWlnaHQgKyBtaWRkbGVNZXRyaWNzLmRlcHRoO1xuICAgICAgICBtaWRkbGVGYWN0b3IgPSAyOyAvLyByZXBlYXQgc3ltbWV0cmljYWxseSBhYm92ZSBhbmQgYmVsb3cgbWlkZGxlXG4gICAgfVxuXG4gICAgLy8gQ2FsY3VhdGUgdGhlIG1pbmltYWwgaGVpZ2h0IHRoYXQgdGhlIGRlbGltaXRlciBjYW4gaGF2ZS5cbiAgICAvLyBJdCBpcyBhdCBsZWFzdCB0aGUgc2l6ZSBvZiB0aGUgdG9wLCBib3R0b20sIGFuZCBvcHRpb25hbCBtaWRkbGUgY29tYmluZWQuXG4gICAgdmFyIG1pbkhlaWdodCA9IHRvcEhlaWdodFRvdGFsICsgYm90dG9tSGVpZ2h0VG90YWwgKyBtaWRkbGVIZWlnaHRUb3RhbDtcblxuICAgIC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiBjb3BpZXMgb2YgdGhlIHJlcGVhdCBzeW1ib2wgd2Ugd2lsbCBuZWVkXG4gICAgdmFyIHJlcGVhdENvdW50ID0gTWF0aC5jZWlsKFxuICAgICAgICAoaGVpZ2h0VG90YWwgLSBtaW5IZWlnaHQpIC8gKG1pZGRsZUZhY3RvciAqIHJlcGVhdEhlaWdodFRvdGFsKSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGRlbGltaXRlciBpbmNsdWRpbmcgYWxsIHRoZSBzeW1ib2xzXG4gICAgdmFyIHJlYWxIZWlnaHRUb3RhbCA9XG4gICAgICAgIG1pbkhlaWdodCArIHJlcGVhdENvdW50ICogbWlkZGxlRmFjdG9yICogcmVwZWF0SGVpZ2h0VG90YWw7XG5cbiAgICAvLyBUaGUgY2VudGVyIG9mIHRoZSBkZWxpbWl0ZXIgaXMgcGxhY2VkIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGF4aXMuIE5vdGVcbiAgICAvLyB0aGF0IGluIHRoaXMgY29udGV4dCwgXCJjZW50ZXJcIiBtZWFucyB0aGF0IHRoZSBkZWxpbWl0ZXIgc2hvdWxkIGJlXG4gICAgLy8gY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzIGluIHRoZSBjdXJyZW50IHN0eWxlLCB3aGlsZSBub3JtYWxseSBpdCBpc1xuICAgIC8vIGNlbnRlcmVkIGFyb3VuZCB0aGUgYXhpcyBpbiB0ZXh0c3R5bGUuXG4gICAgdmFyIGF4aXNIZWlnaHQgPSBvcHRpb25zLnN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodDtcbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgIGF4aXNIZWlnaHQgKj0gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXB0aFxuICAgIHZhciBkZXB0aCA9IHJlYWxIZWlnaHRUb3RhbCAvIDIgLSBheGlzSGVpZ2h0O1xuXG4gICAgLy8gTm93LCB3ZSBzdGFydCBidWlsZGluZyB0aGUgcGllY2VzIHRoYXQgd2lsbCBnbyBpbnRvIHRoZSB2bGlzdFxuXG4gICAgLy8gS2VlcCBhIGxpc3Qgb2YgdGhlIGlubmVyIHBpZWNlc1xuICAgIHZhciBpbm5lcnMgPSBbXTtcblxuICAgIC8vIEFkZCB0aGUgYm90dG9tIHN5bWJvbFxuICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcihib3R0b20sIGZvbnQsIG1vZGUpKTtcblxuICAgIHZhciBpO1xuICAgIGlmIChtaWRkbGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gQWRkIHRoYXQgbWFueSBzeW1ib2xzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXBlYXRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpbm5lcnMucHVzaChtYWtlSW5uZXIocmVwZWF0LCBmb250LCBtb2RlKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIGEgbWlkZGxlIGJpdCwgd2UgbmVlZCB0aGUgbWlkZGxlIHBhcnQgYW5kIHR3byByZXBlYXRlZFxuICAgICAgICAvLyBzZWN0aW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVwZWF0Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgaW5uZXJzLnB1c2gobWFrZUlubmVyKHJlcGVhdCwgZm9udCwgbW9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcihtaWRkbGUsIGZvbnQsIG1vZGUpKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlcGVhdENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcihyZXBlYXQsIGZvbnQsIG1vZGUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgdG9wIHN5bWJvbFxuICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcih0b3AsIGZvbnQsIG1vZGUpKTtcblxuICAgIC8vIEZpbmFsbHksIGJ1aWxkIHRoZSB2bGlzdFxuICAgIHZhciBpbm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChpbm5lcnMsIFwiYm90dG9tXCIsIGRlcHRoLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBzdHlsZVdyYXAoXG4gICAgICAgIG1ha2VTcGFuKFtcImRlbGltc2l6aW5nXCIsIFwibXVsdFwiXSwgW2lubmVyXSwgb3B0aW9ucyksXG4gICAgICAgIFN0eWxlLlRFWFQsIG9wdGlvbnMsIGNsYXNzZXMpO1xufTtcblxuLy8gVGhlcmUgYXJlIHRocmVlIGtpbmRzIG9mIGRlbGltaXRlcnMsIGRlbGltaXRlcnMgdGhhdCBzdGFjayB3aGVuIHRoZXkgYmVjb21lXG4vLyB0b28gbGFyZ2VcbnZhciBzdGFja0xhcmdlRGVsaW1pdGVycyA9IFtcbiAgICBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgXCJdXCIsIFwiXFxcXHJicmFja1wiLFxuICAgIFwiXFxcXHtcIiwgXCJcXFxcbGJyYWNlXCIsIFwiXFxcXH1cIiwgXCJcXFxccmJyYWNlXCIsXG4gICAgXCJcXFxcbGZsb29yXCIsIFwiXFxcXHJmbG9vclwiLCBcIlxcXFxsY2VpbFwiLCBcIlxcXFxyY2VpbFwiLFxuICAgIFwiXFxcXHN1cmRcIlxuXTtcblxuLy8gZGVsaW1pdGVycyB0aGF0IGFsd2F5cyBzdGFja1xudmFyIHN0YWNrQWx3YXlzRGVsaW1pdGVycyA9IFtcbiAgICBcIlxcXFx1cGFycm93XCIsIFwiXFxcXGRvd25hcnJvd1wiLCBcIlxcXFx1cGRvd25hcnJvd1wiLFxuICAgIFwiXFxcXFVwYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsIFwiXFxcXFVwZG93bmFycm93XCIsXG4gICAgXCJ8XCIsIFwiXFxcXHxcIiwgXCJcXFxcdmVydFwiLCBcIlxcXFxWZXJ0XCIsXG4gICAgXCJcXFxcbHZlcnRcIiwgXCJcXFxccnZlcnRcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIixcbiAgICBcIlxcXFxsZ3JvdXBcIiwgXCJcXFxccmdyb3VwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgXCJcXFxccm1vdXN0YWNoZVwiXG5dO1xuXG4vLyBhbmQgZGVsaW1pdGVycyB0aGF0IG5ldmVyIHN0YWNrXG52YXIgc3RhY2tOZXZlckRlbGltaXRlcnMgPSBbXG4gICAgXCI8XCIsIFwiPlwiLCBcIlxcXFxsYW5nbGVcIiwgXCJcXFxccmFuZ2xlXCIsIFwiL1wiLCBcIlxcXFxiYWNrc2xhc2hcIiwgXCJcXFxcbHRcIiwgXCJcXFxcZ3RcIlxuXTtcblxuLy8gTWV0cmljcyBvZiB0aGUgZGlmZmVyZW50IHNpemVzLiBGb3VuZCBieSBsb29raW5nIGF0IFRlWCdzIG91dHB1dCBvZlxuLy8gJFxcYmlnbHwgLy8gXFxCaWdsfCBcXGJpZ2dsfCBcXEJpZ2dsfCBcXHNob3dsaXN0cyRcbi8vIFVzZWQgdG8gY3JlYXRlIHN0YWNrZWQgZGVsaW1pdGVycyBvZiBhcHByb3ByaWF0ZSBzaXplcyBpbiBtYWtlU2l6ZWREZWxpbS5cbnZhciBzaXplVG9NYXhIZWlnaHQgPSBbMCwgMS4yLCAxLjgsIDIuNCwgMy4wXTtcblxuLyoqXG4gKiBVc2VkIHRvIGNyZWF0ZSBhIGRlbGltaXRlciBvZiBhIHNwZWNpZmljIHNpemUsIHdoZXJlIGBzaXplYCBpcyAxLCAyLCAzLCBvciA0LlxuICovXG52YXIgbWFrZVNpemVkRGVsaW0gPSBmdW5jdGlvbihkZWxpbSwgc2l6ZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICAgIC8vIDwgYW5kID4gdHVybiBpbnRvIFxcbGFuZ2xlIGFuZCBcXHJhbmdsZSBpbiBkZWxpbWl0ZXJzXG4gICAgaWYgKGRlbGltID09PSBcIjxcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbHRcIikge1xuICAgICAgICBkZWxpbSA9IFwiXFxcXGxhbmdsZVwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiPlwiIHx8IGRlbGltID09PSBcIlxcXFxndFwiKSB7XG4gICAgICAgIGRlbGltID0gXCJcXFxccmFuZ2xlXCI7XG4gICAgfVxuXG4gICAgLy8gU2l6ZWQgZGVsaW1pdGVycyBhcmUgbmV2ZXIgY2VudGVyZWQuXG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrTGFyZ2VEZWxpbWl0ZXJzLCBkZWxpbSkgfHxcbiAgICAgICAgdXRpbHMuY29udGFpbnMoc3RhY2tOZXZlckRlbGltaXRlcnMsIGRlbGltKSkge1xuICAgICAgICByZXR1cm4gbWFrZUxhcmdlRGVsaW0oZGVsaW0sIHNpemUsIGZhbHNlLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrQWx3YXlzRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgICAgIHJldHVybiBtYWtlU3RhY2tlZERlbGltKFxuICAgICAgICAgICAgZGVsaW0sIHNpemVUb01heEhlaWdodFtzaXplXSwgZmFsc2UsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSWxsZWdhbCBkZWxpbWl0ZXI6ICdcIiArIGRlbGltICsgXCInXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhlcmUgYXJlIHRocmVlIGRpZmZlcmVudCBzZXF1ZW5jZXMgb2YgZGVsaW1pdGVyIHNpemVzIHRoYXQgdGhlIGRlbGltaXRlcnNcbiAqIGZvbGxvdyBkZXBlbmRpbmcgb24gdGhlIGtpbmQgb2YgZGVsaW1pdGVyLiBUaGlzIGlzIHVzZWQgd2hlbiBjcmVhdGluZyBjdXN0b21cbiAqIHNpemVkIGRlbGltaXRlcnMgdG8gZGVjaWRlIHdoZXRoZXIgdG8gY3JlYXRlIGEgc21hbGwsIGxhcmdlLCBvciBzdGFja2VkXG4gKiBkZWxpbWl0ZXIuXG4gKlxuICogSW4gcmVhbCBUZVgsIHRoZXNlIHNlcXVlbmNlcyBhcmVuJ3QgZXhwbGljaXRseSBkZWZpbmVkLCBidXQgYXJlIGluc3RlYWRcbiAqIGRlZmluZWQgaW5zaWRlIHRoZSBmb250IG1ldHJpY3MuIFNpbmNlIHRoZXJlIGFyZSBvbmx5IHRocmVlIHNlcXVlbmNlcyB0aGF0XG4gKiBhcmUgcG9zc2libGUgZm9yIHRoZSBkZWxpbWl0ZXJzIHRoYXQgVGVYIGRlZmluZXMsIGl0IGlzIGVhc2llciB0byBqdXN0IGVuY29kZVxuICogdGhlbSBleHBsaWNpdGx5IGhlcmUuXG4gKi9cblxuLy8gRGVsaW1pdGVycyB0aGF0IG5ldmVyIHN0YWNrIHRyeSBzbWFsbCBkZWxpbWl0ZXJzIGFuZCBsYXJnZSBkZWxpbWl0ZXJzIG9ubHlcbnZhciBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2UgPSBbXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVFNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlRFWFR9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDF9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDJ9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDN9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDR9XG5dO1xuXG4vLyBEZWxpbWl0ZXJzIHRoYXQgYWx3YXlzIHN0YWNrIHRyeSB0aGUgc21hbGwgZGVsaW1pdGVycyBmaXJzdCwgdGhlbiBzdGFja1xudmFyIHN0YWNrQWx3YXlzRGVsaW1pdGVyU2VxdWVuY2UgPSBbXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVFNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlRFWFR9LFxuICAgIHt0eXBlOiBcInN0YWNrXCJ9XG5dO1xuXG4vLyBEZWxpbWl0ZXJzIHRoYXQgc3RhY2sgd2hlbiBsYXJnZSB0cnkgdGhlIHNtYWxsIGFuZCB0aGVuIGxhcmdlIGRlbGltaXRlcnMsIGFuZFxuLy8gc3RhY2sgYWZ0ZXJ3YXJkc1xudmFyIHN0YWNrTGFyZ2VEZWxpbWl0ZXJTZXF1ZW5jZSA9IFtcbiAgICB7dHlwZTogXCJzbWFsbFwiLCBzdHlsZTogU3R5bGUuU0NSSVBUU0NSSVBUfSxcbiAgICB7dHlwZTogXCJzbWFsbFwiLCBzdHlsZTogU3R5bGUuU0NSSVBUfSxcbiAgICB7dHlwZTogXCJzbWFsbFwiLCBzdHlsZTogU3R5bGUuVEVYVH0sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogMX0sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogMn0sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogM30sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogNH0sXG4gICAge3R5cGU6IFwic3RhY2tcIn1cbl07XG5cbi8qKlxuICogR2V0IHRoZSBmb250IHVzZWQgaW4gYSBkZWxpbWl0ZXIgYmFzZWQgb24gd2hhdCBraW5kIG9mIGRlbGltaXRlciBpdCBpcy5cbiAqL1xudmFyIGRlbGltVHlwZVRvRm9udCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiTWFpbi1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgICAgICByZXR1cm4gXCJTaXplXCIgKyB0eXBlLnNpemUgKyBcIi1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlLnR5cGUgPT09IFwic3RhY2tcIikge1xuICAgICAgICByZXR1cm4gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmF2ZXJzZSBhIHNlcXVlbmNlIG9mIHR5cGVzIG9mIGRlbGltaXRlcnMgdG8gZGVjaWRlIHdoYXQga2luZCBvZiBkZWxpbWl0ZXJcbiAqIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIGRlbGltaXRlciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0K2RlcHRoLlxuICovXG52YXIgdHJhdmVyc2VTZXF1ZW5jZSA9IGZ1bmN0aW9uKGRlbGltLCBoZWlnaHQsIHNlcXVlbmNlLCBvcHRpb25zKSB7XG4gICAgLy8gSGVyZSwgd2UgY2hvb3NlIHRoZSBpbmRleCB3ZSBzaG91bGQgc3RhcnQgYXQgaW4gdGhlIHNlcXVlbmNlcy4gSW4gc21hbGxlclxuICAgIC8vIHNpemVzICh3aGljaCBjb3JyZXNwb25kIHRvIGxhcmdlciBudW1iZXJzIGluIHN0eWxlLnNpemUpIHdlIHN0YXJ0IGVhcmxpZXJcbiAgICAvLyBpbiB0aGUgc2VxdWVuY2UuIFRodXMsIHNjcmlwdHNjcmlwdCBzdGFydHMgYXQgaW5kZXggMy0zPTAsIHNjcmlwdCBzdGFydHNcbiAgICAvLyBhdCBpbmRleCAzLTI9MSwgdGV4dCBzdGFydHMgYXQgMy0xPTIsIGFuZCBkaXNwbGF5IHN0YXJ0cyBhdCBtaW4oMiwzLTApPTJcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbigyLCAzIC0gb3B0aW9ucy5zdHlsZS5zaXplKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VxdWVuY2VbaV0udHlwZSA9PT0gXCJzdGFja1wiKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFsd2F5cyB0aGUgbGFzdCBkZWxpbWl0ZXIsIHNvIHdlIGp1c3QgYnJlYWsgdGhlIGxvb3Agbm93LlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWV0cmljcyA9IGdldE1ldHJpY3MoZGVsaW0sIGRlbGltVHlwZVRvRm9udChzZXF1ZW5jZVtpXSkpO1xuICAgICAgICB2YXIgaGVpZ2h0RGVwdGggPSBtZXRyaWNzLmhlaWdodCArIG1ldHJpY3MuZGVwdGg7XG5cbiAgICAgICAgLy8gU21hbGwgZGVsaW1pdGVycyBhcmUgc2NhbGVkIGRvd24gdmVyc2lvbnMgb2YgdGhlIHNhbWUgZm9udCwgc28gd2VcbiAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHN0eWxlIGNoYW5nZSBzaXplLlxuXG4gICAgICAgIGlmIChzZXF1ZW5jZVtpXS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgICAgICAgIGhlaWdodERlcHRoICo9IHNlcXVlbmNlW2ldLnN0eWxlLnNpemVNdWx0aXBsaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGRlbGltaXRlciBhdCB0aGlzIHNpemUgd29ya3MgZm9yIHRoZSBnaXZlbiBoZWlnaHQuXG4gICAgICAgIGlmIChoZWlnaHREZXB0aCA+IGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbmNlW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgcmV0dXJuIHRoZSBsYXN0IHNlcXVlbmNlIGVsZW1lbnQuXG4gICAgcmV0dXJuIHNlcXVlbmNlW3NlcXVlbmNlLmxlbmd0aCAtIDFdO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgZGVsaW1pdGVyIG9mIGEgZ2l2ZW4gaGVpZ2h0K2RlcHRoLCB3aXRoIG9wdGlvbmFsIGNlbnRlcmluZy4gSGVyZSwgd2VcbiAqIHRyYXZlcnNlIHRoZSBzZXF1ZW5jZXMsIGFuZCBjcmVhdGUgYSBkZWxpbWl0ZXIgdGhhdCB0aGUgc2VxdWVuY2UgdGVsbHMgdXMgdG8uXG4gKi9cbnZhciBtYWtlQ3VzdG9tU2l6ZWREZWxpbSA9IGZ1bmN0aW9uKGRlbGltLCBoZWlnaHQsIGNlbnRlciwgb3B0aW9ucywgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpIHtcbiAgICBpZiAoZGVsaW0gPT09IFwiPFwiIHx8IGRlbGltID09PSBcIlxcXFxsdFwiKSB7XG4gICAgICAgIGRlbGltID0gXCJcXFxcbGFuZ2xlXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCI+XCIgfHwgZGVsaW0gPT09IFwiXFxcXGd0XCIpIHtcbiAgICAgICAgZGVsaW0gPSBcIlxcXFxyYW5nbGVcIjtcbiAgICB9XG5cbiAgICAvLyBEZWNpZGUgd2hhdCBzZXF1ZW5jZSB0byB1c2VcbiAgICB2YXIgc2VxdWVuY2U7XG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrTmV2ZXJEZWxpbWl0ZXJzLCBkZWxpbSkpIHtcbiAgICAgICAgc2VxdWVuY2UgPSBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2U7XG4gICAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyhzdGFja0xhcmdlRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgICAgIHNlcXVlbmNlID0gc3RhY2tMYXJnZURlbGltaXRlclNlcXVlbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcXVlbmNlID0gc3RhY2tBbHdheXNEZWxpbWl0ZXJTZXF1ZW5jZTtcbiAgICB9XG5cbiAgICAvLyBMb29rIHRocm91Z2ggdGhlIHNlcXVlbmNlXG4gICAgdmFyIGRlbGltVHlwZSA9IHRyYXZlcnNlU2VxdWVuY2UoZGVsaW0sIGhlaWdodCwgc2VxdWVuY2UsIG9wdGlvbnMpO1xuXG4gICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBzZXF1ZW5jZSBlbGVtZW50IHdlIGRlY2lkZWQgb24sIGNhbGwgdGhlIGFwcHJvcHJpYXRlXG4gICAgLy8gZnVuY3Rpb24uXG4gICAgaWYgKGRlbGltVHlwZS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTbWFsbERlbGltKGRlbGltLCBkZWxpbVR5cGUuc3R5bGUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpO1xuICAgIH0gZWxzZSBpZiAoZGVsaW1UeXBlLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgICAgICByZXR1cm4gbWFrZUxhcmdlRGVsaW0oZGVsaW0sIGRlbGltVHlwZS5zaXplLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzKTtcbiAgICB9IGVsc2UgaWYgKGRlbGltVHlwZS50eXBlID09PSBcInN0YWNrXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTdGFja2VkRGVsaW0oZGVsaW0sIGhlaWdodCwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2UgYSBkZWxpbWl0ZXIgZm9yIHVzZSB3aXRoIGBcXGxlZnRgIGFuZCBgXFxyaWdodGAsIGdpdmVuIGEgaGVpZ2h0IGFuZCBkZXB0aFxuICogb2YgYW4gZXhwcmVzc2lvbiB0aGF0IHRoZSBkZWxpbWl0ZXJzIHN1cnJvdW5kLlxuICovXG52YXIgbWFrZUxlZnRSaWdodERlbGltID0gZnVuY3Rpb24oZGVsaW0sIGhlaWdodCwgZGVwdGgsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcykge1xuICAgIC8vIFdlIGFsd2F5cyBjZW50ZXIgXFxsZWZ0L1xccmlnaHQgZGVsaW1pdGVycywgc28gdGhlIGF4aXMgaXMgYWx3YXlzIHNoaWZ0ZWRcbiAgICB2YXIgYXhpc0hlaWdodCA9XG4gICAgICAgIG9wdGlvbnMuc3R5bGUubWV0cmljcy5heGlzSGVpZ2h0ICogb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIC8vIFRha2VuIGZyb20gVGVYIHNvdXJjZSwgdGV4LndlYiwgZnVuY3Rpb24gbWFrZV9sZWZ0X3JpZ2h0XG4gICAgdmFyIGRlbGltaXRlckZhY3RvciA9IDkwMTtcbiAgICB2YXIgZGVsaW1pdGVyRXh0ZW5kID0gNS4wIC8gZm9udE1ldHJpY3MubWV0cmljcy5wdFBlckVtO1xuXG4gICAgdmFyIG1heERpc3RGcm9tQXhpcyA9IE1hdGgubWF4KFxuICAgICAgICBoZWlnaHQgLSBheGlzSGVpZ2h0LCBkZXB0aCArIGF4aXNIZWlnaHQpO1xuXG4gICAgdmFyIHRvdGFsSGVpZ2h0ID0gTWF0aC5tYXgoXG4gICAgICAgIC8vIEluIHJlYWwgVGVYLCBjYWxjdWxhdGlvbnMgYXJlIGRvbmUgdXNpbmcgaW50ZWdyYWwgdmFsdWVzIHdoaWNoIGFyZVxuICAgICAgICAvLyA2NTUzNiBwZXIgcHQsIG9yIDY1NTM2MCBwZXIgZW0uIFNvLCB0aGUgZGl2aXNpb24gaGVyZSB0cnVuY2F0ZXMgaW5cbiAgICAgICAgLy8gVGVYIGJ1dCBkb2Vzbid0IGhlcmUsIHByb2R1Y2luZyBkaWZmZXJlbnQgcmVzdWx0cy4gSWYgd2Ugd2FudGVkIHRvXG4gICAgICAgIC8vIGV4YWN0bHkgbWF0Y2ggVGVYJ3MgY2FsY3VsYXRpb24sIHdlIGNvdWxkIGRvXG4gICAgICAgIC8vICAgTWF0aC5mbG9vcig2NTUzNjAgKiBtYXhEaXN0RnJvbUF4aXMgLyA1MDApICpcbiAgICAgICAgLy8gICAgZGVsaW1pdGVyRmFjdG9yIC8gNjU1MzYwXG4gICAgICAgIC8vIChUbyBzZWUgdGhlIGRpZmZlcmVuY2UsIGNvbXBhcmVcbiAgICAgICAgLy8gICAgeF57eF57XFxsZWZ0KFxccnVsZXswLjFlbX17MC42OGVtfVxccmlnaHQpfX1cbiAgICAgICAgLy8gaW4gVGVYIGFuZCBLYVRlWClcbiAgICAgICAgbWF4RGlzdEZyb21BeGlzIC8gNTAwICogZGVsaW1pdGVyRmFjdG9yLFxuICAgICAgICAyICogbWF4RGlzdEZyb21BeGlzIC0gZGVsaW1pdGVyRXh0ZW5kKTtcblxuICAgIC8vIEZpbmFsbHksIHdlIGRlZmVyIHRvIGBtYWtlQ3VzdG9tU2l6ZWREZWxpbWAgd2l0aCBvdXIgY2FsY3VsYXRlZCB0b3RhbFxuICAgIC8vIGhlaWdodFxuICAgIHJldHVybiBtYWtlQ3VzdG9tU2l6ZWREZWxpbShkZWxpbSwgdG90YWxIZWlnaHQsIHRydWUsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2l6ZWREZWxpbTogbWFrZVNpemVkRGVsaW0sXG4gICAgY3VzdG9tU2l6ZWREZWxpbTogbWFrZUN1c3RvbVNpemVkRGVsaW0sXG4gICAgbGVmdFJpZ2h0RGVsaW06IG1ha2VMZWZ0UmlnaHREZWxpbVxufTtcbiIsIi8qKlxuICogVGhlc2Ugb2JqZWN0cyBzdG9yZSB0aGUgZGF0YSBhYm91dCB0aGUgRE9NIG5vZGVzIHdlIGNyZWF0ZSwgYXMgd2VsbCBhcyBzb21lXG4gKiBleHRyYSBkYXRhLiBUaGV5IGNhbiB0aGVuIGJlIHRyYW5zZm9ybWVkIGludG8gcmVhbCBET00gbm9kZXMgd2l0aCB0aGVcbiAqIGB0b05vZGVgIGZ1bmN0aW9uIG9yIEhUTUwgbWFya3VwIHVzaW5nIGB0b01hcmt1cGAuIFRoZXkgYXJlIHVzZWZ1bCBmb3IgYm90aFxuICogc3RvcmluZyBleHRyYSBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlcywgYXMgd2VsbCBhcyBwcm92aWRpbmcgYSB3YXkgdG8gZWFzaWx5XG4gKiB3b3JrIHdpdGggdGhlIERPTS5cbiAqXG4gKiBTaW1pbGFyIGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIE1hdGhNTCBub2RlcyBleGlzdCBpbiBtYXRoTUxUcmVlLmpzLlxuICovXG52YXIgdW5pY29kZVJlZ2V4ZXMgPSByZXF1aXJlKFwiLi91bmljb2RlUmVnZXhlc1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBIVE1MIGNsYXNzTmFtZSBiYXNlZCBvbiBhIGxpc3Qgb2YgY2xhc3Nlcy4gSW4gYWRkaXRpb24gdG8gam9pbmluZ1xuICogd2l0aCBzcGFjZXMsIHdlIGFsc28gcmVtb3ZlIG51bGwgb3IgZW1wdHkgY2xhc3Nlcy5cbiAqL1xudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24oY2xhc3Nlcykge1xuICAgIGNsYXNzZXMgPSBjbGFzc2VzLnNsaWNlKCk7XG4gICAgZm9yICh2YXIgaSA9IGNsYXNzZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKCFjbGFzc2VzW2ldKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbGFzc2VzLmpvaW4oXCIgXCIpO1xufTtcblxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHNwYW4gbm9kZSwgd2l0aCBhIGNsYXNzTmFtZSwgYSBsaXN0IG9mIGNoaWxkcmVuLCBhbmRcbiAqIGFuIGlubGluZSBzdHlsZS4gSXQgYWxzbyBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBpdHMgaGVpZ2h0LCBkZXB0aCwgYW5kXG4gKiBtYXhGb250U2l6ZS5cbiAqL1xuZnVuY3Rpb24gc3BhbihjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmRlcHRoID0gMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gMDtcbiAgICB0aGlzLnN0eWxlID0ge307XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3R5bGUuaXNUaWdodCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMucHVzaChcIm10aWdodFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5nZXRDb2xvcigpKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLmNvbG9yID0gb3B0aW9ucy5nZXRDb2xvcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFNldHMgYW4gYXJiaXRyYXJ5IGF0dHJpYnV0ZSBvbiB0aGUgc3Bhbi4gV2FybmluZzogdXNlIHRoaXMgd2lzZWx5LiBOb3QgYWxsXG4gKiBicm93c2VycyBzdXBwb3J0IGF0dHJpYnV0ZXMgdGhlIHNhbWUsIGFuZCBoYXZpbmcgdG9vIG1hbnkgY3VzdG9tIGF0dHJpYnV0ZXNcbiAqIGlzIHByb2JhYmx5IGJhZC5cbiAqL1xuc3Bhbi5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWU7XG59O1xuXG5zcGFuLnByb3RvdHlwZS50cnlDb21iaW5lID0gZnVuY3Rpb24oc2libGluZykge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgc3BhbiBpbnRvIGFuIEhUTUwgbm9kZVxuICovXG5zcGFuLnByb3RvdHlwZS50b05vZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgLy8gQXBwbHkgdGhlIGNsYXNzXG4gICAgc3Bhbi5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpO1xuXG4gICAgLy8gQXBwbHkgaW5saW5lIHN0eWxlc1xuICAgIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0eWxlLCBzdHlsZSkpIHtcbiAgICAgICAgICAgIHNwYW4uc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBhdHRyaWJ1dGVzXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIHRoZSBjaGlsZHJlbiwgYWxzbyBhcyBIVE1MIG5vZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwYW47XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIHNwYW4gaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmdcbiAqL1xuc3Bhbi5wcm90b3R5cGUudG9NYXJrdXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWFya3VwID0gXCI8c3BhblwiO1xuXG4gICAgLy8gQWRkIHRoZSBjbGFzc1xuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIiBjbGFzcz1cXFwiXCI7XG4gICAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSk7XG4gICAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVzID0gXCJcIjtcblxuICAgIC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuICAgIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gdXRpbHMuaHlwaGVuYXRlKHN0eWxlKSArIFwiOlwiICsgdGhpcy5zdHlsZVtzdHlsZV0gKyBcIjtcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIHN0eWxlPVxcXCJcIiArIHV0aWxzLmVzY2FwZShzdHlsZXMpICsgXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBhdHRyaWJ1dGVzXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgICAgICBtYXJrdXAgKz0gXCIgXCIgKyBhdHRyICsgXCI9XFxcIlwiO1xuICAgICAgICAgICAgbWFya3VwICs9IHV0aWxzLmVzY2FwZSh0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICAgICAgbWFya3VwICs9IFwiXFxcIlwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPlwiO1xuXG4gICAgLy8gQWRkIHRoZSBtYXJrdXAgb2YgdGhlIGNoaWxkcmVuLCBhbHNvIGFzIG1hcmt1cFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIjwvc3Bhbj5cIjtcblxuICAgIHJldHVybiBtYXJrdXA7XG59O1xuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgZG9jdW1lbnQgZnJhZ21lbnQsIHdoaWNoIGNvbnRhaW5zIGVsZW1lbnRzLCBidXQgd2hlblxuICogcGxhY2VkIGludG8gdGhlIERPTSBkb2Vzbid0IGhhdmUgYW55IHJlcHJlc2VudGF0aW9uIGl0c2VsZi4gVGh1cywgaXQgb25seVxuICogY29udGFpbnMgY2hpbGRyZW4gYW5kIGRvZXNuJ3QgaGF2ZSBhbnkgSFRNTCBwcm9wZXJ0aWVzLiBJdCBhbHNvIGtlZXBzIHRyYWNrXG4gKiBvZiBhIGhlaWdodCwgZGVwdGgsIGFuZCBtYXhGb250U2l6ZS5cbiAqL1xuZnVuY3Rpb24gZG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbikge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgdGhpcy5tYXhGb250U2l6ZSA9IDA7XG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBhIG5vZGVcbiAqL1xuZG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUudG9Ob2RlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ3JlYXRlIGEgZnJhZ21lbnRcbiAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIC8vIEFwcGVuZCB0aGUgY2hpbGRyZW5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZnJhZy5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZztcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBIVE1MIG1hcmt1cFxuICovXG5kb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS50b01hcmt1cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIlwiO1xuXG4gICAgLy8gU2ltcGx5IGNvbmNhdGVuYXRlIHRoZSBtYXJrdXAgZm9yIHRoZSBjaGlsZHJlbiB0b2dldGhlclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG59O1xuXG52YXIgaUNvbWJpbmF0aW9ucyA9IHtcbiAgICAnw64nOiAnXFx1MDEzMVxcdTAzMDInLFxuICAgICfDryc6ICdcXHUwMTMxXFx1MDMwOCcsXG4gICAgJ8OtJzogJ1xcdTAxMzFcXHUwMzAxJyxcbiAgICAvLyAnxKsnOiAnXFx1MDEzMVxcdTAzMDQnLCAvLyBlbmFibGUgd2hlbiB3ZSBhZGQgRXh0ZW5kZWQgTGF0aW5cbiAgICAnw6wnOiAnXFx1MDEzMVxcdTAzMDAnXG59O1xuXG4vKipcbiAqIEEgc3ltYm9sIG5vZGUgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYSBzaW5nbGUgc3ltYm9sLiBJdCBlaXRoZXIgcmVuZGVyc1xuICogdG8gYSBzaW5nbGUgdGV4dCBub2RlLCBvciBhIHNwYW4gd2l0aCBhIHNpbmdsZSB0ZXh0IG5vZGUgaW4gaXQsIGRlcGVuZGluZyBvblxuICogd2hldGhlciBpdCBoYXMgQ1NTIGNsYXNzZXMsIHN0eWxlcywgb3IgbmVlZHMgaXRhbGljIGNvcnJlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHN5bWJvbE5vZGUodmFsdWUsIGhlaWdodCwgZGVwdGgsIGl0YWxpYywgc2tldywgY2xhc3Nlcywgc3R5bGUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUgfHwgXCJcIjtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aCB8fCAwO1xuICAgIHRoaXMuaXRhbGljID0gaXRhbGljIHx8IDA7XG4gICAgdGhpcy5za2V3ID0gc2tldyB8fCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSAwO1xuXG4gICAgLy8gTWFyayBDSksgY2hhcmFjdGVycyB3aXRoIHNwZWNpZmljIGNsYXNzZXMgc28gdGhhdCB3ZSBjYW4gc3BlY2lmeSB3aGljaFxuICAgIC8vIGZvbnRzIHRvIHVzZS4gIFRoaXMgYWxsb3dzIHVzIHRvIHJlbmRlciB0aGVzZSBjaGFyYWN0ZXJzIHdpdGggYSBzZXJpZlxuICAgIC8vIGZvbnQgaW4gc2l0dWF0aW9ucyB3aGVyZSB0aGUgYnJvd3NlciB3b3VsZCBlaXRoZXIgZGVmYXVsdCB0byBhIHNhbnMgc2VyaWZcbiAgICAvLyBvciByZW5kZXIgYSBwbGFjZWhvbGRlciBjaGFyYWN0ZXIuXG4gICAgaWYgKHVuaWNvZGVSZWdleGVzLmNqa1JlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIC8vIEkgY291bGRuJ3QgZmluZCBhbnkgZm9udHMgdGhhdCBjb250YWluZWQgSGFuZ3VsIGFzIHdlbGwgYXMgYWxsIG9mXG4gICAgICAgIC8vIHRoZSBvdGhlciBjaGFyYWN0ZXJzIHdlIHdhbnRlZCB0byB0ZXN0IHRoZXJlIGZvciBpdCBnZXRzIGl0cyBvd25cbiAgICAgICAgLy8gQ1NTIGNsYXNzLlxuICAgICAgICBpZiAodW5pY29kZVJlZ2V4ZXMuaGFuZ3VsUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKCdoYW5ndWxfZmFsbGJhY2snKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKCdjamtfZmFsbGJhY2snKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgvW8Ouw6/DrcOsXS8udGVzdCh0aGlzLnZhbHVlKSkgeyAgICAvLyBhZGQgxKsgd2hlbiB3ZSBhZGQgRXh0ZW5kZWQgTGF0aW5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGlDb21iaW5hdGlvbnNbdGhpcy52YWx1ZV07XG4gICAgfVxufVxuXG5zeW1ib2xOb2RlLnByb3RvdHlwZS50cnlDb21iaW5lID0gZnVuY3Rpb24oc2libGluZykge1xuICAgIGlmICghc2libGluZ1xuICAgICAgICB8fCAhKHNpYmxpbmcgaW5zdGFuY2VvZiBzeW1ib2xOb2RlKVxuICAgICAgICB8fCB0aGlzLml0YWxpYyA+IDBcbiAgICAgICAgfHwgY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSAhPT0gY3JlYXRlQ2xhc3Moc2libGluZy5jbGFzc2VzKVxuICAgICAgICB8fCB0aGlzLnNrZXcgIT09IHNpYmxpbmcuc2tld1xuICAgICAgICB8fCB0aGlzLm1heEZvbnRTaXplICE9PSBzaWJsaW5nLm1heEZvbnRTaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSlcbiAgICAgICAgICAgICYmIHRoaXMuc3R5bGVbc3R5bGVdICE9PSBzaWJsaW5nLnN0eWxlW3N0eWxlXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoc3R5bGUgaW4gc2libGluZy5zdHlsZSkge1xuICAgICAgICBpZiAoc2libGluZy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSlcbiAgICAgICAgICAgICYmIHRoaXMuc3R5bGVbc3R5bGVdICE9PSBzaWJsaW5nLnN0eWxlW3N0eWxlXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMudmFsdWUgKz0gc2libGluZy52YWx1ZTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KHRoaXMuaGVpZ2h0LCBzaWJsaW5nLmhlaWdodCk7XG4gICAgdGhpcy5kZXB0aCA9IE1hdGgubWF4KHRoaXMuZGVwdGgsIHNpYmxpbmcuZGVwdGgpO1xuICAgIHRoaXMuaXRhbGljID0gc2libGluZy5pdGFsaWM7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0ZXh0IG5vZGUgb3Igc3BhbiBmcm9tIGEgc3ltYm9sIG5vZGUuIE5vdGUgdGhhdCBhIHNwYW4gaXMgb25seVxuICogY3JlYXRlZCBpZiBpdCBpcyBuZWVkZWQuXG4gKi9cbnN5bWJvbE5vZGUucHJvdG90eXBlLnRvTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy52YWx1ZSk7XG4gICAgdmFyIHNwYW4gPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuaXRhbGljID4gMCkge1xuICAgICAgICBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4uc3R5bGUubWFyZ2luUmlnaHQgPSB0aGlzLml0YWxpYyArIFwiZW1cIjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBzcGFuLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNwYW4pIHtcbiAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBzeW1ib2wgbm9kZS5cbiAqL1xuc3ltYm9sTm9kZS5wcm90b3R5cGUudG9NYXJrdXAgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUT0RPKGFscGVydCk6IE1vcmUgZHVwbGljYXRpb24gdGhhbiBJJ2QgbGlrZSBmcm9tXG4gICAgLy8gc3Bhbi5wcm90b3R5cGUudG9NYXJrdXAgYW5kIHN5bWJvbE5vZGUucHJvdG90eXBlLnRvTm9kZS4uLlxuICAgIHZhciBuZWVkc1NwYW4gPSBmYWxzZTtcblxuICAgIHZhciBtYXJrdXAgPSBcIjxzcGFuXCI7XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICBuZWVkc1NwYW4gPSB0cnVlO1xuICAgICAgICBtYXJrdXAgKz0gXCIgY2xhc3M9XFxcIlwiO1xuICAgICAgICBtYXJrdXAgKz0gdXRpbHMuZXNjYXBlKGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3NlcykpO1xuICAgICAgICBtYXJrdXAgKz0gXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlcyA9IFwiXCI7XG5cbiAgICBpZiAodGhpcy5pdGFsaWMgPiAwKSB7XG4gICAgICAgIHN0eWxlcyArPSBcIm1hcmdpbi1yaWdodDpcIiArIHRoaXMuaXRhbGljICsgXCJlbTtcIjtcbiAgICB9XG4gICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSB1dGlscy5oeXBoZW5hdGUoc3R5bGUpICsgXCI6XCIgKyB0aGlzLnN0eWxlW3N0eWxlXSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgICBuZWVkc1NwYW4gPSB0cnVlO1xuICAgICAgICBtYXJrdXAgKz0gXCIgc3R5bGU9XFxcIlwiICsgdXRpbHMuZXNjYXBlKHN0eWxlcykgKyBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgZXNjYXBlZCA9IHV0aWxzLmVzY2FwZSh0aGlzLnZhbHVlKTtcbiAgICBpZiAobmVlZHNTcGFuKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIj5cIjtcbiAgICAgICAgbWFya3VwICs9IGVzY2FwZWQ7XG4gICAgICAgIG1hcmt1cCArPSBcIjwvc3Bhbj5cIjtcbiAgICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXNjYXBlZDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzcGFuOiBzcGFuLFxuICAgIGRvY3VtZW50RnJhZ21lbnQ6IGRvY3VtZW50RnJhZ21lbnQsXG4gICAgc3ltYm9sTm9kZTogc3ltYm9sTm9kZVxufTtcbiIsIi8qIGVzbGludCBuby1jb25zdGFudC1jb25kaXRpb246MCAqL1xudmFyIHBhcnNlRGF0YSA9IHJlcXVpcmUoXCIuL3BhcnNlRGF0YVwiKTtcbnZhciBQYXJzZUVycm9yID0gcmVxdWlyZShcIi4vUGFyc2VFcnJvclwiKTtcbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL1N0eWxlXCIpO1xuXG52YXIgUGFyc2VOb2RlID0gcGFyc2VEYXRhLlBhcnNlTm9kZTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgYm9keSBvZiB0aGUgZW52aXJvbm1lbnQsIHdpdGggcm93cyBkZWxpbWl0ZWQgYnkgXFxcXCBhbmRcbiAqIGNvbHVtbnMgZGVsaW1pdGVkIGJ5ICYsIGFuZCBjcmVhdGUgYSBuZXN0ZWQgbGlzdCBpbiByb3ctbWFqb3Igb3JkZXJcbiAqIHdpdGggb25lIGdyb3VwIHBlciBjZWxsLlxuICovXG5mdW5jdGlvbiBwYXJzZUFycmF5KHBhcnNlciwgcmVzdWx0KSB7XG4gICAgdmFyIHJvdyA9IFtdO1xuICAgIHZhciBib2R5ID0gW3Jvd107XG4gICAgdmFyIHJvd0dhcHMgPSBbXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgY2VsbCA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIG51bGwpO1xuICAgICAgICByb3cucHVzaChuZXcgUGFyc2VOb2RlKFwib3JkZ3JvdXBcIiwgY2VsbCwgcGFyc2VyLm1vZGUpKTtcbiAgICAgICAgdmFyIG5leHQgPSBwYXJzZXIubmV4dFRva2VuLnRleHQ7XG4gICAgICAgIGlmIChuZXh0ID09PSBcIiZcIikge1xuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxlbmRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gXCJcXFxcXFxcXFwiIHx8IG5leHQgPT09IFwiXFxcXGNyXCIpIHtcbiAgICAgICAgICAgIHZhciBjciA9IHBhcnNlci5wYXJzZUZ1bmN0aW9uKCk7XG4gICAgICAgICAgICByb3dHYXBzLnB1c2goY3IudmFsdWUuc2l6ZSk7XG4gICAgICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgICAgIGJvZHkucHVzaChyb3cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCAmIG9yIFxcXFxcXFxcIG9yIFxcXFxlbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5ib2R5ID0gYm9keTtcbiAgICByZXN1bHQucm93R2FwcyA9IHJvd0dhcHM7XG4gICAgcmV0dXJuIG5ldyBQYXJzZU5vZGUocmVzdWx0LnR5cGUsIHJlc3VsdCwgcGFyc2VyLm1vZGUpO1xufVxuXG4vKlxuICogQW4gZW52aXJvbm1lbnQgZGVmaW5pdGlvbiBpcyB2ZXJ5IHNpbWlsYXIgdG8gYSBmdW5jdGlvbiBkZWZpbml0aW9uOlxuICogaXQgaXMgZGVjbGFyZWQgd2l0aCBhIG5hbWUgb3IgYSBsaXN0IG9mIG5hbWVzLCBhIHNldCBvZiBwcm9wZXJ0aWVzXG4gKiBhbmQgYSBoYW5kbGVyIGNvbnRhaW5pbmcgdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGUgcHJvcGVydGllcyBpbmNsdWRlOlxuICogIC0gbnVtQXJnczogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgYWZ0ZXIgdGhlIFxcYmVnaW57bmFtZX0gZnVuY3Rpb24uXG4gKiAgLSBhcmdUeXBlczogKG9wdGlvbmFsKSBKdXN0IGxpa2UgZm9yIGEgZnVuY3Rpb25cbiAqICAtIGFsbG93ZWRJblRleHQ6IChvcHRpb25hbCkgV2hldGhlciBvciBub3QgdGhlIGVudmlyb25tZW50IGlzIGFsbG93ZWQgaW5zaWRlXG4gKiAgICAgICAgICAgICAgICAgICB0ZXh0IG1vZGUgKGRlZmF1bHQgZmFsc2UpIChub3QgZW5mb3JjZWQgeWV0KVxuICogIC0gbnVtT3B0aW9uYWxBcmdzOiAob3B0aW9uYWwpIEp1c3QgbGlrZSBmb3IgYSBmdW5jdGlvblxuICogQSBiYXJlIG51bWJlciBpbnN0ZWFkIG9mIHRoYXQgb2JqZWN0IGluZGljYXRlcyB0aGUgbnVtQXJncyB2YWx1ZS5cbiAqXG4gKiBUaGUgaGFuZGxlciBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdHdvIGFyZ3VtZW50c1xuICogIC0gY29udGV4dDogaW5mb3JtYXRpb24gYW5kIHJlZmVyZW5jZXMgcHJvdmlkZWQgYnkgdGhlIHBhcnNlclxuICogIC0gYXJnczogYW4gYXJyYXkgb2YgYXJndW1lbnRzIHBhc3NlZCB0byBcXGJlZ2lue25hbWV9XG4gKiBUaGUgY29udGV4dCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgLSBlbnZOYW1lOiB0aGUgbmFtZSBvZiB0aGUgZW52aXJvbm1lbnQsIG9uZSBvZiB0aGUgbGlzdGVkIG5hbWVzLlxuICogIC0gcGFyc2VyOiB0aGUgcGFyc2VyIG9iamVjdFxuICogIC0gbGV4ZXI6IHRoZSBsZXhlciBvYmplY3RcbiAqICAtIHBvc2l0aW9uczogdGhlIHBvc2l0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlc2UgYXJndW1lbnRzIGZyb20gYXJncy5cbiAqIFRoZSBoYW5kbGVyIG11c3QgcmV0dXJuIGEgUGFyc2VSZXN1bHQuXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lRW52aXJvbm1lbnQobmFtZXMsIHByb3BzLCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBuYW1lcyA9IFtuYW1lc107XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcHJvcHMgPSB7IG51bUFyZ3M6IHByb3BzIH07XG4gICAgfVxuICAgIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBvZiBlbnZpcm9ubWVudHNcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgbnVtQXJnczogcHJvcHMubnVtQXJncyB8fCAwLFxuICAgICAgICBhcmdUeXBlczogcHJvcHMuYXJnVHlwZXMsXG4gICAgICAgIGdyZWVkaW5lc3M6IDEsXG4gICAgICAgIGFsbG93ZWRJblRleHQ6ICEhcHJvcHMuYWxsb3dlZEluVGV4dCxcbiAgICAgICAgbnVtT3B0aW9uYWxBcmdzOiBwcm9wcy5udW1PcHRpb25hbEFyZ3MgfHwgMCxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0c1tuYW1lc1tpXV0gPSBkYXRhO1xuICAgIH1cbn1cblxuLy8gQXJyYXlzIGFyZSBwYXJ0IG9mIExhVGVYLCBkZWZpbmVkIGluIGx0dGFiLmR0eCBzbyBpdHMgZG9jdW1lbnRhdGlvblxuLy8gaXMgcGFydCBvZiB0aGUgc291cmNlMmUucGRmIGZpbGUgb2YgTGFUZVgyZSBzb3VyY2UgZG9jdW1lbnRhdGlvbi5cbmRlZmluZUVudmlyb25tZW50KFwiYXJyYXlcIiwge1xuICAgIG51bUFyZ3M6IDFcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgY29sYWxpZ24gPSBhcmdzWzBdO1xuICAgIGNvbGFsaWduID0gY29sYWxpZ24udmFsdWUubWFwID8gY29sYWxpZ24udmFsdWUgOiBbY29sYWxpZ25dO1xuICAgIHZhciBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGNhID0gbm9kZS52YWx1ZTtcbiAgICAgICAgaWYgKFwibGNyXCIuaW5kZXhPZihjYSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICAgICAgICBhbGlnbjogY2FcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY2EgPT09IFwifFwiKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic2VwYXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yOiBcInxcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgIFwiVW5rbm93biBjb2x1bW4gYWxpZ25tZW50OiBcIiArIG5vZGUudmFsdWUsXG4gICAgICAgICAgICBub2RlKTtcbiAgICB9KTtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGNvbHM6IGNvbHMsXG4gICAgICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXI6IHRydWUgLy8gXFxAcHJlYW1ibGUgaW4gbHR0YWIuZHR4XG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIHJldHVybiByZXM7XG59KTtcblxuLy8gVGhlIG1hdHJpeCBlbnZpcm9ubWVudHMgb2YgYW1zbWF0aCBidWlsZHMgb24gdGhlIGFycmF5IGVudmlyb25tZW50XG4vLyBvZiBMYVRlWCwgd2hpY2ggaXMgZGlzY3Vzc2VkIGFib3ZlLlxuZGVmaW5lRW52aXJvbm1lbnQoW1xuICAgIFwibWF0cml4XCIsXG4gICAgXCJwbWF0cml4XCIsXG4gICAgXCJibWF0cml4XCIsXG4gICAgXCJCbWF0cml4XCIsXG4gICAgXCJ2bWF0cml4XCIsXG4gICAgXCJWbWF0cml4XCJcbl0sIHtcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgZGVsaW1pdGVycyA9IHtcbiAgICAgICAgXCJtYXRyaXhcIjogbnVsbCxcbiAgICAgICAgXCJwbWF0cml4XCI6IFtcIihcIiwgXCIpXCJdLFxuICAgICAgICBcImJtYXRyaXhcIjogW1wiW1wiLCBcIl1cIl0sXG4gICAgICAgIFwiQm1hdHJpeFwiOiBbXCJcXFxce1wiLCBcIlxcXFx9XCJdLFxuICAgICAgICBcInZtYXRyaXhcIjogW1wifFwiLCBcInxcIl0sXG4gICAgICAgIFwiVm1hdHJpeFwiOiBbXCJcXFxcVmVydFwiLCBcIlxcXFxWZXJ0XCJdXG4gICAgfVtjb250ZXh0LmVudk5hbWVdO1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgaHNraXBCZWZvcmVBbmRBZnRlcjogZmFsc2UgLy8gXFxoc2tpcCAtXFxhcnJheWNvbHNlcCBpbiBhbXNtYXRoXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIGlmIChkZWxpbWl0ZXJzKSB7XG4gICAgICAgIHJlcyA9IG5ldyBQYXJzZU5vZGUoXCJsZWZ0cmlnaHRcIiwge1xuICAgICAgICAgICAgYm9keTogW3Jlc10sXG4gICAgICAgICAgICBsZWZ0OiBkZWxpbWl0ZXJzWzBdLFxuICAgICAgICAgICAgcmlnaHQ6IGRlbGltaXRlcnNbMV1cbiAgICAgICAgfSwgY29udGV4dC5tb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn0pO1xuXG4vLyBBIGNhc2VzIGVudmlyb25tZW50IChpbiBhbXNtYXRoLnN0eSkgaXMgYWxtb3N0IGVxdWl2YWxlbnQgdG9cbi8vIFxcZGVmXFxhcnJheXN0cmV0Y2h7MS4yfSVcbi8vIFxcbGVmdFxce1xcYmVnaW57YXJyYXl9e0B7fWxAe1xccXVhZH1sQHt9fSDigKYgXFxlbmR7YXJyYXl9XFxyaWdodC5cbmRlZmluZUVudmlyb25tZW50KFwiY2FzZXNcIiwge1xufSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgYXJyYXlzdHJldGNoOiAxLjIsXG4gICAgICAgIGNvbHM6IFt7XG4gICAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgICBhbGlnbjogXCJsXCIsXG4gICAgICAgICAgICBwcmVnYXA6IDAsXG4gICAgICAgICAgICAvLyBUT0RPKGtldmluYikgZ2V0IHRoZSBjdXJyZW50IHN0eWxlLlxuICAgICAgICAgICAgLy8gRm9yIG5vdyB3ZSB1c2UgdGhlIG1ldHJpY3MgZm9yIFRFWFQgc3R5bGUgd2hpY2ggaXMgd2hhdCB3ZSB3ZXJlXG4gICAgICAgICAgICAvLyBkb2luZyBiZWZvcmUuICBCZWZvcmUgYXR0ZW1wdGluZyB0byBnZXQgdGhlIGN1cnJlbnQgc3R5bGUgd2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBsb29rIGF0IFRlWCdzIGJlaGF2aW9yIGVzcGVjaWFsbHkgZm9yIFxcb3ZlciBhbmQgbWF0cmljZXMuXG4gICAgICAgICAgICBwb3N0Z2FwOiBTdHlsZS5URVhULm1ldHJpY3MucXVhZFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgICBhbGlnbjogXCJsXCIsXG4gICAgICAgICAgICBwcmVnYXA6IDAsXG4gICAgICAgICAgICBwb3N0Z2FwOiAwXG4gICAgICAgIH1dXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIHJlcyA9IG5ldyBQYXJzZU5vZGUoXCJsZWZ0cmlnaHRcIiwge1xuICAgICAgICBib2R5OiBbcmVzXSxcbiAgICAgICAgbGVmdDogXCJcXFxce1wiLFxuICAgICAgICByaWdodDogXCIuXCJcbiAgICB9LCBjb250ZXh0Lm1vZGUpO1xuICAgIHJldHVybiByZXM7XG59KTtcblxuLy8gQW4gYWxpZ25lZCBlbnZpcm9ubWVudCBpcyBsaWtlIHRoZSBhbGlnbiogZW52aXJvbm1lbnRcbi8vIGV4Y2VwdCBpdCBvcGVyYXRlcyB3aXRoaW4gbWF0aCBtb2RlLlxuLy8gTm90ZSB0aGF0IHdlIGFzc3VtZSBcXG5vbWFsbGluZXNraXBsaW1pdCB0byBiZSB6ZXJvLFxuLy8gc28gdGhhdCBcXHN0cnV0QCBpcyB0aGUgc2FtZSBhcyBcXHN0cnV0LlxuZGVmaW5lRW52aXJvbm1lbnQoXCJhbGlnbmVkXCIsIHtcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGNvbHM6IFtdXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIHZhciBlbXB0eUdyb3VwID0gbmV3IFBhcnNlTm9kZShcIm9yZGdyb3VwXCIsIFtdLCBjb250ZXh0Lm1vZGUpO1xuICAgIHZhciBudW1Db2xzID0gMDtcbiAgICByZXMudmFsdWUuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJvdy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgcm93W2ldLnZhbHVlLnVuc2hpZnQoZW1wdHlHcm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bUNvbHMgPCByb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBudW1Db2xzID0gcm93Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ29sczsgKytpKSB7XG4gICAgICAgIHZhciBhbGlnbiA9IFwiclwiO1xuICAgICAgICB2YXIgcHJlZ2FwID0gMDtcbiAgICAgICAgaWYgKGkgJSAyID09PSAxKSB7XG4gICAgICAgICAgICBhbGlnbiA9IFwibFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBwcmVnYXAgPSAyOyAvLyBvbmUgXFxxcXVhZCBiZXR3ZWVuIGNvbHVtbnNcbiAgICAgICAgfVxuICAgICAgICByZXMudmFsdWUuY29sc1tpXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgICAgIHByZWdhcDogcHJlZ2FwLFxuICAgICAgICAgICAgcG9zdGdhcDogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufSk7XG4iLCIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6MCAqL1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9TdHlsZVwiKTtcbnZhciBjamtSZWdleCA9IHJlcXVpcmUoXCIuL3VuaWNvZGVSZWdleGVzXCIpLmNqa1JlZ2V4O1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBtZXRyaWNzIHJlZ2FyZGluZyBmb250cyBhbmQgaW5kaXZpZHVhbCBzeW1ib2xzLiBUaGUgc2lnbWFcbiAqIGFuZCB4aSB2YXJpYWJsZXMsIGFzIHdlbGwgYXMgdGhlIG1ldHJpY01hcCBtYXAgY29udGFpbiBkYXRhIGV4dHJhY3RlZCBmcm9tXG4gKiBUZVgsIFRlWCBmb250IG1ldHJpY3MsIGFuZCB0aGUgVFRGIGZpbGVzLiBUaGVzZSBkYXRhIGFyZSB0aGVuIGV4cG9zZWQgdmlhIHRoZVxuICogYG1ldHJpY3NgIHZhcmlhYmxlIGFuZCB0aGUgZ2V0Q2hhcmFjdGVyTWV0cmljcyBmdW5jdGlvbi5cbiAqL1xuXG4vLyBJbiBUZVgsIHRoZXJlIGFyZSBhY3R1YWxseSB0aHJlZSBzZXRzIG9mIGRpbWVuc2lvbnMsIG9uZSBmb3IgZWFjaCBvZlxuLy8gdGV4dHN0eWxlLCBzY3JpcHRzdHlsZSwgYW5kIHNjcmlwdHNjcmlwdHN0eWxlLiAgVGhlc2UgYXJlIHByb3ZpZGVkIGluIHRoZVxuLy8gdGhlIGFycmF5cyBiZWxvdywgaW4gdGhhdCBvcmRlci5cbi8vXG4vLyBUaGUgZm9udCBtZXRyaWNzIGFyZSBzdG9yZWQgaW4gZm9udHMgY21zeTEwLCBjbXN5NywgYW5kIGNtc3k1IHJlc3BzZWN0aXZlbHkuXG4vLyBUaGlzIHdhcyBkZXRlcm1pbmVkIGJ5IHJ1bm5pbmcgdGhlIGZvbGxsb3dpbmcgc2NyaXB0OlxuLy9cbi8vICAgICBsYXRleCAtaW50ZXJhY3Rpb249bm9uc3RvcG1vZGUgXFxcbi8vICAgICAnXFxkb2N1bWVudGNsYXNze2FydGljbGV9XFx1c2VwYWNrYWdle2Ftc21hdGh9XFxiZWdpbntkb2N1bWVudH0nIFxcXG4vLyAgICAgJyRhJCBcXGV4cGFuZGFmdGVyXFxzaG93XFx0aGVcXHRleHRmb250MicgXFxcbi8vICAgICAnXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFxzY3JpcHRmb250MicgXFxcbi8vICAgICAnXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFxzY3JpcHRzY3JpcHRmb250MicgXFxcbi8vICAgICAnXFxzdG9wJ1xuLy9cbi8vIFRoZSBtZXRyaWNzIHRoZW1zZWx2ZXMgd2VyZSByZXRyZWl2ZWQgdXNpbmcgdGhlIGZvbGxvd2luZyBjb21tYW5kczpcbi8vXG4vLyAgICAgdGZ0b3BsIGNtc3kxMFxuLy8gICAgIHRmdG9wbCBjbXN5N1xuLy8gICAgIHRmdG9wbCBjbXN5NVxuLy9cbi8vIFRoZSBvdXRwdXQgb2YgZWFjaCBvZiB0aGVzZSBjb21tYW5kcyBpcyBxdWl0ZSBsZW5ndGh5LiAgVGhlIG9ubHkgcGFydCB3ZVxuLy8gY2FyZSBhYm91dCBpcyB0aGUgRk9OVERJTUVOIHNlY3Rpb24uIEVhY2ggdmFsdWUgaXMgbWVhc3VyZWQgaW4gRU1zLlxudmFyIHNpZ21hcyA9IHtcbiAgICBzbGFudDogWzAuMjUwLCAwLjI1MCwgMC4yNTBdLCAgICAgICAvLyBzaWdtYTFcbiAgICBzcGFjZTogWzAuMDAwLCAwLjAwMCwgMC4wMDBdLCAgICAgICAvLyBzaWdtYTJcbiAgICBzdHJldGNoOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sICAgICAvLyBzaWdtYTNcbiAgICBzaHJpbms6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSwgICAgICAvLyBzaWdtYTRcbiAgICB4SGVpZ2h0OiBbMC40MzEsIDAuNDMxLCAwLjQzMV0sICAgICAvLyBzaWdtYTVcbiAgICBxdWFkOiBbMS4wMDAsIDEuMTcxLCAxLjQ3Ml0sICAgICAgICAvLyBzaWdtYTZcbiAgICBleHRyYVNwYWNlOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sICAvLyBzaWdtYTdcbiAgICBudW0xOiBbMC42NzcsIDAuNzMyLCAwLjkyNV0sICAgICAgICAvLyBzaWdtYThcbiAgICBudW0yOiBbMC4zOTQsIDAuMzg0LCAwLjM4N10sICAgICAgICAvLyBzaWdtYTlcbiAgICBudW0zOiBbMC40NDQsIDAuNDcxLCAwLjUwNF0sICAgICAgICAvLyBzaWdtYTEwXG4gICAgZGVub20xOiBbMC42ODYsIDAuNzUyLCAxLjAyNV0sICAgICAgLy8gc2lnbWExMVxuICAgIGRlbm9tMjogWzAuMzQ1LCAwLjM0NCwgMC41MzJdLCAgICAgIC8vIHNpZ21hMTJcbiAgICBzdXAxOiBbMC40MTMsIDAuNTAzLCAwLjUwNF0sICAgICAgICAvLyBzaWdtYTEzXG4gICAgc3VwMjogWzAuMzYzLCAwLjQzMSwgMC40MDRdLCAgICAgICAgLy8gc2lnbWExNFxuICAgIHN1cDM6IFswLjI4OSwgMC4yODYsIDAuMjk0XSwgICAgICAgIC8vIHNpZ21hMTVcbiAgICBzdWIxOiBbMC4xNTAsIDAuMTQzLCAwLjIwMF0sICAgICAgICAvLyBzaWdtYTE2XG4gICAgc3ViMjogWzAuMjQ3LCAwLjI4NiwgMC40MDBdLCAgICAgICAgLy8gc2lnbWExN1xuICAgIHN1cERyb3A6IFswLjM4NiwgMC4zNTMsIDAuNDk0XSwgICAgIC8vIHNpZ21hMThcbiAgICBzdWJEcm9wOiBbMC4wNTAsIDAuMDcxLCAwLjEwMF0sICAgICAvLyBzaWdtYTE5XG4gICAgZGVsaW0xOiBbMi4zOTAsIDEuNzAwLCAxLjk4MF0sICAgICAgLy8gc2lnbWEyMFxuICAgIGRlbGltMjogWzEuMDEwLCAxLjE1NywgMS40MjBdLCAgICAgIC8vIHNpZ21hMjFcbiAgICBheGlzSGVpZ2h0OiBbMC4yNTAsIDAuMjUwLCAwLjI1MF0gIC8vIHNpZ21hMjJcbn07XG5cbi8vIFRoZXNlIGZvbnQgbWV0cmljcyBhcmUgZXh0cmFjdGVkIGZyb20gVGVYIGJ5IHVzaW5nXG4vLyBcXGZvbnRcXGE9Y21leDEwXG4vLyBcXHNob3d0aGVcXGZvbnRkaW1lblhcXGFcbi8vIHdoZXJlIFggaXMgdGhlIGNvcnJlc3BvbmRpbmcgdmFyaWFibGUgbnVtYmVyLiBUaGVzZSBjb3JyZXNwb25kIHRvIHRoZSBmb250XG4vLyBwYXJhbWV0ZXJzIG9mIHRoZSBleHRlbnNpb24gZm9udHMgKGZhbWlseSAzKS4gU2VlIHRoZSBUZVhib29rLCBwYWdlIDQ0MS5cbnZhciB4aTEgPSAwO1xudmFyIHhpMiA9IDA7XG52YXIgeGkzID0gMDtcbnZhciB4aTQgPSAwO1xudmFyIHhpNSA9IDAuNDMxO1xudmFyIHhpNiA9IDE7XG52YXIgeGk3ID0gMDtcbnZhciB4aTggPSAwLjA0O1xudmFyIHhpOSA9IDAuMTExO1xudmFyIHhpMTAgPSAwLjE2NjtcbnZhciB4aTExID0gMC4yO1xudmFyIHhpMTIgPSAwLjY7XG52YXIgeGkxMyA9IDAuMTtcblxuLy8gVGhpcyB2YWx1ZSBkZXRlcm1pbmVzIGhvdyBsYXJnZSBhIHB0IGlzLCBmb3IgbWV0cmljcyB3aGljaCBhcmUgZGVmaW5lZCBpblxuLy8gdGVybXMgb2YgcHRzLlxuLy8gVGhpcyB2YWx1ZSBpcyBhbHNvIHVzZWQgaW4ga2F0ZXgubGVzczsgaWYgeW91IGNoYW5nZSBpdCBtYWtlIHN1cmUgdGhlIHZhbHVlc1xuLy8gbWF0Y2guXG52YXIgcHRQZXJFbSA9IDEwLjA7XG5cbi8vIFRoZSBzcGFjZSBiZXR3ZWVuIGFkamFjZW50IGB8YCBjb2x1bW5zIGluIGFuIGFycmF5IGRlZmluaXRpb24uIEZyb21cbi8vIGBcXHNob3d0aGVcXGRvdWJsZXJ1bGVzZXBgIGluIExhVGVYLlxudmFyIGRvdWJsZVJ1bGVTZXAgPSAyLjAgLyBwdFBlckVtO1xuXG4vKipcbiAqIFRoaXMgaXMganVzdCBhIG1hcHBpbmcgZnJvbSBjb21tb24gbmFtZXMgdG8gcmVhbCBtZXRyaWNzXG4gKi9cbnZhciBtZXRyaWNzID0ge1xuICAgIGRlZmF1bHRSdWxlVGhpY2tuZXNzOiB4aTgsXG4gICAgYmlnT3BTcGFjaW5nMTogeGk5LFxuICAgIGJpZ09wU3BhY2luZzI6IHhpMTAsXG4gICAgYmlnT3BTcGFjaW5nMzogeGkxMSxcbiAgICBiaWdPcFNwYWNpbmc0OiB4aTEyLFxuICAgIGJpZ09wU3BhY2luZzU6IHhpMTMsXG4gICAgcHRQZXJFbTogcHRQZXJFbSxcbiAgICBkb3VibGVSdWxlU2VwOiBkb3VibGVSdWxlU2VwXG59O1xuXG4vLyBUaGlzIG1hcCBjb250YWlucyBhIG1hcHBpbmcgZnJvbSBmb250IG5hbWUgYW5kIGNoYXJhY3RlciBjb2RlIHRvIGNoYXJhY3RlclxuLy8gbWV0cmljcywgaW5jbHVkaW5nIGhlaWdodCwgZGVwdGgsIGl0YWxpYyBjb3JyZWN0aW9uLCBhbmQgc2tldyAoa2VybiBmcm9tIHRoZVxuLy8gY2hhcmFjdGVyIHRvIHRoZSBjb3JyZXNwb25kaW5nIFxcc2tld2NoYXIpXG4vLyBUaGlzIG1hcCBpcyBnZW5lcmF0ZWQgdmlhIGBtYWtlIG1ldHJpY3NgLiBJdCBzaG91bGQgbm90IGJlIGNoYW5nZWQgbWFudWFsbHkuXG52YXIgbWV0cmljTWFwID0gcmVxdWlyZShcIi4vZm9udE1ldHJpY3NEYXRhXCIpO1xuXG4vLyBUaGVzZSBhcmUgdmVyeSByb3VnaCBhcHByb3hpbWF0aW9ucy4gIFdlIGRlZmF1bHQgdG8gVGltZXMgTmV3IFJvbWFuIHdoaWNoXG4vLyBzaG91bGQgaGF2ZSBMYXRpbi0xIGFuZCBDeXJpbGxpYyBjaGFyYWN0ZXJzLCBidXQgbWF5IG5vdCBkZXBlbmRpbmcgb24gdGhlXG4vLyBvcGVyYXRpbmcgc3lzdGVtLiAgVGhlIG1ldHJpY3MgZG8gbm90IGFjY291bnQgZm9yIGV4dHJhIGhlaWdodCBmcm9tIHRoZVxuLy8gYWNjZW50cy4gIEluIHRoZSBjYXNlIG9mIEN5cmlsbGljIGNoYXJhY3RlcnMgd2hpY2ggaGF2ZSBib3RoIGFzY2VuZGVycyBhbmRcbi8vIGRlc2NlbmRlcnMgd2UgcHJlZmVyIGFwcHJveGltYXRpb25zIHdpdGggYXNjZW5kZXJzLCBwcmltYXJpbHkgdG8gcHJldmVudFxuLy8gdGhlIGZyYWN0aW9uIGJhciBvciByb290IGxpbmUgZnJvbSBpbnRlcnNlY3RpbmcgdGhlIGdseXBoLlxuLy8gVE9ETyhrZXZpbmIpIGFsbG93IHVuaW9uIG9mIG11bHRpcGxlIGdseXBoIG1ldHJpY3MgZm9yIGJldHRlciBhY2N1cmFjeS5cbnZhciBleHRyYUNoYXJhY3Rlck1hcCA9IHtcbiAgICAvLyBMYXRpbi0xXG4gICAgJ8OAJzogJ0EnLFxuICAgICfDgSc6ICdBJyxcbiAgICAnw4InOiAnQScsXG4gICAgJ8ODJzogJ0EnLFxuICAgICfDhCc6ICdBJyxcbiAgICAnw4UnOiAnQScsXG4gICAgJ8OGJzogJ0EnLFxuICAgICfDhyc6ICdDJyxcbiAgICAnw4gnOiAnRScsXG4gICAgJ8OJJzogJ0UnLFxuICAgICfDiic6ICdFJyxcbiAgICAnw4snOiAnRScsXG4gICAgJ8OMJzogJ0knLFxuICAgICfDjSc6ICdJJyxcbiAgICAnw44nOiAnSScsXG4gICAgJ8OPJzogJ0knLFxuICAgICfDkCc6ICdEJyxcbiAgICAnw5EnOiAnTicsXG4gICAgJ8OSJzogJ08nLFxuICAgICfDkyc6ICdPJyxcbiAgICAnw5QnOiAnTycsXG4gICAgJ8OVJzogJ08nLFxuICAgICfDlic6ICdPJyxcbiAgICAnw5gnOiAnTycsXG4gICAgJ8OZJzogJ1UnLFxuICAgICfDmic6ICdVJyxcbiAgICAnw5snOiAnVScsXG4gICAgJ8OcJzogJ1UnLFxuICAgICfDnSc6ICdZJyxcbiAgICAnw54nOiAnbycsXG4gICAgJ8OfJzogJ0InLFxuICAgICfDoCc6ICdhJyxcbiAgICAnw6EnOiAnYScsXG4gICAgJ8OiJzogJ2EnLFxuICAgICfDoyc6ICdhJyxcbiAgICAnw6QnOiAnYScsXG4gICAgJ8OlJzogJ2EnLFxuICAgICfDpic6ICdhJyxcbiAgICAnw6cnOiAnYycsXG4gICAgJ8OoJzogJ2UnLFxuICAgICfDqSc6ICdlJyxcbiAgICAnw6onOiAnZScsXG4gICAgJ8OrJzogJ2UnLFxuICAgICfDrCc6ICdpJyxcbiAgICAnw60nOiAnaScsXG4gICAgJ8OuJzogJ2knLFxuICAgICfDryc6ICdpJyxcbiAgICAnw7AnOiAnZCcsXG4gICAgJ8OxJzogJ24nLFxuICAgICfDsic6ICdvJyxcbiAgICAnw7MnOiAnbycsXG4gICAgJ8O0JzogJ28nLFxuICAgICfDtSc6ICdvJyxcbiAgICAnw7YnOiAnbycsXG4gICAgJ8O4JzogJ28nLFxuICAgICfDuSc6ICd1JyxcbiAgICAnw7onOiAndScsXG4gICAgJ8O7JzogJ3UnLFxuICAgICfDvCc6ICd1JyxcbiAgICAnw70nOiAneScsXG4gICAgJ8O+JzogJ28nLFxuICAgICfDvyc6ICd5JyxcblxuICAgIC8vIEN5cmlsbGljXG4gICAgJ9CQJzogJ0EnLFxuICAgICfQkSc6ICdCJyxcbiAgICAn0JInOiAnQicsXG4gICAgJ9CTJzogJ0YnLFxuICAgICfQlCc6ICdBJyxcbiAgICAn0JUnOiAnRScsXG4gICAgJ9CWJzogJ0snLFxuICAgICfQlyc6ICczJyxcbiAgICAn0JgnOiAnTicsXG4gICAgJ9CZJzogJ04nLFxuICAgICfQmic6ICdLJyxcbiAgICAn0JsnOiAnTicsXG4gICAgJ9CcJzogJ00nLFxuICAgICfQnSc6ICdIJyxcbiAgICAn0J4nOiAnTycsXG4gICAgJ9CfJzogJ04nLFxuICAgICfQoCc6ICdQJyxcbiAgICAn0KEnOiAnQycsXG4gICAgJ9CiJzogJ1QnLFxuICAgICfQoyc6ICd5JyxcbiAgICAn0KQnOiAnTycsXG4gICAgJ9ClJzogJ1gnLFxuICAgICfQpic6ICdVJyxcbiAgICAn0KcnOiAnaCcsXG4gICAgJ9CoJzogJ1cnLFxuICAgICfQqSc6ICdXJyxcbiAgICAn0KonOiAnQicsXG4gICAgJ9CrJzogJ1gnLFxuICAgICfQrCc6ICdCJyxcbiAgICAn0K0nOiAnMycsXG4gICAgJ9CuJzogJ1gnLFxuICAgICfQryc6ICdSJyxcbiAgICAn0LAnOiAnYScsXG4gICAgJ9CxJzogJ2InLFxuICAgICfQsic6ICdhJyxcbiAgICAn0LMnOiAncicsXG4gICAgJ9C0JzogJ3knLFxuICAgICfQtSc6ICdlJyxcbiAgICAn0LYnOiAnbScsXG4gICAgJ9C3JzogJ2UnLFxuICAgICfQuCc6ICduJyxcbiAgICAn0LknOiAnbicsXG4gICAgJ9C6JzogJ24nLFxuICAgICfQuyc6ICduJyxcbiAgICAn0LwnOiAnbScsXG4gICAgJ9C9JzogJ24nLFxuICAgICfQvic6ICdvJyxcbiAgICAn0L8nOiAnbicsXG4gICAgJ9GAJzogJ3AnLFxuICAgICfRgSc6ICdjJyxcbiAgICAn0YInOiAnbycsXG4gICAgJ9GDJzogJ3knLFxuICAgICfRhCc6ICdiJyxcbiAgICAn0YUnOiAneCcsXG4gICAgJ9GGJzogJ24nLFxuICAgICfRhyc6ICduJyxcbiAgICAn0YgnOiAndycsXG4gICAgJ9GJJzogJ3cnLFxuICAgICfRiic6ICdhJyxcbiAgICAn0YsnOiAnbScsXG4gICAgJ9GMJzogJ2EnLFxuICAgICfRjSc6ICdlJyxcbiAgICAn0Y4nOiAnbScsXG4gICAgJ9GPJzogJ3InXG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgbG9va2luZyB1cCBpbmZvcm1hdGlvbiBpbiB0aGVcbiAqIG1ldHJpY01hcCB0YWJsZS4gSXQgdGFrZXMgYSBjaGFyYWN0ZXIgYXMgYSBzdHJpbmcsIGFuZCBhIHN0eWxlLlxuICpcbiAqIE5vdGU6IHRoZSBgd2lkdGhgIHByb3BlcnR5IG1heSBiZSB1bmRlZmluZWQgaWYgZm9udE1ldHJpY3NEYXRhLmpzIHdhc24ndFxuICogYnVpbHQgdXNpbmcgYE1ha2UgZXh0ZW5kZWRfbWV0cmljc2AuXG4gKi9cbnZhciBnZXRDaGFyYWN0ZXJNZXRyaWNzID0gZnVuY3Rpb24oY2hhcmFjdGVyLCBzdHlsZSkge1xuICAgIHZhciBjaCA9IGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChjaGFyYWN0ZXJbMF0gaW4gZXh0cmFDaGFyYWN0ZXJNYXApIHtcbiAgICAgICAgY2ggPSBleHRyYUNoYXJhY3Rlck1hcFtjaGFyYWN0ZXJbMF1dLmNoYXJDb2RlQXQoMCk7XG4gICAgfSBlbHNlIGlmIChjamtSZWdleC50ZXN0KGNoYXJhY3RlclswXSkpIHtcbiAgICAgICAgY2ggPSAnTScuY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgdmFyIG1ldHJpY3MgPSBtZXRyaWNNYXBbc3R5bGVdW2NoXTtcbiAgICBpZiAobWV0cmljcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVwdGg6IG1ldHJpY3NbMF0sXG4gICAgICAgICAgICBoZWlnaHQ6IG1ldHJpY3NbMV0sXG4gICAgICAgICAgICBpdGFsaWM6IG1ldHJpY3NbMl0sXG4gICAgICAgICAgICBza2V3OiBtZXRyaWNzWzNdLFxuICAgICAgICAgICAgd2lkdGg6IG1ldHJpY3NbNF1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtZXRyaWNzOiBtZXRyaWNzLFxuICAgIHNpZ21hczogc2lnbWFzLFxuICAgIGdldENoYXJhY3Rlck1ldHJpY3M6IGdldENoYXJhY3Rlck1ldHJpY3Ncbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBcIkFNUy1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI2NVwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNjZcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjY3XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI2OFwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNjlcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI3MVwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzJcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjczXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI3NFwiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzVcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjc2XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI3N1wiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzhcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjc5XCI6IFswLjE2NjY3LCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4MFwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiODFcIjogWzAuMTY2NjcsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjgyXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4M1wiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiODRcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjg1XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NlwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiODdcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjg4XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4OVwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiOTBcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiMTY1XCI6IFswLCAwLjY3NSwgMC4wMjUsIDBdLFxuICAgICAgICBcIjE3NFwiOiBbMC4xNTU1OSwgMC42OTIyNCwgMCwgMF0sXG4gICAgICAgIFwiMjQwXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCIyOTVcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjcxMFwiOiBbMCwgMC44MjUsIDAsIDBdLFxuICAgICAgICBcIjczMlwiOiBbMCwgMC45LCAwLCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuOSwgMCwgMF0sXG4gICAgICAgIFwiOTg5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCIxMDA4XCI6IFswLCAwLjQzMDU2LCAwLjA0MDI4LCAwXSxcbiAgICAgICAgXCI4MjQ1XCI6IFswLCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4NDYzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NDg3XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NDk4XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTAyXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTAzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTA0XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTEzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTkyXCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMF0sXG4gICAgICAgIFwiODU5NFwiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDBdLFxuICAgICAgICBcIjg2MDJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjAzXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODYwNlwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYwOFwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYxMFwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYxMVwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYxOVwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODYyMFwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODYyMVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDBdLFxuICAgICAgICBcIjg2MjJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjI0XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjI1XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjMwXCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NjMxXCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NjM0XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwXSxcbiAgICAgICAgXCI4NjM1XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwXSxcbiAgICAgICAgXCI4NjM4XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjM5XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQyXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQzXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ0XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ2XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ3XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ4XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ5XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjUwXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjUxXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwXSxcbiAgICAgICAgXCI4NjUyXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwXSxcbiAgICAgICAgXCI4NjUzXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODY1NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg2NTVcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjY2XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4NjY3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4NjY5XCI6IFstMC4xMzMxMywgMC4zNzc4OCwgMCwgMF0sXG4gICAgICAgIFwiODY3MlwiOiBbLTAuMDY0LCAwLjQzNywgMCwgMF0sXG4gICAgICAgIFwiODY3NFwiOiBbLTAuMDY0LCAwLjQzNywgMCwgMF0sXG4gICAgICAgIFwiODcwNVwiOiBbMCwgMC44MjUsIDAsIDBdLFxuICAgICAgICBcIjg3MDhcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjg3MDlcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDBdLFxuICAgICAgICBcIjg3MTdcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjg3MjJcIjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwXSxcbiAgICAgICAgXCI4NzI0XCI6IFswLjA4MTk4LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzI2XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4NzMzXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM3XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM4XCI6IFswLjAzNTE3LCAwLjUyMjM5LCAwLCAwXSxcbiAgICAgICAgXCI4NzM5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4NzQwXCI6IFswLjI1MTQyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NzQxXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4NzQyXCI6IFswLjI1MTQyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NzU2XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzU3XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzY0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODc2NVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDBdLFxuICAgICAgICBcIjg3NjlcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NzcwXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMF0sXG4gICAgICAgIFwiODc3NFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMF0sXG4gICAgICAgIFwiODc3NlwiOiBbLTAuMDE2ODgsIDAuNDgzMTIsIDAsIDBdLFxuICAgICAgICBcIjg3NzhcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDBdLFxuICAgICAgICBcIjg3ODJcIjogWzAuMDYwNjIsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg3ODNcIjogWzAuMDYwNjIsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg3ODVcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg3ODZcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg3ODdcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg3OTBcIjogWzAsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjg3OTFcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg3OTZcIjogWzAuMDgxOTgsIDAuOTE2NjcsIDAsIDBdLFxuICAgICAgICBcIjg4MDZcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjg4MDdcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjg4MDhcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjg4MDlcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjg4MTJcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjg4MTRcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4MTVcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4MTZcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4MTdcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4MThcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MTlcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MjJcIjogWzAuMTgwOCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjg4MjNcIjogWzAuMTgwOCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjg4MjhcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjg4MjlcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjg4MzBcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MzFcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MzJcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4MzNcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4NDBcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4NDFcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4NDJcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdLFxuICAgICAgICBcIjg4NDNcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdLFxuICAgICAgICBcIjg4NDdcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg4NDhcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg4NThcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg4NTlcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg4NjFcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg4NjJcIjogWzAsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODYzXCI6IFswLCAwLjY3NSwgMCwgMF0sXG4gICAgICAgIFwiODg2NFwiOiBbMCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjg4NjVcIjogWzAsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODcyXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODczXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODc0XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODc2XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODc3XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODc4XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODc5XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODgyXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4ODgzXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4ODg0XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODg1XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODg4XCI6IFswLCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4ODkwXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODkxXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODkyXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTAxXCI6IFswLCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4OTAzXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTA1XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTA2XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTA3XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTA4XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTA5XCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMF0sXG4gICAgICAgIFwiODkxMFwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxMVwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxMlwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxM1wiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxNFwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxNVwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxNlwiOiBbMCwgMC42OTIyNCwgMCwgMF0sXG4gICAgICAgIFwiODkxOFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg5MTlcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwXSxcbiAgICAgICAgXCI4OTIwXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4OTIxXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4OTIyXCI6IFswLjM4NTY5LCAwLjg4NTY5LCAwLCAwXSxcbiAgICAgICAgXCI4OTIzXCI6IFswLjM4NTY5LCAwLjg4NTY5LCAwLCAwXSxcbiAgICAgICAgXCI4OTI2XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTI3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTI4XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTI5XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTM0XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM1XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM2XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM3XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM4XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwXSxcbiAgICAgICAgXCI4OTM5XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwXSxcbiAgICAgICAgXCI4OTQwXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTQxXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTk0XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTk1XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDE2XCI6IFswLjE1NTU5LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDg0XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDg4XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDkyXCI6IFswLCAwLjM3Nzg4LCAwLCAwXSxcbiAgICAgICAgXCI5NDk2XCI6IFswLCAwLjM3Nzg4LCAwLCAwXSxcbiAgICAgICAgXCI5NTg1XCI6IFswLjE5NDQ0LCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI5NTg2XCI6IFswLjE5NDQ0LCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI5NjMyXCI6IFswLCAwLjY3NSwgMCwgMF0sXG4gICAgICAgIFwiOTYzM1wiOiBbMCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjk2NTBcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NTFcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NTRcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NjBcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NjFcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NjRcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NzRcIjogWzAuMTExMTEsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjk3MzNcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjEwMDAzXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCIxMDAxNlwiOiBbMCwgMC42OTIyNCwgMCwgMF0sXG4gICAgICAgIFwiMTA3MzFcIjogWzAuMTExMTEsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjEwODQ2XCI6IFswLjE5NDQ0LCAwLjc1NTgzLCAwLCAwXSxcbiAgICAgICAgXCIxMDg3N1wiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMF0sXG4gICAgICAgIFwiMTA4NzhcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjEwODg1XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwXSxcbiAgICAgICAgXCIxMDg4NlwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMF0sXG4gICAgICAgIFwiMTA4ODdcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdLFxuICAgICAgICBcIjEwODg4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCIxMDg4OVwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiMTA4OTBcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjEwODkxXCI6IFswLjQ4MjU2LCAwLjk4MjU2LCAwLCAwXSxcbiAgICAgICAgXCIxMDg5MlwiOiBbMC40ODI1NiwgMC45ODI1NiwgMCwgMF0sXG4gICAgICAgIFwiMTA5MDFcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjEwOTAyXCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCIxMDkzM1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiMTA5MzRcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjEwOTM1XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCIxMDkzNlwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiMTA5MzdcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjEwOTM4XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCIxMDk0OVwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMF0sXG4gICAgICAgIFwiMTA5NTBcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjEwOTU1XCI6IFswLjI4NDgxLCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCIxMDk1NlwiOiBbMC4yODQ4MSwgMC43OTM4MywgMCwgMF0sXG4gICAgICAgIFwiNTczNTBcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDBdLFxuICAgICAgICBcIjU3MzUxXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI1NzM1MlwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMF0sXG4gICAgICAgIFwiNTczNTNcIjogWzAsIDAuNDMwNTYsIDAuMDQwMjgsIDBdLFxuICAgICAgICBcIjU3MzU2XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCI1NzM1N1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiNTczNThcIjogWzAuNDE5NTEsIDAuOTE5NTEsIDAsIDBdLFxuICAgICAgICBcIjU3MzU5XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI1NzM2MFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMF0sXG4gICAgICAgIFwiNTczNjFcIjogWzAuNDE5NTEsIDAuOTE5NTEsIDAsIDBdLFxuICAgICAgICBcIjU3MzY2XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCI1NzM2N1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiNTczNjhcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjU3MzY5XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCI1NzM3MFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMF0sXG4gICAgICAgIFwiNTczNzFcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdXG4gICAgfSxcbiAgICBcIkNhbGlncmFwaGljLVJlZ3VsYXJcIjoge1xuICAgICAgICBcIjQ4XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI0OVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTBcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI1MlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1NVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI2NVwiOiBbMCwgMC42ODMzMywgMCwgMC4xOTQ0NV0sXG4gICAgICAgIFwiNjZcIjogWzAsIDAuNjgzMzMsIDAuMDMwNDEsIDAuMTM4ODldLFxuICAgICAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLjA1ODM0LCAwLjEzODg5XSxcbiAgICAgICAgXCI2OFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiNjlcIjogWzAsIDAuNjgzMzMsIDAuMDg5NDQsIDAuMTExMTFdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjY4MzMzLCAwLjA5OTMxLCAwLjExMTExXSxcbiAgICAgICAgXCI3MVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4wNTkzLCAwLjExMTExXSxcbiAgICAgICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMC4wMDk2NSwgMC4xMTExMV0sXG4gICAgICAgIFwiNzNcIjogWzAsIDAuNjgzMzMsIDAuMDczODIsIDBdLFxuICAgICAgICBcIjc0XCI6IFswLjA5NzIyLCAwLjY4MzMzLCAwLjE4NDcyLCAwLjE2NjY3XSxcbiAgICAgICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMC4wMTQ0NSwgMC4wNTU1Nl0sXG4gICAgICAgIFwiNzZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODldLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjY4MzMzLCAwLCAwLjEzODg5XSxcbiAgICAgICAgXCI3OFwiOiBbMCwgMC42ODMzMywgMC4xNDczNiwgMC4wODMzNF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMTExMTFdLFxuICAgICAgICBcIjgwXCI6IFswLCAwLjY4MzMzLCAwLjA4MjIyLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4MVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMCwgMC4xMTExMV0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjgzXCI6IFswLCAwLjY4MzMzLCAwLjA3NSwgMC4xMzg4OV0sXG4gICAgICAgIFwiODRcIjogWzAsIDAuNjgzMzMsIDAuMjU0MTcsIDBdLFxuICAgICAgICBcIjg1XCI6IFswLCAwLjY4MzMzLCAwLjA5OTMxLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NlwiOiBbMCwgMC42ODMzMywgMC4wODIyMiwgMF0sXG4gICAgICAgIFwiODdcIjogWzAsIDAuNjgzMzMsIDAuMDgyMjIsIDAuMDgzMzRdLFxuICAgICAgICBcIjg4XCI6IFswLCAwLjY4MzMzLCAwLjE0NjQzLCAwLjEzODg5XSxcbiAgICAgICAgXCI4OVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4wODIyMiwgMC4wODMzNF0sXG4gICAgICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAuMDc5NDQsIDAuMTM4ODldXG4gICAgfSxcbiAgICBcIkZyYWt0dXItUmVndWxhclwiOiB7XG4gICAgICAgIFwiMzNcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjM0XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIzOFwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiMzlcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjQwXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwXSxcbiAgICAgICAgXCI0MVwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMF0sXG4gICAgICAgIFwiNDJcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjQzXCI6IFswLjA4MzE5LCAwLjU4MjgzLCAwLCAwXSxcbiAgICAgICAgXCI0NFwiOiBbMCwgMC4xMDgwMywgMCwgMF0sXG4gICAgICAgIFwiNDVcIjogWzAuMDgzMTksIDAuNTgyODMsIDAsIDBdLFxuICAgICAgICBcIjQ2XCI6IFswLCAwLjEwODAzLCAwLCAwXSxcbiAgICAgICAgXCI0N1wiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMF0sXG4gICAgICAgIFwiNDhcIjogWzAsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjQ5XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1MFwiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiNTFcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjUyXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1M1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiNTRcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjU1XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1NlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTdcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjU4XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1OVwiOiBbMC4xMjYwNCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiNjFcIjogWy0wLjEzMDk5LCAwLjM2ODY2LCAwLCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMC4xMjYwNCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLjA2MzAyLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAuMTI2MDQsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjAzNzgxLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLjEyNjA0LCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMF0sXG4gICAgICAgIFwiOTNcIjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDBdLFxuICAgICAgICBcIjk0XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjEwNFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiMTA4XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIxMDlcIjogWzAsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjExMFwiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiMTExXCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMTJcIjogWzAuMTg5MDYsIDAuNTIzOTYsIDAsIDBdLFxuICAgICAgICBcIjExM1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiMTE0XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMTVcIjogWzAsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjExNlwiOiBbMCwgMC42MjExOSwgMCwgMF0sXG4gICAgICAgIFwiMTE3XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMThcIjogWzAsIDAuNTIzOTYsIDAsIDBdLFxuICAgICAgICBcIjExOVwiOiBbMCwgMC41MjM5NiwgMCwgMF0sXG4gICAgICAgIFwiMTIwXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMjFcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjEyMlwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiODIxNlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODIxN1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTgxMTJcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjU4MTEzXCI6IFswLCAwLjYyMTE5LCAwLCAwXSxcbiAgICAgICAgXCI1ODExNFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTgxMTVcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjU4MTE2XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1ODExN1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTgxMThcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjU4MTE5XCI6IFswLCAwLjQ3NTM0LCAwLCAwXVxuICAgIH0sXG4gICAgXCJNYWluLUJvbGRcIjoge1xuICAgICAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0M1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMF0sXG4gICAgICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0NlwiOiBbMCwgMC4xNTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1MlwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1NVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1OFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjYwXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI2MVwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjYyXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjY1XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI2NlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNjdcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjY4XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI2OVwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzBcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjcxXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI3MlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzNcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjc0XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI3NVwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzZcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI3OFwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjgwXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjgzXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI4NFwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiODVcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjg2XCI6IFswLCAwLjY4NjExLCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCI4N1wiOiBbMCwgMC42ODYxMSwgMC4wMTU5NywgMF0sXG4gICAgICAgIFwiODhcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjg5XCI6IFswLCAwLjY4NjExLCAwLjAyODc1LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjkyXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjMxLCAwLjEzNDQ0LCAwLjAzMTk0LCAwXSxcbiAgICAgICAgXCI5NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5OVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4xMDkwMywgMF0sXG4gICAgICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwNVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDE1OTcsIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTI0XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEyNlwiOiBbMC4zNSwgMC4zNDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxNzJcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjE3NVwiOiBbMCwgMC41OTYxMSwgMCwgMF0sXG4gICAgICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxNzdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjE4MFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMjE1XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCIyNDdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcxMVwiOiBbMCwgMC42MzE5NCwgMCwgMF0sXG4gICAgICAgIFwiNzEzXCI6IFswLCAwLjU5NjExLCAwLCAwXSxcbiAgICAgICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MjlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzMyXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NjhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3MlwiOiBbMCwgMC41OTYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzc0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzc4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc4MFwiOiBbMCwgMC42MzE5NCwgMCwgMF0sXG4gICAgICAgIFwiODI0XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MTVcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkxNlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTIwXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MjNcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkyNlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTI4XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MzFcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkzM1wiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTM0XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MzZcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkzN1wiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiODIxMVwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiODIxMlwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyNFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODI0MlwiOiBbMCwgMC41NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiODQwN1wiOiBbMCwgMC43MjQ0NCwgMC4xNTQ4NiwgMF0sXG4gICAgICAgIFwiODQ2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ3MlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODUwMVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODU5MlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg1OTNcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg1OTRcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NTk1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTk2XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMF0sXG4gICAgICAgIFwiODU5N1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiODU5OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODU5OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODYwMFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODYwMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODYzNlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg2MzdcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NjQwXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMF0sXG4gICAgICAgIFwiODY0MVwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg2NTZcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NjU3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjU4XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMF0sXG4gICAgICAgIFwiODY1OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODY2MFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg2NjFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MDRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MDZcIjogWzAsIDAuNjk0NDQsIDAuMDYzODksIDBdLFxuICAgICAgICBcIjg3MDdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MDlcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MTFcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjg3MTJcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3MTVcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3MjJcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjNcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjZcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjdcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwXSxcbiAgICAgICAgXCI4NzI4XCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMF0sXG4gICAgICAgIFwiODcyOVwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDBdLFxuICAgICAgICBcIjg3MzBcIjogWzAuMTgsIDAuODIsIDAsIDBdLFxuICAgICAgICBcIjg3MzNcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MzRcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MzZcIjogWzAsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjg3MzlcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3NDFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3NDNcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDRcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDVcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDZcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDdcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMTI3NzgsIDBdLFxuICAgICAgICBcIjg3NjRcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NzY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzcxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4Nzc2XCI6IFswLjAyNDQ0LCAwLjUyNDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzgxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4ODAxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4ODA0XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODA1XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODEwXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODExXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODI2XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODI3XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODM0XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODM1XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODM4XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODM5XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ5XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUwXCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUxXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUyXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUzXCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU0XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU1XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU2XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU3XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4OTAwXCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMF0sXG4gICAgICAgIFwiODkwMVwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDBdLFxuICAgICAgICBcIjg5MDJcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTk0XCI6IFstMC4xMzg4OSwgMC4zNjExMSwgMCwgMF0sXG4gICAgICAgIFwiODk5NVwiOiBbLTAuMTM4ODksIDAuMzYxMTEsIDAsIDBdLFxuICAgICAgICBcIjk2NTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk2NTdcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwXSxcbiAgICAgICAgXCI5NjYxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjY3XCI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMF0sXG4gICAgICAgIFwiOTcxMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyNFwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyNVwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyNlwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyN1wiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgzN1wiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiOTgzOFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgzOVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyMTZcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEwMjE3XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMDgxNVwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiMTA5MjdcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDBdLFxuICAgICAgICBcIjEwOTI4XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXVxuICAgIH0sXG4gICAgXCJNYWluLUl0YWxpY1wiOiB7XG4gICAgICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDBdLFxuICAgICAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLjA2OTYxLCAwXSxcbiAgICAgICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNjYxNiwgMF0sXG4gICAgICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAuMTM2MzksIDBdLFxuICAgICAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwXSxcbiAgICAgICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMC4xMjQxNywgMF0sXG4gICAgICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAuMTYxOTQsIDBdLFxuICAgICAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLjAzNjk0LCAwXSxcbiAgICAgICAgXCI0MlwiOiBbMCwgMC43NSwgMC4xNDkxNywgMF0sXG4gICAgICAgIFwiNDNcIjogWzAuMDU2NjcsIDAuNTYxNjcsIDAuMDM2OTQsIDBdLFxuICAgICAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjEwNTU2LCAwLCAwXSxcbiAgICAgICAgXCI0NVwiOiBbMCwgMC40MzA1NiwgMC4wMjgyNiwgMF0sXG4gICAgICAgIFwiNDZcIjogWzAsIDAuMTA1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLjE2MTk0LCAwXSxcbiAgICAgICAgXCI0OFwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNDlcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDBdLFxuICAgICAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwXSxcbiAgICAgICAgXCI1MVwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNTJcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDBdLFxuICAgICAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwXSxcbiAgICAgICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNTVcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDBdLFxuICAgICAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwXSxcbiAgICAgICAgXCI1N1wiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAuMDU4MiwgMF0sXG4gICAgICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDU4MiwgMF0sXG4gICAgICAgIFwiNjFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLjA2NjE2LCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMC4xMjI1LCAwXSxcbiAgICAgICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMC4wOTU5NywgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4xNDUyOCwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjEyMDI4LCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAuMDg3MjIsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4xNTgwNiwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMTQwMjgsIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wOTQwMywgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTAyNTcsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLjA5NDAzLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMzg2OCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMTE5NzIsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzMzA1LCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xNjM4OSwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMTgzNjEsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjE4MzYxLCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4xNTgwNiwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMTkzODMsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMC4xODc1LCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMC4xMDUyOCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAuMDY2NDYsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjMxLCAwLjEyMDU2LCAwLjA5MjA4LCAwXSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAuMDYzMTIsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLjA1NjUzLCAwXSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDBdLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMC4wNzUxNCwgMF0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjIxMTk0LCAwXSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDg4NDcsIDBdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMC4wNzY3MSwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY1NTM2LCAwLjEwMTksIDBdLFxuICAgICAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NTUzNiwgMC4xNDQ2NywgMF0sXG4gICAgICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjEwNzY0LCAwXSxcbiAgICAgICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDBdLFxuICAgICAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMF0sXG4gICAgICAgIFwiMTEwXCI6IFswLCAwLjQzMDU2LCAwLjA3NjcxLCAwXSxcbiAgICAgICAgXCIxMTFcIjogWzAsIDAuNDMwNTYsIDAuMDYzMTIsIDBdLFxuICAgICAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNjMxMiwgMF0sXG4gICAgICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA4ODQ3LCAwXSxcbiAgICAgICAgXCIxMTRcIjogWzAsIDAuNDMwNTYsIDAuMTA3NjQsIDBdLFxuICAgICAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMC4wODIwOCwgMF0sXG4gICAgICAgIFwiMTE2XCI6IFswLCAwLjYxNTA4LCAwLjA5NDg2LCAwXSxcbiAgICAgICAgXCIxMTdcIjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDBdLFxuICAgICAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMC4xMDc2NCwgMF0sXG4gICAgICAgIFwiMTE5XCI6IFswLCAwLjQzMDU2LCAwLjEwNzY0LCAwXSxcbiAgICAgICAgXCIxMjBcIjogWzAsIDAuNDMwNTYsIDAuMTIwNDIsIDBdLFxuICAgICAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wODg0NywgMF0sXG4gICAgICAgIFwiMTIyXCI6IFswLCAwLjQzMDU2LCAwLjEyMjkyLCAwXSxcbiAgICAgICAgXCIxMjZcIjogWzAuMzUsIDAuMzE3ODYsIDAuMTE1ODUsIDBdLFxuICAgICAgICBcIjE2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzA1XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjc2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzY5XCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuNjk0NDQsIDAuMDY2NDYsIDBdLFxuICAgICAgICBcIjc3MVwiOiBbMCwgMC42Njc4NiwgMC4xMTU4NSwgMF0sXG4gICAgICAgIFwiNzcyXCI6IFswLCAwLjU2MTY3LCAwLjEwMzMzLCAwXSxcbiAgICAgICAgXCI3NzRcIjogWzAsIDAuNjk0NDQsIDAuMTA4MDYsIDBdLFxuICAgICAgICBcIjc3NVwiOiBbMCwgMC42Njc4NiwgMC4xMTc1MiwgMF0sXG4gICAgICAgIFwiNzc2XCI6IFswLCAwLjY2Nzg2LCAwLjEwNDc0LCAwXSxcbiAgICAgICAgXCI3NzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3OVwiOiBbMCwgMC42OTQ0NCwgMC4xMjI1LCAwXSxcbiAgICAgICAgXCI3ODBcIjogWzAsIDAuNjI4NDcsIDAuMDgyOTUsIDBdLFxuICAgICAgICBcIjkxNVwiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMF0sXG4gICAgICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDBdLFxuICAgICAgICBcIjkyM1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLjE1Mjk0LCAwXSxcbiAgICAgICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDBdLFxuICAgICAgICBcIjkzMVwiOiBbMCwgMC42ODMzMywgMC4xMjAyOCwgMF0sXG4gICAgICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLjExMTExLCAwXSxcbiAgICAgICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAuMDU5ODYsIDBdLFxuICAgICAgICBcIjkzNlwiOiBbMCwgMC42ODMzMywgMC4xMTExMSwgMF0sXG4gICAgICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwXSxcbiAgICAgICAgXCI4MjExXCI6IFswLCAwLjQzMDU2LCAwLjA5MjA4LCAwXSxcbiAgICAgICAgXCI4MjEyXCI6IFswLCAwLjQzMDU2LCAwLjA5MjA4LCAwXSxcbiAgICAgICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwXSxcbiAgICAgICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwXSxcbiAgICAgICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLjE2ODUsIDBdLFxuICAgICAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAuMDY5NjEsIDBdLFxuICAgICAgICBcIjg0NjNcIjogWzAsIDAuNjg4ODksIDAsIDBdXG4gICAgfSxcbiAgICBcIk1haW4tUmVndWxhclwiOiB7XG4gICAgICAgIFwiMzJcIjogWzAsIDAsIDAsIDBdLFxuICAgICAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0M1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTA1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI0NlwiOiBbMCwgMC4xMDU1NiwgMCwgMF0sXG4gICAgICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1MlwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1NVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1OFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjYwXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiNjFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI2MlwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMDI1LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjkyXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjMxLCAwLjEyMDU2LCAwLjAyNzc4LCAwXSxcbiAgICAgICAgXCI5NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4wNzc3OCwgMF0sXG4gICAgICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwNVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY2Nzg2LCAwLCAwXSxcbiAgICAgICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNjE1MDgsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTI0XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEyNlwiOiBbMC4zNSwgMC4zMTc4NiwgMCwgMF0sXG4gICAgICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwXSxcbiAgICAgICAgXCIxNjhcIjogWzAsIDAuNjY3ODYsIDAsIDBdLFxuICAgICAgICBcIjE3MlwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTc1XCI6IFswLCAwLjU2Nzc4LCAwLCAwXSxcbiAgICAgICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjE3N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMF0sXG4gICAgICAgIFwiMTgwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIyMTVcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjI0N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMF0sXG4gICAgICAgIFwiMzA1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzExXCI6IFswLCAwLjYyODQ3LCAwLCAwXSxcbiAgICAgICAgXCI3MTNcIjogWzAsIDAuNTY3NzgsIDAsIDBdLFxuICAgICAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcyOVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNjY3ODYsIDAsIDBdLFxuICAgICAgICBcIjc2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3MVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiNzcyXCI6IFswLCAwLjU2Nzc4LCAwLCAwXSxcbiAgICAgICAgXCI3NzRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3NVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiNzc2XCI6IFswLCAwLjY2Nzg2LCAwLCAwXSxcbiAgICAgICAgXCI3NzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3OVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzgwXCI6IFswLCAwLjYyODQ3LCAwLCAwXSxcbiAgICAgICAgXCI4MjRcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkxNVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjkyM1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjkzMVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjkzNlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4MjExXCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwXSxcbiAgICAgICAgXCI4MjEyXCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwXSxcbiAgICAgICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjI0XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjI1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjMwXCI6IFswLCAwLjEyLCAwLCAwXSxcbiAgICAgICAgXCI4MjQyXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NDA3XCI6IFswLCAwLjcxNDQ0LCAwLjE1MzgyLCAwXSxcbiAgICAgICAgXCI4NDYzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NDY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NDY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLjExMTExXSxcbiAgICAgICAgXCI4NDcyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjExMTExXSxcbiAgICAgICAgXCI4NDc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTAxXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTkyXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODU5M1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODU5NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg1OTVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg1OTZcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NTk3XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NTk4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTk5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjAwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjAxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjE0XCI6IFswLjAxMSwgMC41MTEsIDAsIDBdLFxuICAgICAgICBcIjg2MTdcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiODYxOFwiOiBbMC4wMTEsIDAuNTExLCAwLCAwXSxcbiAgICAgICAgXCI4NjM2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODYzN1wiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg2NDBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjQxXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODY1MlwiOiBbMC4wMTEsIDAuNjcxLCAwLCAwXSxcbiAgICAgICAgXCI4NjU2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODY1N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODY1OFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg2NTlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg2NjBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjYxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzA2XCI6IFswLCAwLjY5NDQ0LCAwLjA1NTU2LCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NzA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzA5XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzExXCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4NzEyXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiODcxNVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg3MjJcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjZcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjdcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwXSxcbiAgICAgICAgXCI4NzI4XCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMF0sXG4gICAgICAgIFwiODcyOVwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDBdLFxuICAgICAgICBcIjg3MzBcIjogWzAuMiwgMC44LCAwLCAwXSxcbiAgICAgICAgXCI4NzMzXCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzM0XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM5XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzQxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzQzXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ0XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ1XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMTExLCAwXSxcbiAgICAgICAgXCI4NzY0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODc2OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODc3MVwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDBdLFxuICAgICAgICBcIjg3NzNcIjogWy0wLjAyMiwgMC41ODksIDAsIDBdLFxuICAgICAgICBcIjg3NzZcIjogWy0wLjAxNjg4LCAwLjQ4MzEyLCAwLCAwXSxcbiAgICAgICAgXCI4NzgxXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMF0sXG4gICAgICAgIFwiODc4NFwiOiBbLTAuMTMzLCAwLjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODAwXCI6IFswLjIxNSwgMC43MTYsIDAsIDBdLFxuICAgICAgICBcIjg4MDFcIjogWy0wLjAzNjI1LCAwLjQ2Mzc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODA0XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODA1XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODEwXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiODgxMVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg4MjZcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwXSxcbiAgICAgICAgXCI4ODI3XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiODgzNFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg4MzVcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwXSxcbiAgICAgICAgXCI4ODM4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODM5XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ5XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUwXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUxXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUyXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU0XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU1XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU2XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU3XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODcyXCI6IFswLjI0OSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiODkwMFwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDBdLFxuICAgICAgICBcIjg5MDFcIjogWy0wLjA1NTU1LCAwLjQ0NDQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTAyXCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMF0sXG4gICAgICAgIFwiODkwNFwiOiBbMC4wMDUsIDAuNTA1LCAwLCAwXSxcbiAgICAgICAgXCI4OTQyXCI6IFswLjAzLCAwLjksIDAsIDBdLFxuICAgICAgICBcIjg5NDNcIjogWy0wLjE5LCAwLjMxLCAwLCAwXSxcbiAgICAgICAgXCI4OTQ1XCI6IFstMC4xLCAwLjgyLCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTk0XCI6IFstMC4xNDIzNiwgMC4zNTc2NCwgMCwgMF0sXG4gICAgICAgIFwiODk5NVwiOiBbLTAuMTQyMzYsIDAuMzU3NjQsIDAsIDBdLFxuICAgICAgICBcIjkxMzZcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMF0sXG4gICAgICAgIFwiOTEzN1wiOiBbMC4yNDQsIDAuNzQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjUxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjU3XCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMF0sXG4gICAgICAgIFwiOTY2MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTY2N1wiOiBbLTAuMDM0NzIsIDAuNDY1MjgsIDAsIDBdLFxuICAgICAgICBcIjk3MTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjRcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjVcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjZcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjdcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MzdcIjogWzAsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjk4MzhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MzlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMjE2XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxN1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMjJcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyMjNcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyMjlcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzBcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzFcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzJcIjogWzAuMDI0LCAwLjUyNSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzNcIjogWzAuMDI0LCAwLjUyNSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzRcIjogWzAuMDI0LCAwLjUyNSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzZcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTA4MTVcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjEwOTI3XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCIxMDkyOFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMF1cbiAgICB9LFxuICAgIFwiTWF0aC1Cb2xkSXRhbGljXCI6IHtcbiAgICAgICAgXCI0N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4NjExLCAwLjA0ODM1LCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODYxMSwgMC4wNjk3OSwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjg2MTEsIDAuMDMxOTQsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4NjExLCAwLjA1NDUxLCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4NjExLCAwLjA4MjI5LCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODYxMSwgMC4wNzc3OCwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjg2MTEsIDAuMTAwNjksIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjg2MTEsIDAuMTE0MjQsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4NjExLCAwLjExNDI0LCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODYxMSwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODYxMSwgMC4wMDQyMSwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjg2MTEsIDAuMDUzODIsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODYxMSwgMC4xMTQyNCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjg2MTEsIDAuMjU1NTUsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODYxMSwgMC4wNzc3OCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjg2MTEsIDAuMjU1NTUsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwXSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMDQyLCAwXSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY5MzI2LCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjkzMjYsIDAuMDYyMiwgMF0sXG4gICAgICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjAxODUyLCAwXSxcbiAgICAgICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMDA4OCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAuMDQyMTMsIDBdLFxuICAgICAgICBcIjkxNVwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMF0sXG4gICAgICAgIFwiOTE2XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MjBcIjogWzAsIDAuNjg2MTEsIDAuMDMxOTQsIDBdLFxuICAgICAgICBcIjkyM1wiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTI2XCI6IFswLCAwLjY4NjExLCAwLjA3NDU4LCAwXSxcbiAgICAgICAgXCI5MjhcIjogWzAsIDAuNjg2MTEsIDAuMDgyMjksIDBdLFxuICAgICAgICBcIjkzMVwiOiBbMCwgMC42ODYxMSwgMC4wNTQ1MSwgMF0sXG4gICAgICAgIFwiOTMzXCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwXSxcbiAgICAgICAgXCI5MzRcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkzNlwiOiBbMCwgMC42ODYxMSwgMC4xMTY1MywgMF0sXG4gICAgICAgIFwiOTM3XCI6IFswLCAwLjY4NjExLCAwLjA0ODM1LCAwXSxcbiAgICAgICAgXCI5NDVcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk0NlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzQwMywgMF0sXG4gICAgICAgIFwiOTQ3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA2Mzg5LCAwXSxcbiAgICAgICAgXCI5NDhcIjogWzAsIDAuNjk0NDQsIDAuMDM4MTksIDBdLFxuICAgICAgICBcIjk0OVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTUwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA2MjE1LCAwXSxcbiAgICAgICAgXCI5NTFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk1MlwiOiBbMCwgMC42OTQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiOTUzXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NTRcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTU2XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NTdcIjogWzAsIDAuNDQ0NDQsIDAuMDY4OTgsIDBdLFxuICAgICAgICBcIjk1OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzAyMSwgMF0sXG4gICAgICAgIFwiOTU5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjBcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk2MVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTYyXCI6IFswLjA5NzIyLCAwLjQ0NDQ0LCAwLjA3OTE3LCAwXSxcbiAgICAgICAgXCI5NjNcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk2NFwiOiBbMCwgMC40NDQ0NCwgMC4xMzQ3MiwgMF0sXG4gICAgICAgIFwiOTY1XCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCI5NjlcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5ODJcIjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDBdLFxuICAgICAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMTNcIjogWzAsIDAuNDQ0NDQsIDAsIDBdXG4gICAgfSxcbiAgICBcIk1hdGgtSXRhbGljXCI6IHtcbiAgICAgICAgXCI0N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODldLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0XSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDU1NTZdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjA4MTI1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4xMTExMV0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMDk2MTgsIDAuMTY2NjddLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA1NTU2XSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzRdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzRdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMDc3MywgMC4wODMzNF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzRdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wMjc3OF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4wODMzNF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEwNzY0LCAwLjE2NjY3XSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY1OTUyLCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjU5NTIsIDAuMDU3MjQsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wMzE0OCwgMF0sXG4gICAgICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjAxOTY4LCAwLjA4MzM0XSxcbiAgICAgICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdLFxuICAgICAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4wMjY5MSwgMC4wODMzNF0sXG4gICAgICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDU1NTZdLFxuICAgICAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMC4wNDM5OCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3XSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjgzMzMsIDAuMDc1NjksIDAuMDgzMzRdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDU1NTZdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExLCAwLjA1NTU2XSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjgzMzMsIDAuMDUwMTcsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0NVwiOiBbMCwgMC40MzA1NiwgMC4wMDM3LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUyNzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTU1NiwgMF0sXG4gICAgICAgIFwiOTQ4XCI6IFswLCAwLjY5NDQ0LCAwLjAzNzg1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NDlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNzM3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDI3NzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1M1wiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTU0XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI5NTVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1NlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTU3XCI6IFswLCAwLjQzMDU2LCAwLjA2MzY2LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDQ2MDEsIDAuMTExMTFdLFxuICAgICAgICBcIjk1OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTYwXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40MzA1NiwgMC4wNzk4NiwgMC4wODMzNF0sXG4gICAgICAgIFwiOTYzXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjRcIjogWzAsIDAuNDMwNTYsIDAuMTEzMiwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTY1XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNTg4LCAwLjExMTExXSxcbiAgICAgICAgXCI5NjlcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDBdLFxuICAgICAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5ODJcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjEwMTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdXG4gICAgfSxcbiAgICBcIk1hdGgtUmVndWxhclwiOiB7XG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODldLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0XSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDU1NTZdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjA4MTI1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4xMTExMV0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMDk2MTgsIDAuMTY2NjddLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA1NTU2XSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzRdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzRdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMDc3MywgMC4wODMzNF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzRdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wMjc3OF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4wODMzNF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEwNzY0LCAwLjE2NjY3XSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY1OTUyLCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjU5NTIsIDAuMDU3MjQsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wMzE0OCwgMF0sXG4gICAgICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjAxOTY4LCAwLjA4MzM0XSxcbiAgICAgICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdLFxuICAgICAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4wMjY5MSwgMC4wODMzNF0sXG4gICAgICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDU1NTZdLFxuICAgICAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMC4wNDM5OCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3XSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjgzMzMsIDAuMDc1NjksIDAuMDgzMzRdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDU1NTZdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExLCAwLjA1NTU2XSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjgzMzMsIDAuMDUwMTcsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0NVwiOiBbMCwgMC40MzA1NiwgMC4wMDM3LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUyNzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTU1NiwgMF0sXG4gICAgICAgIFwiOTQ4XCI6IFswLCAwLjY5NDQ0LCAwLjAzNzg1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NDlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNzM3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDI3NzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1M1wiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTU0XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI5NTVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1NlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTU3XCI6IFswLCAwLjQzMDU2LCAwLjA2MzY2LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDQ2MDEsIDAuMTExMTFdLFxuICAgICAgICBcIjk1OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTYwXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40MzA1NiwgMC4wNzk4NiwgMC4wODMzNF0sXG4gICAgICAgIFwiOTYzXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjRcIjogWzAsIDAuNDMwNTYsIDAuMTEzMiwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTY1XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNTg4LCAwLjExMTExXSxcbiAgICAgICAgXCI5NjlcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDBdLFxuICAgICAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5ODJcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjEwMTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdXG4gICAgfSxcbiAgICBcIlNhbnNTZXJpZi1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjQ0XCI6IFswLjEyNSwgMC4wODMzMywgMCwgMF0sXG4gICAgICAgIFwiNDVcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjQ2XCI6IFswLCAwLjA4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDhcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ5XCI6IFswLCAwLjY1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI1MFwiOiBbMCwgMC42NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNTFcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjUyXCI6IFswLCAwLjY1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI1M1wiOiBbMCwgMC42NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNTRcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjU1XCI6IFswLCAwLjY1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI1NlwiOiBbMCwgMC42NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNTdcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjU4XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1OVwiOiBbMC4xMjUsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjYxXCI6IFstMC4xMywgMC4zNywgMCwgMF0sXG4gICAgICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzJcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjczXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODFcIjogWzAuMTI1LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjk0NDQsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY5NDQ0LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjk0NDQsIDAuMDI1LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTVcIjogWzAuMzUsIDAuMDk0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAxXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMDY5NDQsIDBdLFxuICAgICAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTM4OSwgMF0sXG4gICAgICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDVcIjogWzAsIDAuNjc5MzcsIDAsIDBdLFxuICAgICAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NzkzNywgMCwgMF0sXG4gICAgICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwOVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTRcIjogWzAsIDAuNDQ0NDQsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE2XCI6IFswLCAwLjU3MTQzLCAwLCAwXSxcbiAgICAgICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExOFwiOiBbMCwgMC40NDQ0NCwgMC4wMTM4OSwgMF0sXG4gICAgICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTM4OSwgMF0sXG4gICAgICAgIFwiMTIyXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMjZcIjogWzAuMzUsIDAuMzI2NTksIDAsIDBdLFxuICAgICAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NjhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuNjc2NTksIDAsIDBdLFxuICAgICAgICBcIjc3MlwiOiBbMCwgMC42MDg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzc0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzVcIjogWzAsIDAuNjc5MzcsIDAsIDBdLFxuICAgICAgICBcIjc3NlwiOiBbMCwgMC42NzkzNywgMCwgMF0sXG4gICAgICAgIFwiNzc4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc4MFwiOiBbMCwgMC42MzE5NCwgMCwgMF0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjgyMTJcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAsIDBdXG4gICAgfSxcbiAgICBcIlNjcmlwdC1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI2NVwiOiBbMCwgMC43LCAwLjIyOTI1LCAwXSxcbiAgICAgICAgXCI2NlwiOiBbMCwgMC43LCAwLjA0MDg3LCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC43LCAwLjE2ODksIDBdLFxuICAgICAgICBcIjY4XCI6IFswLCAwLjcsIDAuMDkzNzEsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjcsIDAuMTg1ODMsIDBdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjcsIDAuMTM2MzQsIDBdLFxuICAgICAgICBcIjcxXCI6IFswLCAwLjcsIDAuMTczMjIsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjcsIDAuMjk2OTQsIDBdLFxuICAgICAgICBcIjczXCI6IFswLCAwLjcsIDAuMTkxODksIDBdLFxuICAgICAgICBcIjc0XCI6IFswLjI3Nzc4LCAwLjcsIDAuMTkxODksIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjcsIDAuMzEyNTksIDBdLFxuICAgICAgICBcIjc2XCI6IFswLCAwLjcsIDAuMTkxODksIDBdLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjcsIDAuMTU5ODEsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjcsIDAuMzUyNSwgMF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNywgMC4wODA3OCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNywgMC4wODA3OCwgMF0sXG4gICAgICAgIFwiODFcIjogWzAsIDAuNywgMC4wMzMwNSwgMF0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNywgMC4wNjI1OSwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNywgMC4xOTE4OSwgMF0sXG4gICAgICAgIFwiODRcIjogWzAsIDAuNywgMC4yOTA4NywgMF0sXG4gICAgICAgIFwiODVcIjogWzAsIDAuNywgMC4yNTgxNSwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNywgMC4yNzUyMywgMF0sXG4gICAgICAgIFwiODdcIjogWzAsIDAuNywgMC4yNzUyMywgMF0sXG4gICAgICAgIFwiODhcIjogWzAsIDAuNywgMC4yNjAwNiwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNywgMC4yOTM5LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC43LCAwLjI0MDM3LCAwXVxuICAgIH0sXG4gICAgXCJTaXplMS1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI0MFwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiOTJcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCIxMjNcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjEyNVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiNzEwXCI6IFswLCAwLjcyMjIyLCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNzIyMjIsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC43MjIyMiwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjcyMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4MjE0XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDBdLFxuICAgICAgICBcIjg1OTNcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg1OTVcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg2NTdcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg2NTlcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg3MTlcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjBcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjFcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MzBcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjg3MzlcIjogWy0wLjAwNTk5LCAwLjYwNiwgMCwgMF0sXG4gICAgICAgIFwiODc0MVwiOiBbLTAuMDA1OTksIDAuNjA2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ3XCI6IFswLjMwNjEyLCAwLjgwNSwgMC4xOTQ0NSwgMF0sXG4gICAgICAgIFwiODc0OFwiOiBbMC4zMDYsIDAuODA1LCAwLjE5NDQ1LCAwXSxcbiAgICAgICAgXCI4NzQ5XCI6IFswLjMwNiwgMC44MDUsIDAuMTk0NDUsIDBdLFxuICAgICAgICBcIjg3NTBcIjogWzAuMzA2MTIsIDAuODA1LCAwLjE5NDQ1LCAwXSxcbiAgICAgICAgXCI4ODk2XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODk3XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODk4XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODk5XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI5MTY4XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDBdLFxuICAgICAgICBcIjEwMjE2XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxN1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTJcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEwNzUzXCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMDc1NFwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTZcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEwNzU4XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXVxuICAgIH0sXG4gICAgXCJTaXplMi1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI0MFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiOTJcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCIxMjNcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjEyNVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiNzEwXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzE5XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCI4NzIwXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCI4NzIxXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCI4NzMwXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ3XCI6IFswLjg2MjI1LCAxLjM2LCAwLjQ0NDQ1LCAwXSxcbiAgICAgICAgXCI4NzQ4XCI6IFswLjg2MiwgMS4zNiwgMC40NDQ0NSwgMF0sXG4gICAgICAgIFwiODc0OVwiOiBbMC44NjIsIDEuMzYsIDAuNDQ0NDUsIDBdLFxuICAgICAgICBcIjg3NTBcIjogWzAuODYyMjUsIDEuMzYsIDAuNDQ0NDUsIDBdLFxuICAgICAgICBcIjg4OTZcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg4OTdcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg4OThcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg4OTlcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg5NjhcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjg5NjlcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjg5NzBcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjg5NzFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjEwMjE2XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxN1wiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTJcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjEwNzUzXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCIxMDc1NFwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTZcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjEwNzU4XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXVxuICAgIH0sXG4gICAgXCJTaXplMy1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI0MFwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiOTJcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCIxMjNcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdLFxuICAgICAgICBcIjEyNVwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiNzEwXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzMwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxNlwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMTdcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdXG4gICAgfSxcbiAgICBcIlNpemU0LVJlZ3VsYXJcIjoge1xuICAgICAgICBcIjQwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0MVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiNDdcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDBdLFxuICAgICAgICBcIjkxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5MlwiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiOTNcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiMTI1XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI3MTBcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI4NzMwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5MTE1XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMF0sXG4gICAgICAgIFwiOTExNlwiOiBbMWUtMDUsIDAuNiwgMCwgMF0sXG4gICAgICAgIFwiOTExN1wiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDBdLFxuICAgICAgICBcIjkxMThcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwXSxcbiAgICAgICAgXCI5MTE5XCI6IFsxZS0wNSwgMC42LCAwLCAwXSxcbiAgICAgICAgXCI5MTIwXCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMF0sXG4gICAgICAgIFwiOTEyMVwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDBdLFxuICAgICAgICBcIjkxMjJcIjogWy0wLjAwMDk5LCAwLjYwMSwgMCwgMF0sXG4gICAgICAgIFwiOTEyM1wiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDBdLFxuICAgICAgICBcIjkxMjRcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwXSxcbiAgICAgICAgXCI5MTI1XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDBdLFxuICAgICAgICBcIjkxMjZcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwXSxcbiAgICAgICAgXCI5MTI3XCI6IFsxZS0wNSwgMC45LCAwLCAwXSxcbiAgICAgICAgXCI5MTI4XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCI5MTI5XCI6IFswLjkwMDAxLCAwLCAwLCAwXSxcbiAgICAgICAgXCI5MTMwXCI6IFswLCAwLjMsIDAsIDBdLFxuICAgICAgICBcIjkxMzFcIjogWzFlLTA1LCAwLjksIDAsIDBdLFxuICAgICAgICBcIjkxMzJcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjkxMzNcIjogWzAuOTAwMDEsIDAsIDAsIDBdLFxuICAgICAgICBcIjkxNDNcIjogWzAuODg1MDIsIDAuOTE1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxNlwiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMTdcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDBdLFxuICAgICAgICBcIjU3MzQ0XCI6IFstMC4wMDQ5OSwgMC42MDUsIDAsIDBdLFxuICAgICAgICBcIjU3MzQ1XCI6IFstMC4wMDQ5OSwgMC42MDUsIDAsIDBdLFxuICAgICAgICBcIjU3NjgwXCI6IFswLCAwLjEyLCAwLCAwXSxcbiAgICAgICAgXCI1NzY4MVwiOiBbMCwgMC4xMiwgMCwgMF0sXG4gICAgICAgIFwiNTc2ODJcIjogWzAsIDAuMTIsIDAsIDBdLFxuICAgICAgICBcIjU3NjgzXCI6IFswLCAwLjEyLCAwLCAwXVxuICAgIH0sXG4gICAgXCJUeXBld3JpdGVyLVJlZ3VsYXJcIjoge1xuICAgICAgICBcIjMzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIzNFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMzVcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjM2XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzN1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzhcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjM5XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI0MFwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjQyXCI6IFswLCAwLjUyMDgzLCAwLCAwXSxcbiAgICAgICAgXCI0M1wiOiBbLTAuMDgwNTYsIDAuNTMwNTUsIDAsIDBdLFxuICAgICAgICBcIjQ0XCI6IFswLjEzODg5LCAwLjEyNSwgMCwgMF0sXG4gICAgICAgIFwiNDVcIjogWy0wLjA4MDU2LCAwLjUzMDU1LCAwLCAwXSxcbiAgICAgICAgXCI0NlwiOiBbMCwgMC4xMjUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0OFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNDlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjUwXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI1MVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNTJcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjUzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI1NFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNTVcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjU2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI1N1wiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjU5XCI6IFswLjEzODg5LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI2MFwiOiBbLTAuMDU1NTYsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjYxXCI6IFstMC4xOTU0OSwgMC40MTU2MiwgMCwgMF0sXG4gICAgICAgIFwiNjJcIjogWy0wLjA1NTU2LCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNjRcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjY1XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI2NlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNjdcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjY4XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI2OVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzBcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjcxXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3MlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzNcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc0XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzZcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3OFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjgwXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI4MVwiOiBbMC4xMzg4OSwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjgzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI4NFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiODVcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjg2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI4N1wiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiODhcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjg5XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkyXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjA5NTE0LCAwLCAwLCAwXSxcbiAgICAgICAgXCI5NlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjk4XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTAwXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEwMlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTAzXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMDRcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjEwNVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTA2XCI6IFswLjIyMjIyLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIxMDdcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjEwOFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNTUzNTgsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTI0XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMjVcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEyNlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTI3XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIzMDVcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjU2N1wiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNzY4XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NjlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NzJcIjogWzAsIDAuNTY1NTUsIDAsIDBdLFxuICAgICAgICBcIjc3NFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzc2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NzhcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc4MFwiOiBbMCwgMC41NjU5NywgMCwgMF0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjIwMThcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjIwMTlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjgyNDJcIjogWzAsIDAuNjExMTEsIDAsIDBdXG4gICAgfVxufTtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIFBhcnNlRXJyb3IgPSByZXF1aXJlKFwiLi9QYXJzZUVycm9yXCIpO1xudmFyIHBhcnNlRGF0YSA9IHJlcXVpcmUoXCIuL3BhcnNlRGF0YVwiKTtcbnZhciBQYXJzZU5vZGUgPSBwYXJzZURhdGEuUGFyc2VOb2RlO1xuXG4vKiBUaGlzIGZpbGUgY29udGFpbnMgYSBsaXN0IG9mIGZ1bmN0aW9ucyB0aGF0IHdlIHBhcnNlLCBpZGVudGlmaWVkIGJ5XG4gKiB0aGUgY2FsbHMgdG8gZGVmaW5lRnVuY3Rpb24uXG4gKlxuICogVGhlIGZpcnN0IGFyZ3VtZW50IHRvIGRlZmluZUZ1bmN0aW9uIGlzIGEgc2luZ2xlIG5hbWUgb3IgYSBsaXN0IG9mIG5hbWVzLlxuICogQWxsIGZ1bmN0aW9ucyBuYW1lZCBpbiBzdWNoIGEgbGlzdCB3aWxsIHNoYXJlIGEgc2luZ2xlIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEVhY2ggZGVjbGFyZWQgZnVuY3Rpb24gY2FuIGhhdmUgYXNzb2NpYXRlZCBwcm9wZXJ0aWVzLCB3aGljaFxuICogaW5jbHVkZSB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIG51bUFyZ3M6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoZSBmdW5jdGlvbiB0YWtlcy5cbiAqICAgICAgICAgICAgIElmIHRoaXMgaXMgdGhlIG9ubHkgcHJvcGVydHksIGl0IGNhbiBiZSBwYXNzZWQgYXMgYSBudW1iZXJcbiAqICAgICAgICAgICAgIGluc3RlYWQgb2YgYW4gZWxlbWVudCBvZiBhIHByb3BlcnRpZXMgb2JqZWN0LlxuICogIC0gYXJnVHlwZXM6IChvcHRpb25hbCkgQW4gYXJyYXkgY29ycmVzcG9uZGluZyB0byBlYWNoIGFyZ3VtZW50IG9mIHRoZVxuICogICAgICAgICAgICAgIGZ1bmN0aW9uLCBnaXZpbmcgdGhlIHR5cGUgb2YgYXJndW1lbnQgdGhhdCBzaG91bGQgYmUgcGFyc2VkLiBJdHNcbiAqICAgICAgICAgICAgICBsZW5ndGggc2hvdWxkIGJlIGVxdWFsIHRvIGBudW1BcmdzICsgbnVtT3B0aW9uYWxBcmdzYC4gVmFsaWRcbiAqICAgICAgICAgICAgICB0eXBlczpcbiAqICAgICAgICAgICAgICAgLSBcInNpemVcIjogQSBzaXplLWxpa2UgdGhpbmcsIHN1Y2ggYXMgXCIxZW1cIiBvciBcIjVleFwiXG4gKiAgICAgICAgICAgICAgIC0gXCJjb2xvclwiOiBBbiBodG1sIGNvbG9yLCBsaWtlIFwiI2FiY1wiIG9yIFwiYmx1ZVwiXG4gKiAgICAgICAgICAgICAgIC0gXCJvcmlnaW5hbFwiOiBUaGUgc2FtZSB0eXBlIGFzIHRoZSBlbnZpcm9ubWVudCB0aGF0IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJlaW5nIHBhcnNlZCBpcyBpbiAoZS5nLiB1c2VkIGZvciB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2RpZXMgb2YgZnVuY3Rpb25zIGxpa2UgXFxjb2xvciB3aGVyZSB0aGUgZmlyc3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudCBpcyBzcGVjaWFsIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkIG5vcm1hbGx5KVxuICogICAgICAgICAgICAgIE90aGVyIHBvc3NpYmxlIHR5cGVzIChwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZClcbiAqICAgICAgICAgICAgICAgLSBcInRleHRcIjogVGV4dC1saWtlIChlLmcuIFxcdGV4dClcbiAqICAgICAgICAgICAgICAgLSBcIm1hdGhcIjogTm9ybWFsIG1hdGhcbiAqICAgICAgICAgICAgICBJZiB1bmRlZmluZWQsIHRoaXMgd2lsbCBiZSB0cmVhdGVkIGFzIGFuIGFwcHJvcHJpYXRlIGxlbmd0aFxuICogICAgICAgICAgICAgIGFycmF5IG9mIFwib3JpZ2luYWxcIiBzdHJpbmdzXG4gKiAgLSBncmVlZGluZXNzOiAob3B0aW9uYWwpIFRoZSBncmVlZGluZXNzIG9mIHRoZSBmdW5jdGlvbiB0byB1c2UgdW5ncm91cGVkXG4gKiAgICAgICAgICAgICAgICBhcmd1bWVudHMuXG4gKlxuICogICAgICAgICAgICAgICAgRS5nLiBpZiB5b3UgaGF2ZSBhbiBleHByZXNzaW9uXG4gKiAgICAgICAgICAgICAgICAgIFxcc3FydCBcXGZyYWMgMSAyXG4gKiAgICAgICAgICAgICAgICBzaW5jZSBcXGZyYWMgaGFzIGdyZWVkaW5lc3M9MiB2cyBcXHNxcnQncyBncmVlZGluZXNzPTEsIFxcZnJhY1xuICogICAgICAgICAgICAgICAgd2lsbCB1c2UgdGhlIHR3byBhcmd1bWVudHMgJzEnIGFuZCAnMicgYXMgaXRzIHR3byBhcmd1bWVudHMsXG4gKiAgICAgICAgICAgICAgICB0aGVuIHRoYXQgd2hvbGUgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGFzIHRoZSBhcmd1bWVudCB0b1xuICogICAgICAgICAgICAgICAgXFxzcXJ0LiBPbiB0aGUgb3RoZXIgaGFuZCwgdGhlIGV4cHJlc3Npb25zXG4gKiAgICAgICAgICAgICAgICAgIFxcZnJhYyBcXGZyYWMgMSAyIDNcbiAqICAgICAgICAgICAgICAgIGFuZFxuICogICAgICAgICAgICAgICAgICBcXGZyYWMgXFxzcXJ0IDEgMlxuICogICAgICAgICAgICAgICAgd2lsbCBmYWlsIGJlY2F1c2UgXFxmcmFjIGFuZCBcXGZyYWMgaGF2ZSBlcXVhbCBncmVlZGluZXNzXG4gKiAgICAgICAgICAgICAgICBhbmQgXFxzcXJ0IGhhcyBhIGxvd2VyIGdyZWVkaW5lc3MgdGhhbiBcXGZyYWMgcmVzcGVjdGl2ZWx5LiBUb1xuICogICAgICAgICAgICAgICAgbWFrZSB0aGVzZSBwYXJzZSwgd2Ugd291bGQgaGF2ZSB0byBjaGFuZ2UgdGhlbSB0bzpcbiAqICAgICAgICAgICAgICAgICAgXFxmcmFjIHtcXGZyYWMgMSAyfSAzXG4gKiAgICAgICAgICAgICAgICBhbmRcbiAqICAgICAgICAgICAgICAgICAgXFxmcmFjIHtcXHNxcnQgMX0gMlxuICpcbiAqICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAxYFxuICogIC0gYWxsb3dlZEluVGV4dDogKG9wdGlvbmFsKSBXaGV0aGVyIG9yIG5vdCB0aGUgZnVuY3Rpb24gaXMgYWxsb3dlZCBpbnNpZGVcbiAqICAgICAgICAgICAgICAgICAgIHRleHQgbW9kZSAoZGVmYXVsdCBmYWxzZSlcbiAqICAtIG51bU9wdGlvbmFsQXJnczogKG9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIG9wdGlvbmFsIGFyZ3VtZW50cyB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIHBhcnNlLiBJZiB0aGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZW4ndCBmb3VuZCxcbiAqICAgICAgICAgICAgICAgICAgICAgYG51bGxgIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBoYW5kbGVyIGluIHRoZWlyIHBsYWNlLlxuICogICAgICAgICAgICAgICAgICAgICAoZGVmYXVsdCAwKVxuICogIC0gaW5maXg6IChvcHRpb25hbCkgTXVzdCBiZSB0cnVlIGlmIHRoZSBmdW5jdGlvbiBpcyBhbiBpbmZpeCBvcGVyYXRvci5cbiAqXG4gKiBUaGUgbGFzdCBhcmd1bWVudCBpcyB0aGF0IGltcGxlbWVudGF0aW9uLCB0aGUgaGFuZGxlciBmb3IgdGhlIGZ1bmN0aW9uKHMpLlxuICogSXQgaXMgY2FsbGVkIHRvIGhhbmRsZSB0aGVzZSBmdW5jdGlvbnMgYW5kIHRoZWlyIGFyZ3VtZW50cy5cbiAqIEl0IHJlY2VpdmVzIHR3byBhcmd1bWVudHM6XG4gKiAgLSBjb250ZXh0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFuZCByZWZlcmVuY2VzIHByb3ZpZGVkIGJ5IHRoZSBwYXJzZXJcbiAqICAtIGFyZ3MgaXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG9idGFpbmVkIGZyb20gVGVYIGlucHV0XG4gKiBUaGUgY29udGV4dCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgLSBmdW5jTmFtZTogdGhlIHRleHQgKGkuZS4gbmFtZSkgb2YgdGhlIGZ1bmN0aW9uLCBpbmNsdWRpbmcgXFxcbiAqICAtIHBhcnNlcjogdGhlIHBhcnNlciBvYmplY3RcbiAqICAtIGxleGVyOiB0aGUgbGV4ZXIgb2JqZWN0XG4gKiAgLSBwb3NpdGlvbnM6IHRoZSBwb3NpdGlvbnMgaW4gdGhlIG92ZXJhbGwgc3RyaW5nIG9mIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICBhbmQgdGhlIGFyZ3VtZW50cy5cbiAqIFRoZSBsYXR0ZXIgdGhyZWUgc2hvdWxkIG9ubHkgYmUgdXNlZCB0byBwcm9kdWNlIGVycm9yIG1lc3NhZ2VzLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcga2V5czpcbiAqICAtIHR5cGU6IFRoZSB0eXBlIG9mIGVsZW1lbnQgdGhhdCB0aGlzIGlzLiBUaGlzIGlzIHRoZW4gdXNlZCBpblxuICogICAgICAgICAgYnVpbGRIVE1ML2J1aWxkTWF0aE1MIHRvIGRldGVybWluZSB3aGljaCBmdW5jdGlvblxuICogICAgICAgICAgc2hvdWxkIGJlIGNhbGxlZCB0byBidWlsZCB0aGlzIG5vZGUgaW50byBhIERPTSBub2RlXG4gKiBBbnkgb3RoZXIgZGF0YSBjYW4gYmUgYWRkZWQgdG8gdGhlIG9iamVjdCwgd2hpY2ggd2lsbCBiZSBwYXNzZWRcbiAqIGluIHRvIHRoZSBmdW5jdGlvbiBpbiBidWlsZEhUTUwvYnVpbGRNYXRoTUwgYXMgYGdyb3VwLnZhbHVlYC5cbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVGdW5jdGlvbihuYW1lcywgcHJvcHMsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5hbWVzID0gW25hbWVzXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBwcm9wcyA9IHsgbnVtQXJnczogcHJvcHMgfTtcbiAgICB9XG4gICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIG9mIGZ1bmN0aW9uc1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICBudW1BcmdzOiBwcm9wcy5udW1BcmdzLFxuICAgICAgICBhcmdUeXBlczogcHJvcHMuYXJnVHlwZXMsXG4gICAgICAgIGdyZWVkaW5lc3M6IChwcm9wcy5ncmVlZGluZXNzID09PSB1bmRlZmluZWQpID8gMSA6IHByb3BzLmdyZWVkaW5lc3MsXG4gICAgICAgIGFsbG93ZWRJblRleHQ6ICEhcHJvcHMuYWxsb3dlZEluVGV4dCxcbiAgICAgICAgbnVtT3B0aW9uYWxBcmdzOiBwcm9wcy5udW1PcHRpb25hbEFyZ3MgfHwgMCxcbiAgICAgICAgaW5maXg6ICEhcHJvcHMuaW5maXgsXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHNbbmFtZXNbaV1dID0gZGF0YTtcbiAgICB9XG59XG5cbi8vIFNpbmNlIHRoZSBjb3JyZXNwb25kaW5nIGJ1aWxkSFRNTC9idWlsZE1hdGhNTCBmdW5jdGlvbiBleHBlY3RzIGFcbi8vIGxpc3Qgb2YgZWxlbWVudHMsIHdlIG5vcm1hbGl6ZSBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIGFyZ3VtZW50c1xudmFyIG9yZGFyZ3VtZW50ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgcmV0dXJuIGFyZy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2FyZ107XG4gICAgfVxufTtcblxuLy8gQSBub3JtYWwgc3F1YXJlIHJvb3RcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXHNxcnRcIiwge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGluZGV4ID0gYXJnc1swXTtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzcXJ0XCIsXG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgIH07XG59KTtcblxuLy8gTm9uLW1hdGh5IHRleHQsIHBvc3NpYmx5IGluIGEgZm9udFxudmFyIHRleHRGdW5jdGlvblN0eWxlcyA9IHtcbiAgICBcIlxcXFx0ZXh0XCI6IHVuZGVmaW5lZCwgXCJcXFxcdGV4dHJtXCI6IFwibWF0aHJtXCIsIFwiXFxcXHRleHRzZlwiOiBcIm1hdGhzZlwiLFxuICAgIFwiXFxcXHRleHR0dFwiOiBcIm1hdGh0dFwiLCBcIlxcXFx0ZXh0bm9ybWFsXCI6IFwibWF0aHJtXCIsIFwiXFxcXHRleHRiZlwiOiBcIm1hdGhiZlwiLFxuICAgIFwiXFxcXHRleHRpdFwiOiBcInRleHRpdFwiXG59O1xuXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcdGV4dFwiLCBcIlxcXFx0ZXh0cm1cIiwgXCJcXFxcdGV4dHNmXCIsIFwiXFxcXHRleHR0dFwiLCBcIlxcXFx0ZXh0bm9ybWFsXCIsXG4gICAgXCJcXFxcdGV4dGJmXCIsIFwiXFxcXHRleHRpdFwiXG5dLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXSxcbiAgICBncmVlZGluZXNzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgICBzdHlsZTogdGV4dEZ1bmN0aW9uU3R5bGVzW2NvbnRleHQuZnVuY05hbWVdXG4gICAgfTtcbn0pO1xuXG4vLyBBIHR3by1hcmd1bWVudCBjdXN0b20gY29sb3JcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXGNvbG9yXCIsIHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgZ3JlZWRpbmVzczogMyxcbiAgICBhcmdUeXBlczogW1wiY29sb3JcIiwgXCJvcmlnaW5hbFwiXVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBjb2xvciA9IGFyZ3NbMF07XG4gICAgdmFyIGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgY29sb3I6IGNvbG9yLnZhbHVlLFxuICAgICAgICB2YWx1ZTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xufSk7XG5cbi8vIEFuIG92ZXJsaW5lXG5kZWZpbmVGdW5jdGlvbihcIlxcXFxvdmVybGluZVwiLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm92ZXJsaW5lXCIsXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xufSk7XG5cbi8vIEFuIHVuZGVybGluZVxuZGVmaW5lRnVuY3Rpb24oXCJcXFxcdW5kZXJsaW5lXCIsIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidW5kZXJsaW5lXCIsXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xufSk7XG5cbi8vIEEgYm94IG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0XG5kZWZpbmVGdW5jdGlvbihcIlxcXFxydWxlXCIsIHtcbiAgICBudW1BcmdzOiAyLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiLCBcInNpemVcIiwgXCJzaXplXCJdXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIHNoaWZ0ID0gYXJnc1swXTtcbiAgICB2YXIgd2lkdGggPSBhcmdzWzFdO1xuICAgIHZhciBoZWlnaHQgPSBhcmdzWzJdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwicnVsZVwiLFxuICAgICAgICBzaGlmdDogc2hpZnQgJiYgc2hpZnQudmFsdWUsXG4gICAgICAgIHdpZHRoOiB3aWR0aC52YWx1ZSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQudmFsdWVcbiAgICB9O1xufSk7XG5cbi8vIFRPRE86IEluIFRlWCwgXFxta2VybiBvbmx5IGFjY2VwdHMgbXUtdW5pdHMsIGFuZCBcXGtlcm4gZG9lcyBub3QgYWNjZXB0XG4vLyBtdS11bml0cy4gSW4gY3VycmVudCBLYVRlWCB3ZSByZWxheCB0aGlzOyBib3RoIGNvbW1hbmRzIGFjY2VwdCBhbnkgdW5pdC5cbmRlZmluZUZ1bmN0aW9uKFtcIlxcXFxrZXJuXCIsIFwiXFxcXG1rZXJuXCJdLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBkaW1lbnNpb246IGFyZ3NbMF0udmFsdWVcbiAgICB9O1xufSk7XG5cbi8vIEEgS2FUZVggbG9nb1xuZGVmaW5lRnVuY3Rpb24oXCJcXFxcS2FUZVhcIiwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImthdGV4XCJcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFwiXFxcXHBoYW50b21cIiwge1xuICAgIG51bUFyZ3M6IDFcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJwaGFudG9tXCIsXG4gICAgICAgIHZhbHVlOiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG59KTtcblxuLy8gTWF0aCBjbGFzcyBjb21tYW5kcyBleGNlcHQgXFxtYXRob3BcbmRlZmluZUZ1bmN0aW9uKFtcbiAgICBcIlxcXFxtYXRob3JkXCIsIFwiXFxcXG1hdGhiaW5cIiwgXCJcXFxcbWF0aHJlbFwiLCBcIlxcXFxtYXRob3BlblwiLFxuICAgIFwiXFxcXG1hdGhjbG9zZVwiLCBcIlxcXFxtYXRocHVuY3RcIiwgXCJcXFxcbWF0aGlubmVyXCJcbl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICAgIG1jbGFzczogXCJtXCIgKyBjb250ZXh0LmZ1bmNOYW1lLnN1YnN0cig1KSxcbiAgICAgICAgdmFsdWU6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbn0pO1xuXG4vLyBCdWlsZCBhIHJlbGF0aW9uIGJ5IHBsYWNpbmcgb25lIHN5bWJvbCBvbiB0b3Agb2YgYW5vdGhlclxuZGVmaW5lRnVuY3Rpb24oXCJcXFxcc3RhY2tyZWxcIiwge1xuICAgIG51bUFyZ3M6IDJcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgdG9wID0gYXJnc1swXTtcbiAgICB2YXIgYm90dG9tID0gYXJnc1sxXTtcblxuICAgIHZhciBib3R0b21vcCA9IG5ldyBQYXJzZU5vZGUoXCJvcFwiLCB7XG4gICAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgICBhbHdheXNIYW5kbGVTdXBTdWI6IHRydWUsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvcmRhcmd1bWVudChib3R0b20pXG4gICAgfSwgYm90dG9tLm1vZGUpO1xuXG4gICAgdmFyIHN1cHN1YiA9IG5ldyBQYXJzZU5vZGUoXCJzdXBzdWJcIiwge1xuICAgICAgICBiYXNlOiBib3R0b21vcCxcbiAgICAgICAgc3VwOiB0b3AsXG4gICAgICAgIHN1YjogbnVsbFxuICAgIH0sIHRvcC5tb2RlKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICAgIG1jbGFzczogXCJtcmVsXCIsXG4gICAgICAgIHZhbHVlOiBbc3Vwc3ViXVxuICAgIH07XG59KTtcblxuLy8gXFxtb2QtdHlwZSBmdW5jdGlvbnNcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXGJtb2RcIiwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm1vZFwiLFxuICAgICAgICBtb2RUeXBlOiBcImJtb2RcIixcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFtcIlxcXFxwb2RcIiwgXCJcXFxccG1vZFwiLCBcIlxcXFxtb2RcIl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibW9kXCIsXG4gICAgICAgIG1vZFR5cGU6IGNvbnRleHQuZnVuY05hbWUuc3Vic3RyKDEpLFxuICAgICAgICB2YWx1ZTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xufSk7XG5cbi8vIEV4dHJhIGRhdGEgbmVlZGVkIGZvciB0aGUgZGVsaW1pdGVyIGhhbmRsZXIgZG93biBiZWxvd1xudmFyIGRlbGltaXRlclNpemVzID0ge1xuICAgIFwiXFxcXGJpZ2xcIiA6IHttY2xhc3M6IFwibW9wZW5cIiwgICAgc2l6ZTogMX0sXG4gICAgXCJcXFxcQmlnbFwiIDoge21jbGFzczogXCJtb3BlblwiLCAgICBzaXplOiAyfSxcbiAgICBcIlxcXFxiaWdnbFwiOiB7bWNsYXNzOiBcIm1vcGVuXCIsICAgIHNpemU6IDN9LFxuICAgIFwiXFxcXEJpZ2dsXCI6IHttY2xhc3M6IFwibW9wZW5cIiwgICAgc2l6ZTogNH0sXG4gICAgXCJcXFxcYmlnclwiIDoge21jbGFzczogXCJtY2xvc2VcIiwgICBzaXplOiAxfSxcbiAgICBcIlxcXFxCaWdyXCIgOiB7bWNsYXNzOiBcIm1jbG9zZVwiLCAgIHNpemU6IDJ9LFxuICAgIFwiXFxcXGJpZ2dyXCI6IHttY2xhc3M6IFwibWNsb3NlXCIsICAgc2l6ZTogM30sXG4gICAgXCJcXFxcQmlnZ3JcIjoge21jbGFzczogXCJtY2xvc2VcIiwgICBzaXplOiA0fSxcbiAgICBcIlxcXFxiaWdtXCIgOiB7bWNsYXNzOiBcIm1yZWxcIiwgICAgIHNpemU6IDF9LFxuICAgIFwiXFxcXEJpZ21cIiA6IHttY2xhc3M6IFwibXJlbFwiLCAgICAgc2l6ZTogMn0sXG4gICAgXCJcXFxcYmlnZ21cIjoge21jbGFzczogXCJtcmVsXCIsICAgICBzaXplOiAzfSxcbiAgICBcIlxcXFxCaWdnbVwiOiB7bWNsYXNzOiBcIm1yZWxcIiwgICAgIHNpemU6IDR9LFxuICAgIFwiXFxcXGJpZ1wiICA6IHttY2xhc3M6IFwibW9yZFwiLCAgICAgc2l6ZTogMX0sXG4gICAgXCJcXFxcQmlnXCIgIDoge21jbGFzczogXCJtb3JkXCIsICAgICBzaXplOiAyfSxcbiAgICBcIlxcXFxiaWdnXCIgOiB7bWNsYXNzOiBcIm1vcmRcIiwgICAgIHNpemU6IDN9LFxuICAgIFwiXFxcXEJpZ2dcIiA6IHttY2xhc3M6IFwibW9yZFwiLCAgICAgc2l6ZTogNH1cbn07XG5cbnZhciBkZWxpbWl0ZXJzID0gW1xuICAgIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXFxcXGxicmFja1wiLCBcIl1cIiwgXCJcXFxccmJyYWNrXCIsXG4gICAgXCJcXFxce1wiLCBcIlxcXFxsYnJhY2VcIiwgXCJcXFxcfVwiLCBcIlxcXFxyYnJhY2VcIixcbiAgICBcIlxcXFxsZmxvb3JcIiwgXCJcXFxccmZsb29yXCIsIFwiXFxcXGxjZWlsXCIsIFwiXFxcXHJjZWlsXCIsXG4gICAgXCI8XCIsIFwiPlwiLCBcIlxcXFxsYW5nbGVcIiwgXCJcXFxccmFuZ2xlXCIsIFwiXFxcXGx0XCIsIFwiXFxcXGd0XCIsXG4gICAgXCJcXFxcbHZlcnRcIiwgXCJcXFxccnZlcnRcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIixcbiAgICBcIlxcXFxsZ3JvdXBcIiwgXCJcXFxccmdyb3VwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgXCJcXFxccm1vdXN0YWNoZVwiLFxuICAgIFwiL1wiLCBcIlxcXFxiYWNrc2xhc2hcIixcbiAgICBcInxcIiwgXCJcXFxcdmVydFwiLCBcIlxcXFx8XCIsIFwiXFxcXFZlcnRcIixcbiAgICBcIlxcXFx1cGFycm93XCIsIFwiXFxcXFVwYXJyb3dcIixcbiAgICBcIlxcXFxkb3duYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsXG4gICAgXCJcXFxcdXBkb3duYXJyb3dcIiwgXCJcXFxcVXBkb3duYXJyb3dcIixcbiAgICBcIi5cIlxuXTtcblxudmFyIGZvbnRBbGlhc2VzID0ge1xuICAgIFwiXFxcXEJiYlwiOiBcIlxcXFxtYXRoYmJcIixcbiAgICBcIlxcXFxib2xkXCI6IFwiXFxcXG1hdGhiZlwiLFxuICAgIFwiXFxcXGZyYWtcIjogXCJcXFxcbWF0aGZyYWtcIlxufTtcblxuLy8gU2luZ2xlLWFyZ3VtZW50IGNvbG9yIGZ1bmN0aW9uc1xuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGJsdWVcIiwgXCJcXFxcb3JhbmdlXCIsIFwiXFxcXHBpbmtcIiwgXCJcXFxccmVkXCIsXG4gICAgXCJcXFxcZ3JlZW5cIiwgXCJcXFxcZ3JheVwiLCBcIlxcXFxwdXJwbGVcIixcbiAgICBcIlxcXFxibHVlQVwiLCBcIlxcXFxibHVlQlwiLCBcIlxcXFxibHVlQ1wiLCBcIlxcXFxibHVlRFwiLCBcIlxcXFxibHVlRVwiLFxuICAgIFwiXFxcXHRlYWxBXCIsIFwiXFxcXHRlYWxCXCIsIFwiXFxcXHRlYWxDXCIsIFwiXFxcXHRlYWxEXCIsIFwiXFxcXHRlYWxFXCIsXG4gICAgXCJcXFxcZ3JlZW5BXCIsIFwiXFxcXGdyZWVuQlwiLCBcIlxcXFxncmVlbkNcIiwgXCJcXFxcZ3JlZW5EXCIsIFwiXFxcXGdyZWVuRVwiLFxuICAgIFwiXFxcXGdvbGRBXCIsIFwiXFxcXGdvbGRCXCIsIFwiXFxcXGdvbGRDXCIsIFwiXFxcXGdvbGREXCIsIFwiXFxcXGdvbGRFXCIsXG4gICAgXCJcXFxccmVkQVwiLCBcIlxcXFxyZWRCXCIsIFwiXFxcXHJlZENcIiwgXCJcXFxccmVkRFwiLCBcIlxcXFxyZWRFXCIsXG4gICAgXCJcXFxcbWFyb29uQVwiLCBcIlxcXFxtYXJvb25CXCIsIFwiXFxcXG1hcm9vbkNcIiwgXCJcXFxcbWFyb29uRFwiLCBcIlxcXFxtYXJvb25FXCIsXG4gICAgXCJcXFxccHVycGxlQVwiLCBcIlxcXFxwdXJwbGVCXCIsIFwiXFxcXHB1cnBsZUNcIiwgXCJcXFxccHVycGxlRFwiLCBcIlxcXFxwdXJwbGVFXCIsXG4gICAgXCJcXFxcbWludEFcIiwgXCJcXFxcbWludEJcIiwgXCJcXFxcbWludENcIixcbiAgICBcIlxcXFxncmF5QVwiLCBcIlxcXFxncmF5QlwiLCBcIlxcXFxncmF5Q1wiLCBcIlxcXFxncmF5RFwiLCBcIlxcXFxncmF5RVwiLFxuICAgIFwiXFxcXGdyYXlGXCIsIFwiXFxcXGdyYXlHXCIsIFwiXFxcXGdyYXlIXCIsIFwiXFxcXGdyYXlJXCIsXG4gICAgXCJcXFxca2FCbHVlXCIsIFwiXFxcXGthR3JlZW5cIlxuXSwge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBncmVlZGluZXNzOiAzXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgY29sb3I6IFwia2F0ZXgtXCIgKyBjb250ZXh0LmZ1bmNOYW1lLnNsaWNlKDEpLFxuICAgICAgICB2YWx1ZTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xufSk7XG5cbi8vIFRoZXJlIGFyZSAyIGZsYWdzIGZvciBvcGVyYXRvcnM7IHdoZXRoZXIgdGhleSBwcm9kdWNlIGxpbWl0cyBpblxuLy8gZGlzcGxheXN0eWxlLCBhbmQgd2hldGhlciB0aGV5IGFyZSBzeW1ib2xzIGFuZCBzaG91bGQgZ3JvdyBpblxuLy8gZGlzcGxheXN0eWxlLiBUaGVzZSBmb3VyIGdyb3VwcyBjb3ZlciB0aGUgZm91ciBwb3NzaWJsZSBjaG9pY2VzLlxuXG4vLyBObyBsaW1pdHMsIG5vdCBzeW1ib2xzXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcYXJjc2luXCIsIFwiXFxcXGFyY2Nvc1wiLCBcIlxcXFxhcmN0YW5cIiwgXCJcXFxcYXJnXCIsIFwiXFxcXGNvc1wiLCBcIlxcXFxjb3NoXCIsXG4gICAgXCJcXFxcY290XCIsIFwiXFxcXGNvdGhcIiwgXCJcXFxcY3NjXCIsIFwiXFxcXGRlZ1wiLCBcIlxcXFxkaW1cIiwgXCJcXFxcZXhwXCIsIFwiXFxcXGhvbVwiLFxuICAgIFwiXFxcXGtlclwiLCBcIlxcXFxsZ1wiLCBcIlxcXFxsblwiLCBcIlxcXFxsb2dcIiwgXCJcXFxcc2VjXCIsIFwiXFxcXHNpblwiLCBcIlxcXFxzaW5oXCIsXG4gICAgXCJcXFxcdGFuXCIsIFwiXFxcXHRhbmhcIlxuXSwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIGJvZHk6IGNvbnRleHQuZnVuY05hbWVcbiAgICB9O1xufSk7XG5cbi8vIExpbWl0cywgbm90IHN5bWJvbHNcbmRlZmluZUZ1bmN0aW9uKFtcbiAgICBcIlxcXFxkZXRcIiwgXCJcXFxcZ2NkXCIsIFwiXFxcXGluZlwiLCBcIlxcXFxsaW1cIiwgXCJcXFxcbGltaW5mXCIsIFwiXFxcXGxpbXN1cFwiLCBcIlxcXFxtYXhcIixcbiAgICBcIlxcXFxtaW5cIiwgXCJcXFxcUHJcIiwgXCJcXFxcc3VwXCJcbl0sIHtcbiAgICBudW1BcmdzOiAwXG59LCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgICBsaW1pdHM6IHRydWUsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIGJvZHk6IGNvbnRleHQuZnVuY05hbWVcbiAgICB9O1xufSk7XG5cbi8vIE5vIGxpbWl0cywgc3ltYm9sc1xuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGludFwiLCBcIlxcXFxpaW50XCIsIFwiXFxcXGlpaW50XCIsIFwiXFxcXG9pbnRcIlxuXSwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICAgIHN5bWJvbDogdHJ1ZSxcbiAgICAgICAgYm9keTogY29udGV4dC5mdW5jTmFtZVxuICAgIH07XG59KTtcblxuLy8gTGltaXRzLCBzeW1ib2xzXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcY29wcm9kXCIsIFwiXFxcXGJpZ3ZlZVwiLCBcIlxcXFxiaWd3ZWRnZVwiLCBcIlxcXFxiaWd1cGx1c1wiLCBcIlxcXFxiaWdjYXBcIixcbiAgICBcIlxcXFxiaWdjdXBcIiwgXCJcXFxcaW50b3BcIiwgXCJcXFxccHJvZFwiLCBcIlxcXFxzdW1cIiwgXCJcXFxcYmlnb3RpbWVzXCIsXG4gICAgXCJcXFxcYmlnb3BsdXNcIiwgXCJcXFxcYmlnb2RvdFwiLCBcIlxcXFxiaWdzcWN1cFwiLCBcIlxcXFxzbWFsbGludFwiXG5dLCB7XG4gICAgbnVtQXJnczogMFxufSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgICBzeW1ib2w6IHRydWUsXG4gICAgICAgIGJvZHk6IGNvbnRleHQuZnVuY05hbWVcbiAgICB9O1xufSk7XG5cbi8vIFxcbWF0aG9wIGNsYXNzIGNvbW1hbmRcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXG1hdGhvcFwiLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG59KTtcblxuLy8gRnJhY3Rpb25zXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcZGZyYWNcIiwgXCJcXFxcZnJhY1wiLCBcIlxcXFx0ZnJhY1wiLFxuICAgIFwiXFxcXGRiaW5vbVwiLCBcIlxcXFxiaW5vbVwiLCBcIlxcXFx0Ymlub21cIixcbiAgICBcIlxcXFxcXFxcYXRvcGZyYWNcIiAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbl0sIHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGdyZWVkaW5lc3M6IDJcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgbnVtZXIgPSBhcmdzWzBdO1xuICAgIHZhciBkZW5vbSA9IGFyZ3NbMV07XG4gICAgdmFyIGhhc0JhckxpbmU7XG4gICAgdmFyIGxlZnREZWxpbSA9IG51bGw7XG4gICAgdmFyIHJpZ2h0RGVsaW0gPSBudWxsO1xuICAgIHZhciBzaXplID0gXCJhdXRvXCI7XG5cbiAgICBzd2l0Y2ggKGNvbnRleHQuZnVuY05hbWUpIHtcbiAgICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgICBjYXNlIFwiXFxcXGZyYWNcIjpcbiAgICAgICAgY2FzZSBcIlxcXFx0ZnJhY1wiOlxuICAgICAgICAgICAgaGFzQmFyTGluZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlxcXFxcXFxcYXRvcGZyYWNcIjpcbiAgICAgICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgICBjYXNlIFwiXFxcXGJpbm9tXCI6XG4gICAgICAgIGNhc2UgXCJcXFxcdGJpbm9tXCI6XG4gICAgICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBsZWZ0RGVsaW0gPSBcIihcIjtcbiAgICAgICAgICAgIHJpZ2h0RGVsaW0gPSBcIilcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGdlbmZyYWMgY29tbWFuZFwiKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNvbnRleHQuZnVuY05hbWUpIHtcbiAgICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgICAgICAgc2l6ZSA9IFwiZGlzcGxheVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJcXFxcdGZyYWNcIjpcbiAgICAgICAgY2FzZSBcIlxcXFx0Ymlub21cIjpcbiAgICAgICAgICAgIHNpemUgPSBcInRleHRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgICBudW1lcjogbnVtZXIsXG4gICAgICAgIGRlbm9tOiBkZW5vbSxcbiAgICAgICAgaGFzQmFyTGluZTogaGFzQmFyTGluZSxcbiAgICAgICAgbGVmdERlbGltOiBsZWZ0RGVsaW0sXG4gICAgICAgIHJpZ2h0RGVsaW06IHJpZ2h0RGVsaW0sXG4gICAgICAgIHNpemU6IHNpemVcbiAgICB9O1xufSk7XG5cbi8vIExlZnQgYW5kIHJpZ2h0IG92ZXJsYXAgZnVuY3Rpb25zXG5kZWZpbmVGdW5jdGlvbihbXCJcXFxcbGxhcFwiLCBcIlxcXFxybGFwXCJdLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGNvbnRleHQuZnVuY05hbWUuc2xpY2UoMSksXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xufSk7XG5cbi8vIERlbGltaXRlciBmdW5jdGlvbnNcbnZhciBjaGVja0RlbGltaXRlciA9IGZ1bmN0aW9uKGRlbGltLCBjb250ZXh0KSB7XG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKGRlbGltaXRlcnMsIGRlbGltLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZGVsaW07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgZGVsaW1pdGVyOiAnXCIgKyBkZWxpbS52YWx1ZSArIFwiJyBhZnRlciAnXCIgK1xuICAgICAgICAgICAgY29udGV4dC5mdW5jTmFtZSArIFwiJ1wiLCBkZWxpbSk7XG4gICAgfVxufTtcblxuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGJpZ2xcIiwgXCJcXFxcQmlnbFwiLCBcIlxcXFxiaWdnbFwiLCBcIlxcXFxCaWdnbFwiLFxuICAgIFwiXFxcXGJpZ3JcIiwgXCJcXFxcQmlnclwiLCBcIlxcXFxiaWdnclwiLCBcIlxcXFxCaWdnclwiLFxuICAgIFwiXFxcXGJpZ21cIiwgXCJcXFxcQmlnbVwiLCBcIlxcXFxiaWdnbVwiLCBcIlxcXFxCaWdnbVwiLFxuICAgIFwiXFxcXGJpZ1wiLCAgXCJcXFxcQmlnXCIsICBcIlxcXFxiaWdnXCIsICBcIlxcXFxCaWdnXCJcbl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImRlbGltc2l6aW5nXCIsXG4gICAgICAgIHNpemU6IGRlbGltaXRlclNpemVzW2NvbnRleHQuZnVuY05hbWVdLnNpemUsXG4gICAgICAgIG1jbGFzczogZGVsaW1pdGVyU2l6ZXNbY29udGV4dC5mdW5jTmFtZV0ubWNsYXNzLFxuICAgICAgICB2YWx1ZTogZGVsaW0udmFsdWVcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFtcbiAgICBcIlxcXFxsZWZ0XCIsIFwiXFxcXHJpZ2h0XCJcbl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICAvLyBcXGxlZnQgYW5kIFxccmlnaHQgYXJlIGNhdWdodCBzb21ld2hlcmUgaW4gUGFyc2VyLmpzLCB3aGljaCBpc1xuICAgIC8vIHdoeSB0aGlzIGRhdGEgZG9lc24ndCBtYXRjaCB3aGF0IGlzIGluIGJ1aWxkSFRNTC5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgICB2YWx1ZTogZGVsaW0udmFsdWVcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFwiXFxcXG1pZGRsZVwiLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuICAgIGlmICghY29udGV4dC5wYXJzZXIubGVmdHJpZ2h0RGVwdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcbWlkZGxlIHdpdGhvdXQgcHJlY2VkaW5nIFxcXFxsZWZ0XCIsIGRlbGltKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm1pZGRsZVwiLFxuICAgICAgICB2YWx1ZTogZGVsaW0udmFsdWVcbiAgICB9O1xufSk7XG5cbi8vIFNpemluZyBmdW5jdGlvbnMgKGhhbmRsZWQgaW4gUGFyc2VyLmpzIGV4cGxpY2l0bHksIGhlbmNlIG5vIGhhbmRsZXIpXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcdGlueVwiLCBcIlxcXFxzY3JpcHRzaXplXCIsIFwiXFxcXGZvb3Rub3Rlc2l6ZVwiLCBcIlxcXFxzbWFsbFwiLFxuICAgIFwiXFxcXG5vcm1hbHNpemVcIiwgXCJcXFxcbGFyZ2VcIiwgXCJcXFxcTGFyZ2VcIiwgXCJcXFxcTEFSR0VcIiwgXCJcXFxcaHVnZVwiLCBcIlxcXFxIdWdlXCJcbl0sIDAsIG51bGwpO1xuXG4vLyBTdHlsZSBjaGFuZ2luZyBmdW5jdGlvbnMgKGhhbmRsZWQgaW4gUGFyc2VyLmpzIGV4cGxpY2l0bHksIGhlbmNlIG5vXG4vLyBoYW5kbGVyKVxuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGRpc3BsYXlzdHlsZVwiLCBcIlxcXFx0ZXh0c3R5bGVcIiwgXCJcXFxcc2NyaXB0c3R5bGVcIixcbiAgICBcIlxcXFxzY3JpcHRzY3JpcHRzdHlsZVwiXG5dLCAwLCBudWxsKTtcblxuZGVmaW5lRnVuY3Rpb24oW1xuICAgIC8vIHN0eWxlc1xuICAgIFwiXFxcXG1hdGhybVwiLCBcIlxcXFxtYXRoaXRcIiwgXCJcXFxcbWF0aGJmXCIsXG5cbiAgICAvLyBmYW1pbGllc1xuICAgIFwiXFxcXG1hdGhiYlwiLCBcIlxcXFxtYXRoY2FsXCIsIFwiXFxcXG1hdGhmcmFrXCIsIFwiXFxcXG1hdGhzY3JcIiwgXCJcXFxcbWF0aHNmXCIsXG4gICAgXCJcXFxcbWF0aHR0XCIsXG5cbiAgICAvLyBhbGlhc2VzXG4gICAgXCJcXFxcQmJiXCIsIFwiXFxcXGJvbGRcIiwgXCJcXFxcZnJha1wiXG5dLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBncmVlZGluZXNzOiAyXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHZhciBmdW5jID0gY29udGV4dC5mdW5jTmFtZTtcbiAgICBpZiAoZnVuYyBpbiBmb250QWxpYXNlcykge1xuICAgICAgICBmdW5jID0gZm9udEFsaWFzZXNbZnVuY107XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgICBmb250OiBmdW5jLnNsaWNlKDEpLFxuICAgICAgICBib2R5OiBib2R5XG4gICAgfTtcbn0pO1xuXG4vLyBBY2NlbnRzXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcYWN1dGVcIiwgXCJcXFxcZ3JhdmVcIiwgXCJcXFxcZGRvdFwiLCBcIlxcXFx0aWxkZVwiLCBcIlxcXFxiYXJcIiwgXCJcXFxcYnJldmVcIixcbiAgICBcIlxcXFxjaGVja1wiLCBcIlxcXFxoYXRcIiwgXCJcXFxcdmVjXCIsIFwiXFxcXGRvdFwiXG4gICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBleHBhbmRpbmcgYWNjZW50cyB5ZXRcbiAgICAvLyBcIlxcXFx3aWRldGlsZGVcIiwgXCJcXFxcd2lkZWhhdFwiXG5dLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBiYXNlID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImFjY2VudFwiLFxuICAgICAgICBhY2NlbnQ6IGNvbnRleHQuZnVuY05hbWUsXG4gICAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xufSk7XG5cbi8vIEluZml4IGdlbmVyYWxpemVkIGZyYWN0aW9uc1xuZGVmaW5lRnVuY3Rpb24oW1wiXFxcXG92ZXJcIiwgXCJcXFxcY2hvb3NlXCIsIFwiXFxcXGF0b3BcIl0sIHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGluZml4OiB0cnVlXG59LCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIHJlcGxhY2VXaXRoO1xuICAgIHN3aXRjaCAoY29udGV4dC5mdW5jTmFtZSkge1xuICAgICAgICBjYXNlIFwiXFxcXG92ZXJcIjpcbiAgICAgICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcZnJhY1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJcXFxcY2hvb3NlXCI6XG4gICAgICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGJpbm9tXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlxcXFxhdG9wXCI6XG4gICAgICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxhdG9wZnJhY1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgaW5maXggZ2VuZnJhYyBjb21tYW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImluZml4XCIsXG4gICAgICAgIHJlcGxhY2VXaXRoOiByZXBsYWNlV2l0aCxcbiAgICAgICAgdG9rZW46IGNvbnRleHQudG9rZW5cbiAgICB9O1xufSk7XG5cbi8vIFJvdyBicmVha3MgZm9yIGFsaWduZWQgZGF0YVxuZGVmaW5lRnVuY3Rpb24oW1wiXFxcXFxcXFxcIiwgXCJcXFxcY3JcIl0sIHtcbiAgICBudW1BcmdzOiAwLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBzaXplID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImNyXCIsXG4gICAgICAgIHNpemU6IHNpemVcbiAgICB9O1xufSk7XG5cbi8vIEVudmlyb25tZW50IGRlbGltaXRlcnNcbmRlZmluZUZ1bmN0aW9uKFtcIlxcXFxiZWdpblwiLCBcIlxcXFxlbmRcIl0sIHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ0ZXh0XCJdXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIG5hbWVHcm91cCA9IGFyZ3NbMF07XG4gICAgaWYgKG5hbWVHcm91cC50eXBlICE9PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGVudmlyb25tZW50IG5hbWVcIiwgbmFtZUdyb3VwKTtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZUdyb3VwLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG5hbWUgKz0gbmFtZUdyb3VwLnZhbHVlW2ldLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImVudmlyb25tZW50XCIsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIG5hbWVHcm91cDogbmFtZUdyb3VwXG4gICAgfTtcbn0pO1xuIiwiLyoqXG4gKiBUaGVzZSBvYmplY3RzIHN0b3JlIGRhdGEgYWJvdXQgTWF0aE1MIG5vZGVzLiBUaGlzIGlzIHRoZSBNYXRoTUwgZXF1aXZhbGVudFxuICogb2YgdGhlIHR5cGVzIGluIGRvbVRyZWUuanMuIFNpbmNlIE1hdGhNTCBoYW5kbGVzIGl0cyBvd24gcmVuZGVyaW5nLCBhbmRcbiAqIHNpbmNlIHdlJ3JlIG1haW5seSB1c2luZyBNYXRoTUwgdG8gaW1wcm92ZSBhY2Nlc3NpYmlsaXR5LCB3ZSBkb24ndCBtYW5hZ2VcbiAqIGFueSBvZiB0aGUgc3R5bGluZyBzdGF0ZSB0aGF0IHRoZSBwbGFpbiBET00gbm9kZXMgZG8uXG4gKlxuICogVGhlIGB0b05vZGVgIGFuZCBgdG9NYXJrdXBgIGZ1bmN0aW9ucyB3b3JrIHNpbWxhcmx5IHRvIGhvdyB0aGV5IGRvIGluXG4gKiBkb21UcmVlLmpzLCBjcmVhdGluZyBuYW1lc3BhY2VkIERPTSBub2RlcyBhbmQgSFRNTCB0ZXh0IG1hcmt1cCByZXNwZWN0aXZlbHkuXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBnZW5lcmFsIHB1cnBvc2UgTWF0aE1MIG5vZGUgb2YgYW55IHR5cGUuIFRoZVxuICogY29uc3RydWN0b3IgcmVxdWlyZXMgdGhlIHR5cGUgb2Ygbm9kZSB0byBjcmVhdGUgKGZvciBleGFtcGxlLCBgXCJtb1wiYCBvclxuICogYFwibXNwYWNlXCJgLCBjb3JyZXNwb25kaW5nIHRvIGA8bW8+YCBhbmQgYDxtc3BhY2U+YCB0YWdzKS5cbiAqL1xuZnVuY3Rpb24gTWF0aE5vZGUodHlwZSwgY2hpbGRyZW4pIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbn1cblxuLyoqXG4gKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiBhIE1hdGhNTCBub2RlLiBNYXRoTUwgZGVwZW5kcyBvbiBhdHRyaWJ1dGVzIHRvIGNvbnZleSBhXG4gKiBzZW1hbnRpYyBjb250ZW50LCBzbyB0aGlzIGlzIHVzZWQgaGVhdmlseS5cbiAqL1xuTWF0aE5vZGUucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIE1hdGhNTC1uYW1lc3BhY2VkIERPTSBlbGVtZW50LlxuICovXG5NYXRoTm9kZS5wcm90b3R5cGUudG9Ob2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCB0aGlzLnR5cGUpO1xuXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuXG4gKi9cbk1hdGhOb2RlLnByb3RvdHlwZS50b01hcmt1cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIjxcIiArIHRoaXMudHlwZTtcblxuICAgIC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArIFwiPVxcXCJcIjtcbiAgICAgICAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgICAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIj5cIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIjwvXCIgKyB0aGlzLnR5cGUgKyBcIj5cIjtcblxuICAgIHJldHVybiBtYXJrdXA7XG59O1xuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgcGllY2Ugb2YgdGV4dC5cbiAqL1xuZnVuY3Rpb24gVGV4dE5vZGUodGV4dCkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHRleHQgbm9kZSBpbnRvIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuVGV4dE5vZGUucHJvdG90eXBlLnRvTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gSFRNTCBtYXJrdXAgKHdoaWNoIGlzIGp1c3QgdGhlIHRleHQgaXRzZWxmKS5cbiAqL1xuVGV4dE5vZGUucHJvdG90eXBlLnRvTWFya3VwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVzY2FwZSh0aGlzLnRleHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWF0aE5vZGU6IE1hdGhOb2RlLFxuICAgIFRleHROb2RlOiBUZXh0Tm9kZVxufTtcbiIsIi8qKlxuICogVGhlIHJlc3VsdGluZyBwYXJzZSB0cmVlIG5vZGVzIG9mIHRoZSBwYXJzZSB0cmVlLlxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHByb3ZpZGUgcG9zaXRpb24gaW5mb3JtYXRpb24sIHNvIHRoYXQgYSBQYXJzZU5vZGUgY2FuXG4gKiBmdWxmaWwgYSByb2xlIHNpbWlsYXIgdG8gYSBUb2tlbiBpbiBlcnJvciByZXBvcnRpbmcuXG4gKiBGb3IgZGV0YWlscyBvbiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIHNlZSBUb2tlbiBjb25zdHJ1Y3Rvci5cbiAqIFByb3ZpZGluZyBzdWNoIGluZm9ybWF0aW9uIGNhbiBsZWFkIHRvIGJldHRlciBlcnJvciByZXBvcnRpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICB0eXBlICAgICAgIHR5cGUgb2Ygbm9kZSwgbGlrZSBlLmcuIFwib3JkZ3JvdXBcIlxuICogQHBhcmFtIHs/b2JqZWN0fSB2YWx1ZSAgICAgIHR5cGUtc3BlY2lmaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSAgbW9kZSAgICAgICBwYXJzZSBtb2RlIGluIGFjdGlvbiBmb3IgdGhpcyBub2RlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF0aFwiIG9yIFwidGV4dFwiXG4gKiBAcGFyYW0ge1Rva2VuPX0gZmlyc3RUb2tlbiAgZmlyc3QgdG9rZW4gb2YgdGhlIGlucHV0IGZvciB0aGlzIG5vZGUsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBvbWl0IHBvc2l0aW9uIGluZm9ybWF0aW9uIGlmIHVuc2V0XG4gKiBAcGFyYW0ge1Rva2VuPX0gbGFzdFRva2VuICAgbGFzdCB0b2tlbiBvZiB0aGUgaW5wdXQgZm9yIHRoaXMgbm9kZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGRlZmF1bHQgdG8gZmlyc3RUb2tlbiBpZiB1bnNldFxuICovXG5mdW5jdGlvbiBQYXJzZU5vZGUodHlwZSwgdmFsdWUsIG1vZGUsIGZpcnN0VG9rZW4sIGxhc3RUb2tlbikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgaWYgKGZpcnN0VG9rZW4gJiYgKCFsYXN0VG9rZW4gfHwgbGFzdFRva2VuLmxleGVyID09PSBmaXJzdFRva2VuLmxleGVyKSkge1xuICAgICAgICB0aGlzLmxleGVyID0gZmlyc3RUb2tlbi5sZXhlcjtcbiAgICAgICAgdGhpcy5zdGFydCA9IGZpcnN0VG9rZW4uc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gKGxhc3RUb2tlbiB8fCBmaXJzdFRva2VuKS5lbmQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQYXJzZU5vZGU6IFBhcnNlTm9kZVxufTtcblxuIiwiLyoqXG4gKiBQcm92aWRlcyBhIHNpbmdsZSBmdW5jdGlvbiBmb3IgcGFyc2luZyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyXG4gKiBUT0RPKGVtaWx5KTogUmVtb3ZlIHRoaXNcbiAqL1xuXG52YXIgUGFyc2VyID0gcmVxdWlyZShcIi4vUGFyc2VyXCIpO1xuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyLCB0aGVuIHJldHVybnMgdGhlIHBhcnNlZCByZXN1bHQuXG4gKi9cbnZhciBwYXJzZVRyZWUgPSBmdW5jdGlvbih0b1BhcnNlLCBzZXR0aW5ncykge1xuICAgIGlmICghKHR5cGVvZiB0b1BhcnNlID09PSAnc3RyaW5nJyB8fCB0b1BhcnNlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdLYVRlWCBjYW4gb25seSBwYXJzZSBzdHJpbmcgdHlwZWQgZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcih0b1BhcnNlLCBzZXR0aW5ncyk7XG5cbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlVHJlZTtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGhvbGRzIGEgbGlzdCBvZiBhbGwgbm8tYXJndW1lbnQgZnVuY3Rpb25zIGFuZCBzaW5nbGUtY2hhcmFjdGVyXG4gKiBzeW1ib2xzIChsaWtlICdhJyBvciAnOycpLlxuICpcbiAqIEZvciBlYWNoIG9mIHRoZSBzeW1ib2xzLCB0aGVyZSBhcmUgdGhyZWUgcHJvcGVydGllcyB0aGV5IGNhbiBoYXZlOlxuICogLSBmb250IChyZXF1aXJlZCk6IHRoZSBmb250IHRvIGJlIHVzZWQgZm9yIHRoaXMgc3ltYm9sLiBFaXRoZXIgXCJtYWluXCIgKHRoZVxuICAgICBub3JtYWwgZm9udCksIG9yIFwiYW1zXCIgKHRoZSBhbXMgZm9udHMpLlxuICogLSBncm91cCAocmVxdWlyZWQpOiB0aGUgUGFyc2VOb2RlIGdyb3VwIHR5cGUgdGhlIHN5bWJvbCBzaG91bGQgaGF2ZSAoaS5lLlxuICAgICBcInRleHRvcmRcIiwgXCJtYXRob3JkXCIsIGV0YykuXG4gICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vS2hhbi9LYVRlWC93aWtpL0V4YW1pbmluZy1UZVgjZ3JvdXAtdHlwZXNcbiAqIC0gcmVwbGFjZTogdGhlIGNoYXJhY3RlciB0aGF0IHRoaXMgc3ltYm9sIG9yIGZ1bmN0aW9uIHNob3VsZCBiZVxuICogICByZXBsYWNlZCB3aXRoIChpLmUuIFwiXFxwaGlcIiBoYXMgYSByZXBsYWNlIHZhbHVlIG9mIFwiXFx1MDNkNVwiLCB0aGUgcGhpXG4gKiAgIGNoYXJhY3RlciBpbiB0aGUgbWFpbiBmb250KS5cbiAqXG4gKiBUaGUgb3V0ZXJtb3N0IG1hcCBpbiB0aGUgdGFibGUgaW5kaWNhdGVzIHdoYXQgbW9kZSB0aGUgc3ltYm9scyBzaG91bGQgYmVcbiAqIGFjY2VwdGVkIGluIChlLmcuIFwibWF0aFwiIG9yIFwidGV4dFwiKS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYXRoOiB7fSxcbiAgICB0ZXh0OiB7fVxufTtcblxuZnVuY3Rpb24gZGVmaW5lU3ltYm9sKG1vZGUsIGZvbnQsIGdyb3VwLCByZXBsYWNlLCBuYW1lKSB7XG4gICAgbW9kdWxlLmV4cG9ydHNbbW9kZV1bbmFtZV0gPSB7XG4gICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgIGdyb3VwOiBncm91cCxcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZVxuICAgIH07XG59XG5cbi8vIFNvbWUgYWJicmV2aWF0aW9ucyBmb3IgY29tbW9ubHkgdXNlZCBzdHJpbmdzLlxuLy8gVGhpcyBoZWxwcyBtaW5pZnkgdGhlIGNvZGUsIGFuZCBhbHNvIHNwb3R0aW5nIHR5cG9zIHVzaW5nIGpzaGludC5cblxuLy8gbW9kZXM6XG52YXIgbWF0aCA9IFwibWF0aFwiO1xudmFyIHRleHQgPSBcInRleHRcIjtcblxuLy8gZm9udHM6XG52YXIgbWFpbiA9IFwibWFpblwiO1xudmFyIGFtcyA9IFwiYW1zXCI7XG5cbi8vIGdyb3VwczpcbnZhciBhY2NlbnQgPSBcImFjY2VudFwiO1xudmFyIGJpbiA9IFwiYmluXCI7XG52YXIgY2xvc2UgPSBcImNsb3NlXCI7XG52YXIgaW5uZXIgPSBcImlubmVyXCI7XG52YXIgbWF0aG9yZCA9IFwibWF0aG9yZFwiO1xudmFyIG9wID0gXCJvcFwiO1xudmFyIG9wZW4gPSBcIm9wZW5cIjtcbnZhciBwdW5jdCA9IFwicHVuY3RcIjtcbnZhciByZWwgPSBcInJlbFwiO1xudmFyIHNwYWNpbmcgPSBcInNwYWNpbmdcIjtcbnZhciB0ZXh0b3JkID0gXCJ0ZXh0b3JkXCI7XG5cbi8vIE5vdyBjb21lcyB0aGUgc3ltYm9sIHRhYmxlXG5cbi8vIFJlbGF0aW9uIFN5bWJvbHNcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2MVwiLCBcIlxcXFxlcXVpdlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI3YVwiLCBcIlxcXFxwcmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjdiXCIsIFwiXFxcXHN1Y2NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyM2NcIiwgXCJcXFxcc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmE1XCIsIFwiXFxcXHBlcnBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTJhYWZcIiwgXCJcXFxccHJlY2VxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyYWIwXCIsIFwiXFxcXHN1Y2NlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0M1wiLCBcIlxcXFxzaW1lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNmFcIiwgXCJcXFxcbGxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNmJcIiwgXCJcXFxcZ2dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNGRcIiwgXCJcXFxcYXN5bXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMjVcIiwgXCJcXFxccGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYzhcIiwgXCJcXFxcYm93dGllXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMzIzXCIsIFwiXFxcXHNtaWxlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjkxXCIsIFwiXFxcXHNxc3Vic2V0ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyOTJcIiwgXCJcXFxcc3FzdXBzZXRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI1MFwiLCBcIlxcXFxkb3RlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjMyMlwiLCBcIlxcXFxmcm93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwYlwiLCBcIlxcXFxuaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIxZFwiLCBcIlxcXFxwcm9wdG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYTJcIiwgXCJcXFxcdmRhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYTNcIiwgXCJcXFxcZGFzaHZcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMGJcIiwgXCJcXFxcb3duc1wiKTtcblxuLy8gUHVuY3R1YXRpb25cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBwdW5jdCwgXCJcXHUwMDJlXCIsIFwiXFxcXGxkb3RwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHB1bmN0LCBcIlxcdTIyYzVcIiwgXCJcXFxcY2RvdHBcIik7XG5cbi8vIE1pc2MgU3ltYm9sc1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyM1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyM1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEzNVwiLCBcIlxcXFxhbGVwaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMDBcIiwgXCJcXFxcZm9yYWxsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEwZlwiLCBcIlxcXFxoYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwM1wiLCBcIlxcXFxleGlzdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjA3XCIsIFwiXFxcXG5hYmxhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjY2ZFwiLCBcIlxcXFxmbGF0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExM1wiLCBcIlxcXFxlbGxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjZlXCIsIFwiXFxcXG5hdHVyYWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYzXCIsIFwiXFxcXGNsdWJzdWl0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExOFwiLCBcIlxcXFx3cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NmZcIiwgXCJcXFxcc2hhcnBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYyXCIsIFwiXFxcXGRpYW1vbmRzdWl0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExY1wiLCBcIlxcXFxSZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjFcIiwgXCJcXFxcaGVhcnRzdWl0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExMVwiLCBcIlxcXFxJbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjBcIiwgXCJcXFxcc3BhZGVzdWl0XCIpO1xuXG4vLyBNYXRoIGFuZCBUZXh0XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMjFcIiwgXCJcXFxcZGRhZ1wiKTtcblxuLy8gTGFyZ2UgRGVsaW1pdGVyc1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTIzYjFcIiwgXCJcXFxccm1vdXN0YWNoZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIzYjBcIiwgXCJcXFxcbG1vdXN0YWNoZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyN2VmXCIsIFwiXFxcXHJncm91cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTI3ZWVcIiwgXCJcXFxcbGdyb3VwXCIpO1xuXG4vLyBCaW5hcnkgT3BlcmF0b3JzXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTNcIiwgXCJcXFxcbXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTZcIiwgXCJcXFxcb21pbnVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjhlXCIsIFwiXFxcXHVwbHVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjkzXCIsIFwiXFxcXHNxY2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE3XCIsIFwiXFxcXGFzdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5NFwiLCBcIlxcXFxzcWN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjVlZlwiLCBcIlxcXFxiaWdjaXJjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE5XCIsIFwiXFxcXGJ1bGxldFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnZ2VyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjQwXCIsIFwiXFxcXHdyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyYTNmXCIsIFwiXFxcXGFtYWxnXCIpO1xuXG4vLyBBcnJvdyBTeW1ib2xzXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjVcIiwgXCJcXFxcbG9uZ2xlZnRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMFwiLCBcIlxcXFxMZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjhcIiwgXCJcXFxcTG9uZ2xlZnRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmNlwiLCBcIlxcXFxsb25ncmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMlwiLCBcIlxcXFxSaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y5XCIsIFwiXFxcXExvbmdyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk0XCIsIFwiXFxcXGxlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y3XCIsIFwiXFxcXGxvbmdsZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkNFwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmYVwiLCBcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYTZcIiwgXCJcXFxcbWFwc3RvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2ZjXCIsIFwiXFxcXGxvbmdtYXBzdG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTdcIiwgXCJcXFxcbmVhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFhOVwiLCBcIlxcXFxob29rbGVmdGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWFhXCIsIFwiXFxcXGhvb2tyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk4XCIsIFwiXFxcXHNlYXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYmNcIiwgXCJcXFxcbGVmdGhhcnBvb251cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFjMFwiLCBcIlxcXFxyaWdodGhhcnBvb251cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5OVwiLCBcIlxcXFxzd2Fycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWJkXCIsIFwiXFxcXGxlZnRoYXJwb29uZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFjMVwiLCBcIlxcXFxyaWdodGhhcnBvb25kb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk2XCIsIFwiXFxcXG53YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxY2NcIiwgXCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIik7XG5cbi8vIEFNUyBOZWdhdGVkIEJpbmFyeSBSZWxhdGlvbnNcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZlXCIsIFwiXFxcXG5sZXNzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTBcIiwgXCJcXFxcbmxlcXNsYW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTFcIiwgXCJcXFxcbmxlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4N1wiLCBcIlxcXFxsbmVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNjhcIiwgXCJcXFxcbG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAwY1wiLCBcIlxcXFxsdmVydG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlNlwiLCBcIlxcXFxsbnNpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTg5XCIsIFwiXFxcXGxuYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODBcIiwgXCJcXFxcbnByZWNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlMFwiLCBcIlxcXFxucHJlY2VxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZThcIiwgXCJcXFxccHJlY25zaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiOVwiLCBcIlxcXFxwcmVjbmFwcHJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQxXCIsIFwiXFxcXG5zaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAwNlwiLCBcIlxcXFxuc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyNFwiLCBcIlxcXFxubWlkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWNcIiwgXCJcXFxcbnZkYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWRcIiwgXCJcXFxcbnZEYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWFcIiwgXCJcXFxcbnRyaWFuZ2xlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmVjXCIsIFwiXFxcXG50cmlhbmdsZWxlZnRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhhXCIsIFwiXFxcXHN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDFhXCIsIFwiXFxcXHZhcnN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNiXCIsIFwiXFxcXHN1YnNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxN1wiLCBcIlxcXFx2YXJzdWJzZXRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNmZcIiwgXCJcXFxcbmd0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDBmXCIsIFwiXFxcXG5nZXFzbGFudFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDBlXCIsIFwiXFxcXG5nZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODhcIiwgXCJcXFxcZ25lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjY5XCIsIFwiXFxcXGduZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGRcIiwgXCJcXFxcZ3ZlcnRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTdcIiwgXCJcXFxcZ25zaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4YVwiLCBcIlxcXFxnbmFwcHJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjgxXCIsIFwiXFxcXG5zdWNjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTFcIiwgXCJcXFxcbnN1Y2NlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU5XCIsIFwiXFxcXHN1Y2Nuc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYmFcIiwgXCJcXFxcc3VjY25hcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0NlwiLCBcIlxcXFxuY29uZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDA3XCIsIFwiXFxcXG5zaG9ydHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMjZcIiwgXCJcXFxcbnBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWZcIiwgXCJcXFxcblZEYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWJcIiwgXCJcXFxcbnRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlZFwiLCBcIlxcXFxudHJpYW5nbGVyaWdodGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMThcIiwgXCJcXFxcbnN1cHNldGVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhiXCIsIFwiXFxcXHN1cHNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDFiXCIsIFwiXFxcXHZhcnN1cHNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNjXCIsIFwiXFxcXHN1cHNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxOVwiLCBcIlxcXFx2YXJzdXBzZXRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWVcIiwgXCJcXFxcblZkYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYjVcIiwgXCJcXFxccHJlY25lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiNlwiLCBcIlxcXFxzdWNjbmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDE2XCIsIFwiXFxcXG5zdWJzZXRlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiNFwiLCBcIlxcXFx1bmxoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmI1XCIsIFwiXFxcXHVucmhkXCIpO1xuXG4vLyBBTVMgTmVnYXRlZCBBcnJvd3NcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMTlhXCIsIFwiXFxcXG5sZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5YlwiLCBcIlxcXFxucmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWNkXCIsIFwiXFxcXG5MZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjZlwiLCBcIlxcXFxuUmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFlXCIsIFwiXFxcXG5sZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWNlXCIsIFwiXFxcXG5MZWZ0cmlnaHRhcnJvd1wiKTtcblxuLy8gQU1TIE1pc2NcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWIzXCIsIFwiXFxcXHZhcnRyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTBmXCIsIFwiXFxcXGhzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViZFwiLCBcIlxcXFx0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1Y2FcIiwgXCJcXFxcbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjRjOFwiLCBcIlxcXFxjaXJjbGVkU1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhZVwiLCBcIlxcXFxjaXJjbGVkUlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjIyMVwiLCBcIlxcXFxtZWFzdXJlZGFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjA0XCIsIFwiXFxcXG5leGlzdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMjdcIiwgXCJcXFxcbWhvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTMyXCIsIFwiXFxcXEZpbnZcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxNDFcIiwgXCJcXFxcR2FtZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDA2YlwiLCBcIlxcXFxCYmJrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMDM1XCIsIFwiXFxcXGJhY2twcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViMlwiLCBcIlxcXFxibGFja3RyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWJjXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWEwXCIsIFwiXFxcXGJsYWNrc3F1YXJlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyOWViXCIsIFwiXFxcXGJsYWNrbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjYwNVwiLCBcIlxcXFxiaWdzdGFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjIyXCIsIFwiXFxcXHNwaGVyaWNhbGFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjAxXCIsIFwiXFxcXGNvbXBsZW1lbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAwZjBcIiwgXCJcXFxcZXRoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNTcxXCIsIFwiXFxcXGRpYWd1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjU3MlwiLCBcIlxcXFxkaWFnZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjVhMVwiLCBcIlxcXFxzcXVhcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1YTFcIiwgXCJcXFxcQm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWNhXCIsIFwiXFxcXERpYW1vbmRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAwYTVcIiwgXCJcXFxceWVuXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNzEzXCIsIFwiXFxcXGNoZWNrbWFya1wiKTtcblxuLy8gQU1TIEhlYnJld1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTM2XCIsIFwiXFxcXGJldGhcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMzhcIiwgXCJcXFxcZGFsZXRoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTM3XCIsIFwiXFxcXGdpbWVsXCIpO1xuXG4vLyBBTVMgR3JlZWtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDNkZFwiLCBcIlxcXFxkaWdhbW1hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUwM2YwXCIsIFwiXFxcXHZhcmthcHBhXCIpO1xuXG4vLyBBTVMgRGVsaW1pdGVyc1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgb3BlbiwgXCJcXHUyNTBjXCIsIFwiXFxcXHVsY29ybmVyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgY2xvc2UsIFwiXFx1MjUxMFwiLCBcIlxcXFx1cmNvcm5lclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIG9wZW4sIFwiXFx1MjUxNFwiLCBcIlxcXFxsbGNvcm5lclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGNsb3NlLCBcIlxcdTI1MThcIiwgXCJcXFxcbHJjb3JuZXJcIik7XG5cbi8vIEFNUyBCaW5hcnkgUmVsYXRpb25zXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2NlwiLCBcIlxcXFxsZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhN2RcIiwgXCJcXFxcbGVxc2xhbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE5NVwiLCBcIlxcXFxlcXNsYW50bGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcyXCIsIFwiXFxcXGxlc3NzaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4NVwiLCBcIlxcXFxsZXNzYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNGFcIiwgXCJcXFxcYXBwcm94ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJkNlwiLCBcIlxcXFxsZXNzZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDhcIiwgXCJcXFxcbGxsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzZcIiwgXCJcXFxcbGVzc2d0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRhXCIsIFwiXFxcXGxlc3NlcWd0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYThiXCIsIFwiXFxcXGxlc3NlcXFndHJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1MVwiLCBcIlxcXFxkb3RlcWRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUzXCIsIFwiXFxcXHJpc2luZ2RvdHNlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUyXCIsIFwiXFxcXGZhbGxpbmdkb3RzZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzZFwiLCBcIlxcXFxiYWNrc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyY2RcIiwgXCJcXFxcYmFja3NpbWVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYzVcIiwgXCJcXFxcc3Vic2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDBcIiwgXCJcXFxcU3Vic2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOGZcIiwgXCJcXFxcc3FzdWJzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3Y1wiLCBcIlxcXFxwcmVjY3VybHllcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRlXCIsIFwiXFxcXGN1cmx5ZXFwcmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2VcIiwgXCJcXFxccHJlY3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI3XCIsIFwiXFxcXHByZWNhcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiMlwiLCBcIlxcXFx2YXJ0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiNFwiLCBcIlxcXFx0cmlhbmdsZWxlZnRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmE4XCIsIFwiXFxcXHZEYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWFcIiwgXCJcXFxcVnZkYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIzMjNcIiwgXCJcXFxcc21hbGxzbWlsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMzIyXCIsIFwiXFxcXHNtYWxsZnJvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0ZlwiLCBcIlxcXFxidW1wZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0ZVwiLCBcIlxcXFxCdW1wZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2N1wiLCBcIlxcXFxnZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhN2VcIiwgXCJcXFxcZ2Vxc2xhbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE5NlwiLCBcIlxcXFxlcXNsYW50Z3RyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzNcIiwgXCJcXFxcZ3Ryc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODZcIiwgXCJcXFxcZ3RyYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDdcIiwgXCJcXFxcZ3RyZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDlcIiwgXCJcXFxcZ2dnXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzdcIiwgXCJcXFxcZ3RybGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRiXCIsIFwiXFxcXGd0cmVxbGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYThjXCIsIFwiXFxcXGd0cmVxcWxlc3NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1NlwiLCBcIlxcXFxlcWNpcmNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1N1wiLCBcIlxcXFxjaXJjZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1Y1wiLCBcIlxcXFx0cmlhbmdsZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzY1wiLCBcIlxcXFx0aGlja3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQ4XCIsIFwiXFxcXHRoaWNrYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYzZcIiwgXCJcXFxcc3Vwc2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDFcIiwgXCJcXFxcU3Vwc2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOTBcIiwgXCJcXFxcc3FzdXBzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3ZFwiLCBcIlxcXFxzdWNjY3VybHllcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRmXCIsIFwiXFxcXGN1cmx5ZXFzdWNjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2ZcIiwgXCJcXFxcc3VjY3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI4XCIsIFwiXFxcXHN1Y2NhcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiM1wiLCBcIlxcXFx2YXJ0cmlhbmdsZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjVcIiwgXCJcXFxcdHJpYW5nbGVyaWdodGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYTlcIiwgXCJcXFxcVmRhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxzaG9ydG1pZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI1XCIsIFwiXFxcXHNob3J0cGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2Y1wiLCBcIlxcXFxiZXR3ZWVuXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDRcIiwgXCJcXFxccGl0Y2hmb3JrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMWRcIiwgXCJcXFxcdmFycHJvcHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTI1YzBcIiwgXCJcXFxcYmxhY2t0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzNFwiLCBcIlxcXFx0aGVyZWZvcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIwZFwiLCBcIlxcXFxiYWNrZXBzaWxvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWI2XCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjM1XCIsIFwiXFxcXGJlY2F1c2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkOFwiLCBcIlxcXFxsbGxlc3NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkOVwiLCBcIlxcXFxnZ2d0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmIyXCIsIFwiXFxcXGxoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmIzXCIsIFwiXFxcXHJoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQyXCIsIFwiXFxcXGVxc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmM4XCIsIFwiXFxcXEpvaW5cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1MVwiLCBcIlxcXFxEb3RlcVwiKTtcblxuLy8gQU1TIEJpbmFyeSBPcGVyYXRvcnNcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjE0XCIsIFwiXFxcXGRvdHBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjIxNlwiLCBcIlxcXFxzbWFsbHNldG1pbnVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDJcIiwgXCJcXFxcQ2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDNcIiwgXCJcXFxcQ3VwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTJhNWVcIiwgXCJcXFxcZG91YmxlYmFyd2VkZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5ZlwiLCBcIlxcXFxib3htaW51c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjllXCIsIFwiXFxcXGJveHBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjN1wiLCBcIlxcXFxkaXZpZGVvbnRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYzlcIiwgXCJcXFxcbHRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2FcIiwgXCJcXFxccnRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2JcIiwgXCJcXFxcbGVmdHRocmVldGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjY1wiLCBcIlxcXFxyaWdodHRocmVldGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjZlwiLCBcIlxcXFxjdXJseXdlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2VcIiwgXCJcXFxcY3VybHl2ZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5ZFwiLCBcIlxcXFxjaXJjbGVkZGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjliXCIsIFwiXFxcXGNpcmNsZWRhc3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjNVwiLCBcIlxcXFxjZW50ZXJkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiYVwiLCBcIlxcXFxpbnRlcmNhbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQyXCIsIFwiXFxcXGRvdWJsZWNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQzXCIsIFwiXFxcXGRvdWJsZWN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmEwXCIsIFwiXFxcXGJveHRpbWVzXCIpO1xuXG4vLyBBTVMgQXJyb3dzXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFlMlwiLCBcIlxcXFxkYXNocmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWUwXCIsIFwiXFxcXGRhc2hsZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjN1wiLCBcIlxcXFxsZWZ0bGVmdGFycm93c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWM2XCIsIFwiXFxcXGxlZnRyaWdodGFycm93c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWRhXCIsIFwiXFxcXExsZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5ZVwiLCBcIlxcXFx0d29oZWFkbGVmdGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYTJcIiwgXCJcXFxcbGVmdGFycm93dGFpbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFiXCIsIFwiXFxcXGxvb3BhcnJvd2xlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjYlwiLCBcIlxcXFxsZWZ0cmlnaHRoYXJwb29uc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWI2XCIsIFwiXFxcXGN1cnZlYXJyb3dsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmFcIiwgXCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjBcIiwgXCJcXFxcTHNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzhcIiwgXCJcXFxcdXB1cGFycm93c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWJmXCIsIFwiXFxcXHVwaGFycG9vbmxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjM1wiLCBcIlxcXFxkb3duaGFycG9vbmxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiOFwiLCBcIlxcXFxtdWx0aW1hcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFkXCIsIFwiXFxcXGxlZnRyaWdodHNxdWlnYXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjOVwiLCBcIlxcXFxyaWdodHJpZ2h0YXJyb3dzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzRcIiwgXCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYTBcIiwgXCJcXFxcdHdvaGVhZHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhM1wiLCBcIlxcXFxyaWdodGFycm93dGFpbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFjXCIsIFwiXFxcXGxvb3BhcnJvd3JpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjdcIiwgXCJcXFxcY3VydmVhcnJvd3JpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmJcIiwgXCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWIxXCIsIFwiXFxcXFJzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWNhXCIsIFwiXFxcXGRvd25kb3duYXJyb3dzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmVcIiwgXCJcXFxcdXBoYXJwb29ucmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjMlwiLCBcIlxcXFxkb3duaGFycG9vbnJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZGRcIiwgXCJcXFxccmlnaHRzcXVpZ2Fycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZGRcIiwgXCJcXFxcbGVhZHN0b1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWRiXCIsIFwiXFxcXFJyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmVcIiwgXCJcXFxccmVzdHJpY3Rpb25cIik7XG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJgXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIyMFwiLCBcIlxcXFxhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMWVcIiwgXCJcXFxcaW5mdHlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDMyXCIsIFwiXFxcXHByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjViM1wiLCBcIlxcXFx0cmlhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOTNcIiwgXCJcXFxcR2FtbWFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMzk0XCIsIFwiXFxcXERlbHRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5OFwiLCBcIlxcXFxUaGV0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOWJcIiwgXCJcXFxcTGFtYmRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5ZVwiLCBcIlxcXFxYaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTBcIiwgXCJcXFxcUGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2EzXCIsIFwiXFxcXFNpZ21hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhNVwiLCBcIlxcXFxVcHNpbG9uXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhNlwiLCBcIlxcXFxQaGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2E4XCIsIFwiXFxcXFBzaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTlcIiwgXCJcXFxcT21lZ2FcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGFjXCIsIFwiXFxcXG5lZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYWNcIiwgXCJcXFxcbG5vdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyYTRcIiwgXCJcXFxcdG9wXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjJhNVwiLCBcIlxcXFxib3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjA1XCIsIFwiXFxcXGVtcHR5c2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjA1XCIsIFwiXFxcXHZhcm5vdGhpbmdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2IxXCIsIFwiXFxcXGFscGhhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiMlwiLCBcIlxcXFxiZXRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiM1wiLCBcIlxcXFxnYW1tYVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjRcIiwgXCJcXFxcZGVsdGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2Y1XCIsIFwiXFxcXGVwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I2XCIsIFwiXFxcXHpldGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I3XCIsIFwiXFxcXGV0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjhcIiwgXCJcXFxcdGhldGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I5XCIsIFwiXFxcXGlvdGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JhXCIsIFwiXFxcXGthcHBhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiYlwiLCBcIlxcXFxsYW1iZGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JjXCIsIFwiXFxcXG11XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiZFwiLCBcIlxcXFxudVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYmVcIiwgXCJcXFxceGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJvXCIsIFwiXFxcXG9taWNyb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2MwXCIsIFwiXFxcXHBpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjMVwiLCBcIlxcXFxyaG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2MzXCIsIFwiXFxcXHNpZ21hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjNFwiLCBcIlxcXFx0YXVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M1XCIsIFwiXFxcXHVwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2Q1XCIsIFwiXFxcXHBoaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzdcIiwgXCJcXFxcY2hpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjOFwiLCBcIlxcXFxwc2lcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M5XCIsIFwiXFxcXG9tZWdhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiNVwiLCBcIlxcXFx2YXJlcHNpbG9uXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNkMVwiLCBcIlxcXFx2YXJ0aGV0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzZDZcIiwgXCJcXFxcdmFycGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2YxXCIsIFwiXFxcXHZhcnJob1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzJcIiwgXCJcXFxcdmFyc2lnbWFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M2XCIsIFwiXFxcXHZhcnBoaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxN1wiLCBcIipcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIitcIiwgXCIrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjEyXCIsIFwiLVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjJjNVwiLCBcIlxcXFxjZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE4XCIsIFwiXFxcXGNpcmNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTAwZjdcIiwgXCJcXFxcZGl2XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUwMGIxXCIsIFwiXFxcXHBtXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUwMGQ3XCIsIFwiXFxcXHRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjI5XCIsIFwiXFxcXGNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyYVwiLCBcIlxcXFxjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc2V0bWludXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcbGFuZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyOFwiLCBcIlxcXFxsb3JcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcd2VkZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjhcIiwgXCJcXFxcdmVlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIxYVwiLCBcIlxcXFxzdXJkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiKFwiLCBcIihcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJbXCIsIFwiW1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTI3ZThcIiwgXCJcXFxcbGFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiXFx1MjIyM1wiLCBcIlxcXFxsdmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIyMjVcIiwgXCJcXFxcbFZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiKVwiLCBcIilcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXVwiLCBcIl1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiP1wiLCBcIj9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiIVwiLCBcIiFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXFx1MjdlOVwiLCBcIlxcXFxyYW5nbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXFx1MjIyM1wiLCBcIlxcXFxydmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyMjI1XCIsIFwiXFxcXHJWZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI9XCIsIFwiPVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPFwiLCBcIjxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIj5cIiwgXCI+XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI6XCIsIFwiOlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0OFwiLCBcIlxcXFxhcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNDVcIiwgXCJcXFxcY29uZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTBcIiwgXCJcXFxcZ2V0c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPlwiLCBcIlxcXFxndFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwOFwiLCBcIlxcXFxpblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwOVwiLCBcIlxcXFxub3RpblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI4MlwiLCBcIlxcXFxzdWJzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODNcIiwgXCJcXFxcc3Vwc2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjg2XCIsIFwiXFxcXHN1YnNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjg3XCIsIFwiXFxcXHN1cHNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODhcIiwgXCJcXFxcbnN1YnNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODlcIiwgXCJcXFxcbnN1cHNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmE4XCIsIFwiXFxcXG1vZGVsc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MFwiLCBcIlxcXFxsZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNjRcIiwgXCJcXFxcbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNjRcIiwgXCJcXFxcbGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI8XCIsIFwiXFxcXGx0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjYwXCIsIFwiXFxcXG5lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjYwXCIsIFwiXFxcXG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MlwiLCBcIlxcXFxyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTkyXCIsIFwiXFxcXHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzFcIiwgXCJcXFxcbmdlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcwXCIsIFwiXFxcXG5sZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxcIVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJ+XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHNwYWNpbmcsIG51bGwsIFwiXFxcXCxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxcOlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBudWxsLCBcIlxcXFw7XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHNwYWNpbmcsIG51bGwsIFwiXFxcXGVuc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxccXF1YWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxccXVhZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiLFwiLCBcIixcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiO1wiLCBcIjtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiOlwiLCBcIlxcXFxjb2xvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmJjXCIsIFwiXFxcXGJhcndlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYmJcIiwgXCJcXFxcdmVlYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk5XCIsIFwiXFxcXG9kb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTVcIiwgXCJcXFxcb3BsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTdcIiwgXCJcXFxcb3RpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwMlwiLCBcIlxcXFxwYXJ0aWFsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk4XCIsIFwiXFxcXG9zbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjlhXCIsIFwiXFxcXGNpcmNsZWRjaXJjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYTFcIiwgXCJcXFxcYm94ZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyNWIzXCIsIFwiXFxcXGJpZ3RyaWFuZ2xldXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YmRcIiwgXCJcXFxcYmlndHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjJjNFwiLCBcIlxcXFxkaWFtb25kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMmM2XCIsIFwiXFxcXHN0YXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YzNcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyNWI5XCIsIFwiXFxcXHRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwie1wiLCBcIlxcXFxsYnJhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwifVwiLCBcIlxcXFxyYnJhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJbXCIsIFwiXFxcXGxicmFja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJdXCIsIFwiXFxcXHJicmFja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIzMGFcIiwgXCJcXFxcbGZsb29yXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTIzMGJcIiwgXCJcXFxccmZsb29yXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiXFx1MjMwOFwiLCBcIlxcXFxsY2VpbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyMzA5XCIsIFwiXFxcXHJjZWlsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFxcXFwiLCBcIlxcXFxiYWNrc2xhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjIzXCIsIFwifFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjNcIiwgXCJcXFxcdmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjVcIiwgXCJcXFxcfFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjVcIiwgXCJcXFxcVmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MVwiLCBcIlxcXFx1cGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWQxXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTNcIiwgXCJcXFxcZG93bmFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWQzXCIsIFwiXFxcXERvd25hcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5NVwiLCBcIlxcXFx1cGRvd25hcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkNVwiLCBcIlxcXFxVcGRvd25hcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMjEwXCIsIFwiXFxcXGNvcHJvZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMmMxXCIsIFwiXFxcXGJpZ3ZlZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMmMwXCIsIFwiXFxcXGJpZ3dlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGgsIG9wLCBcIlxcdTJhMDRcIiwgXCJcXFxcYmlndXBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjJjMlwiLCBcIlxcXFxiaWdjYXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjJjM1wiLCBcIlxcXFxiaWdjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxpbnRvcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMjJjXCIsIFwiXFxcXGlpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyZFwiLCBcIlxcXFxpaWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMjBmXCIsIFwiXFxcXHByb2RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIxMVwiLCBcIlxcXFxzdW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MmEwMlwiLCBcIlxcXFxiaWdvdGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MmEwMVwiLCBcIlxcXFxiaWdvcGx1c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyYTAwXCIsIFwiXFxcXGJpZ29kb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyZVwiLCBcIlxcXFxvaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGgsIG9wLCBcIlxcdTJhMDZcIiwgXCJcXFxcYmlnc3FjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxzbWFsbGludFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXHRleHRlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXG1hdGhlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXGxkb3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbGRvdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgaW5uZXIsIFwiXFx1MjJlZlwiLCBcIlxcXFxjZG90c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgXCJcXHUyMmYxXCIsIFwiXFxcXGRkb3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjJlZVwiLCBcIlxcXFx2ZG90c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDBiNFwiLCBcIlxcXFxhY3V0ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDA2MFwiLCBcIlxcXFxncmF2ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDBhOFwiLCBcIlxcXFxkZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMDdlXCIsIFwiXFxcXHRpbGRlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMGFmXCIsIFwiXFxcXGJhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkOFwiLCBcIlxcXFxicmV2ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjN1wiLCBcIlxcXFxjaGVja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDA1ZVwiLCBcIlxcXFxoYXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTIwZDdcIiwgXCJcXFxcdmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmQ5XCIsIFwiXFxcXGRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAxMzFcIiwgXCJcXFxcaW1hdGhcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwMjM3XCIsIFwiXFxcXGptYXRoXCIpO1xuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiLS1cIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiLS0tXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxOFwiLCBcImBcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwiJ1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWNcIiwgXCJgYFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWRcIiwgXCInJ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYjBcIiwgXCJcXFxcZGVncmVlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFxkZWdyZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwMGEzXCIsIFwiXFxcXHBvdW5kc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjcyMFwiLCBcIlxcXFxtYWx0ZXNlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIGFtcywgdGV4dG9yZCwgXCJcXHUyNzIwXCIsIFwiXFxcXG1hbHRlc2VcIik7XG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCIgXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIn5cIik7XG5cbi8vIFRoZXJlIGFyZSBsb3RzIG9mIHN5bWJvbHMgd2hpY2ggYXJlIHRoZSBzYW1lLCBzbyB3ZSBhZGQgdGhlbSBpbiBhZnRlcndhcmRzLlxudmFyIGk7XG52YXIgY2g7XG5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gbWF0aCBtb2RlXG52YXIgbWF0aFRleHRTeW1ib2xzID0gXCIwMTIzNDU2Nzg5L0AuXFxcIlwiO1xuZm9yIChpID0gMDsgaSA8IG1hdGhUZXh0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gbWF0aFRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGVcbnZhciB0ZXh0U3ltYm9scyA9IFwiMDEyMzQ1Njc4OSFAKigpLT0rW11cXFwiOzo/Ly4sXCI7XG5mb3IgKGkgPSAwOyBpIDwgdGV4dFN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICBjaCA9IHRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGUsIGFuZCBtYXRob3JkcyBpbiBtYXRoIG1vZGVcbnZhciBsZXR0ZXJzID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XG5mb3IgKGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gbGV0dGVycy5jaGFyQXQoaSk7XG4gICAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCBjaCk7XG4gICAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbi8vIExhdGluLTEgbGV0dGVyc1xuZm9yIChpID0gMHgwMEMwOyBpIDw9IDB4MDBENjsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgY2gpO1xufVxuXG5mb3IgKGkgPSAweDAwRDg7IGkgPD0gMHgwMEY2OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbmZvciAoaSA9IDB4MDBGODsgaSA8PSAweDAwRkY7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQ3lyaWxsaWNcbmZvciAoaSA9IDB4MDQxMDsgaSA8PSAweDA0NEY7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gVW5pY29kZSB2ZXJzaW9ucyBvZiBleGlzdGluZyBjaGFyYWN0ZXJzXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwi4oCTXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxNFwiLCBcIuKAlFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCLigJhcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwi4oCZXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxY1wiLCBcIuKAnFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWRcIiwgXCLigJ1cIik7XG4iLCJ2YXIgaGFuZ3VsUmVnZXggPSAvW1xcdUFDMDAtXFx1RDdBRl0vO1xuXG4vLyBUaGlzIHJlZ2V4IGNvbWJpbmVzXG4vLyAtIEhpcmFnYW5hOiBbXFx1MzA0MC1cXHUzMDlGXVxuLy8gLSBLYXRha2FuYTogW1xcdTMwQTAtXFx1MzBGRl1cbi8vIC0gQ0pLIGlkZW9ncmFtczogW1xcdTRFMDAtXFx1OUZBRl1cbi8vIC0gSGFuZ3VsIHN5bGxhYmxlczogW1xcdUFDMDAtXFx1RDdBRl1cbi8vIE5vdGFibHkgbWlzc2luZyBhcmUgaGFsZndpZHRoIEthdGFrYW5hIGFuZCBSb21hbmppIGdseXBocy5cbnZhciBjamtSZWdleCA9XG4gICAgL1tcXHUzMDQwLVxcdTMwOUZdfFtcXHUzMEEwLVxcdTMwRkZdfFtcXHU0RTAwLVxcdTlGQUZdfFtcXHVBQzAwLVxcdUQ3QUZdLztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY2prUmVnZXg6IGNqa1JlZ2V4LFxuICAgIGhhbmd1bFJlZ2V4OiBoYW5ndWxSZWdleFxufTtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGEgbGlzdCBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB3aGljaCBhcmUgdXNlZnVsIGluIG90aGVyXG4gKiBmaWxlcy5cbiAqL1xuXG4vKipcbiAqIFByb3ZpZGUgYW4gYGluZGV4T2ZgIGZ1bmN0aW9uIHdoaWNoIHdvcmtzIGluIElFOCwgYnV0IGRlZmVycyB0byBuYXRpdmUgaWZcbiAqIHBvc3NpYmxlLlxuICovXG52YXIgbmF0aXZlSW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xudmFyIGluZGV4T2YgPSBmdW5jdGlvbihsaXN0LCBlbGVtKSB7XG4gICAgaWYgKGxpc3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGxpc3QuaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikge1xuICAgICAgICByZXR1cm4gbGlzdC5pbmRleE9mKGVsZW0pO1xuICAgIH1cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGwgPSBsaXN0Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAobGlzdFtpXSA9PT0gZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhbiBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbiBhIGxpc3RcbiAqL1xudmFyIGNvbnRhaW5zID0gZnVuY3Rpb24obGlzdCwgZWxlbSkge1xuICAgIHJldHVybiBpbmRleE9mKGxpc3QsIGVsZW0pICE9PSAtMTtcbn07XG5cbi8qKlxuICogUHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUgaWYgYSBzZXR0aW5nIGlzIHVuZGVmaW5lZFxuICovXG52YXIgZGVmbHQgPSBmdW5jdGlvbihzZXR0aW5nLCBkZWZhdWx0SWZVbmRlZmluZWQpIHtcbiAgICByZXR1cm4gc2V0dGluZyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdElmVW5kZWZpbmVkIDogc2V0dGluZztcbn07XG5cbi8vIGh5cGhlbmF0ZSBhbmQgZXNjYXBlIGFkYXB0ZWQgZnJvbSBGYWNlYm9vaydzIFJlYWN0IHVuZGVyIEFwYWNoZSAyIGxpY2Vuc2VcblxudmFyIHVwcGVyY2FzZSA9IC8oW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHVwcGVyY2FzZSwgXCItJDFcIikudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBFU0NBUEVfTE9PS1VQID0ge1xuICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgXCI+XCI6IFwiJmd0O1wiLFxuICAgIFwiPFwiOiBcIiZsdDtcIixcbiAgICBcIlxcXCJcIjogXCImcXVvdDtcIixcbiAgICBcIidcIjogXCImI3gyNztcIlxufTtcblxudmFyIEVTQ0FQRV9SRUdFWCA9IC9bJj48XCInXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVyKG1hdGNoKSB7XG4gICAgcmV0dXJuIEVTQ0FQRV9MT09LVVBbbWF0Y2hdO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZSh0ZXh0KSB7XG4gICAgcmV0dXJuIChcIlwiICsgdGV4dCkucmVwbGFjZShFU0NBUEVfUkVHRVgsIGVzY2FwZXIpO1xufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgYSBET00gZWxlbWVudCBpbiBhbGwgc3VwcG9ydGVkXG4gKiBicm93c2Vycy4gTm90ZSB0aGF0IHdlIGRvbid0IGRlZmluZSB0aGlzIGlmIHRoZXJlIGlzIG5vIGRvY3VtZW50LlxuICovXG52YXIgc2V0VGV4dENvbnRlbnQ7XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHRlc3ROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgaWYgKFwidGV4dENvbnRlbnRcIiBpbiB0ZXN0Tm9kZSkge1xuICAgICAgICBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uKG5vZGUsIHRleHQpIHtcbiAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24obm9kZSwgdGV4dCkge1xuICAgICAgICAgICAgbm9kZS5pbm5lclRleHQgPSB0ZXh0O1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNsZWFyIGEgbm9kZS5cbiAqL1xuZnVuY3Rpb24gY2xlYXJOb2RlKG5vZGUpIHtcbiAgICBzZXRUZXh0Q29udGVudChub2RlLCBcIlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29udGFpbnM6IGNvbnRhaW5zLFxuICAgIGRlZmx0OiBkZWZsdCxcbiAgICBlc2NhcGU6IGVzY2FwZSxcbiAgICBoeXBoZW5hdGU6IGh5cGhlbmF0ZSxcbiAgICBpbmRleE9mOiBpbmRleE9mLFxuICAgIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgICBjbGVhck5vZGU6IGNsZWFyTm9kZVxufTtcbiIsIi8qKiBAZmxvdyAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0UmVsb2NhdGFibGUocmUpIHtcbiAgLy8gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb3VsZCB1c2UgYSBXZWFrTWFwIGluc3RlYWQgb2YgYW4gZXhwYW5kby5cbiAgaWYgKCFyZS5fX21hdGNoQXRSZWxvY2F0YWJsZSkge1xuICAgIC8vIERpc2p1bmN0aW9ucyBhcmUgdGhlIGxvd2VzdC1wcmVjZWRlbmNlIG9wZXJhdG9yLCBzbyB3ZSBjYW4gbWFrZSBhbnlcbiAgICAvLyBwYXR0ZXJuIG1hdGNoIHRoZSBlbXB0eSBzdHJpbmcgYnkgYXBwZW5kaW5nIGB8KClgIHRvIGl0OlxuICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1wYXR0ZXJuc1xuICAgIHZhciBzb3VyY2UgPSByZS5zb3VyY2UgKyBcInwoKVwiO1xuXG4gICAgLy8gV2UgYWx3YXlzIG1ha2UgdGhlIG5ldyByZWdleCBnbG9iYWwuXG4gICAgdmFyIGZsYWdzID0gXCJnXCIgKyAocmUuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAocmUubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiKSArIChyZS51bmljb2RlID8gXCJ1XCIgOiBcIlwiKVxuICAgIC8vIHN0aWNreSAoLy4uLi95KSBkb2Vzbid0IG1ha2Ugc2Vuc2UgaW4gY29uanVuY3Rpb24gd2l0aCBvdXIgcmVsb2NhdGlvblxuICAgIC8vIGxvZ2ljLCBzbyB3ZSBpZ25vcmUgaXQgaGVyZS5cbiAgICA7XG5cbiAgICByZS5fX21hdGNoQXRSZWxvY2F0YWJsZSA9IG5ldyBSZWdFeHAoc291cmNlLCBmbGFncyk7XG4gIH1cbiAgcmV0dXJuIHJlLl9fbWF0Y2hBdFJlbG9jYXRhYmxlO1xufVxuXG5mdW5jdGlvbiBtYXRjaEF0KHJlLCBzdHIsIHBvcykge1xuICBpZiAocmUuZ2xvYmFsIHx8IHJlLnN0aWNreSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1hdGNoQXQoLi4uKTogT25seSBub24tZ2xvYmFsIHJlZ2V4ZXMgYXJlIHN1cHBvcnRlZFwiKTtcbiAgfVxuICB2YXIgcmVsb2MgPSBnZXRSZWxvY2F0YWJsZShyZSk7XG4gIHJlbG9jLmxhc3RJbmRleCA9IHBvcztcbiAgdmFyIG1hdGNoID0gcmVsb2MuZXhlYyhzdHIpO1xuICAvLyBMYXN0IGNhcHR1cmluZyBncm91cCBpcyBvdXIgc2VudGluZWwgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVnZXhcbiAgLy8gbWF0Y2hlZCBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uXG4gIGlmIChtYXRjaFttYXRjaC5sZW5ndGggLSAxXSA9PSBudWxsKSB7XG4gICAgLy8gT3JpZ2luYWwgcmVnZXggbWF0Y2hlZC5cbiAgICBtYXRjaC5sZW5ndGggPSBtYXRjaC5sZW5ndGggLSAxO1xuICAgIHJldHVybiBtYXRjaDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoQXQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgSW5uZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5uZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyU3Vic2NyaWJlcihwYXJlbnQsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLm91dGVyVmFsdWUgPSBvdXRlclZhbHVlO1xuICAgICAgICB0aGlzLm91dGVySW5kZXggPSBvdXRlckluZGV4O1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhcmVudC5ub3RpZnlOZXh0KHRoaXMub3V0ZXJWYWx1ZSwgdmFsdWUsIHRoaXMub3V0ZXJJbmRleCwgdGhpcy5pbmRleCsrLCB0aGlzKTtcbiAgICB9O1xuICAgIElubmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeUVycm9yKGVycm9yLCB0aGlzKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeUNvbXBsZXRlKHRoaXMpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5uZXJTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5Jbm5lclN1YnNjcmliZXIgPSBJbm5lclN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5lclN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi91dGlsL3Jvb3QnKTtcbnZhciB0b1N1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vdXRpbC90b1N1YnNjcmliZXInKTtcbnZhciBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYW55IHNldCBvZiB2YWx1ZXMgb3ZlciBhbnkgYW1vdW50IG9mIHRpbWUuIFRoaXMgdGhlIG1vc3QgYmFzaWMgYnVpbGRpbmcgYmxvY2tcbiAqIG9mIFJ4SlMuXG4gKlxuICogQGNsYXNzIE9ic2VydmFibGU8VD5cbiAqL1xudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZSB0aGUgZnVuY3Rpb24gdGhhdCBpcyAgY2FsbGVkIHdoZW4gdGhlIE9ic2VydmFibGUgaXNcbiAgICAgKiBpbml0aWFsbHkgc3Vic2NyaWJlZCB0by4gVGhpcyBmdW5jdGlvbiBpcyBnaXZlbiBhIFN1YnNjcmliZXIsIHRvIHdoaWNoIG5ldyB2YWx1ZXNcbiAgICAgKiBjYW4gYmUgYG5leHRgZWQsIG9yIGFuIGBlcnJvcmAgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gcmFpc2UgYW4gZXJyb3IsIG9yXG4gICAgICogYGNvbXBsZXRlYCBjYW4gYmUgY2FsbGVkIHRvIG5vdGlmeSBvZiBhIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlLCB3aXRoIHRoaXMgT2JzZXJ2YWJsZSBhcyB0aGUgc291cmNlLCBhbmQgdGhlIHBhc3NlZFxuICAgICAqIG9wZXJhdG9yIGRlZmluZWQgYXMgdGhlIG5ldyBvYnNlcnZhYmxlJ3Mgb3BlcmF0b3IuXG4gICAgICogQG1ldGhvZCBsaWZ0XG4gICAgICogQHBhcmFtIHtPcGVyYXRvcn0gb3BlcmF0b3IgdGhlIG9wZXJhdG9yIGRlZmluaW5nIHRoZSBvcGVyYXRpb24gdG8gdGFrZSBvbiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IG9ic2VydmFibGUgd2l0aCB0aGUgT3BlcmF0b3IgYXBwbGllZFxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm9wZXJhdG9yO1xuICAgICAgICB2YXIgc2luayA9IHRvU3Vic2NyaWJlcl8xLnRvU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBvcGVyYXRvci5jYWxsKHNpbmssIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpbmsuYWRkKHRoaXMuX3RyeVN1YnNjcmliZShzaW5rKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc2luay5zeW5jRXJyb3JWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2luaztcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShzaW5rKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgc2luay5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGZvckVhY2hcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0IGEgaGFuZGxlciBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBvYnNlcnZhYmxlXG4gICAgICogQHBhcmFtIHtQcm9taXNlQ29uc3RydWN0b3J9IFtQcm9taXNlQ3Rvcl0gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBQcm9taXNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgZWl0aGVyIHJlc29sdmVzIG9uIG9ic2VydmFibGUgY29tcGxldGlvbiBvclxuICAgICAqICByZWplY3RzIHdpdGggdGhlIGhhbmRsZWQgZXJyb3JcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKG5leHQsIFByb21pc2VDdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgICAgIGlmIChyb290XzEucm9vdC5SeCAmJiByb290XzEucm9vdC5SeC5jb25maWcgJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocm9vdF8xLnJvb3QuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFByb21pc2UgaW1wbCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gTXVzdCBiZSBkZWNsYXJlZCBpbiBhIHNlcGFyYXRlIHN0YXRlbWVudCB0byBhdm9pZCBhIFJlZmVybmNlRXJyb3Igd2hlblxuICAgICAgICAgICAgLy8gYWNjZXNzaW5nIHN1YnNjcmlwdGlvbiBiZWxvdyBpbiB0aGUgY2xvc3VyZSBkdWUgdG8gVGVtcG9yYWwgRGVhZCBab25lLlxuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc3Vic2NyaXB0aW9uLCB0aGVuIHdlIGNhbiBzdXJtaXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXh0IGhhbmRsaW5nIGlzIGFzeW5jaHJvbm91cy4gQW55IGVycm9ycyB0aHJvd25cbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBiZSByZWplY3RlZCBleHBsaWNpdGx5IGFuZCB1bnN1YnNjcmliZSBtdXN0IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxlZCBtYW51YWxseVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgTk8gc3Vic2NyaXB0aW9uLCB0aGVuIHdlJ3JlIGdldHRpbmcgYSBuZXh0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgc3luY2hyb25vdXNseSBkdXJpbmcgc3Vic2NyaXB0aW9uLiBXZSBjYW4ganVzdCBjYWxsIGl0LlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBlcnJvcnMsIE9ic2VydmFibGUncyBgc3Vic2NyaWJlYCB3aWxsIGVuc3VyZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5zdWJzY3JpcHRpb24gbG9naWMgaXMgY2FsbGVkLCB0aGVuIHN5bmNocm9ub3VzbHkgcmV0aHJvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIHRoYXQsIFByb21pc2Ugd2lsbCB0cmFwIHRoZSBlcnJvciBhbmQgc2VuZCBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBkb3duIHRoZSByZWplY3Rpb24gcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVqZWN0LCByZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFuIGludGVyb3AgcG9pbnQgZGVmaW5lZCBieSB0aGUgZXM3LW9ic2VydmFibGUgc3BlYyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG4gICAgICogQG1ldGhvZCBTeW1ib2wub2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IHRoaXMgaW5zdGFuY2Ugb2YgdGhlIG9ic2VydmFibGVcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZVtvYnNlcnZhYmxlXzEub2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gSEFDSzogU2luY2UgVHlwZVNjcmlwdCBpbmhlcml0cyBzdGF0aWMgcHJvcGVydGllcyB0b28sIHdlIGhhdmUgdG9cbiAgICAvLyBmaWdodCBhZ2FpbnN0IFR5cGVTY3JpcHQgaGVyZSBzbyBTdWJqZWN0IGNhbiBoYXZlIGEgZGlmZmVyZW50IHN0YXRpYyBjcmVhdGUgc2lnbmF0dXJlXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb2xkIE9ic2VydmFibGUgYnkgY2FsbGluZyB0aGUgT2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICogQG1ldGhvZCBjcmVhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdWJzY3JpYmU/IHRoZSBzdWJzY3JpYmVyIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZCB0byB0aGUgT2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IGNvbGQgb2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZhYmxlO1xufSgpKTtcbmV4cG9ydHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5lbXB0eSA9IHtcbiAgICBjbG9zZWQ6IHRydWUsXG4gICAgbmV4dDogZnVuY3Rpb24gKHZhbHVlKSB7IH0sXG4gICAgZXJyb3I6IGZ1bmN0aW9uIChlcnIpIHsgdGhyb3cgZXJyOyB9LFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7IH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYnNlcnZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBPdXRlclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhPdXRlclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT3V0ZXJTdWJzY3JpYmVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgT3V0ZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICB9O1xuICAgIE91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgT3V0ZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gT3V0ZXJTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5PdXRlclN1YnNjcmliZXIgPSBPdXRlclN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PdXRlclN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEFuIGV4ZWN1dGlvbiBjb250ZXh0IGFuZCBhIGRhdGEgc3RydWN0dXJlIHRvIG9yZGVyIHRhc2tzIGFuZCBzY2hlZHVsZSB0aGVpclxuICogZXhlY3V0aW9uLiBQcm92aWRlcyBhIG5vdGlvbiBvZiAocG90ZW50aWFsbHkgdmlydHVhbCkgdGltZSwgdGhyb3VnaCB0aGVcbiAqIGBub3coKWAgZ2V0dGVyIG1ldGhvZC5cbiAqXG4gKiBFYWNoIHVuaXQgb2Ygd29yayBpbiBhIFNjaGVkdWxlciBpcyBjYWxsZWQgYW4ge0BsaW5rIEFjdGlvbn0uXG4gKlxuICogYGBgdHNcbiAqIGNsYXNzIFNjaGVkdWxlciB7XG4gKiAgIG5vdygpOiBudW1iZXI7XG4gKiAgIHNjaGVkdWxlKHdvcmssIGRlbGF5Pywgc3RhdGU/KTogU3Vic2NyaXB0aW9uO1xuICogfVxuICogYGBgXG4gKlxuICogQGNsYXNzIFNjaGVkdWxlclxuICovXG52YXIgU2NoZWR1bGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY2hlZHVsZXIoU2NoZWR1bGVyQWN0aW9uLCBub3cpIHtcbiAgICAgICAgaWYgKG5vdyA9PT0gdm9pZCAwKSB7IG5vdyA9IFNjaGVkdWxlci5ub3c7IH1cbiAgICAgICAgdGhpcy5TY2hlZHVsZXJBY3Rpb24gPSBTY2hlZHVsZXJBY3Rpb247XG4gICAgICAgIHRoaXMubm93ID0gbm93O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYSBmdW5jdGlvbiwgYHdvcmtgLCBmb3IgZXhlY3V0aW9uLiBNYXkgaGFwcGVuIGF0IHNvbWUgcG9pbnQgaW5cbiAgICAgKiB0aGUgZnV0dXJlLCBhY2NvcmRpbmcgdG8gdGhlIGBkZWxheWAgcGFyYW1ldGVyLCBpZiBzcGVjaWZpZWQuIE1heSBiZSBwYXNzZWRcbiAgICAgKiBzb21lIGNvbnRleHQgb2JqZWN0LCBgc3RhdGVgLCB3aGljaCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgYHdvcmtgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGdpdmVuIGFyZ3VtZW50cyB3aWxsIGJlIHByb2Nlc3NlZCBhbiBzdG9yZWQgYXMgYW4gQWN0aW9uIG9iamVjdCBpbiBhXG4gICAgICogcXVldWUgb2YgYWN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RhdGU6ID9UKTogP1N1YnNjcmlwdGlvbn0gd29yayBBIGZ1bmN0aW9uIHJlcHJlc2VudGluZyBhXG4gICAgICogdGFzaywgb3Igc29tZSB1bml0IG9mIHdvcmsgdG8gYmUgZXhlY3V0ZWQgYnkgdGhlIFNjaGVkdWxlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5XSBUaW1lIHRvIHdhaXQgYmVmb3JlIGV4ZWN1dGluZyB0aGUgd29yaywgd2hlcmUgdGhlXG4gICAgICogdGltZSB1bml0IGlzIGltcGxpY2l0IGFuZCBkZWZpbmVkIGJ5IHRoZSBTY2hlZHVsZXIgaXRzZWxmLlxuICAgICAqIEBwYXJhbSB7VH0gW3N0YXRlXSBTb21lIGNvbnRleHR1YWwgZGF0YSB0aGF0IHRoZSBgd29ya2AgZnVuY3Rpb24gdXNlcyB3aGVuXG4gICAgICogY2FsbGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufSBBIHN1YnNjcmlwdGlvbiBpbiBvcmRlciB0byBiZSBhYmxlIHRvIHVuc3Vic2NyaWJlXG4gICAgICogdGhlIHNjaGVkdWxlZCB3b3JrLlxuICAgICAqL1xuICAgIFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAod29yaywgZGVsYXksIHN0YXRlKSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuU2NoZWR1bGVyQWN0aW9uKHRoaXMsIHdvcmspLnNjaGVkdWxlKHN0YXRlLCBkZWxheSk7XG4gICAgfTtcbiAgICBTY2hlZHVsZXIubm93ID0gRGF0ZS5ub3cgPyBEYXRlLm5vdyA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICtuZXcgRGF0ZSgpOyB9O1xuICAgIHJldHVybiBTY2hlZHVsZXI7XG59KCkpO1xuZXhwb3J0cy5TY2hlZHVsZXIgPSBTY2hlZHVsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY2hlZHVsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL09ic2VydmFibGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvcicpO1xudmFyIFN1YmplY3RTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3ViamVjdFN1YnNjcmlwdGlvbicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEBjbGFzcyBTdWJqZWN0U3Vic2NyaWJlcjxUPlxuICovXG52YXIgU3ViamVjdFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0U3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5TdWJqZWN0U3Vic2NyaWJlciA9IFN1YmplY3RTdWJzY3JpYmVyO1xuLyoqXG4gKiBAY2xhc3MgU3ViamVjdDxUPlxuICovXG52YXIgU3ViamVjdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdCgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aHJvd25FcnJvciA9IG51bGw7XG4gICAgfVxuICAgIFN1YmplY3QucHJvdG90eXBlW3J4U3Vic2NyaWJlcl8xLnJ4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ViamVjdFN1YnNjcmliZXIodGhpcyk7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gbmV3IEFub255bW91c1N1YmplY3QodGhpcywgdGhpcyk7XG4gICAgICAgIHN1YmplY3Qub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29weVtpXS5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50aHJvd25FcnJvciA9IGVycjtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBudWxsO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl90cnlTdWJzY3JpYmUuY2FsbCh0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHRoaXMudGhyb3duRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpcHRpb25fMS5TdWJqZWN0U3Vic2NyaXB0aW9uKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5hc09ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKCk7XG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBTdWJqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJqZWN0O1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5TdWJqZWN0ID0gU3ViamVjdDtcbi8qKlxuICogQGNsYXNzIEFub255bW91c1N1YmplY3Q8VD5cbiAqL1xudmFyIEFub255bW91c1N1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbm9ueW1vdXNTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24ubmV4dCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFub255bW91c1N1YmplY3Q7XG59KFN1YmplY3QpKTtcbmV4cG9ydHMuQW5vbnltb3VzU3ViamVjdCA9IEFub255bW91c1N1YmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0U3Vic2NyaXB0aW9uKHN1YmplY3QsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IHN1YnNjcmliZXI7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgfVxuICAgIFN1YmplY3RTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0O1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gc3ViamVjdC5vYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IG51bGw7XG4gICAgICAgIGlmICghb2JzZXJ2ZXJzIHx8IG9ic2VydmVycy5sZW5ndGggPT09IDAgfHwgc3ViamVjdC5pc1N0b3BwZWQgfHwgc3ViamVjdC5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaWJlckluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2YodGhpcy5zdWJzY3JpYmVyKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2Uoc3Vic2NyaWJlckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5TdWJqZWN0U3Vic2NyaXB0aW9uID0gU3ViamVjdFN1YnNjcmlwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3RTdWJzY3JpcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYnNlcnZlcl8xID0gcmVxdWlyZSgnLi9PYnNlcnZlcicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBPYnNlcnZlcn0gaW50ZXJmYWNlIGFuZCBleHRlbmRzIHRoZVxuICoge0BsaW5rIFN1YnNjcmlwdGlvbn0gY2xhc3MuIFdoaWxlIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGlzIHRoZSBwdWJsaWMgQVBJIGZvclxuICogY29uc3VtaW5nIHRoZSB2YWx1ZXMgb2YgYW4ge0BsaW5rIE9ic2VydmFibGV9LCBhbGwgT2JzZXJ2ZXJzIGdldCBjb252ZXJ0ZWQgdG9cbiAqIGEgU3Vic2NyaWJlciwgaW4gb3JkZXIgdG8gcHJvdmlkZSBTdWJzY3JpcHRpb24tbGlrZSBjYXBhYmlsaXRpZXMgc3VjaCBhc1xuICogYHVuc3Vic2NyaWJlYC4gU3Vic2NyaWJlciBpcyBhIGNvbW1vbiB0eXBlIGluIFJ4SlMsIGFuZCBjcnVjaWFsIGZvclxuICogaW1wbGVtZW50aW5nIG9wZXJhdG9ycywgYnV0IGl0IGlzIHJhcmVseSB1c2VkIGFzIGEgcHVibGljIEFQSS5cbiAqXG4gKiBAY2xhc3MgU3Vic2NyaWJlcjxUPlxuICovXG52YXIgU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbih2YWx1ZTogVCk6IHZvaWR9IFtkZXN0aW5hdGlvbk9yTmV4dF0gQSBwYXJ0aWFsbHlcbiAgICAgKiBkZWZpbmVkIE9ic2VydmVyIG9yIGEgYG5leHRgIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZTogP2FueSk6IHZvaWR9IFtlcnJvcl0gVGhlIGBlcnJvcmAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3luY0Vycm9yVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoIWRlc3RpbmF0aW9uT3JOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBPYnNlcnZlcl8xLmVtcHR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbk9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uT3JOZXh0IGluc3RhbmNlb2YgU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uT3JOZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5hZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlW3J4U3Vic2NyaWJlcl8xLnJ4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIGZhY3RvcnkgZm9yIGEgU3Vic2NyaWJlciwgZ2l2ZW4gYSAocG90ZW50aWFsbHkgcGFydGlhbCkgZGVmaW5pdGlvblxuICAgICAqIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oeDogP1QpOiB2b2lkfSBbbmV4dF0gVGhlIGBuZXh0YCBjYWxsYmFjayBvZiBhbiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHJldHVybiB7U3Vic2NyaWJlcjxUPn0gQSBTdWJzY3JpYmVyIHdyYXBwaW5nIHRoZSAocGFydGlhbGx5IGRlZmluZWQpXG4gICAgICogT2JzZXJ2ZXIgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcihuZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBuZXh0YCBmcm9tXG4gICAgICogdGhlIE9ic2VydmFibGUsIHdpdGggYSB2YWx1ZS4gVGhlIE9ic2VydmFibGUgbWF5IGNhbGwgdGhpcyBtZXRob2QgMCBvciBtb3JlXG4gICAgICogdGltZXMuXG4gICAgICogQHBhcmFtIHtUfSBbdmFsdWVdIFRoZSBgbmV4dGAgdmFsdWUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2YgdHlwZSBgZXJyb3JgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhbiBhdHRhY2hlZCB7QGxpbmsgRXJyb3J9LiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdFxuICAgICAqIHRoZSBPYnNlcnZhYmxlIGhhcyBleHBlcmllbmNlZCBhbiBlcnJvciBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHthbnl9IFtlcnJdIFRoZSBgZXJyb3JgIGV4Y2VwdGlvbi5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIGEgdmFsdWVsZXNzIG5vdGlmaWNhdGlvbiBvZiB0eXBlXG4gICAgICogYGNvbXBsZXRlYCBmcm9tIHRoZSBPYnNlcnZhYmxlLiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdCB0aGUgT2JzZXJ2YWJsZVxuICAgICAqIGhhcyBmaW5pc2hlZCBzZW5kaW5nIHB1c2gtYmFzZWQgbm90aWZpY2F0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cztcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IF9wYXJlbnRzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVyO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3Vic2NyaWJlciA9IFN1YnNjcmliZXI7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhZmVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIoX3BhcmVudFN1YnNjcmliZXIsIG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBfcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9ic2VydmVyT3JOZXh0KSkge1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ic2VydmVyT3JOZXh0KSB7XG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQubmV4dDtcbiAgICAgICAgICAgIGVycm9yID0gb2JzZXJ2ZXJPck5leHQuZXJyb3I7XG4gICAgICAgICAgICBjb21wbGV0ZSA9IG9ic2VydmVyT3JOZXh0LmNvbXBsZXRlO1xuICAgICAgICAgICAgaWYgKG9ic2VydmVyT3JOZXh0ICE9PSBPYnNlcnZlcl8xLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IE9iamVjdC5jcmVhdGUob2JzZXJ2ZXJPck5leHQpO1xuICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihjb250ZXh0LnVuc3Vic2NyaWJlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChjb250ZXh0LnVuc3Vic2NyaWJlLmJpbmQoY29udGV4dCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250ZXh0LnVuc3Vic2NyaWJlID0gdGhpcy51bnN1YnNjcmliZS5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLl9uZXh0ID0gbmV4dDtcbiAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5fY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICB9XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCAmJiB0aGlzLl9uZXh0KSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuICAgICAgICAgICAgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9uZXh0LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgdGhpcy5fbmV4dCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9lcnJvciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgICAgICBfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fY29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgdGhpcy5fY29tcGxldGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclVuc3ViID0gZnVuY3Rpb24gKGZuLCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX190cnlPclNldEVycm9yID0gZnVuY3Rpb24gKHBhcmVudCwgZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBwYXJlbnQuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICBwYXJlbnQuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyID0gbnVsbDtcbiAgICAgICAgX3BhcmVudFN1YnNjcmliZXIudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBTYWZlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuL3V0aWwvaXNBcnJheScpO1xudmFyIGlzT2JqZWN0XzEgPSByZXF1aXJlKCcuL3V0aWwvaXNPYmplY3QnKTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgVW5zdWJzY3JpcHRpb25FcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3InKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGRpc3Bvc2FibGUgcmVzb3VyY2UsIHN1Y2ggYXMgdGhlIGV4ZWN1dGlvbiBvZiBhbiBPYnNlcnZhYmxlLiBBXG4gKiBTdWJzY3JpcHRpb24gaGFzIG9uZSBpbXBvcnRhbnQgbWV0aG9kLCBgdW5zdWJzY3JpYmVgLCB0aGF0IHRha2VzIG5vIGFyZ3VtZW50XG4gKiBhbmQganVzdCBkaXNwb3NlcyB0aGUgcmVzb3VyY2UgaGVsZCBieSB0aGUgc3Vic2NyaXB0aW9uLlxuICpcbiAqIEFkZGl0aW9uYWxseSwgc3Vic2NyaXB0aW9ucyBtYXkgYmUgZ3JvdXBlZCB0b2dldGhlciB0aHJvdWdoIHRoZSBgYWRkKClgXG4gKiBtZXRob2QsIHdoaWNoIHdpbGwgYXR0YWNoIGEgY2hpbGQgU3Vic2NyaXB0aW9uIHRvIHRoZSBjdXJyZW50IFN1YnNjcmlwdGlvbi5cbiAqIFdoZW4gYSBTdWJzY3JpcHRpb24gaXMgdW5zdWJzY3JpYmVkLCBhbGwgaXRzIGNoaWxkcmVuIChhbmQgaXRzIGdyYW5kY2hpbGRyZW4pXG4gKiB3aWxsIGJlIHVuc3Vic2NyaWJlZCBhcyB3ZWxsLlxuICpcbiAqIEBjbGFzcyBTdWJzY3JpcHRpb25cbiAqL1xudmFyIFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbdW5zdWJzY3JpYmVdIEEgZnVuY3Rpb24gZGVzY3JpYmluZyBob3cgdG9cbiAgICAgKiBwZXJmb3JtIHRoZSBkaXNwb3NhbCBvZiByZXNvdXJjZXMgd2hlbiB0aGUgYHVuc3Vic2NyaWJlYCBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbih1bnN1YnNjcmliZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgdGhpcyBTdWJzY3JpcHRpb24gaGFzIGFscmVhZHkgYmVlbiB1bnN1YnNjcmliZWQuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICBpZiAodW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgdGhlIHJlc291cmNlcyBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uIE1heSwgZm9yIGluc3RhbmNlLCBjYW5jZWxcbiAgICAgKiBhbiBvbmdvaW5nIE9ic2VydmFibGUgZXhlY3V0aW9uIG9yIGNhbmNlbCBhbnkgb3RoZXIgdHlwZSBvZiB3b3JrIHRoYXRcbiAgICAgKiBzdGFydGVkIHdoZW4gdGhlIFN1YnNjcmlwdGlvbiB3YXMgY3JlYXRlZC5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYXNFcnJvcnMgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9ycztcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcywgX3BhcmVudCA9IF9hLl9wYXJlbnQsIF9wYXJlbnRzID0gX2EuX3BhcmVudHMsIF91bnN1YnNjcmliZSA9IF9hLl91bnN1YnNjcmliZSwgX3N1YnNjcmlwdGlvbnMgPSBfYS5fc3Vic2NyaXB0aW9ucztcbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRzID0gbnVsbDtcbiAgICAgICAgLy8gbnVsbCBvdXQgX3N1YnNjcmlwdGlvbnMgZmlyc3Qgc28gYW55IGNoaWxkIHN1YnNjcmlwdGlvbnMgdGhhdCBhdHRlbXB0XG4gICAgICAgIC8vIHRvIHJlbW92ZSB0aGVtc2VsdmVzIGZyb20gdGhpcyBzdWJzY3JpcHRpb24gd2lsbCBub29wXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGxlbiA9IF9wYXJlbnRzID8gX3BhcmVudHMubGVuZ3RoIDogMDtcbiAgICAgICAgLy8gaWYgdGhpcy5fcGFyZW50IGlzIG51bGwsIHRoZW4gc28gaXMgdGhpcy5fcGFyZW50cywgYW5kIHdlXG4gICAgICAgIC8vIGRvbid0IGhhdmUgdG8gcmVtb3ZlIG91cnNlbHZlcyBmcm9tIGFueSBwYXJlbnQgc3Vic2NyaXB0aW9ucy5cbiAgICAgICAgd2hpbGUgKF9wYXJlbnQpIHtcbiAgICAgICAgICAgIF9wYXJlbnQucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgLy8gaWYgdGhpcy5fcGFyZW50cyBpcyBudWxsIG9yIGluZGV4ID49IGxlbixcbiAgICAgICAgICAgIC8vIHRoZW4gX3BhcmVudCBpcyBzZXQgdG8gbnVsbCwgYW5kIHRoZSBsb29wIGV4aXRzXG4gICAgICAgICAgICBfcGFyZW50ID0gKytpbmRleCA8IGxlbiAmJiBfcGFyZW50c1tpbmRleF0gfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oX3Vuc3Vic2NyaWJlKSkge1xuICAgICAgICAgICAgdmFyIHRyaWFsID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChfdW5zdWJzY3JpYmUpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAodHJpYWwgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCAoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IgP1xuICAgICAgICAgICAgICAgICAgICBmbGF0dGVuVW5zdWJzY3JpcHRpb25FcnJvcnMoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lLmVycm9ycykgOiBbZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXlfMS5pc0FycmF5KF9zdWJzY3JpcHRpb25zKSkge1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGxlbiA9IF9zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YiA9IF9zdWJzY3JpcHRpb25zW2luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3RfMS5pc09iamVjdChzdWIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmlhbCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc3ViLnVuc3Vic2NyaWJlKS5jYWxsKHN1Yik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnIuZXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdGVhciBkb3duIHRvIGJlIGNhbGxlZCBkdXJpbmcgdGhlIHVuc3Vic2NyaWJlKCkgb2YgdGhpc1xuICAgICAqIFN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIElmIHRoZSB0ZWFyIGRvd24gYmVpbmcgYWRkZWQgaXMgYSBzdWJzY3JpcHRpb24gdGhhdCBpcyBhbHJlYWR5XG4gICAgICogdW5zdWJzY3JpYmVkLCBpcyB0aGUgc2FtZSByZWZlcmVuY2UgYGFkZGAgaXMgYmVpbmcgY2FsbGVkIG9uLCBvciBpc1xuICAgICAqIGBTdWJzY3JpcHRpb24uRU1QVFlgLCBpdCB3aWxsIG5vdCBiZSBhZGRlZC5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgc3Vic2NyaXB0aW9uIGlzIGFscmVhZHkgaW4gYW4gYGNsb3NlZGAgc3RhdGUsIHRoZSBwYXNzZWRcbiAgICAgKiB0ZWFyIGRvd24gbG9naWMgd2lsbCBiZSBleGVjdXRlZCBpbW1lZGlhdGVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VGVhcmRvd25Mb2dpY30gdGVhcmRvd24gVGhlIGFkZGl0aW9uYWwgbG9naWMgdG8gZXhlY3V0ZSBvblxuICAgICAqIHRlYXJkb3duLlxuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn0gUmV0dXJucyB0aGUgU3Vic2NyaXB0aW9uIHVzZWQgb3IgY3JlYXRlZCB0byBiZVxuICAgICAqIGFkZGVkIHRvIHRoZSBpbm5lciBzdWJzY3JpcHRpb25zIGxpc3QuIFRoaXMgU3Vic2NyaXB0aW9uIGNhbiBiZSB1c2VkIHdpdGhcbiAgICAgKiBgcmVtb3ZlKClgIHRvIHJlbW92ZSB0aGUgcGFzc2VkIHRlYXJkb3duIGxvZ2ljIGZyb20gdGhlIGlubmVyIHN1YnNjcmlwdGlvbnNcbiAgICAgKiBsaXN0LlxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XG4gICAgICAgIGlmICghdGVhcmRvd24gfHwgKHRlYXJkb3duID09PSBTdWJzY3JpcHRpb24uRU1QVFkpKSB7XG4gICAgICAgICAgICByZXR1cm4gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZWFyZG93biA9PT0gdGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRlYXJkb3duO1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB0ZWFyZG93bikge1xuICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24odGVhcmRvd24pO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmNsb3NlZCB8fCB0eXBlb2Ygc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3Vic2NyaXB0aW9uLl9hZGRQYXJlbnQgIT09ICdmdW5jdGlvbicgLyogcXVhY2sgcXVhY2sgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uX3N1YnNjcmlwdGlvbnMgPSBbdG1wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHRlYXJkb3duICcgKyB0ZWFyZG93biArICcgYWRkZWQgdG8gU3Vic2NyaXB0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucyB8fCAodGhpcy5fc3Vic2NyaXB0aW9ucyA9IFtdKTtcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5fYWRkUGFyZW50KHRoaXMpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIFN1YnNjcmlwdGlvbiBmcm9tIHRoZSBpbnRlcm5hbCBsaXN0IG9mIHN1YnNjcmlwdGlvbnMgdGhhdCB3aWxsXG4gICAgICogdW5zdWJzY3JpYmUgZHVyaW5nIHRoZSB1bnN1YnNjcmliZSBwcm9jZXNzIG9mIHRoaXMgU3Vic2NyaXB0aW9uLlxuICAgICAqIEBwYXJhbSB7U3Vic2NyaXB0aW9ufSBzdWJzY3JpcHRpb24gVGhlIHN1YnNjcmlwdGlvbiB0byByZW1vdmUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbkluZGV4ID0gc3Vic2NyaXB0aW9ucy5pbmRleE9mKHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2Uoc3Vic2NyaXB0aW9uSW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9hZGRQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF9wYXJlbnQgPSBfYS5fcGFyZW50LCBfcGFyZW50cyA9IF9hLl9wYXJlbnRzO1xuICAgICAgICBpZiAoIV9wYXJlbnQgfHwgX3BhcmVudCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcGFyZW50LCBvciB0aGUgbmV3IHBhcmVudCBpcyB0aGUgc2FtZSBhcyB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgcGFyZW50LCB0aGVuIHNldCB0aGlzLl9wYXJlbnQgdG8gdGhlIG5ldyBwYXJlbnQuXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIV9wYXJlbnRzKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGFscmVhZHkgb25lIHBhcmVudCwgYnV0IG5vdCBtdWx0aXBsZSwgYWxsb2NhdGUgYW4gQXJyYXkgdG9cbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSByZXN0IG9mIHRoZSBwYXJlbnQgU3Vic2NyaXB0aW9ucy5cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudHMgPSBbcGFyZW50XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfcGFyZW50cy5pbmRleE9mKHBhcmVudCkgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGFkZCB0aGUgbmV3IHBhcmVudCB0byB0aGUgX3BhcmVudHMgbGlzdCBpZiBpdCdzIG5vdCBhbHJlYWR5IHRoZXJlLlxuICAgICAgICAgICAgX3BhcmVudHMucHVzaChwYXJlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24uRU1QVFkgPSAoZnVuY3Rpb24gKGVtcHR5KSB7XG4gICAgICAgIGVtcHR5LmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9KG5ldyBTdWJzY3JpcHRpb24oKSkpO1xuICAgIHJldHVybiBTdWJzY3JpcHRpb247XG59KCkpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb247XG5mdW5jdGlvbiBmbGF0dGVuVW5zdWJzY3JpcHRpb25FcnJvcnMoZXJyb3JzKSB7XG4gICAgcmV0dXJuIGVycm9ycy5yZWR1Y2UoZnVuY3Rpb24gKGVycnMsIGVycikgeyByZXR1cm4gZXJycy5jb25jYXQoKGVyciBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKSA/IGVyci5lcnJvcnMgOiBlcnIpOyB9LCBbXSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgU2NhbGFyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9TY2FsYXJPYnNlcnZhYmxlJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0VtcHR5T2JzZXJ2YWJsZScpO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEFycmF5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5T2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgaWYgKCFzY2hlZHVsZXIgJiYgYXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NjYWxhciA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gYXJyYXlbMF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXJyYXlPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChhcnJheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgc29tZSB2YWx1ZXMgeW91IHNwZWNpZnkgYXMgYXJndW1lbnRzLFxuICAgICAqIGltbWVkaWF0ZWx5IG9uZSBhZnRlciB0aGUgb3RoZXIsIGFuZCB0aGVuIGVtaXRzIGEgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkVtaXRzIHRoZSBhcmd1bWVudHMgeW91IHByb3ZpZGUsIHRoZW4gY29tcGxldGVzLlxuICAgICAqIDwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvb2YucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBUaGlzIHN0YXRpYyBvcGVyYXRvciBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIGEgc2ltcGxlIE9ic2VydmFibGUgdGhhdCBvbmx5XG4gICAgICogZW1pdHMgdGhlIGFyZ3VtZW50cyBnaXZlbiwgYW5kIHRoZSBjb21wbGV0ZSBub3RpZmljYXRpb24gdGhlcmVhZnRlci4gSXQgY2FuXG4gICAgICogYmUgdXNlZCBmb3IgY29tcG9zaW5nIHdpdGggb3RoZXIgT2JzZXJ2YWJsZXMsIHN1Y2ggYXMgd2l0aCB7QGxpbmsgY29uY2F0fS5cbiAgICAgKiBCeSBkZWZhdWx0LCBpdCB1c2VzIGEgYG51bGxgIElTY2hlZHVsZXIsIHdoaWNoIG1lYW5zIHRoZSBgbmV4dGBcbiAgICAgKiBub3RpZmljYXRpb25zIGFyZSBzZW50IHN5bmNocm9ub3VzbHksIGFsdGhvdWdoIHdpdGggYSBkaWZmZXJlbnQgSVNjaGVkdWxlclxuICAgICAqIGl0IGlzIHBvc3NpYmxlIHRvIGRldGVybWluZSB3aGVuIHRob3NlIG5vdGlmaWNhdGlvbnMgd2lsbCBiZSBkZWxpdmVyZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IDEwLCAyMCwgMzAsIHRoZW4gJ2EnLCAnYicsICdjJywgdGhlbiBzdGFydCB0aWNraW5nIGV2ZXJ5IHNlY29uZC48L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKDEwLCAyMCwgMzApO1xuICAgICAqIHZhciBsZXR0ZXJzID0gUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKTtcbiAgICAgKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgICAqIHZhciByZXN1bHQgPSBudW1iZXJzLmNvbmNhdChsZXR0ZXJzKS5jb25jYXQoaW50ZXJ2YWwpO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGV9XG4gICAgICogQHNlZSB7QGxpbmsgZW1wdHl9XG4gICAgICogQHNlZSB7QGxpbmsgbmV2ZXJ9XG4gICAgICogQHNlZSB7QGxpbmsgdGhyb3d9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLlR9IHZhbHVlcyBBcmd1bWVudHMgdGhhdCByZXByZXNlbnQgYG5leHRgIHZhbHVlcyB0byBiZSBlbWl0dGVkLlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZW1pc3Npb25zIG9mIHRoZSBgbmV4dGAgbm90aWZpY2F0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgZWFjaCBnaXZlbiBpbnB1dCB2YWx1ZS5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBvZlxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgQXJyYXlPYnNlcnZhYmxlLm9mID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFycmF5W19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSkge1xuICAgICAgICAgICAgYXJyYXkucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2NhbGFyT2JzZXJ2YWJsZV8xLlNjYWxhck9ic2VydmFibGUoYXJyYXlbMF0sIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBcnJheU9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gc3RhdGUuYXJyYXksIGluZGV4ID0gc3RhdGUuaW5kZXgsIGNvdW50ID0gc3RhdGUuY291bnQsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICBpZiAoaW5kZXggPj0gY291bnQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlbaW5kZXhdKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUpO1xuICAgIH07XG4gICAgQXJyYXlPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgdmFyIGNvdW50ID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoQXJyYXlPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgYXJyYXk6IGFycmF5LCBpbmRleDogaW5kZXgsIGNvdW50OiBjb3VudCwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICYmICFzdWJzY3JpYmVyLmNsb3NlZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFycmF5T2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuQXJyYXlPYnNlcnZhYmxlID0gQXJyYXlPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXlPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogQGNsYXNzIENvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPlxuICovXG52YXIgQ29ubmVjdGFibGVPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29ubmVjdGFibGVPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbm5lY3RhYmxlT2JzZXJ2YWJsZShzb3VyY2UsIHN1YmplY3RGYWN0b3J5KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5zdWJqZWN0RmFjdG9yeSA9IHN1YmplY3RGYWN0b3J5O1xuICAgICAgICB0aGlzLl9yZWZDb3VudCA9IDA7XG4gICAgfVxuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN1YmplY3QoKS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLmdldFN1YmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5fc3ViamVjdDtcbiAgICAgICAgaWYgKCFzdWJqZWN0IHx8IHN1YmplY3QuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJqZWN0ID0gdGhpcy5zdWJqZWN0RmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJqZWN0O1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb247XG4gICAgICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgICAgICAgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb24gPSBuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICBjb25uZWN0aW9uLmFkZCh0aGlzLnNvdXJjZVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUobmV3IENvbm5lY3RhYmxlU3Vic2NyaWJlcih0aGlzLmdldFN1YmplY3QoKSwgdGhpcykpKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVmQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFJlZkNvdW50T3BlcmF0b3IodGhpcykpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbm5lY3RhYmxlT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuQ29ubmVjdGFibGVPYnNlcnZhYmxlID0gQ29ubmVjdGFibGVPYnNlcnZhYmxlO1xuZXhwb3J0cy5jb25uZWN0YWJsZU9ic2VydmFibGVEZXNjcmlwdG9yID0ge1xuICAgIG9wZXJhdG9yOiB7IHZhbHVlOiBudWxsIH0sXG4gICAgX3JlZkNvdW50OiB7IHZhbHVlOiAwLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgIF9zdWJqZWN0OiB7IHZhbHVlOiBudWxsLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgIF9jb25uZWN0aW9uOiB7IHZhbHVlOiBudWxsLCB3cml0YWJsZTogdHJ1ZSB9LFxuICAgIF9zdWJzY3JpYmU6IHsgdmFsdWU6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSB9LFxuICAgIGdldFN1YmplY3Q6IHsgdmFsdWU6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuZ2V0U3ViamVjdCB9LFxuICAgIGNvbm5lY3Q6IHsgdmFsdWU6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29ubmVjdCB9LFxuICAgIHJlZkNvdW50OiB7IHZhbHVlOiBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLnJlZkNvdW50IH1cbn07XG52YXIgQ29ubmVjdGFibGVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29ubmVjdGFibGVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbm5lY3RhYmxlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY29ubmVjdGFibGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gY29ubmVjdGFibGU7XG4gICAgfVxuICAgIENvbm5lY3RhYmxlU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9lcnJvci5jYWxsKHRoaXMsIGVycik7XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubmVjdGFibGUgPSB0aGlzLmNvbm5lY3RhYmxlO1xuICAgICAgICBpZiAoY29ubmVjdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5fY29ubmVjdGlvbjtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9yZWZDb3VudCA9IDA7XG4gICAgICAgICAgICBjb25uZWN0YWJsZS5fc3ViamVjdCA9IG51bGw7XG4gICAgICAgICAgICBjb25uZWN0YWJsZS5fY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENvbm5lY3RhYmxlU3Vic2NyaWJlcjtcbn0oU3ViamVjdF8xLlN1YmplY3RTdWJzY3JpYmVyKSk7XG52YXIgUmVmQ291bnRPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVmQ291bnRPcGVyYXRvcihjb25uZWN0YWJsZSkge1xuICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gY29ubmVjdGFibGU7XG4gICAgfVxuICAgIFJlZkNvdW50T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGNvbm5lY3RhYmxlLl9yZWZDb3VudCsrO1xuICAgICAgICB2YXIgcmVmQ291bnRlciA9IG5ldyBSZWZDb3VudFN1YnNjcmliZXIoc3Vic2NyaWJlciwgY29ubmVjdGFibGUpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShyZWZDb3VudGVyKTtcbiAgICAgICAgaWYgKCFyZWZDb3VudGVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmVmQ291bnRlci5jb25uZWN0aW9uID0gY29ubmVjdGFibGUuY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gUmVmQ291bnRPcGVyYXRvcjtcbn0oKSk7XG52YXIgUmVmQ291bnRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVmQ291bnRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZkNvdW50U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY29ubmVjdGFibGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gY29ubmVjdGFibGU7XG4gICAgfVxuICAgIFJlZkNvdW50U3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29ubmVjdGFibGUgPSB0aGlzLmNvbm5lY3RhYmxlO1xuICAgICAgICBpZiAoIWNvbm5lY3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBudWxsO1xuICAgICAgICB2YXIgcmVmQ291bnQgPSBjb25uZWN0YWJsZS5fcmVmQ291bnQ7XG4gICAgICAgIGlmIChyZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3RhYmxlLl9yZWZDb3VudCA9IHJlZkNvdW50IC0gMTtcbiAgICAgICAgaWYgKHJlZkNvdW50ID4gMSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLy9cbiAgICAgICAgLy8gQ29tcGFyZSB0aGUgbG9jYWwgUmVmQ291bnRTdWJzY3JpYmVyJ3MgY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gdG8gdGhlXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIG9uIHRoZSBzaGFyZWQgQ29ubmVjdGFibGVPYnNlcnZhYmxlLiBJbiBjYXNlc1xuICAgICAgICAvLyB3aGVyZSB0aGUgQ29ubmVjdGFibGVPYnNlcnZhYmxlIHNvdXJjZSBzeW5jaHJvbm91c2x5IGVtaXRzIHZhbHVlcywgYW5kXG4gICAgICAgIC8vIHRoZSBSZWZDb3VudFN1YnNjcmliZXIncyBkb3duc3RyZWFtIE9ic2VydmVycyBzeW5jaHJvbm91c2x5IHVuc3Vic2NyaWJlLFxuICAgICAgICAvLyBleGVjdXRpb24gY29udGludWVzIHRvIGhlcmUgYmVmb3JlIHRoZSBSZWZDb3VudE9wZXJhdG9yIGhhcyBhIGNoYW5jZSB0b1xuICAgICAgICAvLyBzdXBwbHkgdGhlIFJlZkNvdW50U3Vic2NyaWJlciB3aXRoIHRoZSBzaGFyZWQgY29ubmVjdGlvbiBTdWJzY3JpcHRpb24uXG4gICAgICAgIC8vIEZvciBleGFtcGxlOlxuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gT2JzZXJ2YWJsZS5yYW5nZSgwLCAxMClcbiAgICAgICAgLy8gICAucHVibGlzaCgpXG4gICAgICAgIC8vICAgLnJlZkNvdW50KClcbiAgICAgICAgLy8gICAudGFrZSg1KVxuICAgICAgICAvLyAgIC5zdWJzY3JpYmUoKTtcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vIEluIG9yZGVyIHRvIGFjY291bnQgZm9yIHRoaXMgY2FzZSwgUmVmQ291bnRTdWJzY3JpYmVyIHNob3VsZCBvbmx5IGRpc3Bvc2VcbiAgICAgICAgLy8gdGhlIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSdzIHNoYXJlZCBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiBpZiB0aGVcbiAgICAgICAgLy8gY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gZXhpc3RzLCAqYW5kKiBlaXRoZXI6XG4gICAgICAgIC8vICAgYS4gUmVmQ291bnRTdWJzY3JpYmVyIGRvZXNuJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgc2hhcmVkIGNvbm5lY3Rpb25cbiAgICAgICAgLy8gICAgICBTdWJzY3JpcHRpb24geWV0LCBvcixcbiAgICAgICAgLy8gICBiLiBSZWZDb3VudFN1YnNjcmliZXIncyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiByZWZlcmVuY2UgaXMgaWRlbnRpY2FsXG4gICAgICAgIC8vICAgICAgdG8gdGhlIHNoYXJlZCBjb25uZWN0aW9uIFN1YnNjcmlwdGlvblxuICAgICAgICAvLy9cbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb247XG4gICAgICAgIHZhciBzaGFyZWRDb25uZWN0aW9uID0gY29ubmVjdGFibGUuX2Nvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIGlmIChzaGFyZWRDb25uZWN0aW9uICYmICghY29ubmVjdGlvbiB8fCBzaGFyZWRDb25uZWN0aW9uID09PSBjb25uZWN0aW9uKSkge1xuICAgICAgICAgICAgc2hhcmVkQ29ubmVjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUmVmQ291bnRTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29ubmVjdGFibGVPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBFbXB0eU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbXB0eU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG5vIGl0ZW1zIHRvIHRoZSBPYnNlcnZlciBhbmQgaW1tZWRpYXRlbHlcbiAgICAgKiBlbWl0cyBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5KdXN0IGVtaXRzICdjb21wbGV0ZScsIGFuZCBub3RoaW5nIGVsc2UuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9lbXB0eS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uLiBJdCBjYW4gYmUgdXNlZCBmb3IgY29tcG9zaW5nIHdpdGggb3RoZXJcbiAgICAgKiBPYnNlcnZhYmxlcywgc3VjaCBhcyBpbiBhIHtAbGluayBtZXJnZU1hcH0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBudW1iZXIgNywgdGhlbiBjb21wbGV0ZS48L2NhcHRpb24+XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZW1wdHkoKS5zdGFydFdpdGgoNyk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBhbmQgZmxhdHRlbiBvbmx5IG9kZCBudW1iZXJzIHRvIHRoZSBzZXF1ZW5jZSAnYScsICdiJywgJ2MnPC9jYXB0aW9uPlxuICAgICAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogdmFyIHJlc3VsdCA9IGludGVydmFsLm1lcmdlTWFwKHggPT5cbiAgICAgKiAgIHggJSAyID09PSAxID8gUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKSA6IFJ4Lk9ic2VydmFibGUuZW1wdHkoKVxuICAgICAqICk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZyB0byB0aGUgY29uc29sZTpcbiAgICAgKiAvLyB4IGlzIGVxdWFsIHRvIHRoZSBjb3VudCBvbiB0aGUgaW50ZXJ2YWwgZWcoMCwxLDIsMywuLi4pXG4gICAgICogLy8geCB3aWxsIG9jY3VyIGV2ZXJ5IDEwMDBtc1xuICAgICAqIC8vIGlmIHggJSAyIGlzIGVxdWFsIHRvIDEgcHJpbnQgYWJjXG4gICAgICogLy8gaWYgeCAlIDIgaXMgbm90IGVxdWFsIHRvIDEgbm90aGluZyB3aWxsIGJlIG91dHB1dFxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIG5ldmVyfVxuICAgICAqIEBzZWUge0BsaW5rIG9mfVxuICAgICAqIEBzZWUge0BsaW5rIHRocm93fVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEEge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbiBvZiB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIFwiZW1wdHlcIiBPYnNlcnZhYmxlOiBlbWl0cyBvbmx5IHRoZSBjb21wbGV0ZVxuICAgICAqIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBlbXB0eVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRW1wdHlPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIEVtcHR5T2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlcjtcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRW1wdHlPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEVtcHR5T2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwgeyBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRW1wdHlPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5FbXB0eU9ic2VydmFibGUgPSBFbXB0eU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbXB0eU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmouYWRkTGlzdGVuZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzSlF1ZXJ5U3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmoub24gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5vZmYgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc05vZGVMaXN0KHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0b1N0cmluZy5jYWxsKHNvdXJjZU9iaikgPT09ICdbb2JqZWN0IE5vZGVMaXN0XSc7XG59XG5mdW5jdGlvbiBpc0hUTUxDb2xsZWN0aW9uKHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0b1N0cmluZy5jYWxsKHNvdXJjZU9iaikgPT09ICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXSc7XG59XG5mdW5jdGlvbiBpc0V2ZW50VGFyZ2V0KHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0eXBlb2Ygc291cmNlT2JqLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5yZW1vdmVFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBGcm9tRXZlbnRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnJvbUV2ZW50T2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGcm9tRXZlbnRPYnNlcnZhYmxlKHNvdXJjZU9iaiwgZXZlbnROYW1lLCBzZWxlY3Rvciwgb3B0aW9ucykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zb3VyY2VPYmogPSBzb3VyY2VPYmo7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgZXZlbnRzIG9mIGEgc3BlY2lmaWMgdHlwZSBjb21pbmcgZnJvbSB0aGVcbiAgICAgKiBnaXZlbiBldmVudCB0YXJnZXQuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q3JlYXRlcyBhbiBPYnNlcnZhYmxlIGZyb20gRE9NIGV2ZW50cywgb3IgTm9kZVxuICAgICAqIEV2ZW50RW1pdHRlciBldmVudHMgb3Igb3RoZXJzLjwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvZnJvbUV2ZW50LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGJ5IGF0dGFjaGluZyBhbiBldmVudCBsaXN0ZW5lciB0byBhbiBcImV2ZW50IHRhcmdldFwiLFxuICAgICAqIHdoaWNoIG1heSBiZSBhbiBvYmplY3Qgd2l0aCBgYWRkRXZlbnRMaXN0ZW5lcmAgYW5kIGByZW1vdmVFdmVudExpc3RlbmVyYCxcbiAgICAgKiBhIE5vZGUuanMgRXZlbnRFbWl0dGVyLCBhIGpRdWVyeSBzdHlsZSBFdmVudEVtaXR0ZXIsIGEgTm9kZUxpc3QgZnJvbSB0aGVcbiAgICAgKiBET00sIG9yIGFuIEhUTUxDb2xsZWN0aW9uIGZyb20gdGhlIERPTS4gVGhlIGV2ZW50IGhhbmRsZXIgaXMgYXR0YWNoZWQgd2hlblxuICAgICAqIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkLCBhbmQgcmVtb3ZlZCB3aGVuIHRoZSBTdWJzY3JpcHRpb24gaXNcbiAgICAgKiB1bnN1YnNjcmliZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyBjbGlja3MgaGFwcGVuaW5nIG9uIHRoZSBET00gZG9jdW1lbnQ8L2NhcHRpb24+XG4gICAgICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAgICAgKiBjbGlja3Muc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogLy8gUmVzdWx0cyBpbjpcbiAgICAgKiAvLyBNb3VzZUV2ZW50IG9iamVjdCBsb2dnZWQgdG8gY29uc29sZSBldmVyeXRpbWUgYSBjbGlja1xuICAgICAqIC8vIG9jY3VycyBvbiB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBmcm9tfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21FdmVudFBhdHRlcm59XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IFRoZSBET01FbGVtZW50LCBldmVudCB0YXJnZXQsIE5vZGUuanNcbiAgICAgKiBFdmVudEVtaXR0ZXIsIE5vZGVMaXN0IG9yIEhUTUxDb2xsZWN0aW9uIHRvIGF0dGFjaCB0aGUgZXZlbnQgaGFuZGxlciB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIG9mIGludGVyZXN0LCBiZWluZyBlbWl0dGVkIGJ5IHRoZVxuICAgICAqIGB0YXJnZXRgLlxuICAgICAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdGhyb3VnaCB0byBhZGRFdmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtIHtTZWxlY3Rvck1ldGhvZFNpZ25hdHVyZTxUPn0gW3NlbGVjdG9yXSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0b1xuICAgICAqIHBvc3QtcHJvY2VzcyByZXN1bHRzLiBJdCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGV2ZW50IGhhbmRsZXIgYW5kXG4gICAgICogc2hvdWxkIHJldHVybiBhIHNpbmdsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fVxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGZyb21FdmVudFxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUsIG9wdGlvbnMsIHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyb21FdmVudE9ic2VydmFibGUodGFyZ2V0LCBldmVudE5hbWUsIHNlbGVjdG9yLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIEZyb21FdmVudE9ic2VydmFibGUuc2V0dXBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc291cmNlT2JqLCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlO1xuICAgICAgICBpZiAoaXNOb2RlTGlzdChzb3VyY2VPYmopIHx8IGlzSFRNTENvbGxlY3Rpb24oc291cmNlT2JqKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZU9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIEZyb21FdmVudE9ic2VydmFibGUuc2V0dXBTdWJzY3JpcHRpb24oc291cmNlT2JqW2ldLCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRXZlbnRUYXJnZXQoc291cmNlT2JqKSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZV8xID0gc291cmNlT2JqO1xuICAgICAgICAgICAgc291cmNlT2JqLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlXzEucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSlF1ZXJ5U3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZV8yID0gc291cmNlT2JqO1xuICAgICAgICAgICAgc291cmNlT2JqLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZV8yLm9mZihldmVudE5hbWUsIGhhbmRsZXIpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTm9kZVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iaikpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VfMyA9IHNvdXJjZU9iajtcbiAgICAgICAgICAgIHNvdXJjZU9iai5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2VfMy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBldmVudCB0YXJnZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLmFkZChuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSk7XG4gICAgfTtcbiAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNvdXJjZU9iaiA9IHRoaXMuc291cmNlT2JqO1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gdGhpcy5ldmVudE5hbWU7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICB2YXIgaGFuZGxlciA9IHNlbGVjdG9yID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHNlbGVjdG9yKS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHN1YnNjcmliZXIubmV4dChlKTsgfTtcbiAgICAgICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5zZXR1cFN1YnNjcmlwdGlvbihzb3VyY2VPYmosIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gRnJvbUV2ZW50T2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRnJvbUV2ZW50T2JzZXJ2YWJsZSA9IEZyb21FdmVudE9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gcm9tRXZlbnRPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBTY2FsYXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2NhbGFyT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY2FsYXJPYnNlcnZhYmxlKHZhbHVlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgdGhpcy5faXNTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTY2FsYXJPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NhbGFyT2JzZXJ2YWJsZSh2YWx1ZSwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFNjYWxhck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGRvbmUgPSBzdGF0ZS5kb25lLCB2YWx1ZSA9IHN0YXRlLnZhbHVlLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBTY2FsYXJPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKFNjYWxhck9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSwgdmFsdWU6IHZhbHVlLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2NhbGFyT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuU2NhbGFyT2JzZXJ2YWJsZSA9IFNjYWxhck9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY2FsYXJPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNOdW1lcmljXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzTnVtZXJpYycpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbnZhciBpc0RhdGVfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNEYXRlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIFRpbWVyT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRpbWVyT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaW1lck9ic2VydmFibGUoZHVlVGltZSwgcGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKGR1ZVRpbWUgPT09IHZvaWQgMCkgeyBkdWVUaW1lID0gMDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wZXJpb2QgPSAtMTtcbiAgICAgICAgdGhpcy5kdWVUaW1lID0gMDtcbiAgICAgICAgaWYgKGlzTnVtZXJpY18xLmlzTnVtZXJpYyhwZXJpb2QpKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmlvZCA9IE51bWJlcihwZXJpb2QpIDwgMSAmJiAxIHx8IE51bWJlcihwZXJpb2QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIocGVyaW9kKSkge1xuICAgICAgICAgICAgc2NoZWR1bGVyID0gcGVyaW9kO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSBpc0RhdGVfMS5pc0RhdGUoZHVlVGltZSkgP1xuICAgICAgICAgICAgKCtkdWVUaW1lIC0gdGhpcy5zY2hlZHVsZXIubm93KCkpIDpcbiAgICAgICAgICAgIGR1ZVRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IHN0YXJ0cyBlbWl0dGluZyBhZnRlciBhbiBgaW5pdGlhbERlbGF5YCBhbmRcbiAgICAgKiBlbWl0cyBldmVyIGluY3JlYXNpbmcgbnVtYmVycyBhZnRlciBlYWNoIGBwZXJpb2RgIG9mIHRpbWUgdGhlcmVhZnRlci5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdHMgbGlrZSB7QGxpbmsgaW50ZXJ2YWx9LCBidXQgeW91IGNhbiBzcGVjaWZ5IHdoZW5cbiAgICAgKiBzaG91bGQgdGhlIGVtaXNzaW9ucyBzdGFydC48L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL3RpbWVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogYHRpbWVyYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbiBpbmZpbml0ZSBzZXF1ZW5jZSBvZiBhc2NlbmRpbmdcbiAgICAgKiBpbnRlZ2Vycywgd2l0aCBhIGNvbnN0YW50IGludGVydmFsIG9mIHRpbWUsIGBwZXJpb2RgIG9mIHlvdXIgY2hvb3NpbmdcbiAgICAgKiBiZXR3ZWVuIHRob3NlIGVtaXNzaW9ucy4gVGhlIGZpcnN0IGVtaXNzaW9uIGhhcHBlbnMgYWZ0ZXIgdGhlIHNwZWNpZmllZFxuICAgICAqIGBpbml0aWFsRGVsYXlgLiBUaGUgaW5pdGlhbCBkZWxheSBtYXkgYmUgYSB7QGxpbmsgRGF0ZX0uIEJ5IGRlZmF1bHQsIHRoaXNcbiAgICAgKiBvcGVyYXRvciB1c2VzIHRoZSBgYXN5bmNgIElTY2hlZHVsZXIgdG8gcHJvdmlkZSBhIG5vdGlvbiBvZiB0aW1lLCBidXQgeW91XG4gICAgICogbWF5IHBhc3MgYW55IElTY2hlZHVsZXIgdG8gaXQuIElmIGBwZXJpb2RgIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBvdXRwdXRcbiAgICAgKiBPYnNlcnZhYmxlIGVtaXRzIG9ubHkgb25lIHZhbHVlLCBgMGAuIE90aGVyd2lzZSwgaXQgZW1pdHMgYW4gaW5maW5pdGVcbiAgICAgKiBzZXF1ZW5jZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGFzY2VuZGluZyBudW1iZXJzLCBvbmUgZXZlcnkgc2Vjb25kICgxMDAwbXMpLCBzdGFydGluZyBhZnRlciAzIHNlY29uZHM8L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLnRpbWVyKDMwMDAsIDEwMDApO1xuICAgICAqIG51bWJlcnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgb25lIG51bWJlciBhZnRlciBmaXZlIHNlY29uZHM8L2NhcHRpb24+XG4gICAgICogdmFyIG51bWJlcnMgPSBSeC5PYnNlcnZhYmxlLnRpbWVyKDUwMDApO1xuICAgICAqIG51bWJlcnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgaW50ZXJ2YWx9XG4gICAgICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxEYXRlfSBpbml0aWFsRGVsYXkgVGhlIGluaXRpYWwgZGVsYXkgdGltZSB0byB3YWl0IGJlZm9yZVxuICAgICAqIGVtaXR0aW5nIHRoZSBmaXJzdCB2YWx1ZSBvZiBgMGAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwZXJpb2RdIFRoZSBwZXJpb2Qgb2YgdGltZSBiZXR3ZWVuIGVtaXNzaW9ucyBvZiB0aGVcbiAgICAgKiBzdWJzZXF1ZW50IG51bWJlcnMuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbiBvZiB2YWx1ZXMsIGFuZCBwcm92aWRpbmcgYSBub3Rpb24gb2YgXCJ0aW1lXCIuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgYDBgIGFmdGVyIHRoZVxuICAgICAqIGBpbml0aWFsRGVsYXlgIGFuZCBldmVyIGluY3JlYXNpbmcgbnVtYmVycyBhZnRlciBlYWNoIGBwZXJpb2RgIG9mIHRpbWVcbiAgICAgKiB0aGVyZWFmdGVyLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIHRpbWVyXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBUaW1lck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGluaXRpYWxEZWxheSwgcGVyaW9kLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgaWYgKGluaXRpYWxEZWxheSA9PT0gdm9pZCAwKSB7IGluaXRpYWxEZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lck9ic2VydmFibGUoaW5pdGlhbERlbGF5LCBwZXJpb2QsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBUaW1lck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgsIHBlcmlvZCA9IHN0YXRlLnBlcmlvZCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzO1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQoaW5kZXgpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwZXJpb2QgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBhY3Rpb24uc2NoZWR1bGUoc3RhdGUsIHBlcmlvZCk7XG4gICAgfTtcbiAgICBUaW1lck9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwZXJpb2QgPSBfYS5wZXJpb2QsIGR1ZVRpbWUgPSBfYS5kdWVUaW1lLCBzY2hlZHVsZXIgPSBfYS5zY2hlZHVsZXI7XG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoVGltZXJPYnNlcnZhYmxlLmRpc3BhdGNoLCBkdWVUaW1lLCB7XG4gICAgICAgICAgICBpbmRleDogaW5kZXgsIHBlcmlvZDogcGVyaW9kLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRpbWVyT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuVGltZXJPYnNlcnZhYmxlID0gVGltZXJPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGltZXJPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9FbXB0eU9ic2VydmFibGUnKTtcbmV4cG9ydHMuZW1wdHkgPSBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1wdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRnJvbUV2ZW50T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9Gcm9tRXZlbnRPYnNlcnZhYmxlJyk7XG5leHBvcnRzLmZyb21FdmVudCA9IEZyb21FdmVudE9ic2VydmFibGVfMS5Gcm9tRXZlbnRPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21FdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vQXJyYXlPYnNlcnZhYmxlJyk7XG5leHBvcnRzLm9mID0gQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlLm9mO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgVGltZXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1RpbWVyT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy50aW1lciA9IFRpbWVyT2JzZXJ2YWJsZV8xLlRpbWVyT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQ2F0Y2hlcyBlcnJvcnMgb24gdGhlIG9ic2VydmFibGUgdG8gYmUgaGFuZGxlZCBieSByZXR1cm5pbmcgYSBuZXcgb2JzZXJ2YWJsZSBvciB0aHJvd2luZyBhbiBlcnJvci5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NhdGNoLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbnRpbnVlcyB3aXRoIGEgZGlmZmVyZW50IE9ic2VydmFibGUgd2hlbiB0aGVyZSdzIGFuIGVycm9yPC9jYXB0aW9uPlxuICpcbiAqIE9ic2VydmFibGUub2YoMSwgMiwgMywgNCwgNSlcbiAqICAgLm1hcChuID0+IHtcbiAqIFx0ICAgaWYgKG4gPT0gNCkge1xuICogXHQgICAgIHRocm93ICdmb3VyISc7XG4gKiAgICAgfVxuICpcdCAgIHJldHVybiBuO1xuICogICB9KVxuICogICAuY2F0Y2goZXJyID0+IE9ic2VydmFibGUub2YoJ0knLCAnSUknLCAnSUlJJywgJ0lWJywgJ1YnKSlcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqICAgLy8gMSwgMiwgMywgSSwgSUksIElJSSwgSVYsIFZcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZXRyaWVzIHRoZSBjYXVnaHQgc291cmNlIE9ic2VydmFibGUgYWdhaW4gaW4gY2FzZSBvZiBlcnJvciwgc2ltaWxhciB0byByZXRyeSgpIG9wZXJhdG9yPC9jYXB0aW9uPlxuICpcbiAqIE9ic2VydmFibGUub2YoMSwgMiwgMywgNCwgNSlcbiAqICAgLm1hcChuID0+IHtcbiAqIFx0ICAgaWYgKG4gPT09IDQpIHtcbiAqIFx0ICAgICB0aHJvdyAnZm91ciEnO1xuICogICAgIH1cbiAqIFx0ICAgcmV0dXJuIG47XG4gKiAgIH0pXG4gKiAgIC5jYXRjaCgoZXJyLCBjYXVnaHQpID0+IGNhdWdodClcbiAqICAgLnRha2UoMzApXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiAgIC8vIDEsIDIsIDMsIDEsIDIsIDMsIC4uLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRocm93cyBhIG5ldyBlcnJvciB3aGVuIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aHJvd3MgYW4gZXJyb3I8L2NhcHRpb24+XG4gKlxuICogT2JzZXJ2YWJsZS5vZigxLCAyLCAzLCA0LCA1KVxuICogICAubWFwKG4gPT4ge1xuICogICAgIGlmIChuID09IDQpIHtcbiAqICAgICAgIHRocm93ICdmb3VyISc7XG4gKiAgICAgfVxuICogICAgIHJldHVybiBuO1xuICogICB9KVxuICogICAuY2F0Y2goZXJyID0+IHtcbiAqICAgICB0aHJvdyAnZXJyb3IgaW4gc291cmNlLiBEZXRhaWxzOiAnICsgZXJyO1xuICogICB9KVxuICogICAuc3Vic2NyaWJlKFxuICogICAgIHggPT4gY29uc29sZS5sb2coeCksXG4gKiAgICAgZXJyID0+IGNvbnNvbGUubG9nKGVycilcbiAqICAgKTtcbiAqICAgLy8gMSwgMiwgMywgZXJyb3IgaW4gc291cmNlLiBEZXRhaWxzOiBmb3VyIVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHNlbGVjdG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhcyBhcmd1bWVudHMgYGVycmAsIHdoaWNoIGlzIHRoZSBlcnJvciwgYW5kIGBjYXVnaHRgLCB3aGljaFxuICogIGlzIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSwgaW4gY2FzZSB5b3UnZCBsaWtlIHRvIFwicmV0cnlcIiB0aGF0IG9ic2VydmFibGUgYnkgcmV0dXJuaW5nIGl0IGFnYWluLiBXaGF0ZXZlciBvYnNlcnZhYmxlXG4gKiAgaXMgcmV0dXJuZWQgYnkgdGhlIGBzZWxlY3RvcmAgd2lsbCBiZSB1c2VkIHRvIGNvbnRpbnVlIHRoZSBvYnNlcnZhYmxlIGNoYWluLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSB0aGF0IG9yaWdpbmF0ZXMgZnJvbSBlaXRoZXIgdGhlIHNvdXJjZSBvciB0aGUgb2JzZXJ2YWJsZSByZXR1cm5lZCBieSB0aGVcbiAqICBjYXRjaCBgc2VsZWN0b3JgIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBjYXRjaFxuICogQG5hbWUgY2F0Y2hcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9jYXRjaChzZWxlY3Rvcikge1xuICAgIHZhciBvcGVyYXRvciA9IG5ldyBDYXRjaE9wZXJhdG9yKHNlbGVjdG9yKTtcbiAgICB2YXIgY2F1Z2h0ID0gdGhpcy5saWZ0KG9wZXJhdG9yKTtcbiAgICByZXR1cm4gKG9wZXJhdG9yLmNhdWdodCA9IGNhdWdodCk7XG59XG5leHBvcnRzLl9jYXRjaCA9IF9jYXRjaDtcbnZhciBDYXRjaE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXRjaE9wZXJhdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB9XG4gICAgQ2F0Y2hPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IENhdGNoU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnNlbGVjdG9yLCB0aGlzLmNhdWdodCkpO1xuICAgIH07XG4gICAgcmV0dXJuIENhdGNoT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBDYXRjaFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYXRjaFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2F0Y2hTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBzZWxlY3RvciwgY2F1Z2h0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNhdWdodCA9IGNhdWdodDtcbiAgICB9XG4gICAgLy8gTk9URTogb3ZlcnJpZGluZyBgZXJyb3JgIGluc3RlYWQgb2YgYF9lcnJvcmAgYmVjYXVzZSB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaGF2ZSB0aGlzIGZsYWcgdGhpcyBzdWJzY3JpYmVyIGFzIGBpc1N0b3BwZWRgLiBXZSBjYW4gbWltaWMgdGhlXG4gICAgLy8gYmVoYXZpb3Igb2YgdGhlIFJldHJ5U3Vic2NyaWJlciAoZnJvbSB0aGUgYHJldHJ5YCBvcGVyYXRvciksIHdoZXJlXG4gICAgLy8gd2UgdW5zdWJzY3JpYmUgZnJvbSBvdXIgc291cmNlIGNoYWluLCByZXNldCBvdXIgU3Vic2NyaWJlciBmbGFncyxcbiAgICAvLyB0aGVuIHN1YnNjcmliZSB0byB0aGUgc2VsZWN0b3IgcmVzdWx0LlxuICAgIENhdGNoU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuc2VsZWN0b3IoZXJyLCB0aGlzLmNhdWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyMikge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlcnIyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYXRjaFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2F0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlQWxsXzEgPSByZXF1aXJlKCcuL21lcmdlQWxsJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIG91dHB1dCBPYnNlcnZhYmxlIHdoaWNoIHNlcXVlbnRpYWxseSBlbWl0cyBhbGwgdmFsdWVzIGZyb20gZXZlcnlcbiAqIGdpdmVuIGlucHV0IE9ic2VydmFibGUgYWZ0ZXIgdGhlIGN1cnJlbnQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29uY2F0ZW5hdGVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5XG4gKiBzZXF1ZW50aWFsbHkgZW1pdHRpbmcgdGhlaXIgdmFsdWVzLCBvbmUgT2JzZXJ2YWJsZSBhZnRlciB0aGUgb3RoZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEpvaW5zIHRoaXMgT2JzZXJ2YWJsZSB3aXRoIG11bHRpcGxlIG90aGVyIE9ic2VydmFibGVzIGJ5IHN1YnNjcmliaW5nIHRvIHRoZW1cbiAqIG9uZSBhdCBhIHRpbWUsIHN0YXJ0aW5nIHdpdGggdGhlIHNvdXJjZSwgYW5kIG1lcmdpbmcgdGhlaXIgcmVzdWx0cyBpbnRvIHRoZVxuICogb3V0cHV0IE9ic2VydmFibGUuIFdpbGwgd2FpdCBmb3IgZWFjaCBPYnNlcnZhYmxlIHRvIGNvbXBsZXRlIGJlZm9yZSBtb3ZpbmdcbiAqIG9uIHRvIHRoZSBuZXh0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIGEgdGltZXIgY291bnRpbmcgZnJvbSAwIHRvIDMgd2l0aCBhIHN5bmNocm9ub3VzIHNlcXVlbmNlIGZyb20gMSB0byAxMDwvY2FwdGlvbj5cbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KTtcbiAqIHZhciBzZXF1ZW5jZSA9IFJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgMTApO1xuICogdmFyIHJlc3VsdCA9IHRpbWVyLmNvbmNhdChzZXF1ZW5jZSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIHJlc3VsdHMgaW46XG4gKiAvLyAxMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAyIC0xMDAwbXMtPiAzIC1pbW1lZGlhdGUtPiAxIC4uLiAxMFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIDMgT2JzZXJ2YWJsZXM8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIHJlc3VsdCA9IHRpbWVyMS5jb25jYXQodGltZXIyLCB0aW1lcjMpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyByZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAoUHJpbnRzIHRvIGNvbnNvbGUgc2VxdWVudGlhbGx5KVxuICogLy8gLTEwMDBtcy0+IDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IC4uLiA5XG4gKiAvLyAtMjAwMG1zLT4gMCAtMjAwMG1zLT4gMSAtMjAwMG1zLT4gLi4uIDVcbiAqIC8vIC01MDBtcy0+IDAgLTUwMG1zLT4gMSAtNTAwbXMtPiAuLi4gOVxuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIGFmdGVyIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gQW4gb3B0aW9uYWwgSVNjaGVkdWxlciB0byBzY2hlZHVsZSBlYWNoXG4gKiBPYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFsbCB2YWx1ZXMgb2YgZWFjaCBwYXNzZWQgT2JzZXJ2YWJsZSBtZXJnZWQgaW50byBhXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgaW4gb3JkZXIsIGluIHNlcmlhbCBmYXNoaW9uLlxuICogQG1ldGhvZCBjb25jYXRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKGNvbmNhdFN0YXRpYy5hcHBseSh2b2lkIDAsIFt0aGlzXS5jb25jYXQob2JzZXJ2YWJsZXMpKSk7XG59XG5leHBvcnRzLmNvbmNhdCA9IGNvbmNhdDtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENyZWF0ZXMgYW4gb3V0cHV0IE9ic2VydmFibGUgd2hpY2ggc2VxdWVudGlhbGx5IGVtaXRzIGFsbCB2YWx1ZXMgZnJvbSBnaXZlblxuICogT2JzZXJ2YWJsZSBhbmQgdGhlbiBtb3ZlcyBvbiB0byB0aGUgbmV4dC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29uY2F0ZW5hdGVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5XG4gKiBzZXF1ZW50aWFsbHkgZW1pdHRpbmcgdGhlaXIgdmFsdWVzLCBvbmUgT2JzZXJ2YWJsZSBhZnRlciB0aGUgb3RoZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBjb25jYXRgIGpvaW5zIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyLCBieSBzdWJzY3JpYmluZyB0byB0aGVtIG9uZSBhdCBhIHRpbWUgYW5kXG4gKiBtZXJnaW5nIHRoZWlyIHJlc3VsdHMgaW50byB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFlvdSBjYW4gcGFzcyBlaXRoZXIgYW4gYXJyYXkgb2ZcbiAqIE9ic2VydmFibGVzLCBvciBwdXQgdGhlbSBkaXJlY3RseSBhcyBhcmd1bWVudHMuIFBhc3NpbmcgYW4gZW1wdHkgYXJyYXkgd2lsbCByZXN1bHRcbiAqIGluIE9ic2VydmFibGUgdGhhdCBjb21wbGV0ZXMgaW1tZWRpYXRlbHkuXG4gKlxuICogYGNvbmNhdGAgd2lsbCBzdWJzY3JpYmUgdG8gZmlyc3QgaW5wdXQgT2JzZXJ2YWJsZSBhbmQgZW1pdCBhbGwgaXRzIHZhbHVlcywgd2l0aG91dFxuICogY2hhbmdpbmcgb3IgYWZmZWN0aW5nIHRoZW0gaW4gYW55IHdheS4gV2hlbiB0aGF0IE9ic2VydmFibGUgY29tcGxldGVzLCBpdCB3aWxsXG4gKiBzdWJzY3JpYmUgdG8gdGhlbiBuZXh0IE9ic2VydmFibGUgcGFzc2VkIGFuZCwgYWdhaW4sIGVtaXQgaXRzIHZhbHVlcy4gVGhpcyB3aWxsIGJlXG4gKiByZXBlYXRlZCwgdW50aWwgdGhlIG9wZXJhdG9yIHJ1bnMgb3V0IG9mIE9ic2VydmFibGVzLiBXaGVuIGxhc3QgaW5wdXQgT2JzZXJ2YWJsZSBjb21wbGV0ZXMsXG4gKiBgY29uY2F0YCB3aWxsIGNvbXBsZXRlIGFzIHdlbGwuIEF0IGFueSBnaXZlbiBtb21lbnQgb25seSBvbmUgT2JzZXJ2YWJsZSBwYXNzZWQgdG8gb3BlcmF0b3JcbiAqIGVtaXRzIHZhbHVlcy4gSWYgeW91IHdvdWxkIGxpa2UgdG8gZW1pdCB2YWx1ZXMgZnJvbSBwYXNzZWQgT2JzZXJ2YWJsZXMgY29uY3VycmVudGx5LCBjaGVjayBvdXRcbiAqIHtAbGluayBtZXJnZX0gaW5zdGVhZCwgZXNwZWNpYWxseSB3aXRoIG9wdGlvbmFsIGBjb25jdXJyZW50YCBwYXJhbWV0ZXIuIEFzIGEgbWF0dGVyIG9mIGZhY3QsXG4gKiBgY29uY2F0YCBpcyBhbiBlcXVpdmFsZW50IG9mIGBtZXJnZWAgb3BlcmF0b3Igd2l0aCBgY29uY3VycmVudGAgcGFyYW1ldGVyIHNldCB0byBgMWAuXG4gKlxuICogTm90ZSB0aGF0IGlmIHNvbWUgaW5wdXQgT2JzZXJ2YWJsZSBuZXZlciBjb21wbGV0ZXMsIGBjb25jYXRgIHdpbGwgYWxzbyBuZXZlciBjb21wbGV0ZVxuICogYW5kIE9ic2VydmFibGVzIGZvbGxvd2luZyB0aGUgb25lIHRoYXQgZGlkIG5vdCBjb21wbGV0ZSB3aWxsIG5ldmVyIGJlIHN1YnNjcmliZWQuIE9uIHRoZSBvdGhlclxuICogaGFuZCwgaWYgc29tZSBPYnNlcnZhYmxlIHNpbXBseSBjb21wbGV0ZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgc3Vic2NyaWJlZCwgaXQgd2lsbCBiZVxuICogaW52aXNpYmxlIGZvciBgY29uY2F0YCwgd2hpY2ggd2lsbCBqdXN0IG1vdmUgb24gdG8gdGhlIG5leHQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBJZiBhbnkgT2JzZXJ2YWJsZSBpbiBjaGFpbiBlcnJvcnMsIGluc3RlYWQgb2YgcGFzc2luZyBjb250cm9sIHRvIHRoZSBuZXh0IE9ic2VydmFibGUsXG4gKiBgY29uY2F0YCB3aWxsIGVycm9yIGltbWVkaWF0ZWx5IGFzIHdlbGwuIE9ic2VydmFibGVzIHRoYXQgd291bGQgYmUgc3Vic2NyaWJlZCBhZnRlclxuICogdGhlIG9uZSB0aGF0IGVtaXR0ZWQgZXJyb3IsIG5ldmVyIHdpbGwuXG4gKlxuICogSWYgeW91IHBhc3MgdG8gYGNvbmNhdGAgdGhlIHNhbWUgT2JzZXJ2YWJsZSBtYW55IHRpbWVzLCBpdHMgc3RyZWFtIG9mIHZhbHVlc1xuICogd2lsbCBiZSBcInJlcGxheWVkXCIgb24gZXZlcnkgc3Vic2NyaXB0aW9uLCB3aGljaCBtZWFucyB5b3UgY2FuIHJlcGVhdCBnaXZlbiBPYnNlcnZhYmxlXG4gKiBhcyBtYW55IHRpbWVzIGFzIHlvdSBsaWtlLiBJZiBwYXNzaW5nIHRoZSBzYW1lIE9ic2VydmFibGUgdG8gYGNvbmNhdGAgMTAwMCB0aW1lcyBiZWNvbWVzIHRlZGlvdXMsXG4gKiB5b3UgY2FuIGFsd2F5cyB1c2Uge0BsaW5rIHJlcGVhdH0uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgYSB0aW1lciBjb3VudGluZyBmcm9tIDAgdG8gMyB3aXRoIGEgc3luY2hyb25vdXMgc2VxdWVuY2UgZnJvbSAxIHRvIDEwPC9jYXB0aW9uPlxuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpO1xuICogdmFyIHNlcXVlbmNlID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMCk7XG4gKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5jb25jYXQodGltZXIsIHNlcXVlbmNlKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gcmVzdWx0cyBpbjpcbiAqIC8vIDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IDIgLTEwMDBtcy0+IDMgLWltbWVkaWF0ZS0+IDEgLi4uIDEwXG4gKlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIGFuIGFycmF5IG9mIDMgT2JzZXJ2YWJsZXM8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuY29uY2F0KFt0aW1lcjEsIHRpbWVyMiwgdGltZXIzXSk7IC8vIG5vdGUgdGhhdCBhcnJheSBpcyBwYXNzZWRcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gKFByaW50cyB0byBjb25zb2xlIHNlcXVlbnRpYWxseSlcbiAqIC8vIC0xMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAuLi4gOVxuICogLy8gLTIwMDBtcy0+IDAgLTIwMDBtcy0+IDEgLTIwMDBtcy0+IC4uLiA1XG4gKiAvLyAtNTAwbXMtPiAwIC01MDBtcy0+IDEgLTUwMG1zLT4gLi4uIDlcbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgdGhlIHNhbWUgT2JzZXJ2YWJsZSB0byByZXBlYXQgaXQ8L2NhcHRpb24+XG4gKiBjb25zdCB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgyKTtcbiAqXG4gKiBSeC5PYnNlcnZhYmxlLmNvbmNhdCh0aW1lciwgdGltZXIpIC8vIGNvbmNhdGluZyB0aGUgc2FtZSBPYnNlcnZhYmxlIVxuICogLnN1YnNjcmliZShcbiAqICAgdmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpLFxuICogICBlcnIgPT4ge30sXG4gKiAgICgpID0+IGNvbnNvbGUubG9nKCcuLi5hbmQgaXQgaXMgZG9uZSEnKVxuICogKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gMCBhZnRlciAxc1xuICogLy8gMSBhZnRlciAyc1xuICogLy8gMCBhZnRlciAzc1xuICogLy8gMSBhZnRlciA0c1xuICogLy8gXCIuLi5hbmQgaXQgaXMgZG9uZSFcIiBhbHNvIGFmdGVyIDRzXG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IGlucHV0MSBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIHdpdGggb3RoZXJzLlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IGlucHV0MiBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIHdpdGggb3RoZXJzLlxuICogTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBBbiBvcHRpb25hbCBJU2NoZWR1bGVyIHRvIHNjaGVkdWxlIGVhY2hcbiAqIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQWxsIHZhbHVlcyBvZiBlYWNoIHBhc3NlZCBPYnNlcnZhYmxlIG1lcmdlZCBpbnRvIGFcbiAqIHNpbmdsZSBPYnNlcnZhYmxlLCBpbiBvcmRlciwgaW4gc2VyaWFsIGZhc2hpb24uXG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIGNvbmNhdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY29uY2F0U3RhdGljKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgc2NoZWR1bGVyID0gbnVsbDtcbiAgICB2YXIgYXJncyA9IG9ic2VydmFibGVzO1xuICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKGFyZ3Nbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGFyZ3MucG9wKCk7XG4gICAgfVxuICAgIGlmIChzY2hlZHVsZXIgPT09IG51bGwgJiYgb2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxICYmIG9ic2VydmFibGVzWzBdIGluc3RhbmNlb2YgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShvYnNlcnZhYmxlcywgc2NoZWR1bGVyKS5saWZ0KG5ldyBtZXJnZUFsbF8xLk1lcmdlQWxsT3BlcmF0b3IoMSkpO1xufVxuZXhwb3J0cy5jb25jYXRTdGF0aWMgPSBjb25jYXRTdGF0aWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG9ubHkgYWZ0ZXIgYSBwYXJ0aWN1bGFyIHRpbWUgc3BhblxuICogaGFzIHBhc3NlZCB3aXRob3V0IGFub3RoZXIgc291cmNlIGVtaXNzaW9uLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGRlbGF5fSwgYnV0IHBhc3NlcyBvbmx5IHRoZSBtb3N0XG4gKiByZWNlbnQgdmFsdWUgZnJvbSBlYWNoIGJ1cnN0IG9mIGVtaXNzaW9ucy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZWJvdW5jZVRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGRlYm91bmNlVGltZWAgZGVsYXlzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IGRyb3BzXG4gKiBwcmV2aW91cyBwZW5kaW5nIGRlbGF5ZWQgZW1pc3Npb25zIGlmIGEgbmV3IHZhbHVlIGFycml2ZXMgb24gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gVGhpcyBvcGVyYXRvciBrZWVwcyB0cmFjayBvZiB0aGUgbW9zdCByZWNlbnQgdmFsdWUgZnJvbSB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLCBhbmQgZW1pdHMgdGhhdCBvbmx5IHdoZW4gYGR1ZVRpbWVgIGVub3VnaCB0aW1lIGhhcyBwYXNzZWRcbiAqIHdpdGhvdXQgYW55IG90aGVyIHZhbHVlIGFwcGVhcmluZyBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGEgbmV3IHZhbHVlXG4gKiBhcHBlYXJzIGJlZm9yZSBgZHVlVGltZWAgc2lsZW5jZSBvY2N1cnMsIHRoZSBwcmV2aW91cyB2YWx1ZSB3aWxsIGJlIGRyb3BwZWRcbiAqIGFuZCB3aWxsIG5vdCBiZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBUaGlzIGlzIGEgcmF0ZS1saW1pdGluZyBvcGVyYXRvciwgYmVjYXVzZSBpdCBpcyBpbXBvc3NpYmxlIGZvciBtb3JlIHRoYW4gb25lXG4gKiB2YWx1ZSB0byBiZSBlbWl0dGVkIGluIGFueSB0aW1lIHdpbmRvdyBvZiBkdXJhdGlvbiBgZHVlVGltZWAsIGJ1dCBpdCBpcyBhbHNvXG4gKiBhIGRlbGF5LWxpa2Ugb3BlcmF0b3Igc2luY2Ugb3V0cHV0IGVtaXNzaW9ucyBkbyBub3Qgb2NjdXIgYXQgdGhlIHNhbWUgdGltZSBhc1xuICogdGhleSBkaWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBPcHRpb25hbGx5IHRha2VzIGEge0BsaW5rIElTY2hlZHVsZXJ9IGZvclxuICogbWFuYWdpbmcgdGltZXJzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG1vc3QgcmVjZW50IGNsaWNrIGFmdGVyIGEgYnVyc3Qgb2YgY2xpY2tzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZGVib3VuY2VUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICogQHNlZSB7QGxpbmsgc2FtcGxlVGltZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlVGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVlVGltZSBUaGUgdGltZW91dCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRoZSB0aW1lXG4gKiB1bml0IGRldGVybWluZWQgaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmApIGZvciB0aGUgd2luZG93IG9mXG4gKiB0aW1lIHJlcXVpcmVkIHRvIHdhaXQgZm9yIGVtaXNzaW9uIHNpbGVuY2UgYmVmb3JlIGVtaXR0aW5nIHRoZSBtb3N0IHJlY2VudFxuICogc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgdGltZW91dCBmb3IgZWFjaCB2YWx1ZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBkZWxheXMgdGhlIGVtaXNzaW9ucyBvZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGJ5IHRoZSBzcGVjaWZpZWQgYGR1ZVRpbWVgLCBhbmQgbWF5IGRyb3Agc29tZSB2YWx1ZXMgaWYgdGhleSBvY2N1clxuICogdG9vIGZyZXF1ZW50bHkuXG4gKiBAbWV0aG9kIGRlYm91bmNlVGltZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2VUaW1lKGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGVib3VuY2VUaW1lT3BlcmF0b3IoZHVlVGltZSwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLmRlYm91bmNlVGltZSA9IGRlYm91bmNlVGltZTtcbnZhciBEZWJvdW5jZVRpbWVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VUaW1lT3BlcmF0b3IoZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGR1ZVRpbWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBEZWJvdW5jZVRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlYm91bmNlVGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kdWVUaW1lLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIERlYm91bmNlVGltZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGVib3VuY2VUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlYm91bmNlVGltZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VUaW1lU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kdWVUaW1lID0gZHVlVGltZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJEZWJvdW5jZSgpO1xuICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb24gPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIHRoaXMuZHVlVGltZSwgdGhpcykpO1xuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlYm91bmNlZE5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuZGVib3VuY2VkTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhckRlYm91bmNlKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5sYXN0VmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbGVhckRlYm91bmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gdGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChkZWJvdW5jZWRTdWJzY3JpcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGRlYm91bmNlZFN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBkZWJvdW5jZWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlYm91bmNlVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaE5leHQoc3Vic2NyaWJlcikge1xuICAgIHN1YnNjcmliZXIuZGVib3VuY2VkTmV4dCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2VUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUGVyZm9ybSBhIHNpZGUgZWZmZWN0IGZvciBldmVyeSBlbWlzc2lvbiBvbiB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCByZXR1cm5cbiAqIGFuIE9ic2VydmFibGUgdGhhdCBpcyBpZGVudGljYWwgdG8gdGhlIHNvdXJjZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SW50ZXJjZXB0cyBlYWNoIGVtaXNzaW9uIG9uIHRoZSBzb3VyY2UgYW5kIHJ1bnMgYVxuICogZnVuY3Rpb24sIGJ1dCByZXR1cm5zIGFuIG91dHB1dCB3aGljaCBpcyBpZGVudGljYWwgdG8gdGhlIHNvdXJjZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kby5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGEgbWlycm9yZWQgT2JzZXJ2YWJsZSBvZiB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBtb2RpZmllZCBzbyB0aGF0XG4gKiB0aGUgcHJvdmlkZWQgT2JzZXJ2ZXIgaXMgY2FsbGVkIHRvIHBlcmZvcm0gYSBzaWRlIGVmZmVjdCBmb3IgZXZlcnkgdmFsdWUsXG4gKiBlcnJvciwgYW5kIGNvbXBsZXRpb24gZW1pdHRlZCBieSB0aGUgc291cmNlLiBBbnkgZXJyb3JzIHRoYXQgYXJlIHRocm93biBpblxuICogdGhlIGFmb3JlbWVudGlvbmVkIE9ic2VydmVyIG9yIGhhbmRsZXJzIGFyZSBzYWZlbHkgc2VudCBkb3duIHRoZSBlcnJvciBwYXRoXG4gKiBvZiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogVGhpcyBvcGVyYXRvciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZyB5b3VyIE9ic2VydmFibGVzIGZvciB0aGUgY29ycmVjdCB2YWx1ZXNcbiAqIG9yIHBlcmZvcm1pbmcgb3RoZXIgc2lkZSBlZmZlY3RzLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgZGlmZmVyZW50IHRvIGEgYHN1YnNjcmliZWAgb24gdGhlIE9ic2VydmFibGUuIElmIHRoZSBPYnNlcnZhYmxlXG4gKiByZXR1cm5lZCBieSBgZG9gIGlzIG5vdCBzdWJzY3JpYmVkLCB0aGUgc2lkZSBlZmZlY3RzIHNwZWNpZmllZCBieSB0aGVcbiAqIE9ic2VydmVyIHdpbGwgbmV2ZXIgaGFwcGVuLiBgZG9gIHRoZXJlZm9yZSBzaW1wbHkgc3BpZXMgb24gZXhpc3RpbmdcbiAqIGV4ZWN1dGlvbiwgaXQgZG9lcyBub3QgdHJpZ2dlciBhbiBleGVjdXRpb24gdG8gaGFwcGVuIGxpa2UgYHN1YnNjcmliZWAgZG9lcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgZXZlcnkgZXZlcnkgY2xpY2sgdG8gdGhlIGNsaWVudFggcG9zaXRpb24gb2YgdGhhdCBjbGljaywgd2hpbGUgYWxzbyBsb2dnaW5nIHRoZSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcG9zaXRpb25zID0gY2xpY2tzXG4gKiAgIC5kbyhldiA9PiBjb25zb2xlLmxvZyhldikpXG4gKiAgIC5tYXAoZXYgPT4gZXYuY2xpZW50WCk7XG4gKiBwb3NpdGlvbnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1hcH1cbiAqIEBzZWUge0BsaW5rIHN1YnNjcmliZX1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmVyfGZ1bmN0aW9ufSBbbmV4dE9yT2JzZXJ2ZXJdIEEgbm9ybWFsIE9ic2VydmVyIG9iamVjdCBvciBhXG4gKiBjYWxsYmFjayBmb3IgYG5leHRgLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayBmb3IgZXJyb3JzIGluIHRoZSBzb3VyY2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY29tcGxldGVdIENhbGxiYWNrIGZvciB0aGUgY29tcGxldGlvbiBvZiB0aGUgc291cmNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBpZGVudGljYWwgdG8gdGhlIHNvdXJjZSwgYnV0IHJ1bnMgdGhlXG4gKiBzcGVjaWZpZWQgT2JzZXJ2ZXIgb3IgY2FsbGJhY2socykgZm9yIGVhY2ggaXRlbS5cbiAqIEBtZXRob2QgZG9cbiAqIEBuYW1lIGRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBfZG8obmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERvT3BlcmF0b3IobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkpO1xufVxuZXhwb3J0cy5fZG8gPSBfZG87XG52YXIgRG9PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9PcGVyYXRvcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMubmV4dE9yT2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gY29tcGxldGU7XG4gICAgfVxuICAgIERvT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEb1N1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5uZXh0T3JPYnNlcnZlciwgdGhpcy5lcnJvciwgdGhpcy5jb21wbGV0ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERvT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEb1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb1N1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZChzYWZlU3Vic2NyaWJlcik7XG4gICAgICAgIHRoaXMuc2FmZVN1YnNjcmliZXIgPSBzYWZlU3Vic2NyaWJlcjtcbiAgICB9XG4gICAgRG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb1N1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gdGhpcy5zYWZlU3Vic2NyaWJlcjtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERvU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSBvbmx5IGlmIHRoZSBwcmV2aW91cyBwcm9qZWN0ZWQgT2JzZXJ2YWJsZSBoYXMgY29tcGxldGVkLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5NYXBzIGVhY2ggdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSwgdGhlbiBmbGF0dGVucyBhbGwgb2ZcbiAqIHRoZXNlIGlubmVyIE9ic2VydmFibGVzIHVzaW5nIHtAbGluayBleGhhdXN0fS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9leGhhdXN0TWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGJhc2VkIG9uIGFwcGx5aW5nIGEgZnVuY3Rpb24gdGhhdCB5b3VcbiAqIHN1cHBseSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoZXJlIHRoYXQgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gKHNvLWNhbGxlZCBcImlubmVyXCIpIE9ic2VydmFibGUuIFdoZW4gaXQgcHJvamVjdHMgYSBzb3VyY2UgdmFsdWUgdG9cbiAqIGFuIE9ic2VydmFibGUsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnlcbiAqIHRoYXQgcHJvamVjdGVkIE9ic2VydmFibGUuIEhvd2V2ZXIsIGBleGhhdXN0TWFwYCBpZ25vcmVzIGV2ZXJ5IG5ldyBwcm9qZWN0ZWRcbiAqIE9ic2VydmFibGUgaWYgdGhlIHByZXZpb3VzIHByb2plY3RlZCBPYnNlcnZhYmxlIGhhcyBub3QgeWV0IGNvbXBsZXRlZC4gT25jZVxuICogdGhhdCBvbmUgY29tcGxldGVzLCBpdCB3aWxsIGFjY2VwdCBhbmQgZmxhdHRlbiB0aGUgbmV4dCBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogYW5kIHJlcGVhdCB0aGlzIHByb2Nlc3MuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UnVuIGEgZmluaXRlIHRpbWVyIGZvciBlYWNoIGNsaWNrLCBvbmx5IGlmIHRoZXJlIGlzIG5vIGN1cnJlbnRseSBhY3RpdmUgdGltZXI8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5leGhhdXN0TWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIGNvbnRhaW5pbmcgcHJvamVjdGVkIE9ic2VydmFibGVzXG4gKiBvZiBlYWNoIGl0ZW0gb2YgdGhlIHNvdXJjZSwgaWdub3JpbmcgcHJvamVjdGVkIE9ic2VydmFibGVzIHRoYXQgc3RhcnQgYmVmb3JlXG4gKiB0aGVpciBwcmVjZWRpbmcgT2JzZXJ2YWJsZSBoYXMgY29tcGxldGVkLlxuICogQG1ldGhvZCBleGhhdXN0TWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBleGhhdXN0TWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoRmlyc3RNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvcikpO1xufVxuZXhwb3J0cy5leGhhdXN0TWFwID0gZXhoYXVzdE1hcDtcbnZhciBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9XG4gICAgU3dpdGNoRmlyc3RNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMucmVzdWx0U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudHJ5TmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5TmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5wcm9qZWN0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmhhc1N1YnNjcmlwdGlvbiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCwgdmFsdWUsIGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnRyeVNlbGVjdFJlc3VsdChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5U2VsZWN0UmVzdWx0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVzdWx0U2VsZWN0b3IgPSBfYS5yZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5oYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhoYXVzdE1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEZpbHRlciBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBieSBvbmx5IGVtaXR0aW5nIHRob3NlIHRoYXRcbiAqIHNhdGlzZnkgYSBzcGVjaWZpZWQgcHJlZGljYXRlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlXG4gKiBbQXJyYXkucHJvdG90eXBlLmZpbHRlcigpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXIpLFxuICogaXQgb25seSBlbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBpZiBpdCBwYXNzZXMgYSBjcml0ZXJpb24gZnVuY3Rpb24uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZmlsdGVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFNpbWlsYXIgdG8gdGhlIHdlbGwta25vd24gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZCwgdGhpcyBvcGVyYXRvclxuICogdGFrZXMgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBwYXNzZXMgdGhlbSB0aHJvdWdoIGEgYHByZWRpY2F0ZWBcbiAqIGZ1bmN0aW9uIGFuZCBvbmx5IGVtaXRzIHRob3NlIHZhbHVlcyB0aGF0IHlpZWxkZWQgYHRydWVgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgb25seSBjbGljayBldmVudHMgd2hvc2UgdGFyZ2V0IHdhcyBhIERJViBlbGVtZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBjbGlja3NPbkRpdnMgPSBjbGlja3MuZmlsdGVyKGV2ID0+IGV2LnRhcmdldC50YWdOYW1lID09PSAnRElWJyk7XG4gKiBjbGlja3NPbkRpdnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0fVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbENoYW5nZWR9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZH1cbiAqIEBzZWUge0BsaW5rIGlnbm9yZUVsZW1lbnRzfVxuICogQHNlZSB7QGxpbmsgcGFydGl0aW9ufVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogYm9vbGVhbn0gcHJlZGljYXRlIEEgZnVuY3Rpb24gdGhhdFxuICogZXZhbHVhdGVzIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGl0IHJldHVybnMgYHRydWVgLFxuICogdGhlIHZhbHVlIGlzIGVtaXR0ZWQsIGlmIGBmYWxzZWAgdGhlIHZhbHVlIGlzIG5vdCBwYXNzZWQgdG8gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS4gVGhlIGBpbmRleGAgcGFyYW1ldGVyIGlzIHRoZSBudW1iZXIgYGlgIGZvciB0aGUgaS10aCBzb3VyY2VcbiAqIGVtaXNzaW9uIHRoYXQgaGFzIGhhcHBlbmVkIHNpbmNlIHRoZSBzdWJzY3JpcHRpb24sIHN0YXJ0aW5nIGZyb20gdGhlIG51bWJlclxuICogYDBgLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIGB0aGlzYFxuICogaW4gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIHRoYXQgd2VyZVxuICogYWxsb3dlZCBieSB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24uXG4gKiBAbWV0aG9kIGZpbHRlclxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEZpbHRlck9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZykpO1xufVxuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG52YXIgRmlsdGVyT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbHRlck9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICB9XG4gICAgRmlsdGVyT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaWx0ZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnRoaXNBcmcpKTtcbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXJPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEZpbHRlclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaWx0ZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpbHRlclN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgfVxuICAgIC8vIHRoZSB0cnkgY2F0Y2ggYmxvY2sgYmVsb3cgaXMgbGVmdCBzcGVjaWZpY2FsbHkgZm9yXG4gICAgLy8gb3B0aW1pemF0aW9uIGFuZCBwZXJmIHJlYXNvbnMuIGEgdHJ5Q2F0Y2hlciBpcyBub3QgbmVjZXNzYXJ5IGhlcmUuXG4gICAgRmlsdGVyU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlLmNhbGwodGhpcy50aGlzQXJnLCB2YWx1ZSwgdGhpcy5jb3VudCsrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCB3aWxsIGNhbGwgYSBzcGVjaWZpZWQgZnVuY3Rpb24gd2hlblxuICogdGhlIHNvdXJjZSB0ZXJtaW5hdGVzIG9uIGNvbXBsZXRlIG9yIGVycm9yLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gc291cmNlIHRlcm1pbmF0ZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlLCBidXQgd2lsbCBjYWxsIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gb24gdGVybWluYXRpb24uXG4gKiBAbWV0aG9kIGZpbmFsbHlcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9maW5hbGx5KGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRmluYWxseU9wZXJhdG9yKGNhbGxiYWNrKSk7XG59XG5leHBvcnRzLl9maW5hbGx5ID0gX2ZpbmFsbHk7XG52YXIgRmluYWxseU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaW5hbGx5T3BlcmF0b3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBGaW5hbGx5T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaW5hbGx5U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNhbGxiYWNrKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmluYWxseU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRmluYWxseVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaW5hbGx5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaW5hbGx5U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFkZChuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKGNhbGxiYWNrKSk7XG4gICAgfVxuICAgIHJldHVybiBGaW5hbGx5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbmFsbHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEFwcGxpZXMgYSBnaXZlbiBgcHJvamVjdGAgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUsIGFuZCBlbWl0cyB0aGUgcmVzdWx0aW5nIHZhbHVlcyBhcyBhbiBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlIFtBcnJheS5wcm90b3R5cGUubWFwKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L21hcCksXG4gKiBpdCBwYXNzZXMgZWFjaCBzb3VyY2UgdmFsdWUgdGhyb3VnaCBhIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIHRvIGdldFxuICogY29ycmVzcG9uZGluZyBvdXRwdXQgdmFsdWVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBTaW1pbGFyIHRvIHRoZSB3ZWxsIGtub3duIGBBcnJheS5wcm90b3R5cGUubWFwYCBmdW5jdGlvbiwgdGhpcyBvcGVyYXRvclxuICogYXBwbGllcyBhIHByb2plY3Rpb24gdG8gZWFjaCB2YWx1ZSBhbmQgZW1pdHMgdGhhdCBwcm9qZWN0aW9uIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGV2ZXJ5IGV2ZXJ5IGNsaWNrIHRvIHRoZSBjbGllbnRYIHBvc2l0aW9uIG9mIHRoYXQgY2xpY2s8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHBvc2l0aW9ucyA9IGNsaWNrcy5tYXAoZXYgPT4gZXYuY2xpZW50WCk7XG4gKiBwb3NpdGlvbnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1hcFRvfVxuICogQHNlZSB7QGxpbmsgcGx1Y2t9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IFJ9IHByb2plY3QgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5XG4gKiB0byBlYWNoIGB2YWx1ZWAgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIFRoZSBgaW5kZXhgIHBhcmFtZXRlciBpc1xuICogdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIGVtaXNzaW9uIHRoYXQgaGFzIGhhcHBlbmVkIHNpbmNlIHRoZVxuICogc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXIgYDBgLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZWZpbmUgd2hhdCBgdGhpc2AgaXMgaW4gdGhlXG4gKiBgcHJvamVjdGAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgdHJhbnNmb3JtZWQgYnkgdGhlIGdpdmVuIGBwcm9qZWN0YCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgbWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXAocHJvamVjdCwgdGhpc0FyZykge1xuICAgIGlmICh0eXBlb2YgcHJvamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbi4gQXJlIHlvdSBsb29raW5nIGZvciBgbWFwVG8oKWA/Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1hcE9wZXJhdG9yKHByb2plY3QsIHRoaXNBcmcpKTtcbn1cbmV4cG9ydHMubWFwID0gbWFwO1xudmFyIE1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBPcGVyYXRvcihwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgfVxuICAgIE1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMudGhpc0FyZykpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWFwT3BlcmF0b3IgPSBNYXBPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWFwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgdGhpc0FyZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnIHx8IHRoaXM7XG4gICAgfVxuICAgIC8vIE5PVEU6IFRoaXMgbG9va3MgdW5vcHRpbWl6ZWQsIGJ1dCBpdCdzIGFjdHVhbGx5IHB1cnBvc2VmdWxseSBOT1RcbiAgICAvLyB1c2luZyB0cnkvY2F0Y2ggb3B0aW1pemF0aW9ucy5cbiAgICBNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmNhbGwodGhpcy50aGlzQXJnLCB2YWx1ZSwgdGhpcy5jb3VudCsrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSB3aGljaFxuICogY29uY3VycmVudGx5IGRlbGl2ZXJzIGFsbCB2YWx1ZXMgdGhhdCBhcmUgZW1pdHRlZCBvbiB0aGUgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIGFuIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2VBbGwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1lcmdlQWxsYCBzdWJzY3JpYmVzIHRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcywgYWxzbyBrbm93biBhc1xuICogYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZSBlbWl0dGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlcywgaXQgc3Vic2NyaWJlcyB0byB0aGF0IGFuZCBkZWxpdmVycyBhbGwgdGhlIHZhbHVlcyBmcm9tIHRoZVxuICogaW5uZXIgT2JzZXJ2YWJsZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvbmx5XG4gKiBjb21wbGV0ZXMgb25jZSBhbGwgaW5uZXIgT2JzZXJ2YWJsZXMgaGF2ZSBjb21wbGV0ZWQuIEFueSBlcnJvciBkZWxpdmVyZWQgYnlcbiAqIGEgaW5uZXIgT2JzZXJ2YWJsZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlNwYXduIGEgbmV3IGludGVydmFsIE9ic2VydmFibGUgZm9yIGVhY2ggY2xpY2sgZXZlbnQsIGFuZCBibGVuZCB0aGVpciBvdXRwdXRzIGFzIG9uZSBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHZhciBmaXJzdE9yZGVyID0gaGlnaGVyT3JkZXIubWVyZ2VBbGwoKTtcbiAqIGZpcnN0T3JkZXIuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvdW50IGZyb20gMCB0byA5IGV2ZXJ5IHNlY29uZCBmb3IgZWFjaCBjbGljaywgYnV0IG9ubHkgYWxsb3cgMiBjb25jdXJyZW50IHRpbWVyczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKSk7XG4gKiB2YXIgZmlyc3RPcmRlciA9IGhpZ2hlck9yZGVyLm1lcmdlQWxsKDIpO1xuICogZmlyc3RPcmRlci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZX1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaH1cbiAqIEBzZWUge0BsaW5rIHppcEFsbH1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbm5lclxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdmFsdWVzIGNvbWluZyBmcm9tIGFsbCB0aGVcbiAqIGlubmVyIE9ic2VydmFibGVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBtZXJnZUFsbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VBbGwoY29uY3VycmVudCkge1xuICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1lcmdlQWxsT3BlcmF0b3IoY29uY3VycmVudCkpO1xufVxuZXhwb3J0cy5tZXJnZUFsbCA9IG1lcmdlQWxsO1xudmFyIE1lcmdlQWxsT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lcmdlQWxsT3BlcmF0b3IoY29uY3VycmVudCkge1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgIH1cbiAgICBNZXJnZUFsbE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlQWxsU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5jb25jdXJyZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VBbGxPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk1lcmdlQWxsT3BlcmF0b3IgPSBNZXJnZUFsbE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNZXJnZUFsbFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXJnZUFsbFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVyZ2VBbGxTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25jdXJyZW50KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgIH1cbiAgICBNZXJnZUFsbFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlIDwgdGhpcy5jb25jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBvYnNlcnZhYmxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG9ic2VydmFibGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZUFsbFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlQWxsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlQWxsU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnRzLk1lcmdlQWxsU3Vic2NyaWJlciA9IE1lcmdlQWxsU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlQWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgbWVyZ2VBbGx9Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlTWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGJhc2VkIG9uIGFwcGx5aW5nIGEgZnVuY3Rpb24gdGhhdCB5b3VcbiAqIHN1cHBseSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoZXJlIHRoYXQgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gT2JzZXJ2YWJsZSwgYW5kIHRoZW4gbWVyZ2luZyB0aG9zZSByZXN1bHRpbmcgT2JzZXJ2YWJsZXMgYW5kXG4gKiBlbWl0dGluZyB0aGUgcmVzdWx0cyBvZiB0aGlzIG1lcmdlci5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgYW5kIGZsYXR0ZW4gZWFjaCBsZXR0ZXIgdG8gYW4gT2JzZXJ2YWJsZSB0aWNraW5nIGV2ZXJ5IDEgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGxldHRlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpO1xuICogdmFyIHJlc3VsdCA9IGxldHRlcnMubWVyZ2VNYXAoeCA9PlxuICogICBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLm1hcChpID0+IHgraSlcbiAqICk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIGEwXG4gKiAvLyBiMFxuICogLy8gYzBcbiAqIC8vIGExXG4gKiAvLyBiMVxuICogLy8gYzFcbiAqIC8vIGNvbnRpbnVlcyB0byBsaXN0IGEsYixjIHdpdGggcmVzcGVjdGl2ZSBhc2NlbmRpbmcgaW50ZWdlcnNcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2V9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgP2luZGV4OiBudW1iZXIpOiBPYnNlcnZhYmxlSW5wdXR9IHByb2plY3QgQSBmdW5jdGlvblxuICogdGhhdCwgd2hlbiBhcHBsaWVkIHRvIGFuIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHJldHVybnMgYW5cbiAqIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlXG4gKiBwcm9qZWN0aW9uIGZ1bmN0aW9uIChhbmQgdGhlIG9wdGlvbmFsIGByZXN1bHRTZWxlY3RvcmApIHRvIGVhY2ggaXRlbSBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIG1lcmdpbmcgdGhlIHJlc3VsdHMgb2YgdGhlIE9ic2VydmFibGVzIG9idGFpbmVkXG4gKiBmcm9tIHRoaXMgdHJhbnNmb3JtYXRpb24uXG4gKiBAbWV0aG9kIG1lcmdlTWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtZXJnZU1hcChwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkge1xuICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0U2VsZWN0b3IgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmN1cnJlbnQgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgcmVzdWx0U2VsZWN0b3IgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNZXJnZU1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSk7XG59XG5leHBvcnRzLm1lcmdlTWFwID0gbWVyZ2VNYXA7XG52YXIgTWVyZ2VNYXBPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVyZ2VNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkge1xuICAgICAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgIH1cbiAgICBNZXJnZU1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlTWFwU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5wcm9qZWN0LCB0aGlzLnJlc3VsdFNlbGVjdG9yLCB0aGlzLmNvbmN1cnJlbnQpKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXJnZU1hcE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWVyZ2VNYXBPcGVyYXRvciA9IE1lcmdlTWFwT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE1lcmdlTWFwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lcmdlTWFwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXJnZU1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPCB0aGlzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeU5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeU5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgIHRoaXMuX2lubmVyU3ViKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2lubmVyU3ViID0gZnVuY3Rpb24gKGlzaCwgdmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgaXNoLCB2YWx1ZSwgaW5kZXgpKTtcbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlSZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbm90aWZ5UmVzdWx0U2VsZWN0b3IgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5yZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmFjdGl2ZS0tO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQoYnVmZmVyLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZXJnZU1hcFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5NZXJnZU1hcFN1YnNjcmliZXIgPSBNZXJnZU1hcFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZU1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBDb25uZWN0YWJsZU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0cyBvZiBpbnZva2luZyBhIHNwZWNpZmllZCBzZWxlY3RvciBvbiBpdGVtc1xuICogZW1pdHRlZCBieSBhIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG8gdGhlIHVuZGVybHlpbmcgc3RyZWFtLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbXVsdGljYXN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3ViamVjdH0gc3ViamVjdE9yU3ViamVjdEZhY3RvcnkgLSBGYWN0b3J5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBpbnRlcm1lZGlhdGUgc3ViamVjdCB0aHJvdWdoXG4gKiB3aGljaCB0aGUgc291cmNlIHNlcXVlbmNlJ3MgZWxlbWVudHMgd2lsbCBiZSBtdWx0aWNhc3QgdG8gdGhlIHNlbGVjdG9yIGZ1bmN0aW9uXG4gKiBvciBTdWJqZWN0IHRvIHB1c2ggc291cmNlIGVsZW1lbnRzIGludG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbc2VsZWN0b3JdIC0gT3B0aW9uYWwgc2VsZWN0b3IgZnVuY3Rpb24gdGhhdCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc3RyZWFtXG4gKiBhcyBtYW55IHRpbWVzIGFzIG5lZWRlZCwgd2l0aG91dCBjYXVzaW5nIG11bHRpcGxlIHN1YnNjcmlwdGlvbnMgdG8gdGhlIHNvdXJjZSBzdHJlYW0uXG4gKiBTdWJzY3JpYmVycyB0byB0aGUgZ2l2ZW4gc291cmNlIHdpbGwgcmVjZWl2ZSBhbGwgbm90aWZpY2F0aW9ucyBvZiB0aGUgc291cmNlIGZyb20gdGhlXG4gKiB0aW1lIG9mIHRoZSBzdWJzY3JpcHRpb24gZm9yd2FyZC5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgcmVzdWx0cyBvZiBpbnZva2luZyB0aGUgc2VsZWN0b3JcbiAqIG9uIHRoZSBpdGVtcyBlbWl0dGVkIGJ5IGEgYENvbm5lY3RhYmxlT2JzZXJ2YWJsZWAgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvXG4gKiB0aGUgdW5kZXJseWluZyBzdHJlYW0uXG4gKiBAbWV0aG9kIG11bHRpY2FzdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbXVsdGljYXN0KHN1YmplY3RPclN1YmplY3RGYWN0b3J5LCBzZWxlY3Rvcikge1xuICAgIHZhciBzdWJqZWN0RmFjdG9yeTtcbiAgICBpZiAodHlwZW9mIHN1YmplY3RPclN1YmplY3RGYWN0b3J5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN1YmplY3RGYWN0b3J5ID0gc3ViamVjdE9yU3ViamVjdEZhY3Rvcnk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdWJqZWN0RmFjdG9yeSA9IGZ1bmN0aW9uIHN1YmplY3RGYWN0b3J5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YmplY3RPclN1YmplY3RGYWN0b3J5O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE11bHRpY2FzdE9wZXJhdG9yKHN1YmplY3RGYWN0b3J5LCBzZWxlY3RvcikpO1xuICAgIH1cbiAgICB2YXIgY29ubmVjdGFibGUgPSBPYmplY3QuY3JlYXRlKHRoaXMsIENvbm5lY3RhYmxlT2JzZXJ2YWJsZV8xLmNvbm5lY3RhYmxlT2JzZXJ2YWJsZURlc2NyaXB0b3IpO1xuICAgIGNvbm5lY3RhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgY29ubmVjdGFibGUuc3ViamVjdEZhY3RvcnkgPSBzdWJqZWN0RmFjdG9yeTtcbiAgICByZXR1cm4gY29ubmVjdGFibGU7XG59XG5leHBvcnRzLm11bHRpY2FzdCA9IG11bHRpY2FzdDtcbnZhciBNdWx0aWNhc3RPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTXVsdGljYXN0T3BlcmF0b3Ioc3ViamVjdEZhY3RvcnksIHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdEZhY3RvcnkgPSBzdWJqZWN0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgIH1cbiAgICBNdWx0aWNhc3RPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzLnN1YmplY3RGYWN0b3J5KCk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzZWxlY3RvcihzdWJqZWN0KS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoc291cmNlLnN1YnNjcmliZShzdWJqZWN0KSk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICByZXR1cm4gTXVsdGljYXN0T3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NdWx0aWNhc3RPcGVyYXRvciA9IE11bHRpY2FzdE9wZXJhdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bXVsdGljYXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBHcm91cHMgcGFpcnMgb2YgY29uc2VjdXRpdmUgZW1pc3Npb25zIHRvZ2V0aGVyIGFuZCBlbWl0cyB0aGVtIGFzIGFuIGFycmF5IG9mXG4gKiB0d28gdmFsdWVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5QdXRzIHRoZSBjdXJyZW50IHZhbHVlIGFuZCBwcmV2aW91cyB2YWx1ZSB0b2dldGhlciBhc1xuICogYW4gYXJyYXksIGFuZCBlbWl0cyB0aGF0Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3BhaXJ3aXNlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFRoZSBOdGggZW1pc3Npb24gZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2lsbCBjYXVzZSB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIHRvIGVtaXQgYW4gYXJyYXkgWyhOLTEpdGgsIE50aF0gb2YgdGhlIHByZXZpb3VzIGFuZCB0aGUgY3VycmVudCB2YWx1ZSwgYXMgYVxuICogcGFpci4gRm9yIHRoaXMgcmVhc29uLCBgcGFpcndpc2VgIGVtaXRzIG9uIHRoZSBzZWNvbmQgYW5kIHN1YnNlcXVlbnRcbiAqIGVtaXNzaW9ucyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IG5vdCBvbiB0aGUgZmlyc3QgZW1pc3Npb24sIGJlY2F1c2VcbiAqIHRoZXJlIGlzIG5vIHByZXZpb3VzIHZhbHVlIGluIHRoYXQgY2FzZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljayAoc3RhcnRpbmcgZnJvbSB0aGUgc2Vjb25kKSwgZW1pdCB0aGUgcmVsYXRpdmUgZGlzdGFuY2UgdG8gdGhlIHByZXZpb3VzIGNsaWNrPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwYWlycyA9IGNsaWNrcy5wYWlyd2lzZSgpO1xuICogdmFyIGRpc3RhbmNlID0gcGFpcnMubWFwKHBhaXIgPT4ge1xuICogICB2YXIgeDAgPSBwYWlyWzBdLmNsaWVudFg7XG4gKiAgIHZhciB5MCA9IHBhaXJbMF0uY2xpZW50WTtcbiAqICAgdmFyIHgxID0gcGFpclsxXS5jbGllbnRYO1xuICogICB2YXIgeTEgPSBwYWlyWzFdLmNsaWVudFk7XG4gKiAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeDAgLSB4MSwgMikgKyBNYXRoLnBvdyh5MCAtIHkxLCAyKSk7XG4gKiB9KTtcbiAqIGRpc3RhbmNlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJDb3VudH1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPEFycmF5PFQ+Pn0gQW4gT2JzZXJ2YWJsZSBvZiBwYWlycyAoYXMgYXJyYXlzKSBvZlxuICogY29uc2VjdXRpdmUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBwYWlyd2lzZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gcGFpcndpc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgUGFpcndpc2VPcGVyYXRvcigpKTtcbn1cbmV4cG9ydHMucGFpcndpc2UgPSBwYWlyd2lzZTtcbnZhciBQYWlyd2lzZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWlyd2lzZU9wZXJhdG9yKCkge1xuICAgIH1cbiAgICBQYWlyd2lzZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUGFpcndpc2VTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBQYWlyd2lzZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgUGFpcndpc2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFpcndpc2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhaXJ3aXNlU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaGFzUHJldiA9IGZhbHNlO1xuICAgIH1cbiAgICBQYWlyd2lzZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1ByZXYpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChbdGhpcy5wcmV2LCB2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNQcmV2ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXYgPSB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiBQYWlyd2lzZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWlyd2lzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4vbXVsdGljYXN0Jyk7XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xuZnVuY3Rpb24gc2hhcmVTdWJqZWN0RmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG59XG4vKipcbiAqIFJldHVybnMgYSBuZXcgT2JzZXJ2YWJsZSB0aGF0IG11bHRpY2FzdHMgKHNoYXJlcykgdGhlIG9yaWdpbmFsIE9ic2VydmFibGUuIEFzIGxvbmcgYXMgdGhlcmUgaXMgYXQgbGVhc3Qgb25lXG4gKiBTdWJzY3JpYmVyIHRoaXMgT2JzZXJ2YWJsZSB3aWxsIGJlIHN1YnNjcmliZWQgYW5kIGVtaXR0aW5nIGRhdGEuIFdoZW4gYWxsIHN1YnNjcmliZXJzIGhhdmUgdW5zdWJzY3JpYmVkIGl0IHdpbGxcbiAqIHVuc3Vic2NyaWJlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBCZWNhdXNlIHRoZSBPYnNlcnZhYmxlIGlzIG11bHRpY2FzdGluZyBpdCBtYWtlcyB0aGUgc3RyZWFtIGBob3RgLlxuICogVGhpcyBpcyBhbiBhbGlhcyBmb3IgLnB1Ymxpc2goKS5yZWZDb3VudCgpLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2hhcmUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHVwb24gY29ubmVjdGlvbiBjYXVzZXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRvIGVtaXQgaXRlbXMgdG8gaXRzIE9ic2VydmVycy5cbiAqIEBtZXRob2Qgc2hhcmVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNoYXJlKCkge1xuICAgIHJldHVybiBtdWx0aWNhc3RfMS5tdWx0aWNhc3QuY2FsbCh0aGlzLCBzaGFyZVN1YmplY3RGYWN0b3J5KS5yZWZDb3VudCgpO1xufVxuZXhwb3J0cy5zaGFyZSA9IHNoYXJlO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIFNjYWxhck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvU2NhbGFyT2JzZXJ2YWJsZScpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoJy4vY29uY2F0Jyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyB5b3Ugc3BlY2lmeSBhcyBhcmd1bWVudHMgYmVmb3JlIGl0IGJlZ2lucyB0byBlbWl0XG4gKiBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N0YXJ0V2l0aC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0gey4uLlR9IHZhbHVlcyAtIEl0ZW1zIHlvdSB3YW50IHRoZSBtb2RpZmllZCBPYnNlcnZhYmxlIHRvIGVtaXQgZmlyc3QuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gLSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyBpbiB0aGUgc3BlY2lmaWVkIEl0ZXJhYmxlIGFuZCB0aGVuIGVtaXRzIHRoZSBpdGVtc1xuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN0YXJ0V2l0aFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc3RhcnRXaXRoKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFycmF5W19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgc2NoZWR1bGVyID0gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSkge1xuICAgICAgICBhcnJheS5wb3AoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY29uY2F0XzEuY29uY2F0U3RhdGljKG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKSwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdF8xLmNvbmNhdFN0YXRpYyhuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb25jYXRfMS5jb25jYXRTdGF0aWMobmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpLCB0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLnN0YXJ0V2l0aCA9IHN0YXJ0V2l0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXJ0V2l0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIGFuIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUsIGVtaXR0aW5nIHZhbHVlcyBvbmx5IGZyb20gdGhlIG1vc3QgcmVjZW50bHkgcHJvamVjdGVkIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPk1hcHMgZWFjaCB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlLCB0aGVuIGZsYXR0ZW5zIGFsbCBvZlxuICogdGhlc2UgaW5uZXIgT2JzZXJ2YWJsZXMgdXNpbmcge0BsaW5rIHN3aXRjaH0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc3dpdGNoTWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGJhc2VkIG9uIGFwcGx5aW5nIGEgZnVuY3Rpb24gdGhhdCB5b3VcbiAqIHN1cHBseSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoZXJlIHRoYXQgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gKHNvLWNhbGxlZCBcImlubmVyXCIpIE9ic2VydmFibGUuIEVhY2ggdGltZSBpdCBvYnNlcnZlcyBvbmUgb2YgdGhlc2VcbiAqIGlubmVyIE9ic2VydmFibGVzLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmVnaW5zIGVtaXR0aW5nIHRoZSBpdGVtcyBlbWl0dGVkIGJ5XG4gKiB0aGF0IGlubmVyIE9ic2VydmFibGUuIFdoZW4gYSBuZXcgaW5uZXIgT2JzZXJ2YWJsZSBpcyBlbWl0dGVkLCBgc3dpdGNoTWFwYFxuICogc3RvcHMgZW1pdHRpbmcgaXRlbXMgZnJvbSB0aGUgZWFybGllci1lbWl0dGVkIGlubmVyIE9ic2VydmFibGUgYW5kIGJlZ2luc1xuICogZW1pdHRpbmcgaXRlbXMgZnJvbSB0aGUgbmV3IG9uZS4gSXQgY29udGludWVzIHRvIGJlaGF2ZSBsaWtlIHRoaXMgZm9yXG4gKiBzdWJzZXF1ZW50IGlubmVyIE9ic2VydmFibGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJlcnVuIGFuIGludGVydmFsIE9ic2VydmFibGUgb24gZXZlcnkgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5zd2l0Y2hNYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgc3dpdGNofVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwVG99XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgP2luZGV4OiBudW1iZXIpOiBPYnNlcnZhYmxlSW5wdXR9IHByb2plY3QgQSBmdW5jdGlvblxuICogdGhhdCwgd2hlbiBhcHBsaWVkIHRvIGFuIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHJldHVybnMgYW5cbiAqIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlXG4gKiBwcm9qZWN0aW9uIGZ1bmN0aW9uIChhbmQgdGhlIG9wdGlvbmFsIGByZXN1bHRTZWxlY3RvcmApIHRvIGVhY2ggaXRlbSBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIHRha2luZyBvbmx5IHRoZSB2YWx1ZXMgZnJvbSB0aGUgbW9zdCByZWNlbnRseVxuICogcHJvamVjdGVkIGlubmVyIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN3aXRjaE1hcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc3dpdGNoTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuc3dpdGNoTWFwID0gc3dpdGNoTWFwO1xudmFyIFN3aXRjaE1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgfVxuICAgIFN3aXRjaE1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoTWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMucmVzdWx0U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN3aXRjaE1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbm5lclN1YihyZXN1bHQsIHZhbHVlLCBpbmRleCk7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAocmVzdWx0LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCwgdmFsdWUsIGluZGV4KSk7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmICghaW5uZXJTdWJzY3JpcHRpb24gfHwgaW5uZXJTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl90cnlOb3RpZnlOZXh0KG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5Tm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaE1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogRW1pdHMgdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB1bnRpbCBhIGBub3RpZmllcmBcbiAqIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGV0cyB2YWx1ZXMgcGFzcyB1bnRpbCBhIHNlY29uZCBPYnNlcnZhYmxlLFxuICogYG5vdGlmaWVyYCwgZW1pdHMgc29tZXRoaW5nLiBUaGVuLCBpdCBjb21wbGV0ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvdGFrZVVudGlsLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0YWtlVW50aWxgIHN1YnNjcmliZXMgYW5kIGJlZ2lucyBtaXJyb3JpbmcgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJdCBhbHNvXG4gKiBtb25pdG9ycyBhIHNlY29uZCBPYnNlcnZhYmxlLCBgbm90aWZpZXJgIHRoYXQgeW91IHByb3ZpZGUuIElmIHRoZSBgbm90aWZpZXJgXG4gKiBlbWl0cyBhIHZhbHVlIG9yIGEgY29tcGxldGUgbm90aWZpY2F0aW9uLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgc3RvcHNcbiAqIG1pcnJvcmluZyB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIGNvbXBsZXRlcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5UaWNrIGV2ZXJ5IHNlY29uZCB1bnRpbCB0aGUgZmlyc3QgY2xpY2sgaGFwcGVuczwvY2FwdGlvbj5cbiAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGludGVydmFsLnRha2VVbnRpbChjbGlja3MpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICogQHNlZSB7QGxpbmsgdGFrZUxhc3R9XG4gKiBAc2VlIHtAbGluayB0YWtlV2hpbGV9XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gbm90aWZpZXIgVGhlIE9ic2VydmFibGUgd2hvc2UgZmlyc3QgZW1pdHRlZCB2YWx1ZSB3aWxsXG4gKiBjYXVzZSB0aGUgb3V0cHV0IE9ic2VydmFibGUgb2YgYHRha2VVbnRpbGAgdG8gc3RvcCBlbWl0dGluZyB2YWx1ZXMgZnJvbSB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIHVudGlsIHN1Y2ggdGltZSBhcyBgbm90aWZpZXJgIGVtaXRzIGl0cyBmaXJzdCB2YWx1ZS5cbiAqIEBtZXRob2QgdGFrZVVudGlsXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0YWtlVW50aWwobm90aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUYWtlVW50aWxPcGVyYXRvcihub3RpZmllcikpO1xufVxuZXhwb3J0cy50YWtlVW50aWwgPSB0YWtlVW50aWw7XG52YXIgVGFrZVVudGlsT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRha2VVbnRpbE9wZXJhdG9yKG5vdGlmaWVyKSB7XG4gICAgICAgIHRoaXMubm90aWZpZXIgPSBub3RpZmllcjtcbiAgICB9XG4gICAgVGFrZVVudGlsT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlVW50aWxTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubm90aWZpZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlVW50aWxPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRha2VVbnRpbFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWtlVW50aWxTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRha2VVbnRpbFN1YnNjcmliZXIoZGVzdGluYXRpb24sIG5vdGlmaWVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG5vdGlmaWVyKSk7XG4gICAgfVxuICAgIFRha2VVbnRpbFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgVGFrZVVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9O1xuICAgIHJldHVybiBUYWtlVW50aWxTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2VVbnRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnKTtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXknKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIGl0ZXJhdG9yXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvaXRlcmF0b3InKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEBwYXJhbSBvYnNlcnZhYmxlc1xuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn1cbiAqIEBtZXRob2QgemlwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB6aXBQcm90bygpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKHppcFN0YXRpYy5hcHBseSh2b2lkIDAsIFt0aGlzXS5jb25jYXQob2JzZXJ2YWJsZXMpKSk7XG59XG5leHBvcnRzLnppcFByb3RvID0gemlwUHJvdG87XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0byBjcmVhdGUgYW4gT2JzZXJ2YWJsZSB3aG9zZSB2YWx1ZXMgYXJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgdmFsdWVzLCBpbiBvcmRlciwgb2YgZWFjaFxuICogb2YgaXRzIGlucHV0IE9ic2VydmFibGVzLlxuICpcbiAqIElmIHRoZSBsYXRlc3QgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24sIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjb21wdXRlIHRoZSBjcmVhdGVkIHZhbHVlIGZyb20gdGhlIGlucHV0IHZhbHVlcy5cbiAqIE90aGVyd2lzZSwgYW4gYXJyYXkgb2YgdGhlIGlucHV0IHZhbHVlcyBpcyByZXR1cm5lZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db21iaW5lIGFnZSBhbmQgbmFtZSBmcm9tIGRpZmZlcmVudCBzb3VyY2VzPC9jYXB0aW9uPlxuICpcbiAqIGxldCBhZ2UkID0gT2JzZXJ2YWJsZS5vZjxudW1iZXI+KDI3LCAyNSwgMjkpO1xuICogbGV0IG5hbWUkID0gT2JzZXJ2YWJsZS5vZjxzdHJpbmc+KCdGb28nLCAnQmFyJywgJ0JlZXInKTtcbiAqIGxldCBpc0RldiQgPSBPYnNlcnZhYmxlLm9mPGJvb2xlYW4+KHRydWUsIHRydWUsIGZhbHNlKTtcbiAqXG4gKiBPYnNlcnZhYmxlXG4gKiAgICAgLnppcChhZ2UkLFxuICogICAgICAgICAgbmFtZSQsXG4gKiAgICAgICAgICBpc0RldiQsXG4gKiAgICAgICAgICAoYWdlOiBudW1iZXIsIG5hbWU6IHN0cmluZywgaXNEZXY6IGJvb2xlYW4pID0+ICh7IGFnZSwgbmFtZSwgaXNEZXYgfSkpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBvdXRwdXRzXG4gKiAvLyB7IGFnZTogMjcsIG5hbWU6ICdGb28nLCBpc0RldjogdHJ1ZSB9XG4gKiAvLyB7IGFnZTogMjUsIG5hbWU6ICdCYXInLCBpc0RldjogdHJ1ZSB9XG4gKiAvLyB7IGFnZTogMjksIG5hbWU6ICdCZWVyJywgaXNEZXY6IGZhbHNlIH1cbiAqXG4gKiBAcGFyYW0gb2JzZXJ2YWJsZXNcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59XG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIHppcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gemlwU3RhdGljKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcHJvamVjdCA9IG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0eXBlb2YgcHJvamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMpLmxpZnQobmV3IFppcE9wZXJhdG9yKHByb2plY3QpKTtcbn1cbmV4cG9ydHMuemlwU3RhdGljID0gemlwU3RhdGljO1xudmFyIFppcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBaaXBPcGVyYXRvcihwcm9qZWN0KSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgfVxuICAgIFppcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgWmlwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLlppcE9wZXJhdG9yID0gWmlwT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFppcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaaXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFppcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaXRlcmF0b3JzID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gKHR5cGVvZiBwcm9qZWN0ID09PSAnZnVuY3Rpb24nKSA/IHByb2plY3QgOiBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHRoaXMuaXRlcmF0b3JzO1xuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljQXJyYXlJdGVyYXRvcih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVtpdGVyYXRvcl8xLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaXRlcmF0b3JzLnB1c2gobmV3IFN0YXRpY0l0ZXJhdG9yKHZhbHVlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdG9ycy5wdXNoKG5ldyBaaXBCdWZmZXJJdGVyYXRvcih0aGlzLmRlc3RpbmF0aW9uLCB0aGlzLCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICAgICAgdmFyIGxlbiA9IGl0ZXJhdG9ycy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGxlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLnN0aWxsVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaXRlcmF0b3Iuc3Vic2NyaWJlKGl0ZXJhdG9yLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS0tOyAvLyBub3QgYW4gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlJbmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLmNoZWNrSXRlcmF0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgICAgIHZhciBsZW4gPSBpdGVyYXRvcnMubGVuZ3RoO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICAvLyBhYm9ydCBpZiBub3QgYWxsIG9mIHRoZW0gaGF2ZSB2YWx1ZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci5oYXNWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXRlcmF0b3IuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvdWxkQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBpdCdzIGNvbXBsZXRlZCBub3cgdGhhdCB5b3UndmUgZ290dGVuXG4gICAgICAgICAgICAvLyB0aGUgbmV4dCB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChpdGVyYXRvci5oYXNDb21wbGV0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHNob3VsZENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvamVjdCkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5UHJvamVjdChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZENvbXBsZXRlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJvamVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlppcFN1YnNjcmliZXIgPSBaaXBTdWJzY3JpYmVyO1xudmFyIFN0YXRpY0l0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNJdGVyYXRvcihpdGVyYXRvcikge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgIHRoaXMubmV4dFJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICB9XG4gICAgU3RhdGljSXRlcmF0b3IucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICB0aGlzLm5leHRSZXN1bHQgPSB0aGlzLml0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0UmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICByZXR1cm4gbmV4dFJlc3VsdCAmJiBuZXh0UmVzdWx0LmRvbmU7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljSXRlcmF0b3I7XG59KCkpO1xudmFyIFN0YXRpY0FycmF5SXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRpY0FycmF5SXRlcmF0b3IoYXJyYXkpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB9XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JfMS5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgcmV0dXJuIGkgPCB0aGlzLmxlbmd0aCA/IHsgdmFsdWU6IGFycmF5W2ldLCBkb25lOiBmYWxzZSB9IDogeyB2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZSB9O1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA+IHRoaXMuaW5kZXg7XG4gICAgfTtcbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gdGhpcy5pbmRleDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNBcnJheUl0ZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgWmlwQnVmZmVySXRlcmF0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaaXBCdWZmZXJJdGVyYXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBaaXBCdWZmZXJJdGVyYXRvcihkZXN0aW5hdGlvbiwgcGFyZW50LCBvYnNlcnZhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuc3RpbGxVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICB9XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIE5PVEU6IHRoZXJlIGlzIGFjdHVhbGx5IGEgbmFtZSBjb2xsaXNpb24gaGVyZSB3aXRoIFN1YnNjcmliZXIubmV4dCBhbmQgSXRlcmF0b3IubmV4dFxuICAgIC8vICAgIHRoaXMgaXMgbGVnaXQgYmVjYXVzZSBgbmV4dCgpYCB3aWxsIG5ldmVyIGJlIGNhbGxlZCBieSBhIHN1YnNjcmlwdGlvbiBpbiB0aGlzIGNhc2UuXG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDAgJiYgdGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGJ1ZmZlci5zaGlmdCgpLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQ29tcGxldGU7XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5SW5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbm5lclZhbHVlKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hlY2tJdGVyYXRvcnMoKTtcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHRoaXMub2JzZXJ2YWJsZSwgdGhpcywgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcEJ1ZmZlckl0ZXJhdG9yO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIEEgdW5pdCBvZiB3b3JrIHRvIGJlIGV4ZWN1dGVkIGluIGEge0BsaW5rIFNjaGVkdWxlcn0uIEFuIGFjdGlvbiBpcyB0eXBpY2FsbHlcbiAqIGNyZWF0ZWQgZnJvbSB3aXRoaW4gYSBTY2hlZHVsZXIgYW5kIGFuIFJ4SlMgdXNlciBkb2VzIG5vdCBuZWVkIHRvIGNvbmNlcm5cbiAqIHRoZW1zZWx2ZXMgYWJvdXQgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBhbiBBY3Rpb24uXG4gKlxuICogYGBgdHNcbiAqIGNsYXNzIEFjdGlvbjxUPiBleHRlbmRzIFN1YnNjcmlwdGlvbiB7XG4gKiAgIG5ldyAoc2NoZWR1bGVyOiBTY2hlZHVsZXIsIHdvcms6IChzdGF0ZT86IFQpID0+IHZvaWQpO1xuICogICBzY2hlZHVsZShzdGF0ZT86IFQsIGRlbGF5OiBudW1iZXIgPSAwKTogU3Vic2NyaXB0aW9uO1xuICogfVxuICogYGBgXG4gKlxuICogQGNsYXNzIEFjdGlvbjxUPlxuICovXG52YXIgQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyB0aGlzIGFjdGlvbiBvbiBpdHMgcGFyZW50IFNjaGVkdWxlciBmb3IgZXhlY3V0aW9uLiBNYXkgYmUgcGFzc2VkXG4gICAgICogc29tZSBjb250ZXh0IG9iamVjdCwgYHN0YXRlYC4gTWF5IGhhcHBlbiBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUsXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBgZGVsYXlgIHBhcmFtZXRlciwgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7VH0gW3N0YXRlXSBTb21lIGNvbnRleHR1YWwgZGF0YSB0aGF0IHRoZSBgd29ya2AgZnVuY3Rpb24gdXNlcyB3aGVuXG4gICAgICogY2FsbGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gVGltZSB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHdvcmssIHdoZXJlIHRoZVxuICAgICAqIHRpbWUgdW5pdCBpcyBpbXBsaWNpdCBhbmQgZGVmaW5lZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEFjdGlvbjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLkFjdGlvbiA9IEFjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIEFjdGlvbl8xID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQXN5bmNBY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc3luY0FjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3luY0FjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc2NoZWR1bGVyLCB3b3JrKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMud29yayA9IHdvcms7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyByZXBsYWNlIHRoZSBjdXJyZW50IHN0YXRlIHdpdGggdGhlIG5ldyBzdGF0ZS5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAvLyBTZXQgdGhlIHBlbmRpbmcgZmxhZyBpbmRpY2F0aW5nIHRoYXQgdGhpcyBhY3Rpb24gaGFzIGJlZW4gc2NoZWR1bGVkLCBvclxuICAgICAgICAvLyBoYXMgcmVjdXJzaXZlbHkgcmVzY2hlZHVsZWQgaXRzZWxmLlxuICAgICAgICB0aGlzLnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEltcG9ydGFudCBpbXBsZW1lbnRhdGlvbiBub3RlOlxuICAgICAgICAvL1xuICAgICAgICAvLyBBY3Rpb25zIG9ubHkgZXhlY3V0ZSBvbmNlIGJ5IGRlZmF1bHQsIHVubGVzcyByZXNjaGVkdWxlZCBmcm9tIHdpdGhpbiB0aGVcbiAgICAgICAgLy8gc2NoZWR1bGVkIGNhbGxiYWNrLiBUaGlzIGFsbG93cyB1cyB0byBpbXBsZW1lbnQgc2luZ2xlIGFuZCByZXBlYXRcbiAgICAgICAgLy8gYWN0aW9ucyB2aWEgdGhlIHNhbWUgY29kZSBwYXRoLCB3aXRob3V0IGFkZGluZyBBUEkgc3VyZmFjZSBhcmVhLCBhcyB3ZWxsXG4gICAgICAgIC8vIGFzIG1pbWljIHRyYWRpdGlvbmFsIHJlY3Vyc2lvbiBidXQgYWNyb3NzIGFzeW5jaHJvbm91cyBib3VuZGFyaWVzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCBKUyBydW50aW1lcyBhbmQgdGltZXJzIGRpc3Rpbmd1aXNoIGJldHdlZW4gaW50ZXJ2YWxzIGFjaGlldmVkIGJ5XG4gICAgICAgIC8vIHNlcmlhbCBgc2V0VGltZW91dGAgY2FsbHMgdnMuIGEgc2luZ2xlIGBzZXRJbnRlcnZhbGAgY2FsbC4gQW4gaW50ZXJ2YWwgb2ZcbiAgICAgICAgLy8gc2VyaWFsIGBzZXRUaW1lb3V0YCBjYWxscyBjYW4gYmUgaW5kaXZpZHVhbGx5IGRlbGF5ZWQsIHdoaWNoIGRlbGF5c1xuICAgICAgICAvLyBzY2hlZHVsaW5nIHRoZSBuZXh0IGBzZXRUaW1lb3V0YCwgYW5kIHNvIG9uLiBgc2V0SW50ZXJ2YWxgIGF0dGVtcHRzIHRvXG4gICAgICAgIC8vIGd1YXJhbnRlZSB0aGUgaW50ZXJ2YWwgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIG1vcmUgcHJlY2lzZWx5IHRvIHRoZVxuICAgICAgICAvLyBpbnRlcnZhbCBwZXJpb2QsIHJlZ2FyZGxlc3Mgb2YgbG9hZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSB1c2UgYHNldEludGVydmFsYCB0byBzY2hlZHVsZSBzaW5nbGUgYW5kIHJlcGVhdCBhY3Rpb25zLlxuICAgICAgICAvLyBJZiB0aGUgYWN0aW9uIHJlc2NoZWR1bGVzIGl0c2VsZiB3aXRoIHRoZSBzYW1lIGRlbGF5LCB0aGUgaW50ZXJ2YWwgaXMgbm90XG4gICAgICAgIC8vIGNhbmNlbGVkLiBJZiB0aGUgYWN0aW9uIGRvZXNuJ3QgcmVzY2hlZHVsZSwgb3IgcmVzY2hlZHVsZXMgd2l0aCBhXG4gICAgICAgIC8vIGRpZmZlcmVudCBkZWxheSwgdGhlIGludGVydmFsIHdpbGwgYmUgY2FuY2VsZWQgYWZ0ZXIgc2NoZWR1bGVkIGNhbGxiYWNrXG4gICAgICAgIC8vIGV4ZWN1dGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIC8vIElmIHRoaXMgYWN0aW9uIGhhcyBhbHJlYWR5IGFuIGFzeW5jIElkLCBkb24ndCByZXF1ZXN0IGEgbmV3IG9uZS5cbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuaWQgfHwgdGhpcy5yZXF1ZXN0QXN5bmNJZChzY2hlZHVsZXIsIHRoaXMuaWQsIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHJldHVybiByb290XzEucm9vdC5zZXRJbnRlcnZhbChzY2hlZHVsZXIuZmx1c2guYmluZChzY2hlZHVsZXIsIHRoaXMpLCBkZWxheSk7XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIC8vIElmIHRoaXMgYWN0aW9uIGlzIHJlc2NoZWR1bGVkIHdpdGggdGhlIHNhbWUgZGVsYXkgdGltZSwgZG9uJ3QgY2xlYXIgdGhlIGludGVydmFsIGlkLlxuICAgICAgICBpZiAoZGVsYXkgIT09IG51bGwgJiYgdGhpcy5kZWxheSA9PT0gZGVsYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHRoZSBhY3Rpb24ncyBkZWxheSB0aW1lIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IGRlbGF5LFxuICAgICAgICAvLyBjbGVhciB0aGUgaW50ZXJ2YWwgaWRcbiAgICAgICAgcmV0dXJuIHJvb3RfMS5yb290LmNsZWFySW50ZXJ2YWwoaWQpICYmIHVuZGVmaW5lZCB8fCB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbW1lZGlhdGVseSBleGVjdXRlcyB0aGlzIGFjdGlvbiBhbmQgdGhlIGB3b3JrYCBpdCBjb250YWlucy5cbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignZXhlY3V0aW5nIGEgY2FuY2VsbGVkIGFjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9leGVjdXRlKHN0YXRlLCBkZWxheSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGVuZGluZyA9PT0gZmFsc2UgJiYgdGhpcy5pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEZXF1ZXVlIGlmIHRoZSBhY3Rpb24gZGlkbid0IHJlc2NoZWR1bGUgaXRzZWxmLiBEb24ndCBjYWxsXG4gICAgICAgICAgICAvLyB1bnN1YnNjcmliZSgpLCBiZWNhdXNlIHRoZSBhY3Rpb24gY291bGQgcmVzY2hlZHVsZSBsYXRlci5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOlxuICAgICAgICAgICAgLy8gYGBgXG4gICAgICAgICAgICAvLyBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gZG9Xb3JrKGNvdW50ZXIpIHtcbiAgICAgICAgICAgIC8vICAgLyogLi4uIEknbSBhIGJ1c3kgd29ya2VyIGJlZSAuLi4gKi9cbiAgICAgICAgICAgIC8vICAgdmFyIG9yaWdpbmFsQWN0aW9uID0gdGhpcztcbiAgICAgICAgICAgIC8vICAgLyogd2FpdCAxMDBtcyBiZWZvcmUgcmVzY2hlZHVsaW5nIHRoZSBhY3Rpb24gKi9cbiAgICAgICAgICAgIC8vICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyAgICAgb3JpZ2luYWxBY3Rpb24uc2NoZWR1bGUoY291bnRlciArIDEpO1xuICAgICAgICAgICAgLy8gICB9LCAxMDApO1xuICAgICAgICAgICAgLy8gfSwgMTAwMCk7XG4gICAgICAgICAgICAvLyBgYGBcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHRoaXMuc2NoZWR1bGVyLCB0aGlzLmlkLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICB2YXIgZXJyb3JlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3JWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud29yayhzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgZXJyb3JWYWx1ZSA9ICEhZSAmJiBlIHx8IG5ldyBFcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JlZCkge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yVmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBzY2hlZHVsZXIuYWN0aW9ucztcbiAgICAgICAgdmFyIGluZGV4ID0gYWN0aW9ucy5pbmRleE9mKHRoaXMpO1xuICAgICAgICB0aGlzLndvcmsgPSBudWxsO1xuICAgICAgICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQoc2NoZWR1bGVyLCBpZCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBc3luY0FjdGlvbjtcbn0oQWN0aW9uXzEuQWN0aW9uKSk7XG5leHBvcnRzLkFzeW5jQWN0aW9uID0gQXN5bmNBY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY0FjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFNjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vU2NoZWR1bGVyJyk7XG52YXIgQXN5bmNTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc3luY1NjaGVkdWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3luY1NjaGVkdWxlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIFNjaGVkdWxlciBpcyBjdXJyZW50bHkgZXhlY3V0aW5nIGEgYmF0Y2ggb2ZcbiAgICAgICAgICogcXVldWVkIGFjdGlvbnMuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVybmFsIElEIHVzZWQgdG8gdHJhY2sgdGhlIGxhdGVzdCBhc3luY2hyb25vdXMgdGFzayBzdWNoIGFzIHRob3NlXG4gICAgICAgICAqIGNvbWluZyBmcm9tIGBzZXRUaW1lb3V0YCwgYHNldEludGVydmFsYCwgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAsIGFuZFxuICAgICAgICAgKiBvdGhlcnMuXG4gICAgICAgICAqIEB0eXBlIHthbnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaGVkdWxlZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgQXN5bmNTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSk7IC8vIGV4aGF1c3QgdGhlIHNjaGVkdWxlciBxdWV1ZVxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdoaWxlIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNTY2hlZHVsZXI7XG59KFNjaGVkdWxlcl8xLlNjaGVkdWxlcikpO1xuZXhwb3J0cy5Bc3luY1NjaGVkdWxlciA9IEFzeW5jU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXN5bmNTY2hlZHVsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXN5bmNBY3Rpb25fMSA9IHJlcXVpcmUoJy4vQXN5bmNBY3Rpb24nKTtcbnZhciBBc3luY1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi9Bc3luY1NjaGVkdWxlcicpO1xuLyoqXG4gKlxuICogQXN5bmMgU2NoZWR1bGVyXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlNjaGVkdWxlIHRhc2sgYXMgaWYgeW91IHVzZWQgc2V0VGltZW91dCh0YXNrLCBkdXJhdGlvbik8L3NwYW4+XG4gKlxuICogYGFzeW5jYCBzY2hlZHVsZXIgc2NoZWR1bGVzIHRhc2tzIGFzeW5jaHJvbm91c2x5LCBieSBwdXR0aW5nIHRoZW0gb24gdGhlIEphdmFTY3JpcHRcbiAqIGV2ZW50IGxvb3AgcXVldWUuIEl0IGlzIGJlc3QgdXNlZCB0byBkZWxheSB0YXNrcyBpbiB0aW1lIG9yIHRvIHNjaGVkdWxlIHRhc2tzIHJlcGVhdGluZ1xuICogaW4gaW50ZXJ2YWxzLlxuICpcbiAqIElmIHlvdSBqdXN0IHdhbnQgdG8gXCJkZWZlclwiIHRhc2ssIHRoYXQgaXMgdG8gcGVyZm9ybSBpdCByaWdodCBhZnRlciBjdXJyZW50bHlcbiAqIGV4ZWN1dGluZyBzeW5jaHJvbm91cyBjb2RlIGVuZHMgKGNvbW1vbmx5IGFjaGlldmVkIGJ5IGBzZXRUaW1lb3V0KGRlZmVycmVkVGFzaywgMClgKSxcbiAqIGJldHRlciBjaG9pY2Ugd2lsbCBiZSB0aGUge0BsaW5rIGFzYXB9IHNjaGVkdWxlci5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2UgYXN5bmMgc2NoZWR1bGVyIHRvIGRlbGF5IHRhc2s8L2NhcHRpb24+XG4gKiBjb25zdCB0YXNrID0gKCkgPT4gY29uc29sZS5sb2coJ2l0IHdvcmtzIScpO1xuICpcbiAqIFJ4LlNjaGVkdWxlci5hc3luYy5zY2hlZHVsZSh0YXNrLCAyMDAwKTtcbiAqXG4gKiAvLyBBZnRlciAyIHNlY29uZHMgbG9nczpcbiAqIC8vIFwiaXQgd29ya3MhXCJcbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VXNlIGFzeW5jIHNjaGVkdWxlciB0byByZXBlYXQgdGFzayBpbiBpbnRlcnZhbHM8L2NhcHRpb24+XG4gKiBmdW5jdGlvbiB0YXNrKHN0YXRlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHN0YXRlKTtcbiAqICAgdGhpcy5zY2hlZHVsZShzdGF0ZSArIDEsIDEwMDApOyAvLyBgdGhpc2AgcmVmZXJlbmNlcyBjdXJyZW50bHkgZXhlY3V0aW5nIEFjdGlvbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3ZSByZXNjaGVkdWxlIHdpdGggbmV3IHN0YXRlIGFuZCBkZWxheVxuICogfVxuICpcbiAqIFJ4LlNjaGVkdWxlci5hc3luYy5zY2hlZHVsZSh0YXNrLCAzMDAwLCAwKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gMCBhZnRlciAzc1xuICogLy8gMSBhZnRlciA0c1xuICogLy8gMiBhZnRlciA1c1xuICogLy8gMyBhZnRlciA2c1xuICpcbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgYXN5bmNcbiAqIEBvd25lciBTY2hlZHVsZXJcbiAqL1xuZXhwb3J0cy5hc3luYyA9IG5ldyBBc3luY1NjaGVkdWxlcl8xLkFzeW5jU2NoZWR1bGVyKEFzeW5jQWN0aW9uXzEuQXN5bmNBY3Rpb24pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG5mdW5jdGlvbiBzeW1ib2xJdGVyYXRvclBvbnlmaWxsKHJvb3QpIHtcbiAgICB2YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCFTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIFN5bWJvbC5pdGVyYXRvciA9IFN5bWJvbCgnaXRlcmF0b3IgcG9seWZpbGwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3ltYm9sLml0ZXJhdG9yO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gW2ZvciBNb3ppbGxhIEdlY2tvIDI3LTM1Ol0oaHR0cHM6Ly9temwubGEvMmV3RTF6QylcbiAgICAgICAgdmFyIFNldF8xID0gcm9vdC5TZXQ7XG4gICAgICAgIGlmIChTZXRfMSAmJiB0eXBlb2YgbmV3IFNldF8xKClbJ0BAaXRlcmF0b3InXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuICdAQGl0ZXJhdG9yJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgTWFwXzEgPSByb290Lk1hcDtcbiAgICAgICAgLy8gcmVxdWlyZWQgZm9yIGNvbXBhdGFiaWxpdHkgd2l0aCBlczYtc2hpbVxuICAgICAgICBpZiAoTWFwXzEpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWFwXzEucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIC8vIGFjY29yZGluZyB0byBzcGVjLCBNYXAucHJvdG90eXBlW0BAaXRlcmF0b3JdIGFuZCBNYXAub3JvdG90eXBlLmVudHJpZXMgbXVzdCBiZSBlcXVhbC5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnZW50cmllcycgJiYga2V5ICE9PSAnc2l6ZScgJiYgTWFwXzEucHJvdG90eXBlW2tleV0gPT09IE1hcF8xLnByb3RvdHlwZVsnZW50cmllcyddKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnQEBpdGVyYXRvcic7XG4gICAgfVxufVxuZXhwb3J0cy5zeW1ib2xJdGVyYXRvclBvbnlmaWxsID0gc3ltYm9sSXRlcmF0b3JQb255ZmlsbDtcbmV4cG9ydHMuaXRlcmF0b3IgPSBzeW1ib2xJdGVyYXRvclBvbnlmaWxsKHJvb3RfMS5yb290KTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGl0ZXJhdG9yIGluc3RlYWRcbiAqL1xuZXhwb3J0cy4kJGl0ZXJhdG9yID0gZXhwb3J0cy5pdGVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZXJhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xuZnVuY3Rpb24gZ2V0U3ltYm9sT2JzZXJ2YWJsZShjb250ZXh0KSB7XG4gICAgdmFyICQkb2JzZXJ2YWJsZTtcbiAgICB2YXIgU3ltYm9sID0gY29udGV4dC5TeW1ib2w7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAkJG9ic2VydmFibGUgPSBTeW1ib2wub2JzZXJ2YWJsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICQkb2JzZXJ2YWJsZSA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuICAgICAgICAgICAgU3ltYm9sLm9ic2VydmFibGUgPSAkJG9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICQkb2JzZXJ2YWJsZSA9ICdAQG9ic2VydmFibGUnO1xuICAgIH1cbiAgICByZXR1cm4gJCRvYnNlcnZhYmxlO1xufVxuZXhwb3J0cy5nZXRTeW1ib2xPYnNlcnZhYmxlID0gZ2V0U3ltYm9sT2JzZXJ2YWJsZTtcbmV4cG9ydHMub2JzZXJ2YWJsZSA9IGdldFN5bWJvbE9ic2VydmFibGUocm9vdF8xLnJvb3QpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2Ugb2JzZXJ2YWJsZSBpbnN0ZWFkXG4gKi9cbmV4cG9ydHMuJCRvYnNlcnZhYmxlID0gZXhwb3J0cy5vYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBTeW1ib2wgPSByb290XzEucm9vdC5TeW1ib2w7XG5leHBvcnRzLnJ4U3Vic2NyaWJlciA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKSA/XG4gICAgU3ltYm9sLmZvcigncnhTdWJzY3JpYmVyJykgOiAnQEByeFN1YnNjcmliZXInO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgcnhTdWJzY3JpYmVyIGluc3RlYWRcbiAqL1xuZXhwb3J0cy4kJHJ4U3Vic2NyaWJlciA9IGV4cG9ydHMucnhTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnhTdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGFuIGFjdGlvbiBpcyBpbnZhbGlkIGJlY2F1c2UgdGhlIG9iamVjdCBoYXMgYmVlblxuICogdW5zdWJzY3JpYmVkLlxuICpcbiAqIEBzZWUge0BsaW5rIFN1YmplY3R9XG4gKiBAc2VlIHtAbGluayBCZWhhdmlvclN1YmplY3R9XG4gKlxuICogQGNsYXNzIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXG4gKi9cbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9iamVjdFVuc3Vic2NyaWJlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCkge1xuICAgICAgICB2YXIgZXJyID0gX3N1cGVyLmNhbGwodGhpcywgJ29iamVjdCB1bnN1YnNjcmliZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5PYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gb25lIG9yIG1vcmUgZXJyb3JzIGhhdmUgb2NjdXJyZWQgZHVyaW5nIHRoZVxuICogYHVuc3Vic2NyaWJlYCBvZiBhIHtAbGluayBTdWJzY3JpcHRpb259LlxuICovXG52YXIgVW5zdWJzY3JpcHRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVuc3Vic2NyaXB0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB2YXIgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBlcnJvcnMgP1xuICAgICAgICAgICAgZXJyb3JzLmxlbmd0aCArIFwiIGVycm9ycyBvY2N1cnJlZCBkdXJpbmcgdW5zdWJzY3JpcHRpb246XFxuICBcIiArIGVycm9ycy5tYXAoZnVuY3Rpb24gKGVyciwgaSkgeyByZXR1cm4gKChpICsgMSkgKyBcIikgXCIgKyBlcnIudG9TdHJpbmcoKSk7IH0pLmpvaW4oJ1xcbiAgJykgOiAnJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ1Vuc3Vic2NyaXB0aW9uRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIFVuc3Vic2NyaXB0aW9uRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlVuc3Vic2NyaXB0aW9uRXJyb3IgPSBVbnN1YnNjcmlwdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5zdWJzY3JpcHRpb25FcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIHR5cGVvZiBhbnkgc28gdGhhdCBpdCB3ZSBkb24ndCBoYXZlIHRvIGNhc3Qgd2hlbiBjb21wYXJpbmcgYSByZXN1bHQgdG8gdGhlIGVycm9yIG9iamVjdFxuZXhwb3J0cy5lcnJvck9iamVjdCA9IHsgZToge30gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgdHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJzsgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0FycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0FycmF5TGlrZSA9IChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB0eXBlb2YgeC5sZW5ndGggPT09ICdudW1iZXInOyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQXJyYXlMaWtlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4oK3ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNEYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzRnVuY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG5mdW5jdGlvbiBpc051bWVyaWModmFsKSB7XG4gICAgLy8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcIlwiKVxuICAgIC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcbiAgICAvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cbiAgICAvLyBhZGRpbmcgMSBjb3JyZWN0cyBsb3NzIG9mIHByZWNpc2lvbiBmcm9tIHBhcnNlRmxvYXQgKCMxNTEwMClcbiAgICByZXR1cm4gIWlzQXJyYXlfMS5pc0FycmF5KHZhbCkgJiYgKHZhbCAtIHBhcnNlRmxvYXQodmFsKSArIDEpID49IDA7XG59XG5leHBvcnRzLmlzTnVtZXJpYyA9IGlzTnVtZXJpYztcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzTnVtZXJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzUHJvbWlzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzU2NoZWR1bGVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zY2hlZHVsZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNTY2hlZHVsZXIgPSBpc1NjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiB3aW5kb3c6IGJyb3dzZXIgaW4gRE9NIG1haW4gdGhyZWFkXG4gKiBzZWxmOiBicm93c2VyIGluIFdlYldvcmtlclxuICogZ2xvYmFsOiBOb2RlLmpzL290aGVyXG4gKi9cbmV4cG9ydHMucm9vdCA9ICh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdy53aW5kb3cgPT09IHdpbmRvdyAmJiB3aW5kb3dcbiAgICB8fCB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZlxuICAgIHx8IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCk7XG5pZiAoIWV4cG9ydHMucm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUnhKUyBjb3VsZCBub3QgZmluZCBhbnkgZ2xvYmFsIGNvbnRleHQgKHdpbmRvdywgc2VsZiwgZ2xvYmFsKScpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm9vdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbnZhciBpc0FycmF5TGlrZV8xID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xudmFyIGlzUHJvbWlzZV8xID0gcmVxdWlyZSgnLi9pc1Byb21pc2UnKTtcbnZhciBpc09iamVjdF8xID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL2l0ZXJhdG9yJyk7XG52YXIgSW5uZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9Jbm5lclN1YnNjcmliZXInKTtcbnZhciBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvb2JzZXJ2YWJsZScpO1xuZnVuY3Rpb24gc3Vic2NyaWJlVG9SZXN1bHQob3V0ZXJTdWJzY3JpYmVyLCByZXN1bHQsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpIHtcbiAgICB2YXIgZGVzdGluYXRpb24gPSBuZXcgSW5uZXJTdWJzY3JpYmVyXzEuSW5uZXJTdWJzY3JpYmVyKG91dGVyU3Vic2NyaWJlciwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCk7XG4gICAgaWYgKGRlc3RpbmF0aW9uLmNsb3NlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSB7XG4gICAgICAgIGlmIChyZXN1bHQuX2lzU2NhbGFyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1YnNjcmliZShkZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheUxpa2VfMS5pc0FycmF5TGlrZShyZXN1bHQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuICYmICFkZXN0aW5hdGlvbi5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUHJvbWlzZV8xLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBkZXN0aW5hdGlvbi5lcnJvcihlcnIpOyB9KVxuICAgICAgICAgICAgLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgLy8gRXNjYXBpbmcgdGhlIFByb21pc2UgdHJhcDogZ2xvYmFsbHkgdGhyb3cgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICAgICAgcm9vdF8xLnJvb3Quc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W2l0ZXJhdG9yXzEuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHJlc3VsdFtpdGVyYXRvcl8xLml0ZXJhdG9yXSgpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W29ic2VydmFibGVfMS5vYnNlcnZhYmxlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgb2JzID0gcmVzdWx0W29ic2VydmFibGVfMS5vYnNlcnZhYmxlXSgpO1xuICAgICAgICBpZiAodHlwZW9mIG9icy5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBUeXBlRXJyb3IoJ1Byb3ZpZGVkIG9iamVjdCBkb2VzIG5vdCBjb3JyZWN0bHkgaW1wbGVtZW50IFN5bWJvbC5vYnNlcnZhYmxlJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9icy5zdWJzY3JpYmUobmV3IElubmVyU3Vic2NyaWJlcl8xLklubmVyU3Vic2NyaWJlcihvdXRlclN1YnNjcmliZXIsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaXNPYmplY3RfMS5pc09iamVjdChyZXN1bHQpID8gJ2FuIGludmFsaWQgb2JqZWN0JyA6IFwiJ1wiICsgcmVzdWx0ICsgXCInXCI7XG4gICAgICAgIHZhciBtc2cgPSAoXCJZb3UgcHJvdmlkZWQgXCIgKyB2YWx1ZSArIFwiIHdoZXJlIGEgc3RyZWFtIHdhcyBleHBlY3RlZC5cIilcbiAgICAgICAgICAgICsgJyBZb3UgY2FuIHByb3ZpZGUgYW4gT2JzZXJ2YWJsZSwgUHJvbWlzZSwgQXJyYXksIG9yIEl0ZXJhYmxlLic7XG4gICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBUeXBlRXJyb3IobXNnKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5zdWJzY3JpYmVUb1Jlc3VsdCA9IHN1YnNjcmliZVRvUmVzdWx0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3Vic2NyaWJlVG9SZXN1bHQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xudmFyIE9ic2VydmVyXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZlcicpO1xuZnVuY3Rpb24gdG9TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICBpZiAobmV4dE9yT2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyIGluc3RhbmNlb2YgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyXzEucnhTdWJzY3JpYmVyXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlcl8xLnJ4U3Vic2NyaWJlcl0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5leHRPck9ic2VydmVyICYmICFlcnJvciAmJiAhY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihPYnNlcnZlcl8xLmVtcHR5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbn1cbmV4cG9ydHMudG9TdWJzY3JpYmVyID0gdG9TdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9TdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL2Vycm9yT2JqZWN0Jyk7XG52YXIgdHJ5Q2F0Y2hUYXJnZXQ7XG5mdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnlDYXRjaFRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIHRyeUNhdGNoVGFyZ2V0ID0gZm47XG4gICAgcmV0dXJuIHRyeUNhdGNoZXI7XG59XG5leHBvcnRzLnRyeUNhdGNoID0gdHJ5Q2F0Y2g7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cnlDYXRjaC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0FycmF5aXNoID0gcmVxdWlyZSgnaXMtYXJyYXlpc2gnKTtcblxudmFyIGNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbnZhciBzd2l6emxlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzd2l6emxlKGFyZ3MpIHtcblx0dmFyIHJlc3VsdHMgPSBbXTtcblxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdHZhciBhcmcgPSBhcmdzW2ldO1xuXG5cdFx0aWYgKGlzQXJyYXlpc2goYXJnKSkge1xuXHRcdFx0Ly8gaHR0cDovL2pzcGVyZi5jb20vamF2YXNjcmlwdC1hcnJheS1jb25jYXQtdnMtcHVzaC85OFxuXHRcdFx0cmVzdWx0cyA9IGNvbmNhdC5jYWxsKHJlc3VsdHMsIHNsaWNlLmNhbGwoYXJnKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdHMucHVzaChhcmcpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuc3dpenpsZS53cmFwID0gZnVuY3Rpb24gKGZuKSB7XG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGZuKHN3aXp6bGUoYXJndW1lbnRzKSk7XG5cdH07XG59O1xuIiwiLy8gQ29weXJpZ2h0IDIwMTQgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gICAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4hZnVuY3Rpb24oYSxiKXt2YXIgYz17fSxkPXt9LGU9e30sZj1udWxsOyFmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGEpcmV0dXJuIGE7dmFyIGI9e307Zm9yKHZhciBjIGluIGEpYltjXT1hW2NdO3JldHVybiBifWZ1bmN0aW9uIGQoKXt0aGlzLl9kZWxheT0wLHRoaXMuX2VuZERlbGF5PTAsdGhpcy5fZmlsbD1cIm5vbmVcIix0aGlzLl9pdGVyYXRpb25TdGFydD0wLHRoaXMuX2l0ZXJhdGlvbnM9MSx0aGlzLl9kdXJhdGlvbj0wLHRoaXMuX3BsYXliYWNrUmF0ZT0xLHRoaXMuX2RpcmVjdGlvbj1cIm5vcm1hbFwiLHRoaXMuX2Vhc2luZz1cImxpbmVhclwiLHRoaXMuX2Vhc2luZ0Z1bmN0aW9uPXh9ZnVuY3Rpb24gZSgpe3JldHVybiBhLmlzRGVwcmVjYXRlZChcIkludmFsaWQgdGltaW5nIGlucHV0c1wiLFwiMjAxNi0wMy0wMlwiLFwiVHlwZUVycm9yIGV4Y2VwdGlvbnMgd2lsbCBiZSB0aHJvd24gaW5zdGVhZC5cIiwhMCl9ZnVuY3Rpb24gZihiLGMsZSl7dmFyIGY9bmV3IGQ7cmV0dXJuIGMmJihmLmZpbGw9XCJib3RoXCIsZi5kdXJhdGlvbj1cImF1dG9cIiksXCJudW1iZXJcIiE9dHlwZW9mIGJ8fGlzTmFOKGIpP3ZvaWQgMCE9PWImJk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGIpLmZvckVhY2goZnVuY3Rpb24oYyl7aWYoXCJhdXRvXCIhPWJbY10pe2lmKChcIm51bWJlclwiPT10eXBlb2YgZltjXXx8XCJkdXJhdGlvblwiPT1jKSYmKFwibnVtYmVyXCIhPXR5cGVvZiBiW2NdfHxpc05hTihiW2NdKSkpcmV0dXJuO2lmKFwiZmlsbFwiPT1jJiZ2LmluZGV4T2YoYltjXSk9PS0xKXJldHVybjtpZihcImRpcmVjdGlvblwiPT1jJiZ3LmluZGV4T2YoYltjXSk9PS0xKXJldHVybjtpZihcInBsYXliYWNrUmF0ZVwiPT1jJiYxIT09YltjXSYmYS5pc0RlcHJlY2F0ZWQoXCJBbmltYXRpb25FZmZlY3RUaW1pbmcucGxheWJhY2tSYXRlXCIsXCIyMDE0LTExLTI4XCIsXCJVc2UgQW5pbWF0aW9uLnBsYXliYWNrUmF0ZSBpbnN0ZWFkLlwiKSlyZXR1cm47ZltjXT1iW2NdfX0pOmYuZHVyYXRpb249YixmfWZ1bmN0aW9uIGcoYSl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIGEmJihhPWlzTmFOKGEpP3tkdXJhdGlvbjowfTp7ZHVyYXRpb246YX0pLGF9ZnVuY3Rpb24gaChiLGMpe3JldHVybiBiPWEubnVtZXJpY1RpbWluZ1RvT2JqZWN0KGIpLGYoYixjKX1mdW5jdGlvbiBpKGEsYixjLGQpe3JldHVybiBhPDB8fGE+MXx8YzwwfHxjPjE/eDpmdW5jdGlvbihlKXtmdW5jdGlvbiBmKGEsYixjKXtyZXR1cm4gMyphKigxLWMpKigxLWMpKmMrMypiKigxLWMpKmMqYytjKmMqY31pZihlPD0wKXt2YXIgZz0wO3JldHVybiBhPjA/Zz1iL2E6IWImJmM+MCYmKGc9ZC9jKSxnKmV9aWYoZT49MSl7dmFyIGg9MDtyZXR1cm4gYzwxP2g9KGQtMSkvKGMtMSk6MT09YyYmYTwxJiYoaD0oYi0xKS8oYS0xKSksMStoKihlLTEpfWZvcih2YXIgaT0wLGo9MTtpPGo7KXt2YXIgaz0oaStqKS8yLGw9ZihhLGMsayk7aWYoTWF0aC5hYnMoZS1sKTwxZS01KXJldHVybiBmKGIsZCxrKTtsPGU/aT1rOmo9a31yZXR1cm4gZihiLGQsayl9fWZ1bmN0aW9uIGooYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7aWYoYz49MSlyZXR1cm4gMTt2YXIgZD0xL2E7cmV0dXJuIGMrPWIqZCxjLWMlZH19ZnVuY3Rpb24gayhhKXtDfHwoQz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlKSxDLmFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uPVwiXCIsQy5hbmltYXRpb25UaW1pbmdGdW5jdGlvbj1hO3ZhciBiPUMuYW5pbWF0aW9uVGltaW5nRnVuY3Rpb247aWYoXCJcIj09YiYmZSgpKXRocm93IG5ldyBUeXBlRXJyb3IoYStcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgZWFzaW5nXCIpO3JldHVybiBifWZ1bmN0aW9uIGwoYSl7aWYoXCJsaW5lYXJcIj09YSlyZXR1cm4geDt2YXIgYj1FLmV4ZWMoYSk7aWYoYilyZXR1cm4gaS5hcHBseSh0aGlzLGIuc2xpY2UoMSkubWFwKE51bWJlcikpO3ZhciBjPUYuZXhlYyhhKTtpZihjKXJldHVybiBqKE51bWJlcihjWzFdKSx7c3RhcnQ6eSxtaWRkbGU6eixlbmQ6QX1bY1syXV0pO3ZhciBkPUJbYV07cmV0dXJuIGQ/ZDp4fWZ1bmN0aW9uIG0oYSl7cmV0dXJuIE1hdGguYWJzKG4oYSkvYS5wbGF5YmFja1JhdGUpfWZ1bmN0aW9uIG4oYSl7cmV0dXJuIDA9PT1hLmR1cmF0aW9ufHwwPT09YS5pdGVyYXRpb25zPzA6YS5kdXJhdGlvbiphLml0ZXJhdGlvbnN9ZnVuY3Rpb24gbyhhLGIsYyl7aWYobnVsbD09YilyZXR1cm4gRzt2YXIgZD1jLmRlbGF5K2ErYy5lbmREZWxheTtyZXR1cm4gYjxNYXRoLm1pbihjLmRlbGF5LGQpP0g6Yj49TWF0aC5taW4oYy5kZWxheSthLGQpP0k6Sn1mdW5jdGlvbiBwKGEsYixjLGQsZSl7c3dpdGNoKGQpe2Nhc2UgSDpyZXR1cm5cImJhY2t3YXJkc1wiPT1ifHxcImJvdGhcIj09Yj8wOm51bGw7Y2FzZSBKOnJldHVybiBjLWU7Y2FzZSBJOnJldHVyblwiZm9yd2FyZHNcIj09Ynx8XCJib3RoXCI9PWI/YTpudWxsO2Nhc2UgRzpyZXR1cm4gbnVsbH19ZnVuY3Rpb24gcShhLGIsYyxkLGUpe3ZhciBmPWU7cmV0dXJuIDA9PT1hP2IhPT1IJiYoZis9Yyk6Zis9ZC9hLGZ9ZnVuY3Rpb24gcihhLGIsYyxkLGUsZil7dmFyIGc9YT09PTEvMD9iJTE6YSUxO3JldHVybiAwIT09Z3x8YyE9PUl8fDA9PT1kfHwwPT09ZSYmMCE9PWZ8fChnPTEpLGd9ZnVuY3Rpb24gcyhhLGIsYyxkKXtyZXR1cm4gYT09PUkmJmI9PT0xLzA/MS8wOjE9PT1jP01hdGguZmxvb3IoZCktMTpNYXRoLmZsb29yKGQpfWZ1bmN0aW9uIHQoYSxiLGMpe3ZhciBkPWE7aWYoXCJub3JtYWxcIiE9PWEmJlwicmV2ZXJzZVwiIT09YSl7dmFyIGU9YjtcImFsdGVybmF0ZS1yZXZlcnNlXCI9PT1hJiYoZSs9MSksZD1cIm5vcm1hbFwiLGUhPT0xLzAmJmUlMiE9PTAmJihkPVwicmV2ZXJzZVwiKX1yZXR1cm5cIm5vcm1hbFwiPT09ZD9jOjEtY31mdW5jdGlvbiB1KGEsYixjKXt2YXIgZD1vKGEsYixjKSxlPXAoYSxjLmZpbGwsYixkLGMuZGVsYXkpO2lmKG51bGw9PT1lKXJldHVybiBudWxsO3ZhciBmPXEoYy5kdXJhdGlvbixkLGMuaXRlcmF0aW9ucyxlLGMuaXRlcmF0aW9uU3RhcnQpLGc9cihmLGMuaXRlcmF0aW9uU3RhcnQsZCxjLml0ZXJhdGlvbnMsZSxjLmR1cmF0aW9uKSxoPXMoZCxjLml0ZXJhdGlvbnMsZyxmKSxpPXQoYy5kaXJlY3Rpb24saCxnKTtyZXR1cm4gYy5fZWFzaW5nRnVuY3Rpb24oaSl9dmFyIHY9XCJiYWNrd2FyZHN8Zm9yd2FyZHN8Ym90aHxub25lXCIuc3BsaXQoXCJ8XCIpLHc9XCJyZXZlcnNlfGFsdGVybmF0ZXxhbHRlcm5hdGUtcmV2ZXJzZVwiLnNwbGl0KFwifFwiKSx4PWZ1bmN0aW9uKGEpe3JldHVybiBhfTtkLnByb3RvdHlwZT17X3NldE1lbWJlcjpmdW5jdGlvbihiLGMpe3RoaXNbXCJfXCIrYl09Yyx0aGlzLl9lZmZlY3QmJih0aGlzLl9lZmZlY3QuX3RpbWluZ0lucHV0W2JdPWMsdGhpcy5fZWZmZWN0Ll90aW1pbmc9YS5ub3JtYWxpemVUaW1pbmdJbnB1dCh0aGlzLl9lZmZlY3QuX3RpbWluZ0lucHV0KSx0aGlzLl9lZmZlY3QuYWN0aXZlRHVyYXRpb249YS5jYWxjdWxhdGVBY3RpdmVEdXJhdGlvbih0aGlzLl9lZmZlY3QuX3RpbWluZyksdGhpcy5fZWZmZWN0Ll9hbmltYXRpb24mJnRoaXMuX2VmZmVjdC5fYW5pbWF0aW9uLl9yZWJ1aWxkVW5kZXJseWluZ0FuaW1hdGlvbigpKX0sZ2V0IHBsYXliYWNrUmF0ZSgpe3JldHVybiB0aGlzLl9wbGF5YmFja1JhdGV9LHNldCBkZWxheShhKXt0aGlzLl9zZXRNZW1iZXIoXCJkZWxheVwiLGEpfSxnZXQgZGVsYXkoKXtyZXR1cm4gdGhpcy5fZGVsYXl9LHNldCBlbmREZWxheShhKXt0aGlzLl9zZXRNZW1iZXIoXCJlbmREZWxheVwiLGEpfSxnZXQgZW5kRGVsYXkoKXtyZXR1cm4gdGhpcy5fZW5kRGVsYXl9LHNldCBmaWxsKGEpe3RoaXMuX3NldE1lbWJlcihcImZpbGxcIixhKX0sZ2V0IGZpbGwoKXtyZXR1cm4gdGhpcy5fZmlsbH0sc2V0IGl0ZXJhdGlvblN0YXJ0KGEpe2lmKChpc05hTihhKXx8YTwwKSYmZSgpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRpb25TdGFydCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlciwgcmVjZWl2ZWQ6IFwiK3RpbWluZy5pdGVyYXRpb25TdGFydCk7dGhpcy5fc2V0TWVtYmVyKFwiaXRlcmF0aW9uU3RhcnRcIixhKX0sZ2V0IGl0ZXJhdGlvblN0YXJ0KCl7cmV0dXJuIHRoaXMuX2l0ZXJhdGlvblN0YXJ0fSxzZXQgZHVyYXRpb24oYSl7aWYoXCJhdXRvXCIhPWEmJihpc05hTihhKXx8YTwwKSYmZSgpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJkdXJhdGlvbiBtdXN0IGJlIG5vbi1uZWdhdGl2ZSBvciBhdXRvLCByZWNlaXZlZDogXCIrYSk7dGhpcy5fc2V0TWVtYmVyKFwiZHVyYXRpb25cIixhKX0sZ2V0IGR1cmF0aW9uKCl7cmV0dXJuIHRoaXMuX2R1cmF0aW9ufSxzZXQgZGlyZWN0aW9uKGEpe3RoaXMuX3NldE1lbWJlcihcImRpcmVjdGlvblwiLGEpfSxnZXQgZGlyZWN0aW9uKCl7cmV0dXJuIHRoaXMuX2RpcmVjdGlvbn0sc2V0IGVhc2luZyhhKXt0aGlzLl9lYXNpbmdGdW5jdGlvbj1sKGsoYSkpLHRoaXMuX3NldE1lbWJlcihcImVhc2luZ1wiLGEpfSxnZXQgZWFzaW5nKCl7cmV0dXJuIHRoaXMuX2Vhc2luZ30sc2V0IGl0ZXJhdGlvbnMoYSl7aWYoKGlzTmFOKGEpfHxhPDApJiZlKCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIml0ZXJhdGlvbnMgbXVzdCBiZSBub24tbmVnYXRpdmUsIHJlY2VpdmVkOiBcIithKTt0aGlzLl9zZXRNZW1iZXIoXCJpdGVyYXRpb25zXCIsYSl9LGdldCBpdGVyYXRpb25zKCl7cmV0dXJuIHRoaXMuX2l0ZXJhdGlvbnN9fTt2YXIgeT0xLHo9LjUsQT0wLEI9e2Vhc2U6aSguMjUsLjEsLjI1LDEpLFwiZWFzZS1pblwiOmkoLjQyLDAsMSwxKSxcImVhc2Utb3V0XCI6aSgwLDAsLjU4LDEpLFwiZWFzZS1pbi1vdXRcIjppKC40MiwwLC41OCwxKSxcInN0ZXAtc3RhcnRcIjpqKDEseSksXCJzdGVwLW1pZGRsZVwiOmooMSx6KSxcInN0ZXAtZW5kXCI6aigxLEEpfSxDPW51bGwsRD1cIlxcXFxzKigtP1xcXFxkK1xcXFwuP1xcXFxkKnwtP1xcXFwuXFxcXGQrKVxcXFxzKlwiLEU9bmV3IFJlZ0V4cChcImN1YmljLWJlemllclxcXFwoXCIrRCtcIixcIitEK1wiLFwiK0QrXCIsXCIrRCtcIlxcXFwpXCIpLEY9L3N0ZXBzXFwoXFxzKihcXGQrKVxccyosXFxzKihzdGFydHxtaWRkbGV8ZW5kKVxccypcXCkvLEc9MCxIPTEsST0yLEo9MzthLmNsb25lVGltaW5nSW5wdXQ9YyxhLm1ha2VUaW1pbmc9ZixhLm51bWVyaWNUaW1pbmdUb09iamVjdD1nLGEubm9ybWFsaXplVGltaW5nSW5wdXQ9aCxhLmNhbGN1bGF0ZUFjdGl2ZUR1cmF0aW9uPW0sYS5jYWxjdWxhdGVJdGVyYXRpb25Qcm9ncmVzcz11LGEuY2FsY3VsYXRlUGhhc2U9byxhLm5vcm1hbGl6ZUVhc2luZz1rLGEucGFyc2VFYXNpbmdGdW5jdGlvbj1sfShjLGYpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIpe3JldHVybiBhIGluIGs/a1thXVtiXXx8YjpifWZ1bmN0aW9uIGQoYSl7cmV0dXJuXCJkaXNwbGF5XCI9PT1hfHwwPT09YS5sYXN0SW5kZXhPZihcImFuaW1hdGlvblwiLDApfHwwPT09YS5sYXN0SW5kZXhPZihcInRyYW5zaXRpb25cIiwwKX1mdW5jdGlvbiBlKGEsYixlKXtpZighZChhKSl7dmFyIGY9aFthXTtpZihmKXtpLnN0eWxlW2FdPWI7Zm9yKHZhciBnIGluIGYpe3ZhciBqPWZbZ10saz1pLnN0eWxlW2pdO2Vbal09YyhqLGspfX1lbHNlIGVbYV09YyhhLGIpfX1mdW5jdGlvbiBmKGEpe3ZhciBiPVtdO2Zvcih2YXIgYyBpbiBhKWlmKCEoYyBpbltcImVhc2luZ1wiLFwib2Zmc2V0XCIsXCJjb21wb3NpdGVcIl0pKXt2YXIgZD1hW2NdO0FycmF5LmlzQXJyYXkoZCl8fChkPVtkXSk7Zm9yKHZhciBlLGY9ZC5sZW5ndGgsZz0wO2c8ZjtnKyspZT17fSxcIm9mZnNldFwiaW4gYT9lLm9mZnNldD1hLm9mZnNldDoxPT1mP2Uub2Zmc2V0PTE6ZS5vZmZzZXQ9Zy8oZi0xKSxcImVhc2luZ1wiaW4gYSYmKGUuZWFzaW5nPWEuZWFzaW5nKSxcImNvbXBvc2l0ZVwiaW4gYSYmKGUuY29tcG9zaXRlPWEuY29tcG9zaXRlKSxlW2NdPWRbZ10sYi5wdXNoKGUpfXJldHVybiBiLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5vZmZzZXQtYi5vZmZzZXR9KSxifWZ1bmN0aW9uIGcoYil7ZnVuY3Rpb24gYygpe3ZhciBhPWQubGVuZ3RoO251bGw9PWRbYS0xXS5vZmZzZXQmJihkW2EtMV0ub2Zmc2V0PTEpLGE+MSYmbnVsbD09ZFswXS5vZmZzZXQmJihkWzBdLm9mZnNldD0wKTtmb3IodmFyIGI9MCxjPWRbMF0ub2Zmc2V0LGU9MTtlPGE7ZSsrKXt2YXIgZj1kW2VdLm9mZnNldDtpZihudWxsIT1mKXtmb3IodmFyIGc9MTtnPGUtYjtnKyspZFtiK2ddLm9mZnNldD1jKyhmLWMpKmcvKGUtYik7Yj1lLGM9Zn19fWlmKG51bGw9PWIpcmV0dXJuW107d2luZG93LlN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yJiZBcnJheS5wcm90b3R5cGUuZnJvbSYmYltTeW1ib2wuaXRlcmF0b3JdJiYoYj1BcnJheS5mcm9tKGIpKSxBcnJheS5pc0FycmF5KGIpfHwoYj1mKGIpKTtmb3IodmFyIGQ9Yi5tYXAoZnVuY3Rpb24oYil7dmFyIGM9e307Zm9yKHZhciBkIGluIGIpe3ZhciBmPWJbZF07aWYoXCJvZmZzZXRcIj09ZCl7aWYobnVsbCE9Zil7aWYoZj1OdW1iZXIoZiksIWlzRmluaXRlKGYpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJLZXlmcmFtZSBvZmZzZXRzIG11c3QgYmUgbnVtYmVycy5cIik7aWYoZjwwfHxmPjEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIktleWZyYW1lIG9mZnNldHMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuXCIpfX1lbHNlIGlmKFwiY29tcG9zaXRlXCI9PWQpe2lmKFwiYWRkXCI9PWZ8fFwiYWNjdW11bGF0ZVwiPT1mKXRocm93e3R5cGU6RE9NRXhjZXB0aW9uLk5PVF9TVVBQT1JURURfRVJSLG5hbWU6XCJOb3RTdXBwb3J0ZWRFcnJvclwiLG1lc3NhZ2U6XCJhZGQgY29tcG9zaXRpbmcgaXMgbm90IHN1cHBvcnRlZFwifTtpZihcInJlcGxhY2VcIiE9Zil0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBjb21wb3NpdGUgbW9kZSBcIitmK1wiLlwiKX1lbHNlIGY9XCJlYXNpbmdcIj09ZD9hLm5vcm1hbGl6ZUVhc2luZyhmKTpcIlwiK2Y7ZShkLGYsYyl9cmV0dXJuIHZvaWQgMD09Yy5vZmZzZXQmJihjLm9mZnNldD1udWxsKSx2b2lkIDA9PWMuZWFzaW5nJiYoYy5lYXNpbmc9XCJsaW5lYXJcIiksY30pLGc9ITAsaD0tKDEvMCksaT0wO2k8ZC5sZW5ndGg7aSsrKXt2YXIgaj1kW2ldLm9mZnNldDtpZihudWxsIT1qKXtpZihqPGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIktleWZyYW1lcyBhcmUgbm90IGxvb3NlbHkgc29ydGVkIGJ5IG9mZnNldC4gU29ydCBvciBzcGVjaWZ5IG9mZnNldHMuXCIpO2g9an1lbHNlIGc9ITF9cmV0dXJuIGQ9ZC5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGEub2Zmc2V0Pj0wJiZhLm9mZnNldDw9MX0pLGd8fGMoKSxkfXZhciBoPXtiYWNrZ3JvdW5kOltcImJhY2tncm91bmRJbWFnZVwiLFwiYmFja2dyb3VuZFBvc2l0aW9uXCIsXCJiYWNrZ3JvdW5kU2l6ZVwiLFwiYmFja2dyb3VuZFJlcGVhdFwiLFwiYmFja2dyb3VuZEF0dGFjaG1lbnRcIixcImJhY2tncm91bmRPcmlnaW5cIixcImJhY2tncm91bmRDbGlwXCIsXCJiYWNrZ3JvdW5kQ29sb3JcIl0sYm9yZGVyOltcImJvcmRlclRvcENvbG9yXCIsXCJib3JkZXJUb3BTdHlsZVwiLFwiYm9yZGVyVG9wV2lkdGhcIixcImJvcmRlclJpZ2h0Q29sb3JcIixcImJvcmRlclJpZ2h0U3R5bGVcIixcImJvcmRlclJpZ2h0V2lkdGhcIixcImJvcmRlckJvdHRvbUNvbG9yXCIsXCJib3JkZXJCb3R0b21TdHlsZVwiLFwiYm9yZGVyQm90dG9tV2lkdGhcIixcImJvcmRlckxlZnRDb2xvclwiLFwiYm9yZGVyTGVmdFN0eWxlXCIsXCJib3JkZXJMZWZ0V2lkdGhcIl0sYm9yZGVyQm90dG9tOltcImJvcmRlckJvdHRvbVdpZHRoXCIsXCJib3JkZXJCb3R0b21TdHlsZVwiLFwiYm9yZGVyQm90dG9tQ29sb3JcIl0sYm9yZGVyQ29sb3I6W1wiYm9yZGVyVG9wQ29sb3JcIixcImJvcmRlclJpZ2h0Q29sb3JcIixcImJvcmRlckJvdHRvbUNvbG9yXCIsXCJib3JkZXJMZWZ0Q29sb3JcIl0sYm9yZGVyTGVmdDpbXCJib3JkZXJMZWZ0V2lkdGhcIixcImJvcmRlckxlZnRTdHlsZVwiLFwiYm9yZGVyTGVmdENvbG9yXCJdLGJvcmRlclJhZGl1czpbXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIl0sYm9yZGVyUmlnaHQ6W1wiYm9yZGVyUmlnaHRXaWR0aFwiLFwiYm9yZGVyUmlnaHRTdHlsZVwiLFwiYm9yZGVyUmlnaHRDb2xvclwiXSxib3JkZXJUb3A6W1wiYm9yZGVyVG9wV2lkdGhcIixcImJvcmRlclRvcFN0eWxlXCIsXCJib3JkZXJUb3BDb2xvclwiXSxib3JkZXJXaWR0aDpbXCJib3JkZXJUb3BXaWR0aFwiLFwiYm9yZGVyUmlnaHRXaWR0aFwiLFwiYm9yZGVyQm90dG9tV2lkdGhcIixcImJvcmRlckxlZnRXaWR0aFwiXSxmbGV4OltcImZsZXhHcm93XCIsXCJmbGV4U2hyaW5rXCIsXCJmbGV4QmFzaXNcIl0sZm9udDpbXCJmb250RmFtaWx5XCIsXCJmb250U2l6ZVwiLFwiZm9udFN0eWxlXCIsXCJmb250VmFyaWFudFwiLFwiZm9udFdlaWdodFwiLFwibGluZUhlaWdodFwiXSxtYXJnaW46W1wibWFyZ2luVG9wXCIsXCJtYXJnaW5SaWdodFwiLFwibWFyZ2luQm90dG9tXCIsXCJtYXJnaW5MZWZ0XCJdLG91dGxpbmU6W1wib3V0bGluZUNvbG9yXCIsXCJvdXRsaW5lU3R5bGVcIixcIm91dGxpbmVXaWR0aFwiXSxwYWRkaW5nOltcInBhZGRpbmdUb3BcIixcInBhZGRpbmdSaWdodFwiLFwicGFkZGluZ0JvdHRvbVwiLFwicGFkZGluZ0xlZnRcIl19LGk9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFwiZGl2XCIpLGo9e3RoaW46XCIxcHhcIixtZWRpdW06XCIzcHhcIix0aGljazpcIjVweFwifSxrPXtib3JkZXJCb3R0b21XaWR0aDpqLGJvcmRlckxlZnRXaWR0aDpqLGJvcmRlclJpZ2h0V2lkdGg6aixib3JkZXJUb3BXaWR0aDpqLGZvbnRTaXplOntcInh4LXNtYWxsXCI6XCI2MCVcIixcIngtc21hbGxcIjpcIjc1JVwiLHNtYWxsOlwiODklXCIsbWVkaXVtOlwiMTAwJVwiLGxhcmdlOlwiMTIwJVwiLFwieC1sYXJnZVwiOlwiMTUwJVwiLFwieHgtbGFyZ2VcIjpcIjIwMCVcIn0sZm9udFdlaWdodDp7bm9ybWFsOlwiNDAwXCIsYm9sZDpcIjcwMFwifSxvdXRsaW5lV2lkdGg6aix0ZXh0U2hhZG93Ontub25lOlwiMHB4IDBweCAwcHggdHJhbnNwYXJlbnRcIn0sYm94U2hhZG93Ontub25lOlwiMHB4IDBweCAwcHggMHB4IHRyYW5zcGFyZW50XCJ9fTthLmNvbnZlcnRUb0FycmF5Rm9ybT1mLGEubm9ybWFsaXplS2V5ZnJhbWVzPWd9KGMsZiksZnVuY3Rpb24oYSl7dmFyIGI9e307YS5pc0RlcHJlY2F0ZWQ9ZnVuY3Rpb24oYSxjLGQsZSl7dmFyIGY9ZT9cImFyZVwiOlwiaXNcIixnPW5ldyBEYXRlLGg9bmV3IERhdGUoYyk7cmV0dXJuIGguc2V0TW9udGgoaC5nZXRNb250aCgpKzMpLCEoZzxoJiYoYSBpbiBifHxjb25zb2xlLndhcm4oXCJXZWIgQW5pbWF0aW9uczogXCIrYStcIiBcIitmK1wiIGRlcHJlY2F0ZWQgYW5kIHdpbGwgc3RvcCB3b3JraW5nIG9uIFwiK2gudG9EYXRlU3RyaW5nKCkrXCIuIFwiK2QpLGJbYV09ITAsMSkpfSxhLmRlcHJlY2F0ZWQ9ZnVuY3Rpb24oYixjLGQsZSl7dmFyIGY9ZT9cImFyZVwiOlwiaXNcIjtpZihhLmlzRGVwcmVjYXRlZChiLGMsZCxlKSl0aHJvdyBuZXcgRXJyb3IoYitcIiBcIitmK1wiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFwiK2QpfX0oYyksZnVuY3Rpb24oKXtpZihkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYW5pbWF0ZSl7dmFyIGE9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFuaW1hdGUoW10sMCksYj0hMDtpZihhJiYoYj0hMSxcInBsYXl8Y3VycmVudFRpbWV8cGF1c2V8cmV2ZXJzZXxwbGF5YmFja1JhdGV8Y2FuY2VsfGZpbmlzaHxzdGFydFRpbWV8cGxheVN0YXRlXCIuc3BsaXQoXCJ8XCIpLmZvckVhY2goZnVuY3Rpb24oYyl7dm9pZCAwPT09YVtjXSYmKGI9ITApfSkpLCFiKXJldHVybn0hZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYSl7Zm9yKHZhciBiPXt9LGM9MDtjPGEubGVuZ3RoO2MrKylmb3IodmFyIGQgaW4gYVtjXSlpZihcIm9mZnNldFwiIT1kJiZcImVhc2luZ1wiIT1kJiZcImNvbXBvc2l0ZVwiIT1kKXt2YXIgZT17b2Zmc2V0OmFbY10ub2Zmc2V0LGVhc2luZzphW2NdLmVhc2luZyx2YWx1ZTphW2NdW2RdfTtiW2RdPWJbZF18fFtdLGJbZF0ucHVzaChlKX1mb3IodmFyIGYgaW4gYil7dmFyIGc9YltmXTtpZigwIT1nWzBdLm9mZnNldHx8MSE9Z1tnLmxlbmd0aC0xXS5vZmZzZXQpdGhyb3d7dHlwZTpET01FeGNlcHRpb24uTk9UX1NVUFBPUlRFRF9FUlIsbmFtZTpcIk5vdFN1cHBvcnRlZEVycm9yXCIsbWVzc2FnZTpcIlBhcnRpYWwga2V5ZnJhbWVzIGFyZSBub3Qgc3VwcG9ydGVkXCJ9fXJldHVybiBifWZ1bmN0aW9uIGUoYyl7dmFyIGQ9W107Zm9yKHZhciBlIGluIGMpZm9yKHZhciBmPWNbZV0sZz0wO2c8Zi5sZW5ndGgtMTtnKyspe3ZhciBoPWcsaT1nKzEsaj1mW2hdLm9mZnNldCxrPWZbaV0ub2Zmc2V0LGw9aixtPWs7MD09ZyYmKGw9LSgxLzApLDA9PWsmJihpPWgpKSxnPT1mLmxlbmd0aC0yJiYobT0xLzAsMT09aiYmKGg9aSkpLGQucHVzaCh7YXBwbHlGcm9tOmwsYXBwbHlUbzptLHN0YXJ0T2Zmc2V0OmZbaF0ub2Zmc2V0LGVuZE9mZnNldDpmW2ldLm9mZnNldCxlYXNpbmdGdW5jdGlvbjphLnBhcnNlRWFzaW5nRnVuY3Rpb24oZltoXS5lYXNpbmcpLHByb3BlcnR5OmUsaW50ZXJwb2xhdGlvbjpiLnByb3BlcnR5SW50ZXJwb2xhdGlvbihlLGZbaF0udmFsdWUsZltpXS52YWx1ZSl9KX1yZXR1cm4gZC5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuc3RhcnRPZmZzZXQtYi5zdGFydE9mZnNldH0pLGR9Yi5jb252ZXJ0RWZmZWN0SW5wdXQ9ZnVuY3Rpb24oYyl7dmFyIGY9YS5ub3JtYWxpemVLZXlmcmFtZXMoYyksZz1kKGYpLGg9ZShnKTtyZXR1cm4gZnVuY3Rpb24oYSxjKXtpZihudWxsIT1jKWguZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBjPj1hLmFwcGx5RnJvbSYmYzxhLmFwcGx5VG99KS5mb3JFYWNoKGZ1bmN0aW9uKGQpe3ZhciBlPWMtZC5zdGFydE9mZnNldCxmPWQuZW5kT2Zmc2V0LWQuc3RhcnRPZmZzZXQsZz0wPT1mPzA6ZC5lYXNpbmdGdW5jdGlvbihlL2YpO2IuYXBwbHkoYSxkLnByb3BlcnR5LGQuaW50ZXJwb2xhdGlvbihnKSl9KTtlbHNlIGZvcih2YXIgZCBpbiBnKVwib2Zmc2V0XCIhPWQmJlwiZWFzaW5nXCIhPWQmJlwiY29tcG9zaXRlXCIhPWQmJmIuY2xlYXIoYSxkKX19fShjLGQsZiksZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYSl7cmV0dXJuIGEucmVwbGFjZSgvLSguKS9nLGZ1bmN0aW9uKGEsYil7cmV0dXJuIGIudG9VcHBlckNhc2UoKX0pfWZ1bmN0aW9uIGUoYSxiLGMpe2hbY109aFtjXXx8W10saFtjXS5wdXNoKFthLGJdKX1mdW5jdGlvbiBmKGEsYixjKXtmb3IodmFyIGY9MDtmPGMubGVuZ3RoO2YrKyl7dmFyIGc9Y1tmXTtlKGEsYixkKGcpKX19ZnVuY3Rpb24gZyhjLGUsZil7dmFyIGc9YzsvLS8udGVzdChjKSYmIWEuaXNEZXByZWNhdGVkKFwiSHlwaGVuYXRlZCBwcm9wZXJ0eSBuYW1lc1wiLFwiMjAxNi0wMy0yMlwiLFwiVXNlIGNhbWVsQ2FzZSBpbnN0ZWFkLlwiLCEwKSYmKGc9ZChjKSksXCJpbml0aWFsXCIhPWUmJlwiaW5pdGlhbFwiIT1mfHwoXCJpbml0aWFsXCI9PWUmJihlPWlbZ10pLFwiaW5pdGlhbFwiPT1mJiYoZj1pW2ddKSk7Zm9yKHZhciBqPWU9PWY/W106aFtnXSxrPTA7aiYmazxqLmxlbmd0aDtrKyspe3ZhciBsPWpba11bMF0oZSksbT1qW2tdWzBdKGYpO2lmKHZvaWQgMCE9PWwmJnZvaWQgMCE9PW0pe3ZhciBuPWpba11bMV0obCxtKTtpZihuKXt2YXIgbz1iLkludGVycG9sYXRpb24uYXBwbHkobnVsbCxuKTtyZXR1cm4gZnVuY3Rpb24oYSl7cmV0dXJuIDA9PWE/ZToxPT1hP2Y6byhhKX19fX1yZXR1cm4gYi5JbnRlcnBvbGF0aW9uKCExLCEwLGZ1bmN0aW9uKGEpe3JldHVybiBhP2Y6ZX0pfXZhciBoPXt9O2IuYWRkUHJvcGVydGllc0hhbmRsZXI9Zjt2YXIgaT17YmFja2dyb3VuZENvbG9yOlwidHJhbnNwYXJlbnRcIixiYWNrZ3JvdW5kUG9zaXRpb246XCIwJSAwJVwiLGJvcmRlckJvdHRvbUNvbG9yOlwiY3VycmVudENvbG9yXCIsYm9yZGVyQm90dG9tTGVmdFJhZGl1czpcIjBweFwiLGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOlwiMHB4XCIsYm9yZGVyQm90dG9tV2lkdGg6XCIzcHhcIixib3JkZXJMZWZ0Q29sb3I6XCJjdXJyZW50Q29sb3JcIixib3JkZXJMZWZ0V2lkdGg6XCIzcHhcIixib3JkZXJSaWdodENvbG9yOlwiY3VycmVudENvbG9yXCIsYm9yZGVyUmlnaHRXaWR0aDpcIjNweFwiLGJvcmRlclNwYWNpbmc6XCIycHhcIixib3JkZXJUb3BDb2xvcjpcImN1cnJlbnRDb2xvclwiLGJvcmRlclRvcExlZnRSYWRpdXM6XCIwcHhcIixib3JkZXJUb3BSaWdodFJhZGl1czpcIjBweFwiLGJvcmRlclRvcFdpZHRoOlwiM3B4XCIsYm90dG9tOlwiYXV0b1wiLGNsaXA6XCJyZWN0KDBweCwgMHB4LCAwcHgsIDBweClcIixjb2xvcjpcImJsYWNrXCIsZm9udFNpemU6XCIxMDAlXCIsZm9udFdlaWdodDpcIjQwMFwiLGhlaWdodDpcImF1dG9cIixsZWZ0OlwiYXV0b1wiLGxldHRlclNwYWNpbmc6XCJub3JtYWxcIixsaW5lSGVpZ2h0OlwiMTIwJVwiLG1hcmdpbkJvdHRvbTpcIjBweFwiLG1hcmdpbkxlZnQ6XCIwcHhcIixtYXJnaW5SaWdodDpcIjBweFwiLG1hcmdpblRvcDpcIjBweFwiLG1heEhlaWdodDpcIm5vbmVcIixtYXhXaWR0aDpcIm5vbmVcIixtaW5IZWlnaHQ6XCIwcHhcIixtaW5XaWR0aDpcIjBweFwiLG9wYWNpdHk6XCIxLjBcIixvdXRsaW5lQ29sb3I6XCJpbnZlcnRcIixvdXRsaW5lT2Zmc2V0OlwiMHB4XCIsb3V0bGluZVdpZHRoOlwiM3B4XCIscGFkZGluZ0JvdHRvbTpcIjBweFwiLHBhZGRpbmdMZWZ0OlwiMHB4XCIscGFkZGluZ1JpZ2h0OlwiMHB4XCIscGFkZGluZ1RvcDpcIjBweFwiLHJpZ2h0OlwiYXV0b1wiLHRleHRJbmRlbnQ6XCIwcHhcIix0ZXh0U2hhZG93OlwiMHB4IDBweCAwcHggdHJhbnNwYXJlbnRcIix0b3A6XCJhdXRvXCIsdHJhbnNmb3JtOlwiXCIsdmVydGljYWxBbGlnbjpcIjBweFwiLHZpc2liaWxpdHk6XCJ2aXNpYmxlXCIsd2lkdGg6XCJhdXRvXCIsd29yZFNwYWNpbmc6XCJub3JtYWxcIix6SW5kZXg6XCJhdXRvXCJ9O2IucHJvcGVydHlJbnRlcnBvbGF0aW9uPWd9KGMsZCxmKSxmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChiKXt2YXIgYz1hLmNhbGN1bGF0ZUFjdGl2ZUR1cmF0aW9uKGIpLGQ9ZnVuY3Rpb24oZCl7cmV0dXJuIGEuY2FsY3VsYXRlSXRlcmF0aW9uUHJvZ3Jlc3MoYyxkLGIpfTtyZXR1cm4gZC5fdG90YWxEdXJhdGlvbj1iLmRlbGF5K2MrYi5lbmREZWxheSxkfWIuS2V5ZnJhbWVFZmZlY3Q9ZnVuY3Rpb24oYyxlLGYsZyl7dmFyIGgsaT1kKGEubm9ybWFsaXplVGltaW5nSW5wdXQoZikpLGo9Yi5jb252ZXJ0RWZmZWN0SW5wdXQoZSksaz1mdW5jdGlvbigpe2ooYyxoKX07cmV0dXJuIGsuX3VwZGF0ZT1mdW5jdGlvbihhKXtyZXR1cm4gaD1pKGEpLG51bGwhPT1ofSxrLl9jbGVhcj1mdW5jdGlvbigpe2ooYyxudWxsKX0say5faGFzU2FtZVRhcmdldD1mdW5jdGlvbihhKXtyZXR1cm4gYz09PWF9LGsuX3RhcmdldD1jLGsuX3RvdGFsRHVyYXRpb249aS5fdG90YWxEdXJhdGlvbixrLl9pZD1nLGt9LGIuTnVsbEVmZmVjdD1mdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe2EmJihhKCksYT1udWxsKX07cmV0dXJuIGIuX3VwZGF0ZT1mdW5jdGlvbigpe3JldHVybiBudWxsfSxiLl90b3RhbER1cmF0aW9uPTAsYi5faGFzU2FtZVRhcmdldD1mdW5jdGlvbigpe3JldHVybiExfSxifX0oYyxkLGYpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIsYyl7Yy5lbnVtZXJhYmxlPSEwLGMuY29uZmlndXJhYmxlPSEwLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGIsYyl9ZnVuY3Rpb24gZChhKXt0aGlzLl9zdXJyb2dhdGVTdHlsZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsXCJkaXZcIikuc3R5bGUsdGhpcy5fc3R5bGU9YS5zdHlsZSx0aGlzLl9sZW5ndGg9MCx0aGlzLl9pc0FuaW1hdGVkUHJvcGVydHk9e307Zm9yKHZhciBiPTA7Yjx0aGlzLl9zdHlsZS5sZW5ndGg7YisrKXt2YXIgYz10aGlzLl9zdHlsZVtiXTt0aGlzLl9zdXJyb2dhdGVTdHlsZVtjXT10aGlzLl9zdHlsZVtjXX10aGlzLl91cGRhdGVJbmRpY2VzKCl9ZnVuY3Rpb24gZShhKXtpZighYS5fd2ViQW5pbWF0aW9uc1BhdGNoZWRTdHlsZSl7dmFyIGI9bmV3IGQoYSk7dHJ5e2MoYSxcInN0eWxlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBifX0pfWNhdGNoKGIpe2Euc3R5bGUuX3NldD1mdW5jdGlvbihiLGMpe2Euc3R5bGVbYl09Y30sYS5zdHlsZS5fY2xlYXI9ZnVuY3Rpb24oYil7YS5zdHlsZVtiXT1cIlwifX1hLl93ZWJBbmltYXRpb25zUGF0Y2hlZFN0eWxlPWEuc3R5bGV9fXZhciBmPXtjc3NUZXh0OjEsbGVuZ3RoOjEscGFyZW50UnVsZToxfSxnPXtnZXRQcm9wZXJ0eUNTU1ZhbHVlOjEsZ2V0UHJvcGVydHlQcmlvcml0eToxLGdldFByb3BlcnR5VmFsdWU6MSxpdGVtOjEscmVtb3ZlUHJvcGVydHk6MSxzZXRQcm9wZXJ0eToxfSxoPXtyZW1vdmVQcm9wZXJ0eToxLHNldFByb3BlcnR5OjF9O2QucHJvdG90eXBlPXtnZXQgY3NzVGV4dCgpe3JldHVybiB0aGlzLl9zdXJyb2dhdGVTdHlsZS5jc3NUZXh0fSxzZXQgY3NzVGV4dChhKXtmb3IodmFyIGI9e30sYz0wO2M8dGhpcy5fc3Vycm9nYXRlU3R5bGUubGVuZ3RoO2MrKyliW3RoaXMuX3N1cnJvZ2F0ZVN0eWxlW2NdXT0hMDt0aGlzLl9zdXJyb2dhdGVTdHlsZS5jc3NUZXh0PWEsdGhpcy5fdXBkYXRlSW5kaWNlcygpO2Zvcih2YXIgYz0wO2M8dGhpcy5fc3Vycm9nYXRlU3R5bGUubGVuZ3RoO2MrKyliW3RoaXMuX3N1cnJvZ2F0ZVN0eWxlW2NdXT0hMDtmb3IodmFyIGQgaW4gYil0aGlzLl9pc0FuaW1hdGVkUHJvcGVydHlbZF18fHRoaXMuX3N0eWxlLnNldFByb3BlcnR5KGQsdGhpcy5fc3Vycm9nYXRlU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShkKSl9LGdldCBsZW5ndGgoKXtyZXR1cm4gdGhpcy5fc3Vycm9nYXRlU3R5bGUubGVuZ3RofSxnZXQgcGFyZW50UnVsZSgpe3JldHVybiB0aGlzLl9zdHlsZS5wYXJlbnRSdWxlfSxfdXBkYXRlSW5kaWNlczpmdW5jdGlvbigpe2Zvcig7dGhpcy5fbGVuZ3RoPHRoaXMuX3N1cnJvZ2F0ZVN0eWxlLmxlbmd0aDspT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsdGhpcy5fbGVuZ3RoLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N1cnJvZ2F0ZVN0eWxlW2FdfX0odGhpcy5fbGVuZ3RoKX0pLHRoaXMuX2xlbmd0aCsrO2Zvcig7dGhpcy5fbGVuZ3RoPnRoaXMuX3N1cnJvZ2F0ZVN0eWxlLmxlbmd0aDspdGhpcy5fbGVuZ3RoLS0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsdGhpcy5fbGVuZ3RoLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMSx2YWx1ZTp2b2lkIDB9KX0sX3NldDpmdW5jdGlvbihhLGIpe3RoaXMuX3N0eWxlW2FdPWIsdGhpcy5faXNBbmltYXRlZFByb3BlcnR5W2FdPSEwfSxfY2xlYXI6ZnVuY3Rpb24oYSl7dGhpcy5fc3R5bGVbYV09dGhpcy5fc3Vycm9nYXRlU3R5bGVbYV0sZGVsZXRlIHRoaXMuX2lzQW5pbWF0ZWRQcm9wZXJ0eVthXX19O2Zvcih2YXIgaSBpbiBnKWQucHJvdG90eXBlW2ldPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGM9dGhpcy5fc3Vycm9nYXRlU3R5bGVbYV0uYXBwbHkodGhpcy5fc3Vycm9nYXRlU3R5bGUsYXJndW1lbnRzKTtyZXR1cm4gYiYmKHRoaXMuX2lzQW5pbWF0ZWRQcm9wZXJ0eVthcmd1bWVudHNbMF1dfHx0aGlzLl9zdHlsZVthXS5hcHBseSh0aGlzLl9zdHlsZSxhcmd1bWVudHMpLHRoaXMuX3VwZGF0ZUluZGljZXMoKSksY319KGksaSBpbiBoKTtmb3IodmFyIGogaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKWogaW4gZnx8aiBpbiBnfHwhZnVuY3Rpb24oYSl7YyhkLnByb3RvdHlwZSxhLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3Vycm9nYXRlU3R5bGVbYV19LHNldDpmdW5jdGlvbihiKXt0aGlzLl9zdXJyb2dhdGVTdHlsZVthXT1iLHRoaXMuX3VwZGF0ZUluZGljZXMoKSx0aGlzLl9pc0FuaW1hdGVkUHJvcGVydHlbYV18fCh0aGlzLl9zdHlsZVthXT1iKX19KX0oaik7YS5hcHBseT1mdW5jdGlvbihiLGMsZCl7ZShiKSxiLnN0eWxlLl9zZXQoYS5wcm9wZXJ0eU5hbWUoYyksZCl9LGEuY2xlYXI9ZnVuY3Rpb24oYixjKXtiLl93ZWJBbmltYXRpb25zUGF0Y2hlZFN0eWxlJiZiLnN0eWxlLl9jbGVhcihhLnByb3BlcnR5TmFtZShjKSl9fShkLGYpLGZ1bmN0aW9uKGEpe3dpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5hbmltYXRlPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9XCJcIjtyZXR1cm4gYyYmYy5pZCYmKGQ9Yy5pZCksYS50aW1lbGluZS5fcGxheShhLktleWZyYW1lRWZmZWN0KHRoaXMsYixjLGQpKX19KGQpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIsZCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGEmJlwibnVtYmVyXCI9PXR5cGVvZiBiKXJldHVybiBhKigxLWQpK2IqZDtpZihcImJvb2xlYW5cIj09dHlwZW9mIGEmJlwiYm9vbGVhblwiPT10eXBlb2YgYilyZXR1cm4gZDwuNT9hOmI7aWYoYS5sZW5ndGg9PWIubGVuZ3RoKXtmb3IodmFyIGU9W10sZj0wO2Y8YS5sZW5ndGg7ZisrKWUucHVzaChjKGFbZl0sYltmXSxkKSk7cmV0dXJuIGV9dGhyb3dcIk1pc21hdGNoZWQgaW50ZXJwb2xhdGlvbiBhcmd1bWVudHMgXCIrYStcIjpcIitifWEuSW50ZXJwb2xhdGlvbj1mdW5jdGlvbihhLGIsZCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBkKGMoYSxiLGUpKX19fShkLGYpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIsYyl7cmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGEsYyksYil9ZnVuY3Rpb24gZChiLGQsZSl7dmFyIGY9YS5kb3QoYixkKTtmPWMoZiwtMSwxKTt2YXIgZz1bXTtpZigxPT09ZilnPWI7ZWxzZSBmb3IodmFyIGg9TWF0aC5hY29zKGYpLGk9MSpNYXRoLnNpbihlKmgpL01hdGguc3FydCgxLWYqZiksaj0wO2o8NDtqKyspZy5wdXNoKGJbal0qKE1hdGguY29zKGUqaCktZippKStkW2pdKmkpO3JldHVybiBnfXZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIpe2Zvcih2YXIgYz1bWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdXSxkPTA7ZDw0O2QrKylmb3IodmFyIGU9MDtlPDQ7ZSsrKWZvcih2YXIgZj0wO2Y8NDtmKyspY1tkXVtlXSs9YltkXVtmXSphW2ZdW2VdO3JldHVybiBjfWZ1bmN0aW9uIGIoYSl7cmV0dXJuIDA9PWFbMF1bMl0mJjA9PWFbMF1bM10mJjA9PWFbMV1bMl0mJjA9PWFbMV1bM10mJjA9PWFbMl1bMF0mJjA9PWFbMl1bMV0mJjE9PWFbMl1bMl0mJjA9PWFbMl1bM10mJjA9PWFbM11bMl0mJjE9PWFbM11bM119ZnVuY3Rpb24gYyhjLGQsZSxmLGcpe2Zvcih2YXIgaD1bWzEsMCwwLDBdLFswLDEsMCwwXSxbMCwwLDEsMF0sWzAsMCwwLDFdXSxpPTA7aTw0O2krKyloW2ldWzNdPWdbaV07Zm9yKHZhciBpPTA7aTwzO2krKylmb3IodmFyIGo9MDtqPDM7aisrKWhbM11baV0rPWNbal0qaFtqXVtpXTt2YXIgaz1mWzBdLGw9ZlsxXSxtPWZbMl0sbj1mWzNdLG89W1sxLDAsMCwwXSxbMCwxLDAsMF0sWzAsMCwxLDBdLFswLDAsMCwxXV07b1swXVswXT0xLTIqKGwqbCttKm0pLG9bMF1bMV09MiooaypsLW0qbiksb1swXVsyXT0yKihrKm0rbCpuKSxvWzFdWzBdPTIqKGsqbCttKm4pLG9bMV1bMV09MS0yKihrKmsrbSptKSxvWzFdWzJdPTIqKGwqbS1rKm4pLG9bMl1bMF09MiooayptLWwqbiksb1syXVsxXT0yKihsKm0raypuKSxvWzJdWzJdPTEtMiooayprK2wqbCksaD1hKGgsbyk7dmFyIHA9W1sxLDAsMCwwXSxbMCwxLDAsMF0sWzAsMCwxLDBdLFswLDAsMCwxXV07ZVsyXSYmKHBbMl1bMV09ZVsyXSxoPWEoaCxwKSksZVsxXSYmKHBbMl1bMV09MCxwWzJdWzBdPWVbMF0saD1hKGgscCkpLGVbMF0mJihwWzJdWzBdPTAscFsxXVswXT1lWzBdLGg9YShoLHApKTtmb3IodmFyIGk9MDtpPDM7aSsrKWZvcih2YXIgaj0wO2o8MztqKyspaFtpXVtqXSo9ZFtpXTtyZXR1cm4gYihoKT9baFswXVswXSxoWzBdWzFdLGhbMV1bMF0saFsxXVsxXSxoWzNdWzBdLGhbM11bMV1dOmhbMF0uY29uY2F0KGhbMV0saFsyXSxoWzNdKX1yZXR1cm4gY30oKTthLmNvbXBvc2VNYXRyaXg9ZSxhLnF1YXQ9ZH0oZCxmKSxmdW5jdGlvbihhLGIsYyl7YS5zZXF1ZW5jZU51bWJlcj0wO3ZhciBkPWZ1bmN0aW9uKGEsYixjKXt0aGlzLnRhcmdldD1hLHRoaXMuY3VycmVudFRpbWU9Yix0aGlzLnRpbWVsaW5lVGltZT1jLHRoaXMudHlwZT1cImZpbmlzaFwiLHRoaXMuYnViYmxlcz0hMSx0aGlzLmNhbmNlbGFibGU9ITEsdGhpcy5jdXJyZW50VGFyZ2V0PWEsdGhpcy5kZWZhdWx0UHJldmVudGVkPSExLHRoaXMuZXZlbnRQaGFzZT1FdmVudC5BVF9UQVJHRVQsdGhpcy50aW1lU3RhbXA9RGF0ZS5ub3coKX07Yi5BbmltYXRpb249ZnVuY3Rpb24oYil7dGhpcy5pZD1cIlwiLGImJmIuX2lkJiYodGhpcy5pZD1iLl9pZCksdGhpcy5fc2VxdWVuY2VOdW1iZXI9YS5zZXF1ZW5jZU51bWJlcisrLHRoaXMuX2N1cnJlbnRUaW1lPTAsdGhpcy5fc3RhcnRUaW1lPW51bGwsdGhpcy5fcGF1c2VkPSExLHRoaXMuX3BsYXliYWNrUmF0ZT0xLHRoaXMuX2luVGltZWxpbmU9ITAsdGhpcy5fZmluaXNoZWRGbGFnPSEwLHRoaXMub25maW5pc2g9bnVsbCx0aGlzLl9maW5pc2hIYW5kbGVycz1bXSx0aGlzLl9lZmZlY3Q9Yix0aGlzLl9pbkVmZmVjdD10aGlzLl9lZmZlY3QuX3VwZGF0ZSgwKSx0aGlzLl9pZGxlPSEwLHRoaXMuX2N1cnJlbnRUaW1lUGVuZGluZz0hMX0sYi5BbmltYXRpb24ucHJvdG90eXBlPXtfZW5zdXJlQWxpdmU6ZnVuY3Rpb24oKXt0aGlzLnBsYXliYWNrUmF0ZTwwJiYwPT09dGhpcy5jdXJyZW50VGltZT90aGlzLl9pbkVmZmVjdD10aGlzLl9lZmZlY3QuX3VwZGF0ZSgtMSk6dGhpcy5faW5FZmZlY3Q9dGhpcy5fZWZmZWN0Ll91cGRhdGUodGhpcy5jdXJyZW50VGltZSksdGhpcy5faW5UaW1lbGluZXx8IXRoaXMuX2luRWZmZWN0JiZ0aGlzLl9maW5pc2hlZEZsYWd8fCh0aGlzLl9pblRpbWVsaW5lPSEwLGIudGltZWxpbmUuX2FuaW1hdGlvbnMucHVzaCh0aGlzKSl9LF90aWNrQ3VycmVudFRpbWU6ZnVuY3Rpb24oYSxiKXthIT10aGlzLl9jdXJyZW50VGltZSYmKHRoaXMuX2N1cnJlbnRUaW1lPWEsdGhpcy5faXNGaW5pc2hlZCYmIWImJih0aGlzLl9jdXJyZW50VGltZT10aGlzLl9wbGF5YmFja1JhdGU+MD90aGlzLl90b3RhbER1cmF0aW9uOjApLHRoaXMuX2Vuc3VyZUFsaXZlKCkpfSxnZXQgY3VycmVudFRpbWUoKXtyZXR1cm4gdGhpcy5faWRsZXx8dGhpcy5fY3VycmVudFRpbWVQZW5kaW5nP251bGw6dGhpcy5fY3VycmVudFRpbWV9LHNldCBjdXJyZW50VGltZShhKXthPSthLGlzTmFOKGEpfHwoYi5yZXN0YXJ0KCksdGhpcy5fcGF1c2VkfHxudWxsPT10aGlzLl9zdGFydFRpbWV8fCh0aGlzLl9zdGFydFRpbWU9dGhpcy5fdGltZWxpbmUuY3VycmVudFRpbWUtYS90aGlzLl9wbGF5YmFja1JhdGUpLHRoaXMuX2N1cnJlbnRUaW1lUGVuZGluZz0hMSx0aGlzLl9jdXJyZW50VGltZSE9YSYmKHRoaXMuX2lkbGUmJih0aGlzLl9pZGxlPSExLHRoaXMuX3BhdXNlZD0hMCksdGhpcy5fdGlja0N1cnJlbnRUaW1lKGEsITApLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpKSl9LGdldCBzdGFydFRpbWUoKXtyZXR1cm4gdGhpcy5fc3RhcnRUaW1lfSxzZXQgc3RhcnRUaW1lKGEpe2E9K2EsaXNOYU4oYSl8fHRoaXMuX3BhdXNlZHx8dGhpcy5faWRsZXx8KHRoaXMuX3N0YXJ0VGltZT1hLHRoaXMuX3RpY2tDdXJyZW50VGltZSgodGhpcy5fdGltZWxpbmUuY3VycmVudFRpbWUtdGhpcy5fc3RhcnRUaW1lKSp0aGlzLnBsYXliYWNrUmF0ZSksYi5hcHBseURpcnRpZWRBbmltYXRpb24odGhpcykpfSxnZXQgcGxheWJhY2tSYXRlKCl7cmV0dXJuIHRoaXMuX3BsYXliYWNrUmF0ZX0sc2V0IHBsYXliYWNrUmF0ZShhKXtpZihhIT10aGlzLl9wbGF5YmFja1JhdGUpe3ZhciBjPXRoaXMuY3VycmVudFRpbWU7dGhpcy5fcGxheWJhY2tSYXRlPWEsdGhpcy5fc3RhcnRUaW1lPW51bGwsXCJwYXVzZWRcIiE9dGhpcy5wbGF5U3RhdGUmJlwiaWRsZVwiIT10aGlzLnBsYXlTdGF0ZSYmKHRoaXMuX2ZpbmlzaGVkRmxhZz0hMSx0aGlzLl9pZGxlPSExLHRoaXMuX2Vuc3VyZUFsaXZlKCksYi5hcHBseURpcnRpZWRBbmltYXRpb24odGhpcykpLG51bGwhPWMmJih0aGlzLmN1cnJlbnRUaW1lPWMpfX0sZ2V0IF9pc0ZpbmlzaGVkKCl7cmV0dXJuIXRoaXMuX2lkbGUmJih0aGlzLl9wbGF5YmFja1JhdGU+MCYmdGhpcy5fY3VycmVudFRpbWU+PXRoaXMuX3RvdGFsRHVyYXRpb258fHRoaXMuX3BsYXliYWNrUmF0ZTwwJiZ0aGlzLl9jdXJyZW50VGltZTw9MCl9LGdldCBfdG90YWxEdXJhdGlvbigpe3JldHVybiB0aGlzLl9lZmZlY3QuX3RvdGFsRHVyYXRpb259LGdldCBwbGF5U3RhdGUoKXtyZXR1cm4gdGhpcy5faWRsZT9cImlkbGVcIjpudWxsPT10aGlzLl9zdGFydFRpbWUmJiF0aGlzLl9wYXVzZWQmJjAhPXRoaXMucGxheWJhY2tSYXRlfHx0aGlzLl9jdXJyZW50VGltZVBlbmRpbmc/XCJwZW5kaW5nXCI6dGhpcy5fcGF1c2VkP1wicGF1c2VkXCI6dGhpcy5faXNGaW5pc2hlZD9cImZpbmlzaGVkXCI6XCJydW5uaW5nXCJ9LF9yZXdpbmQ6ZnVuY3Rpb24oKXtpZih0aGlzLl9wbGF5YmFja1JhdGU+PTApdGhpcy5fY3VycmVudFRpbWU9MDtlbHNle2lmKCEodGhpcy5fdG90YWxEdXJhdGlvbjwxLzApKXRocm93IG5ldyBET01FeGNlcHRpb24oXCJVbmFibGUgdG8gcmV3aW5kIG5lZ2F0aXZlIHBsYXliYWNrIHJhdGUgYW5pbWF0aW9uIHdpdGggaW5maW5pdGUgZHVyYXRpb25cIixcIkludmFsaWRTdGF0ZUVycm9yXCIpO3RoaXMuX2N1cnJlbnRUaW1lPXRoaXMuX3RvdGFsRHVyYXRpb259fSxwbGF5OmZ1bmN0aW9uKCl7dGhpcy5fcGF1c2VkPSExLCh0aGlzLl9pc0ZpbmlzaGVkfHx0aGlzLl9pZGxlKSYmKHRoaXMuX3Jld2luZCgpLHRoaXMuX3N0YXJ0VGltZT1udWxsKSx0aGlzLl9maW5pc2hlZEZsYWc9ITEsdGhpcy5faWRsZT0hMSx0aGlzLl9lbnN1cmVBbGl2ZSgpLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpfSxwYXVzZTpmdW5jdGlvbigpe3RoaXMuX2lzRmluaXNoZWR8fHRoaXMuX3BhdXNlZHx8dGhpcy5faWRsZT90aGlzLl9pZGxlJiYodGhpcy5fcmV3aW5kKCksdGhpcy5faWRsZT0hMSk6dGhpcy5fY3VycmVudFRpbWVQZW5kaW5nPSEwLHRoaXMuX3N0YXJ0VGltZT1udWxsLHRoaXMuX3BhdXNlZD0hMH0sZmluaXNoOmZ1bmN0aW9uKCl7dGhpcy5faWRsZXx8KHRoaXMuY3VycmVudFRpbWU9dGhpcy5fcGxheWJhY2tSYXRlPjA/dGhpcy5fdG90YWxEdXJhdGlvbjowLHRoaXMuX3N0YXJ0VGltZT10aGlzLl90b3RhbER1cmF0aW9uLXRoaXMuY3VycmVudFRpbWUsdGhpcy5fY3VycmVudFRpbWVQZW5kaW5nPSExLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpKX0sY2FuY2VsOmZ1bmN0aW9uKCl7dGhpcy5faW5FZmZlY3QmJih0aGlzLl9pbkVmZmVjdD0hMSx0aGlzLl9pZGxlPSEwLHRoaXMuX3BhdXNlZD0hMSx0aGlzLl9pc0ZpbmlzaGVkPSEwLHRoaXMuX2ZpbmlzaGVkRmxhZz0hMCx0aGlzLl9jdXJyZW50VGltZT0wLHRoaXMuX3N0YXJ0VGltZT1udWxsLHRoaXMuX2VmZmVjdC5fdXBkYXRlKG51bGwpLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpKX0scmV2ZXJzZTpmdW5jdGlvbigpe3RoaXMucGxheWJhY2tSYXRlKj0tMSx0aGlzLnBsYXkoKX0sYWRkRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbihhLGIpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGImJlwiZmluaXNoXCI9PWEmJnRoaXMuX2ZpbmlzaEhhbmRsZXJzLnB1c2goYil9LHJlbW92ZUV2ZW50TGlzdGVuZXI6ZnVuY3Rpb24oYSxiKXtpZihcImZpbmlzaFwiPT1hKXt2YXIgYz10aGlzLl9maW5pc2hIYW5kbGVycy5pbmRleE9mKGIpO2M+PTAmJnRoaXMuX2ZpbmlzaEhhbmRsZXJzLnNwbGljZShjLDEpfX0sX2ZpcmVFdmVudHM6ZnVuY3Rpb24oYSl7aWYodGhpcy5faXNGaW5pc2hlZCl7aWYoIXRoaXMuX2ZpbmlzaGVkRmxhZyl7dmFyIGI9bmV3IGQodGhpcyx0aGlzLl9jdXJyZW50VGltZSxhKSxjPXRoaXMuX2ZpbmlzaEhhbmRsZXJzLmNvbmNhdCh0aGlzLm9uZmluaXNoP1t0aGlzLm9uZmluaXNoXTpbXSk7c2V0VGltZW91dChmdW5jdGlvbigpe2MuZm9yRWFjaChmdW5jdGlvbihhKXthLmNhbGwoYi50YXJnZXQsYil9KX0sMCksdGhpcy5fZmluaXNoZWRGbGFnPSEwfX1lbHNlIHRoaXMuX2ZpbmlzaGVkRmxhZz0hMX0sX3RpY2s6ZnVuY3Rpb24oYSxiKXt0aGlzLl9pZGxlfHx0aGlzLl9wYXVzZWR8fChudWxsPT10aGlzLl9zdGFydFRpbWU/YiYmKHRoaXMuc3RhcnRUaW1lPWEtdGhpcy5fY3VycmVudFRpbWUvdGhpcy5wbGF5YmFja1JhdGUpOnRoaXMuX2lzRmluaXNoZWR8fHRoaXMuX3RpY2tDdXJyZW50VGltZSgoYS10aGlzLl9zdGFydFRpbWUpKnRoaXMucGxheWJhY2tSYXRlKSksYiYmKHRoaXMuX2N1cnJlbnRUaW1lUGVuZGluZz0hMSx0aGlzLl9maXJlRXZlbnRzKGEpKX0sZ2V0IF9uZWVkc1RpY2soKXtyZXR1cm4gdGhpcy5wbGF5U3RhdGUgaW57cGVuZGluZzoxLHJ1bm5pbmc6MX18fCF0aGlzLl9maW5pc2hlZEZsYWd9LF90YXJnZXRBbmltYXRpb25zOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fZWZmZWN0Ll90YXJnZXQ7cmV0dXJuIGEuX2FjdGl2ZUFuaW1hdGlvbnN8fChhLl9hY3RpdmVBbmltYXRpb25zPVtdKSxhLl9hY3RpdmVBbmltYXRpb25zfSxfbWFya1RhcmdldDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX3RhcmdldEFuaW1hdGlvbnMoKTthLmluZGV4T2YodGhpcyk9PT0tMSYmYS5wdXNoKHRoaXMpfSxfdW5tYXJrVGFyZ2V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fdGFyZ2V0QW5pbWF0aW9ucygpLGI9YS5pbmRleE9mKHRoaXMpO2IhPT0tMSYmYS5zcGxpY2UoYiwxKX19fShjLGQsZiksZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYSl7dmFyIGI9ajtqPVtdLGE8cS5jdXJyZW50VGltZSYmKGE9cS5jdXJyZW50VGltZSkscS5fYW5pbWF0aW9ucy5zb3J0KGUpLHEuX2FuaW1hdGlvbnM9aChhLCEwLHEuX2FuaW1hdGlvbnMpWzBdLGIuZm9yRWFjaChmdW5jdGlvbihiKXtiWzFdKGEpfSksZygpLGw9dm9pZCAwfWZ1bmN0aW9uIGUoYSxiKXtyZXR1cm4gYS5fc2VxdWVuY2VOdW1iZXItYi5fc2VxdWVuY2VOdW1iZXJ9ZnVuY3Rpb24gZigpe3RoaXMuX2FuaW1hdGlvbnM9W10sdGhpcy5jdXJyZW50VGltZT13aW5kb3cucGVyZm9ybWFuY2UmJnBlcmZvcm1hbmNlLm5vdz9wZXJmb3JtYW5jZS5ub3coKTowfWZ1bmN0aW9uIGcoKXtvLmZvckVhY2goZnVuY3Rpb24oYSl7YSgpfSksby5sZW5ndGg9MH1mdW5jdGlvbiBoKGEsYyxkKXtwPSEwLG49ITE7dmFyIGU9Yi50aW1lbGluZTtlLmN1cnJlbnRUaW1lPWEsbT0hMTt2YXIgZj1bXSxnPVtdLGg9W10saT1bXTtyZXR1cm4gZC5mb3JFYWNoKGZ1bmN0aW9uKGIpe2IuX3RpY2soYSxjKSxiLl9pbkVmZmVjdD8oZy5wdXNoKGIuX2VmZmVjdCksYi5fbWFya1RhcmdldCgpKTooZi5wdXNoKGIuX2VmZmVjdCksYi5fdW5tYXJrVGFyZ2V0KCkpLGIuX25lZWRzVGljayYmKG09ITApO3ZhciBkPWIuX2luRWZmZWN0fHxiLl9uZWVkc1RpY2s7Yi5faW5UaW1lbGluZT1kLGQ/aC5wdXNoKGIpOmkucHVzaChiKX0pLG8ucHVzaC5hcHBseShvLGYpLG8ucHVzaC5hcHBseShvLGcpLG0mJnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe30pLHA9ITEsW2gsaV19dmFyIGk9d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSxqPVtdLGs9MDt3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lPWZ1bmN0aW9uKGEpe3ZhciBiPWsrKztyZXR1cm4gMD09ai5sZW5ndGgmJmkoZCksai5wdXNoKFtiLGFdKSxifSx3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU9ZnVuY3Rpb24oYSl7ai5mb3JFYWNoKGZ1bmN0aW9uKGIpe2JbMF09PWEmJihiWzFdPWZ1bmN0aW9uKCl7fSl9KX0sZi5wcm90b3R5cGU9e19wbGF5OmZ1bmN0aW9uKGMpe2MuX3RpbWluZz1hLm5vcm1hbGl6ZVRpbWluZ0lucHV0KGMudGltaW5nKTt2YXIgZD1uZXcgYi5BbmltYXRpb24oYyk7cmV0dXJuIGQuX2lkbGU9ITEsZC5fdGltZWxpbmU9dGhpcyx0aGlzLl9hbmltYXRpb25zLnB1c2goZCksYi5yZXN0YXJ0KCksYi5hcHBseURpcnRpZWRBbmltYXRpb24oZCksZH19O3ZhciBsPXZvaWQgMCxtPSExLG49ITE7Yi5yZXN0YXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIG18fChtPSEwLHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe30pLG49ITApLG59LGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uPWZ1bmN0aW9uKGEpe2lmKCFwKXthLl9tYXJrVGFyZ2V0KCk7dmFyIGM9YS5fdGFyZ2V0QW5pbWF0aW9ucygpO2Muc29ydChlKTt2YXIgZD1oKGIudGltZWxpbmUuY3VycmVudFRpbWUsITEsYy5zbGljZSgpKVsxXTtkLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9cS5fYW5pbWF0aW9ucy5pbmRleE9mKGEpO2IhPT0tMSYmcS5fYW5pbWF0aW9ucy5zcGxpY2UoYiwxKX0pLGcoKX19O3ZhciBvPVtdLHA9ITEscT1uZXcgZjtiLnRpbWVsaW5lPXF9KGMsZCxmKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiKXtmb3IodmFyIGM9MCxkPTA7ZDxhLmxlbmd0aDtkKyspYys9YVtkXSpiW2RdO3JldHVybiBjfWZ1bmN0aW9uIGQoYSxiKXtyZXR1cm5bYVswXSpiWzBdK2FbNF0qYlsxXSthWzhdKmJbMl0rYVsxMl0qYlszXSxhWzFdKmJbMF0rYVs1XSpiWzFdK2FbOV0qYlsyXSthWzEzXSpiWzNdLGFbMl0qYlswXSthWzZdKmJbMV0rYVsxMF0qYlsyXSthWzE0XSpiWzNdLGFbM10qYlswXSthWzddKmJbMV0rYVsxMV0qYlsyXSthWzE1XSpiWzNdLGFbMF0qYls0XSthWzRdKmJbNV0rYVs4XSpiWzZdK2FbMTJdKmJbN10sYVsxXSpiWzRdK2FbNV0qYls1XSthWzldKmJbNl0rYVsxM10qYls3XSxhWzJdKmJbNF0rYVs2XSpiWzVdK2FbMTBdKmJbNl0rYVsxNF0qYls3XSxhWzNdKmJbNF0rYVs3XSpiWzVdK2FbMTFdKmJbNl0rYVsxNV0qYls3XSxhWzBdKmJbOF0rYVs0XSpiWzldK2FbOF0qYlsxMF0rYVsxMl0qYlsxMV0sYVsxXSpiWzhdK2FbNV0qYls5XSthWzldKmJbMTBdK2FbMTNdKmJbMTFdLGFbMl0qYls4XSthWzZdKmJbOV0rYVsxMF0qYlsxMF0rYVsxNF0qYlsxMV0sYVszXSpiWzhdK2FbN10qYls5XSthWzExXSpiWzEwXSthWzE1XSpiWzExXSxhWzBdKmJbMTJdK2FbNF0qYlsxM10rYVs4XSpiWzE0XSthWzEyXSpiWzE1XSxhWzFdKmJbMTJdK2FbNV0qYlsxM10rYVs5XSpiWzE0XSthWzEzXSpiWzE1XSxhWzJdKmJbMTJdK2FbNl0qYlsxM10rYVsxMF0qYlsxNF0rYVsxNF0qYlsxNV0sYVszXSpiWzEyXSthWzddKmJbMTNdK2FbMTFdKmJbMTRdK2FbMTVdKmJbMTVdXX1mdW5jdGlvbiBlKGEpe3ZhciBiPWEucmFkfHwwLGM9YS5kZWd8fDAsZD1hLmdyYWR8fDAsZT1hLnR1cm58fDAsZj0oYy8zNjArZC80MDArZSkqKDIqTWF0aC5QSSkrYjtyZXR1cm4gZn1mdW5jdGlvbiBmKGEpe3N3aXRjaChhLnQpe2Nhc2VcInJvdGF0ZXhcIjp2YXIgYj1lKGEuZFswXSk7cmV0dXJuWzEsMCwwLDAsMCxNYXRoLmNvcyhiKSxNYXRoLnNpbihiKSwwLDAsLU1hdGguc2luKGIpLE1hdGguY29zKGIpLDAsMCwwLDAsMV07Y2FzZVwicm90YXRleVwiOnZhciBiPWUoYS5kWzBdKTtyZXR1cm5bTWF0aC5jb3MoYiksMCwtTWF0aC5zaW4oYiksMCwwLDEsMCwwLE1hdGguc2luKGIpLDAsTWF0aC5jb3MoYiksMCwwLDAsMCwxXTtjYXNlXCJyb3RhdGVcIjpjYXNlXCJyb3RhdGV6XCI6dmFyIGI9ZShhLmRbMF0pO3JldHVybltNYXRoLmNvcyhiKSxNYXRoLnNpbihiKSwwLDAsLU1hdGguc2luKGIpLE1hdGguY29zKGIpLDAsMCwwLDAsMSwwLDAsMCwwLDFdO2Nhc2VcInJvdGF0ZTNkXCI6dmFyIGM9YS5kWzBdLGQ9YS5kWzFdLGY9YS5kWzJdLGI9ZShhLmRbM10pLGc9YypjK2QqZCtmKmY7aWYoMD09PWcpYz0xLGQ9MCxmPTA7ZWxzZSBpZigxIT09Zyl7dmFyIGg9TWF0aC5zcXJ0KGcpO2MvPWgsZC89aCxmLz1ofXZhciBpPU1hdGguc2luKGIvMiksaj1pKk1hdGguY29zKGIvMiksaz1pKmk7cmV0dXJuWzEtMiooZCpkK2YqZikqaywyKihjKmQqaytmKmopLDIqKGMqZiprLWQqaiksMCwyKihjKmQqay1mKmopLDEtMiooYypjK2YqZikqaywyKihkKmYqaytjKmopLDAsMiooYypmKmsrZCpqKSwyKihkKmYqay1jKmopLDEtMiooYypjK2QqZCkqaywwLDAsMCwwLDFdO2Nhc2VcInNjYWxlXCI6cmV0dXJuW2EuZFswXSwwLDAsMCwwLGEuZFsxXSwwLDAsMCwwLDEsMCwwLDAsMCwxXTtjYXNlXCJzY2FsZXhcIjpyZXR1cm5bYS5kWzBdLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXTtjYXNlXCJzY2FsZXlcIjpyZXR1cm5bMSwwLDAsMCwwLGEuZFswXSwwLDAsMCwwLDEsMCwwLDAsMCwxXTtjYXNlXCJzY2FsZXpcIjpyZXR1cm5bMSwwLDAsMCwwLDEsMCwwLDAsMCxhLmRbMF0sMCwwLDAsMCwxXTtjYXNlXCJzY2FsZTNkXCI6cmV0dXJuW2EuZFswXSwwLDAsMCwwLGEuZFsxXSwwLDAsMCwwLGEuZFsyXSwwLDAsMCwwLDFdO2Nhc2VcInNrZXdcIjp2YXIgbD1lKGEuZFswXSksbT1lKGEuZFsxXSk7cmV0dXJuWzEsTWF0aC50YW4obSksMCwwLE1hdGgudGFuKGwpLDEsMCwwLDAsMCwxLDAsMCwwLDAsMV07Y2FzZVwic2tld3hcIjp2YXIgYj1lKGEuZFswXSk7cmV0dXJuWzEsMCwwLDAsTWF0aC50YW4oYiksMSwwLDAsMCwwLDEsMCwwLDAsMCwxXTtjYXNlXCJza2V3eVwiOnZhciBiPWUoYS5kWzBdKTtyZXR1cm5bMSxNYXRoLnRhbihiKSwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDFdO2Nhc2VcInRyYW5zbGF0ZVwiOnZhciBjPWEuZFswXS5weHx8MCxkPWEuZFsxXS5weHx8MDtyZXR1cm5bMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsYyxkLDAsMV07Y2FzZVwidHJhbnNsYXRleFwiOnZhciBjPWEuZFswXS5weHx8MDtyZXR1cm5bMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsYywwLDAsMV07Y2FzZVwidHJhbnNsYXRleVwiOnZhciBkPWEuZFswXS5weHx8MDtyZXR1cm5bMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCxkLDAsMV07Y2FzZVwidHJhbnNsYXRlelwiOnZhciBmPWEuZFswXS5weHx8MDtyZXR1cm5bMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLGYsMV07Y2FzZVwidHJhbnNsYXRlM2RcIjp2YXIgYz1hLmRbMF0ucHh8fDAsZD1hLmRbMV0ucHh8fDAsZj1hLmRbMl0ucHh8fDA7cmV0dXJuWzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLGMsZCxmLDFdO2Nhc2VcInBlcnNwZWN0aXZlXCI6dmFyIG49YS5kWzBdLnB4Py0xL2EuZFswXS5weDowO3JldHVyblsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsbiwwLDAsMCwxXTtjYXNlXCJtYXRyaXhcIjpyZXR1cm5bYS5kWzBdLGEuZFsxXSwwLDAsYS5kWzJdLGEuZFszXSwwLDAsMCwwLDEsMCxhLmRbNF0sYS5kWzVdLDAsMV07Y2FzZVwibWF0cml4M2RcIjpyZXR1cm4gYS5kfX1mdW5jdGlvbiBnKGEpe3JldHVybiAwPT09YS5sZW5ndGg/WzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDFdOmEubWFwKGYpLnJlZHVjZShkKX1mdW5jdGlvbiBoKGEpe3JldHVybltpKGcoYSkpXX12YXIgaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSl7cmV0dXJuIGFbMF1bMF0qYVsxXVsxXSphWzJdWzJdK2FbMV1bMF0qYVsyXVsxXSphWzBdWzJdK2FbMl1bMF0qYVswXVsxXSphWzFdWzJdLWFbMF1bMl0qYVsxXVsxXSphWzJdWzBdLWFbMV1bMl0qYVsyXVsxXSphWzBdWzBdLWFbMl1bMl0qYVswXVsxXSphWzFdWzBdfWZ1bmN0aW9uIGIoYil7Zm9yKHZhciBjPTEvYShiKSxkPWJbMF1bMF0sZT1iWzBdWzFdLGY9YlswXVsyXSxnPWJbMV1bMF0saD1iWzFdWzFdLGk9YlsxXVsyXSxqPWJbMl1bMF0saz1iWzJdWzFdLGw9YlsyXVsyXSxtPVtbKGgqbC1pKmspKmMsKGYqay1lKmwpKmMsKGUqaS1mKmgpKmMsMF0sWyhpKmotZypsKSpjLChkKmwtZipqKSpjLChmKmctZCppKSpjLDBdLFsoZyprLWgqaikqYywoaiplLWQqaykqYywoZCpoLWUqZykqYywwXV0sbj1bXSxvPTA7bzwzO28rKyl7Zm9yKHZhciBwPTAscT0wO3E8MztxKyspcCs9YlszXVtxXSptW3FdW29dO24ucHVzaChwKX1yZXR1cm4gbi5wdXNoKDEpLG0ucHVzaChuKSxtfWZ1bmN0aW9uIGQoYSl7cmV0dXJuW1thWzBdWzBdLGFbMV1bMF0sYVsyXVswXSxhWzNdWzBdXSxbYVswXVsxXSxhWzFdWzFdLGFbMl1bMV0sYVszXVsxXV0sW2FbMF1bMl0sYVsxXVsyXSxhWzJdWzJdLGFbM11bMl1dLFthWzBdWzNdLGFbMV1bM10sYVsyXVszXSxhWzNdWzNdXV19ZnVuY3Rpb24gZShhLGIpe2Zvcih2YXIgYz1bXSxkPTA7ZDw0O2QrKyl7Zm9yKHZhciBlPTAsZj0wO2Y8NDtmKyspZSs9YVtmXSpiW2ZdW2RdO2MucHVzaChlKX1yZXR1cm4gY31mdW5jdGlvbiBmKGEpe3ZhciBiPWcoYSk7cmV0dXJuW2FbMF0vYixhWzFdL2IsYVsyXS9iXX1mdW5jdGlvbiBnKGEpe3JldHVybiBNYXRoLnNxcnQoYVswXSphWzBdK2FbMV0qYVsxXSthWzJdKmFbMl0pfWZ1bmN0aW9uIGgoYSxiLGMsZCl7cmV0dXJuW2MqYVswXStkKmJbMF0sYyphWzFdK2QqYlsxXSxjKmFbMl0rZCpiWzJdXX1mdW5jdGlvbiBpKGEsYil7cmV0dXJuW2FbMV0qYlsyXS1hWzJdKmJbMV0sYVsyXSpiWzBdLWFbMF0qYlsyXSxhWzBdKmJbMV0tYVsxXSpiWzBdXX1mdW5jdGlvbiBqKGope3ZhciBrPVtqLnNsaWNlKDAsNCksai5zbGljZSg0LDgpLGouc2xpY2UoOCwxMiksai5zbGljZSgxMiwxNildO2lmKDEhPT1rWzNdWzNdKXJldHVybiBudWxsO2Zvcih2YXIgbD1bXSxtPTA7bTw0O20rKylsLnB1c2goa1ttXS5zbGljZSgpKTtmb3IodmFyIG09MDttPDM7bSsrKWxbbV1bM109MDtpZigwPT09YShsKSlyZXR1cm4hMTt2YXIgbixvPVtdO2lmKGtbMF1bM118fGtbMV1bM118fGtbMl1bM10pe28ucHVzaChrWzBdWzNdKSxvLnB1c2goa1sxXVszXSksby5wdXNoKGtbMl1bM10pLG8ucHVzaChrWzNdWzNdKTt2YXIgcD1iKGwpLHE9ZChwKTtuPWUobyxxKX1lbHNlIG49WzAsMCwwLDFdO3ZhciByPWtbM10uc2xpY2UoMCwzKSxzPVtdO3MucHVzaChrWzBdLnNsaWNlKDAsMykpO3ZhciB0PVtdO3QucHVzaChnKHNbMF0pKSxzWzBdPWYoc1swXSk7dmFyIHU9W107cy5wdXNoKGtbMV0uc2xpY2UoMCwzKSksdS5wdXNoKGMoc1swXSxzWzFdKSksc1sxXT1oKHNbMV0sc1swXSwxLC11WzBdKSx0LnB1c2goZyhzWzFdKSksc1sxXT1mKHNbMV0pLHVbMF0vPXRbMV0scy5wdXNoKGtbMl0uc2xpY2UoMCwzKSksdS5wdXNoKGMoc1swXSxzWzJdKSksc1syXT1oKHNbMl0sc1swXSwxLC11WzFdKSx1LnB1c2goYyhzWzFdLHNbMl0pKSxzWzJdPWgoc1syXSxzWzFdLDEsLXVbMl0pLHQucHVzaChnKHNbMl0pKSxzWzJdPWYoc1syXSksdVsxXS89dFsyXSx1WzJdLz10WzJdO3ZhciB2PWkoc1sxXSxzWzJdKTtpZihjKHNbMF0sdik8MClmb3IodmFyIG09MDttPDM7bSsrKXRbbV0qPS0xLHNbbV1bMF0qPS0xLHNbbV1bMV0qPS0xLHNbbV1bMl0qPS0xO3ZhciB3LHgseT1zWzBdWzBdK3NbMV1bMV0rc1syXVsyXSsxO3JldHVybiB5PjFlLTQ/KHc9LjUvTWF0aC5zcXJ0KHkpLHg9WyhzWzJdWzFdLXNbMV1bMl0pKncsKHNbMF1bMl0tc1syXVswXSkqdywoc1sxXVswXS1zWzBdWzFdKSp3LC4yNS93XSk6c1swXVswXT5zWzFdWzFdJiZzWzBdWzBdPnNbMl1bMl0/KHc9MipNYXRoLnNxcnQoMStzWzBdWzBdLXNbMV1bMV0tc1syXVsyXSkseD1bLjI1KncsKHNbMF1bMV0rc1sxXVswXSkvdywoc1swXVsyXStzWzJdWzBdKS93LChzWzJdWzFdLXNbMV1bMl0pL3ddKTpzWzFdWzFdPnNbMl1bMl0/KHc9MipNYXRoLnNxcnQoMStzWzFdWzFdLXNbMF1bMF0tc1syXVsyXSkseD1bKHNbMF1bMV0rc1sxXVswXSkvdywuMjUqdywoc1sxXVsyXStzWzJdWzFdKS93LChzWzBdWzJdLXNbMl1bMF0pL3ddKToodz0yKk1hdGguc3FydCgxK3NbMl1bMl0tc1swXVswXS1zWzFdWzFdKSx4PVsoc1swXVsyXStzWzJdWzBdKS93LChzWzFdWzJdK3NbMl1bMV0pL3csLjI1KncsKHNbMV1bMF0tc1swXVsxXSkvd10pLFtyLHQsdSx4LG5dfXJldHVybiBqfSgpO2EuZG90PWMsYS5tYWtlTWF0cml4RGVjb21wb3NpdGlvbj1ofShkLGYpLGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSxiKXt2YXIgYz1hLmV4ZWMoYik7aWYoYylyZXR1cm4gYz1hLmlnbm9yZUNhc2U/Y1swXS50b0xvd2VyQ2FzZSgpOmNbMF0sW2MsYi5zdWJzdHIoYy5sZW5ndGgpXX1mdW5jdGlvbiBjKGEsYil7Yj1iLnJlcGxhY2UoL15cXHMqLyxcIlwiKTt2YXIgYz1hKGIpO2lmKGMpcmV0dXJuW2NbMF0sY1sxXS5yZXBsYWNlKC9eXFxzKi8sXCJcIildfWZ1bmN0aW9uIGQoYSxkLGUpe2E9Yy5iaW5kKG51bGwsYSk7Zm9yKHZhciBmPVtdOzspe3ZhciBnPWEoZSk7aWYoIWcpcmV0dXJuW2YsZV07aWYoZi5wdXNoKGdbMF0pLGU9Z1sxXSxnPWIoZCxlKSwhZ3x8XCJcIj09Z1sxXSlyZXR1cm5bZixlXTtlPWdbMV19fWZ1bmN0aW9uIGUoYSxiKXtmb3IodmFyIGM9MCxkPTA7ZDxiLmxlbmd0aCYmKCEvXFxzfCwvLnRlc3QoYltkXSl8fDAhPWMpO2QrKylpZihcIihcIj09YltkXSljKys7ZWxzZSBpZihcIilcIj09YltkXSYmKGMtLSwwPT1jJiZkKyssYzw9MCkpYnJlYWs7dmFyIGU9YShiLnN1YnN0cigwLGQpKTtyZXR1cm4gdm9pZCAwPT1lP3ZvaWQgMDpbZSxiLnN1YnN0cihkKV19ZnVuY3Rpb24gZihhLGIpe2Zvcih2YXIgYz1hLGQ9YjtjJiZkOyljPmQ/YyU9ZDpkJT1jO3JldHVybiBjPWEqYi8oYytkKX1mdW5jdGlvbiBnKGEpe3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz1hKGIpO3JldHVybiBjJiYoY1swXT12b2lkIDApLGN9fWZ1bmN0aW9uIGgoYSxiKXtyZXR1cm4gZnVuY3Rpb24oYyl7dmFyIGQ9YShjKTtyZXR1cm4gZD9kOltiLGNdfX1mdW5jdGlvbiBpKGIsYyl7Zm9yKHZhciBkPVtdLGU9MDtlPGIubGVuZ3RoO2UrKyl7dmFyIGY9YS5jb25zdW1lVHJpbW1lZChiW2VdLGMpO2lmKCFmfHxcIlwiPT1mWzBdKXJldHVybjt2b2lkIDAhPT1mWzBdJiZkLnB1c2goZlswXSksYz1mWzFdfWlmKFwiXCI9PWMpcmV0dXJuIGR9ZnVuY3Rpb24gaihhLGIsYyxkLGUpe2Zvcih2YXIgZz1bXSxoPVtdLGk9W10saj1mKGQubGVuZ3RoLGUubGVuZ3RoKSxrPTA7azxqO2srKyl7dmFyIGw9YihkW2slZC5sZW5ndGhdLGVbayVlLmxlbmd0aF0pO2lmKCFsKXJldHVybjtnLnB1c2gobFswXSksaC5wdXNoKGxbMV0pLGkucHVzaChsWzJdKX1yZXR1cm5bZyxoLGZ1bmN0aW9uKGIpe3ZhciBkPWIubWFwKGZ1bmN0aW9uKGEsYil7cmV0dXJuIGlbYl0oYSl9KS5qb2luKGMpO3JldHVybiBhP2EoZCk6ZH1dfWZ1bmN0aW9uIGsoYSxiLGMpe2Zvcih2YXIgZD1bXSxlPVtdLGY9W10sZz0wLGg9MDtoPGMubGVuZ3RoO2grKylpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBjW2hdKXt2YXIgaT1jW2hdKGFbZ10sYltnKytdKTtkLnB1c2goaVswXSksZS5wdXNoKGlbMV0pLGYucHVzaChpWzJdKX1lbHNlIWZ1bmN0aW9uKGEpe2QucHVzaCghMSksZS5wdXNoKCExKSxmLnB1c2goZnVuY3Rpb24oKXtyZXR1cm4gY1thXX0pfShoKTtyZXR1cm5bZCxlLGZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1cIlwiLGM9MDtjPGEubGVuZ3RoO2MrKyliKz1mW2NdKGFbY10pO3JldHVybiBifV19YS5jb25zdW1lVG9rZW49YixhLmNvbnN1bWVUcmltbWVkPWMsYS5jb25zdW1lUmVwZWF0ZWQ9ZCxhLmNvbnN1bWVQYXJlbnRoZXNpc2VkPWUsYS5pZ25vcmU9ZyxhLm9wdGlvbmFsPWgsYS5jb25zdW1lTGlzdD1pLGEubWVyZ2VOZXN0ZWRSZXBlYXRlZD1qLmJpbmQobnVsbCxudWxsKSxhLm1lcmdlV3JhcHBlZE5lc3RlZFJlcGVhdGVkPWosYS5tZXJnZUxpc3Q9a30oZCksZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiKXtmdW5jdGlvbiBjKGIpe3ZhciBjPWEuY29uc3VtZVRva2VuKC9eaW5zZXQvaSxiKTtpZihjKXJldHVybiBkLmluc2V0PSEwLGM7dmFyIGM9YS5jb25zdW1lTGVuZ3RoT3JQZXJjZW50KGIpO2lmKGMpcmV0dXJuIGQubGVuZ3Rocy5wdXNoKGNbMF0pLGM7dmFyIGM9YS5jb25zdW1lQ29sb3IoYik7cmV0dXJuIGM/KGQuY29sb3I9Y1swXSxjKTp2b2lkIDB9dmFyIGQ9e2luc2V0OiExLGxlbmd0aHM6W10sY29sb3I6bnVsbH0sZT1hLmNvbnN1bWVSZXBlYXRlZChjLC9eLyxiKTtpZihlJiZlWzBdLmxlbmd0aClyZXR1cm5bZCxlWzFdXX1mdW5jdGlvbiBjKGMpe3ZhciBkPWEuY29uc3VtZVJlcGVhdGVkKGIsL14sLyxjKTtpZihkJiZcIlwiPT1kWzFdKXJldHVybiBkWzBdfWZ1bmN0aW9uIGQoYixjKXtmb3IoO2IubGVuZ3Rocy5sZW5ndGg8TWF0aC5tYXgoYi5sZW5ndGhzLmxlbmd0aCxjLmxlbmd0aHMubGVuZ3RoKTspYi5sZW5ndGhzLnB1c2goe3B4OjB9KTtmb3IoO2MubGVuZ3Rocy5sZW5ndGg8TWF0aC5tYXgoYi5sZW5ndGhzLmxlbmd0aCxjLmxlbmd0aHMubGVuZ3RoKTspYy5sZW5ndGhzLnB1c2goe3B4OjB9KTtpZihiLmluc2V0PT1jLmluc2V0JiYhIWIuY29sb3I9PSEhYy5jb2xvcil7Zm9yKHZhciBkLGU9W10sZj1bW10sMF0sZz1bW10sMF0saD0wO2g8Yi5sZW5ndGhzLmxlbmd0aDtoKyspe3ZhciBpPWEubWVyZ2VEaW1lbnNpb25zKGIubGVuZ3Roc1toXSxjLmxlbmd0aHNbaF0sMj09aCk7ZlswXS5wdXNoKGlbMF0pLGdbMF0ucHVzaChpWzFdKSxlLnB1c2goaVsyXSl9aWYoYi5jb2xvciYmYy5jb2xvcil7dmFyIGo9YS5tZXJnZUNvbG9ycyhiLmNvbG9yLGMuY29sb3IpO2ZbMV09alswXSxnWzFdPWpbMV0sZD1qWzJdO1xufXJldHVybltmLGcsZnVuY3Rpb24oYSl7Zm9yKHZhciBjPWIuaW5zZXQ/XCJpbnNldCBcIjpcIiBcIixmPTA7ZjxlLmxlbmd0aDtmKyspYys9ZVtmXShhWzBdW2ZdKStcIiBcIjtyZXR1cm4gZCYmKGMrPWQoYVsxXSkpLGN9XX19ZnVuY3Rpb24gZShiLGMsZCxlKXtmdW5jdGlvbiBmKGEpe3JldHVybntpbnNldDphLGNvbG9yOlswLDAsMCwwXSxsZW5ndGhzOlt7cHg6MH0se3B4OjB9LHtweDowfSx7cHg6MH1dfX1mb3IodmFyIGc9W10saD1bXSxpPTA7aTxkLmxlbmd0aHx8aTxlLmxlbmd0aDtpKyspe3ZhciBqPWRbaV18fGYoZVtpXS5pbnNldCksaz1lW2ldfHxmKGRbaV0uaW5zZXQpO2cucHVzaChqKSxoLnB1c2goayl9cmV0dXJuIGEubWVyZ2VOZXN0ZWRSZXBlYXRlZChiLGMsZyxoKX12YXIgZj1lLmJpbmQobnVsbCxkLFwiLCBcIik7YS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihjLGYsW1wiYm94LXNoYWRvd1wiLFwidGV4dC1zaGFkb3dcIl0pfShkKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIGEudG9GaXhlZCgzKS5yZXBsYWNlKFwiLjAwMFwiLFwiXCIpfWZ1bmN0aW9uIGQoYSxiLGMpe3JldHVybiBNYXRoLm1pbihiLE1hdGgubWF4KGEsYykpfWZ1bmN0aW9uIGUoYSl7aWYoL15cXHMqWy0rXT8oXFxkKlxcLik/XFxkK1xccyokLy50ZXN0KGEpKXJldHVybiBOdW1iZXIoYSl9ZnVuY3Rpb24gZihhLGIpe3JldHVyblthLGIsY119ZnVuY3Rpb24gZyhhLGIpe2lmKDAhPWEpcmV0dXJuIGkoMCwxLzApKGEsYil9ZnVuY3Rpb24gaChhLGIpe3JldHVyblthLGIsZnVuY3Rpb24oYSl7cmV0dXJuIE1hdGgucm91bmQoZCgxLDEvMCxhKSl9XX1mdW5jdGlvbiBpKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGUsZil7cmV0dXJuW2UsZixmdW5jdGlvbihlKXtyZXR1cm4gYyhkKGEsYixlKSl9XX19ZnVuY3Rpb24gaihhLGIpe3JldHVyblthLGIsTWF0aC5yb3VuZF19YS5jbGFtcD1kLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoZSxpKDAsMS8wKSxbXCJib3JkZXItaW1hZ2Utd2lkdGhcIixcImxpbmUtaGVpZ2h0XCJdKSxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGUsaSgwLDEpLFtcIm9wYWNpdHlcIixcInNoYXBlLWltYWdlLXRocmVzaG9sZFwiXSksYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihlLGcsW1wiZmxleC1ncm93XCIsXCJmbGV4LXNocmlua1wiXSksYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihlLGgsW1wib3JwaGFuc1wiLFwid2lkb3dzXCJdKSxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGUsaixbXCJ6LWluZGV4XCJdKSxhLnBhcnNlTnVtYmVyPWUsYS5tZXJnZU51bWJlcnM9ZixhLm51bWJlclRvU3RyaW5nPWN9KGQsZiksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYil7aWYoXCJ2aXNpYmxlXCI9PWF8fFwidmlzaWJsZVwiPT1iKXJldHVyblswLDEsZnVuY3Rpb24oYyl7cmV0dXJuIGM8PTA/YTpjPj0xP2I6XCJ2aXNpYmxlXCJ9XX1hLmFkZFByb3BlcnRpZXNIYW5kbGVyKFN0cmluZyxjLFtcInZpc2liaWxpdHlcIl0pfShkKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7YT1hLnRyaW0oKSxmLmZpbGxTdHlsZT1cIiMwMDBcIixmLmZpbGxTdHlsZT1hO3ZhciBiPWYuZmlsbFN0eWxlO2lmKGYuZmlsbFN0eWxlPVwiI2ZmZlwiLGYuZmlsbFN0eWxlPWEsYj09Zi5maWxsU3R5bGUpe2YuZmlsbFJlY3QoMCwwLDEsMSk7dmFyIGM9Zi5nZXRJbWFnZURhdGEoMCwwLDEsMSkuZGF0YTtmLmNsZWFyUmVjdCgwLDAsMSwxKTt2YXIgZD1jWzNdLzI1NTtyZXR1cm5bY1swXSpkLGNbMV0qZCxjWzJdKmQsZF19fWZ1bmN0aW9uIGQoYixjKXtyZXR1cm5bYixjLGZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIE1hdGgubWF4KDAsTWF0aC5taW4oMjU1LGEpKX1pZihiWzNdKWZvcih2YXIgZD0wO2Q8MztkKyspYltkXT1NYXRoLnJvdW5kKGMoYltkXS9iWzNdKSk7cmV0dXJuIGJbM109YS5udW1iZXJUb1N0cmluZyhhLmNsYW1wKDAsMSxiWzNdKSksXCJyZ2JhKFwiK2Iuam9pbihcIixcIikrXCIpXCJ9XX12YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsXCJjYW52YXNcIik7ZS53aWR0aD1lLmhlaWdodD0xO3ZhciBmPWUuZ2V0Q29udGV4dChcIjJkXCIpO2EuYWRkUHJvcGVydGllc0hhbmRsZXIoYyxkLFtcImJhY2tncm91bmQtY29sb3JcIixcImJvcmRlci1ib3R0b20tY29sb3JcIixcImJvcmRlci1sZWZ0LWNvbG9yXCIsXCJib3JkZXItcmlnaHQtY29sb3JcIixcImJvcmRlci10b3AtY29sb3JcIixcImNvbG9yXCIsXCJvdXRsaW5lLWNvbG9yXCIsXCJ0ZXh0LWRlY29yYXRpb24tY29sb3JcIl0pLGEuY29uc3VtZUNvbG9yPWEuY29uc3VtZVBhcmVudGhlc2lzZWQuYmluZChudWxsLGMpLGEubWVyZ2VDb2xvcnM9ZH0oZCxmKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiKXtpZihiPWIudHJpbSgpLnRvTG93ZXJDYXNlKCksXCIwXCI9PWImJlwicHhcIi5zZWFyY2goYSk+PTApcmV0dXJue3B4OjB9O2lmKC9eW14oXSokfF5jYWxjLy50ZXN0KGIpKXtiPWIucmVwbGFjZSgvY2FsY1xcKC9nLFwiKFwiKTt2YXIgYz17fTtiPWIucmVwbGFjZShhLGZ1bmN0aW9uKGEpe3JldHVybiBjW2FdPW51bGwsXCJVXCIrYX0pO2Zvcih2YXIgZD1cIlUoXCIrYS5zb3VyY2UrXCIpXCIsZT1iLnJlcGxhY2UoL1stK10/KFxcZCpcXC4pP1xcZCsvZyxcIk5cIikucmVwbGFjZShuZXcgUmVnRXhwKFwiTlwiK2QsXCJnXCIpLFwiRFwiKS5yZXBsYWNlKC9cXHNbKy1dXFxzL2csXCJPXCIpLnJlcGxhY2UoL1xccy9nLFwiXCIpLGY9Wy9OXFwqKEQpL2csLyhOfEQpWypcXC9dTi9nLC8oTnxEKU9cXDEvZywvXFwoKE58RClcXCkvZ10sZz0wO2c8Zi5sZW5ndGg7KWZbZ10udGVzdChlKT8oZT1lLnJlcGxhY2UoZltnXSxcIiQxXCIpLGc9MCk6ZysrO2lmKFwiRFwiPT1lKXtmb3IodmFyIGggaW4gYyl7dmFyIGk9ZXZhbChiLnJlcGxhY2UobmV3IFJlZ0V4cChcIlVcIitoLFwiZ1wiKSxcIlwiKS5yZXBsYWNlKG5ldyBSZWdFeHAoZCxcImdcIiksXCIqMFwiKSk7aWYoIWlzRmluaXRlKGkpKXJldHVybjtjW2hdPWl9cmV0dXJuIGN9fX1mdW5jdGlvbiBkKGEsYil7cmV0dXJuIGUoYSxiLCEwKX1mdW5jdGlvbiBlKGIsYyxkKXt2YXIgZSxmPVtdO2ZvcihlIGluIGIpZi5wdXNoKGUpO2ZvcihlIGluIGMpZi5pbmRleE9mKGUpPDAmJmYucHVzaChlKTtyZXR1cm4gYj1mLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYlthXXx8MH0pLGM9Zi5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGNbYV18fDB9KSxbYixjLGZ1bmN0aW9uKGIpe3ZhciBjPWIubWFwKGZ1bmN0aW9uKGMsZSl7cmV0dXJuIDE9PWIubGVuZ3RoJiZkJiYoYz1NYXRoLm1heChjLDApKSxhLm51bWJlclRvU3RyaW5nKGMpK2ZbZV19KS5qb2luKFwiICsgXCIpO3JldHVybiBiLmxlbmd0aD4xP1wiY2FsYyhcIitjK1wiKVwiOmN9XX12YXIgZj1cInB4fGVtfGV4fGNofHJlbXx2d3x2aHx2bWlufHZtYXh8Y218bW18aW58cHR8cGNcIixnPWMuYmluZChudWxsLG5ldyBSZWdFeHAoZixcImdcIikpLGg9Yy5iaW5kKG51bGwsbmV3IFJlZ0V4cChmK1wifCVcIixcImdcIikpLGk9Yy5iaW5kKG51bGwsL2RlZ3xyYWR8Z3JhZHx0dXJuL2cpO2EucGFyc2VMZW5ndGg9ZyxhLnBhcnNlTGVuZ3RoT3JQZXJjZW50PWgsYS5jb25zdW1lTGVuZ3RoT3JQZXJjZW50PWEuY29uc3VtZVBhcmVudGhlc2lzZWQuYmluZChudWxsLGgpLGEucGFyc2VBbmdsZT1pLGEubWVyZ2VEaW1lbnNpb25zPWU7dmFyIGo9YS5jb25zdW1lUGFyZW50aGVzaXNlZC5iaW5kKG51bGwsZyksaz1hLmNvbnN1bWVSZXBlYXRlZC5iaW5kKHZvaWQgMCxqLC9eLyksbD1hLmNvbnN1bWVSZXBlYXRlZC5iaW5kKHZvaWQgMCxrLC9eLC8pO2EuY29uc3VtZVNpemVQYWlyTGlzdD1sO3ZhciBtPWZ1bmN0aW9uKGEpe3ZhciBiPWwoYSk7aWYoYiYmXCJcIj09YlsxXSlyZXR1cm4gYlswXX0sbj1hLm1lcmdlTmVzdGVkUmVwZWF0ZWQuYmluZCh2b2lkIDAsZCxcIiBcIiksbz1hLm1lcmdlTmVzdGVkUmVwZWF0ZWQuYmluZCh2b2lkIDAsbixcIixcIik7YS5tZXJnZU5vbk5lZ2F0aXZlU2l6ZVBhaXI9bixhLmFkZFByb3BlcnRpZXNIYW5kbGVyKG0sbyxbXCJiYWNrZ3JvdW5kLXNpemVcIl0pLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoaCxkLFtcImJvcmRlci1ib3R0b20td2lkdGhcIixcImJvcmRlci1pbWFnZS13aWR0aFwiLFwiYm9yZGVyLWxlZnQtd2lkdGhcIixcImJvcmRlci1yaWdodC13aWR0aFwiLFwiYm9yZGVyLXRvcC13aWR0aFwiLFwiZmxleC1iYXNpc1wiLFwiZm9udC1zaXplXCIsXCJoZWlnaHRcIixcImxpbmUtaGVpZ2h0XCIsXCJtYXgtaGVpZ2h0XCIsXCJtYXgtd2lkdGhcIixcIm91dGxpbmUtd2lkdGhcIixcIndpZHRoXCJdKSxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGgsZSxbXCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsXCJib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1c1wiLFwiYm9yZGVyLXRvcC1sZWZ0LXJhZGl1c1wiLFwiYm9yZGVyLXRvcC1yaWdodC1yYWRpdXNcIixcImJvdHRvbVwiLFwibGVmdFwiLFwibGV0dGVyLXNwYWNpbmdcIixcIm1hcmdpbi1ib3R0b21cIixcIm1hcmdpbi1sZWZ0XCIsXCJtYXJnaW4tcmlnaHRcIixcIm1hcmdpbi10b3BcIixcIm1pbi1oZWlnaHRcIixcIm1pbi13aWR0aFwiLFwib3V0bGluZS1vZmZzZXRcIixcInBhZGRpbmctYm90dG9tXCIsXCJwYWRkaW5nLWxlZnRcIixcInBhZGRpbmctcmlnaHRcIixcInBhZGRpbmctdG9wXCIsXCJwZXJzcGVjdGl2ZVwiLFwicmlnaHRcIixcInNoYXBlLW1hcmdpblwiLFwidGV4dC1pbmRlbnRcIixcInRvcFwiLFwidmVydGljYWwtYWxpZ25cIixcIndvcmQtc3BhY2luZ1wiXSl9KGQsZiksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGIpe3JldHVybiBhLmNvbnN1bWVMZW5ndGhPclBlcmNlbnQoYil8fGEuY29uc3VtZVRva2VuKC9eYXV0by8sYil9ZnVuY3Rpb24gZChiKXt2YXIgZD1hLmNvbnN1bWVMaXN0KFthLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKG51bGwsL15yZWN0LykpLGEuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQobnVsbCwvXlxcKC8pKSxhLmNvbnN1bWVSZXBlYXRlZC5iaW5kKG51bGwsYywvXiwvKSxhLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKG51bGwsL15cXCkvKSldLGIpO2lmKGQmJjQ9PWRbMF0ubGVuZ3RoKXJldHVybiBkWzBdfWZ1bmN0aW9uIGUoYixjKXtyZXR1cm5cImF1dG9cIj09Ynx8XCJhdXRvXCI9PWM/WyEwLCExLGZ1bmN0aW9uKGQpe3ZhciBlPWQ/YjpjO2lmKFwiYXV0b1wiPT1lKXJldHVyblwiYXV0b1wiO3ZhciBmPWEubWVyZ2VEaW1lbnNpb25zKGUsZSk7cmV0dXJuIGZbMl0oZlswXSl9XTphLm1lcmdlRGltZW5zaW9ucyhiLGMpfWZ1bmN0aW9uIGYoYSl7cmV0dXJuXCJyZWN0KFwiK2ErXCIpXCJ9dmFyIGc9YS5tZXJnZVdyYXBwZWROZXN0ZWRSZXBlYXRlZC5iaW5kKG51bGwsZixlLFwiLCBcIik7YS5wYXJzZUJveD1kLGEubWVyZ2VCb3hlcz1nLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoZCxnLFtcImNsaXBcIl0pfShkLGYpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gZnVuY3Rpb24oYil7dmFyIGM9MDtyZXR1cm4gYS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGE9PT1rP2JbYysrXTphfSl9fWZ1bmN0aW9uIGQoYSl7cmV0dXJuIGF9ZnVuY3Rpb24gZShiKXtpZihiPWIudG9Mb3dlckNhc2UoKS50cmltKCksXCJub25lXCI9PWIpcmV0dXJuW107Zm9yKHZhciBjLGQ9L1xccyooXFx3KylcXCgoW14pXSopXFwpL2csZT1bXSxmPTA7Yz1kLmV4ZWMoYik7KXtpZihjLmluZGV4IT1mKXJldHVybjtmPWMuaW5kZXgrY1swXS5sZW5ndGg7dmFyIGc9Y1sxXSxoPW5bZ107aWYoIWgpcmV0dXJuO3ZhciBpPWNbMl0uc3BsaXQoXCIsXCIpLGo9aFswXTtpZihqLmxlbmd0aDxpLmxlbmd0aClyZXR1cm47Zm9yKHZhciBrPVtdLG89MDtvPGoubGVuZ3RoO28rKyl7dmFyIHAscT1pW29dLHI9altvXTtpZihwPXE/e0E6ZnVuY3Rpb24oYil7cmV0dXJuXCIwXCI9PWIudHJpbSgpP206YS5wYXJzZUFuZ2xlKGIpfSxOOmEucGFyc2VOdW1iZXIsVDphLnBhcnNlTGVuZ3RoT3JQZXJjZW50LEw6YS5wYXJzZUxlbmd0aH1bci50b1VwcGVyQ2FzZSgpXShxKTp7YTptLG46a1swXSx0Omx9W3JdLHZvaWQgMD09PXApcmV0dXJuO2sucHVzaChwKX1pZihlLnB1c2goe3Q6ZyxkOmt9KSxkLmxhc3RJbmRleD09Yi5sZW5ndGgpcmV0dXJuIGV9fWZ1bmN0aW9uIGYoYSl7cmV0dXJuIGEudG9GaXhlZCg2KS5yZXBsYWNlKFwiLjAwMDAwMFwiLFwiXCIpfWZ1bmN0aW9uIGcoYixjKXtpZihiLmRlY29tcG9zaXRpb25QYWlyIT09Yyl7Yi5kZWNvbXBvc2l0aW9uUGFpcj1jO3ZhciBkPWEubWFrZU1hdHJpeERlY29tcG9zaXRpb24oYil9aWYoYy5kZWNvbXBvc2l0aW9uUGFpciE9PWIpe2MuZGVjb21wb3NpdGlvblBhaXI9Yjt2YXIgZT1hLm1ha2VNYXRyaXhEZWNvbXBvc2l0aW9uKGMpfXJldHVybiBudWxsPT1kWzBdfHxudWxsPT1lWzBdP1tbITFdLFshMF0sZnVuY3Rpb24oYSl7cmV0dXJuIGE/Y1swXS5kOmJbMF0uZH1dOihkWzBdLnB1c2goMCksZVswXS5wdXNoKDEpLFtkLGUsZnVuY3Rpb24oYil7dmFyIGM9YS5xdWF0KGRbMF1bM10sZVswXVszXSxiWzVdKSxnPWEuY29tcG9zZU1hdHJpeChiWzBdLGJbMV0sYlsyXSxjLGJbNF0pLGg9Zy5tYXAoZikuam9pbihcIixcIik7cmV0dXJuIGh9XSl9ZnVuY3Rpb24gaChhKXtyZXR1cm4gYS5yZXBsYWNlKC9beHldLyxcIlwiKX1mdW5jdGlvbiBpKGEpe3JldHVybiBhLnJlcGxhY2UoLyh4fHl8enwzZCk/JC8sXCIzZFwiKX1mdW5jdGlvbiBqKGIsYyl7dmFyIGQ9YS5tYWtlTWF0cml4RGVjb21wb3NpdGlvbiYmITAsZT0hMTtpZighYi5sZW5ndGh8fCFjLmxlbmd0aCl7Yi5sZW5ndGh8fChlPSEwLGI9YyxjPVtdKTtmb3IodmFyIGY9MDtmPGIubGVuZ3RoO2YrKyl7dmFyIGo9YltmXS50LGs9YltmXS5kLGw9XCJzY2FsZVwiPT1qLnN1YnN0cigwLDUpPzE6MDtjLnB1c2goe3Q6aixkOmsubWFwKGZ1bmN0aW9uKGEpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhKXJldHVybiBsO3ZhciBiPXt9O2Zvcih2YXIgYyBpbiBhKWJbY109bDtyZXR1cm4gYn0pfSl9fXZhciBtPWZ1bmN0aW9uKGEsYil7cmV0dXJuXCJwZXJzcGVjdGl2ZVwiPT1hJiZcInBlcnNwZWN0aXZlXCI9PWJ8fChcIm1hdHJpeFwiPT1hfHxcIm1hdHJpeDNkXCI9PWEpJiYoXCJtYXRyaXhcIj09Ynx8XCJtYXRyaXgzZFwiPT1iKX0sbz1bXSxwPVtdLHE9W107aWYoYi5sZW5ndGghPWMubGVuZ3RoKXtpZighZClyZXR1cm47dmFyIHI9ZyhiLGMpO289W3JbMF1dLHA9W3JbMV1dLHE9W1tcIm1hdHJpeFwiLFtyWzJdXV1dfWVsc2UgZm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKyspe3ZhciBqLHM9YltmXS50LHQ9Y1tmXS50LHU9YltmXS5kLHY9Y1tmXS5kLHc9bltzXSx4PW5bdF07aWYobShzLHQpKXtpZighZClyZXR1cm47dmFyIHI9ZyhbYltmXV0sW2NbZl1dKTtvLnB1c2goclswXSkscC5wdXNoKHJbMV0pLHEucHVzaChbXCJtYXRyaXhcIixbclsyXV1dKX1lbHNle2lmKHM9PXQpaj1zO2Vsc2UgaWYod1syXSYmeFsyXSYmaChzKT09aCh0KSlqPWgocyksdT13WzJdKHUpLHY9eFsyXSh2KTtlbHNle2lmKCF3WzFdfHwheFsxXXx8aShzKSE9aSh0KSl7aWYoIWQpcmV0dXJuO3ZhciByPWcoYixjKTtvPVtyWzBdXSxwPVtyWzFdXSxxPVtbXCJtYXRyaXhcIixbclsyXV1dXTticmVha31qPWkocyksdT13WzFdKHUpLHY9eFsxXSh2KX1mb3IodmFyIHk9W10sej1bXSxBPVtdLEI9MDtCPHUubGVuZ3RoO0IrKyl7dmFyIEM9XCJudW1iZXJcIj09dHlwZW9mIHVbQl0/YS5tZXJnZU51bWJlcnM6YS5tZXJnZURpbWVuc2lvbnMscj1DKHVbQl0sdltCXSk7eVtCXT1yWzBdLHpbQl09clsxXSxBLnB1c2goclsyXSl9by5wdXNoKHkpLHAucHVzaCh6KSxxLnB1c2goW2osQV0pfX1pZihlKXt2YXIgRD1vO289cCxwPUR9cmV0dXJuW28scCxmdW5jdGlvbihhKXtyZXR1cm4gYS5tYXAoZnVuY3Rpb24oYSxiKXt2YXIgYz1hLm1hcChmdW5jdGlvbihhLGMpe3JldHVybiBxW2JdWzFdW2NdKGEpfSkuam9pbihcIixcIik7cmV0dXJuXCJtYXRyaXhcIj09cVtiXVswXSYmMTY9PWMuc3BsaXQoXCIsXCIpLmxlbmd0aCYmKHFbYl1bMF09XCJtYXRyaXgzZFwiKSxxW2JdWzBdK1wiKFwiK2MrXCIpXCJ9KS5qb2luKFwiIFwiKX1dfXZhciBrPW51bGwsbD17cHg6MH0sbT17ZGVnOjB9LG49e21hdHJpeDpbXCJOTk5OTk5cIixbayxrLDAsMCxrLGssMCwwLDAsMCwxLDAsayxrLDAsMV0sZF0sbWF0cml4M2Q6W1wiTk5OTk5OTk5OTk5OTk5OTlwiLGRdLHJvdGF0ZTpbXCJBXCJdLHJvdGF0ZXg6W1wiQVwiXSxyb3RhdGV5OltcIkFcIl0scm90YXRlejpbXCJBXCJdLHJvdGF0ZTNkOltcIk5OTkFcIl0scGVyc3BlY3RpdmU6W1wiTFwiXSxzY2FsZTpbXCJOblwiLGMoW2ssaywxXSksZF0sc2NhbGV4OltcIk5cIixjKFtrLDEsMV0pLGMoW2ssMV0pXSxzY2FsZXk6W1wiTlwiLGMoWzEsaywxXSksYyhbMSxrXSldLHNjYWxlejpbXCJOXCIsYyhbMSwxLGtdKV0sc2NhbGUzZDpbXCJOTk5cIixkXSxza2V3OltcIkFhXCIsbnVsbCxkXSxza2V3eDpbXCJBXCIsbnVsbCxjKFtrLG1dKV0sc2tld3k6W1wiQVwiLG51bGwsYyhbbSxrXSldLHRyYW5zbGF0ZTpbXCJUdFwiLGMoW2ssayxsXSksZF0sdHJhbnNsYXRleDpbXCJUXCIsYyhbayxsLGxdKSxjKFtrLGxdKV0sdHJhbnNsYXRleTpbXCJUXCIsYyhbbCxrLGxdKSxjKFtsLGtdKV0sdHJhbnNsYXRlejpbXCJMXCIsYyhbbCxsLGtdKV0sdHJhbnNsYXRlM2Q6W1wiVFRMXCIsZF19O2EuYWRkUHJvcGVydGllc0hhbmRsZXIoZSxqLFtcInRyYW5zZm9ybVwiXSl9KGQsZiksZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhKXt2YXIgYj1OdW1iZXIoYSk7aWYoIShpc05hTihiKXx8YjwxMDB8fGI+OTAwfHxiJTEwMCE9PTApKXJldHVybiBifWZ1bmN0aW9uIGMoYil7cmV0dXJuIGI9MTAwKk1hdGgucm91bmQoYi8xMDApLGI9YS5jbGFtcCgxMDAsOTAwLGIpLDQwMD09PWI/XCJub3JtYWxcIjo3MDA9PT1iP1wiYm9sZFwiOlN0cmluZyhiKX1mdW5jdGlvbiBkKGEsYil7cmV0dXJuW2EsYixjXX1hLmFkZFByb3BlcnRpZXNIYW5kbGVyKGIsZCxbXCJmb250LXdlaWdodFwiXSl9KGQpLGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSl7dmFyIGI9e307Zm9yKHZhciBjIGluIGEpYltjXT0tYVtjXTtyZXR1cm4gYn1mdW5jdGlvbiBjKGIpe3JldHVybiBhLmNvbnN1bWVUb2tlbigvXihsZWZ0fGNlbnRlcnxyaWdodHx0b3B8Ym90dG9tKVxcYi9pLGIpfHxhLmNvbnN1bWVMZW5ndGhPclBlcmNlbnQoYil9ZnVuY3Rpb24gZChiLGQpe3ZhciBlPWEuY29uc3VtZVJlcGVhdGVkKGMsL14vLGQpO2lmKGUmJlwiXCI9PWVbMV0pe3ZhciBmPWVbMF07aWYoZlswXT1mWzBdfHxcImNlbnRlclwiLGZbMV09ZlsxXXx8XCJjZW50ZXJcIiwzPT1iJiYoZlsyXT1mWzJdfHx7cHg6MH0pLGYubGVuZ3RoPT1iKXtpZigvdG9wfGJvdHRvbS8udGVzdChmWzBdKXx8L2xlZnR8cmlnaHQvLnRlc3QoZlsxXSkpe3ZhciBoPWZbMF07ZlswXT1mWzFdLGZbMV09aH1pZigvbGVmdHxyaWdodHxjZW50ZXJ8T2JqZWN0Ly50ZXN0KGZbMF0pJiYvdG9wfGJvdHRvbXxjZW50ZXJ8T2JqZWN0Ly50ZXN0KGZbMV0pKXJldHVybiBmLm1hcChmdW5jdGlvbihhKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgYT9hOmdbYV19KX19fWZ1bmN0aW9uIGUoZCl7dmFyIGU9YS5jb25zdW1lUmVwZWF0ZWQoYywvXi8sZCk7aWYoZSl7Zm9yKHZhciBmPWVbMF0saD1be1wiJVwiOjUwfSx7XCIlXCI6NTB9XSxpPTAsaj0hMSxrPTA7azxmLmxlbmd0aDtrKyspe3ZhciBsPWZba107XCJzdHJpbmdcIj09dHlwZW9mIGw/KGo9L2JvdHRvbXxyaWdodC8udGVzdChsKSxpPXtsZWZ0OjAscmlnaHQ6MCxjZW50ZXI6aSx0b3A6MSxib3R0b206MX1bbF0saFtpXT1nW2xdLFwiY2VudGVyXCI9PWwmJmkrKyk6KGomJihsPWIobCksbFtcIiVcIl09KGxbXCIlXCJdfHwwKSsxMDApLGhbaV09bCxpKyssaj0hMSl9cmV0dXJuW2gsZVsxXV19fWZ1bmN0aW9uIGYoYil7dmFyIGM9YS5jb25zdW1lUmVwZWF0ZWQoZSwvXiwvLGIpO2lmKGMmJlwiXCI9PWNbMV0pcmV0dXJuIGNbMF19dmFyIGc9e2xlZnQ6e1wiJVwiOjB9LGNlbnRlcjp7XCIlXCI6NTB9LHJpZ2h0OntcIiVcIjoxMDB9LHRvcDp7XCIlXCI6MH0sYm90dG9tOntcIiVcIjoxMDB9fSxoPWEubWVyZ2VOZXN0ZWRSZXBlYXRlZC5iaW5kKG51bGwsYS5tZXJnZURpbWVuc2lvbnMsXCIgXCIpO2EuYWRkUHJvcGVydGllc0hhbmRsZXIoZC5iaW5kKG51bGwsMyksaCxbXCJ0cmFuc2Zvcm0tb3JpZ2luXCJdKSxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGQuYmluZChudWxsLDIpLGgsW1wicGVyc3BlY3RpdmUtb3JpZ2luXCJdKSxhLmNvbnN1bWVQb3NpdGlvbj1lLGEubWVyZ2VPZmZzZXRMaXN0PWg7dmFyIGk9YS5tZXJnZU5lc3RlZFJlcGVhdGVkLmJpbmQobnVsbCxoLFwiLCBcIik7YS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihmLGksW1wiYmFja2dyb3VuZC1wb3NpdGlvblwiLFwib2JqZWN0LXBvc2l0aW9uXCJdKX0oZCksZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiKXt2YXIgYz1hLmNvbnN1bWVUb2tlbigvXmNpcmNsZS8sYik7aWYoYyYmY1swXSlyZXR1cm5bXCJjaXJjbGVcIl0uY29uY2F0KGEuY29uc3VtZUxpc3QoW2EuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQodm9pZCAwLC9eXFwoLykpLGQsYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZCh2b2lkIDAsL15hdC8pKSxhLmNvbnN1bWVQb3NpdGlvbixhLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKHZvaWQgMCwvXlxcKS8pKV0sY1sxXSkpO3ZhciBmPWEuY29uc3VtZVRva2VuKC9eZWxsaXBzZS8sYik7aWYoZiYmZlswXSlyZXR1cm5bXCJlbGxpcHNlXCJdLmNvbmNhdChhLmNvbnN1bWVMaXN0KFthLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKHZvaWQgMCwvXlxcKC8pKSxlLGEuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQodm9pZCAwLC9eYXQvKSksYS5jb25zdW1lUG9zaXRpb24sYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZCh2b2lkIDAsL15cXCkvKSldLGZbMV0pKTt2YXIgZz1hLmNvbnN1bWVUb2tlbigvXnBvbHlnb24vLGIpO3JldHVybiBnJiZnWzBdP1tcInBvbHlnb25cIl0uY29uY2F0KGEuY29uc3VtZUxpc3QoW2EuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQodm9pZCAwLC9eXFwoLykpLGEub3B0aW9uYWwoYS5jb25zdW1lVG9rZW4uYmluZCh2b2lkIDAsL15ub256ZXJvXFxzKix8XmV2ZW5vZGRcXHMqLC8pLFwibm9uemVybyxcIiksYS5jb25zdW1lU2l6ZVBhaXJMaXN0LGEuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQodm9pZCAwLC9eXFwpLykpXSxnWzFdKSk6dm9pZCAwfWZ1bmN0aW9uIGMoYixjKXtpZihiWzBdPT09Y1swXSlyZXR1cm5cImNpcmNsZVwiPT1iWzBdP2EubWVyZ2VMaXN0KGIuc2xpY2UoMSksYy5zbGljZSgxKSxbXCJjaXJjbGUoXCIsYS5tZXJnZURpbWVuc2lvbnMsXCIgYXQgXCIsYS5tZXJnZU9mZnNldExpc3QsXCIpXCJdKTpcImVsbGlwc2VcIj09YlswXT9hLm1lcmdlTGlzdChiLnNsaWNlKDEpLGMuc2xpY2UoMSksW1wiZWxsaXBzZShcIixhLm1lcmdlTm9uTmVnYXRpdmVTaXplUGFpcixcIiBhdCBcIixhLm1lcmdlT2Zmc2V0TGlzdCxcIilcIl0pOlwicG9seWdvblwiPT1iWzBdJiZiWzFdPT1jWzFdP2EubWVyZ2VMaXN0KGIuc2xpY2UoMiksYy5zbGljZSgyKSxbXCJwb2x5Z29uKFwiLGJbMV0sZyxcIilcIl0pOnZvaWQgMH12YXIgZD1hLmNvbnN1bWVQYXJlbnRoZXNpc2VkLmJpbmQobnVsbCxhLnBhcnNlTGVuZ3RoT3JQZXJjZW50KSxlPWEuY29uc3VtZVJlcGVhdGVkLmJpbmQodm9pZCAwLGQsL14vKSxmPWEubWVyZ2VOZXN0ZWRSZXBlYXRlZC5iaW5kKHZvaWQgMCxhLm1lcmdlRGltZW5zaW9ucyxcIiBcIiksZz1hLm1lcmdlTmVzdGVkUmVwZWF0ZWQuYmluZCh2b2lkIDAsZixcIixcIik7YS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihiLGMsW1wic2hhcGUtb3V0c2lkZVwiXSl9KGQpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIpe2IuY29uY2F0KFthXSkuZm9yRWFjaChmdW5jdGlvbihiKXtiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSYmKGRbYV09Yil9KX12YXIgZD17fTtjKFwidHJhbnNmb3JtXCIsW1wid2Via2l0VHJhbnNmb3JtXCIsXCJtc1RyYW5zZm9ybVwiXSksYyhcInRyYW5zZm9ybU9yaWdpblwiLFtcIndlYmtpdFRyYW5zZm9ybU9yaWdpblwiXSksYyhcInBlcnNwZWN0aXZlXCIsW1wid2Via2l0UGVyc3BlY3RpdmVcIl0pLGMoXCJwZXJzcGVjdGl2ZU9yaWdpblwiLFtcIndlYmtpdFBlcnNwZWN0aXZlT3JpZ2luXCJdKSxhLnByb3BlcnR5TmFtZT1mdW5jdGlvbihhKXtyZXR1cm4gZFthXXx8YX19KGQsZil9KCksIWZ1bmN0aW9uKCl7aWYodm9pZCAwPT09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5hbmltYXRlKFtdKS5vbmNhbmNlbCl7dmFyIGE7aWYod2luZG93LnBlcmZvcm1hbmNlJiZwZXJmb3JtYW5jZS5ub3cpdmFyIGE9ZnVuY3Rpb24oKXtyZXR1cm4gcGVyZm9ybWFuY2Uubm93KCl9O2Vsc2UgdmFyIGE9ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX07dmFyIGI9ZnVuY3Rpb24oYSxiLGMpe3RoaXMudGFyZ2V0PWEsdGhpcy5jdXJyZW50VGltZT1iLHRoaXMudGltZWxpbmVUaW1lPWMsdGhpcy50eXBlPVwiY2FuY2VsXCIsdGhpcy5idWJibGVzPSExLHRoaXMuY2FuY2VsYWJsZT0hMSx0aGlzLmN1cnJlbnRUYXJnZXQ9YSx0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITEsdGhpcy5ldmVudFBoYXNlPUV2ZW50LkFUX1RBUkdFVCx0aGlzLnRpbWVTdGFtcD1EYXRlLm5vdygpfSxjPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5hbmltYXRlO3dpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5hbmltYXRlPWZ1bmN0aW9uKGQsZSl7dmFyIGY9Yy5jYWxsKHRoaXMsZCxlKTtmLl9jYW5jZWxIYW5kbGVycz1bXSxmLm9uY2FuY2VsPW51bGw7dmFyIGc9Zi5jYW5jZWw7Zi5jYW5jZWw9ZnVuY3Rpb24oKXtnLmNhbGwodGhpcyk7dmFyIGM9bmV3IGIodGhpcyxudWxsLGEoKSksZD10aGlzLl9jYW5jZWxIYW5kbGVycy5jb25jYXQodGhpcy5vbmNhbmNlbD9bdGhpcy5vbmNhbmNlbF06W10pO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtkLmZvckVhY2goZnVuY3Rpb24oYSl7YS5jYWxsKGMudGFyZ2V0LGMpfSl9LDApfTt2YXIgaD1mLmFkZEV2ZW50TGlzdGVuZXI7Zi5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGEsYil7XCJmdW5jdGlvblwiPT10eXBlb2YgYiYmXCJjYW5jZWxcIj09YT90aGlzLl9jYW5jZWxIYW5kbGVycy5wdXNoKGIpOmguY2FsbCh0aGlzLGEsYil9O3ZhciBpPWYucmVtb3ZlRXZlbnRMaXN0ZW5lcjtyZXR1cm4gZi5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGEsYil7aWYoXCJjYW5jZWxcIj09YSl7dmFyIGM9dGhpcy5fY2FuY2VsSGFuZGxlcnMuaW5kZXhPZihiKTtjPj0wJiZ0aGlzLl9jYW5jZWxIYW5kbGVycy5zcGxpY2UoYywxKX1lbHNlIGkuY2FsbCh0aGlzLGEsYil9LGZ9fX0oKSxmdW5jdGlvbihhKXt2YXIgYj1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsYz1udWxsLGQ9ITE7dHJ5e3ZhciBlPWdldENvbXB1dGVkU3R5bGUoYikuZ2V0UHJvcGVydHlWYWx1ZShcIm9wYWNpdHlcIiksZj1cIjBcIj09ZT9cIjFcIjpcIjBcIjtjPWIuYW5pbWF0ZSh7b3BhY2l0eTpbZixmXX0se2R1cmF0aW9uOjF9KSxjLmN1cnJlbnRUaW1lPTAsZD1nZXRDb21wdXRlZFN0eWxlKGIpLmdldFByb3BlcnR5VmFsdWUoXCJvcGFjaXR5XCIpPT1mfWNhdGNoKGEpe31maW5hbGx5e2MmJmMuY2FuY2VsKCl9aWYoIWQpe3ZhciBnPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5hbmltYXRlO3dpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5hbmltYXRlPWZ1bmN0aW9uKGIsYyl7cmV0dXJuIHdpbmRvdy5TeW1ib2wmJlN5bWJvbC5pdGVyYXRvciYmQXJyYXkucHJvdG90eXBlLmZyb20mJmJbU3ltYm9sLml0ZXJhdG9yXSYmKGI9QXJyYXkuZnJvbShiKSksQXJyYXkuaXNBcnJheShiKXx8bnVsbD09PWJ8fChiPWEuY29udmVydFRvQXJyYXlGb3JtKGIpKSxnLmNhbGwodGhpcyxiLGMpfX19KGMpLGIudHJ1ZT1hfSh7fSxmdW5jdGlvbigpe3JldHVybiB0aGlzfSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYi1hbmltYXRpb25zLm1pbi5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgRmxvcmlhbiBLbGFtcGZlclxuLy8gTGljZW5zZWQgdW5kZXIgTUlUXG5cbi8vIGNvbnN0IEpTX0ZFQVRVUkVTID0gW1xuLy8gICAnZm4vYXJyYXkvZm9yLWVhY2gnLFxuLy8gICAnZm4vZnVuY3Rpb24vYmluZCcsXG4vLyAgICdmbi9udW1iZXIvY29uc3RydWN0b3InLFxuLy8gICAnZm4vb2JqZWN0L2Fzc2lnbicsXG4vLyAgICdmbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5Jyxcbi8vICAgJ2ZuL29iamVjdC9rZXlzJyxcbi8vIF07XG5cbi8vIGNvbnN0IE1PREVSTklaUl9URVNUUyA9IFtcbi8vICAgJ2N1c3RvbWV2ZW50Jyxcbi8vIF07XG5cbmNsYXNzIE1peCB7fVxuXG5jb25zdCBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sIHx8ICh4ID0+IGBfJHt4fWApO1xuXG5jb25zdCBkZWYgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkuYmluZChPYmplY3QpO1xuXG5jb25zdCBST09UID0gU3ltYm9sKCdyb290Jyk7XG5jb25zdCBTVEFURSA9IFN5bWJvbCgnc3RhdGUnKTtcblxuZnVuY3Rpb24gY3JlYXRlRXZlbnQoZXZlbnROYW1lLCBkYXRhID0ge30pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChldmVudE5hbWUsIHRydWUsIHRydWUsIGRhdGEuZGV0YWlsKTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBQcm9wZXJ0eShrZXksIHNpZGVFZmZlY3QpIHtcbiAgZGVmKHRoaXMsIGtleSwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiAoKSA9PiB0aGlzW1NUQVRFXVtrZXldLFxuICAgIHNldDogKHZhbHVlKSA9PiB7XG4gICAgICBpZiAoc2lkZUVmZmVjdCAhPSBudWxsKSB7XG4gICAgICAgIHNpZGVFZmZlY3QodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbn1cblxuLy8gVE9ETzogc3R1ZHkgaG93IG5hdGl2ZSBlbGVtZW50cyBkZWFsIHdpdGggYXR0cmlidXRlcy9wcm9wZXJpdGVzXG5mdW5jdGlvbiBzZXR1cFByb3BlcnRpZXMoKSB7XG4gIGNvbnN0IHNpZGVFZmZlY3RzID0gdGhpcy5zaWRlRWZmZWN0cygpO1xuXG4gIE9iamVjdC5rZXlzKHRoaXNbU1RBVEVdKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAodHlwZW9mIHRoaXNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHNpZGVFZmZlY3QgPSBzaWRlRWZmZWN0c1trZXldO1xuICAgICAgc2V0dXBQcm9wZXJ0eS5jYWxsKHRoaXMsIGtleSwgc2lkZUVmZmVjdCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgKEMgPSBNaXgpID0+IGNsYXNzIGV4dGVuZHMgQyB7XG4gIGdldCBjb21wb25lbnROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudE5hbWUoKTtcbiAgfVxuXG4gIGdldENvbXBvbmVudE5hbWUoKSB7XG4gICAgdGhyb3cgRXJyb3IoJ0NvbXBvbmVudCBuZWVkcyB0byBoYXZlIGEgbmFtZSwgZS5nLiBgbXktdGFnYC4gT3ZlcnJpZGUgYGdldENvbXBvbmVudE5hbWVgJyk7XG4gIH1cblxuICBzZXR1cENvbXBvbmVudChlbCwgc3RhdGUpIHtcbiAgICBkZWYodGhpcywgU1RBVEUsIHsgdmFsdWU6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdHMoKSwgc3RhdGUpIH0pO1xuICAgIHNldHVwUHJvcGVydGllcy5jYWxsKHRoaXMpO1xuICAgIGRlZih0aGlzLCBST09ULCB7IHZhbHVlOiB0aGlzLnNldHVwRE9NKGVsKSB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldHVwRE9NKGVsKSB7XG4gICAgcmV0dXJuIGVsO1xuICB9XG5cbiAgZ2V0IHJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Um9vdCgpO1xuICB9XG5cbiAgZ2V0IGVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldEVsKCk7XG4gIH1cblxuICBnZXRSb290KCkge1xuICAgIHJldHVybiB0aGlzW1JPT1RdO1xuICB9XG5cbiAgZ2V0RWwoKSB7XG4gICAgcmV0dXJuIHRoaXNbUk9PVF07XG4gIH1cblxuICBmaXJlRXZlbnQoZXZlbnROYW1lLCBkYXRhKSB7XG4gICAgY29uc3QgZXZlbnROYW1lTlMgPSBgJHt0aGlzLmNvbXBvbmVudE5hbWV9LSR7ZXZlbnROYW1lfWA7XG4gICAgdGhpcy5lbC5kaXNwYXRjaEV2ZW50KGNyZWF0ZUV2ZW50KGV2ZW50TmFtZU5TLCBkYXRhKSk7XG4gIH1cblxuICBkZWZhdWx0cygpIHtcbiAgICAvLyBUT0RPOiBwcm9kdWN0aW9uIGJ1aWxkcyB3aXRoIHByZXByb2Nlc3M/XG4gICAgY29uc29sZS53YXJuKCdkZWZhdWx0cyBub3QgcHJvdmlkZWQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgc2lkZUVmZmVjdHMoKSB7XG4gICAgLy8gVE9ETzogcHJvZHVjdGlvbiBidWlsZHMgd2l0aCBwcmVwcm9jZXNzP1xuICAgIGNvbnNvbGUud2Fybignc2lkZUVmZmVjdHMgbm90IHByb3ZpZGVkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHNldFN0YXRlKGtleU9yTWFwLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Yga2V5T3JNYXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnNldFN0YXRlS1Yoa2V5T3JNYXAsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXlPck1hcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGVNYXAoa2V5T3JNYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBFcnJvcignc2V0U3RhdGUgbmVlZHMgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBzZXRTdGF0ZUtWKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzW1NUQVRFXVtrZXldID0gdmFsdWU7XG4gIH1cblxuICBzZXRTdGF0ZU1hcChtYXApIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzW1NUQVRFXSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlS1Yoa2V5LCBtYXBba2V5XSk7XG4gICAgfSk7XG4gIH1cbn07XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgRmxvcmlhbiBLbGFtcGZlclxuLy8gTGljZW5zZWQgdW5kZXIgTUlUXG5cbi8qKlxuICAqIEBwYXJhbSB0IGN1cnJlbnQgdGltZVxuICAqIEBwYXJhbSBiIHN0YXJ0IHZhbHVlXG4gICogQHBhcmFtIGMgY2hhbmdlIGluIHZhbHVlXG4gICogQHBhcmFtIGQgZHVyYXRpb25cbiAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAqL1xuZnVuY3Rpb24gbGluZWFyVHdlZW4odCwgYiwgYywgZCkge1xuICByZXR1cm4gKChjICogdCkgLyBkKSArIGI7XG59XG5cbmZ1bmN0aW9uIHBhZ2VEaXN0KHAxLCBwMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KCgocDEucGFnZVggLSBwMi5wYWdlWCkgKiogMikgKyAoKHAxLnBhZ2VZIC0gcDIucGFnZVkpICoqIDIpKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnModGFyZ2V0LCBjbGFzc05hbWUpIHtcbiAgbGV0IHQgPSB0YXJnZXQ7XG4gIHdoaWxlICh0ICE9IG51bGwpIHtcbiAgICBpZiAodC5jbGFzc0xpc3QgJiYgdC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHQgPSB0LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgeyBsaW5lYXJUd2VlbiwgcGFnZURpc3QsIGNvbnRhaW5zIH07XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgRmxvcmlhbiBLbGFtcGZlclxuLy8gTGljZW5zZWQgdW5kZXIgTUlUXG5cbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcywgaW1wb3J0L25vLXVucmVzb2x2ZWQsIGltcG9ydC9leHRlbnNpb25zICovXG5cbmltcG9ydCBjb21wb25lbnRDb3JlIGZyb20gJ3ktY29tcG9uZW50L3NyYy9jb21wb25lbnQtY29yZSc7XG5cbmltcG9ydCB7IGxpbmVhclR3ZWVuLCBwYWdlRGlzdCB9IGZyb20gJy4uL2NvbW1vbic7XG5cbi8vIGNvbnN0IEpTX0ZFQVRVUkVTID0gW1xuLy8gICAnZm4vYXJyYXkvZm9yLWVhY2gnLFxuLy8gICAnZm4vZnVuY3Rpb24vYmluZCcsXG4vLyAgICdmbi9udW1iZXIvY29uc3RydWN0b3InLFxuLy8gICAnZm4vb2JqZWN0L2Fzc2lnbicsXG4vLyAgICdmbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5Jyxcbi8vICAgJ2ZuL29iamVjdC9rZXlzJyxcbi8vICAgJ2ZuL2FycmF5L3JlZHVjZScsXG4vLyBdO1xuLy9cbi8vIGNvbnN0IE1PREVSTklaUl9URVNUUyA9IFtcbi8vICAgJ2N1c3RvbWV2ZW50Jyxcbi8vICAgJ2V2ZW50bGlzdGVuZXInLFxuLy8gICAncXVlcnlzZWxlY3RvcicsXG4vLyAgICdyZXF1ZXN0YW5pbWF0aW9uZnJhbWUnLFxuLy8gICAnY2xhc3NsaXN0Jyxcbi8vICAgJ29wYWNpdHknLFxuLy8gICAnY3NzdHJhbnNmb3JtcycsXG4vLyAgICdjc3Nwb2ludGVyZXZlbnRzJyxcbi8vIF07XG5cbmNvbnN0IFN5bWJvbCA9IGdsb2JhbC5TeW1ib2wgfHwgKHggPT4gYF8ke3h9YCk7XG5cbmNvbnN0IElETEUgPSBTeW1ib2woJ2lkbGUnKTtcbmNvbnN0IFRPVUNISU5HID0gU3ltYm9sKCd0b3VjaGluZycpO1xuY29uc3QgU1RBUlRfQU5JTUFUSU5HID0gU3ltYm9sKCdzdGFydEFuaW1hdGluZycpO1xuY29uc3QgQU5JTUFUSU5HID0gU3ltYm9sKCdhbmltYXRpbmcnKTtcblxuY29uc3QgVkVMT0NJVFlfVEhSRVNIT0xEID0gMC4yO1xuY29uc3QgVkVMT0NJVFlfTElORUFSX0NPTUJJTkFUSU9OID0gMC44O1xuXG5jb25zdCBkZWYgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkuYmluZChPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBDID0+IGNsYXNzIGV4dGVuZHMgY29tcG9uZW50Q29yZShDKSB7XG5cbiAgLy8gQG92ZXJyaWRlXG4gIGdldENvbXBvbmVudE5hbWUoKSB7XG4gICAgcmV0dXJuICd5LWRyYXdlcic7XG4gIH1cblxuICAvLyBAb3ZlcnJpZGVcbiAgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW5lZDogZmFsc2UsXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IDIwMCxcbiAgICAgIHBlcnNpc3RlbnQ6IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICAvLyBAb3ZlcnJpZGVcbiAgc2lkZUVmZmVjdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW5lZDogKG8pID0+IHtcbiAgICAgICAgaWYgKG8gPT09IHRydWUpIHRoaXMub3BlbigpO1xuICAgICAgICBlbHNlIHRoaXMuY2xvc2UoKTtcbiAgICAgIH0sXG4gICAgICBwZXJzaXN0ZW50OiAoZCkgPT4ge1xuICAgICAgICBpZiAoZCA9PT0gdHJ1ZSkgdGhpcy5wZXJzaXN0KCk7XG4gICAgICAgIGVsc2UgdGhpcy51bnBlcnNpc3QoKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8vIEBvdmVycmlkZVxuICBzZXR1cENvbXBvbmVudChlbCwgcHJvcHMpIHtcbiAgICBzdXBlci5zZXR1cENvbXBvbmVudChlbCwgcHJvcHMpO1xuXG4gICAgdGhpcy5jYWNoZURPTUVsZW1lbnRzKCk7XG4gICAgdGhpcy5kZWZQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5iaW5kQ2FsbGJhY2tzKCk7XG5cbiAgICB0aGlzLmp1bXBUbyh0aGlzLm9wZW5lZCk7XG4gICAgaWYgKCF0aGlzLnBlcnNpc3RlbnQpIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBpZiAodGhpcy5wZXJzaXN0ZW50KSB0aGlzLnNjcmltLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNhY2hlRE9NRWxlbWVudHMoKSB7XG4gICAgZGVmKHRoaXMsICdzY3JpbScsIHsgdmFsdWU6IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKCcueS1kcmF3ZXItc2NyaW0nKSB9KTtcbiAgICBkZWYodGhpcywgJ2NvbnRlbnQnLCB7IHZhbHVlOiB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcignLnktZHJhd2VyLWNvbnRlbnQnKSB9KTtcbiAgfVxuXG4gIGRlZlByb3BlcnRpZXMoKSB7XG4gICAgZGVmKHRoaXMsICdzdGFydFgnLCB7IHZhbHVlOiAwLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ3N0YXJ0WScsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAncGFnZVgnLCB7IHZhbHVlOiAwLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ3BhZ2VZJywgeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdsYXN0UGFnZVgnLCB7IHZhbHVlOiAwLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ2xhc3RQYWdlWScsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnaXNTY3JvbGxpbmcnLCB7IHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnc3RhcnRlZE1vdmluZycsIHsgdmFsdWU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ2xvb3BTdGF0ZScsIHsgdmFsdWU6IElETEUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAndmVsb2NpdHknLCB7IHZhbHVlOiAwLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ3N0YXJ0VHJhbnNsYXRlWCcsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAndHJhbnNsYXRlWCcsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnYW5pbWF0aW9uRnJhbWVSZXF1ZXN0ZWQnLCB7IHZhbHVlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICd0b3VjaGluZycsIHsgdmFsdWU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ2xhc3RUaW1lJywgeyB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ3NsaWRlcldpZHRoJywgeyB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ2FuaW1hdGlvbicsIHsgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgfVxuXG4gIGJpbmRDYWxsYmFja3MoKSB7XG4gICAgZGVmKHRoaXMsICd0b3VjaFN0YXJ0Q2FsbGJhY2snLCB7IHZhbHVlOiB0aGlzLnRvdWNoU3RhcnRDYWxsYmFjay5iaW5kKHRoaXMpIH0pO1xuICAgIGRlZih0aGlzLCAndG91Y2hNb3ZlQ2FsbGJhY2snLCB7IHZhbHVlOiB0aGlzLnRvdWNoTW92ZUNhbGxiYWNrLmJpbmQodGhpcykgfSk7XG4gICAgZGVmKHRoaXMsICd0b3VjaEVuZENhbGxiYWNrJywgeyB2YWx1ZTogdGhpcy50b3VjaEVuZENhbGxiYWNrLmJpbmQodGhpcykgfSk7XG4gICAgZGVmKHRoaXMsICdzY3JpbUNsaWNrQ2FsbGJhY2snLCB7IHZhbHVlOiB0aGlzLnNjcmltQ2xpY2tDYWxsYmFjay5iaW5kKHRoaXMpIH0pO1xuICAgIGRlZih0aGlzLCAnYW5pbWF0aW9uRnJhbWVDYWxsYmFjaycsIHsgdmFsdWU6IHRoaXMuYW5pbWF0aW9uRnJhbWVDYWxsYmFjay5iaW5kKHRoaXMpIH0pO1xuICB9XG5cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMudG91Y2hTdGFydENhbGxiYWNrLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMudG91Y2hNb3ZlQ2FsbGJhY2ssIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLnRvdWNoRW5kQ2FsbGJhY2ssIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG5cbiAgICB0aGlzLnNjcmltLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zY3JpbUNsaWNrQ2FsbGJhY2spO1xuICB9XG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMudG91Y2hTdGFydENhbGxiYWNrLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMudG91Y2hNb3ZlQ2FsbGJhY2ssIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLnRvdWNoRW5kQ2FsbGJhY2ssIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG5cbiAgICB0aGlzLnNjcmltLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5zY3JpbUNsaWNrQ2FsbGJhY2spO1xuICB9XG5cbiAgcmVxdWVzdEFuaW1hdGlvbkxvb3AoKSB7XG4gICAgaWYgKCF0aGlzLmFuaW1hdGlvbkZyYW1lUmVxdWVzdGVkKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lQ2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIGdldE5lYXJlc3RUb3VjaCh0b3VjaGVzKSB7XG4gICAgaWYgKHRvdWNoZXMubGVuZ3RoID09PSAxKSByZXR1cm4gdG91Y2hlc1swXTtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnJlZHVjZS5jYWxsKHRvdWNoZXMsIChhY2MsIHRvdWNoKSA9PiB7XG4gICAgICBjb25zdCBkaXN0ID0gcGFnZURpc3QodGhpcywgdG91Y2gpO1xuICAgICAgcmV0dXJuIChkaXN0IDwgYWNjLmRpc3QpID8ge1xuICAgICAgICBkaXN0LFxuICAgICAgICB0b3VjaCxcbiAgICAgIH0gOiBhY2M7XG4gICAgfSwge1xuICAgICAgZGlzdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgdG91Y2g6IG51bGwsXG4gICAgfSkudG91Y2g7XG4gIH1cblxuICB0b3VjaFN0YXJ0Q2FsbGJhY2soZSkge1xuICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gdW5kZWZpbmVkO1xuXG4gICAgICBjb25zdCB0b3VjaCA9IGUudG91Y2hlc1swXTtcbiAgICAgIHRoaXMuc3RhcnRYID0gdG91Y2gucGFnZVg7XG4gICAgICB0aGlzLnN0YXJ0WSA9IHRvdWNoLnBhZ2VZO1xuICAgICAgdGhpcy5wYWdlWCA9IHRvdWNoLnBhZ2VYO1xuICAgICAgdGhpcy5wYWdlWSA9IHRvdWNoLnBhZ2VZO1xuICAgICAgdGhpcy5sYXN0UGFnZVggPSB0b3VjaC5wYWdlWDtcbiAgICAgIHRoaXMubGFzdFBhZ2VZID0gdG91Y2gucGFnZVk7XG5cbiAgICAgIGlmICh0aGlzLm9wZW5lZCB8fCAodGhpcy5wYWdlWCA8IHdpbmRvdy5pbm5lcldpZHRoIC8gMykpIHtcbiAgICAgICAgdGhpcy5wcmVwSW50ZXJhY3Rpb24oKTtcbiAgICAgICAgdGhpcy50b3VjaGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMubG9vcFN0YXRlID0gVE9VQ0hJTkc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdG91Y2hNb3ZlQ2FsbGJhY2soZSkge1xuICAgIGlmICh0aGlzLnRvdWNoaW5nKSB7XG4gICAgICBjb25zdCB0b3VjaCA9IHRoaXMuZ2V0TmVhcmVzdFRvdWNoKGUudG91Y2hlcyk7XG4gICAgICB0aGlzLnBhZ2VYID0gdG91Y2gucGFnZVg7XG4gICAgICB0aGlzLnBhZ2VZID0gdG91Y2gucGFnZVk7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5pc1Njcm9sbGluZyA9PT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5zdGFydGVkTW92aW5nKSB7XG4gICAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBNYXRoLmFicyh0aGlzLnN0YXJ0WSAtIHRoaXMucGFnZVkpID4gTWF0aC5hYnModGhpcy5zdGFydFggLSB0aGlzLnBhZ2VYKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgdGhpcy5sb29wU3RhdGUgPSBUT1VDSElORztcbiAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25Mb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHRoaXMuc3RhcnRlZE1vdmluZyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlTWVudU9wZW4oKSB7XG4gICAgaWYgKHRoaXMudmVsb2NpdHkgPiBWRUxPQ0lUWV9USFJFU0hPTEQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoJ29wZW5lZCcsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy52ZWxvY2l0eSA8IC1WRUxPQ0lUWV9USFJFU0hPTEQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoJ29wZW5lZCcsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHJhbnNsYXRlWCA+PSB0aGlzLnNsaWRlcldpZHRoIC8gMikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSgnb3BlbmVkJywgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoJ29wZW5lZCcsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICB0b3VjaEVuZENhbGxiYWNrKGUpIHtcbiAgICBpZiAodGhpcy50b3VjaGluZykge1xuICAgICAgaWYgKHRoaXMuaXNTY3JvbGxpbmcgfHwgZS50b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGFydGVkTW92aW5nKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWVudU9wZW4oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICAgIHRoaXMuc2NyaW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhbGwnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zY3JpbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9vcFN0YXRlID0gU1RBUlRfQU5JTUFUSU5HO1xuICAgICAgdGhpcy5zdGFydGVkTW92aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnRvdWNoaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc2NyaW1DbGlja0NhbGxiYWNrKCkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuXG4gIHByZXBJbnRlcmFjdGlvbigpIHtcbiAgICB0aGlzLmNvbnRlbnQuc3R5bGUud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICAgIHRoaXMuc2NyaW0uc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICB0aGlzLmNvbnRlbnQuY2xhc3NMaXN0LnJlbW92ZSgneS1kcmF3ZXItb3BlbmVkJyk7XG4gICAgdGhpcy5zbGlkZXJXaWR0aCA9IHRoaXMuZ2V0TW92YWJsZVNsaWRlcldpZHRoKCk7XG4gIH1cblxuICBnZXRNb3ZhYmxlU2xpZGVyV2lkdGgoKSB7XG4gICAgLy8gU2luY2UgcGFydCBvZiB0aGUgc2xpZGVyIGNvdWxkIGJlIHZpc2libGUsXG4gICAgLy8gdGhlIHdpZHRoIHRoYXQgaXMgXCJtb3ZhYmxlXCIgaXMgbGVzcyB0aGFuIHRoZSBjb21wbGV0ZSBzbGlkZXIgd2lkdGhcbiAgICAvLyBhbmQgZ2l2ZW4gYnlcbiAgICByZXR1cm4gLXRoaXMuY29udGVudC5vZmZzZXRMZWZ0O1xuICB9XG5cbiAgYW5pbWF0ZVRvKG9wZW5lZCkge1xuICAgIHRoaXMucHJlcEludGVyYWN0aW9uKCk7XG4gICAgdGhpcy5zZXRTdGF0ZSgnb3BlbmVkJywgb3BlbmVkKTtcbiAgICB0aGlzLmxvb3BTdGF0ZSA9IFNUQVJUX0FOSU1BVElORztcbiAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25Mb29wKCk7XG4gIH1cblxuICBqdW1wVG8ob3BlbmVkKSB7XG4gICAgdGhpcy5wcmVwSW50ZXJhY3Rpb24oKTtcbiAgICB0aGlzLnNldFN0YXRlKCdvcGVuZWQnLCBvcGVuZWQpO1xuICAgIHRoaXMubG9vcFN0YXRlID0gSURMRTtcbiAgICB0aGlzLnN0YXJ0VHJhbnNsYXRlWCA9IG9wZW5lZCAqIHRoaXMuc2xpZGVyV2lkdGg7XG4gICAgdGhpcy5lbmRBbmltYXRpbmcoKTtcbiAgICB0aGlzLnVwZGF0ZURPTSh0aGlzLnN0YXJ0VHJhbnNsYXRlWCwgdGhpcy5zbGlkZXJXaWR0aCk7XG4gIH1cblxuICB1cGRhdGVUcmFuc2xhdGVYKCkge1xuICAgIGNvbnN0IGRlbHRhWCA9IHRoaXMucGFnZVggLSB0aGlzLnN0YXJ0WDtcbiAgICB0aGlzLnRyYW5zbGF0ZVggPSB0aGlzLnN0YXJ0VHJhbnNsYXRlWCArIGRlbHRhWDtcbiAgICB0aGlzLnRyYW5zbGF0ZVggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLnNsaWRlcldpZHRoLCB0aGlzLnRyYW5zbGF0ZVgpKTtcbiAgICByZXR1cm4gZGVsdGFYO1xuICB9XG5cbiAgYW5pbWF0aW9uRnJhbWVDYWxsYmFjayh0aW1lKSB7XG4gICAgc3dpdGNoICh0aGlzLmxvb3BTdGF0ZSkge1xuICAgICAgY2FzZSBUT1VDSElORzoge1xuICAgICAgICB0aGlzLnRvdWNoaW5nRnJhbWUodGltZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIFNUQVJUX0FOSU1BVElORzoge1xuICAgICAgICB0aGlzLnN0YXJ0QW5pbWF0aW5nRnJhbWUodGltZSk7XG4gICAgICAgIHRoaXMubG9vcFN0YXRlID0gQU5JTUFUSU5HO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sodGltZSk7IC8vIGp1bXAgdG8gbmV4dCBjYXNlIGJsb2NrXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIEFOSU1BVElORzoge1xuICAgICAgICB0aGlzLmFuaW1hdGluZ0ZyYW1lKHRpbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b3VjaGluZ0ZyYW1lKHRpbWUpIHtcbiAgICBjb25zdCB0aW1lRGlmZiA9IHRpbWUgLSB0aGlzLmxhc3RUaW1lO1xuXG4gICAgaWYgKHRpbWVEaWZmID4gMCkge1xuICAgICAgY29uc3QgcGFnZVhEaWZmID0gdGhpcy5wYWdlWCAtIHRoaXMubGFzdFBhZ2VYO1xuICAgICAgdGhpcy52ZWxvY2l0eSA9IChWRUxPQ0lUWV9MSU5FQVJfQ09NQklOQVRJT04gKiAocGFnZVhEaWZmIC8gdGltZURpZmYpKSArXG4gICAgICAgICAgICAgICAgICAgICAgKCgxIC0gVkVMT0NJVFlfTElORUFSX0NPTUJJTkFUSU9OKSAqIHRoaXMudmVsb2NpdHkpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlVHJhbnNsYXRlWCgpO1xuICAgIHRoaXMudXBkYXRlRE9NKHRoaXMudHJhbnNsYXRlWCwgdGhpcy5zbGlkZXJXaWR0aCk7XG5cbiAgICB0aGlzLmxhc3RUaW1lID0gdGltZTtcbiAgICB0aGlzLmxhc3RQYWdlWCA9IHRoaXMucGFnZVg7XG4gICAgdGhpcy5sYXN0UGFnZVkgPSB0aGlzLnBhZ2VZO1xuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVDYWxsYmFjayk7XG4gIH1cblxuICBzdGFydEFuaW1hdGluZ0ZyYW1lKHRpbWUpIHtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zbGF0ZVgoKTtcblxuICAgIC8vIHN0b3JlIGFsbCBhbmltYXRpb24gcmVsYXRlZCBkYXRhIGluIHRoaXMgb2JqZWN0LFxuICAgIC8vIGRlbGV0ZSBhZnRlciBhbmltYXRpb24gaXMgY29tcGxldGVkXG4gICAgY29uc3QgYW5pbWF0aW9uID0ge307XG4gICAgYW5pbWF0aW9uLnN0YXJ0WCA9IHRoaXMudHJhbnNsYXRlWDtcbiAgICBhbmltYXRpb24uZW5kWCA9ICh0aGlzLm9wZW5lZCA/IDEgOiAwKSAqIHRoaXMuc2xpZGVyV2lkdGg7XG4gICAgYW5pbWF0aW9uLmNoYW5nZUluVmFsdWUgPSBhbmltYXRpb24uZW5kWCAtIGFuaW1hdGlvbi5zdGFydFg7XG4gICAgYW5pbWF0aW9uLnN0YXJ0VGltZSA9IHRpbWU7XG4gICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XG4gIH1cblxuICBhbmltYXRpbmdGcmFtZSh0aW1lKSB7XG4gICAgY29uc3QgdGltZUluQW5pbWF0aW9uID0gdGltZSAtIHRoaXMuYW5pbWF0aW9uLnN0YXJ0VGltZTtcblxuICAgIGlmICh0aW1lSW5BbmltYXRpb24gPCB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbikge1xuICAgICAgdGhpcy5hbmltYXRpbmdDb250KHRpbWVJbkFuaW1hdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYW5pbWF0aW5nRW5kKCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVET00odGhpcy5zdGFydFRyYW5zbGF0ZVgsIHRoaXMuc2xpZGVyV2lkdGgpO1xuICB9XG5cbiAgYW5pbWF0aW5nQ29udCh0aW1lSW5BbmltYXRpb24pIHtcbiAgICBjb25zdCBzdGFydFZhbHVlID0gdGhpcy5hbmltYXRpb24uc3RhcnRYO1xuICAgIGNvbnN0IGNoYW5nZUluVmFsdWUgPSB0aGlzLmFuaW1hdGlvbi5jaGFuZ2VJblZhbHVlO1xuICAgIHRoaXMuc3RhcnRUcmFuc2xhdGVYID0gbGluZWFyVHdlZW4odGltZUluQW5pbWF0aW9uLCBzdGFydFZhbHVlLCBjaGFuZ2VJblZhbHVlLFxuICAgICAgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lQ2FsbGJhY2spO1xuICB9XG5cbiAgYW5pbWF0aW5nRW5kKCkge1xuICAgIC8vIGVuZCBhbmltYXRpb25cbiAgICB0aGlzLnN0YXJ0VHJhbnNsYXRlWCA9IHRoaXMuYW5pbWF0aW9uLmVuZFg7XG4gICAgZGVsZXRlIHRoaXMuYW5pbWF0aW9uO1xuICAgIHRoaXMuZW5kQW5pbWF0aW5nKCk7XG4gIH1cblxuICBlbmRBbmltYXRpbmcoKSB7XG4gICAgdGhpcy5hbmltYXRpb25GcmFtZVJlcXVlc3RlZCA9IGZhbHNlO1xuICAgIHRoaXMubG9vcFN0YXRlID0gSURMRTtcbiAgICB0aGlzLnZlbG9jaXR5ID0gMDtcblxuICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgLy8gZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcbiAgICAgIHRoaXMuc2NyaW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhbGwnO1xuICAgICAgdGhpcy5jb250ZW50LmNsYXNzTGlzdC5hZGQoJ3ktZHJhd2VyLW9wZW5lZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93WSA9ICcnO1xuICAgICAgdGhpcy5zY3JpbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZW50LnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgICB0aGlzLnNjcmltLnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcblxuICAgIHRoaXMuZmlyZUV2ZW50KCd0cmFuc2l0aW9uZWQnKTtcbiAgfVxuXG4gIHVwZGF0ZURPTSh0cmFuc2xhdGVYLCBzbGlkZXJXaWR0aCkge1xuICAgIHRoaXMuY29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke3RyYW5zbGF0ZVh9cHgpYDtcbiAgICB0aGlzLnNjcmltLnN0eWxlLm9wYWNpdHkgPSB0cmFuc2xhdGVYIC8gc2xpZGVyV2lkdGg7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICB0aGlzLmFuaW1hdGVUbyhmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvcGVuKCkge1xuICAgIHRoaXMuYW5pbWF0ZVRvKHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwZXJzaXN0KCkge1xuICAgIHRoaXMuc2NyaW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgdGhpcy5zZXRTdGF0ZSgncGVyc2lzdGVudCcsIHRydWUpO1xuICB9XG5cbiAgdW5wZXJzaXN0KCkge1xuICAgIHRoaXMuc2NyaW0uc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnNldFN0YXRlKCdwZXJzaXN0ZW50JywgZmFsc2UpO1xuICB9XG59O1xuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE3IEZsb3JpYW4gS2xhbXBmZXJcbi8vIExpY2Vuc2VkIHVuZGVyIE1JVFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXMsIGltcG9ydC9uby11bnJlc29sdmVkLCBpbXBvcnQvZXh0ZW5zaW9ucyAqL1xuaW1wb3J0IGRyYXdlckNvcmUgZnJvbSAnLi4vY29yZSc7XG5cbmNvbnN0IHN0eWxlID0gYFxuPHN0eWxlPlxuQG1lZGlhIHNjcmVlbiB7XG4gIC55LWRyYXdlci1zY3JpbSB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogMDtcbiAgICByaWdodDogMDtcbiAgICBib3R0b206IDA7XG4gICAgbGVmdDogMDtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHotaW5kZXg6IDA7XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLDAsMCk7XG4gICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcblxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC42Nyk7XG4gIH1cblxuICAueS1kcmF3ZXItY29udGVudCB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIGxlZnQ6IDA7XG4gICAgYm90dG9tOiAwO1xuICAgIHRvcDogMDtcbiAgICB6LWluZGV4OiAxO1xuICAgIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwwLDApO1xuICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcbiAgICBjb250YWluOiBzdHJpY3Q7XG5cbiAgICBsZWZ0OiAtMThyZW07XG4gICAgd2lkdGg6IDE4cmVtO1xuICAgIGJhY2tncm91bmQ6ICNlOGU4ZTg7XG4gIH1cblxuICAueS1kcmF3ZXItY29udGVudC55LWRyYXdlci1vcGVuZWQge1xuICAgIGxlZnQ6IDAhaW1wb3J0YW50O1xuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwwLDApIWltcG9ydGFudDtcbiAgfVxufVxuXG5AbWVkaWEgcHJpbnQge1xuICAueS1kcmF3ZXItc2NyaW0ge1xuICAgIGRpc3BsYXk6IG5vbmUhaW1wb3J0YW50O1xuICB9XG5cbiAgLnktZHJhd2VyLWNvbnRlbnQge1xuICAgIHRyYW5zZm9ybTogbm9uZSFpbXBvcnRhbnQ7XG4gIH1cbn1cblxuPC9zdHlsZT5gO1xuXG5cbmZ1bmN0aW9uIGZyYWdtZW50RnJvbVN0cmluZyhzdHJIVE1MKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHJIVE1MKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHJhd2VyIGV4dGVuZHMgZHJhd2VyQ29yZSgpIHtcbiAgY29uc3RydWN0b3IoZWwsIHByb3BzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldHVwQ29tcG9uZW50KGVsLCBwcm9wcyk7XG4gIH1cblxuICAvLyBAb3ZlcnJpZGVcbiAgc2V0dXBET00oZWwpIHtcbiAgICBpZiAoIWVsKSB0aHJvdyBFcnJvcignTm8gZWxlbWVudCBwcm92aWRlZCcpO1xuXG4gICAgY29uc3Qgc2NyaW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzY3JpbS5jbGFzc0xpc3QuYWRkKCd5LWRyYXdlci1zY3JpbScpO1xuXG4gICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgneS1kcmF3ZXItY29udGVudCcpO1xuICAgIHdoaWxlIChlbC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsLmNoaWxkcmVuWzBdKTtcbiAgICB9XG5cbiAgICBlbC5hcHBlbmRDaGlsZChzY3JpbSk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICBjb25zdCByZWYgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGUnKVswXTtcbiAgICByZWYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZnJhZ21lbnRGcm9tU3RyaW5nKHN0eWxlKSwgcmVmKTtcblxuICAgIHJldHVybiBlbDtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgSW5uZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5uZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyU3Vic2NyaWJlcihwYXJlbnQsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLm91dGVyVmFsdWUgPSBvdXRlclZhbHVlO1xuICAgICAgICB0aGlzLm91dGVySW5kZXggPSBvdXRlckluZGV4O1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhcmVudC5ub3RpZnlOZXh0KHRoaXMub3V0ZXJWYWx1ZSwgdmFsdWUsIHRoaXMub3V0ZXJJbmRleCwgdGhpcy5pbmRleCsrLCB0aGlzKTtcbiAgICB9O1xuICAgIElubmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeUVycm9yKGVycm9yLCB0aGlzKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeUNvbXBsZXRlKHRoaXMpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5uZXJTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5Jbm5lclN1YnNjcmliZXIgPSBJbm5lclN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5lclN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBwdXNoLWJhc2VkIGV2ZW50IG9yIHZhbHVlIHRoYXQgYW4ge0BsaW5rIE9ic2VydmFibGV9IGNhbiBlbWl0LlxuICogVGhpcyBjbGFzcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBvcGVyYXRvcnMgdGhhdCBtYW5hZ2Ugbm90aWZpY2F0aW9ucyxcbiAqIGxpa2Uge0BsaW5rIG1hdGVyaWFsaXplfSwge0BsaW5rIGRlbWF0ZXJpYWxpemV9LCB7QGxpbmsgb2JzZXJ2ZU9ufSwgYW5kXG4gKiBvdGhlcnMuIEJlc2lkZXMgd3JhcHBpbmcgdGhlIGFjdHVhbCBkZWxpdmVyZWQgdmFsdWUsIGl0IGFsc28gYW5ub3RhdGVzIGl0XG4gKiB3aXRoIG1ldGFkYXRhIG9mLCBmb3IgaW5zdGFuY2UsIHdoYXQgdHlwZSBvZiBwdXNoIG1lc3NhZ2UgaXQgaXMgKGBuZXh0YCxcbiAqIGBlcnJvcmAsIG9yIGBjb21wbGV0ZWApLlxuICpcbiAqIEBzZWUge0BsaW5rIG1hdGVyaWFsaXplfVxuICogQHNlZSB7QGxpbmsgZGVtYXRlcmlhbGl6ZX1cbiAqIEBzZWUge0BsaW5rIG9ic2VydmVPbn1cbiAqXG4gKiBAY2xhc3MgTm90aWZpY2F0aW9uPFQ+XG4gKi9cbnZhciBOb3RpZmljYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vdGlmaWNhdGlvbihraW5kLCB2YWx1ZSwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBraW5kID09PSAnTic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGl2ZXJzIHRvIHRoZSBnaXZlbiBgb2JzZXJ2ZXJgIHRoZSB2YWx1ZSB3cmFwcGVkIGJ5IHRoaXMgTm90aWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ9IG9ic2VydmVyXG4gICAgICogQHJldHVyblxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvciAmJiBvYnNlcnZlci5lcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5jb21wbGV0ZSAmJiBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBzb21lIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2tzLCBkZWxpdmVyIHRoZSB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGVcbiAgICAgKiBjdXJyZW50IE5vdGlmaWNhdGlvbiB0byB0aGUgY29ycmVjdGx5IGNvcnJlc3BvbmRpbmcgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IHZvaWR9IG5leHQgQW4gT2JzZXJ2ZXIgYG5leHRgIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBhbnkpOiB2b2lkfSBbZXJyb3JdIEFuIE9ic2VydmVyIGBlcnJvcmAgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIEFuIE9ic2VydmVyIGBjb21wbGV0ZWAgY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuZG8gPSBmdW5jdGlvbiAobmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBraW5kID0gdGhpcy5raW5kO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0ICYmIG5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IgJiYgZXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxldGUgJiYgY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGFrZXMgYW4gT2JzZXJ2ZXIgb3IgaXRzIGluZGl2aWR1YWwgY2FsbGJhY2sgZnVuY3Rpb25zLCBhbmQgY2FsbHMgYG9ic2VydmVgXG4gICAgICogb3IgYGRvYCBtZXRob2RzIGFjY29yZGluZ2x5LlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBuZXh0T3JPYnNlcnZlciBBbiBPYnNlcnZlciBvclxuICAgICAqIHRoZSBgbmV4dGAgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IGFueSk6IHZvaWR9IFtlcnJvcl0gQW4gT2JzZXJ2ZXIgYGVycm9yYCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gQW4gT2JzZXJ2ZXIgYGNvbXBsZXRlYCBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgJiYgdHlwZW9mIG5leHRPck9ic2VydmVyLm5leHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9ic2VydmUobmV4dE9yT2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG8obmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IGp1c3QgZGVsaXZlcnMgdGhlIG5vdGlmaWNhdGlvbiByZXByZXNlbnRlZFxuICAgICAqIGJ5IHRoaXMgTm90aWZpY2F0aW9uIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLnRvT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtpbmQgPSB0aGlzLmtpbmQ7XG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLm9mKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnRocm93KHRoaXMuZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmVtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIG5vdGlmaWNhdGlvbiBraW5kIHZhbHVlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHNob3J0Y3V0IHRvIGNyZWF0ZSBhIE5vdGlmaWNhdGlvbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBgbmV4dGAgZnJvbSBhXG4gICAgICogZ2l2ZW4gdmFsdWUuXG4gICAgICogQHBhcmFtIHtUfSB2YWx1ZSBUaGUgYG5leHRgIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge05vdGlmaWNhdGlvbjxUPn0gVGhlIFwibmV4dFwiIE5vdGlmaWNhdGlvbiByZXByZXNlbnRpbmcgdGhlXG4gICAgICogYXJndW1lbnQuXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm90aWZpY2F0aW9uKCdOJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVuZGVmaW5lZFZhbHVlTm90aWZpY2F0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBzaG9ydGN1dCB0byBjcmVhdGUgYSBOb3RpZmljYXRpb24gaW5zdGFuY2Ugb2YgdGhlIHR5cGUgYGVycm9yYCBmcm9tIGFcbiAgICAgKiBnaXZlbiBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2FueX0gW2Vycl0gVGhlIGBlcnJvcmAgZXJyb3IuXG4gICAgICogQHJldHVybiB7Tm90aWZpY2F0aW9uPFQ+fSBUaGUgXCJlcnJvclwiIE5vdGlmaWNhdGlvbiByZXByZXNlbnRpbmcgdGhlXG4gICAgICogYXJndW1lbnQuXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLmNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbignRScsIHVuZGVmaW5lZCwgZXJyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgc2hvcnRjdXQgdG8gY3JlYXRlIGEgTm90aWZpY2F0aW9uIGluc3RhbmNlIG9mIHRoZSB0eXBlIGBjb21wbGV0ZWAuXG4gICAgICogQHJldHVybiB7Tm90aWZpY2F0aW9uPGFueT59IFRoZSB2YWx1ZWxlc3MgXCJjb21wbGV0ZVwiIE5vdGlmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlTm90aWZpY2F0aW9uO1xuICAgIH07XG4gICAgTm90aWZpY2F0aW9uLmNvbXBsZXRlTm90aWZpY2F0aW9uID0gbmV3IE5vdGlmaWNhdGlvbignQycpO1xuICAgIE5vdGlmaWNhdGlvbi51bmRlZmluZWRWYWx1ZU5vdGlmaWNhdGlvbiA9IG5ldyBOb3RpZmljYXRpb24oJ04nLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiBOb3RpZmljYXRpb247XG59KCkpO1xuZXhwb3J0cy5Ob3RpZmljYXRpb24gPSBOb3RpZmljYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob3RpZmljYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi91dGlsL3Jvb3QnKTtcbnZhciB0b1N1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vdXRpbC90b1N1YnNjcmliZXInKTtcbnZhciBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYW55IHNldCBvZiB2YWx1ZXMgb3ZlciBhbnkgYW1vdW50IG9mIHRpbWUuIFRoaXMgdGhlIG1vc3QgYmFzaWMgYnVpbGRpbmcgYmxvY2tcbiAqIG9mIFJ4SlMuXG4gKlxuICogQGNsYXNzIE9ic2VydmFibGU8VD5cbiAqL1xudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZSB0aGUgZnVuY3Rpb24gdGhhdCBpcyAgY2FsbGVkIHdoZW4gdGhlIE9ic2VydmFibGUgaXNcbiAgICAgKiBpbml0aWFsbHkgc3Vic2NyaWJlZCB0by4gVGhpcyBmdW5jdGlvbiBpcyBnaXZlbiBhIFN1YnNjcmliZXIsIHRvIHdoaWNoIG5ldyB2YWx1ZXNcbiAgICAgKiBjYW4gYmUgYG5leHRgZWQsIG9yIGFuIGBlcnJvcmAgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gcmFpc2UgYW4gZXJyb3IsIG9yXG4gICAgICogYGNvbXBsZXRlYCBjYW4gYmUgY2FsbGVkIHRvIG5vdGlmeSBvZiBhIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlLCB3aXRoIHRoaXMgT2JzZXJ2YWJsZSBhcyB0aGUgc291cmNlLCBhbmQgdGhlIHBhc3NlZFxuICAgICAqIG9wZXJhdG9yIGRlZmluZWQgYXMgdGhlIG5ldyBvYnNlcnZhYmxlJ3Mgb3BlcmF0b3IuXG4gICAgICogQG1ldGhvZCBsaWZ0XG4gICAgICogQHBhcmFtIHtPcGVyYXRvcn0gb3BlcmF0b3IgdGhlIG9wZXJhdG9yIGRlZmluaW5nIHRoZSBvcGVyYXRpb24gdG8gdGFrZSBvbiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IG9ic2VydmFibGUgd2l0aCB0aGUgT3BlcmF0b3IgYXBwbGllZFxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm9wZXJhdG9yO1xuICAgICAgICB2YXIgc2luayA9IHRvU3Vic2NyaWJlcl8xLnRvU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBvcGVyYXRvci5jYWxsKHNpbmssIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpbmsuYWRkKHRoaXMuX3RyeVN1YnNjcmliZShzaW5rKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc2luay5zeW5jRXJyb3JWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2luaztcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShzaW5rKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgc2luay5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGZvckVhY2hcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0IGEgaGFuZGxlciBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBvYnNlcnZhYmxlXG4gICAgICogQHBhcmFtIHtQcm9taXNlQ29uc3RydWN0b3J9IFtQcm9taXNlQ3Rvcl0gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBQcm9taXNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgZWl0aGVyIHJlc29sdmVzIG9uIG9ic2VydmFibGUgY29tcGxldGlvbiBvclxuICAgICAqICByZWplY3RzIHdpdGggdGhlIGhhbmRsZWQgZXJyb3JcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKG5leHQsIFByb21pc2VDdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgICAgIGlmIChyb290XzEucm9vdC5SeCAmJiByb290XzEucm9vdC5SeC5jb25maWcgJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocm9vdF8xLnJvb3QuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFByb21pc2UgaW1wbCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc3Vic2NyaXB0aW9uLCB0aGVuIHdlIGNhbiBzdXJtaXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXh0IGhhbmRsaW5nIGlzIGFzeW5jaHJvbm91cy4gQW55IGVycm9ycyB0aHJvd25cbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBiZSByZWplY3RlZCBleHBsaWNpdGx5IGFuZCB1bnN1YnNjcmliZSBtdXN0IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxlZCBtYW51YWxseVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgTk8gc3Vic2NyaXB0aW9uLCB0aGVuIHdlJ3JlIGdldHRpbmcgYSBuZXh0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgc3luY2hyb25vdXNseSBkdXJpbmcgc3Vic2NyaXB0aW9uLiBXZSBjYW4ganVzdCBjYWxsIGl0LlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBlcnJvcnMsIE9ic2VydmFibGUncyBgc3Vic2NyaWJlYCB3aWxsIGVuc3VyZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5zdWJzY3JpcHRpb24gbG9naWMgaXMgY2FsbGVkLCB0aGVuIHN5bmNocm9ub3VzbHkgcmV0aHJvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIHRoYXQsIFByb21pc2Ugd2lsbCB0cmFwIHRoZSBlcnJvciBhbmQgc2VuZCBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBkb3duIHRoZSByZWplY3Rpb24gcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVqZWN0LCByZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFuIGludGVyb3AgcG9pbnQgZGVmaW5lZCBieSB0aGUgZXM3LW9ic2VydmFibGUgc3BlYyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG4gICAgICogQG1ldGhvZCBTeW1ib2wub2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IHRoaXMgaW5zdGFuY2Ugb2YgdGhlIG9ic2VydmFibGVcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZVtvYnNlcnZhYmxlXzEuJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBIQUNLOiBTaW5jZSBUeXBlU2NyaXB0IGluaGVyaXRzIHN0YXRpYyBwcm9wZXJ0aWVzIHRvbywgd2UgaGF2ZSB0b1xuICAgIC8vIGZpZ2h0IGFnYWluc3QgVHlwZVNjcmlwdCBoZXJlIHNvIFN1YmplY3QgY2FuIGhhdmUgYSBkaWZmZXJlbnQgc3RhdGljIGNyZWF0ZSBzaWduYXR1cmVcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbGQgT2JzZXJ2YWJsZSBieSBjYWxsaW5nIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZT8gdGhlIHN1YnNjcmliZXIgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYSBuZXcgY29sZCBvYnNlcnZhYmxlXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmUpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KCkpO1xuZXhwb3J0cy5PYnNlcnZhYmxlID0gT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVtcHR5ID0ge1xuICAgIGNsb3NlZDogdHJ1ZSxcbiAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24gKGVycikgeyB0aHJvdyBlcnI7IH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE91dGVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE91dGVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPdXRlclN1YnNjcmliZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgIH07XG4gICAgT3V0ZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBPdXRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLk91dGVyU3Vic2NyaWJlciA9IE91dGVyU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU91dGVyU3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaWJlcicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yJyk7XG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJqZWN0U3Vic2NyaXB0aW9uJyk7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9yeFN1YnNjcmliZXInKTtcbi8qKlxuICogQGNsYXNzIFN1YmplY3RTdWJzY3JpYmVyPFQ+XG4gKi9cbnZhciBTdWJqZWN0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gU3ViamVjdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlN1YmplY3RTdWJzY3JpYmVyID0gU3ViamVjdFN1YnNjcmliZXI7XG4vKipcbiAqIEBjbGFzcyBTdWJqZWN0PFQ+XG4gKi9cbnZhciBTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0KCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRocm93bkVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgU3ViamVjdC5wcm90b3R5cGVbcnhTdWJzY3JpYmVyXzEuJCRyeFN1YnNjcmliZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpYmVyKHRoaXMpO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgc3ViamVjdCA9IG5ldyBBbm9ueW1vdXNTdWJqZWN0KHRoaXMsIHRoaXMpO1xuICAgICAgICBzdWJqZWN0Lm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvcHlbaV0ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBlcnI7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbnVsbDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlLmNhbGwodGhpcywgc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWJqZWN0U3Vic2NyaXB0aW9uXzEuU3ViamVjdFN1YnNjcmlwdGlvbih0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuYXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgU3ViamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3ViamVjdDtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuU3ViamVjdCA9IFN1YmplY3Q7XG4vKipcbiAqIEBjbGFzcyBBbm9ueW1vdXNTdWJqZWN0PFQ+XG4gKi9cbnZhciBBbm9ueW1vdXNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5vbnltb3VzU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbm9ueW1vdXNTdWJqZWN0KGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLm5leHQpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uY29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBbm9ueW1vdXNTdWJqZWN0O1xufShTdWJqZWN0KSk7XG5leHBvcnRzLkFub255bW91c1N1YmplY3QgPSBBbm9ueW1vdXNTdWJqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ViamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3RTdWJzY3JpcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmlwdGlvbihzdWJqZWN0LCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBzdWJzY3JpYmVyO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBTdWJqZWN0U3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHN1YmplY3Qub2JzZXJ2ZXJzO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBudWxsO1xuICAgICAgICBpZiAoIW9ic2VydmVycyB8fCBvYnNlcnZlcnMubGVuZ3RoID09PSAwIHx8IHN1YmplY3QuaXNTdG9wcGVkIHx8IHN1YmplY3QuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmliZXJJbmRleCA9IG9ic2VydmVycy5pbmRleE9mKHRoaXMuc3Vic2NyaWJlcik7XG4gICAgICAgIGlmIChzdWJzY3JpYmVySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKHN1YnNjcmliZXJJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaXB0aW9uO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmlwdGlvbiA9IFN1YmplY3RTdWJzY3JpcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0U3Vic2NyaXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG52YXIgT2JzZXJ2ZXJfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2ZXInKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGludGVyZmFjZSBhbmQgZXh0ZW5kcyB0aGVcbiAqIHtAbGluayBTdWJzY3JpcHRpb259IGNsYXNzLiBXaGlsZSB0aGUge0BsaW5rIE9ic2VydmVyfSBpcyB0aGUgcHVibGljIEFQSSBmb3JcbiAqIGNvbnN1bWluZyB0aGUgdmFsdWVzIG9mIGFuIHtAbGluayBPYnNlcnZhYmxlfSwgYWxsIE9ic2VydmVycyBnZXQgY29udmVydGVkIHRvXG4gKiBhIFN1YnNjcmliZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgU3Vic2NyaXB0aW9uLWxpa2UgY2FwYWJpbGl0aWVzIHN1Y2ggYXNcbiAqIGB1bnN1YnNjcmliZWAuIFN1YnNjcmliZXIgaXMgYSBjb21tb24gdHlwZSBpbiBSeEpTLCBhbmQgY3J1Y2lhbCBmb3JcbiAqIGltcGxlbWVudGluZyBvcGVyYXRvcnMsIGJ1dCBpdCBpcyByYXJlbHkgdXNlZCBhcyBhIHB1YmxpYyBBUEkuXG4gKlxuICogQGNsYXNzIFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBbZGVzdGluYXRpb25Pck5leHRdIEEgcGFydGlhbGx5XG4gICAgICogZGVmaW5lZCBPYnNlcnZlciBvciBhIGBuZXh0YCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlcihkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IE9ic2VydmVyXzEuZW1wdHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbk9yTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25Pck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbk9yTmV4dCBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbk9yTmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uYWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIGZhY3RvcnkgZm9yIGEgU3Vic2NyaWJlciwgZ2l2ZW4gYSAocG90ZW50aWFsbHkgcGFydGlhbCkgZGVmaW5pdGlvblxuICAgICAqIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oeDogP1QpOiB2b2lkfSBbbmV4dF0gVGhlIGBuZXh0YCBjYWxsYmFjayBvZiBhbiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHJldHVybiB7U3Vic2NyaWJlcjxUPn0gQSBTdWJzY3JpYmVyIHdyYXBwaW5nIHRoZSAocGFydGlhbGx5IGRlZmluZWQpXG4gICAgICogT2JzZXJ2ZXIgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcihuZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBuZXh0YCBmcm9tXG4gICAgICogdGhlIE9ic2VydmFibGUsIHdpdGggYSB2YWx1ZS4gVGhlIE9ic2VydmFibGUgbWF5IGNhbGwgdGhpcyBtZXRob2QgMCBvciBtb3JlXG4gICAgICogdGltZXMuXG4gICAgICogQHBhcmFtIHtUfSBbdmFsdWVdIFRoZSBgbmV4dGAgdmFsdWUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2YgdHlwZSBgZXJyb3JgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhbiBhdHRhY2hlZCB7QGxpbmsgRXJyb3J9LiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdFxuICAgICAqIHRoZSBPYnNlcnZhYmxlIGhhcyBleHBlcmllbmNlZCBhbiBlcnJvciBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHthbnl9IFtlcnJdIFRoZSBgZXJyb3JgIGV4Y2VwdGlvbi5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIGEgdmFsdWVsZXNzIG5vdGlmaWNhdGlvbiBvZiB0eXBlXG4gICAgICogYGNvbXBsZXRlYCBmcm9tIHRoZSBPYnNlcnZhYmxlLiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdCB0aGUgT2JzZXJ2YWJsZVxuICAgICAqIGhhcyBmaW5pc2hlZCBzZW5kaW5nIHB1c2gtYmFzZWQgbm90aWZpY2F0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cztcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IF9wYXJlbnRzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVyO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3Vic2NyaWJlciA9IFN1YnNjcmliZXI7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhZmVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIoX3BhcmVudFN1YnNjcmliZXIsIG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBfcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9ic2VydmVyT3JOZXh0KSkge1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ic2VydmVyT3JOZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQubmV4dDtcbiAgICAgICAgICAgIGVycm9yID0gb2JzZXJ2ZXJPck5leHQuZXJyb3I7XG4gICAgICAgICAgICBjb21wbGV0ZSA9IG9ic2VydmVyT3JOZXh0LmNvbXBsZXRlO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKGNvbnRleHQudW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoY29udGV4dC51bnN1YnNjcmliZS5iaW5kKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSB0aGlzLnVuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIH1cbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMuX25leHQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX25leHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9uZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgdGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yVW5zdWIgPSBmdW5jdGlvbiAoZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yU2V0RXJyb3IgPSBmdW5jdGlvbiAocGFyZW50LCBmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICBfcGFyZW50U3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0FycmF5Jyk7XG52YXIgaXNPYmplY3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc09iamVjdCcpO1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0Z1bmN0aW9uJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvcicpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGlzcG9zYWJsZSByZXNvdXJjZSwgc3VjaCBhcyB0aGUgZXhlY3V0aW9uIG9mIGFuIE9ic2VydmFibGUuIEFcbiAqIFN1YnNjcmlwdGlvbiBoYXMgb25lIGltcG9ydGFudCBtZXRob2QsIGB1bnN1YnNjcmliZWAsIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRcbiAqIGFuZCBqdXN0IGRpc3Bvc2VzIHRoZSByZXNvdXJjZSBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uXG4gKlxuICogQWRkaXRpb25hbGx5LCBzdWJzY3JpcHRpb25zIG1heSBiZSBncm91cGVkIHRvZ2V0aGVyIHRocm91Z2ggdGhlIGBhZGQoKWBcbiAqIG1ldGhvZCwgd2hpY2ggd2lsbCBhdHRhY2ggYSBjaGlsZCBTdWJzY3JpcHRpb24gdG8gdGhlIGN1cnJlbnQgU3Vic2NyaXB0aW9uLlxuICogV2hlbiBhIFN1YnNjcmlwdGlvbiBpcyB1bnN1YnNjcmliZWQsIGFsbCBpdHMgY2hpbGRyZW4gKGFuZCBpdHMgZ3JhbmRjaGlsZHJlbilcbiAqIHdpbGwgYmUgdW5zdWJzY3JpYmVkIGFzIHdlbGwuXG4gKlxuICogQGNsYXNzIFN1YnNjcmlwdGlvblxuICovXG52YXIgU3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFt1bnN1YnNjcmliZV0gQSBmdW5jdGlvbiBkZXNjcmliaW5nIGhvdyB0b1xuICAgICAqIHBlcmZvcm0gdGhlIGRpc3Bvc2FsIG9mIHJlc291cmNlcyB3aGVuIHRoZSBgdW5zdWJzY3JpYmVgIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIFN1YnNjcmlwdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHVuc3Vic2NyaWJlZC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi4gTWF5LCBmb3IgaW5zdGFuY2UsIGNhbmNlbFxuICAgICAqIGFuIG9uZ29pbmcgT2JzZXJ2YWJsZSBleGVjdXRpb24gb3IgY2FuY2VsIGFueSBvdGhlciB0eXBlIG9mIHdvcmsgdGhhdFxuICAgICAqIHN0YXJ0ZWQgd2hlbiB0aGUgU3Vic2NyaXB0aW9uIHdhcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3JzO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cywgX3Vuc3Vic2NyaWJlID0gX2EuX3Vuc3Vic2NyaWJlLCBfc3Vic2NyaXB0aW9ucyA9IF9hLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBudWxsO1xuICAgICAgICAvLyBudWxsIG91dCBfc3Vic2NyaXB0aW9ucyBmaXJzdCBzbyBhbnkgY2hpbGQgc3Vic2NyaXB0aW9ucyB0aGF0IGF0dGVtcHRcbiAgICAgICAgLy8gdG8gcmVtb3ZlIHRoZW1zZWx2ZXMgZnJvbSB0aGlzIHN1YnNjcmlwdGlvbiB3aWxsIG5vb3BcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgbGVuID0gX3BhcmVudHMgPyBfcGFyZW50cy5sZW5ndGggOiAwO1xuICAgICAgICAvLyBpZiB0aGlzLl9wYXJlbnQgaXMgbnVsbCwgdGhlbiBzbyBpcyB0aGlzLl9wYXJlbnRzLCBhbmQgd2VcbiAgICAgICAgLy8gZG9uJ3QgaGF2ZSB0byByZW1vdmUgb3Vyc2VsdmVzIGZyb20gYW55IHBhcmVudCBzdWJzY3JpcHRpb25zLlxuICAgICAgICB3aGlsZSAoX3BhcmVudCkge1xuICAgICAgICAgICAgX3BhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAvLyBpZiB0aGlzLl9wYXJlbnRzIGlzIG51bGwgb3IgaW5kZXggPj0gbGVuLFxuICAgICAgICAgICAgLy8gdGhlbiBfcGFyZW50IGlzIHNldCB0byBudWxsLCBhbmQgdGhlIGxvb3AgZXhpdHNcbiAgICAgICAgICAgIF9wYXJlbnQgPSArK2luZGV4IDwgbGVuICYmIF9wYXJlbnRzW2luZGV4XSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihfdW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKF91bnN1YnNjcmliZSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IChlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvciA/XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUuZXJyb3JzKSA6IFtlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkoX3N1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgbGVuID0gX3N1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gX3N1YnNjcmlwdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdF8xLmlzT2JqZWN0KHN1YikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWFsID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChzdWIudW5zdWJzY3JpYmUpLmNhbGwoc3ViKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWFsID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVyci5lcnJvcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Vycm9ycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0ZWFyIGRvd24gdG8gYmUgY2FsbGVkIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUoKSBvZiB0aGlzXG4gICAgICogU3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRlYXIgZG93biBiZWluZyBhZGRlZCBpcyBhIHN1YnNjcmlwdGlvbiB0aGF0IGlzIGFscmVhZHlcbiAgICAgKiB1bnN1YnNjcmliZWQsIGlzIHRoZSBzYW1lIHJlZmVyZW5jZSBgYWRkYCBpcyBiZWluZyBjYWxsZWQgb24sIG9yIGlzXG4gICAgICogYFN1YnNjcmlwdGlvbi5FTVBUWWAsIGl0IHdpbGwgbm90IGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBzdWJzY3JpcHRpb24gaXMgYWxyZWFkeSBpbiBhbiBgY2xvc2VkYCBzdGF0ZSwgdGhlIHBhc3NlZFxuICAgICAqIHRlYXIgZG93biBsb2dpYyB3aWxsIGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUZWFyZG93bkxvZ2ljfSB0ZWFyZG93biBUaGUgYWRkaXRpb25hbCBsb2dpYyB0byBleGVjdXRlIG9uXG4gICAgICogdGVhcmRvd24uXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufSBSZXR1cm5zIHRoZSBTdWJzY3JpcHRpb24gdXNlZCBvciBjcmVhdGVkIHRvIGJlXG4gICAgICogYWRkZWQgdG8gdGhlIGlubmVyIHN1YnNjcmlwdGlvbnMgbGlzdC4gVGhpcyBTdWJzY3JpcHRpb24gY2FuIGJlIHVzZWQgd2l0aFxuICAgICAqIGByZW1vdmUoKWAgdG8gcmVtb3ZlIHRoZSBwYXNzZWQgdGVhcmRvd24gbG9naWMgZnJvbSB0aGUgaW5uZXIgc3Vic2NyaXB0aW9uc1xuICAgICAqIGxpc3QuXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGVhcmRvd24pIHtcbiAgICAgICAgaWYgKCF0ZWFyZG93biB8fCAodGVhcmRvd24gPT09IFN1YnNjcmlwdGlvbi5FTVBUWSkpIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlYXJkb3duID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGVhcmRvd247XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHRlYXJkb3duKSB7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0ZWFyZG93bik7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2xvc2VkIHx8IHR5cGVvZiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb24uX2FkZFBhcmVudCAhPT0gJ2Z1bmN0aW9uJyAvKiBxdWFjayBxdWFjayAqLykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5fc3Vic2NyaXB0aW9ucyA9IFt0bXBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgdGVhcmRvd24gJyArIHRlYXJkb3duICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zIHx8ICh0aGlzLl9zdWJzY3JpcHRpb25zID0gW10pO1xuICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLl9hZGRQYXJlbnQodGhpcyk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgU3Vic2NyaXB0aW9uIGZyb20gdGhlIGludGVybmFsIGxpc3Qgb2Ygc3Vic2NyaXB0aW9ucyB0aGF0IHdpbGxcbiAgICAgKiB1bnN1YnNjcmliZSBkdXJpbmcgdGhlIHVuc3Vic2NyaWJlIHByb2Nlc3Mgb2YgdGhpcyBTdWJzY3JpcHRpb24uXG4gICAgICogQHBhcmFtIHtTdWJzY3JpcHRpb259IHN1YnNjcmlwdGlvbiBUaGUgc3Vic2NyaXB0aW9uIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX2FkZFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgX3BhcmVudCA9IF9hLl9wYXJlbnQsIF9wYXJlbnRzID0gX2EuX3BhcmVudHM7XG4gICAgICAgIGlmICghX3BhcmVudCB8fCBfcGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwYXJlbnQsIG9yIHRoZSBuZXcgcGFyZW50IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBwYXJlbnQsIHRoZW4gc2V0IHRoaXMuX3BhcmVudCB0byB0aGUgbmV3IHBhcmVudC5cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghX3BhcmVudHMpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBvbmUgcGFyZW50LCBidXQgbm90IG11bHRpcGxlLCBhbGxvY2F0ZSBhbiBBcnJheSB0b1xuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHJlc3Qgb2YgdGhlIHBhcmVudCBTdWJzY3JpcHRpb25zLlxuICAgICAgICAgICAgdGhpcy5fcGFyZW50cyA9IFtwYXJlbnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9wYXJlbnRzLmluZGV4T2YocGFyZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoZSBuZXcgcGFyZW50IHRvIHRoZSBfcGFyZW50cyBsaXN0IGlmIGl0J3Mgbm90IGFscmVhZHkgdGhlcmUuXG4gICAgICAgICAgICBfcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5FTVBUWSA9IChmdW5jdGlvbiAoZW1wdHkpIHtcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0obmV3IFN1YnNjcmlwdGlvbigpKSk7XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbjtcbmZ1bmN0aW9uIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvcnMpIHtcbiAgICByZXR1cm4gZXJyb3JzLnJlZHVjZShmdW5jdGlvbiAoZXJycywgZXJyKSB7IHJldHVybiBlcnJzLmNvbmNhdCgoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpID8gZXJyLmVycm9ycyA6IGVycik7IH0sIFtdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmlwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVmZXJfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvZGVmZXInKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmRlZmVyID0gZGVmZXJfMS5kZWZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBhamF4XzEgPSByZXF1aXJlKCcuLi8uLi8uLi9vYnNlcnZhYmxlL2RvbS9hamF4Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5hamF4ID0gYWpheF8xLmFqYXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hamF4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBmcm9tRXZlbnRfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvZnJvbUV2ZW50Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5mcm9tRXZlbnQgPSBmcm9tRXZlbnRfMS5mcm9tRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL21lcmdlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5tZXJnZSA9IG1lcmdlXzEubWVyZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgb2ZfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvb2YnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLm9mID0gb2ZfMS5vZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9mLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0aHJvd18xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS90aHJvdycpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUudGhyb3cgPSB0aHJvd18xLl90aHJvdztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocm93LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0aW1lcl8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS90aW1lcicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUudGltZXIgPSB0aW1lcl8xLnRpbWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGNhdGNoXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9jYXRjaCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmNhdGNoID0gY2F0Y2hfMS5fY2F0Y2g7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuX2NhdGNoID0gY2F0Y2hfMS5fY2F0Y2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVib3VuY2VUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kZWJvdW5jZVRpbWUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kZWJvdW5jZVRpbWUgPSBkZWJvdW5jZVRpbWVfMS5kZWJvdW5jZVRpbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZVRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGRlbGF5XzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kZWxheScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRlbGF5ID0gZGVsYXlfMS5kZWxheTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZGlzdGluY3RVbnRpbEtleUNoYW5nZWQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCA9IGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkXzEuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZG9fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RvJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZG8gPSBkb18xLl9kbztcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5fZG8gPSBkb18xLl9kbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBmaWx0ZXJfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2ZpbHRlcicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmZpbHRlciA9IGZpbHRlcl8xLmZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWFwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9tYXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5tYXAgPSBtYXBfMS5tYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlQWxsXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9tZXJnZUFsbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm1lcmdlQWxsID0gbWVyZ2VBbGxfMS5tZXJnZUFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlQWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciByZXRyeVdoZW5fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3JldHJ5V2hlbicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnJldHJ5V2hlbiA9IHJldHJ5V2hlbl8xLnJldHJ5V2hlbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5V2hlbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc2hhcmVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3NoYXJlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc2hhcmUgPSBzaGFyZV8xLnNoYXJlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHN0YXJ0V2l0aF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc3RhcnRXaXRoJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3RhcnRXaXRoID0gc3RhcnRXaXRoXzEuc3RhcnRXaXRoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhcnRXaXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzd2l0Y2hfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3N3aXRjaCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnN3aXRjaCA9IHN3aXRjaF8xLl9zd2l0Y2g7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N3aXRjaCA9IHN3aXRjaF8xLl9zd2l0Y2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHN3aXRjaE1hcF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc3dpdGNoTWFwJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3dpdGNoTWFwID0gc3dpdGNoTWFwXzEuc3dpdGNoTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoTWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0YWtlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90YWtlJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGFrZSA9IHRha2VfMS50YWtlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGFrZVVudGlsXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90YWtlVW50aWwnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50YWtlVW50aWwgPSB0YWtlVW50aWxfMS50YWtlVW50aWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlVW50aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRocm90dGxlVGltZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvdGhyb3R0bGVUaW1lJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGhyb3R0bGVUaW1lID0gdGhyb3R0bGVUaW1lXzEudGhyb3R0bGVUaW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3R0bGVUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB3aXRoTGF0ZXN0RnJvbV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivd2l0aExhdGVzdEZyb20nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS53aXRoTGF0ZXN0RnJvbSA9IHdpdGhMYXRlc3RGcm9tXzEud2l0aExhdGVzdEZyb207XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aXRoTGF0ZXN0RnJvbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgemlwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci96aXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS56aXAgPSB6aXBfMS56aXBQcm90bztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBTY2FsYXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1NjYWxhck9ic2VydmFibGUnKTtcbnZhciBFbXB0eU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRW1wdHlPYnNlcnZhYmxlJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgQXJyYXlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBpZiAoIXNjaGVkdWxlciAmJiBhcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnJheVswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcnJheU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGFycmF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBzb21lIHZhbHVlcyB5b3Ugc3BlY2lmeSBhcyBhcmd1bWVudHMsXG4gICAgICogaW1tZWRpYXRlbHkgb25lIGFmdGVyIHRoZSBvdGhlciwgYW5kIHRoZW4gZW1pdHMgYSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgdGhlIGFyZ3VtZW50cyB5b3UgcHJvdmlkZSwgdGhlbiBjb21wbGV0ZXMuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9vZi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgYXJndW1lbnRzIGdpdmVuLCBhbmQgdGhlIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiB0aGVyZWFmdGVyLiBJdCBjYW5cbiAgICAgKiBiZSB1c2VkIGZvciBjb21wb3Npbmcgd2l0aCBvdGhlciBPYnNlcnZhYmxlcywgc3VjaCBhcyB3aXRoIHtAbGluayBjb25jYXR9LlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgYSBgbnVsbGAgSVNjaGVkdWxlciwgd2hpY2ggbWVhbnMgdGhlIGBuZXh0YFxuICAgICAqIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgc3luY2hyb25vdXNseSwgYWx0aG91Z2ggd2l0aCBhIGRpZmZlcmVudCBJU2NoZWR1bGVyXG4gICAgICogaXQgaXMgcG9zc2libGUgdG8gZGV0ZXJtaW5lIHdoZW4gdGhvc2Ugbm90aWZpY2F0aW9ucyB3aWxsIGJlIGRlbGl2ZXJlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgMTAsIDIwLCAzMCwgdGhlbiAnYScsICdiJywgJ2MnLCB0aGVuIHN0YXJ0IHRpY2tpbmcgZXZlcnkgc2Vjb25kLjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUub2YoMTAsIDIwLCAzMCk7XG4gICAgICogdmFyIGxldHRlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpO1xuICAgICAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogdmFyIHJlc3VsdCA9IG51bWJlcnMuY29uY2F0KGxldHRlcnMpLmNvbmNhdChpbnRlcnZhbCk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICAgKiBAc2VlIHtAbGluayBlbXB0eX1cbiAgICAgKiBAc2VlIHtAbGluayBuZXZlcn1cbiAgICAgKiBAc2VlIHtAbGluayB0aHJvd31cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uVH0gdmFsdWVzIEFyZ3VtZW50cyB0aGF0IHJlcHJlc2VudCBgbmV4dGAgdmFsdWVzIHRvIGJlIGVtaXR0ZWQuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEEge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBlYWNoIGdpdmVuIGlucHV0IHZhbHVlLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIG9mXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBBcnJheU9ic2VydmFibGUub2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJyYXlbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgICAgICBhcnJheS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFycmF5T2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBzdGF0ZS5hcnJheSwgaW5kZXggPSBzdGF0ZS5pbmRleCwgY291bnQgPSBzdGF0ZS5jb3VudCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChpbmRleCA+PSBjb3VudCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheVtpbmRleF0pO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBBcnJheU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICB2YXIgY291bnQgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShBcnJheU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBhcnJheTogYXJyYXksIGluZGV4OiBpbmRleCwgY291bnQ6IGNvdW50LCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5BcnJheU9ic2VydmFibGUgPSBBcnJheU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBAY2xhc3MgQ29ubmVjdGFibGVPYnNlcnZhYmxlPFQ+XG4gKi9cbnZhciBDb25uZWN0YWJsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25uZWN0YWJsZU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGFibGVPYnNlcnZhYmxlKHNvdXJjZSwgc3ViamVjdEZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN1YmplY3RGYWN0b3J5ID0gc3ViamVjdEZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX3JlZkNvdW50ID0gMDtcbiAgICB9XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3ViamVjdCgpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuZ2V0U3ViamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzLl9zdWJqZWN0O1xuICAgICAgICBpZiAoIXN1YmplY3QgfHwgc3ViamVjdC5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YmplY3QgPSB0aGlzLnN1YmplY3RGYWN0b3J5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YmplY3Q7XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5fY29ubmVjdGlvbjtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uID0gdGhpcy5fY29ubmVjdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uYWRkKHRoaXMuc291cmNlXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZShuZXcgQ29ubmVjdGFibGVTdWJzY3JpYmVyKHRoaXMuZ2V0U3ViamVjdCgpLCB0aGlzKSkpO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5yZWZDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlmdChuZXcgUmVmQ291bnRPcGVyYXRvcih0aGlzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGFibGVPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Db25uZWN0YWJsZU9ic2VydmFibGUgPSBDb25uZWN0YWJsZU9ic2VydmFibGU7XG5leHBvcnRzLmNvbm5lY3RhYmxlT2JzZXJ2YWJsZURlc2NyaXB0b3IgPSB7XG4gICAgb3BlcmF0b3I6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBfcmVmQ291bnQ6IHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgX3N1YnNjcmliZTogeyB2YWx1ZTogQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlIH0sXG4gICAgZ2V0U3ViamVjdDogeyB2YWx1ZTogQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5nZXRTdWJqZWN0IH0sXG4gICAgY29ubmVjdDogeyB2YWx1ZTogQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5jb25uZWN0IH0sXG4gICAgcmVmQ291bnQ6IHsgdmFsdWU6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVmQ291bnQgfVxufTtcbnZhciBDb25uZWN0YWJsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25uZWN0YWJsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGFibGVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25uZWN0YWJsZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2Vycm9yLmNhbGwodGhpcywgZXJyKTtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGlmIChjb25uZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uO1xuICAgICAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50ID0gMDtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGFibGVTdWJzY3JpYmVyO1xufShTdWJqZWN0XzEuU3ViamVjdFN1YnNjcmliZXIpKTtcbnZhciBSZWZDb3VudE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZDb3VudE9wZXJhdG9yKGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgUmVmQ291bnRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gdGhpcy5jb25uZWN0YWJsZTtcbiAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50Kys7XG4gICAgICAgIHZhciByZWZDb3VudGVyID0gbmV3IFJlZkNvdW50U3Vic2NyaWJlcihzdWJzY3JpYmVyLCBjb25uZWN0YWJsZSk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHJlZkNvdW50ZXIpO1xuICAgICAgICBpZiAoIXJlZkNvdW50ZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZWZDb3VudGVyLmNvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudE9wZXJhdG9yO1xufSgpKTtcbnZhciBSZWZDb3VudFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWZDb3VudFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmQ291bnRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25uZWN0YWJsZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgUmVmQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGlmICghY29ubmVjdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IG51bGw7XG4gICAgICAgIHZhciByZWZDb3VudCA9IGNvbm5lY3RhYmxlLl9yZWZDb3VudDtcbiAgICAgICAgaWYgKHJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50ID0gcmVmQ291bnQgLSAxO1xuICAgICAgICBpZiAocmVmQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vL1xuICAgICAgICAvLyBDb21wYXJlIHRoZSBsb2NhbCBSZWZDb3VudFN1YnNjcmliZXIncyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiB0byB0aGVcbiAgICAgICAgLy8gY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gb24gdGhlIHNoYXJlZCBDb25uZWN0YWJsZU9ic2VydmFibGUuIEluIGNhc2VzXG4gICAgICAgIC8vIHdoZXJlIHRoZSBDb25uZWN0YWJsZU9ic2VydmFibGUgc291cmNlIHN5bmNocm9ub3VzbHkgZW1pdHMgdmFsdWVzLCBhbmRcbiAgICAgICAgLy8gdGhlIFJlZkNvdW50U3Vic2NyaWJlcidzIGRvd25zdHJlYW0gT2JzZXJ2ZXJzIHN5bmNocm9ub3VzbHkgdW5zdWJzY3JpYmUsXG4gICAgICAgIC8vIGV4ZWN1dGlvbiBjb250aW51ZXMgdG8gaGVyZSBiZWZvcmUgdGhlIFJlZkNvdW50T3BlcmF0b3IgaGFzIGEgY2hhbmNlIHRvXG4gICAgICAgIC8vIHN1cHBseSB0aGUgUmVmQ291bnRTdWJzY3JpYmVyIHdpdGggdGhlIHNoYXJlZCBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbi5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyBPYnNlcnZhYmxlLnJhbmdlKDAsIDEwKVxuICAgICAgICAvLyAgIC5wdWJsaXNoKClcbiAgICAgICAgLy8gICAucmVmQ291bnQoKVxuICAgICAgICAvLyAgIC50YWtlKDUpXG4gICAgICAgIC8vICAgLnN1YnNjcmliZSgpO1xuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhpcyBjYXNlLCBSZWZDb3VudFN1YnNjcmliZXIgc2hvdWxkIG9ubHkgZGlzcG9zZVxuICAgICAgICAvLyB0aGUgQ29ubmVjdGFibGVPYnNlcnZhYmxlJ3Mgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIGlmIHRoZVxuICAgICAgICAvLyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiBleGlzdHMsICphbmQqIGVpdGhlcjpcbiAgICAgICAgLy8gICBhLiBSZWZDb3VudFN1YnNjcmliZXIgZG9lc24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBzaGFyZWQgY29ubmVjdGlvblxuICAgICAgICAvLyAgICAgIFN1YnNjcmlwdGlvbiB5ZXQsIG9yLFxuICAgICAgICAvLyAgIGIuIFJlZkNvdW50U3Vic2NyaWJlcidzIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIHJlZmVyZW5jZSBpcyBpZGVudGljYWxcbiAgICAgICAgLy8gICAgICB0byB0aGUgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uXG4gICAgICAgIC8vL1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgdmFyIHNoYXJlZENvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5fY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHNoYXJlZENvbm5lY3Rpb24gJiYgKCFjb25uZWN0aW9uIHx8IHNoYXJlZENvbm5lY3Rpb24gPT09IGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICBzaGFyZWRDb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25uZWN0YWJsZU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBEZWZlck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWZlck9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVmZXJPYnNlcnZhYmxlKG9ic2VydmFibGVGYWN0b3J5KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmFibGVGYWN0b3J5ID0gb2JzZXJ2YWJsZUZhY3Rvcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0LCBvbiBzdWJzY3JpYmUsIGNhbGxzIGFuIE9ic2VydmFibGUgZmFjdG9yeSB0b1xuICAgICAqIG1ha2UgYW4gT2JzZXJ2YWJsZSBmb3IgZWFjaCBuZXcgT2JzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q3JlYXRlcyB0aGUgT2JzZXJ2YWJsZSBsYXppbHksIHRoYXQgaXMsIG9ubHkgd2hlbiBpdFxuICAgICAqIGlzIHN1YnNjcmliZWQuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9kZWZlci5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIGBkZWZlcmAgYWxsb3dzIHlvdSB0byBjcmVhdGUgdGhlIE9ic2VydmFibGUgb25seSB3aGVuIHRoZSBPYnNlcnZlclxuICAgICAqIHN1YnNjcmliZXMsIGFuZCBjcmVhdGUgYSBmcmVzaCBPYnNlcnZhYmxlIGZvciBlYWNoIE9ic2VydmVyLiBJdCB3YWl0cyB1bnRpbFxuICAgICAqIGFuIE9ic2VydmVyIHN1YnNjcmliZXMgdG8gaXQsIGFuZCB0aGVuIGl0IGdlbmVyYXRlcyBhbiBPYnNlcnZhYmxlLFxuICAgICAqIHR5cGljYWxseSB3aXRoIGFuIE9ic2VydmFibGUgZmFjdG9yeSBmdW5jdGlvbi4gSXQgZG9lcyB0aGlzIGFmcmVzaCBmb3IgZWFjaFxuICAgICAqIHN1YnNjcmliZXIsIHNvIGFsdGhvdWdoIGVhY2ggc3Vic2NyaWJlciBtYXkgdGhpbmsgaXQgaXMgc3Vic2NyaWJpbmcgdG8gdGhlXG4gICAgICogc2FtZSBPYnNlcnZhYmxlLCBpbiBmYWN0IGVhY2ggc3Vic2NyaWJlciBnZXRzIGl0cyBvd24gaW5kaXZpZHVhbFxuICAgICAqIE9ic2VydmFibGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdWJzY3JpYmUgdG8gZWl0aGVyIGFuIE9ic2VydmFibGUgb2YgY2xpY2tzIG9yIGFuIE9ic2VydmFibGUgb2YgaW50ZXJ2YWwsIGF0IHJhbmRvbTwvY2FwdGlvbj5cbiAgICAgKiB2YXIgY2xpY2tzT3JJbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAqICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgKiAgICAgcmV0dXJuIFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAgICAgKiAgIH0gZWxzZSB7XG4gICAgICogICAgIHJldHVybiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGNsaWNrc09ySW50ZXJ2YWwuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIGJlaGF2aW9yOlxuICAgICAqIC8vIElmIHRoZSByZXN1bHQgb2YgTWF0aC5yYW5kb20oKSBpcyBncmVhdGVyIHRoYW4gMC41IGl0IHdpbGwgbGlzdGVuXG4gICAgICogLy8gZm9yIGNsaWNrcyBhbnl3aGVyZSBvbiB0aGUgXCJkb2N1bWVudFwiOyB3aGVuIGRvY3VtZW50IGlzIGNsaWNrZWQgaXRcbiAgICAgKiAvLyB3aWxsIGxvZyBhIE1vdXNlRXZlbnQgb2JqZWN0IHRvIHRoZSBjb25zb2xlLiBJZiB0aGUgcmVzdWx0IGlzIGxlc3NcbiAgICAgKiAvLyB0aGFuIDAuNSBpdCB3aWxsIGVtaXQgYXNjZW5kaW5nIG51bWJlcnMsIG9uZSBldmVyeSBzZWNvbmQoMTAwMG1zKS5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogU3Vic2NyaWJhYmxlT3JQcm9taXNlfSBvYnNlcnZhYmxlRmFjdG9yeSBUaGUgT2JzZXJ2YWJsZVxuICAgICAqIGZhY3RvcnkgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIE9ic2VydmVyIHRoYXQgc3Vic2NyaWJlcyB0byB0aGUgb3V0cHV0XG4gICAgICogT2JzZXJ2YWJsZS4gTWF5IGFsc28gcmV0dXJuIGEgUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBjb252ZXJ0ZWQgb24gdGhlIGZseVxuICAgICAqIHRvIGFuIE9ic2VydmFibGUuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB3aG9zZSBPYnNlcnZlcnMnIHN1YnNjcmlwdGlvbnMgdHJpZ2dlclxuICAgICAqIGFuIGludm9jYXRpb24gb2YgdGhlIGdpdmVuIE9ic2VydmFibGUgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBkZWZlclxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRGVmZXJPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlRmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gbmV3IERlZmVyT2JzZXJ2YWJsZShvYnNlcnZhYmxlRmFjdG9yeSk7XG4gICAgfTtcbiAgICBEZWZlck9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gbmV3IERlZmVyU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9ic2VydmFibGVGYWN0b3J5KTtcbiAgICB9O1xuICAgIHJldHVybiBEZWZlck9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkRlZmVyT2JzZXJ2YWJsZSA9IERlZmVyT2JzZXJ2YWJsZTtcbnZhciBEZWZlclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWZlclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVmZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBmYWN0b3J5KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5mYWN0b3J5ID0gZmFjdG9yeTtcbiAgICAgICAgdGhpcy50cnlEZWZlcigpO1xuICAgIH1cbiAgICBEZWZlclN1YnNjcmliZXIucHJvdG90eXBlLnRyeURlZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fY2FsbEZhY3RvcnkoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWZlclN1YnNjcmliZXIucHJvdG90eXBlLl9jYWxsRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZmFjdG9yeSgpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVmZXJTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlZmVyT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgRW1wdHlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW1wdHlPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBubyBpdGVtcyB0byB0aGUgT2JzZXJ2ZXIgYW5kIGltbWVkaWF0ZWx5XG4gICAgICogZW1pdHMgYSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SnVzdCBlbWl0cyAnY29tcGxldGUnLCBhbmQgbm90aGluZyBlbHNlLlxuICAgICAqIDwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvZW1wdHkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBUaGlzIHN0YXRpYyBvcGVyYXRvciBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIGEgc2ltcGxlIE9ic2VydmFibGUgdGhhdCBvbmx5XG4gICAgICogZW1pdHMgdGhlIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi4gSXQgY2FuIGJlIHVzZWQgZm9yIGNvbXBvc2luZyB3aXRoIG90aGVyXG4gICAgICogT2JzZXJ2YWJsZXMsIHN1Y2ggYXMgaW4gYSB7QGxpbmsgbWVyZ2VNYXB9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbnVtYmVyIDcsIHRoZW4gY29tcGxldGUuPC9jYXB0aW9uPlxuICAgICAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLmVtcHR5KCkuc3RhcnRXaXRoKDcpO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgYW5kIGZsYXR0ZW4gb25seSBvZGQgbnVtYmVycyB0byB0aGUgc2VxdWVuY2UgJ2EnLCAnYicsICdjJzwvY2FwdGlvbj5cbiAgICAgKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgICAqIHZhciByZXN1bHQgPSBpbnRlcnZhbC5tZXJnZU1hcCh4ID0+XG4gICAgICogICB4ICUgMiA9PT0gMSA/IFJ4Lk9ic2VydmFibGUub2YoJ2EnLCAnYicsICdjJykgOiBSeC5PYnNlcnZhYmxlLmVtcHR5KClcbiAgICAgKiApO1xuICAgICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmcgdG8gdGhlIGNvbnNvbGU6XG4gICAgICogLy8geCBpcyBlcXVhbCB0byB0aGUgY291bnQgb24gdGhlIGludGVydmFsIGVnKDAsMSwyLDMsLi4uKVxuICAgICAqIC8vIHggd2lsbCBvY2N1ciBldmVyeSAxMDAwbXNcbiAgICAgKiAvLyBpZiB4ICUgMiBpcyBlcXVhbCB0byAxIHByaW50IGFiY1xuICAgICAqIC8vIGlmIHggJSAyIGlzIG5vdCBlcXVhbCB0byAxIG5vdGhpbmcgd2lsbCBiZSBvdXRwdXRcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICAgKiBAc2VlIHtAbGluayBuZXZlcn1cbiAgICAgKiBAc2VlIHtAbGluayBvZn1cbiAgICAgKiBAc2VlIHtAbGluayB0aHJvd31cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZW1pc3Npb24gb2YgdGhlIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBcImVtcHR5XCIgT2JzZXJ2YWJsZTogZW1pdHMgb25seSB0aGUgY29tcGxldGVcbiAgICAgKiBub3RpZmljYXRpb24uXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgZW1wdHlcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEVtcHR5T2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBFbXB0eU9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXI7XG4gICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICB9O1xuICAgIEVtcHR5T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShFbXB0eU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHsgc3Vic2NyaWJlcjogc3Vic2NyaWJlciB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEVtcHR5T2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRW1wdHlPYnNlcnZhYmxlID0gRW1wdHlPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW1wdHlPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBFcnJvck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFcnJvck9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXJyb3JPYnNlcnZhYmxlKGVycm9yLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG5vIGl0ZW1zIHRvIHRoZSBPYnNlcnZlciBhbmQgaW1tZWRpYXRlbHlcbiAgICAgKiBlbWl0cyBhbiBlcnJvciBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SnVzdCBlbWl0cyAnZXJyb3InLCBhbmQgbm90aGluZyBlbHNlLlxuICAgICAqIDwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvdGhyb3cucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBUaGlzIHN0YXRpYyBvcGVyYXRvciBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIGEgc2ltcGxlIE9ic2VydmFibGUgdGhhdCBvbmx5XG4gICAgICogZW1pdHMgdGhlIGVycm9yIG5vdGlmaWNhdGlvbi4gSXQgY2FuIGJlIHVzZWQgZm9yIGNvbXBvc2luZyB3aXRoIG90aGVyXG4gICAgICogT2JzZXJ2YWJsZXMsIHN1Y2ggYXMgaW4gYSB7QGxpbmsgbWVyZ2VNYXB9LlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbnVtYmVyIDcsIHRoZW4gZW1pdCBhbiBlcnJvci48L2NhcHRpb24+XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUudGhyb3cobmV3IEVycm9yKCdvb3BzIScpKS5zdGFydFdpdGgoNyk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGFuZCBmbGF0dGVuIG51bWJlcnMgdG8gdGhlIHNlcXVlbmNlICdhJywgJ2InLCAnYycsIGJ1dCB0aHJvdyBhbiBlcnJvciBmb3IgMTM8L2NhcHRpb24+XG4gICAgICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gaW50ZXJ2YWwubWVyZ2VNYXAoeCA9PlxuICAgICAqICAgeCA9PT0gMTMgP1xuICAgICAqICAgICBSeC5PYnNlcnZhYmxlLnRocm93KCdUaGlydGVlbnMgYXJlIGJhZCcpIDpcbiAgICAgKiAgICAgUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKVxuICAgICAqICk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIGVtcHR5fVxuICAgICAqIEBzZWUge0BsaW5rIG5ldmVyfVxuICAgICAqIEBzZWUge0BsaW5rIG9mfVxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGVycm9yIFRoZSBwYXJ0aWN1bGFyIEVycm9yIHRvIHBhc3MgdG8gdGhlIGVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHRoZSBlcnJvciBub3RpZmljYXRpb24uXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gZXJyb3IgT2JzZXJ2YWJsZTogZW1pdHMgb25seSB0aGUgZXJyb3Igbm90aWZpY2F0aW9uXG4gICAgICogdXNpbmcgdGhlIGdpdmVuIGVycm9yIGFyZ3VtZW50LlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIHRocm93XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBFcnJvck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGVycm9yLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvck9ic2VydmFibGUoZXJyb3IsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBFcnJvck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBlcnJvciA9IGFyZy5lcnJvciwgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIEVycm9yT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMuZXJyb3I7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShFcnJvck9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFcnJvck9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkVycm9yT2JzZXJ2YWJsZSA9IEVycm9yT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVycm9yT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiBpc05vZGVTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5hZGRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5vbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLm9mZiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzTm9kZUxpc3Qoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHRvU3RyaW5nLmNhbGwoc291cmNlT2JqKSA9PT0gJ1tvYmplY3QgTm9kZUxpc3RdJztcbn1cbmZ1bmN0aW9uIGlzSFRNTENvbGxlY3Rpb24oc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHRvU3RyaW5nLmNhbGwoc291cmNlT2JqKSA9PT0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJztcbn1cbmZ1bmN0aW9uIGlzRXZlbnRUYXJnZXQoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmouYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEZyb21FdmVudE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGcm9tRXZlbnRPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZyb21FdmVudE9ic2VydmFibGUoc291cmNlT2JqLCBldmVudE5hbWUsIHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZU9iaiA9IHNvdXJjZU9iajtcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBldmVudHMgb2YgYSBzcGVjaWZpYyB0eXBlIGNvbWluZyBmcm9tIHRoZVxuICAgICAqIGdpdmVuIGV2ZW50IHRhcmdldC5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5DcmVhdGVzIGFuIE9ic2VydmFibGUgZnJvbSBET00gZXZlbnRzLCBvciBOb2RlXG4gICAgICogRXZlbnRFbWl0dGVyIGV2ZW50cyBvciBvdGhlcnMuPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9mcm9tRXZlbnQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgYnkgYXR0YWNoaW5nIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGFuIFwiZXZlbnQgdGFyZ2V0XCIsXG4gICAgICogd2hpY2ggbWF5IGJlIGFuIG9iamVjdCB3aXRoIGBhZGRFdmVudExpc3RlbmVyYCBhbmQgYHJlbW92ZUV2ZW50TGlzdGVuZXJgLFxuICAgICAqIGEgTm9kZS5qcyBFdmVudEVtaXR0ZXIsIGEgalF1ZXJ5IHN0eWxlIEV2ZW50RW1pdHRlciwgYSBOb2RlTGlzdCBmcm9tIHRoZVxuICAgICAqIERPTSwgb3IgYW4gSFRNTENvbGxlY3Rpb24gZnJvbSB0aGUgRE9NLiBUaGUgZXZlbnQgaGFuZGxlciBpcyBhdHRhY2hlZCB3aGVuXG4gICAgICogdGhlIG91dHB1dCBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQsIGFuZCByZW1vdmVkIHdoZW4gdGhlIFN1YnNjcmlwdGlvbiBpc1xuICAgICAqIHVuc3Vic2NyaWJlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGNsaWNrcyBoYXBwZW5pbmcgb24gdGhlIERPTSBkb2N1bWVudDwvY2FwdGlvbj5cbiAgICAgKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICAgICAqIGNsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXN1bHRzIGluOlxuICAgICAqIC8vIE1vdXNlRXZlbnQgb2JqZWN0IGxvZ2dlZCB0byBjb25zb2xlIGV2ZXJ5dGltZSBhIGNsaWNrXG4gICAgICogLy8gb2NjdXJzIG9uIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGZyb219XG4gICAgICogQHNlZSB7QGxpbmsgZnJvbUV2ZW50UGF0dGVybn1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgVGhlIERPTUVsZW1lbnQsIGV2ZW50IHRhcmdldCwgTm9kZS5qc1xuICAgICAqIEV2ZW50RW1pdHRlciwgTm9kZUxpc3Qgb3IgSFRNTENvbGxlY3Rpb24gdG8gYXR0YWNoIHRoZSBldmVudCBoYW5kbGVyIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgb2YgaW50ZXJlc3QsIGJlaW5nIGVtaXR0ZWQgYnkgdGhlXG4gICAgICogYHRhcmdldGAuXG4gICAgICogQHBhcmFtIHtFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0aHJvdWdoIHRvIGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge1NlbGVjdG9yTWV0aG9kU2lnbmF0dXJlPFQ+fSBbc2VsZWN0b3JdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvXG4gICAgICogcG9zdC1wcm9jZXNzIHJlc3VsdHMuIEl0IHRha2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgZXZlbnQgaGFuZGxlciBhbmRcbiAgICAgKiBzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59XG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgZnJvbUV2ZW50XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgb3B0aW9ucywgc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJvbUV2ZW50T2JzZXJ2YWJsZSh0YXJnZXQsIGV2ZW50TmFtZSwgc2VsZWN0b3IsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5zZXR1cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzb3VyY2VPYmosIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmU7XG4gICAgICAgIGlmIChpc05vZGVMaXN0KHNvdXJjZU9iaikgfHwgaXNIVE1MQ29sbGVjdGlvbihzb3VyY2VPYmopKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlT2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5zZXR1cFN1YnNjcmlwdGlvbihzb3VyY2VPYmpbaV0sIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFdmVudFRhcmdldChzb3VyY2VPYmopKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlXzEgPSBzb3VyY2VPYmo7XG4gICAgICAgICAgICBzb3VyY2VPYmouYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2VfMS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlXzIgPSBzb3VyY2VPYmo7XG4gICAgICAgICAgICBzb3VyY2VPYmoub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlXzIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZV8zID0gc291cmNlT2JqO1xuICAgICAgICAgICAgc291cmNlT2JqLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZV8zLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGV2ZW50IHRhcmdldCcpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIuYWRkKG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24odW5zdWJzY3JpYmUpKTtcbiAgICB9O1xuICAgIEZyb21FdmVudE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc291cmNlT2JqID0gdGhpcy5zb3VyY2VPYmo7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSB0aGlzLmV2ZW50TmFtZTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG4gICAgICAgIHZhciBoYW5kbGVyID0gc2VsZWN0b3IgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc2VsZWN0b3IpLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gc3Vic2NyaWJlci5uZXh0KGUpOyB9O1xuICAgICAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnNldHVwU3Vic2NyaXB0aW9uKHNvdXJjZU9iaiwgZXZlbnROYW1lLCBoYW5kbGVyLCBzdWJzY3JpYmVyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBGcm9tRXZlbnRPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Gcm9tRXZlbnRPYnNlcnZhYmxlID0gRnJvbUV2ZW50T2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyb21FdmVudE9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIFNjYWxhck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY2FsYXJPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNjYWxhck9ic2VydmFibGUodmFsdWUsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5faXNTY2FsYXIgPSB0cnVlO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFNjYWxhck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXJPYnNlcnZhYmxlKHZhbHVlLCBzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgU2NhbGFyT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgZG9uZSA9IHN0YXRlLmRvbmUsIHZhbHVlID0gc3RhdGUudmFsdWUsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbiAgICB9O1xuICAgIFNjYWxhck9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoU2NhbGFyT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLCB2YWx1ZTogdmFsdWUsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTY2FsYXJPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5TY2FsYXJPYnNlcnZhYmxlID0gU2NhbGFyT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjYWxhck9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc051bWVyaWNfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNOdW1lcmljJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgVGltZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZXJPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVyT2JzZXJ2YWJsZShkdWVUaW1lLCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoZHVlVGltZSA9PT0gdm9pZCAwKSB7IGR1ZVRpbWUgPSAwOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBlcmlvZCA9IC0xO1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSAwO1xuICAgICAgICBpZiAoaXNOdW1lcmljXzEuaXNOdW1lcmljKHBlcmlvZCkpIHtcbiAgICAgICAgICAgIHRoaXMucGVyaW9kID0gTnVtYmVyKHBlcmlvZCkgPCAxICYmIDEgfHwgTnVtYmVyKHBlcmlvZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihwZXJpb2QpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBwZXJpb2Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGlzRGF0ZV8xLmlzRGF0ZShkdWVUaW1lKSA/XG4gICAgICAgICAgICAoK2R1ZVRpbWUgLSB0aGlzLnNjaGVkdWxlci5ub3coKSkgOlxuICAgICAgICAgICAgZHVlVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgc3RhcnRzIGVtaXR0aW5nIGFmdGVyIGFuIGBpbml0aWFsRGVsYXlgIGFuZFxuICAgICAqIGVtaXRzIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZSB0aGVyZWFmdGVyLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0cyBsaWtlIHtAbGluayBpbnRlcnZhbH0sIGJ1dCB5b3UgY2FuIHNwZWNpZnkgd2hlblxuICAgICAqIHNob3VsZCB0aGUgZW1pc3Npb25zIHN0YXJ0Ljwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvdGltZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBgdGltZXJgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFuIGluZmluaXRlIHNlcXVlbmNlIG9mIGFzY2VuZGluZ1xuICAgICAqIGludGVnZXJzLCB3aXRoIGEgY29uc3RhbnQgaW50ZXJ2YWwgb2YgdGltZSwgYHBlcmlvZGAgb2YgeW91ciBjaG9vc2luZ1xuICAgICAqIGJldHdlZW4gdGhvc2UgZW1pc3Npb25zLiBUaGUgZmlyc3QgZW1pc3Npb24gaGFwcGVucyBhZnRlciB0aGUgc3BlY2lmaWVkXG4gICAgICogYGluaXRpYWxEZWxheWAuIFRoZSBpbml0aWFsIGRlbGF5IG1heSBiZSBhIHtAbGluayBEYXRlfS4gQnkgZGVmYXVsdCwgdGhpc1xuICAgICAqIG9wZXJhdG9yIHVzZXMgdGhlIGBhc3luY2AgSVNjaGVkdWxlciB0byBwcm92aWRlIGEgbm90aW9uIG9mIHRpbWUsIGJ1dCB5b3VcbiAgICAgKiBtYXkgcGFzcyBhbnkgSVNjaGVkdWxlciB0byBpdC4gSWYgYHBlcmlvZGAgaXMgbm90IHNwZWNpZmllZCwgdGhlIG91dHB1dFxuICAgICAqIE9ic2VydmFibGUgZW1pdHMgb25seSBvbmUgdmFsdWUsIGAwYC4gT3RoZXJ3aXNlLCBpdCBlbWl0cyBhbiBpbmZpbml0ZVxuICAgICAqIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgYXNjZW5kaW5nIG51bWJlcnMsIG9uZSBldmVyeSBzZWNvbmQgKDEwMDBtcyksIHN0YXJ0aW5nIGFmdGVyIDMgc2Vjb25kczwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUudGltZXIoMzAwMCwgMTAwMCk7XG4gICAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyBvbmUgbnVtYmVyIGFmdGVyIGZpdmUgc2Vjb25kczwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUudGltZXIoNTAwMCk7XG4gICAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBpbnRlcnZhbH1cbiAgICAgKiBAc2VlIHtAbGluayBkZWxheX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGluaXRpYWxEZWxheSBUaGUgaW5pdGlhbCBkZWxheSB0aW1lIHRvIHdhaXQgYmVmb3JlXG4gICAgICogZW1pdHRpbmcgdGhlIGZpcnN0IHZhbHVlIG9mIGAwYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BlcmlvZF0gVGhlIHBlcmlvZCBvZiB0aW1lIGJldHdlZW4gZW1pc3Npb25zIG9mIHRoZVxuICAgICAqIHN1YnNlcXVlbnQgbnVtYmVycy5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHZhbHVlcywgYW5kIHByb3ZpZGluZyBhIG5vdGlvbiBvZiBcInRpbWVcIi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBgMGAgYWZ0ZXIgdGhlXG4gICAgICogYGluaXRpYWxEZWxheWAgYW5kIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZVxuICAgICAqIHRoZXJlYWZ0ZXIuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgdGltZXJcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbERlbGF5LCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoaW5pdGlhbERlbGF5ID09PSB2b2lkIDApIHsgaW5pdGlhbERlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IFRpbWVyT2JzZXJ2YWJsZShpbml0aWFsRGVsYXksIHBlcmlvZCwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCwgcGVyaW9kID0gc3RhdGUucGVyaW9kLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXM7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChpbmRleCk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBlcmlvZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIGFjdGlvbi5zY2hlZHVsZShzdGF0ZSwgcGVyaW9kKTtcbiAgICB9O1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHBlcmlvZCA9IF9hLnBlcmlvZCwgZHVlVGltZSA9IF9hLmR1ZVRpbWUsIHNjaGVkdWxlciA9IF9hLnNjaGVkdWxlcjtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShUaW1lck9ic2VydmFibGUuZGlzcGF0Y2gsIGR1ZVRpbWUsIHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCwgcGVyaW9kOiBwZXJpb2QsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZXJPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5UaW1lck9ic2VydmFibGUgPSBUaW1lck9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW1lck9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRGVmZXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0RlZmVyT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5kZWZlciA9IERlZmVyT2JzZXJ2YWJsZV8xLkRlZmVyT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvcm9vdCcpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi8uLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vLi4vU3Vic2NyaWJlcicpO1xudmFyIG1hcF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvbWFwJyk7XG5mdW5jdGlvbiBnZXRDT1JTUmVxdWVzdCgpIHtcbiAgICBpZiAocm9vdF8xLnJvb3QuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByb290XzEucm9vdC5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICghIXJvb3RfMS5yb290LlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgcm9vdF8xLnJvb3QuWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ09SUyBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlcicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFhNTEh0dHBSZXF1ZXN0KCkge1xuICAgIGlmIChyb290XzEucm9vdC5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IHJvb3RfMS5yb290LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcHJvZ0lkID0gdm9pZCAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHByb2dJZHMgPSBbJ01zeG1sMi5YTUxIVFRQJywgJ01pY3Jvc29mdC5YTUxIVFRQJywgJ01zeG1sMi5YTUxIVFRQLjQuMCddO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBwcm9nSWQgPSBwcm9nSWRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV3IHJvb3RfMS5yb290LkFjdGl2ZVhPYmplY3QocHJvZ0lkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJvb3RfMS5yb290LkFjdGl2ZVhPYmplY3QocHJvZ0lkKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYTUxIdHRwUmVxdWVzdCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3NlcicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYWpheEdldCh1cmwsIGhlYWRlcnMpIHtcbiAgICBpZiAoaGVhZGVycyA9PT0gdm9pZCAwKSB7IGhlYWRlcnMgPSBudWxsOyB9XG4gICAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZSh7IG1ldGhvZDogJ0dFVCcsIHVybDogdXJsLCBoZWFkZXJzOiBoZWFkZXJzIH0pO1xufVxuZXhwb3J0cy5hamF4R2V0ID0gYWpheEdldDtcbjtcbmZ1bmN0aW9uIGFqYXhQb3N0KHVybCwgYm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdQT1NUJywgdXJsOiB1cmwsIGJvZHk6IGJvZHksIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG59XG5leHBvcnRzLmFqYXhQb3N0ID0gYWpheFBvc3Q7XG47XG5mdW5jdGlvbiBhamF4RGVsZXRlKHVybCwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdERUxFVEUnLCB1cmw6IHVybCwgaGVhZGVyczogaGVhZGVycyB9KTtcbn1cbmV4cG9ydHMuYWpheERlbGV0ZSA9IGFqYXhEZWxldGU7XG47XG5mdW5jdGlvbiBhamF4UHV0KHVybCwgYm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdQVVQnLCB1cmw6IHVybCwgYm9keTogYm9keSwgaGVhZGVyczogaGVhZGVycyB9KTtcbn1cbmV4cG9ydHMuYWpheFB1dCA9IGFqYXhQdXQ7XG47XG5mdW5jdGlvbiBhamF4UGF0Y2godXJsLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZSh7IG1ldGhvZDogJ1BBVENIJywgdXJsOiB1cmwsIGJvZHk6IGJvZHksIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG59XG5leHBvcnRzLmFqYXhQYXRjaCA9IGFqYXhQYXRjaDtcbjtcbmZ1bmN0aW9uIGFqYXhHZXRKU09OKHVybCwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdHRVQnLCB1cmw6IHVybCwgcmVzcG9uc2VUeXBlOiAnanNvbicsIGhlYWRlcnM6IGhlYWRlcnMgfSlcbiAgICAgICAgLmxpZnQobmV3IG1hcF8xLk1hcE9wZXJhdG9yKGZ1bmN0aW9uICh4LCBpbmRleCkgeyByZXR1cm4geC5yZXNwb25zZTsgfSwgbnVsbCkpO1xufVxuZXhwb3J0cy5hamF4R2V0SlNPTiA9IGFqYXhHZXRKU09OO1xuO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBBamF4T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFqYXhPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFqYXhPYnNlcnZhYmxlKHVybE9yUmVxdWVzdCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZVhIUjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyb3NzRG9tYWluID8gZ2V0Q09SU1JlcXVlc3QuY2FsbCh0aGlzKSA6IGdldFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3Jvc3NEb21haW46IGZhbHNlLFxuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgdGltZW91dDogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIHVybE9yUmVxdWVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlcXVlc3QudXJsID0gdXJsT3JSZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiB1cmxPclJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodXJsT3JSZXF1ZXN0Lmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RbcHJvcF0gPSB1cmxPclJlcXVlc3RbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgfVxuICAgIEFqYXhPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBamF4U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnJlcXVlc3QpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYnNlcnZhYmxlIGZvciBhbiBBamF4IHJlcXVlc3Qgd2l0aCBlaXRoZXIgYSByZXF1ZXN0IG9iamVjdCB3aXRoXG4gICAgICogdXJsLCBoZWFkZXJzLCBldGMgb3IgYSBzdHJpbmcgZm9yIGEgVVJMLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlLmFqYXgoJy9wcm9kdWN0cycpO1xuICAgICAqIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUuYWpheCh7IHVybDogJ3Byb2R1Y3RzJywgbWV0aG9kOiAnR0VUJyB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gcmVxdWVzdCBDYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgICogICBBIHN0cmluZyBvZiB0aGUgVVJMIHRvIG1ha2UgdGhlIEFqYXggY2FsbC5cbiAgICAgKiAgIEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllc1xuICAgICAqICAgLSB1cmw6IFVSTCBvZiB0aGUgcmVxdWVzdFxuICAgICAqICAgLSBib2R5OiBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdFxuICAgICAqICAgLSBtZXRob2Q6IE1ldGhvZCBvZiB0aGUgcmVxdWVzdCwgc3VjaCBhcyBHRVQsIFBPU1QsIFBVVCwgUEFUQ0gsIERFTEVURVxuICAgICAqICAgLSBhc3luYzogV2hldGhlciB0aGUgcmVxdWVzdCBpcyBhc3luY1xuICAgICAqICAgLSBoZWFkZXJzOiBPcHRpb25hbCBoZWFkZXJzXG4gICAgICogICAtIGNyb3NzRG9tYWluOiB0cnVlIGlmIGEgY3Jvc3MgZG9tYWluIHJlcXVlc3QsIGVsc2UgZmFsc2VcbiAgICAgKiAgIC0gY3JlYXRlWEhSOiBhIGZ1bmN0aW9uIHRvIG92ZXJyaWRlIGlmIHlvdSBuZWVkIHRvIHVzZSBhbiBhbHRlcm5hdGVcbiAgICAgKiAgIFhNTEh0dHBSZXF1ZXN0IGltcGxlbWVudGF0aW9uLlxuICAgICAqICAgLSByZXN1bHRTZWxlY3RvcjogYSBmdW5jdGlvbiB0byB1c2UgdG8gYWx0ZXIgdGhlIG91dHB1dCB2YWx1ZSB0eXBlIG9mXG4gICAgICogICB0aGUgT2JzZXJ2YWJsZS4gR2V0cyB7QGxpbmsgQWpheFJlc3BvbnNlfSBhcyBhbiBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIFhNTEh0dHBSZXF1ZXN0LlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGFqYXhcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICovXG4gICAgQWpheE9ic2VydmFibGUuY3JlYXRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNyZWF0ZSA9IGZ1bmN0aW9uICh1cmxPclJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUodXJsT3JSZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgY3JlYXRlLmdldCA9IGFqYXhHZXQ7XG4gICAgICAgIGNyZWF0ZS5wb3N0ID0gYWpheFBvc3Q7XG4gICAgICAgIGNyZWF0ZS5kZWxldGUgPSBhamF4RGVsZXRlO1xuICAgICAgICBjcmVhdGUucHV0ID0gYWpheFB1dDtcbiAgICAgICAgY3JlYXRlLnBhdGNoID0gYWpheFBhdGNoO1xuICAgICAgICBjcmVhdGUuZ2V0SlNPTiA9IGFqYXhHZXRKU09OO1xuICAgICAgICByZXR1cm4gY3JlYXRlO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIEFqYXhPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5BamF4T2JzZXJ2YWJsZSA9IEFqYXhPYnNlcnZhYmxlO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBBamF4U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFqYXhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFqYXhTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCByZXF1ZXN0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHZhciBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzIHx8IHt9O1xuICAgICAgICAvLyBmb3JjZSBDT1JTIGlmIHJlcXVlc3RlZFxuICAgICAgICBpZiAoIXJlcXVlc3QuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbJ1gtUmVxdWVzdGVkLVdpdGgnXSkge1xuICAgICAgICAgICAgaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcbiAgICAgICAgfVxuICAgICAgICAvLyBlbnN1cmUgY29udGVudCB0eXBlIGlzIHNldFxuICAgICAgICBpZiAoISgnQ29udGVudC1UeXBlJyBpbiBoZWFkZXJzKSAmJiAhKHJvb3RfMS5yb290LkZvcm1EYXRhICYmIHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIHJvb3RfMS5yb290LkZvcm1EYXRhKSAmJiB0eXBlb2YgcmVxdWVzdC5ib2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04JztcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9wZXJseSBzZXJpYWxpemUgYm9keVxuICAgICAgICByZXF1ZXN0LmJvZHkgPSB0aGlzLnNlcmlhbGl6ZUJvZHkocmVxdWVzdC5ib2R5LCByZXF1ZXN0LmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKTtcbiAgICAgICAgdGhpcy5zZW5kKCk7XG4gICAgfVxuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgeGhyID0gX2EueGhyLCByZXF1ZXN0ID0gX2EucmVxdWVzdCwgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbjtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0gbmV3IEFqYXhSZXNwb25zZShlLCB4aHIsIHJlcXVlc3QpO1xuICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXF1ZXN0ID0gX2EucmVxdWVzdCwgX2IgPSBfYS5yZXF1ZXN0LCB1c2VyID0gX2IudXNlciwgbWV0aG9kID0gX2IubWV0aG9kLCB1cmwgPSBfYi51cmwsIGFzeW5jID0gX2IuYXN5bmMsIHBhc3N3b3JkID0gX2IucGFzc3dvcmQsIGhlYWRlcnMgPSBfYi5oZWFkZXJzLCBib2R5ID0gX2IuYm9keTtcbiAgICAgICAgdmFyIGNyZWF0ZVhIUiA9IHJlcXVlc3QuY3JlYXRlWEhSO1xuICAgICAgICB2YXIgeGhyID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChjcmVhdGVYSFIpLmNhbGwocmVxdWVzdCk7XG4gICAgICAgIGlmICh4aHIgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMueGhyID0geGhyO1xuICAgICAgICAgICAgLy8gc2V0IHVwIHRoZSBldmVudHMgYmVmb3JlIG9wZW4gWEhSXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3QvVXNpbmdfWE1MSHR0cFJlcXVlc3RcbiAgICAgICAgICAgIC8vIFlvdSBuZWVkIHRvIGFkZCB0aGUgZXZlbnQgbGlzdGVuZXJzIGJlZm9yZSBjYWxsaW5nIG9wZW4oKSBvbiB0aGUgcmVxdWVzdC5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgcHJvZ3Jlc3MgZXZlbnRzIHdpbGwgbm90IGZpcmUuXG4gICAgICAgICAgICB0aGlzLnNldHVwRXZlbnRzKHhociwgcmVxdWVzdCk7XG4gICAgICAgICAgICAvLyBvcGVuIFhIUlxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh1c2VyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIub3BlbikuY2FsbCh4aHIsIG1ldGhvZCwgdXJsLCBhc3luYywgdXNlciwgcGFzc3dvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIub3BlbikuY2FsbCh4aHIsIG1ldGhvZCwgdXJsLCBhc3luYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGltZW91dCwgcmVzcG9uc2VUeXBlIGFuZCB3aXRoQ3JlZGVudGlhbHMgY2FuIGJlIHNldCBvbmNlIHRoZSBYSFIgaXMgb3BlblxuICAgICAgICAgICAgeGhyLnRpbWVvdXQgPSByZXF1ZXN0LnRpbWVvdXQ7XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gcmVxdWVzdC5yZXNwb25zZVR5cGU7XG4gICAgICAgICAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhcmVxdWVzdC53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgaGVhZGVyc1xuICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXJzKHhociwgaGVhZGVycyk7XG4gICAgICAgICAgICAvLyBmaW5hbGx5IHNlbmQgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIHJlc3VsdCA9IGJvZHkgPyB0cnlDYXRjaF8xLnRyeUNhdGNoKHhoci5zZW5kKS5jYWxsKHhociwgYm9keSkgOiB0cnlDYXRjaF8xLnRyeUNhdGNoKHhoci5zZW5kKS5jYWxsKHhocik7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4aHI7XG4gICAgfTtcbiAgICBBamF4U3Vic2NyaWJlci5wcm90b3R5cGUuc2VyaWFsaXplQm9keSA9IGZ1bmN0aW9uIChib2R5LCBjb250ZW50VHlwZSkge1xuICAgICAgICBpZiAoIWJvZHkgfHwgdHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290XzEucm9vdC5Gb3JtRGF0YSAmJiBib2R5IGluc3RhbmNlb2Ygcm9vdF8xLnJvb3QuRm9ybURhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgdmFyIHNwbGl0SW5kZXggPSBjb250ZW50VHlwZS5pbmRleE9mKCc7Jyk7XG4gICAgICAgICAgICBpZiAoc3BsaXRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLnN1YnN0cmluZygwLCBzcGxpdEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhib2R5KS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKGVuY29kZVVSSShrZXkpICsgXCI9XCIgKyBlbmNvZGVVUkkoYm9keVtrZXldKSk7IH0pLmpvaW4oJyYnKTtcbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2pzb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5zZXRIZWFkZXJzID0gZnVuY3Rpb24gKHhociwgaGVhZGVycykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgaWYgKGhlYWRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLnNldHVwRXZlbnRzID0gZnVuY3Rpb24gKHhociwgcmVxdWVzdCkge1xuICAgICAgICB2YXIgcHJvZ3Jlc3NTdWJzY3JpYmVyID0gcmVxdWVzdC5wcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgIGZ1bmN0aW9uIHhoclRpbWVvdXQoZSkge1xuICAgICAgICAgICAgdmFyIF9hID0geGhyVGltZW91dCwgc3Vic2NyaWJlciA9IF9hLnN1YnNjcmliZXIsIHByb2dyZXNzU3Vic2NyaWJlciA9IF9hLnByb2dyZXNzU3Vic2NyaWJlciwgcmVxdWVzdCA9IF9hLnJlcXVlc3Q7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihuZXcgQWpheFRpbWVvdXRFcnJvcih0aGlzLCByZXF1ZXN0KSk7IC8vVE9ETzogTWFrZSBiZXR0ZXJlci5cbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIHhoci5vbnRpbWVvdXQgPSB4aHJUaW1lb3V0O1xuICAgICAgICB4aHJUaW1lb3V0LnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB4aHJUaW1lb3V0LnN1YnNjcmliZXIgPSB0aGlzO1xuICAgICAgICB4aHJUaW1lb3V0LnByb2dyZXNzU3Vic2NyaWJlciA9IHByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKHhoci51cGxvYWQgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhoclByb2dyZXNzXzE7XG4gICAgICAgICAgICAgICAgeGhyUHJvZ3Jlc3NfMSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzc1N1YnNjcmliZXIgPSB4aHJQcm9ncmVzc18xLnByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLm5leHQoZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAocm9vdF8xLnJvb3QuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSB4aHJQcm9ncmVzc18xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0geGhyUHJvZ3Jlc3NfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeGhyUHJvZ3Jlc3NfMS5wcm9ncmVzc1N1YnNjcmliZXIgPSBwcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgeGhyRXJyb3JfMTtcbiAgICAgICAgICAgIHhockVycm9yXzEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHhockVycm9yXzEsIHByb2dyZXNzU3Vic2NyaWJlciA9IF9hLnByb2dyZXNzU3Vic2NyaWJlciwgc3Vic2NyaWJlciA9IF9hLnN1YnNjcmliZXIsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0O1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKG5ldyBBamF4RXJyb3IoJ2FqYXggZXJyb3InLCB0aGlzLCByZXF1ZXN0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSB4aHJFcnJvcl8xO1xuICAgICAgICAgICAgeGhyRXJyb3JfMS5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgICAgIHhockVycm9yXzEuc3Vic2NyaWJlciA9IHRoaXM7XG4gICAgICAgICAgICB4aHJFcnJvcl8xLnByb2dyZXNzU3Vic2NyaWJlciA9IHByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB4aHJSZWFkeVN0YXRlQ2hhbmdlKGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHhoclJlYWR5U3RhdGVDaGFuZ2UsIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyLCBwcm9ncmVzc1N1YnNjcmliZXIgPSBfYS5wcm9ncmVzc1N1YnNjcmliZXIsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0O1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBJRTkgYnVnIChodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwKVxuICAgICAgICAgICAgICAgIHZhciBzdGF0dXNfMSA9IHRoaXMuc3RhdHVzID09PSAxMjIzID8gMjA0IDogdGhpcy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gKHRoaXMucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyAodGhpcy5yZXNwb25zZSB8fCB0aGlzLnJlc3BvbnNlVGV4dCkgOiB0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAvLyBmaXggc3RhdHVzIGNvZGUgd2hlbiBpdCBpcyAwICgwIHN0YXR1cyBpcyB1bmRvY3VtZW50ZWQpLlxuICAgICAgICAgICAgICAgIC8vIE9jY3VycyB3aGVuIGFjY2Vzc2luZyBmaWxlIHJlc291cmNlcyBvciBvbiBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gd2hpbGUgcmV0cmlldmluZyBmaWxlcyBmcm9tIGFwcGxpY2F0aW9uIGNhY2hlLlxuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNfMSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNfMSA9IHJlc3BvbnNlID8gMjAwIDogMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKDIwMCA8PSBzdGF0dXNfMSAmJiBzdGF0dXNfMSA8IDMwMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc1N1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoZSk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzU3Vic2NyaWJlci5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKG5ldyBBamF4RXJyb3IoJ2FqYXggZXJyb3IgJyArIHN0YXR1c18xLCB0aGlzLCByZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoclJlYWR5U3RhdGVDaGFuZ2U7XG4gICAgICAgIHhoclJlYWR5U3RhdGVDaGFuZ2Uuc3Vic2NyaWJlciA9IHRoaXM7XG4gICAgICAgIHhoclJlYWR5U3RhdGVDaGFuZ2UucHJvZ3Jlc3NTdWJzY3JpYmVyID0gcHJvZ3Jlc3NTdWJzY3JpYmVyO1xuICAgICAgICB4aHJSZWFkeVN0YXRlQ2hhbmdlLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIH07XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBkb25lID0gX2EuZG9uZSwgeGhyID0gX2EueGhyO1xuICAgICAgICBpZiAoIWRvbmUgJiYgeGhyICYmIHhoci5yZWFkeVN0YXRlICE9PSA0ICYmIHR5cGVvZiB4aHIuYWJvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBBamF4U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuQWpheFN1YnNjcmliZXIgPSBBamF4U3Vic2NyaWJlcjtcbi8qKlxuICogQSBub3JtYWxpemVkIEFKQVggcmVzcG9uc2UuXG4gKlxuICogQHNlZSB7QGxpbmsgYWpheH1cbiAqXG4gKiBAY2xhc3MgQWpheFJlc3BvbnNlXG4gKi9cbnZhciBBamF4UmVzcG9uc2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFqYXhSZXNwb25zZShvcmlnaW5hbEV2ZW50LCB4aHIsIHJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgdGhpcy54aHIgPSB4aHI7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSB4aHIucmVzcG9uc2VUeXBlIHx8IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICBpZiAoJ3Jlc3BvbnNlJyBpbiB4aHIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9JRSBkb2VzIG5vdCBzdXBwb3J0IGpzb24gYXMgcmVzcG9uc2VUeXBlLCBwYXJzZSBpdCBpbnRlcm5hbGx5XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSB4aHIucmVzcG9uc2VUeXBlID8geGhyLnJlc3BvbnNlIDogSlNPTi5wYXJzZSh4aHIucmVzcG9uc2UgfHwgeGhyLnJlc3BvbnNlVGV4dCB8fCAnbnVsbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCB8fCAnbnVsbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3htbCc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHhoci5yZXNwb25zZVhNTDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gKCdyZXNwb25zZScgaW4geGhyKSA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFqYXhSZXNwb25zZTtcbn0oKSk7XG5leHBvcnRzLkFqYXhSZXNwb25zZSA9IEFqYXhSZXNwb25zZTtcbi8qKlxuICogQSBub3JtYWxpemVkIEFKQVggZXJyb3IuXG4gKlxuICogQHNlZSB7QGxpbmsgYWpheH1cbiAqXG4gKiBAY2xhc3MgQWpheEVycm9yXG4gKi9cbnZhciBBamF4RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBamF4RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWpheEVycm9yKG1lc3NhZ2UsIHhociwgcmVxdWVzdCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy54aHIgPSB4aHI7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICB9XG4gICAgcmV0dXJuIEFqYXhFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQWpheEVycm9yID0gQWpheEVycm9yO1xuLyoqXG4gKiBAc2VlIHtAbGluayBhamF4fVxuICpcbiAqIEBjbGFzcyBBamF4VGltZW91dEVycm9yXG4gKi9cbnZhciBBamF4VGltZW91dEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWpheFRpbWVvdXRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBamF4VGltZW91dEVycm9yKHhociwgcmVxdWVzdCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCAnYWpheCB0aW1lb3V0JywgeGhyLCByZXF1ZXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIEFqYXhUaW1lb3V0RXJyb3I7XG59KEFqYXhFcnJvcikpO1xuZXhwb3J0cy5BamF4VGltZW91dEVycm9yID0gQWpheFRpbWVvdXRFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFqYXhPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFqYXhPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0FqYXhPYnNlcnZhYmxlJyk7XG5leHBvcnRzLmFqYXggPSBBamF4T2JzZXJ2YWJsZV8xLkFqYXhPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFqYXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbWVyZ2VfMSA9IHJlcXVpcmUoJy4uL29wZXJhdG9yL21lcmdlJyk7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2VfMS5tZXJnZVN0YXRpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEVycm9yT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9FcnJvck9ic2VydmFibGUnKTtcbmV4cG9ydHMuX3Rocm93ID0gRXJyb3JPYnNlcnZhYmxlXzEuRXJyb3JPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocm93LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBDYXRjaGVzIGVycm9ycyBvbiB0aGUgb2JzZXJ2YWJsZSB0byBiZSBoYW5kbGVkIGJ5IHJldHVybmluZyBhIG5ldyBvYnNlcnZhYmxlIG9yIHRocm93aW5nIGFuIGVycm9yLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY2F0Y2gucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29udGludWVzIHdpdGggYSBkaWZmZXJlbnQgT2JzZXJ2YWJsZSB3aGVuIHRoZXJlJ3MgYW4gZXJyb3I8L2NhcHRpb24+XG4gKlxuICogT2JzZXJ2YWJsZS5vZigxLCAyLCAzLCA0LCA1KVxuICogICAubWFwKG4gPT4ge1xuICogXHQgICBpZiAobiA9PSA0KSB7XG4gKiBcdCAgICAgdGhyb3cgJ2ZvdXIhJztcbiAqICAgICB9XG4gKlx0ICAgcmV0dXJuIG47XG4gKiAgIH0pXG4gKiAgIC5jYXRjaChlcnIgPT4gT2JzZXJ2YWJsZS5vZignSScsICdJSScsICdJSUknLCAnSVYnLCAnVicpKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogICAvLyAxLCAyLCAzLCBJLCBJSSwgSUlJLCBJViwgVlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJldHJpZXMgdGhlIGNhdWdodCBzb3VyY2UgT2JzZXJ2YWJsZSBhZ2FpbiBpbiBjYXNlIG9mIGVycm9yLCBzaW1pbGFyIHRvIHJldHJ5KCkgb3BlcmF0b3I8L2NhcHRpb24+XG4gKlxuICogT2JzZXJ2YWJsZS5vZigxLCAyLCAzLCA0LCA1KVxuICogICAubWFwKG4gPT4ge1xuICogXHQgICBpZiAobiA9PT0gNCkge1xuICogXHQgICAgIHRocm93ICdmb3VyISc7XG4gKiAgICAgfVxuICogXHQgICByZXR1cm4gbjtcbiAqICAgfSlcbiAqICAgLmNhdGNoKChlcnIsIGNhdWdodCkgPT4gY2F1Z2h0KVxuICogICAudGFrZSgzMClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqICAgLy8gMSwgMiwgMywgMSwgMiwgMywgLi4uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VGhyb3dzIGEgbmV3IGVycm9yIHdoZW4gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRocm93cyBhbiBlcnJvcjwvY2FwdGlvbj5cbiAqXG4gKiBPYnNlcnZhYmxlLm9mKDEsIDIsIDMsIDQsIDUpXG4gKiAgIC5tYXAobiA9PiB7XG4gKiAgICAgaWYgKG4gPT0gNCkge1xuICogICAgICAgdGhyb3cgJ2ZvdXIhJztcbiAqICAgICB9XG4gKiAgICAgcmV0dXJuIG47XG4gKiAgIH0pXG4gKiAgIC5jYXRjaChlcnIgPT4ge1xuICogICAgIHRocm93ICdlcnJvciBpbiBzb3VyY2UuIERldGFpbHM6ICcgKyBlcnI7XG4gKiAgIH0pXG4gKiAgIC5zdWJzY3JpYmUoXG4gKiAgICAgeCA9PiBjb25zb2xlLmxvZyh4KSxcbiAqICAgICBlcnIgPT4gY29uc29sZS5sb2coZXJyKVxuICogICApO1xuICogICAvLyAxLCAyLCAzLCBlcnJvciBpbiBzb3VyY2UuIERldGFpbHM6IGZvdXIhXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc2VsZWN0b3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFzIGFyZ3VtZW50cyBgZXJyYCwgd2hpY2ggaXMgdGhlIGVycm9yLCBhbmQgYGNhdWdodGAsIHdoaWNoXG4gKiAgaXMgdGhlIHNvdXJjZSBvYnNlcnZhYmxlLCBpbiBjYXNlIHlvdSdkIGxpa2UgdG8gXCJyZXRyeVwiIHRoYXQgb2JzZXJ2YWJsZSBieSByZXR1cm5pbmcgaXQgYWdhaW4uIFdoYXRldmVyIG9ic2VydmFibGVcbiAqICBpcyByZXR1cm5lZCBieSB0aGUgYHNlbGVjdG9yYCB3aWxsIGJlIHVzZWQgdG8gY29udGludWUgdGhlIG9ic2VydmFibGUgY2hhaW4uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHRoYXQgb3JpZ2luYXRlcyBmcm9tIGVpdGhlciB0aGUgc291cmNlIG9yIHRoZSBvYnNlcnZhYmxlIHJldHVybmVkIGJ5IHRoZVxuICogIGNhdGNoIGBzZWxlY3RvcmAgZnVuY3Rpb24uXG4gKiBAbWV0aG9kIGNhdGNoXG4gKiBAbmFtZSBjYXRjaFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gX2NhdGNoKHNlbGVjdG9yKSB7XG4gICAgdmFyIG9wZXJhdG9yID0gbmV3IENhdGNoT3BlcmF0b3Ioc2VsZWN0b3IpO1xuICAgIHZhciBjYXVnaHQgPSB0aGlzLmxpZnQob3BlcmF0b3IpO1xuICAgIHJldHVybiAob3BlcmF0b3IuY2F1Z2h0ID0gY2F1Z2h0KTtcbn1cbmV4cG9ydHMuX2NhdGNoID0gX2NhdGNoO1xudmFyIENhdGNoT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhdGNoT3BlcmF0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgIH1cbiAgICBDYXRjaE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQ2F0Y2hTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuc2VsZWN0b3IsIHRoaXMuY2F1Z2h0KSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0Y2hPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIENhdGNoU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhdGNoU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYXRjaFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHNlbGVjdG9yLCBjYXVnaHQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY2F1Z2h0ID0gY2F1Z2h0O1xuICAgIH1cbiAgICAvLyBOT1RFOiBvdmVycmlkaW5nIGBlcnJvcmAgaW5zdGVhZCBvZiBgX2Vycm9yYCBiZWNhdXNlIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBoYXZlIHRoaXMgZmxhZyB0aGlzIHN1YnNjcmliZXIgYXMgYGlzU3RvcHBlZGAuIFdlIGNhbiBtaW1pYyB0aGVcbiAgICAvLyBiZWhhdmlvciBvZiB0aGUgUmV0cnlTdWJzY3JpYmVyIChmcm9tIHRoZSBgcmV0cnlgIG9wZXJhdG9yKSwgd2hlcmVcbiAgICAvLyB3ZSB1bnN1YnNjcmliZSBmcm9tIG91ciBzb3VyY2UgY2hhaW4sIHJlc2V0IG91ciBTdWJzY3JpYmVyIGZsYWdzLFxuICAgIC8vIHRoZW4gc3Vic2NyaWJlIHRvIHRoZSBzZWxlY3RvciByZXN1bHQuXG4gICAgQ2F0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5zZWxlY3RvcihlcnIsIHRoaXMuY2F1Z2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIyKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGVycjIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSgpO1xuICAgICAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXN1bHQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhdGNoU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG4vKipcbiAqIEVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb25seSBhZnRlciBhIHBhcnRpY3VsYXIgdGltZSBzcGFuXG4gKiBoYXMgcGFzc2VkIHdpdGhvdXQgYW5vdGhlciBzb3VyY2UgZW1pc3Npb24uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZGVsYXl9LCBidXQgcGFzc2VzIG9ubHkgdGhlIG1vc3RcbiAqIHJlY2VudCB2YWx1ZSBmcm9tIGVhY2ggYnVyc3Qgb2YgZW1pc3Npb25zLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlYm91bmNlVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZGVib3VuY2VUaW1lYCBkZWxheXMgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgZHJvcHNcbiAqIHByZXZpb3VzIHBlbmRpbmcgZGVsYXllZCBlbWlzc2lvbnMgaWYgYSBuZXcgdmFsdWUgYXJyaXZlcyBvbiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGlzIG9wZXJhdG9yIGtlZXBzIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCB2YWx1ZSBmcm9tIHRoZVxuICogc291cmNlIE9ic2VydmFibGUsIGFuZCBlbWl0cyB0aGF0IG9ubHkgd2hlbiBgZHVlVGltZWAgZW5vdWdoIHRpbWUgaGFzIHBhc3NlZFxuICogd2l0aG91dCBhbnkgb3RoZXIgdmFsdWUgYXBwZWFyaW5nIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgYSBuZXcgdmFsdWVcbiAqIGFwcGVhcnMgYmVmb3JlIGBkdWVUaW1lYCBzaWxlbmNlIG9jY3VycywgdGhlIHByZXZpb3VzIHZhbHVlIHdpbGwgYmUgZHJvcHBlZFxuICogYW5kIHdpbGwgbm90IGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIFRoaXMgaXMgYSByYXRlLWxpbWl0aW5nIG9wZXJhdG9yLCBiZWNhdXNlIGl0IGlzIGltcG9zc2libGUgZm9yIG1vcmUgdGhhbiBvbmVcbiAqIHZhbHVlIHRvIGJlIGVtaXR0ZWQgaW4gYW55IHRpbWUgd2luZG93IG9mIGR1cmF0aW9uIGBkdWVUaW1lYCwgYnV0IGl0IGlzIGFsc29cbiAqIGEgZGVsYXktbGlrZSBvcGVyYXRvciBzaW5jZSBvdXRwdXQgZW1pc3Npb25zIGRvIG5vdCBvY2N1ciBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gKiB0aGV5IGRpZCBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuIE9wdGlvbmFsbHkgdGFrZXMgYSB7QGxpbmsgSVNjaGVkdWxlcn0gZm9yXG4gKiBtYW5hZ2luZyB0aW1lcnMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbW9zdCByZWNlbnQgY2xpY2sgYWZ0ZXIgYSBidXJzdCBvZiBjbGlja3M8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5kZWJvdW5jZVRpbWUoMTAwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0VGltZX1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlfVxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGVUaW1lfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdWVUaW1lIFRoZSB0aW1lb3V0IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGhlIHRpbWVcbiAqIHVuaXQgZGV0ZXJtaW5lZCBpbnRlcm5hbGx5IGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCkgZm9yIHRoZSB3aW5kb3cgb2ZcbiAqIHRpbWUgcmVxdWlyZWQgdG8gd2FpdCBmb3IgZW1pc3Npb24gc2lsZW5jZSBiZWZvcmUgZW1pdHRpbmcgdGhlIG1vc3QgcmVjZW50XG4gKiBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSB0aW1lb3V0IGZvciBlYWNoIHZhbHVlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhlIHNwZWNpZmllZCBgZHVlVGltZWAsIGFuZCBtYXkgZHJvcCBzb21lIHZhbHVlcyBpZiB0aGV5IG9jY3VyXG4gKiB0b28gZnJlcXVlbnRseS5cbiAqIEBtZXRob2QgZGVib3VuY2VUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWJvdW5jZVRpbWUoZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEZWJvdW5jZVRpbWVPcGVyYXRvcihkdWVUaW1lLCBzY2hlZHVsZXIpKTtcbn1cbmV4cG9ydHMuZGVib3VuY2VUaW1lID0gZGVib3VuY2VUaW1lO1xudmFyIERlYm91bmNlVGltZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZVRpbWVPcGVyYXRvcihkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5kdWVUaW1lID0gZHVlVGltZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIERlYm91bmNlVGltZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVib3VuY2VUaW1lU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1ZVRpbWUsIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVib3VuY2VUaW1lT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVib3VuY2VUaW1lU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSBkdWVUaW1lO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jbGVhckRlYm91bmNlKCk7XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZCh0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgdGhpcy5kdWVUaW1lLCB0aGlzKSk7XG4gICAgfTtcbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVib3VuY2VkTmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5kZWJvdW5jZWROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyRGVib3VuY2UoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmxhc3RWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmNsZWFyRGVib3VuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWJvdW5jZWRTdWJzY3JpcHRpb24gPSB0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGRlYm91bmNlZFN1YnNjcmlwdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZGVib3VuY2VkU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGRlYm91bmNlZFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVib3VuY2VUaW1lU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChzdWJzY3JpYmVyKSB7XG4gICAgc3Vic2NyaWJlci5kZWJvdW5jZWROZXh0KCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZVRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgaXNEYXRlXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzRGF0ZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBOb3RpZmljYXRpb25fMSA9IHJlcXVpcmUoJy4uL05vdGlmaWNhdGlvbicpO1xuLyoqXG4gKiBEZWxheXMgdGhlIGVtaXNzaW9uIG9mIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IGEgZ2l2ZW4gdGltZW91dCBvclxuICogdW50aWwgYSBnaXZlbiBEYXRlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5UaW1lIHNoaWZ0cyBlYWNoIGl0ZW0gYnkgc29tZSBzcGVjaWZpZWQgYW1vdW50IG9mXG4gKiBtaWxsaXNlY29uZHMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZGVsYXkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogSWYgdGhlIGRlbGF5IGFyZ3VtZW50IGlzIGEgTnVtYmVyLCB0aGlzIG9wZXJhdG9yIHRpbWUgc2hpZnRzIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhhdCBhbW91bnQgb2YgdGltZSBleHByZXNzZWQgaW4gbWlsbGlzZWNvbmRzLiBUaGUgcmVsYXRpdmVcbiAqIHRpbWUgaW50ZXJ2YWxzIGJldHdlZW4gdGhlIHZhbHVlcyBhcmUgcHJlc2VydmVkLlxuICpcbiAqIElmIHRoZSBkZWxheSBhcmd1bWVudCBpcyBhIERhdGUsIHRoaXMgb3BlcmF0b3IgdGltZSBzaGlmdHMgdGhlIHN0YXJ0IG9mIHRoZVxuICogT2JzZXJ2YWJsZSBleGVjdXRpb24gdW50aWwgdGhlIGdpdmVuIGRhdGUgb2NjdXJzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkRlbGF5IGVhY2ggY2xpY2sgYnkgb25lIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgZGVsYXllZENsaWNrcyA9IGNsaWNrcy5kZWxheSgxMDAwKTsgLy8gZWFjaCBjbGljayBlbWl0dGVkIGFmdGVyIDEgc2Vjb25kXG4gKiBkZWxheWVkQ2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWxheSBhbGwgY2xpY2tzIHVudGlsIGEgZnV0dXJlIGRhdGUgaGFwcGVuczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgZGF0ZSA9IG5ldyBEYXRlKCdNYXJjaCAxNSwgMjA1MCAxMjowMDowMCcpOyAvLyBpbiB0aGUgZnV0dXJlXG4gKiB2YXIgZGVsYXllZENsaWNrcyA9IGNsaWNrcy5kZWxheShkYXRlKTsgLy8gY2xpY2sgZW1pdHRlZCBvbmx5IGFmdGVyIHRoYXQgZGF0ZVxuICogZGVsYXllZENsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZGVib3VuY2VUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVsYXlXaGVufVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGRlbGF5IFRoZSBkZWxheSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgKGEgYG51bWJlcmApIG9yXG4gKiBhIGBEYXRlYCB1bnRpbCB3aGljaCB0aGUgZW1pc3Npb24gb2YgdGhlIHNvdXJjZSBpdGVtcyBpcyBkZWxheWVkLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3JcbiAqIG1hbmFnaW5nIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGhlIHRpbWUtc2hpZnQgZm9yIGVhY2ggaXRlbS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBkZWxheXMgdGhlIGVtaXNzaW9ucyBvZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGJ5IHRoZSBzcGVjaWZpZWQgdGltZW91dCBvciBEYXRlLlxuICogQG1ldGhvZCBkZWxheVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGVsYXkoZGVsYXksIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgdmFyIGFic29sdXRlRGVsYXkgPSBpc0RhdGVfMS5pc0RhdGUoZGVsYXkpO1xuICAgIHZhciBkZWxheUZvciA9IGFic29sdXRlRGVsYXkgPyAoK2RlbGF5IC0gc2NoZWR1bGVyLm5vdygpKSA6IE1hdGguYWJzKGRlbGF5KTtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEZWxheU9wZXJhdG9yKGRlbGF5Rm9yLCBzY2hlZHVsZXIpKTtcbn1cbmV4cG9ydHMuZGVsYXkgPSBkZWxheTtcbnZhciBEZWxheU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWxheU9wZXJhdG9yKGRlbGF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgRGVsYXlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlbGF5U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmRlbGF5LCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIERlbGF5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEZWxheVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWxheVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVsYXlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkZWxheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVycm9yZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgRGVsYXlTdWJzY3JpYmVyLmRpc3BhdGNoID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzdGF0ZS5zb3VyY2U7XG4gICAgICAgIHZhciBxdWV1ZSA9IHNvdXJjZS5xdWV1ZTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHN0YXRlLnNjaGVkdWxlcjtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gc3RhdGUuZGVzdGluYXRpb247XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwICYmIChxdWV1ZVswXS50aW1lIC0gc2NoZWR1bGVyLm5vdygpKSA8PSAwKSB7XG4gICAgICAgICAgICBxdWV1ZS5zaGlmdCgpLm5vdGlmaWNhdGlvbi5vYnNlcnZlKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGRlbGF5XzEgPSBNYXRoLm1heCgwLCBxdWV1ZVswXS50aW1lIC0gc2NoZWR1bGVyLm5vdygpKTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUsIGRlbGF5XzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc291cmNlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9zY2hlZHVsZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoRGVsYXlTdWJzY3JpYmVyLmRpc3BhdGNoLCB0aGlzLmRlbGF5LCB7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMsIGRlc3RpbmF0aW9uOiB0aGlzLmRlc3RpbmF0aW9uLCBzY2hlZHVsZXI6IHNjaGVkdWxlclxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBEZWxheVN1YnNjcmliZXIucHJvdG90eXBlLnNjaGVkdWxlTm90aWZpY2F0aW9uID0gZnVuY3Rpb24gKG5vdGlmaWNhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5lcnJvcmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyBEZWxheU1lc3NhZ2Uoc2NoZWR1bGVyLm5vdygpICsgdGhpcy5kZWxheSwgbm90aWZpY2F0aW9uKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQodmFsdWUpKTtcbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmVycm9yZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSgpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWxheVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG52YXIgRGVsYXlNZXNzYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWxheU1lc3NhZ2UodGltZSwgbm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gRGVsYXlNZXNzYWdlO1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFsbCBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IGFyZSBkaXN0aW5jdCBieSBjb21wYXJpc29uIGZyb20gdGhlIHByZXZpb3VzIGl0ZW0uXG4gKlxuICogSWYgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGl0ZW0gdG8gdGVzdCBmb3Igd2hldGhlciBvciBub3QgdGhhdCB2YWx1ZSBzaG91bGQgYmUgZW1pdHRlZC5cbiAqXG4gKiBJZiBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLCBhbiBlcXVhbGl0eSBjaGVjayBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QSBzaW1wbGUgZXhhbXBsZSB3aXRoIG51bWJlcnM8L2NhcHRpb24+XG4gKiBPYnNlcnZhYmxlLm9mKDEsIDEsIDIsIDIsIDIsIDEsIDEsIDIsIDMsIDMsIDQpXG4gKiAgIC5kaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7IC8vIDEsIDIsIDEsIDIsIDMsIDRcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BbiBleGFtcGxlIHVzaW5nIGEgY29tcGFyZSBmdW5jdGlvbjwvY2FwdGlvbj5cbiAqIGludGVyZmFjZSBQZXJzb24ge1xuICogICAgYWdlOiBudW1iZXIsXG4gKiAgICBuYW1lOiBzdHJpbmdcbiAqIH1cbiAqXG4gKiBPYnNlcnZhYmxlLm9mPFBlcnNvbj4oXG4gKiAgICAgeyBhZ2U6IDQsIG5hbWU6ICdGb28nfSxcbiAqICAgICB7IGFnZTogNywgbmFtZTogJ0Jhcid9LFxuICogICAgIHsgYWdlOiA1LCBuYW1lOiAnRm9vJ30pXG4gKiAgICAgeyBhZ2U6IDYsIG5hbWU6ICdGb28nfSlcbiAqICAgICAuZGlzdGluY3RVbnRpbENoYW5nZWQoKHA6IFBlcnNvbiwgcTogUGVyc29uKSA9PiBwLm5hbWUgPT09IHEubmFtZSlcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIGRpc3BsYXlzOlxuICogLy8geyBhZ2U6IDQsIG5hbWU6ICdGb28nIH1cbiAqIC8vIHsgYWdlOiA3LCBuYW1lOiAnQmFyJyB9XG4gKiAvLyB7IGFnZTogNSwgbmFtZTogJ0ZvbycgfVxuICpcbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0fVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbEtleUNoYW5nZWR9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NvbXBhcmVdIE9wdGlvbmFsIGNvbXBhcmlzb24gZnVuY3Rpb24gY2FsbGVkIHRvIHRlc3QgaWYgYW4gaXRlbSBpcyBkaXN0aW5jdCBmcm9tIHRoZSBwcmV2aW91cyBpdGVtIGluIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCBkaXN0aW5jdCB2YWx1ZXMuXG4gKiBAbWV0aG9kIGRpc3RpbmN0VW50aWxDaGFuZ2VkXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkaXN0aW5jdFVudGlsQ2hhbmdlZChjb21wYXJlLCBrZXlTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERpc3RpbmN0VW50aWxDaGFuZ2VkT3BlcmF0b3IoY29tcGFyZSwga2V5U2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuZGlzdGluY3RVbnRpbENoYW5nZWQgPSBkaXN0aW5jdFVudGlsQ2hhbmdlZDtcbnZhciBEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yKGNvbXBhcmUsIGtleVNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIHRoaXMua2V5U2VsZWN0b3IgPSBrZXlTZWxlY3RvcjtcbiAgICB9XG4gICAgRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNvbXBhcmUsIHRoaXMua2V5U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY29tcGFyZSwga2V5U2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmtleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaGFzS2V5ID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5jb21wYXJlID0gY29tcGFyZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4geCA9PT0geTtcbiAgICB9O1xuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGtleVNlbGVjdG9yID0gdGhpcy5rZXlTZWxlY3RvcjtcbiAgICAgICAgdmFyIGtleSA9IHZhbHVlO1xuICAgICAgICBpZiAoa2V5U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGtleSA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godGhpcy5rZXlTZWxlY3RvcikodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5oYXNLZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godGhpcy5jb21wYXJlKSh0aGlzLmtleSwga2V5KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNLZXkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCb29sZWFuKHJlc3VsdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXN0aW5jdFVudGlsQ2hhbmdlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBkaXN0aW5jdFVudGlsQ2hhbmdlZF8xID0gcmVxdWlyZSgnLi9kaXN0aW5jdFVudGlsQ2hhbmdlZCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYWxsIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgYXJlIGRpc3RpbmN0IGJ5IGNvbXBhcmlzb24gZnJvbSB0aGUgcHJldmlvdXMgaXRlbSxcbiAqIHVzaW5nIGEgcHJvcGVydHkgYWNjZXNzZWQgYnkgdXNpbmcgdGhlIGtleSBwcm92aWRlZCB0byBjaGVjayBpZiB0aGUgdHdvIGl0ZW1zIGFyZSBkaXN0aW5jdC5cbiAqXG4gKiBJZiBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHRoZW4gaXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggaXRlbSB0byB0ZXN0IGZvciB3aGV0aGVyIG9yIG5vdCB0aGF0IHZhbHVlIHNob3VsZCBiZSBlbWl0dGVkLlxuICpcbiAqIElmIGEgY29tcGFyYXRvciBmdW5jdGlvbiBpcyBub3QgcHJvdmlkZWQsIGFuIGVxdWFsaXR5IGNoZWNrIGlzIHVzZWQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BbiBleGFtcGxlIGNvbXBhcmluZyB0aGUgbmFtZSBvZiBwZXJzb25zPC9jYXB0aW9uPlxuICpcbiAqICBpbnRlcmZhY2UgUGVyc29uIHtcbiAqICAgICBhZ2U6IG51bWJlcixcbiAqICAgICBuYW1lOiBzdHJpbmdcbiAqICB9XG4gKlxuICogT2JzZXJ2YWJsZS5vZjxQZXJzb24+KFxuICogICAgIHsgYWdlOiA0LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgeyBhZ2U6IDcsIG5hbWU6ICdCYXInfSxcbiAqICAgICB7IGFnZTogNSwgbmFtZTogJ0Zvbyd9LFxuICogICAgIHsgYWdlOiA2LCBuYW1lOiAnRm9vJ30pXG4gKiAgICAgLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKCduYW1lJylcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIGRpc3BsYXlzOlxuICogLy8geyBhZ2U6IDQsIG5hbWU6ICdGb28nIH1cbiAqIC8vIHsgYWdlOiA3LCBuYW1lOiAnQmFyJyB9XG4gKiAvLyB7IGFnZTogNSwgbmFtZTogJ0ZvbycgfVxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkFuIGV4YW1wbGUgY29tcGFyaW5nIHRoZSBmaXJzdCBsZXR0ZXJzIG9mIHRoZSBuYW1lPC9jYXB0aW9uPlxuICpcbiAqIGludGVyZmFjZSBQZXJzb24ge1xuICogICAgIGFnZTogbnVtYmVyLFxuICogICAgIG5hbWU6IHN0cmluZ1xuICogIH1cbiAqXG4gKiBPYnNlcnZhYmxlLm9mPFBlcnNvbj4oXG4gKiAgICAgeyBhZ2U6IDQsIG5hbWU6ICdGb28xJ30sXG4gKiAgICAgeyBhZ2U6IDcsIG5hbWU6ICdCYXInfSxcbiAqICAgICB7IGFnZTogNSwgbmFtZTogJ0ZvbzInfSxcbiAqICAgICB7IGFnZTogNiwgbmFtZTogJ0ZvbzMnfSlcbiAqICAgICAuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQoJ25hbWUnLCAoeDogc3RyaW5nLCB5OiBzdHJpbmcpID0+IHguc3Vic3RyaW5nKDAsIDMpID09PSB5LnN1YnN0cmluZygwLCAzKSlcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIGRpc3BsYXlzOlxuICogLy8geyBhZ2U6IDQsIG5hbWU6ICdGb28xJyB9XG4gKiAvLyB7IGFnZTogNywgbmFtZTogJ0JhcicgfVxuICogLy8geyBhZ2U6IDUsIG5hbWU6ICdGb28yJyB9XG4gKlxuICogQHNlZSB7QGxpbmsgZGlzdGluY3R9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsQ2hhbmdlZH1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFN0cmluZyBrZXkgZm9yIG9iamVjdCBwcm9wZXJ0eSBsb29rdXAgb24gZWFjaCBpdGVtLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NvbXBhcmVdIE9wdGlvbmFsIGNvbXBhcmlzb24gZnVuY3Rpb24gY2FsbGVkIHRvIHRlc3QgaWYgYW4gaXRlbSBpcyBkaXN0aW5jdCBmcm9tIHRoZSBwcmV2aW91cyBpdGVtIGluIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCBkaXN0aW5jdCB2YWx1ZXMgYmFzZWQgb24gdGhlIGtleSBzcGVjaWZpZWQuXG4gKiBAbWV0aG9kIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZChrZXksIGNvbXBhcmUpIHtcbiAgICByZXR1cm4gZGlzdGluY3RVbnRpbENoYW5nZWRfMS5kaXN0aW5jdFVudGlsQ2hhbmdlZC5jYWxsKHRoaXMsIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmIChjb21wYXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZSh4W2tleV0sIHlba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhba2V5XSA9PT0geVtrZXldO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCA9IGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGluY3RVbnRpbEtleUNoYW5nZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQZXJmb3JtIGEgc2lkZSBlZmZlY3QgZm9yIGV2ZXJ5IGVtaXNzaW9uIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IHJldHVyblxuICogYW4gT2JzZXJ2YWJsZSB0aGF0IGlzIGlkZW50aWNhbCB0byB0aGUgc291cmNlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JbnRlcmNlcHRzIGVhY2ggZW1pc3Npb24gb24gdGhlIHNvdXJjZSBhbmQgcnVucyBhXG4gKiBmdW5jdGlvbiwgYnV0IHJldHVybnMgYW4gb3V0cHV0IHdoaWNoIGlzIGlkZW50aWNhbCB0byB0aGUgc291cmNlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYSBtaXJyb3JlZCBPYnNlcnZhYmxlIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IG1vZGlmaWVkIHNvIHRoYXRcbiAqIHRoZSBwcm92aWRlZCBPYnNlcnZlciBpcyBjYWxsZWQgdG8gcGVyZm9ybSBhIHNpZGUgZWZmZWN0IGZvciBldmVyeSB2YWx1ZSxcbiAqIGVycm9yLCBhbmQgY29tcGxldGlvbiBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UuIEFueSBlcnJvcnMgdGhhdCBhcmUgdGhyb3duIGluXG4gKiB0aGUgYWZvcmVtZW50aW9uZWQgT2JzZXJ2ZXIgb3IgaGFuZGxlcnMgYXJlIHNhZmVseSBzZW50IGRvd24gdGhlIGVycm9yIHBhdGhcbiAqIG9mIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBUaGlzIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nIHlvdXIgT2JzZXJ2YWJsZXMgZm9yIHRoZSBjb3JyZWN0IHZhbHVlc1xuICogb3IgcGVyZm9ybWluZyBvdGhlciBzaWRlIGVmZmVjdHMuXG4gKlxuICogTm90ZTogdGhpcyBpcyBkaWZmZXJlbnQgdG8gYSBgc3Vic2NyaWJlYCBvbiB0aGUgT2JzZXJ2YWJsZS4gSWYgdGhlIE9ic2VydmFibGVcbiAqIHJldHVybmVkIGJ5IGBkb2AgaXMgbm90IHN1YnNjcmliZWQsIHRoZSBzaWRlIGVmZmVjdHMgc3BlY2lmaWVkIGJ5IHRoZVxuICogT2JzZXJ2ZXIgd2lsbCBuZXZlciBoYXBwZW4uIGBkb2AgdGhlcmVmb3JlIHNpbXBseSBzcGllcyBvbiBleGlzdGluZ1xuICogZXhlY3V0aW9uLCBpdCBkb2VzIG5vdCB0cmlnZ2VyIGFuIGV4ZWN1dGlvbiB0byBoYXBwZW4gbGlrZSBgc3Vic2NyaWJlYCBkb2VzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBldmVyeSBldmVyeSBjbGljayB0byB0aGUgY2xpZW50WCBwb3NpdGlvbiBvZiB0aGF0IGNsaWNrLCB3aGlsZSBhbHNvIGxvZ2dpbmcgdGhlIGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwb3NpdGlvbnMgPSBjbGlja3NcbiAqICAgLmRvKGV2ID0+IGNvbnNvbGUubG9nKGV2KSlcbiAqICAgLm1hcChldiA9PiBldi5jbGllbnRYKTtcbiAqIHBvc2l0aW9ucy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwfVxuICogQHNlZSB7QGxpbmsgc3Vic2NyaWJlfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb259IFtuZXh0T3JPYnNlcnZlcl0gQSBub3JtYWwgT2JzZXJ2ZXIgb2JqZWN0IG9yIGFcbiAqIGNhbGxiYWNrIGZvciBgbmV4dGAuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIGZvciBlcnJvcnMgaW4gdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjb21wbGV0ZV0gQ2FsbGJhY2sgZm9yIHRoZSBjb21wbGV0aW9uIG9mIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIGlkZW50aWNhbCB0byB0aGUgc291cmNlLCBidXQgcnVucyB0aGVcbiAqIHNwZWNpZmllZCBPYnNlcnZlciBvciBjYWxsYmFjayhzKSBmb3IgZWFjaCBpdGVtLlxuICogQG1ldGhvZCBkb1xuICogQG5hbWUgZG9cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9kbyhuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRG9PcGVyYXRvcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSk7XG59XG5leHBvcnRzLl9kbyA9IF9kbztcbnZhciBEb09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb09wZXJhdG9yKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5uZXh0T3JPYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICB9XG4gICAgRG9PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERvU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5leHRPck9ic2VydmVyLCB0aGlzLmVycm9yLCB0aGlzLmNvbXBsZXRlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRG9PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERvU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb1N1YnNjcmliZXIoZGVzdGluYXRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKHNhZmVTdWJzY3JpYmVyKTtcbiAgICAgICAgdGhpcy5zYWZlU3Vic2NyaWJlciA9IHNhZmVTdWJzY3JpYmVyO1xuICAgIH1cbiAgICBEb1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IHRoaXMuc2FmZVN1YnNjcmliZXI7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IHRoaXMuc2FmZVN1YnNjcmliZXI7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIGlmIChzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3Ioc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRG9TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBGaWx0ZXIgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgb25seSBlbWl0dGluZyB0aG9zZSB0aGF0XG4gKiBzYXRpc2Z5IGEgc3BlY2lmaWVkIHByZWRpY2F0ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGlrZVxuICogW0FycmF5LnByb3RvdHlwZS5maWx0ZXIoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmlsdGVyKSxcbiAqIGl0IG9ubHkgZW1pdHMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgaWYgaXQgcGFzc2VzIGEgY3JpdGVyaW9uIGZ1bmN0aW9uLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2ZpbHRlci5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBTaW1pbGFyIHRvIHRoZSB3ZWxsLWtub3duIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2QsIHRoaXMgb3BlcmF0b3JcbiAqIHRha2VzIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcGFzc2VzIHRoZW0gdGhyb3VnaCBhIGBwcmVkaWNhdGVgXG4gKiBmdW5jdGlvbiBhbmQgb25seSBlbWl0cyB0aG9zZSB2YWx1ZXMgdGhhdCB5aWVsZGVkIGB0cnVlYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IG9ubHkgY2xpY2sgZXZlbnRzIHdob3NlIHRhcmdldCB3YXMgYSBESVYgZWxlbWVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgY2xpY2tzT25EaXZzID0gY2xpY2tzLmZpbHRlcihldiA9PiBldi50YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpO1xuICogY2xpY2tzT25EaXZzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxDaGFuZ2VkfVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbEtleUNoYW5nZWR9XG4gKiBAc2VlIHtAbGluayBpZ25vcmVFbGVtZW50c31cbiAqIEBzZWUge0BsaW5rIHBhcnRpdGlvbn1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW59IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRoYXRcbiAqIGV2YWx1YXRlcyBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBpdCByZXR1cm5zIGB0cnVlYCxcbiAqIHRoZSB2YWx1ZSBpcyBlbWl0dGVkLCBpZiBgZmFsc2VgIHRoZSB2YWx1ZSBpcyBub3QgcGFzc2VkIHRvIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuIFRoZSBgaW5kZXhgIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggc291cmNlXG4gKiBlbWlzc2lvbiB0aGF0IGhhcyBoYXBwZW5lZCBzaW5jZSB0aGUgc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXJcbiAqIGAwYC5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiBgdGhpc2BcbiAqIGluIHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSB0aGF0IHdlcmVcbiAqIGFsbG93ZWQgYnkgdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBmaWx0ZXJcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBGaWx0ZXJPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcpKTtcbn1cbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xudmFyIEZpbHRlck9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWx0ZXJPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgfVxuICAgIEZpbHRlck9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmlsdGVyU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy50aGlzQXJnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBGaWx0ZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmlsdGVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaWx0ZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgIH1cbiAgICAvLyB0aGUgdHJ5IGNhdGNoIGJsb2NrIGJlbG93IGlzIGxlZnQgc3BlY2lmaWNhbGx5IGZvclxuICAgIC8vIG9wdGltaXphdGlvbiBhbmQgcGVyZiByZWFzb25zLiBhIHRyeUNhdGNoZXIgaXMgbm90IG5lY2Vzc2FyeSBoZXJlLlxuICAgIEZpbHRlclN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZS5jYWxsKHRoaXMudGhpc0FyZywgdmFsdWUsIHRoaXMuY291bnQrKyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXJTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBBcHBsaWVzIGEgZ2l2ZW4gYHByb2plY3RgIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLCBhbmQgZW1pdHMgdGhlIHJlc3VsdGluZyB2YWx1ZXMgYXMgYW4gT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGlrZSBbQXJyYXkucHJvdG90eXBlLm1hcCgpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9tYXApLFxuICogaXQgcGFzc2VzIGVhY2ggc291cmNlIHZhbHVlIHRocm91Z2ggYSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiB0byBnZXRcbiAqIGNvcnJlc3BvbmRpbmcgb3V0cHV0IHZhbHVlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogU2ltaWxhciB0byB0aGUgd2VsbCBrbm93biBgQXJyYXkucHJvdG90eXBlLm1hcGAgZnVuY3Rpb24sIHRoaXMgb3BlcmF0b3JcbiAqIGFwcGxpZXMgYSBwcm9qZWN0aW9uIHRvIGVhY2ggdmFsdWUgYW5kIGVtaXRzIHRoYXQgcHJvamVjdGlvbiBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBldmVyeSBldmVyeSBjbGljayB0byB0aGUgY2xpZW50WCBwb3NpdGlvbiBvZiB0aGF0IGNsaWNrPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwb3NpdGlvbnMgPSBjbGlja3MubWFwKGV2ID0+IGV2LmNsaWVudFgpO1xuICogcG9zaXRpb25zLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtYXBUb31cbiAqIEBzZWUge0BsaW5rIHBsdWNrfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBSfSBwcm9qZWN0IFRoZSBmdW5jdGlvbiB0byBhcHBseVxuICogdG8gZWFjaCBgdmFsdWVgIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBUaGUgYGluZGV4YCBwYXJhbWV0ZXIgaXNcbiAqIHRoZSBudW1iZXIgYGlgIGZvciB0aGUgaS10aCBlbWlzc2lvbiB0aGF0IGhhcyBoYXBwZW5lZCBzaW5jZSB0aGVcbiAqIHN1YnNjcmlwdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgbnVtYmVyIGAwYC5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gZGVmaW5lIHdoYXQgYHRoaXNgIGlzIGluIHRoZVxuICogYHByb2plY3RgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIHRyYW5zZm9ybWVkIGJ5IHRoZSBnaXZlbiBgcHJvamVjdGAgZnVuY3Rpb24uXG4gKiBAbWV0aG9kIG1hcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWFwKHByb2plY3QsIHRoaXNBcmcpIHtcbiAgICBpZiAodHlwZW9mIHByb2plY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgaXMgbm90IGEgZnVuY3Rpb24uIEFyZSB5b3UgbG9va2luZyBmb3IgYG1hcFRvKClgPycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNYXBPcGVyYXRvcihwcm9qZWN0LCB0aGlzQXJnKSk7XG59XG5leHBvcnRzLm1hcCA9IG1hcDtcbnZhciBNYXBPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwT3BlcmF0b3IocHJvamVjdCwgdGhpc0FyZykge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgIH1cbiAgICBNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1hcFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcm9qZWN0LCB0aGlzLnRoaXNBcmcpKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk1hcE9wZXJhdG9yID0gTWFwT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHRoaXNBcmcpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZyB8fCB0aGlzO1xuICAgIH1cbiAgICAvLyBOT1RFOiBUaGlzIGxvb2tzIHVub3B0aW1pemVkLCBidXQgaXQncyBhY3R1YWxseSBwdXJwb3NlZnVsbHkgTk9UXG4gICAgLy8gdXNpbmcgdHJ5L2NhdGNoIG9wdGltaXphdGlvbnMuXG4gICAgTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5jYWxsKHRoaXMudGhpc0FyZywgdmFsdWUsIHRoaXMuY291bnQrKyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnKTtcbnZhciBtZXJnZUFsbF8xID0gcmVxdWlyZSgnLi9tZXJnZUFsbCcpO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIG91dHB1dCBPYnNlcnZhYmxlIHdoaWNoIGNvbmN1cnJlbnRseSBlbWl0cyBhbGwgdmFsdWVzIGZyb20gZXZlcnlcbiAqIGdpdmVuIGlucHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5IGJsZW5kaW5nXG4gKiB0aGVpciB2YWx1ZXMgaW50byBvbmUgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tZXJnZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgbWVyZ2VgIHN1YnNjcmliZXMgdG8gZWFjaCBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlIChlaXRoZXIgdGhlIHNvdXJjZSBvciBhblxuICogT2JzZXJ2YWJsZSBnaXZlbiBhcyBhcmd1bWVudCksIGFuZCBzaW1wbHkgZm9yd2FyZHMgKHdpdGhvdXQgZG9pbmcgYW55XG4gKiB0cmFuc2Zvcm1hdGlvbikgYWxsIHRoZSB2YWx1ZXMgZnJvbSBhbGwgdGhlIGlucHV0IE9ic2VydmFibGVzIHRvIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvbmx5IGNvbXBsZXRlcyBvbmNlIGFsbCBpbnB1dCBPYnNlcnZhYmxlc1xuICogaGF2ZSBjb21wbGV0ZWQuIEFueSBlcnJvciBkZWxpdmVyZWQgYnkgYW4gaW5wdXQgT2JzZXJ2YWJsZSB3aWxsIGJlIGltbWVkaWF0ZWx5XG4gKiBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NZXJnZSB0b2dldGhlciB0d28gT2JzZXJ2YWJsZXM6IDFzIGludGVydmFsIGFuZCBjbGlja3M8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBjbGlja3NPclRpbWVyID0gY2xpY2tzLm1lcmdlKHRpbWVyKTtcbiAqIGNsaWNrc09yVGltZXIuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1lcmdlIHRvZ2V0aGVyIDMgT2JzZXJ2YWJsZXMsIGJ1dCBvbmx5IDIgcnVuIGNvbmN1cnJlbnRseTwvY2FwdGlvbj5cbiAqIHZhciB0aW1lcjEgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApO1xuICogdmFyIHRpbWVyMiA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkudGFrZSg2KTtcbiAqIHZhciB0aW1lcjMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkudGFrZSgxMCk7XG4gKiB2YXIgY29uY3VycmVudCA9IDI7IC8vIHRoZSBhcmd1bWVudFxuICogdmFyIG1lcmdlZCA9IHRpbWVyMS5tZXJnZSh0aW1lcjIsIHRpbWVyMywgY29uY3VycmVudCk7XG4gKiBtZXJnZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1lcmdlQWxsfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIG1lcmdlIHdpdGggdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbnB1dFxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBUaGUgSVNjaGVkdWxlciB0byB1c2UgZm9yIG1hbmFnaW5nXG4gKiBjb25jdXJyZW5jeSBvZiBpbnB1dCBPYnNlcnZhYmxlcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyB0aGF0IGFyZSB0aGUgcmVzdWx0IG9mXG4gKiBldmVyeSBpbnB1dCBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBtZXJnZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQuY2FsbChtZXJnZVN0YXRpYy5hcHBseSh2b2lkIDAsIFt0aGlzXS5jb25jYXQob2JzZXJ2YWJsZXMpKSk7XG59XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIG91dHB1dCBPYnNlcnZhYmxlIHdoaWNoIGNvbmN1cnJlbnRseSBlbWl0cyBhbGwgdmFsdWVzIGZyb20gZXZlcnlcbiAqIGdpdmVuIGlucHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5IGJsZW5kaW5nXG4gKiB0aGVpciB2YWx1ZXMgaW50byBvbmUgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tZXJnZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgbWVyZ2VgIHN1YnNjcmliZXMgdG8gZWFjaCBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlIChhcyBhcmd1bWVudHMpLCBhbmQgc2ltcGx5XG4gKiBmb3J3YXJkcyAod2l0aG91dCBkb2luZyBhbnkgdHJhbnNmb3JtYXRpb24pIGFsbCB0aGUgdmFsdWVzIGZyb20gYWxsIHRoZSBpbnB1dFxuICogT2JzZXJ2YWJsZXMgdG8gdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgb25seSBjb21wbGV0ZXNcbiAqIG9uY2UgYWxsIGlucHV0IE9ic2VydmFibGVzIGhhdmUgY29tcGxldGVkLiBBbnkgZXJyb3IgZGVsaXZlcmVkIGJ5IGFuIGlucHV0XG4gKiBPYnNlcnZhYmxlIHdpbGwgYmUgaW1tZWRpYXRlbHkgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWVyZ2UgdG9nZXRoZXIgdHdvIE9ic2VydmFibGVzOiAxcyBpbnRlcnZhbCBhbmQgY2xpY2tzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgY2xpY2tzT3JUaW1lciA9IFJ4Lk9ic2VydmFibGUubWVyZ2UoY2xpY2tzLCB0aW1lcik7XG4gKiBjbGlja3NPclRpbWVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyB0aW1lciB3aWxsIGVtaXQgYXNjZW5kaW5nIHZhbHVlcywgb25lIGV2ZXJ5IHNlY29uZCgxMDAwbXMpIHRvIGNvbnNvbGVcbiAqIC8vIGNsaWNrcyBsb2dzIE1vdXNlRXZlbnRzIHRvIGNvbnNvbGUgZXZlcnl0aW1lIHRoZSBcImRvY3VtZW50XCIgaXMgY2xpY2tlZFxuICogLy8gU2luY2UgdGhlIHR3byBzdHJlYW1zIGFyZSBtZXJnZWQgeW91IHNlZSB0aGVzZSBoYXBwZW5pbmdcbiAqIC8vIGFzIHRoZXkgb2NjdXIuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWVyZ2UgdG9nZXRoZXIgMyBPYnNlcnZhYmxlcywgYnV0IG9ubHkgMiBydW4gY29uY3VycmVudGx5PC9jYXB0aW9uPlxuICogdmFyIHRpbWVyMSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCk7XG4gKiB2YXIgdGltZXIyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKS50YWtlKDYpO1xuICogdmFyIHRpbWVyMyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKS50YWtlKDEwKTtcbiAqIHZhciBjb25jdXJyZW50ID0gMjsgLy8gdGhlIGFyZ3VtZW50XG4gKiB2YXIgbWVyZ2VkID0gUnguT2JzZXJ2YWJsZS5tZXJnZSh0aW1lcjEsIHRpbWVyMiwgdGltZXIzLCBjb25jdXJyZW50KTtcbiAqIG1lcmdlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gLSBGaXJzdCB0aW1lcjEgYW5kIHRpbWVyMiB3aWxsIHJ1biBjb25jdXJyZW50bHlcbiAqIC8vIC0gdGltZXIxIHdpbGwgZW1pdCBhIHZhbHVlIGV2ZXJ5IDEwMDBtcyBmb3IgMTAgaXRlcmF0aW9uc1xuICogLy8gLSB0aW1lcjIgd2lsbCBlbWl0IGEgdmFsdWUgZXZlcnkgMjAwMG1zIGZvciA2IGl0ZXJhdGlvbnNcbiAqIC8vIC0gYWZ0ZXIgdGltZXIxIGhpdHMgaXQncyBtYXggaXRlcmF0aW9uLCB0aW1lcjIgd2lsbFxuICogLy8gICBjb250aW51ZSwgYW5kIHRpbWVyMyB3aWxsIHN0YXJ0IHRvIHJ1biBjb25jdXJyZW50bHkgd2l0aCB0aW1lcjJcbiAqIC8vIC0gd2hlbiB0aW1lcjIgaGl0cyBpdCdzIG1heCBpdGVyYXRpb24gaXQgdGVybWluYXRlcywgYW5kXG4gKiAvLyAgIHRpbWVyMyB3aWxsIGNvbnRpbnVlIHRvIGVtaXQgYSB2YWx1ZSBldmVyeSA1MDBtcyB1bnRpbCBpdCBpcyBjb21wbGV0ZVxuICpcbiAqIEBzZWUge0BsaW5rIG1lcmdlQWxsfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICpcbiAqIEBwYXJhbSB7Li4uT2JzZXJ2YWJsZUlucHV0fSBvYnNlcnZhYmxlcyBJbnB1dCBPYnNlcnZhYmxlcyB0byBtZXJnZSB0b2dldGhlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlucHV0XG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPW51bGxdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3IgbWFuYWdpbmdcbiAqIGNvbmN1cnJlbmN5IG9mIGlucHV0IE9ic2VydmFibGVzLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIHRoYXQgYXJlIHRoZSByZXN1bHQgb2ZcbiAqIGV2ZXJ5IGlucHV0IE9ic2VydmFibGUuXG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIG1lcmdlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtZXJnZVN0YXRpYygpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIHNjaGVkdWxlciA9IG51bGw7XG4gICAgdmFyIGxhc3QgPSBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihsYXN0KSkge1xuICAgICAgICBzY2hlZHVsZXIgPSBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICAgICAgaWYgKG9ic2VydmFibGVzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgY29uY3VycmVudCA9IG9ic2VydmFibGVzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsYXN0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25jdXJyZW50ID0gb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgfVxuICAgIGlmIChzY2hlZHVsZXIgPT09IG51bGwgJiYgb2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxICYmIG9ic2VydmFibGVzWzBdIGluc3RhbmNlb2YgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShvYnNlcnZhYmxlcywgc2NoZWR1bGVyKS5saWZ0KG5ldyBtZXJnZUFsbF8xLk1lcmdlQWxsT3BlcmF0b3IoY29uY3VycmVudCkpO1xufVxuZXhwb3J0cy5tZXJnZVN0YXRpYyA9IG1lcmdlU3RhdGljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIENvbnZlcnRzIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUgaW50byBhIGZpcnN0LW9yZGVyIE9ic2VydmFibGUgd2hpY2hcbiAqIGNvbmN1cnJlbnRseSBkZWxpdmVycyBhbGwgdmFsdWVzIHRoYXQgYXJlIGVtaXR0ZWQgb24gdGhlIGlubmVyIE9ic2VydmFibGVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlQWxsLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBtZXJnZUFsbGAgc3Vic2NyaWJlcyB0byBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgT2JzZXJ2YWJsZXMsIGFsc28ga25vd24gYXNcbiAqIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUuIEVhY2ggdGltZSBpdCBvYnNlcnZlcyBvbmUgb2YgdGhlc2UgZW1pdHRlZCBpbm5lclxuICogT2JzZXJ2YWJsZXMsIGl0IHN1YnNjcmliZXMgdG8gdGhhdCBhbmQgZGVsaXZlcnMgYWxsIHRoZSB2YWx1ZXMgZnJvbSB0aGVcbiAqIGlubmVyIE9ic2VydmFibGUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgb25seVxuICogY29tcGxldGVzIG9uY2UgYWxsIGlubmVyIE9ic2VydmFibGVzIGhhdmUgY29tcGxldGVkLiBBbnkgZXJyb3IgZGVsaXZlcmVkIGJ5XG4gKiBhIGlubmVyIE9ic2VydmFibGUgd2lsbCBiZSBpbW1lZGlhdGVseSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TcGF3biBhIG5ldyBpbnRlcnZhbCBPYnNlcnZhYmxlIGZvciBlYWNoIGNsaWNrIGV2ZW50LCBhbmQgYmxlbmQgdGhlaXIgb3V0cHV0cyBhcyBvbmUgT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiB2YXIgZmlyc3RPcmRlciA9IGhpZ2hlck9yZGVyLm1lcmdlQWxsKCk7XG4gKiBmaXJzdE9yZGVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db3VudCBmcm9tIDAgdG8gOSBldmVyeSBzZWNvbmQgZm9yIGVhY2ggY2xpY2ssIGJ1dCBvbmx5IGFsbG93IDIgY29uY3VycmVudCB0aW1lcnM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGhpZ2hlck9yZGVyID0gY2xpY2tzLm1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCkpO1xuICogdmFyIGZpcnN0T3JkZXIgPSBoaWdoZXJPcmRlci5tZXJnZUFsbCgyKTtcbiAqIGZpcnN0T3JkZXIuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0fVxuICogQHNlZSB7QGxpbmsgbWVyZ2V9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayB6aXBBbGx9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5uZXJcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHZhbHVlcyBjb21pbmcgZnJvbSBhbGwgdGhlXG4gKiBpbm5lciBPYnNlcnZhYmxlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgbWVyZ2VBbGxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQWxsKGNvbmN1cnJlbnQpIHtcbiAgICBpZiAoY29uY3VycmVudCA9PT0gdm9pZCAwKSB7IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNZXJnZUFsbE9wZXJhdG9yKGNvbmN1cnJlbnQpKTtcbn1cbmV4cG9ydHMubWVyZ2VBbGwgPSBtZXJnZUFsbDtcbnZhciBNZXJnZUFsbE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZUFsbE9wZXJhdG9yKGNvbmN1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICB9XG4gICAgTWVyZ2VBbGxPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChvYnNlcnZlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNZXJnZUFsbFN1YnNjcmliZXIob2JzZXJ2ZXIsIHRoaXMuY29uY3VycmVudCkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlQWxsT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NZXJnZUFsbE9wZXJhdG9yID0gTWVyZ2VBbGxPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWVyZ2VBbGxTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVyZ2VBbGxTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lcmdlQWxsU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY29uY3VycmVudCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICB9XG4gICAgTWVyZ2VBbGxTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uIChvYnNlcnZhYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA8IHRoaXMuY29uY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb2JzZXJ2YWJsZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaChvYnNlcnZhYmxlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VBbGxTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZUFsbFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmFjdGl2ZS0tO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQoYnVmZmVyLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNZXJnZUFsbFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5NZXJnZUFsbFN1YnNjcmliZXIgPSBNZXJnZUFsbFN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZUFsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIHRoZSBleGNlcHRpb24gb2YgYW4gYGVycm9yYC4gSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlXG4gKiBjYWxscyBgZXJyb3JgLCB0aGlzIG1ldGhvZCB3aWxsIGVtaXQgdGhlIFRocm93YWJsZSB0aGF0IGNhdXNlZCB0aGUgZXJyb3IgdG8gdGhlIE9ic2VydmFibGUgcmV0dXJuZWQgZnJvbSBgbm90aWZpZXJgLlxuICogSWYgdGhhdCBPYnNlcnZhYmxlIGNhbGxzIGBjb21wbGV0ZWAgb3IgYGVycm9yYCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgY2FsbCBgY29tcGxldGVgIG9yIGBlcnJvcmAgb24gdGhlIGNoaWxkXG4gKiBzdWJzY3JpcHRpb24uIE90aGVyd2lzZSB0aGlzIG1ldGhvZCB3aWxsIHJlc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3JldHJ5V2hlbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGVycm9yczogT2JzZXJ2YWJsZSk6IE9ic2VydmFibGV9IG5vdGlmaWVyIC0gUmVjZWl2ZXMgYW4gT2JzZXJ2YWJsZSBvZiBub3RpZmljYXRpb25zIHdpdGggd2hpY2ggYVxuICogdXNlciBjYW4gYGNvbXBsZXRlYCBvciBgZXJyb3JgLCBhYm9ydGluZyB0aGUgcmV0cnkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIE9ic2VydmFibGUgbW9kaWZpZWQgd2l0aCByZXRyeSBsb2dpYy5cbiAqIEBtZXRob2QgcmV0cnlXaGVuXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiByZXRyeVdoZW4obm90aWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZXRyeVdoZW5PcGVyYXRvcihub3RpZmllciwgdGhpcykpO1xufVxuZXhwb3J0cy5yZXRyeVdoZW4gPSByZXRyeVdoZW47XG52YXIgUmV0cnlXaGVuT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJldHJ5V2hlbk9wZXJhdG9yKG5vdGlmaWVyLCBzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgUmV0cnlXaGVuT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSZXRyeVdoZW5TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubm90aWZpZXIsIHRoaXMuc291cmNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gUmV0cnlXaGVuT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBSZXRyeVdoZW5TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmV0cnlXaGVuU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZXRyeVdoZW5TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBub3RpZmllciwgc291cmNlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgUmV0cnlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSB0aGlzLmVycm9ycztcbiAgICAgICAgICAgIHZhciByZXRyaWVzID0gdGhpcy5yZXRyaWVzO1xuICAgICAgICAgICAgdmFyIHJldHJpZXNTdWJzY3JpcHRpb24gPSB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgICAgICBpZiAoIXJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbiAgICAgICAgICAgICAgICByZXRyaWVzID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLm5vdGlmaWVyKShlcnJvcnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXRyaWVzID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0cmllc1N1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmV0cmllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSgpO1xuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzO1xuICAgICAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gcmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIGVycm9ycy5uZXh0KGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJldHJ5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZXJyb3JzID0gX2EuZXJyb3JzLCByZXRyaWVzU3Vic2NyaXB0aW9uID0gX2EucmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgZXJyb3JzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldHJpZXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHJpZXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXRyaWVzID0gbnVsbDtcbiAgICB9O1xuICAgIFJldHJ5V2hlblN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZXJyb3JzID0gX2EuZXJyb3JzLCByZXRyaWVzID0gX2EucmV0cmllcywgcmV0cmllc1N1YnNjcmlwdGlvbiA9IF9hLnJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXRyaWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB0aGlzLnJldHJpZXMgPSByZXRyaWVzO1xuICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSByZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnNvdXJjZS5zdWJzY3JpYmUodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gUmV0cnlXaGVuU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeVdoZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIENvbnZlcnRzIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUgaW50byBhIGZpcnN0LW9yZGVyIE9ic2VydmFibGUgYnlcbiAqIHN1YnNjcmliaW5nIHRvIG9ubHkgdGhlIG1vc3QgcmVjZW50bHkgZW1pdHRlZCBvZiB0aG9zZSBpbm5lciBPYnNlcnZhYmxlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgYW4gT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlcyBieSBkcm9wcGluZyB0aGVcbiAqIHByZXZpb3VzIGlubmVyIE9ic2VydmFibGUgb25jZSBhIG5ldyBvbmUgYXBwZWFycy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zd2l0Y2gucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHN3aXRjaGAgc3Vic2NyaWJlcyB0byBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgT2JzZXJ2YWJsZXMsIGFsc28ga25vd24gYXMgYVxuICogaGlnaGVyLW9yZGVyIE9ic2VydmFibGUuIEVhY2ggdGltZSBpdCBvYnNlcnZlcyBvbmUgb2YgdGhlc2UgZW1pdHRlZCBpbm5lclxuICogT2JzZXJ2YWJsZXMsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBzdWJzY3JpYmVzIHRvIHRoZSBpbm5lciBPYnNlcnZhYmxlIGFuZFxuICogYmVnaW5zIGVtaXR0aW5nIHRoZSBpdGVtcyBlbWl0dGVkIGJ5IHRoYXQuIFNvIGZhciwgaXQgYmVoYXZlc1xuICogbGlrZSB7QGxpbmsgbWVyZ2VBbGx9LiBIb3dldmVyLCB3aGVuIGEgbmV3IGlubmVyIE9ic2VydmFibGUgaXMgZW1pdHRlZCxcbiAqIGBzd2l0Y2hgIHVuc3Vic2NyaWJlcyBmcm9tIHRoZSBlYXJsaWVyLWVtaXR0ZWQgaW5uZXIgT2JzZXJ2YWJsZSBhbmRcbiAqIHN1YnNjcmliZXMgdG8gdGhlIG5ldyBpbm5lciBPYnNlcnZhYmxlIGFuZCBiZWdpbnMgZW1pdHRpbmcgaXRlbXMgZnJvbSBpdC4gSXRcbiAqIGNvbnRpbnVlcyB0byBiZWhhdmUgbGlrZSB0aGlzIGZvciBzdWJzZXF1ZW50IGlubmVyIE9ic2VydmFibGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJlcnVuIGFuIGludGVydmFsIE9ic2VydmFibGUgb24gZXZlcnkgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogLy8gRWFjaCBjbGljayBldmVudCBpcyBtYXBwZWQgdG8gYW4gT2JzZXJ2YWJsZSB0aGF0IHRpY2tzIGV2ZXJ5IHNlY29uZFxuICogdmFyIGhpZ2hlck9yZGVyID0gY2xpY2tzLm1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogdmFyIHN3aXRjaGVkID0gaGlnaGVyT3JkZXIuc3dpdGNoKCk7XG4gKiAvLyBUaGUgb3V0Y29tZSBpcyB0aGF0IGBzd2l0Y2hlZGAgaXMgZXNzZW50aWFsbHkgYSB0aW1lciB0aGF0IHJlc3RhcnRzXG4gKiAvLyBvbiBldmVyeSBjbGljay4gVGhlIGludGVydmFsIE9ic2VydmFibGVzIGZyb20gb2xkZXIgY2xpY2tzIGRvIG5vdCBtZXJnZVxuICogLy8gd2l0aCB0aGUgY3VycmVudCBpbnRlcnZhbCBPYnNlcnZhYmxlLlxuICogc3dpdGNoZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0fVxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqIEBzZWUge0BsaW5rIHppcEFsbH1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlXG4gKiBPYnNlcnZhYmxlIG1vc3QgcmVjZW50bHkgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN3aXRjaFxuICogQG5hbWUgc3dpdGNoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBfc3dpdGNoKCkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFN3aXRjaE9wZXJhdG9yKCkpO1xufVxuZXhwb3J0cy5fc3dpdGNoID0gX3N3aXRjaDtcbnZhciBTd2l0Y2hPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3dpdGNoT3BlcmF0b3IoKSB7XG4gICAgfVxuICAgIFN3aXRjaE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoU3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3dpdGNoT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTd2l0Y2hTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3dpdGNoU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTd2l0Y2hTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlSW5uZXIoKTtcbiAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgdGhpcy5hZGQodGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgdmFsdWUpKTtcbiAgICB9O1xuICAgIFN3aXRjaFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmVJbm5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0aGlzLmFjdGl2ZSA+IDAgPyB0aGlzLmFjdGl2ZSAtIDEgOiAwO1xuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSB0aGlzLmlubmVyU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoaW5uZXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGlubmVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1YnNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIFN3aXRjaFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlSW5uZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcGxldGVkICYmIHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIGFuIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUsIGVtaXR0aW5nIHZhbHVlcyBvbmx5IGZyb20gdGhlIG1vc3QgcmVjZW50bHkgcHJvamVjdGVkIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPk1hcHMgZWFjaCB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlLCB0aGVuIGZsYXR0ZW5zIGFsbCBvZlxuICogdGhlc2UgaW5uZXIgT2JzZXJ2YWJsZXMgdXNpbmcge0BsaW5rIHN3aXRjaH0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc3dpdGNoTWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGJhc2VkIG9uIGFwcGx5aW5nIGEgZnVuY3Rpb24gdGhhdCB5b3VcbiAqIHN1cHBseSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoZXJlIHRoYXQgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gKHNvLWNhbGxlZCBcImlubmVyXCIpIE9ic2VydmFibGUuIEVhY2ggdGltZSBpdCBvYnNlcnZlcyBvbmUgb2YgdGhlc2VcbiAqIGlubmVyIE9ic2VydmFibGVzLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmVnaW5zIGVtaXR0aW5nIHRoZSBpdGVtcyBlbWl0dGVkIGJ5XG4gKiB0aGF0IGlubmVyIE9ic2VydmFibGUuIFdoZW4gYSBuZXcgaW5uZXIgT2JzZXJ2YWJsZSBpcyBlbWl0dGVkLCBgc3dpdGNoTWFwYFxuICogc3RvcHMgZW1pdHRpbmcgaXRlbXMgZnJvbSB0aGUgZWFybGllci1lbWl0dGVkIGlubmVyIE9ic2VydmFibGUgYW5kIGJlZ2luc1xuICogZW1pdHRpbmcgaXRlbXMgZnJvbSB0aGUgbmV3IG9uZS4gSXQgY29udGludWVzIHRvIGJlaGF2ZSBsaWtlIHRoaXMgZm9yXG4gKiBzdWJzZXF1ZW50IGlubmVyIE9ic2VydmFibGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJlcnVuIGFuIGludGVydmFsIE9ic2VydmFibGUgb24gZXZlcnkgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5zd2l0Y2hNYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdE1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgc3dpdGNofVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwVG99XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgP2luZGV4OiBudW1iZXIpOiBPYnNlcnZhYmxlSW5wdXR9IHByb2plY3QgQSBmdW5jdGlvblxuICogdGhhdCwgd2hlbiBhcHBsaWVkIHRvIGFuIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHJldHVybnMgYW5cbiAqIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlXG4gKiBwcm9qZWN0aW9uIGZ1bmN0aW9uIChhbmQgdGhlIG9wdGlvbmFsIGByZXN1bHRTZWxlY3RvcmApIHRvIGVhY2ggaXRlbSBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIHRha2luZyBvbmx5IHRoZSB2YWx1ZXMgZnJvbSB0aGUgbW9zdCByZWNlbnRseVxuICogcHJvamVjdGVkIGlubmVyIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN3aXRjaE1hcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc3dpdGNoTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuc3dpdGNoTWFwID0gc3dpdGNoTWFwO1xudmFyIFN3aXRjaE1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgfVxuICAgIFN3aXRjaE1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoTWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMucmVzdWx0U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN3aXRjaE1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0KHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbm5lclN1YihyZXN1bHQsIHZhbHVlLCBpbmRleCk7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAocmVzdWx0LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBpbm5lclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCwgdmFsdWUsIGluZGV4KSk7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmICghaW5uZXJTdWJzY3JpcHRpb24gfHwgaW5uZXJTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH07XG4gICAgU3dpdGNoTWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl90cnlOb3RpZnlOZXh0KG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5Tm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hNYXBTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaE1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcicpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbi8qKlxuICogRW1pdHMgb25seSB0aGUgZmlyc3QgYGNvdW50YCB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRha2VzIHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UsIHRoZW5cbiAqIGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0YWtlYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBvbmx5IHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIHRoZSBzb3VyY2UgZW1pdHMgZmV3ZXIgdGhhbiBgY291bnRgIHZhbHVlcyB0aGVuXG4gKiBhbGwgb2YgaXRzIHZhbHVlcyBhcmUgZW1pdHRlZC4gQWZ0ZXIgdGhhdCwgaXQgY29tcGxldGVzLCByZWdhcmRsZXNzIGlmIHRoZVxuICogc291cmNlIGNvbXBsZXRlcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5UYWtlIHRoZSBmaXJzdCA1IHNlY29uZHMgb2YgYW4gaW5maW5pdGUgMS1zZWNvbmQgaW50ZXJ2YWwgT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgZml2ZSA9IGludGVydmFsLnRha2UoNSk7XG4gKiBmaXZlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqIEBzZWUge0BsaW5rIHRha2VVbnRpbH1cbiAqIEBzZWUge0BsaW5rIHRha2VXaGlsZX1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHRocm93cyB7QXJndW1lbnRPdXRPZlJhbmdlRXJyb3J9IFdoZW4gdXNpbmcgYHRha2UoaSlgLCBpdCBkZWxpdmVycyBhblxuICogQXJndW1lbnRPdXRPclJhbmdlRXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYCBjYWxsYmFjayBpZiBgaSA8IDBgLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgYG5leHRgIHZhbHVlcyB0byBlbWl0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGZpcnN0IGBjb3VudGBcbiAqIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgb3IgYWxsIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBpZiB0aGUgc291cmNlIGVtaXRzIGZld2VyIHRoYW4gYGNvdW50YCB2YWx1ZXMuXG4gKiBAbWV0aG9kIHRha2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRha2UoY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRha2VPcGVyYXRvcihjb3VudCkpO1xuICAgIH1cbn1cbmV4cG9ydHMudGFrZSA9IHRha2U7XG52YXIgVGFrZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlT3BlcmF0b3IodG90YWwpIHtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICBpZiAodGhpcy50b3RhbCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcl8xLkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRha2VPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMudG90YWwpKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUYWtlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRha2VTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRha2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0b3RhbCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMudG90YWwgPSB0b3RhbDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgfVxuICAgIFRha2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdG90YWwgPSB0aGlzLnRvdGFsO1xuICAgICAgICB2YXIgY291bnQgPSArK3RoaXMuY291bnQ7XG4gICAgICAgIGlmIChjb3VudCA8PSB0b3RhbCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gdG90YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBFbWl0cyB0aGUgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHVudGlsIGEgYG5vdGlmaWVyYFxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MZXRzIHZhbHVlcyBwYXNzIHVudGlsIGEgc2Vjb25kIE9ic2VydmFibGUsXG4gKiBgbm90aWZpZXJgLCBlbWl0cyBzb21ldGhpbmcuIFRoZW4sIGl0IGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlVW50aWwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRha2VVbnRpbGAgc3Vic2NyaWJlcyBhbmQgYmVnaW5zIG1pcnJvcmluZyB0aGUgc291cmNlIE9ic2VydmFibGUuIEl0IGFsc29cbiAqIG1vbml0b3JzIGEgc2Vjb25kIE9ic2VydmFibGUsIGBub3RpZmllcmAgdGhhdCB5b3UgcHJvdmlkZS4gSWYgdGhlIGBub3RpZmllcmBcbiAqIGVtaXRzIGEgdmFsdWUgb3IgYSBjb21wbGV0ZSBub3RpZmljYXRpb24sIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBzdG9wc1xuICogbWlycm9yaW5nIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgY29tcGxldGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRpY2sgZXZlcnkgc2Vjb25kIHVudGlsIHRoZSBmaXJzdCBjbGljayBoYXBwZW5zPC9jYXB0aW9uPlxuICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gaW50ZXJ2YWwudGFrZVVudGlsKGNsaWNrcyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqIEBzZWUge0BsaW5rIHRha2VXaGlsZX1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBub3RpZmllciBUaGUgT2JzZXJ2YWJsZSB3aG9zZSBmaXJzdCBlbWl0dGVkIHZhbHVlIHdpbGxcbiAqIGNhdXNlIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvZiBgdGFrZVVudGlsYCB0byBzdG9wIGVtaXR0aW5nIHZhbHVlcyBmcm9tIHRoZVxuICogc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgdW50aWwgc3VjaCB0aW1lIGFzIGBub3RpZmllcmAgZW1pdHMgaXRzIGZpcnN0IHZhbHVlLlxuICogQG1ldGhvZCB0YWtlVW50aWxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRha2VVbnRpbChub3RpZmllcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRha2VVbnRpbE9wZXJhdG9yKG5vdGlmaWVyKSk7XG59XG5leHBvcnRzLnRha2VVbnRpbCA9IHRha2VVbnRpbDtcbnZhciBUYWtlVW50aWxPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFrZVVudGlsT3BlcmF0b3Iobm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgIH1cbiAgICBUYWtlVW50aWxPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VVbnRpbFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5ub3RpZmllcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VVbnRpbE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGFrZVVudGlsU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRha2VVbnRpbFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFrZVVudGlsU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgbm90aWZpZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgbm90aWZpZXIpKTtcbiAgICB9XG4gICAgVGFrZVVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBUYWtlVW50aWxTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH07XG4gICAgcmV0dXJuIFRha2VVbnRpbFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZVVudGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbi8qKlxuICogRW1pdHMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgdGhlbiBpZ25vcmVzIHN1YnNlcXVlbnQgc291cmNlXG4gKiB2YWx1ZXMgZm9yIGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzLCB0aGVuIHJlcGVhdHMgdGhpcyBwcm9jZXNzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MZXRzIGEgdmFsdWUgcGFzcywgdGhlbiBpZ25vcmVzIHNvdXJjZSB2YWx1ZXMgZm9yIHRoZVxuICogbmV4dCBgZHVyYXRpb25gIG1pbGxpc2Vjb25kcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90aHJvdHRsZVRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRocm90dGxlVGltZWAgZW1pdHMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIHdoZW4gaXRzIGludGVybmFsIHRpbWVyIGlzIGRpc2FibGVkLCBhbmQgaWdub3JlcyBzb3VyY2UgdmFsdWVzIHdoZW4gdGhlIHRpbWVyXG4gKiBpcyBlbmFibGVkLiBJbml0aWFsbHksIHRoZSB0aW1lciBpcyBkaXNhYmxlZC4gQXMgc29vbiBhcyB0aGUgZmlyc3Qgc291cmNlXG4gKiB2YWx1ZSBhcnJpdmVzLCBpdCBpcyBmb3J3YXJkZWQgdG8gdGhlIG91dHB1dCBPYnNlcnZhYmxlLCBhbmQgdGhlbiB0aGUgdGltZXJcbiAqIGlzIGVuYWJsZWQuIEFmdGVyIGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzIChvciB0aGUgdGltZSB1bml0IGRldGVybWluZWRcbiAqIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgKSBoYXMgcGFzc2VkLCB0aGUgdGltZXIgaXMgZGlzYWJsZWQsXG4gKiBhbmQgdGhpcyBwcm9jZXNzIHJlcGVhdHMgZm9yIHRoZSBuZXh0IHNvdXJjZSB2YWx1ZS4gT3B0aW9uYWxseSB0YWtlcyBhXG4gKiB7QGxpbmsgSVNjaGVkdWxlcn0gZm9yIG1hbmFnaW5nIHRpbWVycy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IGNsaWNrcyBhdCBhIHJhdGUgb2YgYXQgbW9zdCBvbmUgY2xpY2sgcGVyIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnRocm90dGxlVGltZSgxMDAwKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXRUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2VUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGV9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIFRpbWUgdG8gd2FpdCBiZWZvcmUgZW1pdHRpbmcgYW5vdGhlciB2YWx1ZSBhZnRlclxuICogZW1pdHRpbmcgdGhlIGxhc3QgdmFsdWUsIG1lYXN1cmVkIGluIG1pbGxpc2Vjb25kcyBvciB0aGUgdGltZSB1bml0IGRldGVybWluZWRcbiAqIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgc2FtcGxpbmcuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgcGVyZm9ybXMgdGhlIHRocm90dGxlIG9wZXJhdGlvbiB0b1xuICogbGltaXQgdGhlIHJhdGUgb2YgZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZS5cbiAqIEBtZXRob2QgdGhyb3R0bGVUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB0aHJvdHRsZVRpbWUoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGhyb3R0bGVUaW1lT3BlcmF0b3IoZHVyYXRpb24sIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy50aHJvdHRsZVRpbWUgPSB0aHJvdHRsZVRpbWU7XG52YXIgVGhyb3R0bGVUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRocm90dGxlVGltZU9wZXJhdG9yKGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgVGhyb3R0bGVUaW1lT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVyYXRpb24sIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3R0bGVUaW1lT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhyb3R0bGVUaW1lU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgVGhyb3R0bGVUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRocm90dGxlZCkge1xuICAgICAgICAgICAgdGhpcy5hZGQodGhpcy50aHJvdHRsZWQgPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIHRoaXMuZHVyYXRpb24sIHsgc3Vic2NyaWJlcjogdGhpcyB9KSk7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbGVhclRocm90dGxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGhyb3R0bGVkID0gdGhpcy50aHJvdHRsZWQ7XG4gICAgICAgIGlmICh0aHJvdHRsZWQpIHtcbiAgICAgICAgICAgIHRocm90dGxlZC51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhyb3R0bGVkKTtcbiAgICAgICAgICAgIHRoaXMudGhyb3R0bGVkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRocm90dGxlVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaE5leHQoYXJnKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlcjtcbiAgICBzdWJzY3JpYmVyLmNsZWFyVGhyb3R0bGUoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRocm90dGxlVGltZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENvbWJpbmVzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIG90aGVyIE9ic2VydmFibGVzIHRvIGNyZWF0ZSBhbiBPYnNlcnZhYmxlXG4gKiB3aG9zZSB2YWx1ZXMgYXJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgbGF0ZXN0IHZhbHVlcyBvZiBlYWNoLCBvbmx5IHdoZW4gdGhlXG4gKiBzb3VyY2UgZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPldoZW5ldmVyIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLCBpdFxuICogY29tcHV0ZXMgYSBmb3JtdWxhIHVzaW5nIHRoYXQgdmFsdWUgcGx1cyB0aGUgbGF0ZXN0IHZhbHVlcyBmcm9tIG90aGVyIGlucHV0XG4gKiBPYnNlcnZhYmxlcywgdGhlbiBlbWl0cyB0aGUgb3V0cHV0IG9mIHRoYXQgZm9ybXVsYS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy93aXRoTGF0ZXN0RnJvbS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgd2l0aExhdGVzdEZyb21gIGNvbWJpbmVzIGVhY2ggdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgKHRoZVxuICogaW5zdGFuY2UpIHdpdGggdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSB0aGUgb3RoZXIgaW5wdXQgT2JzZXJ2YWJsZXMgb25seSB3aGVuXG4gKiB0aGUgc291cmNlIGVtaXRzIGEgdmFsdWUsIG9wdGlvbmFsbHkgdXNpbmcgYSBgcHJvamVjdGAgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lXG4gKiB0aGUgdmFsdWUgdG8gYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuIEFsbCBpbnB1dCBPYnNlcnZhYmxlcyBtdXN0XG4gKiBlbWl0IGF0IGxlYXN0IG9uZSB2YWx1ZSBiZWZvcmUgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHdpbGwgZW1pdCBhIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk9uIGV2ZXJ5IGNsaWNrIGV2ZW50LCBlbWl0IGFuIGFycmF5IHdpdGggdGhlIGxhdGVzdCB0aW1lciBldmVudCBwbHVzIHRoZSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy53aXRoTGF0ZXN0RnJvbSh0aW1lcik7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVMYXRlc3R9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IG90aGVyIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29tYmluZSB3aXRoIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Byb2plY3RdIFByb2plY3Rpb24gZnVuY3Rpb24gZm9yIGNvbWJpbmluZyB2YWx1ZXNcbiAqIHRvZ2V0aGVyLiBSZWNlaXZlcyBhbGwgdmFsdWVzIGluIG9yZGVyIG9mIHRoZSBPYnNlcnZhYmxlcyBwYXNzZWQsIHdoZXJlIHRoZVxuICogZmlyc3QgcGFyYW1ldGVyIGlzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuIChlLmcuXG4gKiBgYS53aXRoTGF0ZXN0RnJvbShiLCBjLCAoYTEsIGIxLCBjMSkgPT4gYTEgKyBiMSArIGMxKWApLiBJZiB0aGlzIGlzIG5vdFxuICogcGFzc2VkLCBhcnJheXMgd2lsbCBiZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgcHJvamVjdGVkIHZhbHVlcyBmcm9tIHRoZSBtb3N0IHJlY2VudFxuICogdmFsdWVzIGZyb20gZWFjaCBpbnB1dCBPYnNlcnZhYmxlLCBvciBhbiBhcnJheSBvZiB0aGUgbW9zdCByZWNlbnQgdmFsdWVzIGZyb21cbiAqIGVhY2ggaW5wdXQgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgd2l0aExhdGVzdEZyb21cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHdpdGhMYXRlc3RGcm9tKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHByb2plY3Q7XG4gICAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvamVjdCA9IGFyZ3MucG9wKCk7XG4gICAgfVxuICAgIHZhciBvYnNlcnZhYmxlcyA9IGFyZ3M7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgV2l0aExhdGVzdEZyb21PcGVyYXRvcihvYnNlcnZhYmxlcywgcHJvamVjdCkpO1xufVxuZXhwb3J0cy53aXRoTGF0ZXN0RnJvbSA9IHdpdGhMYXRlc3RGcm9tO1xudmFyIFdpdGhMYXRlc3RGcm9tT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFdpdGhMYXRlc3RGcm9tT3BlcmF0b3Iob2JzZXJ2YWJsZXMsIHByb2plY3QpIHtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcyA9IG9ic2VydmFibGVzO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgIH1cbiAgICBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMub2JzZXJ2YWJsZXMsIHRoaXMucHJvamVjdCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFdpdGhMYXRlc3RGcm9tT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBvYnNlcnZhYmxlcywgcHJvamVjdCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlcztcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy50b1Jlc3BvbmQgPSBbXTtcbiAgICAgICAgdmFyIGxlbiA9IG9ic2VydmFibGVzLmxlbmd0aDtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy50b1Jlc3BvbmQucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG9ic2VydmFibGVzW2ldO1xuICAgICAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBvYnNlcnZhYmxlLCBvYnNlcnZhYmxlLCBpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMudmFsdWVzW291dGVySW5kZXhdID0gaW5uZXJWYWx1ZTtcbiAgICAgICAgdmFyIHRvUmVzcG9uZCA9IHRoaXMudG9SZXNwb25kO1xuICAgICAgICBpZiAodG9SZXNwb25kLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IHRvUmVzcG9uZC5pbmRleE9mKG91dGVySW5kZXgpO1xuICAgICAgICAgICAgaWYgKGZvdW5kICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRvUmVzcG9uZC5zcGxpY2UoZm91bmQsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfTtcbiAgICBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnRvUmVzcG9uZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW3ZhbHVlXS5jb25jYXQodGhpcy52YWx1ZXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyeVByb2plY3QoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeVByb2plY3QgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2l0aExhdGVzdEZyb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL2l0ZXJhdG9yJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBAcGFyYW0gb2JzZXJ2YWJsZXNcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59XG4gKiBAbWV0aG9kIHppcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gemlwUHJvdG8oKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQuY2FsbCh6aXBTdGF0aWMuYXBwbHkodm9pZCAwLCBbdGhpc10uY29uY2F0KG9ic2VydmFibGVzKSkpO1xufVxuZXhwb3J0cy56aXBQcm90byA9IHppcFByb3RvO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ29tYmluZXMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG8gY3JlYXRlIGFuIE9ic2VydmFibGUgd2hvc2UgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGZyb20gdGhlIHZhbHVlcywgaW4gb3JkZXIsIG9mIGVhY2hcbiAqIG9mIGl0cyBpbnB1dCBPYnNlcnZhYmxlcy5cbiAqXG4gKiBJZiB0aGUgbGF0ZXN0IHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uLCB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGUgY3JlYXRlZCB2YWx1ZSBmcm9tIHRoZSBpbnB1dCB2YWx1ZXMuXG4gKiBPdGhlcndpc2UsIGFuIGFycmF5IG9mIHRoZSBpbnB1dCB2YWx1ZXMgaXMgcmV0dXJuZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29tYmluZSBhZ2UgYW5kIG5hbWUgZnJvbSBkaWZmZXJlbnQgc291cmNlczwvY2FwdGlvbj5cbiAqXG4gKiBsZXQgYWdlJCA9IE9ic2VydmFibGUub2Y8bnVtYmVyPigyNywgMjUsIDI5KTtcbiAqIGxldCBuYW1lJCA9IE9ic2VydmFibGUub2Y8c3RyaW5nPignRm9vJywgJ0JhcicsICdCZWVyJyk7XG4gKiBsZXQgaXNEZXYkID0gT2JzZXJ2YWJsZS5vZjxib29sZWFuPih0cnVlLCB0cnVlLCBmYWxzZSk7XG4gKlxuICogT2JzZXJ2YWJsZVxuICogICAgIC56aXAoYWdlJCxcbiAqICAgICAgICAgIG5hbWUkLFxuICogICAgICAgICAgaXNEZXYkLFxuICogICAgICAgICAgKGFnZTogbnVtYmVyLCBuYW1lOiBzdHJpbmcsIGlzRGV2OiBib29sZWFuKSA9PiAoeyBhZ2UsIG5hbWUsIGlzRGV2IH0pKVxuICogICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gb3V0cHV0c1xuICogLy8geyBhZ2U6IDI3LCBuYW1lOiAnRm9vJywgaXNEZXY6IHRydWUgfVxuICogLy8geyBhZ2U6IDI1LCBuYW1lOiAnQmFyJywgaXNEZXY6IHRydWUgfVxuICogLy8geyBhZ2U6IDI5LCBuYW1lOiAnQmVlcicsIGlzRGV2OiBmYWxzZSB9XG4gKlxuICogQHBhcmFtIG9ic2VydmFibGVzXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fVxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSB6aXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHppcFN0YXRpYygpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIHByb2plY3QgPSBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAodHlwZW9mIHByb2plY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKG9ic2VydmFibGVzKS5saWZ0KG5ldyBaaXBPcGVyYXRvcihwcm9qZWN0KSk7XG59XG5leHBvcnRzLnppcFN0YXRpYyA9IHppcFN0YXRpYztcbnZhciBaaXBPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWmlwT3BlcmF0b3IocHJvamVjdCkge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgIH1cbiAgICBaaXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFppcFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcm9qZWN0KSk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5aaXBPcGVyYXRvciA9IFppcE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBaaXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWmlwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBaaXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7IHZhbHVlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLml0ZXJhdG9ycyA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMucHJvamVjdCA9ICh0eXBlb2YgcHJvamVjdCA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9qZWN0IDogbnVsbDtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICAgICAgaWYgKGlzQXJyYXlfMS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgaXRlcmF0b3JzLnB1c2gobmV3IFN0YXRpY0FycmF5SXRlcmF0b3IodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWVbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaXRlcmF0b3JzLnB1c2gobmV3IFN0YXRpY0l0ZXJhdG9yKHZhbHVlW2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0oKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0b3JzLnB1c2gobmV3IFppcEJ1ZmZlckl0ZXJhdG9yKHRoaXMuZGVzdGluYXRpb24sIHRoaXMsIHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHRoaXMuaXRlcmF0b3JzO1xuICAgICAgICB2YXIgbGVuID0gaXRlcmF0b3JzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBsZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVyYXRvci5zdGlsbFVuc3Vic2NyaWJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGl0ZXJhdG9yLnN1YnNjcmliZShpdGVyYXRvciwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmUtLTsgLy8gbm90IGFuIG9ic2VydmFibGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5SW5hY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5jaGVja0l0ZXJhdG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHRoaXMuaXRlcmF0b3JzO1xuICAgICAgICB2YXIgbGVuID0gaXRlcmF0b3JzLmxlbmd0aDtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgLy8gYWJvcnQgaWYgbm90IGFsbCBvZiB0aGVtIGhhdmUgdmFsdWVzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3IuaGFzVmFsdWUgPT09ICdmdW5jdGlvbicgJiYgIWl0ZXJhdG9yLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3VsZENvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yc1tpXTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgaXQncyBjb21wbGV0ZWQgbm93IHRoYXQgeW91J3ZlIGdvdHRlblxuICAgICAgICAgICAgLy8gdGhlIG5leHQgdmFsdWUuXG4gICAgICAgICAgICBpZiAoaXRlcmF0b3IuaGFzQ29tcGxldGVkKCkpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3MucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb2plY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeVByb2plY3QoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRDb21wbGV0ZSkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuX3RyeVByb2plY3QgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5aaXBTdWJzY3JpYmVyID0gWmlwU3Vic2NyaWJlcjtcbnZhciBTdGF0aWNJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljSXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICAgICAgdGhpcy5pdGVyYXRvciA9IGl0ZXJhdG9yO1xuICAgICAgICB0aGlzLm5leHRSZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgfVxuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBTdGF0aWNJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMubmV4dFJlc3VsdDtcbiAgICAgICAgdGhpcy5uZXh0UmVzdWx0ID0gdGhpcy5pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBTdGF0aWNJdGVyYXRvci5wcm90b3R5cGUuaGFzQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJlc3VsdCA9IHRoaXMubmV4dFJlc3VsdDtcbiAgICAgICAgcmV0dXJuIG5leHRSZXN1bHQgJiYgbmV4dFJlc3VsdC5kb25lO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0l0ZXJhdG9yO1xufSgpKTtcbnZhciBTdGF0aWNBcnJheUl0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNBcnJheUl0ZXJhdG9yKGFycmF5KSB7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgfVxuICAgIFN0YXRpY0FycmF5SXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgcmV0dXJuIGkgPCB0aGlzLmxlbmd0aCA/IHsgdmFsdWU6IGFycmF5W2ldLCBkb25lOiBmYWxzZSB9IDogeyB2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZSB9O1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA+IHRoaXMuaW5kZXg7XG4gICAgfTtcbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gdGhpcy5pbmRleDtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNBcnJheUl0ZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgWmlwQnVmZmVySXRlcmF0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaaXBCdWZmZXJJdGVyYXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBaaXBCdWZmZXJJdGVyYXRvcihkZXN0aW5hdGlvbiwgcGFyZW50LCBvYnNlcnZhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZSA9IG9ic2VydmFibGU7XG4gICAgICAgIHRoaXMuc3RpbGxVbnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICB9XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlW2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLy8gTk9URTogdGhlcmUgaXMgYWN0dWFsbHkgYSBuYW1lIGNvbGxpc2lvbiBoZXJlIHdpdGggU3Vic2NyaWJlci5uZXh0IGFuZCBJdGVyYXRvci5uZXh0XG4gICAgLy8gICAgdGhpcyBpcyBsZWdpdCBiZWNhdXNlIGBuZXh0KClgIHdpbGwgbmV2ZXIgYmUgY2FsbGVkIGJ5IGEgc3Vic2NyaXB0aW9uIGluIHRoaXMgY2FzZS5cbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBudWxsLCBkb25lOiB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogYnVmZmVyLnNoaWZ0KCksIGRvbmU6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUuaGFzQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoID09PSAwICYmIHRoaXMuaXNDb21wbGV0ZTtcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5ub3RpZnlJbmFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGlubmVyVmFsdWUpO1xuICAgICAgICB0aGlzLnBhcmVudC5jaGVja0l0ZXJhdG9ycygpO1xuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgdGhpcy5vYnNlcnZhYmxlLCB0aGlzLCBpbmRleCk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwQnVmZmVySXRlcmF0b3I7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emlwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogQSB1bml0IG9mIHdvcmsgdG8gYmUgZXhlY3V0ZWQgaW4gYSB7QGxpbmsgU2NoZWR1bGVyfS4gQW4gYWN0aW9uIGlzIHR5cGljYWxseVxuICogY3JlYXRlZCBmcm9tIHdpdGhpbiBhIFNjaGVkdWxlciBhbmQgYW4gUnhKUyB1c2VyIGRvZXMgbm90IG5lZWQgdG8gY29uY2VyblxuICogdGhlbXNlbHZlcyBhYm91dCBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGFuIEFjdGlvbi5cbiAqXG4gKiBgYGB0c1xuICogY2xhc3MgQWN0aW9uPFQ+IGV4dGVuZHMgU3Vic2NyaXB0aW9uIHtcbiAqICAgbmV3IChzY2hlZHVsZXI6IFNjaGVkdWxlciwgd29yazogKHN0YXRlPzogVCkgPT4gdm9pZCk7XG4gKiAgIHNjaGVkdWxlKHN0YXRlPzogVCwgZGVsYXk6IG51bWJlciA9IDApOiBTdWJzY3JpcHRpb247XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAY2xhc3MgQWN0aW9uPFQ+XG4gKi9cbnZhciBBY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIHRoaXMgYWN0aW9uIG9uIGl0cyBwYXJlbnQgU2NoZWR1bGVyIGZvciBleGVjdXRpb24uIE1heSBiZSBwYXNzZWRcbiAgICAgKiBzb21lIGNvbnRleHQgb2JqZWN0LCBgc3RhdGVgLiBNYXkgaGFwcGVuIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZSxcbiAgICAgKiBhY2NvcmRpbmcgdG8gdGhlIGBkZWxheWAgcGFyYW1ldGVyLCBpZiBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHtUfSBbc3RhdGVdIFNvbWUgY29udGV4dHVhbCBkYXRhIHRoYXQgdGhlIGB3b3JrYCBmdW5jdGlvbiB1c2VzIHdoZW5cbiAgICAgKiBjYWxsZWQgYnkgdGhlIFNjaGVkdWxlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5XSBUaW1lIHRvIHdhaXQgYmVmb3JlIGV4ZWN1dGluZyB0aGUgd29yaywgd2hlcmUgdGhlXG4gICAgICogdGltZSB1bml0IGlzIGltcGxpY2l0IGFuZCBkZWZpbmVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gQWN0aW9uO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuQWN0aW9uID0gQWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG52YXIgQWN0aW9uXzEgPSByZXF1aXJlKCcuL0FjdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBBc3luY0FjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzeW5jQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFzeW5jQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy53b3JrID0gd29yaztcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWx3YXlzIHJlcGxhY2UgdGhlIGN1cnJlbnQgc3RhdGUgd2l0aCB0aGUgbmV3IHN0YXRlLlxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIC8vIFNldCB0aGUgcGVuZGluZyBmbGFnIGluZGljYXRpbmcgdGhhdCB0aGlzIGFjdGlvbiBoYXMgYmVlbiBzY2hlZHVsZWQsIG9yXG4gICAgICAgIC8vIGhhcyByZWN1cnNpdmVseSByZXNjaGVkdWxlZCBpdHNlbGYuXG4gICAgICAgIHRoaXMucGVuZGluZyA9IHRydWU7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW1wb3J0YW50IGltcGxlbWVudGF0aW9uIG5vdGU6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFjdGlvbnMgb25seSBleGVjdXRlIG9uY2UgYnkgZGVmYXVsdCwgdW5sZXNzIHJlc2NoZWR1bGVkIGZyb20gd2l0aGluIHRoZVxuICAgICAgICAvLyBzY2hlZHVsZWQgY2FsbGJhY2suIFRoaXMgYWxsb3dzIHVzIHRvIGltcGxlbWVudCBzaW5nbGUgYW5kIHJlcGVhdFxuICAgICAgICAvLyBhY3Rpb25zIHZpYSB0aGUgc2FtZSBjb2RlIHBhdGgsIHdpdGhvdXQgYWRkaW5nIEFQSSBzdXJmYWNlIGFyZWEsIGFzIHdlbGxcbiAgICAgICAgLy8gYXMgbWltaWMgdHJhZGl0aW9uYWwgcmVjdXJzaW9uIGJ1dCBhY3Jvc3MgYXN5bmNocm9ub3VzIGJvdW5kYXJpZXMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhvd2V2ZXIsIEpTIHJ1bnRpbWVzIGFuZCB0aW1lcnMgZGlzdGluZ3Vpc2ggYmV0d2VlbiBpbnRlcnZhbHMgYWNoaWV2ZWQgYnlcbiAgICAgICAgLy8gc2VyaWFsIGBzZXRUaW1lb3V0YCBjYWxscyB2cy4gYSBzaW5nbGUgYHNldEludGVydmFsYCBjYWxsLiBBbiBpbnRlcnZhbCBvZlxuICAgICAgICAvLyBzZXJpYWwgYHNldFRpbWVvdXRgIGNhbGxzIGNhbiBiZSBpbmRpdmlkdWFsbHkgZGVsYXllZCwgd2hpY2ggZGVsYXlzXG4gICAgICAgIC8vIHNjaGVkdWxpbmcgdGhlIG5leHQgYHNldFRpbWVvdXRgLCBhbmQgc28gb24uIGBzZXRJbnRlcnZhbGAgYXR0ZW1wdHMgdG9cbiAgICAgICAgLy8gZ3VhcmFudGVlIHRoZSBpbnRlcnZhbCBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgbW9yZSBwcmVjaXNlbHkgdG8gdGhlXG4gICAgICAgIC8vIGludGVydmFsIHBlcmlvZCwgcmVnYXJkbGVzcyBvZiBsb2FkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGVyZWZvcmUsIHdlIHVzZSBgc2V0SW50ZXJ2YWxgIHRvIHNjaGVkdWxlIHNpbmdsZSBhbmQgcmVwZWF0IGFjdGlvbnMuXG4gICAgICAgIC8vIElmIHRoZSBhY3Rpb24gcmVzY2hlZHVsZXMgaXRzZWxmIHdpdGggdGhlIHNhbWUgZGVsYXksIHRoZSBpbnRlcnZhbCBpcyBub3RcbiAgICAgICAgLy8gY2FuY2VsZWQuIElmIHRoZSBhY3Rpb24gZG9lc24ndCByZXNjaGVkdWxlLCBvciByZXNjaGVkdWxlcyB3aXRoIGFcbiAgICAgICAgLy8gZGlmZmVyZW50IGRlbGF5LCB0aGUgaW50ZXJ2YWwgd2lsbCBiZSBjYW5jZWxlZCBhZnRlciBzY2hlZHVsZWQgY2FsbGJhY2tcbiAgICAgICAgLy8gZXhlY3V0aW9uLlxuICAgICAgICAvL1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQoc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgLy8gSWYgdGhpcyBhY3Rpb24gaGFzIGFscmVhZHkgYW4gYXN5bmMgSWQsIGRvbid0IHJlcXVlc3QgYSBuZXcgb25lLlxuICAgICAgICB0aGlzLmlkID0gdGhpcy5pZCB8fCB0aGlzLnJlcXVlc3RBc3luY0lkKHNjaGVkdWxlciwgdGhpcy5pZCwgZGVsYXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIHJvb3RfMS5yb290LnNldEludGVydmFsKHNjaGVkdWxlci5mbHVzaC5iaW5kKHNjaGVkdWxlciwgdGhpcyksIGRlbGF5KTtcbiAgICB9O1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5yZWN5Y2xlQXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgLy8gSWYgdGhpcyBhY3Rpb24gaXMgcmVzY2hlZHVsZWQgd2l0aCB0aGUgc2FtZSBkZWxheSB0aW1lLCBkb24ndCBjbGVhciB0aGUgaW50ZXJ2YWwgaWQuXG4gICAgICAgIGlmIChkZWxheSAhPT0gbnVsbCAmJiB0aGlzLmRlbGF5ID09PSBkZWxheSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIGFjdGlvbidzIGRlbGF5IHRpbWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgZGVsYXksXG4gICAgICAgIC8vIGNsZWFyIHRoZSBpbnRlcnZhbCBpZFxuICAgICAgICByZXR1cm4gcm9vdF8xLnJvb3QuY2xlYXJJbnRlcnZhbChpZCkgJiYgdW5kZWZpbmVkIHx8IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGV4ZWN1dGVzIHRoaXMgYWN0aW9uIGFuZCB0aGUgYHdvcmtgIGl0IGNvbnRhaW5zLlxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdleGVjdXRpbmcgYSBjYW5jZWxsZWQgYWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMuX2V4ZWN1dGUoc3RhdGUsIGRlbGF5KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wZW5kaW5nID09PSBmYWxzZSAmJiB0aGlzLmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERlcXVldWUgaWYgdGhlIGFjdGlvbiBkaWRuJ3QgcmVzY2hlZHVsZSBpdHNlbGYuIERvbid0IGNhbGxcbiAgICAgICAgICAgIC8vIHVuc3Vic2NyaWJlKCksIGJlY2F1c2UgdGhlIGFjdGlvbiBjb3VsZCByZXNjaGVkdWxlIGxhdGVyLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgICAgICAvLyBgYGBcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiBkb1dvcmsoY291bnRlcikge1xuICAgICAgICAgICAgLy8gICAvKiAuLi4gSSdtIGEgYnVzeSB3b3JrZXIgYmVlIC4uLiAqL1xuICAgICAgICAgICAgLy8gICB2YXIgb3JpZ2luYWxBY3Rpb24gPSB0aGlzO1xuICAgICAgICAgICAgLy8gICAvKiB3YWl0IDEwMG1zIGJlZm9yZSByZXNjaGVkdWxpbmcgdGhlIGFjdGlvbiAqL1xuICAgICAgICAgICAgLy8gICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vICAgICBvcmlnaW5hbEFjdGlvbi5zY2hlZHVsZShjb3VudGVyICsgMSk7XG4gICAgICAgICAgICAvLyAgIH0sIDEwMCk7XG4gICAgICAgICAgICAvLyB9LCAxMDAwKTtcbiAgICAgICAgICAgIC8vIGBgYFxuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQodGhpcy5zY2hlZHVsZXIsIHRoaXMuaWQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIHZhciBlcnJvcmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvclZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53b3JrKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvclZhbHVlID0gISFlICYmIGUgfHwgbmV3IEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JWYWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHNjaGVkdWxlci5hY3Rpb25zO1xuICAgICAgICB2YXIgaW5kZXggPSBhY3Rpb25zLmluZGV4T2YodGhpcyk7XG4gICAgICAgIHRoaXMud29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gbnVsbDtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXIsIGlkLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jQWN0aW9uO1xufShBY3Rpb25fMS5BY3Rpb24pKTtcbmV4cG9ydHMuQXN5bmNBY3Rpb24gPSBBc3luY0FjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzeW5jQWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi9TY2hlZHVsZXInKTtcbnZhciBBc3luY1NjaGVkdWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzeW5jU2NoZWR1bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFzeW5jU2NoZWR1bGVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGUgU2NoZWR1bGVyIGlzIGN1cnJlbnRseSBleGVjdXRpbmcgYSBiYXRjaCBvZlxuICAgICAgICAgKiBxdWV1ZWQgYWN0aW9ucy5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZXJuYWwgSUQgdXNlZCB0byB0cmFjayB0aGUgbGF0ZXN0IGFzeW5jaHJvbm91cyB0YXNrIHN1Y2ggYXMgdGhvc2VcbiAgICAgICAgICogY29taW5nIGZyb20gYHNldFRpbWVvdXRgLCBgc2V0SW50ZXJ2YWxgLCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCwgYW5kXG4gICAgICAgICAqIG90aGVycy5cbiAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBBc3luY1NjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPSBhY3Rpb24uZXhlY3V0ZShhY3Rpb24uc3RhdGUsIGFjdGlvbi5kZWxheSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKTsgLy8gZXhoYXVzdCB0aGUgc2NoZWR1bGVyIHF1ZXVlXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgd2hpbGUgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBc3luY1NjaGVkdWxlcjtcbn0oU2NoZWR1bGVyXzEuU2NoZWR1bGVyKSk7XG5leHBvcnRzLkFzeW5jU2NoZWR1bGVyID0gQXN5bmNTY2hlZHVsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY1NjaGVkdWxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbmZ1bmN0aW9uIHN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwocm9vdCkge1xuICAgIHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoIVN5bWJvbC5pdGVyYXRvcikge1xuICAgICAgICAgICAgU3ltYm9sLml0ZXJhdG9yID0gU3ltYm9sKCdpdGVyYXRvciBwb2x5ZmlsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTeW1ib2wuaXRlcmF0b3I7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBbZm9yIE1vemlsbGEgR2Vja28gMjctMzU6XShodHRwczovL216bC5sYS8yZXdFMXpDKVxuICAgICAgICB2YXIgU2V0XzEgPSByb290LlNldDtcbiAgICAgICAgaWYgKFNldF8xICYmIHR5cGVvZiBuZXcgU2V0XzEoKVsnQEBpdGVyYXRvciddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0BAaXRlcmF0b3InO1xuICAgICAgICB9XG4gICAgICAgIHZhciBNYXBfMSA9IHJvb3QuTWFwO1xuICAgICAgICAvLyByZXF1aXJlZCBmb3IgY29tcGF0YWJpbGl0eSB3aXRoIGVzNi1zaGltXG4gICAgICAgIGlmIChNYXBfMSkge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXBfMS5wcm90b3R5cGUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHNwZWMsIE1hcC5wcm90b3R5cGVbQEBpdGVyYXRvcl0gYW5kIE1hcC5vcm90b3R5cGUuZW50cmllcyBtdXN0IGJlIGVxdWFsLlxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdlbnRyaWVzJyAmJiBrZXkgIT09ICdzaXplJyAmJiBNYXBfMS5wcm90b3R5cGVba2V5XSA9PT0gTWFwXzEucHJvdG90eXBlWydlbnRyaWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdAQGl0ZXJhdG9yJztcbiAgICB9XG59XG5leHBvcnRzLnN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwgPSBzeW1ib2xJdGVyYXRvclBvbnlmaWxsO1xuZXhwb3J0cy4kJGl0ZXJhdG9yID0gc3ltYm9sSXRlcmF0b3JQb255ZmlsbChyb290XzEucm9vdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pdGVyYXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbmZ1bmN0aW9uIGdldFN5bWJvbE9ic2VydmFibGUoY29udGV4dCkge1xuICAgIHZhciAkJG9ic2VydmFibGU7XG4gICAgdmFyIFN5bWJvbCA9IGNvbnRleHQuU3ltYm9sO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgJCRvYnNlcnZhYmxlID0gU3ltYm9sLm9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAkJG9ic2VydmFibGUgPSBTeW1ib2woJ29ic2VydmFibGUnKTtcbiAgICAgICAgICAgIFN5bWJvbC5vYnNlcnZhYmxlID0gJCRvYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAkJG9ic2VydmFibGUgPSAnQEBvYnNlcnZhYmxlJztcbiAgICB9XG4gICAgcmV0dXJuICQkb2JzZXJ2YWJsZTtcbn1cbmV4cG9ydHMuZ2V0U3ltYm9sT2JzZXJ2YWJsZSA9IGdldFN5bWJvbE9ic2VydmFibGU7XG5leHBvcnRzLiQkb2JzZXJ2YWJsZSA9IGdldFN5bWJvbE9ic2VydmFibGUocm9vdF8xLnJvb3QpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBTeW1ib2wgPSByb290XzEucm9vdC5TeW1ib2w7XG5leHBvcnRzLiQkcnhTdWJzY3JpYmVyID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpID9cbiAgICBTeW1ib2wuZm9yKCdyeFN1YnNjcmliZXInKSA6ICdAQHJ4U3Vic2NyaWJlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yeFN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYW4gZWxlbWVudCB3YXMgcXVlcmllZCBhdCBhIGNlcnRhaW4gaW5kZXggb2YgYW5cbiAqIE9ic2VydmFibGUsIGJ1dCBubyBzdWNoIGluZGV4IG9yIHBvc2l0aW9uIGV4aXN0cyBpbiB0aGF0IHNlcXVlbmNlLlxuICpcbiAqIEBzZWUge0BsaW5rIGVsZW1lbnRBdH1cbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqXG4gKiBAY2xhc3MgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JcbiAqL1xudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IoKSB7XG4gICAgICAgIHZhciBlcnIgPSBfc3VwZXIuY2FsbCh0aGlzLCAnYXJndW1lbnQgb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGFuIGFjdGlvbiBpcyBpbnZhbGlkIGJlY2F1c2UgdGhlIG9iamVjdCBoYXMgYmVlblxuICogdW5zdWJzY3JpYmVkLlxuICpcbiAqIEBzZWUge0BsaW5rIFN1YmplY3R9XG4gKiBAc2VlIHtAbGluayBCZWhhdmlvclN1YmplY3R9XG4gKlxuICogQGNsYXNzIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXG4gKi9cbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9iamVjdFVuc3Vic2NyaWJlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCkge1xuICAgICAgICB2YXIgZXJyID0gX3N1cGVyLmNhbGwodGhpcywgJ29iamVjdCB1bnN1YnNjcmliZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5PYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gb25lIG9yIG1vcmUgZXJyb3JzIGhhdmUgb2NjdXJyZWQgZHVyaW5nIHRoZVxuICogYHVuc3Vic2NyaWJlYCBvZiBhIHtAbGluayBTdWJzY3JpcHRpb259LlxuICovXG52YXIgVW5zdWJzY3JpcHRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVuc3Vic2NyaXB0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB2YXIgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBlcnJvcnMgP1xuICAgICAgICAgICAgZXJyb3JzLmxlbmd0aCArIFwiIGVycm9ycyBvY2N1cnJlZCBkdXJpbmcgdW5zdWJzY3JpcHRpb246XFxuICBcIiArIGVycm9ycy5tYXAoZnVuY3Rpb24gKGVyciwgaSkgeyByZXR1cm4gKChpICsgMSkgKyBcIikgXCIgKyBlcnIudG9TdHJpbmcoKSk7IH0pLmpvaW4oJ1xcbiAgJykgOiAnJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ1Vuc3Vic2NyaXB0aW9uRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIFVuc3Vic2NyaXB0aW9uRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlVuc3Vic2NyaXB0aW9uRXJyb3IgPSBVbnN1YnNjcmlwdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5zdWJzY3JpcHRpb25FcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiB3aW5kb3c6IGJyb3dzZXIgaW4gRE9NIG1haW4gdGhyZWFkXG4gKiBzZWxmOiBicm93c2VyIGluIFdlYldvcmtlclxuICogZ2xvYmFsOiBOb2RlLmpzL290aGVyXG4gKi9cbmV4cG9ydHMucm9vdCA9ICh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdy53aW5kb3cgPT09IHdpbmRvdyAmJiB3aW5kb3dcbiAgICB8fCB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZlxuICAgIHx8IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCk7XG5pZiAoIWV4cG9ydHMucm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUnhKUyBjb3VsZCBub3QgZmluZCBhbnkgZ2xvYmFsIGNvbnRleHQgKHdpbmRvdywgc2VsZiwgZ2xvYmFsKScpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm9vdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbnZhciBpc0FycmF5TGlrZV8xID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xudmFyIGlzUHJvbWlzZV8xID0gcmVxdWlyZSgnLi9pc1Byb21pc2UnKTtcbnZhciBpc09iamVjdF8xID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL2l0ZXJhdG9yJyk7XG52YXIgSW5uZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9Jbm5lclN1YnNjcmliZXInKTtcbnZhciBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvb2JzZXJ2YWJsZScpO1xuZnVuY3Rpb24gc3Vic2NyaWJlVG9SZXN1bHQob3V0ZXJTdWJzY3JpYmVyLCByZXN1bHQsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpIHtcbiAgICB2YXIgZGVzdGluYXRpb24gPSBuZXcgSW5uZXJTdWJzY3JpYmVyXzEuSW5uZXJTdWJzY3JpYmVyKG91dGVyU3Vic2NyaWJlciwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCk7XG4gICAgaWYgKGRlc3RpbmF0aW9uLmNsb3NlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSB7XG4gICAgICAgIGlmIChyZXN1bHQuX2lzU2NhbGFyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1YnNjcmliZShkZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheUxpa2VfMS5pc0FycmF5TGlrZShyZXN1bHQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuICYmICFkZXN0aW5hdGlvbi5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUHJvbWlzZV8xLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBkZXN0aW5hdGlvbi5lcnJvcihlcnIpOyB9KVxuICAgICAgICAgICAgLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgLy8gRXNjYXBpbmcgdGhlIFByb21pc2UgdHJhcDogZ2xvYmFsbHkgdGhyb3cgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICAgICAgcm9vdF8xLnJvb3Quc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gcmVzdWx0W2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0oKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoaXRlbS5kb25lKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdFtvYnNlcnZhYmxlXzEuJCRvYnNlcnZhYmxlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgb2JzID0gcmVzdWx0W29ic2VydmFibGVfMS4kJG9ic2VydmFibGVdKCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IobmV3IFR5cGVFcnJvcignUHJvdmlkZWQgb2JqZWN0IGRvZXMgbm90IGNvcnJlY3RseSBpbXBsZW1lbnQgU3ltYm9sLm9ic2VydmFibGUnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzLnN1YnNjcmliZShuZXcgSW5uZXJTdWJzY3JpYmVyXzEuSW5uZXJTdWJzY3JpYmVyKG91dGVyU3Vic2NyaWJlciwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUgPSBpc09iamVjdF8xLmlzT2JqZWN0KHJlc3VsdCkgPyAnYW4gaW52YWxpZCBvYmplY3QnIDogXCInXCIgKyByZXN1bHQgKyBcIidcIjtcbiAgICAgICAgdmFyIG1zZyA9IChcIllvdSBwcm92aWRlZCBcIiArIHZhbHVlICsgXCIgd2hlcmUgYSBzdHJlYW0gd2FzIGV4cGVjdGVkLlwiKVxuICAgICAgICAgICAgKyAnIFlvdSBjYW4gcHJvdmlkZSBhbiBPYnNlcnZhYmxlLCBQcm9taXNlLCBBcnJheSwgb3IgSXRlcmFibGUuJztcbiAgICAgICAgZGVzdGluYXRpb24uZXJyb3IobmV3IFR5cGVFcnJvcihtc2cpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLnN1YnNjcmliZVRvUmVzdWx0ID0gc3Vic2NyaWJlVG9SZXN1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVUb1Jlc3VsdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG52YXIgT2JzZXJ2ZXJfMSA9IHJlcXVpcmUoJy4uL09ic2VydmVyJyk7XG5mdW5jdGlvbiB0b1N1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIGlmIChuZXh0T3JPYnNlcnZlcikge1xuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgaW5zdGFuY2VvZiBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5leHRPck9ic2VydmVyICYmICFlcnJvciAmJiAhY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihPYnNlcnZlcl8xLmVtcHR5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbn1cbmV4cG9ydHMudG9TdWJzY3JpYmVyID0gdG9TdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9TdWJzY3JpYmVyLmpzLm1hcCIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyXG4vLyBMaWNlbnNlZCB1bmRlciBNSVRcblxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgdXJsIGlzIGV4dGVybmFsXG4gKlxuICogQHBhcmFtICAge3N0cmluZ30gICAgdXJsIC0gdXJsIGJlaW5nIGV2YWx1YXRlZFxuICogQHNlZSAgICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MjM4MzUxL2Zhc3Rlc3Qtd2F5LXRvLWRldGVjdC1leHRlcm5hbC11cmxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVybmFsKHVybCkge1xuICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaCgvXihbXjpcXC8/I10rOik/KD86XFwvXFwvKFteXFwvPyNdKikpPyhbXj8jXSspPyhcXD9bXiNdKik/KCMuKik/Lyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxuICBpZiAodHlwZW9mIG1hdGNoWzFdID09PSAnc3RyaW5nJyAmJlxuICAgICAgbWF0Y2hbMV0ubGVuZ3RoID4gMCAmJlxuICAgICAgbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSAhPT0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sXG4gICAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBwb3J0ID0geyBodHRwOiA4MCwgaHR0cHM6IDQ0MyB9W3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbF07XG5cbiAgaWYgKHR5cGVvZiBtYXRjaFsyXSA9PT0gJ3N0cmluZycgJiZcbiAgICBtYXRjaFsyXS5sZW5ndGggPiAwICYmXG4gICAgbWF0Y2hbMl0ucmVwbGFjZShuZXcgUmVnRXhwKGA6KCR7cG9ydH0pPyRgKSwgJycpICE9PSB3aW5kb3cubG9jYXRpb24uaG9zdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFN0cmlwcyB0aGUgaGFzaCBmcm9tIGEgdXJsIGFuZCByZXR1cm5zIHRoZSBuZXcgaHJlZlxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIGhyZWYgLSB1cmwgYmVpbmcgZXZhbHVhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEhhc2goaHJlZikge1xuICByZXR1cm4gaHJlZi5yZXBsYWNlKC8jLiovLCAnJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgdXJsIGlzIGFuIGludGVybmFsIGhhc2hcbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSAgICBocmVmIC0gdXJsIGJlaW5nIGV2YWx1YXRlZFxuICogQHBhcmFtICAge3N0cmluZ30gICAgcHJldiAtIHByZXZpb3VzIHVybCAob3B0aW9uYWwpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hhc2goaHJlZiwgcHJldikge1xuICBjb25zdCBwID0gcHJldiB8fCB3aW5kb3cubG9jYXRpb24uaHJlZjtcblxuICBjb25zdCBoYXNIYXNoID0gaHJlZi5pbmRleE9mKCcjJykgPiAtMTtcbiAgY29uc3Qgc2FtZVBhdGggPSBzdHJpcEhhc2goaHJlZikgPT09IHN0cmlwSGFzaChwKTtcblxuICByZXR1cm4gKGhhc0hhc2ggJiYgc2FtZVBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIChlbC5tYXRjaGVzIHx8IGVsLm1hdGNoZXNTZWxlY3RvciB8fCBlbC5tc01hdGNoZXNTZWxlY3RvciB8fCBlbC5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWwub01hdGNoZXNTZWxlY3RvcikuY2FsbChlbCwgc2VsZWN0b3IpO1xuICAvLyBpZiAoIW1hdGNoZXMubWVtbykge1xuICAvLyAgIG1hdGNoZXMubWVtbyA9XG4gIC8vICAgICBlbC5tYXRjaGVzIHx8XG4gIC8vICAgICBlbC5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgLy8gICAgIGVsLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gIC8vICAgICBlbC5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgLy8gICAgIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAvLyAgICAgZWwub01hdGNoZXNTZWxlY3RvcjtcbiAgLy8gfVxuICAvLyByZXR1cm4gbWF0Y2hlcy5tZW1vLmNhbGwoZWwsIHNlbGVjdG9yKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JJbnYoZWwsIHNlbGVjdG9yKSB7XG4gIGxldCBjdXJyID0gZWw7XG4gIHdoaWxlIChjdXJyICE9PSBkb2N1bWVudCAmJiBjdXJyICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBpZiAobWF0Y2hlcyhjdXJyLCBzZWxlY3RvcikpIHJldHVybiBjdXJyO1xuICAgIGN1cnIgPSBjdXJyLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB3ZSBzaG91bGQgYmUgbG9hZGluZyB0aGlzIFVSTFxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIHVybCAtIHVybCBiZWluZyBldmFsdWF0ZWRcbiAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIGJsYWNrbGlzdCAtIGpxdWVyeSBzZWxlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkTG9hZEFuY2hvcihhbmNob3IsIGJsYWNrbGlzdCwgaHJlZlJlZ2V4KSB7XG4gIGNvbnN0IGhyZWYgPSBhbmNob3IuaHJlZjtcbiAgLy8gVVJMIHdpbGwgb25seSBiZSBsb2FkZWQgaWYgaXQncyBub3QgYW4gZXh0ZXJuYWwgbGluaywgaGFzaCwgb3JcbiAgLy8gYmxhY2tsaXN0ZWRcbiAgcmV0dXJuIChcbiAgICAhaXNFeHRlcm5hbChocmVmKSAmJlxuICAgICFpc0hhc2goaHJlZikgJiZcbiAgICAhbWF0Y2hlcyhhbmNob3IsIGJsYWNrbGlzdCkgJiZcbiAgICBhbmNob3IudGFyZ2V0ID09PSAnJyAmJiAoXG4gICAgICBocmVmUmVnZXggPT09IG51bGwgfHxcbiAgICAgIGhyZWYuc2VhcmNoKGhyZWZSZWdleCkgIT09IC0xXG4gICAgKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICBjb25zdCBoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBjb25zdCBiID0gZG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgc2ggPSAnc2Nyb2xsSGVpZ2h0JztcbiAgcmV0dXJuIGhbc2hdIHx8IGJbc2hdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsTGVmdCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY3JvbGxUb3AoKSB7XG4gIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBJbnRlcnZhbChpbml0LCBleHApIHtcbiAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcikgPT4ge1xuICAgIGxldCBuID0gaW5pdDtcbiAgICBsZXQgaWQ7XG5cbiAgICBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgb2JzZXJ2ZXIubmV4dChuKTtcbiAgICAgIG4gKj0gZXhwO1xuICAgICAgaWQgPSBzZXRUaW1lb3V0KG5leHQsIG4pO1xuICAgIH1cblxuICAgIGlkID0gc2V0VGltZW91dChuZXh0LCBuKTtcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJhZ21lbnRGcm9tU3RyaW5nKHN0ckhUTUwpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHN0ckhUTUwpO1xufVxuIiwiLy8gQ29weXJpZ2h0IChjKSAyMDE3IEZsb3JpYW4gS2xhbXBmZXJcbi8vIExpY2Vuc2VkIHVuZGVyIE1JVFxuXG4vKlxuZXNsaW50LWRpc2FibGVcbmltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcyxcbmltcG9ydC9uby11bnJlc29sdmVkLFxuaW1wb3J0L2V4dGVuc2lvbnMsXG5uby1jb25zb2xlXG4qL1xuXG4vLyBjb25zdCBKU19GRUFUVVJFUyA9IFtcbi8vICAgJ2ZuL2FycmF5L2Zvci1lYWNoJyxcbi8vICAgJ2ZuL2Z1bmN0aW9uL2JpbmQnLFxuLy8gICAnZm4vbnVtYmVyL2NvbnN0cnVjdG9yJyxcbi8vICAgJ2ZuL29iamVjdC9hc3NpZ24nLFxuLy8gICAnZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eScsXG4vLyAgICdmbi9vYmplY3Qva2V5cycsXG4vLyBdO1xuLy9cbi8vIGNvbnN0IE1PREVSTklaUl9URVNUUyA9IFtcbi8vICAgJ2N1c3RvbWV2ZW50Jyxcbi8vICAgJ2RvY3VtZW50ZnJhZ21lbnQnLFxuLy8gICAnZXZlbnRsaXN0ZW5lcicsXG4vLyAgICdoaXN0b3J5Jyxcbi8vICAgJ3JlcXVlc3RhbmltYXRpb25mcmFtZScsXG4vLyAgICdxdWVyeXNlbGVjdG9yJyxcbi8vIF07XG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9kZWZlcic7XG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9tZXJnZSc7XG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvb2YnO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL3Rocm93JztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS90aW1lcic7XG5cbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9kb20vYWpheCc7XG5cbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvY2F0Y2gnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9kZWJvdW5jZVRpbWUnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9kZWxheSc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvZG8nO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9maWx0ZXInO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tYXAnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tZXJnZUFsbCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3JldHJ5V2hlbic7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3NoYXJlJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivc3RhcnRXaXRoJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvdGFrZSc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3Rha2VVbnRpbCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3Rocm90dGxlVGltZSc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3dpdGhMYXRlc3RGcm9tJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvemlwJztcblxuaW1wb3J0IGNvbXBvbmVudENvcmUgZnJvbSAneS1jb21wb25lbnQvc3JjL2NvbXBvbmVudC1jb3JlJztcblxuaW1wb3J0IHtcbiAgc2hvdWxkTG9hZEFuY2hvcixcbiAgZ2V0U2Nyb2xsVG9wLFxuICBnZXRTY3JvbGxIZWlnaHQsXG4gIGV4cEludGVydmFsLFxuICBmcmFnbWVudEZyb21TdHJpbmcsXG59IGZyb20gJy4uL2NvbW1vbic7XG5cbmltcG9ydCB7IFB1c2gsIEhpbnQsIFBvcCB9IGZyb20gJy4va2luZCc7XG5cbi8vIH4gbWl4aW4gcHVzaFN0YXRlQ29yZSB3aXRoIGNvbXBvbmVudENvcmUgeyAuLi5cbmV4cG9ydCBkZWZhdWx0IEMgPT4gY2xhc3MgZXh0ZW5kcyBjb21wb25lbnRDb3JlKEMpIHtcblxuICAvLyBAb3ZlcnJpZGVcbiAgZ2V0Q29tcG9uZW50TmFtZSgpIHtcbiAgICByZXR1cm4gJ3ktcHVzaC1zdGF0ZSc7XG4gIH1cblxuICAvLyBAb3ZlcnJpZGVcbiAgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcGxhY2VJZHM6IFtdLFxuICAgICAgbGlua1NlbGVjdG9yOiAnYVtocmVmXScsXG4gICAgICBzY3JvbGxSZXN0b3JhdGlvbjogZmFsc2UsXG4gICAgICBocmVmUmVnZXg6IG51bGwsXG4gICAgICBibGFja2xpc3Q6ICcubm8tcHVzaC1zdGF0ZScsXG4gICAgICBkdXJhdGlvbjogMCxcbiAgICAgIG5vUG9wRHVyYXRpb246IHRydWUsXG4gICAgfTtcbiAgfVxuXG4gIC8vIEBvdmVycmlkZVxuICBzaWRlRWZmZWN0cygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvLyBAb3ZlcnJpZGVcbiAgc3RhcnRIaXN0b3J5KCkge1xuICAgIHRoaXMuY2hlY2tQcmVDb25kaXRpb24oKTtcbiAgICB0aGlzLnNldHVwU2Nyb2xsUmVzdG9yYXRpb24oKTtcbiAgICB0aGlzLmNhY2hlVGl0bGVFbGVtZW50KCk7XG4gICAgdGhpcy5zZXR1cE9ic2VydmFibGVzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjaGVja1ByZUNvbmRpdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZXBsYWNlSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmVsLmlkO1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gcmVwbGFjZSBpZHMgcHJvdmlkZWQuIFdpbGwgcmVwbGFjZSBlbnRpcmUgY29udGVudCBvZiAjJHtpZH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKCdObyByZXBsYWNlIGlkcyBwcm92aWRlZCBub3IgZG9lcyB0aGlzIGNvbXBvbmVudCBoYXZlIGFuZCBpZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldHVwU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gICAgaWYgKCdzY3JvbGxSZXN0b3JhdGlvbicgaW4gaGlzdG9yeSkge1xuICAgICAgaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IHRoaXMuc2Nyb2xsUmVzdG9yYXRpb24gPyAnbWFudWFsJyA6ICdhdXRvJztcbiAgICB9XG5cbiAgICB0aGlzLnNldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMudXBkYXRlSGlzdG9yeVN0YXRlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgY2FjaGVUaXRsZUVsZW1lbnQoKSB7XG4gICAgdGhpcy50aXRsZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCd0aXRsZScpIHx8IHt9O1xuICB9XG5cbiAgYmluZFB1c2hFdmVudHMobGluayQpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tRXZlbnRzKGxpbmskLCAnY2xpY2snKVxuICAgICAgLm1hcChldmVudCA9PiBuZXcgUHVzaChldmVudCkpXG4gICAgICAuZmlsdGVyKGtpbmQgPT4gdGhpcy5pc1BhZ2VDaGFuZ2VFdmVudChraW5kKSlcbiAgICAgIC5kbygoeyBldmVudCB9KSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlSGlzdG9yeVN0YXRlKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGJpbmRIaW50RXZlbnRzKGxpbmskKSB7XG4gICAgcmV0dXJuIE9ic2VydmFibGUubWVyZ2UoXG4gICAgICAgIHRoaXMuZnJvbUV2ZW50cyhsaW5rJCwgJ21vdXNlZW50ZXInKSxcbiAgICAgICAgdGhpcy5mcm9tRXZlbnRzKGxpbmskLCAndG91Y2hzdGFydCcpLFxuICAgICAgICB0aGlzLmZyb21FdmVudHMobGluayQsICdmb2N1cycpLFxuICAgICAgKVxuICAgICAgLm1hcChldmVudCA9PiBuZXcgSGludChldmVudCkpXG4gICAgICAuZmlsdGVyKGtpbmQgPT4gdGhpcy5pc1BhZ2VDaGFuZ2VBbmNob3Ioa2luZCkpO1xuICB9XG5cbiAgYmluZFBvcHN0YXRlRXZlbnQoKSB7XG4gICAgcmV0dXJuIE9ic2VydmFibGUuZnJvbUV2ZW50KHdpbmRvdywgJ3BvcHN0YXRlJylcbiAgICAgIC5tYXAoZXZlbnQgPT4gbmV3IFBvcChldmVudCkpXG4gICAgICAuZmlsdGVyKCgpID0+IHdpbmRvdy5oaXN0b3J5LnN0YXRlICE9IG51bGwpO1xuICB9XG5cbiAgbGlua09ic2VydmFibGUoKSB7XG4gICAgcmV0dXJuIE9ic2VydmFibGUub2YodGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMubGlua1NlbGVjdG9yKSk7XG4gIH1cblxuICBmcm9tRXZlbnRzKGxpbmskLCBldmVudCkge1xuICAgIHJldHVybiBsaW5rJC5tYXAobGluayA9PiBPYnNlcnZhYmxlLmZyb21FdmVudChsaW5rLCBldmVudCkpLm1lcmdlQWxsKCk7XG4gIH1cblxuICBmZXRjaFBhZ2Uoa2luZCkge1xuICAgIHJldHVybiBPYnNlcnZhYmxlXG4gICAgICAuYWpheCh0aGlzLmhyZWZUb0FqYXgoa2luZCkpXG4gICAgICAubWFwKCh7IHJlc3BvbnNlIH0pID0+IE9iamVjdC5hc3NpZ24oa2luZCwgeyByZXNwb25zZSB9KSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB0aGlzLnJlY292ZXJJZlJlc3BvbnNlKGtpbmQsIGVycm9yKSlcbiAgICAgIC5yZXRyeVdoZW4oKCkgPT4gT2JzZXJ2YWJsZS5tZXJnZShcbiAgICAgICAgICBPYnNlcnZhYmxlLmZyb21FdmVudCh3aW5kb3csICdvbmxpbmUnKSxcbiAgICAgICAgICBleHBJbnRlcnZhbCgxMDAwLCAyKSlcbiAgICAgICAgLmRvKHRoaXMub25SZXRyeS5iaW5kKHRoaXMsIGtpbmQpKSk7XG4gIH1cblxuICBocmVmVG9BamF4KHsgaHJlZiB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmw6IGhyZWYsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICB9O1xuICB9XG5cbiAgcmVjb3ZlcklmUmVzcG9uc2Uoa2luZCwgZXJyb3IpIHtcbiAgICBjb25zdCB7IHN0YXR1cywgeGhyIH0gPSBlcnJvcjtcblxuICAgIGlmICh4aHIgJiYgc3RhdHVzICYmIHN0YXR1cyA+IDQwMCkge1xuICAgICAgLy8gUmVjb3ZlciB3aXRoIGVycm9yIHBhZ2UgcmV0dXJuZWQgZnJvbSBzZXJ2ZXIuXG4gICAgICAvLyBOT1RFOiBUaGlzIGFzc3VtZXMgZXJyb3IgcGFnZSBjb250YWlucyB0aGUgc2FtZSBpZHMgYXMgdGhlIG90aGVyIHBhZ2VzLi4uXG4gICAgICByZXR1cm4gT2JzZXJ2YWJsZS5vZihPYmplY3QuYXNzaWduKGtpbmQsIHsgcmVzcG9uc2U6IHhoci5yZXNwb25zZSB9KSk7XG4gICAgfVxuXG4gICAgLy8gZWxzZVxuICAgIHRoaXMub25FcnJvcihPYmplY3QuYXNzaWduKGtpbmQsIGVycm9yKSk7XG4gICAgcmV0dXJuIE9ic2VydmFibGUudGhyb3coZXJyb3IpO1xuICB9XG5cbiAgc2V0dXBPYnNlcnZhYmxlcygpIHtcbiAgICAvLyBTZWUgYHJlbmV3RXZlbnRMaXN0ZW5lcnNgXG4gICAgLy8gVE9ETzogUG9zc2libGUgd2l0aG91dCBzdWJqZWN0cz9cbiAgICB0aGlzLnB1c2gkJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgdGhpcy5oaW50JCQgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgY29uc3QgcHVzaCQgPSB0aGlzLnB1c2gkJC5zd2l0Y2goKVxuICAgICAgLy8gVE9ETzogVGhpcyBwcmV2ZW50cyBhIHdob2xlIGNsYXNzIG9mIGNvbmN1cnJlbmN5IGJ1Z3MsXG4gICAgICAvLyBUaGlzIGlzIG5vdCBhbiBpc3N1ZSBmb3IgZmFzdCBhbmltYXRpb25zIChhbmQgcHJldmVudHMgYWNjaWRlbnRpYWwgZG91YmxlIHRhcHBpbmcpXG4gICAgICAvLyBJZGVhbGx5IHRoZSBVSSBpcyBmdWxseSByZXBzb25zaXZlIGF0IGFsbCB0aW1lcyB0aG91Z2guLlxuICAgICAgLy8gTm90ZSB0aGF0IHNwYW1taW5nIHRoZSBiYWNrL2ZvcndhcmQgYnV0dG9uIGlzIHN0aWxsIHBvc3NpYmxlIChvbmx5IGFmZmVjdHMgYHB1c2gkYClcbiAgICAgIC50aHJvdHRsZVRpbWUodGhpcy5kdXJhdGlvbiArIDEwMCk7XG5cbiAgICBjb25zdCBwb3AkID0gdGhpcy5iaW5kUG9wc3RhdGVFdmVudCgpO1xuXG4gICAgLy8gRGVmaW5pdGl2ZSBwYWdlIGNoYW5nZSAoaS5lLiBlaXRoZXIgcHVzaCBvciBwb3AgZXZlbnQpXG4gICAgdGhpcy5wYWdlJCA9IE9ic2VydmFibGUubWVyZ2UocHVzaCQsIHBvcCQpLnNoYXJlKCk7XG5cbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIHByZWZldGNoIChpLmUuIHVzZSBiYW5kd2lkdGgpIGZvciBhIF9wcm9iYWJpbGlzdGljXyBwYWdlIGxvYWQsXG4gICAgLy8gd2hpbGUgYSBfZGVmaW5pdGl2ZV8gcGFnZSBsb2FkIGlzIGdvaW5nIG9uID0+IGBwYXVzZXIkYCBzdHJlYW0uXG4gICAgLy8gTmVlZHMgdG8gYmUgZGVmZXJyZWQgYi9jIG9mIFwiY3ljbGljYWxcIiBkZXBlbmRlbmN5LlxuICAgIGNvbnN0IHBhdXNlciQgPSBPYnNlcnZhYmxlLmRlZmVyKCgpID0+XG4gICAgICBPYnNlcnZhYmxlLm1lcmdlKFxuICAgICAgICAvLyBBIHBhZ2UgY2hhbmdlIGV2ZW50IG1lYW5zIHdlIHdhbnQgdG8gcGF1c2UgcHJlZmV0Y2hpbmdcbiAgICAgICAgdGhpcy5wYWdlJC5tYXAoKCkgPT4gdHJ1ZSksXG4gICAgICAgIC8vIEEgcmVuZGVyIGNvbXBsZXRlIGV2ZW50IG1lYW5zIHdlIHdhbnQgdG8gcmVzdW1lIHByZWZldGNoaW5nXG4gICAgICAgIHRoaXMucmVuZGVyJC5tYXAoKCkgPT4gZmFsc2UpLFxuICAgICAgKVxuICAgICAgICAvLyBTdGFydCB3aXRoIHByZWZldGNoaW5nXG4gICAgICAgIC5zdGFydFdpdGgoZmFsc2UpLFxuICAgICk7XG5cbiAgICAvLyBUaGUgc3RyZWFtIG9mIGhpbnQgKHByZWZldGNoKSBldmVudHMsIHBvc3NpYmx5IHBhdXNlZC5cbiAgICAvLyBEcmVhbSBzeW50YXggKG5vdCBzdXBwb3J0ZWQsIHlldCk6IGB0aGlzLmhpbnQkJC5zd2l0Y2goKS5wYXVzZWFibGUocGF1c2VyJClgXG4gICAgdGhpcy5oaW50JCA9IHRoaXMuaGludCQkLnN3aXRjaCgpXG4gICAgICAud2l0aExhdGVzdEZyb20ocGF1c2VyJClcbiAgICAgIC5maWx0ZXIoKFssIHBhdXNlZF0pID0+IHBhdXNlZCA9PT0gZmFsc2UpXG4gICAgICAubWFwKChbeF0pID0+IHgpO1xuXG4gICAgLy8gVGhlIHN0cmVhbSBvZiAocHJlLSlmZXRjaCBldmVudHMuXG4gICAgLy8gSW5jbHVkZXMgZGVmaW5pdGl2ZSBwYWdlIGNoYW5nZSBldmVudHMgZG8gZGVhbCB3aXRoIHVuZXhwZWN0ZWQgcGFnZSBjaGFuZ2VzLlxuICAgIHRoaXMucHJlZmV0Y2gkID0gT2JzZXJ2YWJsZS5tZXJnZSh0aGlzLmhpbnQkLCB0aGlzLnBhZ2UkKVxuICAgICAgLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKCdocmVmJykgLy8gRG9uJ3QgYWJvcnQgYSByZXF1ZXN0IGlmIHRoZSB1c2VyIFwiamlnZ2xlc1wiIG92ZXIgYSBsaW5rXG4gICAgICAuc3dpdGNoTWFwKGtpbmQgPT4gdGhpcy5mZXRjaFBhZ2Uoa2luZCkpXG4gICAgICAuY2F0Y2goKGVyciwgY2F1Z2h0KSA9PiBjYXVnaHQpXG4gICAgICAuc3RhcnRXaXRoKHt9KSAvLyBTdGFydCB3aXRoIHNvbWUgdmFsdWUgc28gYHdpdGhMYXRlc3RGcm9tYCBiZWxvdyBkb2Vzbid0IFwiYmxvY2tcIlxuICAgICAgLnNoYXJlKCk7XG5cbiAgICB0aGlzLnJlbmRlciQgPSB0aGlzLnBhZ2UkXG4gICAgICAuZG8odGhpcy5vblN0YXJ0LmJpbmQodGhpcykpXG4gICAgICAud2l0aExhdGVzdEZyb20odGhpcy5wcmVmZXRjaCQpXG4gICAgICAuc3dpdGNoTWFwKHRoaXMuZ2V0UmVzcG9uc2UuYmluZCh0aGlzKSlcbiAgICAgIC5tYXAodGhpcy5yZXNwb25zZVRvQ29udGVudC5iaW5kKHRoaXMpKVxuICAgICAgLmRvKHRoaXMub25SZWFkeS5iaW5kKHRoaXMpKVxuICAgICAgLmRvKHRoaXMudXBkYXRlRE9NLmJpbmQodGhpcykpXG4gICAgICAuZG8odGhpcy5yZXNldFNjcm9sbFBvc3Rpb24uYmluZCh0aGlzKSlcbiAgICAgIC5kbyh0aGlzLm9uQWZ0ZXIuYmluZCh0aGlzKSlcbiAgICAgIC5jYXRjaCgoZXJyb3IsIGNhdWdodCkgPT4ge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gY2F1Z2h0O1xuICAgICAgfSlcbiAgICAgIC8vIGBzaGFyZWBpbmcgdGhlIHN0cmVhbSBiZXR3ZWVuIHRoZSBzdWJzY3JpcHRpb24gYmVsb3cgYW5kIGBwYXVzZXIkYC5cbiAgICAgIC5zaGFyZSgpO1xuXG4gICAgdGhpcy5yZW5kZXIkXG4gICAgICAvLyBSZW5ld2luZyBldmVudCBsaXN0ZW5lcnMgYWZ0ZXIgRE9NIHVwZGF0ZS9sYXlvdXQvcGFpbnRpbmcgaXMgY29tcGxldGVcbiAgICAgIC8vIEhBQ0s6IGRvbid0IHVzZSB0aW1lLCB1c2Ugb3V0c2lkZSBvYnNlcnZhYmxlIGluc3RlYWQ/XG4gICAgICAuZGVib3VuY2VUaW1lKHRoaXMuZHVyYXRpb24pXG4gICAgICAuZG8odGhpcy5yZW5ld0V2ZW50TGlzdGVuZXJzLmJpbmQodGhpcykpXG4gICAgICAuc3Vic2NyaWJlKCk7XG5cbiAgICAvLyBmaXJlIGBwcm9ncmVzc2AgZXZlbnQgd2hlbiBmZXRjaGluZyB0YWtlcyBsb25nZXIgdGhhbiBgdGhpcy5kdXJhdGlvbmAuXG4gICAgdGhpcy5wYWdlJFxuICAgICAgLy8gSEFDSzogYWRkIHNvbWUgdGltZSwganRic1xuICAgICAgLnN3aXRjaE1hcCgoKSA9PiBPYnNlcnZhYmxlLnRpbWVyKHRoaXMuZHVyYXRpb24gKyAyMDApLnRha2VVbnRpbCh0aGlzLnJlbmRlciQpKVxuICAgICAgLnN1YnNjcmliZSh0aGlzLm9uUHJvZ3Jlc3MuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBTdGFydCBwdWxsaW5nIHZhbHVlc1xuICAgIHRoaXMucmVuZGVyJC5zdWJzY3JpYmUoKTtcblxuICAgIC8vIFB1c2ggc3RyZWFtcyBpbnRvIGBwdXNoJCRgIGFuZCBgaGludCQkYFxuICAgIHRoaXMucmVuZXdFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgZ2V0UmVzcG9uc2UoW2tpbmQsIHByZWZldGNoXSkge1xuICAgIGxldCByZXM7XG5cbiAgICAvLyBQcmVmZXRjaCBhbHJlYWR5IGNvbXBsZXRlLCB1c2UgcmVzdWx0XG4gICAgaWYgKGtpbmQuaHJlZiA9PT0gcHJlZmV0Y2guaHJlZikge1xuICAgICAgcmVzID0gT2JzZXJ2YWJsZS5vZihPYmplY3QuYXNzaWduKGtpbmQsIHsgcmVzcG9uc2U6IHByZWZldGNoLnJlc3BvbnNlIH0pKTtcblxuICAgICAgaWYgKGtpbmQgaW5zdGFuY2VvZiBQdXNoIHx8ICF0aGlzLm5vUG9wRHVyYXRpb24pIHtcbiAgICAgICAgLy8gSEFDSzogYWRkIHNvbWUgZXh0cmEgdGltZSB0byBwcmV2ZW50ICdmbGlja2VyaW5nJ1xuICAgICAgICAvLyBpZGVhbGx5LCB3ZSdkIGxpa2UgdG8gdGFrZSBhbiBhbmltYXRpb24gb2JzZXJ2YWJsZSBhcyBpbnB1dCBpbnN0ZWFkXG4gICAgICAgIHJlcyA9IHJlcy5kZWxheSh0aGlzLmR1cmF0aW9uICsgMTAwKTtcbiAgICAgIH1cbiAgICAvLyBQcmVmZXRjaCBpbiBwcm9ncmVzcywgdXNlIG5leHQgcmVzdWx0ICh0aGlzIGlzIHdoeSBgcHJlZmV0Y2gkYCBoYWQgdG8gYmUgYHNoYXJlYGQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHRoaXMucHJlZmV0Y2gkLnRha2UoMSlcbiAgICAgICAgLm1hcChmZXRjaCA9PiBPYmplY3QuYXNzaWduKGtpbmQsIHsgcmVzcG9uc2U6IGZldGNoLnJlc3BvbnNlIH0pKTtcblxuICAgICAgaWYgKGtpbmQgaW5zdGFuY2VvZiBQdXNoIHx8ICF0aGlzLm5vUG9wRHVyYXRpb24pIHtcbiAgICAgICAgLy8gSEFDSzogYWRkIHNvbWUgZXh0cmEgdGltZSB0byBwcmV2ZW50ICdmbGlja2VyaW5nJ1xuICAgICAgICAvLyBpZGVhbGx5LCB3ZSdkIGxpa2UgdG8gdGFrZSBhbiBhbmltYXRpb24gb2JzZXJ2YWJsZSBhcyBpbnB1dCBpbnN0ZWFkXG4gICAgICAgIHJlcyA9IHJlcy56aXAoT2JzZXJ2YWJsZS50aW1lcih0aGlzLmR1cmF0aW9uICsgMTAwKSwgeCA9PiB4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgb25TdGFydChzcG9uZ2UpIHtcbiAgICBjb25zdCB7IGhyZWYgfSA9IHNwb25nZTtcblxuICAgIGlmIChzcG9uZ2UgaW5zdGFuY2VvZiBQdXNoKSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoeyBpZDogdGhpcy5jb21wb25lbnROYW1lIH0sICcnLCBocmVmKTtcbiAgICB9XG5cbiAgICB0aGlzLmZpcmVFdmVudCgnc3RhcnQnLCB7IGRldGFpbDogc3BvbmdlIH0pO1xuICB9XG5cbiAgb25Qcm9ncmVzcyhzcG9uZ2UpIHtcbiAgICB0aGlzLmZpcmVFdmVudCgncHJvZ3Jlc3MnLCB7IGRldGFpbDogc3BvbmdlIH0pO1xuICB9XG5cbiAgcmVzcG9uc2VUb0NvbnRlbnQoc3BvbmdlKSB7XG4gICAgY29uc3QgeyByZXNwb25zZSB9ID0gc3BvbmdlO1xuXG4gICAgY29uc3QgZG9jdW1lbnRGcmFnbWVudCA9IGZyYWdtZW50RnJvbVN0cmluZyhyZXNwb25zZSk7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLmdldFRpdGxlRnJvbURvY3VtZW50RnJhZ21lbnQoZG9jdW1lbnRGcmFnbWVudCk7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudEZyb21Eb2N1bWVudEZyYWdtZW50KGRvY3VtZW50RnJhZ21lbnQpO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3BvbmdlLCB7IHRpdGxlLCBjb250ZW50IH0pO1xuICB9XG5cbiAgb25SZWFkeShzcG9uZ2UpIHtcbiAgICB0aGlzLmZpcmVFdmVudCgncmVhZHknLCB7IGRldGFpbDogc3BvbmdlIH0pO1xuICB9XG5cbiAgdXBkYXRlRE9NKHNwb25nZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGhyZWYsIHRpdGxlLCBjb250ZW50IH0gPSBzcG9uZ2U7XG5cbiAgICAgIGlmIChzcG9uZ2UgaW5zdGFuY2VvZiBQdXNoKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGlkOiB0aGlzLmNvbXBvbmVudE5hbWUgfSwgdGl0bGUsIGhyZWYpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRpdGxlRWxlbWVudC50ZXh0Q29udGVudCA9IHRpdGxlO1xuICAgICAgdGhpcy5yZXBsYWNlQ29udGVudChjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihzcG9uZ2UsIHsgZXJyb3IgfSk7XG4gICAgfVxuICB9XG5cbiAgb25BZnRlcihzcG9uZ2UpIHtcbiAgICB0aGlzLmZpcmVFdmVudCgnYWZ0ZXInLCB7IGRldGFpbDogc3BvbmdlIH0pO1xuICB9XG5cbiAgcmVuZXdFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCBsaW5rJCA9IHRoaXMubGlua09ic2VydmFibGUoKTtcbiAgICB0aGlzLnB1c2gkJC5uZXh0KHRoaXMuYmluZFB1c2hFdmVudHMobGluayQpKTtcbiAgICB0aGlzLmhpbnQkJC5uZXh0KHRoaXMuYmluZEhpbnRFdmVudHMobGluayQpKTtcbiAgfVxuXG4gIG9uRXJyb3IoZXJyKSB7XG4gICAgdGhpcy5lbC5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gICAgdGhpcy5maXJlRXZlbnQoJ2Vycm9yJywgeyBkZXRhaWw6IGVyciB9KTtcbiAgfVxuXG4gIG9uUmV0cnkoa2luZCkge1xuICAgIHRoaXMuZmlyZUV2ZW50KCdyZXRyeScsIHsgZGV0YWlsOiBraW5kIH0pO1xuICB9XG5cbiAgaXNQYWdlQ2hhbmdlRXZlbnQoa2luZCkge1xuICAgIGNvbnN0IHsgZXZlbnQgfSA9IGtpbmQ7XG4gICAgcmV0dXJuIChcbiAgICAgICFldmVudC5tZXRhS2V5ICYmXG4gICAgICAhZXZlbnQuY3RybEtleSAmJlxuICAgICAgdGhpcy5pc1BhZ2VDaGFuZ2VBbmNob3Ioa2luZClcbiAgICApO1xuICB9XG5cbiAgaXNQYWdlQ2hhbmdlQW5jaG9yKHsgZXZlbnQ6IHsgY3VycmVudFRhcmdldDogYW5jaG9yIH0gfSkge1xuICAgIHJldHVybiAoXG4gICAgICBhbmNob3IgIT0gbnVsbCAmJlxuICAgICAgc2hvdWxkTG9hZEFuY2hvcihhbmNob3IsIHRoaXMuYmxhY2tsaXN0LCB0aGlzLmhyZWZSZWdleClcbiAgICApO1xuICB9XG5cbiAgZ2V0VGl0bGVGcm9tRG9jdW1lbnRGcmFnbWVudChkb2N1bWVudEZyYWdtZW50KSB7XG4gICAgcmV0dXJuIChkb2N1bWVudEZyYWdtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RpdGxlJykgfHwge30pLnRleHRDb250ZW50O1xuICB9XG5cbiAgZ2V0Q29udGVudEZyb21Eb2N1bWVudEZyYWdtZW50KGRvY3VtZW50RnJhZ21lbnQpIHtcbiAgICBpZiAodGhpcy5yZXBsYWNlSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VJZHMubWFwKGlkID0+IGRvY3VtZW50RnJhZ21lbnQucXVlcnlTZWxlY3RvcihgIyR7aWR9YCkpO1xuICAgIH1cblxuICAgIHJldHVybiBkb2N1bWVudEZyYWdtZW50LnF1ZXJ5U2VsZWN0b3IoYCMke3RoaXMuZWwuaWR9YCk7XG4gIH1cblxuICByZXBsYWNlQ29udGVudChjb250ZW50KSB7XG4gICAgaWYgKHRoaXMucmVwbGFjZUlkcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnJlcGxhY2VDb250ZW50QnlJZHMoY29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVwbGFjZUNvbnRlbnRXaG9sZXNhbGUoY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgcmVwbGFjZUNvbnRlbnRCeUlkcyhlbGVtZW50cykge1xuICAgIGNvbnN0IG9sZEVsZW1lbnRzID0gdGhpcy5yZXBsYWNlSWRzXG4gICAgICAubWFwKGlkID0+IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSk7XG5cbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG9sZEVsZW1lbnRzLCAob2xkRWxlbWVudCkgPT4ge1xuICAgICAgb2xkRWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChlbGVtZW50cy5zaGlmdCgpLCBvbGRFbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlcGxhY2VDb250ZW50V2hvbGVzYWxlKGNvbnRlbnQpIHtcbiAgICB0aGlzLmVsLmlubmVySFRNTCA9IGNvbnRlbnQuaW5uZXJIVE1MO1xuICB9XG5cbiAgc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3RhdGUsIHtcbiAgICAgIHNjcm9sbFRvcDogZ2V0U2Nyb2xsVG9wKCksXG4gICAgICBzY3JvbGxIZWlnaHQ6IGdldFNjcm9sbEhlaWdodCgpLFxuICAgIH0pO1xuICB9XG5cbiAgdXBkYXRlSGlzdG9yeVN0YXRlKCkge1xuICAgIGxldCBzdGF0ZSA9IGhpc3Rvcnkuc3RhdGUgfHwgeyBpZDogdGhpcy5jb21wb25lbnROYW1lIH07XG4gICAgc3RhdGUgPSB0aGlzLnNjcm9sbFJlc3RvcmF0aW9uID8gdGhpcy5zYXZlU2Nyb2xsUG9zaXRpb24oc3RhdGUpIDogc3RhdGU7XG4gICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIGRvY3VtZW50LnRpdGxlLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gIH1cblxuICBzZXRTY3JvbGxQb3NpdGlvbigpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGhpc3Rvcnkuc3RhdGUgfHwge307XG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5taW5IZWlnaHQgPSBgJHtzdGF0ZS5zY3JvbGxIZWlnaHQgfHwgMH1weGA7XG4gICAgaWYgKHN0YXRlLnNjcm9sbFRvcCAhPSBudWxsKSB3aW5kb3cuc2Nyb2xsKHdpbmRvdy5wYWdlWE9mZnNldCwgc3RhdGUuc2Nyb2xsVG9wKTtcbiAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm1pbkhlaWdodCA9ICcnO1xuICB9XG5cbiAgcmVzZXRTY3JvbGxQb3N0aW9uKHNwb25nZSkge1xuICAgIGlmICh0aGlzLnNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICBpZiAoc3BvbmdlIGluc3RhbmNlb2YgUG9wKSB7XG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG4iLCIvLyBDb3B5cmlnaHQgKGMpIDIwMTcgRmxvcmlhbiBLbGFtcGZlclxuLy8gTGljZW5zZWQgdW5kZXIgTUlUXG5cbmV4cG9ydCBjbGFzcyBLaW5kIHtcbiAgY29uc3RydWN0b3IoZXZlbnQpIHtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFB1c2ggZXh0ZW5kcyBLaW5kIHtcbiAgY29uc3RydWN0b3IoZXZlbnQpIHtcbiAgICBzdXBlcihldmVudCk7XG4gICAgdGhpcy5ocmVmID0gZXZlbnQuY3VycmVudFRhcmdldC5ocmVmO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7IHJldHVybiAncHVzaCc7IH1cbn1cblxuZXhwb3J0IGNsYXNzIEhpbnQgZXh0ZW5kcyBLaW5kIHtcbiAgY29uc3RydWN0b3IoZXZlbnQpIHtcbiAgICBzdXBlcihldmVudCk7XG4gICAgdGhpcy5ocmVmID0gZXZlbnQuY3VycmVudFRhcmdldC5ocmVmO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7IHJldHVybiAnaGludCc7IH1cbn1cblxuZXhwb3J0IGNsYXNzIFBvcCBleHRlbmRzIEtpbmQge1xuICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgIHN1cGVyKGV2ZW50KTtcbiAgICB0aGlzLmhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgfVxuXG4gIGdldCB0eXBlKCkgeyByZXR1cm4gJ3BvcCc7IH1cbn1cbiIsIi8vIENvcHlyaWdodCAoYykgMjAxNyBGbG9yaWFuIEtsYW1wZmVyXG4vLyBMaWNlbnNlZCB1bmRlciBNSVRcblxuaW1wb3J0IHB1c2hTdGF0ZUNvcmUgZnJvbSAnLi4vY29yZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1c2hTdGF0ZSBleHRlbmRzIHB1c2hTdGF0ZUNvcmUoKSB7XG4gIGNvbnN0cnVjdG9yKGVsLCBwcm9wcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zZXR1cENvbXBvbmVudChlbCwgcHJvcHMpO1xuICB9XG5cbiAgLy8gQG92ZXJyaWRlXG4gIHNldHVwRE9NKGVsKSB7XG4gICAgaWYgKCFlbCkgdGhyb3cgRXJyb3IoJ05vIGVsZW1lbnQgcHJvdmlkZWQnKTtcbiAgICByZXR1cm4gZWw7XG4gIH1cbn1cbiJdfQ==
