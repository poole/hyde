{"version":3,"sources":["webpack:///ts_src/Patch/Native.ts","webpack:///ts_src/Utilities.ts","webpack:///ts_src/CustomElementInternals.ts","webpack:///ts_src/custom-elements.ts","webpack:///ts_src/Deferred.ts","webpack:///ts_src/DocumentConstructionObserver.ts","webpack:///ts_src/CustomElementRegistry.ts","webpack:///ts_src/Patch/Interface/ParentNode.ts","webpack:///ts_src/Patch/Document.ts","webpack:///ts_src/Patch/Interface/ChildNode.ts","webpack:///ts_src/Patch/Element.ts","webpack:///ts_src/CustomElementState.ts","webpack:///ts_src/AlreadyConstructedMarker.ts","webpack:///ts_src/Patch/HTMLElement.ts","webpack:///ts_src/Patch/Node.ts","webpack:///ts_src/Patch/DocumentFragment.ts"],"names":["Document_createElement","window","Document_createElementNS","Document_importNode","Document_prepend","Document_append","DocumentFragment_prepend","DocumentFragment_append","Node_cloneNode","Node_appendChild","Node_insertBefore","Node_removeChild","Node_replaceChild","Node_textContent","Element_attachShadow","Element_innerHTML","Object","Element_getAttribute","Element_setAttribute","Element_removeAttribute","Element_getAttributeNS","Element_setAttributeNS","Element_removeAttributeNS","Element_insertAdjacentElement","Element_insertAdjacentHTML","Element_prepend","Element_append","Element_before","Element_after","Element_replaceWith","Element_remove","HTMLElement","HTMLElement_innerHTML","HTMLElement_insertAdjacentElement","HTMLElement_insertAdjacentHTML","reservedElementNameSet","Set","isValidCustomElementName","reserved","validForm","nativeContains","document","isConnected","nativeValue","node","undefined","current","childrenFromFragment","nativeChildren","fragment","Array","children","n","Node","nextSiblingOrAncestorSibling","walkDeepDescendantElements","root","element","callback","localName","importNode","visitedImports","child","shadowRoot","firstChild","CustomElementInternals","noDocumentConstructionObserver","priorCustomElements","shadyDomFastWalk","forEachElement","sd","querySelectorAll","elements","i","addNodePatch","addElementPatch","patchTree","patchElement","__CE_patched","connectTree","upgradeReaction","disconnectTree","patchAndUpgradeTree","options","upgrade","gatherElements","_hasPatches","import","__CE_documentLoadHandled","clonedVisitedImports","ownerDocument","registry","doc","internal_localNameToDefinition","definition","__CE_state","constructionStack","result","constructorFunction","Error","e","__CE_definition","attributeChangedCallback","hasAttributes","observedAttributes","name","value","getAttribute","_upgradeAnElement","connectedCallback","reportTheException","NS_HTML","call","HTMLUnknownElement","message","error","filename","lineno","colno","event","ErrorEvent","cancelable","event.preventDefault","configurable","get","enumerable","console","Deferred","constructor","DocumentConstructionObserver","internals","childList","subtree","disconnect","readyState","mutations","addedNodes","j","CustomElementRegistry","Map","this._flushCallback","constructorGetter","internal_assertCanDefineLocalName","internal_reifyDefinition","prototype","getCallback","callbackValue","disconnectedCallback","adoptedCallback","elementsWithStableDefinitions","unflushedLocalNames","elementsWithPendingDefinitions","pendingElements","_localNameToDefinition","pendingUpgradableElements","deferred","Promise","prior","_promise","anyDefinitionExists","definitionHasFlushed","inner","existingDefinition","appendPrependPatch","flattenedNodes","connectedElements","length","builtInMethod","builtIn","destination","Document","Document.prototype.createElement","createAnElement","Document.prototype.importNode","clone","Document.prototype.createElementNS","PatchParentNode","prepend","append","beforeAfterPatch","Element","destination.replaceWith","wasConnected","apply","destination.remove","patch_innerHTML","baseDescriptor","set","removedElements","custom","patch_insertAdjacentElement","destination.insertAdjacentElement","insertedElement","baseMethod","patch_insertAdjacentHTML","upgradeNodesInRange","nodes","destination.insertAdjacentHTML","strPosition","position","marker","String","Element.prototype.attachShadow","_patchesNode","isTemplate","content","rawElement","assignedValue","container","Element.prototype.setAttribute","oldValue","newValue","Element.prototype.setAttributeNS","Element.prototype.removeAttribute","Element.prototype.removeAttributeNS","PatchChildNode","alreadyConstructedMarker","PatchedHTMLElement","_constructorToDefinition","lastIndex","setPrototypeOf","writable","patch_textContent","removedNodes","childNodes","childNodesLength","Node.prototype.insertBefore","insertedNodes","nativeResult","nodeWasConnectedElement","Node.prototype.appendChild","Node.prototype.cloneNode","Node.prototype.removeChild","Node.prototype.replaceChild","nodeToInsert","nodeToInsertWasConnectedElement","thisIsConnected","parts","installPolyfill","PatchHTMLElement","PatchDocument","DocumentFragment","PatchNode","PatchElement","customElements"],"mappings":"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","file":"vendors~webcomponents-hydejack-9.0.0-rc.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nexport const Document_createElement = window.Document.prototype.createElement;\nexport const Document_createElementNS =\n    window.Document.prototype.createElementNS;\nexport const Document_importNode = window.Document.prototype.importNode;\n\nexport const Document_prepend = window.Document.prototype['prepend'];\nexport const Document_append = window.Document.prototype['append'];\nexport const DocumentFragment_prepend =\n    window.DocumentFragment.prototype['prepend'];\nexport const DocumentFragment_append =\n    window.DocumentFragment.prototype['append'];\nexport const Node_cloneNode = window.Node.prototype.cloneNode;\nexport const Node_appendChild = window.Node.prototype.appendChild;\nexport const Node_insertBefore = window.Node.prototype.insertBefore;\nexport const Node_removeChild = window.Node.prototype.removeChild;\nexport const Node_replaceChild = window.Node.prototype.replaceChild;\nexport const Node_textContent =\n    Object.getOwnPropertyDescriptor(window.Node.prototype, 'textContent');\nexport const Element_attachShadow = window.Element.prototype['attachShadow'];\nexport const Element_innerHTML =\n    Object.getOwnPropertyDescriptor(window.Element.prototype, 'innerHTML');\nexport const Element_getAttribute = window.Element.prototype.getAttribute;\nexport const Element_setAttribute = window.Element.prototype.setAttribute;\nexport const Element_removeAttribute = window.Element.prototype.removeAttribute;\nexport const Element_getAttributeNS = window.Element.prototype.getAttributeNS;\nexport const Element_setAttributeNS = window.Element.prototype.setAttributeNS;\nexport const Element_removeAttributeNS =\n    window.Element.prototype.removeAttributeNS;\nexport const Element_insertAdjacentElement =\n    window.Element.prototype['insertAdjacentElement'];\nexport const Element_insertAdjacentHTML =\n    window.Element.prototype['insertAdjacentHTML'];\nexport const Element_prepend = window.Element.prototype['prepend'];\nexport const Element_append = window.Element.prototype['append'];\nexport const Element_before = window.Element.prototype['before'];\nexport const Element_after = window.Element.prototype['after'];\nexport const Element_replaceWith = window.Element.prototype['replaceWith'];\nexport const Element_remove = window.Element.prototype['remove'];\nexport const HTMLElement = window.HTMLElement;\nexport const HTMLElement_innerHTML =\n    Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, 'innerHTML');\nexport const HTMLElement_insertAdjacentElement =\n    window.HTMLElement.prototype['insertAdjacentElement'];\nexport const HTMLElement_insertAdjacentHTML =\n    window.HTMLElement.prototype['insertAdjacentHTML'];\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport {HTMLImportElement} from './Externs.js';\n\nconst reservedElementNameSet = new Set<string>();\n// IE11 does not support constructing a set using an iterable.\n['annotation-xml',\n 'color-profile',\n 'font-face',\n 'font-face-src',\n 'font-face-uri',\n 'font-face-format',\n 'font-face-name',\n 'missing-glyph',\n].forEach(item => reservedElementNameSet.add(item));\n\nexport function isValidCustomElementName(localName: string) {\n  const reserved = reservedElementNameSet.has(localName);\n  const validForm = /^[a-z][.0-9_a-z]*-[-.0-9_a-z]*$/.test(localName);\n  return !reserved && validForm;\n}\n\n// Note, IE11 doesn't have `document.contains`.\nconst nativeContains = document.contains ?\n    document.contains.bind(document) :\n    document.documentElement.contains.bind(document.documentElement);\n\nexport function isConnected(node: Node) {\n  // Use `Node#isConnected`, if defined.\n  const nativeValue = node.isConnected;\n  if (nativeValue !== undefined) {\n    return nativeValue;\n  }\n  // Optimization: It's significantly faster here to try to use `contains`,\n  // especially on Edge/IE/\n  if (nativeContains(node)) {\n    return true;\n  }\n\n  let current: Node|undefined = node;\n  while (current &&\n         !(current.__CE_isImportDocument || current instanceof Document)) {\n    current = current.parentNode ||\n        (window.ShadowRoot && current instanceof ShadowRoot ? current.host :\n                                                              undefined);\n  }\n  return !!(\n      current &&\n      (current.__CE_isImportDocument || current instanceof Document));\n}\n\nexport function childrenFromFragment(fragment: DocumentFragment): Array<Element> {\n  // Note, IE doesn't have `children` on document fragments.\n  const nativeChildren = fragment.children;\n  if (nativeChildren) {\n    return Array.prototype.slice.call(nativeChildren);\n  }\n  const children: Array<Element> = [];\n  for (let n = fragment.firstChild; n; n = n.nextSibling) {\n    if (n.nodeType === Node.ELEMENT_NODE) {\n      children.push(n as Element);\n    }\n  }\n  return children;\n}\n\nfunction nextSiblingOrAncestorSibling(root: Node, start: Node) {\n  let node: Node|null = start;\n  while (node && node !== root && !node.nextSibling) {\n    node = node.parentNode;\n  }\n  return (!node || node === root) ? null : node.nextSibling;\n}\n\n\nfunction nextNode(root: Node, start: Node) {\n  return start.firstChild ? start.firstChild :\n                            nextSiblingOrAncestorSibling(root, start);\n}\n\nexport function walkDeepDescendantElements(\n    root: Node, callback: (elem: Element) => void, visitedImports?: Set<Node>) {\n  let node: Node|null = root;\n  while (node) {\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      const element = node as Element;\n\n      callback(element);\n\n      const localName = element.localName;\n      if (localName === 'link' && element.getAttribute('rel') === 'import') {\n        // If this import (polyfilled or not) has its root node available,\n        // walk it.\n        const importNode = (element as HTMLImportElement).import;\n        if (visitedImports === undefined) {\n          visitedImports = new Set();\n        }\n        if (importNode instanceof Node && !visitedImports.has(importNode)) {\n          // Prevent multiple walks of the same import root.\n          visitedImports.add(importNode);\n\n          for (let child = importNode.firstChild; child;\n               child = child.nextSibling) {\n            walkDeepDescendantElements(child, callback, visitedImports);\n          }\n        }\n\n        // Ignore descendants of import links to prevent attempting to walk the\n        // elements created by the HTML Imports polyfill that we just walked\n        // above.\n        node = nextSiblingOrAncestorSibling(root, element);\n        continue;\n      } else if (localName === 'template') {\n        // Ignore descendants of templates. There shouldn't be any descendants\n        // because they will be moved into `.content` during construction in\n        // browsers that support template but, in case they exist and are still\n        // waiting to be moved by a polyfill, they will be ignored.\n        node = nextSiblingOrAncestorSibling(root, element);\n        continue;\n      }\n\n      // Walk shadow roots.\n      const shadowRoot = element.__CE_shadowRoot;\n      if (shadowRoot) {\n        for (let child = shadowRoot.firstChild; child;\n             child = child.nextSibling) {\n          walkDeepDescendantElements(child, callback, visitedImports);\n        }\n      }\n    }\n\n    node = nextNode(root, node);\n  }\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport './Externs.js';\nimport {CustomElementState as CEState} from './CustomElementState.js';\nimport {CustomElementDefinition, HTMLImportElement} from './Externs.js';\nimport * as Native from './Patch/Native.js';\nimport * as Utilities from './Utilities.js';\n\nconst NS_HTML = 'http://www.w3.org/1999/xhtml';\n\nexport default class CustomElementInternals {\n  private readonly _patchesNode: Array<(node: Node) => void> = [];\n  private readonly _patchesElement: Array<(elem: Element) => void> = [];\n  private _hasPatches = false;\n  public readonly shadyDomFastWalk: boolean;\n  public readonly useDocumentConstructionObserver: boolean;\n\n  constructor(options: {\n    shadyDomFastWalk: boolean,\n    noDocumentConstructionObserver: boolean\n  }) {\n    this.shadyDomFastWalk = options.shadyDomFastWalk;\n    this.useDocumentConstructionObserver =\n        !options.noDocumentConstructionObserver;\n  }\n\n  forEachElement(\n      node: Node, callback: (elem: Element) => void,\n      visitedImports?: Set<Node>) {\n    const sd = window['ShadyDom'];\n    if (this.shadyDomFastWalk && sd && sd['inUse']) {\n      if (node.nodeType === Node.ELEMENT_NODE) {\n        const element = node as Element;\n        callback(element);\n      }\n      // most easily gets to document, element, documentFragment\n      if ((node as Element).querySelectorAll!) {\n        const elements = sd['nativeMethods'].querySelectorAll.call(node, '*');\n        for (let i = 0; i < elements.length; i++) {\n          callback(elements[i]);\n        }\n      }\n    } else {\n      Utilities.walkDeepDescendantElements(node, callback, visitedImports);\n    }\n  }\n\n  addNodePatch(patch: (node: Node) => void) {\n    this._hasPatches = true;\n    this._patchesNode.push(patch);\n  }\n\n  addElementPatch(patch: (element: Element) => void) {\n    this._hasPatches = true;\n    this._patchesElement.push(patch);\n  }\n\n  patchTree(node: Node) {\n    if (!this._hasPatches) {\n      return;\n    }\n\n    this.forEachElement(node, element => this.patchElement(element));\n  }\n\n  patchNode(node: Node) {\n    if (!this._hasPatches) {\n      return;\n    }\n\n    if (node.__CE_patched) {\n      return;\n    }\n    node.__CE_patched = true;\n\n    for (let i = 0; i < this._patchesNode.length; i++) {\n      this._patchesNode[i](node);\n    }\n  }\n\n  patchElement(element: Element) {\n    if (!this._hasPatches) {\n      return;\n    }\n\n    if (element.__CE_patched) {\n      return;\n    }\n    element.__CE_patched = true;\n\n    for (let i = 0; i < this._patchesNode.length; i++) {\n      this._patchesNode[i](element);\n    }\n\n    for (let i = 0; i < this._patchesElement.length; i++) {\n      this._patchesElement[i](element);\n    }\n  }\n\n  connectTree(root: Node) {\n    const elements: Array<Element> = [];\n\n    this.forEachElement(root, element => elements.push(element));\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (element.__CE_state === CEState.custom) {\n        this.connectedCallback(element);\n      } else {\n        this.upgradeReaction(element as HTMLElement);\n      }\n    }\n  }\n\n  disconnectTree(root: Node) {\n    const elements: Array<Element> = [];\n\n    this.forEachElement(root, element => elements.push(element));\n\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      if (element.__CE_state === CEState.custom) {\n        this.disconnectedCallback(element);\n      }\n    }\n  }\n\n  /**\n   * Upgrades all uncustomized custom elements at and below a root node for\n   * which there is a definition. When custom element reaction callbacks are\n   * assumed to be called synchronously (which, by the current DOM / HTML spec\n   * definitions, they are *not*), callbacks for both elements customized\n   * synchronously by the parser and elements being upgraded occur in the same\n   * relative order.\n   *\n   * NOTE: This function, when used to simulate the construction of a tree\n   * that is already created but not customized (i.e. by the parser), does\n   * *not* prevent the element from reading the 'final' (true) state of the\n   * tree. For example, the element, during truly synchronous parsing /\n   * construction would see that it contains no children as they have not yet\n   * been inserted. However, this function does not modify the tree, the\n   * element will (incorrectly) have children. Additionally, self-modification\n   * restrictions for custom element constructors imposed by the DOM spec are\n   * *not* enforced.\n   *\n   *\n   * The following nested list shows the steps extending down from the HTML\n   * spec's parsing section that cause elements to be synchronously created\n   * and upgraded:\n   *\n   * The \"in body\" insertion mode:\n   * https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n   * - Switch on token:\n   *   .. other cases ..\n   *   -> Any other start tag\n   *      - [Insert an HTML element](below) for the token.\n   *\n   * Insert an HTML element:\n   * https://html.spec.whatwg.org/multipage/syntax.html#insert-an-html-element\n   * - Insert a foreign element for the token in the HTML namespace:\n   *   https://html.spec.whatwg.org/multipage/syntax.html#insert-a-foreign-element\n   *   - Create an element for a token:\n   *     https://html.spec.whatwg.org/multipage/syntax.html#create-an-element-for-the-token\n   *     - Will execute script flag is true?\n   *       - (Element queue pushed to the custom element reactions stack.)\n   *     - Create an element:\n   *       https://dom.spec.whatwg.org/#concept-create-element\n   *       - Sync CE flag is true?\n   *         - Constructor called.\n   *         - Self-modification restrictions enforced.\n   *       - Sync CE flag is false?\n   *         - (Upgrade reaction enqueued.)\n   *     - Attributes appended to element.\n   *       (`attributeChangedCallback` reactions enqueued.)\n   *     - Will execute script flag is true?\n   *       - (Element queue popped from the custom element reactions stack.\n   *         Reactions in the popped stack are invoked.)\n   *   - (Element queue pushed to the custom element reactions stack.)\n   *   - Insert the element:\n   *     https://dom.spec.whatwg.org/#concept-node-insert\n   *     - Shadow-including descendants are connected. During parsing\n   *       construction, there are no shadow-*excluding* descendants.\n   *       However, the constructor may have validly attached a shadow\n   *       tree to itself and added descendants to that shadow tree.\n   *       (`connectedCallback` reactions enqueued.)\n   *   - (Element queue popped from the custom element reactions stack.\n   *     Reactions in the popped stack are invoked.)\n   */\n  patchAndUpgradeTree(root: Node, options: {\n    visitedImports?: Set<Node>,\n    upgrade?: (elem: HTMLElement) => void\n  } = {}) {\n    const visitedImports = options.visitedImports;\n    const upgrade =\n        options.upgrade || (element => this.upgradeReaction(element));\n\n    const elements: Array<Element> = [];\n\n    const gatherElements = (element: Element) => {\n      if (this._hasPatches) {\n        this.patchElement(element);\n      }\n      if (element.localName === 'link' &&\n          element.getAttribute('rel') === 'import') {\n        const importElem = element as HTMLImportElement;\n        // The HTML Imports polyfill sets a descendant element of the link to\n        // the `import` property, specifically this is *not* a Document.\n        const importNode = importElem.import;\n\n        if (importNode instanceof Node) {\n          importNode.__CE_isImportDocument = true;\n          // Connected links are associated with the global registry.\n          importNode.__CE_registry = document.__CE_registry;\n        }\n\n\n\n        if (importNode &&\n            (importNode as HTMLImportDocument).readyState === 'complete') {\n          importNode.__CE_documentLoadHandled = true;\n        } else {\n          // If this link's import root is not available, its contents can't\n          // be walked. Wait for 'load' and walk it when it's ready.\n          element.addEventListener('load', () => {\n            const importNode = importElem.import!;\n\n            if (importNode.__CE_documentLoadHandled) {\n              return;\n            }\n            importNode.__CE_documentLoadHandled = true;\n\n            // Clone the `visitedImports` set that was populated sync during\n            // the `patchAndUpgradeTree` call that caused this 'load' handler\n            // to be added. Then, remove *this* link's import node so that we\n            // can walk that import again, even if it was partially walked\n            // later during the same `patchAndUpgradeTree` call.\n            const clonedVisitedImports = new Set<Node>();\n            if (visitedImports) {\n              // IE11 does not support constructing a set using an iterable.\n              visitedImports.forEach(item => clonedVisitedImports.add(item));\n              clonedVisitedImports.delete(importNode);\n            }\n            this.patchAndUpgradeTree(\n                importNode, {visitedImports: clonedVisitedImports, upgrade});\n          });\n        }\n      } else {\n        elements.push(element);\n      }\n    };\n\n    // `forEachElement` populates (and internally checks against)\n    // `visitedImports` when traversing a loaded import.\n    this.forEachElement(root, gatherElements, visitedImports);\n\n    for (let i = 0; i < elements.length; i++) {\n      upgrade(elements[i] as HTMLElement);\n    }\n  }\n\n  upgradeReaction(element: HTMLElement) {\n    try {\n      const definition = this._lookupACustomElementDefinition(\n          element.ownerDocument!, element.localName);\n      if (definition) {\n        this._upgradeAnElement(element, definition);\n      }\n    } catch (e) {\n      this.reportTheException(e);\n    }\n  }\n\n  /**\n   * @see https://html.spec.whatwg.org/multipage/custom-elements.html#concept-upgrade-an-element\n   */\n  private _upgradeAnElement(\n      element: HTMLElement, definition: CustomElementDefinition) {\n    const currentState = element.__CE_state;\n    if (currentState !== undefined) {\n      return;\n    }\n\n    definition.constructionStack.push(element);\n\n    try {\n      try {\n        const result = new (definition.constructorFunction)();\n        if (result !== element) {\n          throw new Error(\n              'The custom element constructor did not produce the element being upgraded.');\n        }\n      } finally {\n        definition.constructionStack.pop();\n      }\n    } catch (e) {\n      element.__CE_state = CEState.failed;\n      throw e;\n    }\n\n    element.__CE_state = CEState.custom;\n    element.__CE_definition = definition;\n\n    // Check `hasAttributes` here to avoid iterating when it's not necessary.\n    if (definition.attributeChangedCallback && element.hasAttributes()) {\n      const observedAttributes = definition.observedAttributes;\n      for (let i = 0; i < observedAttributes.length; i++) {\n        const name = observedAttributes[i];\n        const value = element.getAttribute(name);\n        if (value !== null) {\n          this.attributeChangedCallback(element, name, null, value, null);\n        }\n      }\n    }\n\n    if (Utilities.isConnected(element)) {\n      this.connectedCallback(element);\n    }\n  }\n\n  connectedCallback(element: Element) {\n    const definition = element.__CE_definition!;\n    if (definition.connectedCallback) {\n      try {\n        definition.connectedCallback.call(element);\n      } catch (e) {\n        this.reportTheException(e);\n      }\n    }\n  }\n\n  disconnectedCallback(element: Element) {\n    const definition = element.__CE_definition!;\n    if (definition.disconnectedCallback) {\n      try {\n        definition.disconnectedCallback.call(element);\n      } catch (e) {\n        this.reportTheException(e);\n      }\n    }\n  }\n\n  attributeChangedCallback(\n      element: Element, name: string, oldValue?: string|null,\n      newValue?: string|null, namespace?: string|null) {\n    const definition = element.__CE_definition!;\n    if (definition.attributeChangedCallback &&\n        definition.observedAttributes.indexOf(name) > -1) {\n      try {\n        definition.attributeChangedCallback.call(\n            element, name, oldValue, newValue, namespace);\n      } catch (e) {\n        this.reportTheException(e);\n      }\n    }\n  }\n\n  /**\n   * Runs HTML's 'look up a custom element definition', excluding the namespace\n   * check.\n   *\n   * @see https://html.spec.whatwg.org/multipage/custom-elements.html#look-up-a-custom-element-definition\n   */\n  private _lookupACustomElementDefinition(doc: Document, localName: string):\n      CustomElementDefinition|undefined {\n    // The document must be associated with a registry.\n    const registry = doc.__CE_registry;\n    if (!registry) {\n      return;\n    }\n\n    // Prevent elements created in documents without a browsing context from\n    // upgrading.\n    //\n    // https://html.spec.whatwg.org/multipage/custom-elements.html#look-up-a-custom-element-definition\n    //   \"If document does not have a browsing context, return null.\"\n    //\n    // https://html.spec.whatwg.org/multipage/window-object.html#dom-document-defaultview\n    //   \"The defaultView IDL attribute of the Document interface, on getting,\n    //   must return this Document's browsing context's WindowProxy object, if\n    //   this Document has an associated browsing context, or null otherwise.\"\n    if (!doc.defaultView && !doc.__CE_isImportDocument) {\n      return;\n    }\n\n    return registry.internal_localNameToDefinition(localName);\n  }\n\n  /**\n   * Runs the DOM's 'create an element'. If namespace is not null, then the\n   * native `createElementNS` is used. Otherwise, `createElement` is used.\n   *\n   * Note, the template polyfill only wraps `createElement`, preventing this\n   * function from using `createElementNS` in all cases.\n   *\n   * @see https://dom.spec.whatwg.org/#concept-create-element\n   */\n  createAnElement(doc: Document, localName: string, namespace: string|null):\n      Element {\n    const registry = doc.__CE_registry;\n    // Only create custom elements if the document is associated with a\n    // registry.\n    if (registry && (namespace === null || namespace === NS_HTML)) {\n      const definition = registry.internal_localNameToDefinition(localName);\n      if (definition) {\n        try {\n          const result = new (definition.constructorFunction)();\n\n          // These conformance checks can't be performed when the user calls\n          // the element's constructor themselves. However, this also true in\n          // native implementations.\n\n          if (result.__CE_state === undefined ||\n              result.__CE_definition === undefined) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The returned value was not constructed with the HTMLElement ' +\n                'constructor.');\n          }\n\n          if (result.namespaceURI !== NS_HTML) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The constructed element\\'s namespace must be the HTML ' +\n                'namespace.');\n          }\n\n          // The following Errors should be DOMExceptions but DOMException\n          // isn't constructible in all browsers.\n\n          if (result.hasAttributes()) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The constructed element must not have any attributes.');\n          }\n\n          // ShadyDOM doesn't wrap `#hasChildNodes`, so we check `#firstChild`\n          // instead.\n          if (result.firstChild !== null) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The constructed element must not have any children.');\n          }\n\n          if (result.parentNode !== null) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The constructed element must not have a parent node.');\n          }\n\n          if (result.ownerDocument !== doc) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The constructed element\\'s owner document is incorrect.');\n          }\n\n          if (result.localName !== localName) {\n            throw new Error(\n                'Failed to construct \\'' + localName + '\\': ' +\n                'The constructed element\\'s local name is incorrect.');\n          }\n\n          return result;\n        } catch (e) {\n          this.reportTheException(e);\n\n          // When construction fails, a new HTMLUnknownElement is produced.\n          // However, there's no direct way to create one, so we create a\n          // regular HTMLElement and replace its prototype.\n          const result = namespace === null ?\n              Native.Document_createElement.call(doc, localName) :\n              Native.Document_createElementNS.call(doc, namespace, localName);\n          Object.setPrototypeOf(result, HTMLUnknownElement.prototype);\n          result.__CE_state = CEState.failed;\n          result.__CE_definition = undefined;\n          this.patchElement(result);\n          return result;\n        }\n      }\n    }\n\n    const result = namespace === null ?\n        Native.Document_createElement.call(doc, localName) :\n        Native.Document_createElementNS.call(doc, namespace, localName);\n    this.patchElement(result);\n    return result;\n  }\n\n  /**\n   * Runs the DOM's 'report the exception' algorithm.\n   *\n   * @see https://html.spec.whatwg.org/multipage/webappapis.html#report-the-exception\n   */\n  reportTheException(error: Error) {\n    const message = error.message;\n    const filename =\n        /* Safari */ error.sourceURL || /* Firefox */ error.fileName || '';\n    const lineno =\n        /* Safari */ error.line || /* Firefox */ error.lineNumber || 0;\n    const colno =\n        /* Safari */ error.column || /* Firefox */ error.columnNumber || 0;\n\n    let event: ErrorEvent|undefined = undefined;\n    if (ErrorEvent.prototype.initErrorEvent === undefined) {\n      event = new ErrorEvent(\n          'error', {cancelable: true, message, filename, lineno, colno, error});\n    } else {\n      event = document.createEvent('ErrorEvent') as ErrorEvent;\n      // initErrorEvent(type, bubbles, cancelable, message, filename, line)\n      event.initErrorEvent!('error', false, true, message, filename, lineno);\n      // Hack for IE, where ErrorEvent#preventDefault does not set\n      // #defaultPrevented to true.\n      event.preventDefault = function(this: ErrorEvent) {\n        Object.defineProperty(this, 'defaultPrevented', {\n          configurable: true,\n          get: function(this: ErrorEvent) {\n            return true;\n          },\n        });\n      };\n    }\n\n    if (event.error === undefined) {\n      Object.defineProperty(event, 'error', {\n        configurable: true,\n        enumerable: true,\n        get: function() {\n          return error;\n        },\n      });\n    }\n\n    window.dispatchEvent(event);\n    if (!event.defaultPrevented) {\n      // In 'report the exception', UAs may optionally write errors to the\n      // console if their associated ErrorEvent isn't handled during dispatch\n      // (indicated by calling `preventDefault`). In practice, these errors are\n      // always displayed.\n      console.error(error);\n    }\n  }\n}\n\ndeclare interface HTMLImportDocument extends Node {\n  readyState: 'complete'|string;\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from './CustomElementInternals.js';\nimport CustomElementRegistry from './CustomElementRegistry.js';\nimport PatchDocument from './Patch/Document.js';\nimport PatchDocumentFragment from './Patch/DocumentFragment.js';\nimport PatchElement from './Patch/Element.js';\nimport PatchHTMLElement from './Patch/HTMLElement.js';\nimport PatchNode from './Patch/Node.js';\n\nconst priorCustomElements = window['customElements'];\n\nfunction installPolyfill() {\n  const noDocumentConstructionObserver =\n      !!(priorCustomElements?.['noDocumentConstructionObserver']);\n  const shadyDomFastWalk = !!(priorCustomElements?.['shadyDomFastWalk']);\n\n  const internals = new CustomElementInternals(\n      {noDocumentConstructionObserver, shadyDomFastWalk});\n\n  PatchHTMLElement(internals);\n  PatchDocument(internals);\n  PatchDocumentFragment(internals);\n  PatchNode(internals);\n  PatchElement(internals);\n\n  const customElements = new CustomElementRegistry(internals);\n\n  // The main document is associated with the global registry.\n  document.__CE_registry = customElements;\n\n  Object.defineProperty(window, 'customElements', {\n    configurable: true,\n    enumerable: true,\n    value: customElements,\n  });\n}\n\nif (!priorCustomElements || priorCustomElements['forcePolyfill'] ||\n    (typeof priorCustomElements['define'] != 'function') ||\n    (typeof priorCustomElements['get'] != 'function')) {\n  installPolyfill();\n}\n\n// This is NOT public API and is only meant to work around a GC bug in older\n// versions of Safari that randomly removes the polyfill during tests.\n(window as any)['__CE_installPolyfill'] = installPolyfill;\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nexport default class Deferred<T> {\n  private _value: T|undefined = undefined;\n\n  private _resolve!: (val: T) => void;\n\n  private readonly _promise: Promise<T>;\n  constructor() {\n    this._promise = new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n  resolve(value: T) {\n    if (this._value) {\n      throw new Error('Already resolved.');\n    }\n\n    this._value = value;\n    this._resolve(value);\n  }\n\n  toPromise() {\n    return this._promise;\n  }\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from './CustomElementInternals.js';\n\nexport default class DocumentConstructionObserver {\n  private readonly _internals: CustomElementInternals;\n  private readonly _document: Document;\n  private _observer: MutationObserver|undefined = undefined;\n  constructor(internals: CustomElementInternals, doc: Document) {\n    this._internals = internals;\n    this._document = doc;\n\n    // Simulate tree construction for all currently accessible nodes in the\n    // document.\n    this._internals.patchAndUpgradeTree(this._document);\n\n    if (this._document.readyState === 'loading') {\n      this._observer = new MutationObserver(this._handleMutations.bind(this));\n\n      // Nodes created by the parser are given to the observer *before* the next\n      // task runs. Inline scripts are run in a new task. This means that the\n      // observer will be able to handle the newly parsed nodes before the\n      // inline script is run.\n      this._observer.observe(this._document, {\n        childList: true,\n        subtree: true,\n      });\n    }\n  }\n\n  disconnect() {\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n  }\n\n  private _handleMutations(mutations: ReadonlyArray<MutationRecord>) {\n    // Once the document's `readyState` is 'interactive' or 'complete', all new\n    // nodes created within that document will be the result of script and\n    // should be handled by patching.\n    const readyState = this._document.readyState;\n    if (readyState === 'interactive' || readyState === 'complete') {\n      this.disconnect();\n    }\n\n    for (let i = 0; i < mutations.length; i++) {\n      const addedNodes = mutations[i].addedNodes;\n      for (let j = 0; j < addedNodes.length; j++) {\n        const node = addedNodes[j];\n        this._internals.patchAndUpgradeTree(node);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport {AlreadyConstructedMarkerType} from './AlreadyConstructedMarker.js';\nimport CustomElementInternals from './CustomElementInternals.js';\nimport Deferred from './Deferred.js';\nimport DocumentConstructionObserver from './DocumentConstructionObserver.js';\nimport {Constructor, CustomElementDefinition} from './Externs.js';\nimport * as Utilities from './Utilities.js';\n\ninterface ElementConstructor {\n  new(): HTMLElement;\n  observedAttributes?: Array<string>;\n}\ntype ConstructorGetter = () => ElementConstructor;\n\n\n/**\n * @unrestricted\n */\nexport default class CustomElementRegistry {\n  private readonly _localNameToConstructorGetter =\n      new Map<string, ConstructorGetter>();\n  private readonly _localNameToDefinition =\n      new Map<string, CustomElementDefinition>();\n  private readonly _constructorToDefinition =\n      new Map<Constructor<HTMLElement>, CustomElementDefinition>();\n  private _elementDefinitionIsRunning = false;\n  private readonly _internals: CustomElementInternals;\n  private readonly _whenDefinedDeferred =\n      new Map<string, Deferred<undefined>>();\n\n  /**\n   * The default flush callback triggers the document walk synchronously.\n   */\n  private _flushCallback: (fn: () => void) => void = (fn) => fn();\n  private _flushPending = false;\n\n  /**\n   * A map from `localName`s of definitions that were defined *after* the\n   * last flush to unupgraded elements matching that definition, in document\n   * order. Entries are added to this map when a definition is registered,\n   * but the list of elements is only populated during a flush after which\n   * all of the entries are removed. DO NOT edit outside of `#_flush`.\n   */\n  private readonly _unflushedLocalNames: Array<string> = [];\n\n  private readonly _documentConstructionObserver: DocumentConstructionObserver|\n      undefined;\n\n  constructor(internals: CustomElementInternals) {\n    this._internals = internals;\n    this._documentConstructionObserver =\n        internals.useDocumentConstructionObserver ?\n        new DocumentConstructionObserver(internals, document) :\n        undefined;\n  }\n\n  polyfillDefineLazy(localName: string, constructorGetter: ConstructorGetter) {\n    if (!(constructorGetter instanceof Function)) {\n      throw new TypeError(\n          'Custom element constructor getters must be functions.');\n    }\n    this.internal_assertCanDefineLocalName(localName);\n    this._localNameToConstructorGetter.set(localName, constructorGetter);\n    this._unflushedLocalNames.push(localName);\n    // If we've already called the flush callback and it hasn't called back\n    // yet, don't call it again.\n    if (!this._flushPending) {\n      this._flushPending = true;\n      this._flushCallback(() => this._flush());\n    }\n  }\n\n  define(localName: string, constructor: Function) {\n    if (!(constructor instanceof Function)) {\n      throw new TypeError('Custom element constructors must be functions.');\n    }\n\n    this.internal_assertCanDefineLocalName(localName);\n\n    this.internal_reifyDefinition(localName, constructor as ElementConstructor);\n    this._unflushedLocalNames.push(localName);\n    // If we've already called the flush callback and it hasn't called back\n    // yet, don't call it again.\n    if (!this._flushPending) {\n      this._flushPending = true;\n      this._flushCallback(() => this._flush());\n    }\n  }\n\n  internal_assertCanDefineLocalName(localName: string) {\n    if (!Utilities.isValidCustomElementName(localName)) {\n      throw new SyntaxError(`The element name '${localName}' is not valid.`);\n    }\n\n    if (this.internal_localNameToDefinition(localName)) {\n      throw new Error(\n          `A custom element with name ` +\n          `'${localName}' has already been defined.`);\n    }\n\n    if (this._elementDefinitionIsRunning) {\n      throw new Error('A custom element is already being defined.');\n    }\n  }\n\n  internal_reifyDefinition(localName: string, constructor: ElementConstructor) {\n    this._elementDefinitionIsRunning = true;\n\n    let connectedCallback: CustomElementDefinition['connectedCallback'];\n    let disconnectedCallback: CustomElementDefinition['disconnectedCallback'];\n    let adoptedCallback: CustomElementDefinition['adoptedCallback'];\n    let attributeChangedCallback:\n        CustomElementDefinition['attributeChangedCallback'];\n    let observedAttributes: CustomElementDefinition['observedAttributes'];\n    try {\n      const prototype = constructor.prototype;\n      if (!(prototype instanceof Object)) {\n        throw new TypeError(\n            'The custom element constructor\\'s prototype is not an object.');\n      }\n\n      type CEReactionCallback = 'connectedCallback'|'disconnectedCallback'|\n          'adoptedCallback'|'attributeChangedCallback';\n      const getCallback =\n          function getCallback(name: CEReactionCallback) {\n        const callbackValue = prototype[name];\n        if (callbackValue !== undefined &&\n            !(callbackValue instanceof Function)) {\n          throw new Error(`The '${name}' callback must be a function.`);\n        }\n        return callbackValue;\n      }\n\n      connectedCallback = getCallback('connectedCallback');\n      disconnectedCallback = getCallback('disconnectedCallback');\n      adoptedCallback = getCallback('adoptedCallback');\n      attributeChangedCallback = getCallback('attributeChangedCallback');\n      // `observedAttributes` should not be read unless an\n      // `attributesChangedCallback` exists\n      observedAttributes =\n          (attributeChangedCallback && constructor['observedAttributes']) || [];\n    } catch (e) {\n      throw e;\n    } finally {\n      this._elementDefinitionIsRunning = false;\n    }\n\n    const definition = {\n      localName,\n      constructorFunction: constructor,\n      connectedCallback,\n      disconnectedCallback,\n      adoptedCallback,\n      attributeChangedCallback,\n      observedAttributes,\n      constructionStack: [] as Array<HTMLElement|AlreadyConstructedMarkerType>,\n    };\n\n    this._localNameToDefinition.set(localName, definition);\n    this._constructorToDefinition.set(\n        definition.constructorFunction, definition);\n\n    return definition;\n  }\n\n  upgrade(node: Node): void {\n    this._internals.patchAndUpgradeTree(node);\n  }\n\n  private _flush() {\n    // If no new definitions were defined, don't attempt to flush. This could\n    // happen if a flush callback keeps the function it is given and calls it\n    // multiple times.\n    if (this._flushPending === false) {\n      return;\n    }\n    this._flushPending = false;\n\n    /**\n     * Unupgraded elements with definitions that were defined *before* the last\n     * flush, in document order.\n     */\n    const elementsWithStableDefinitions: Array<HTMLElement> = [];\n\n    const unflushedLocalNames = this._unflushedLocalNames;\n    const elementsWithPendingDefinitions =\n        new Map<string, Array<HTMLElement>>();\n    for (let i = 0; i < unflushedLocalNames.length; i++) {\n      elementsWithPendingDefinitions.set(unflushedLocalNames[i], []);\n    }\n\n    this._internals.patchAndUpgradeTree(document, {\n      upgrade: element => {\n        // Ignore the element if it has already upgraded or failed to upgrade.\n        if (element.__CE_state !== undefined) {\n          return;\n        }\n\n        const localName = element.localName;\n\n        // If there is an applicable pending definition for the element, add the\n        // element to the list of elements to be upgraded with that definition.\n        const pendingElements = elementsWithPendingDefinitions.get(localName);\n        if (pendingElements) {\n          pendingElements.push(element);\n          // If there is *any other* applicable definition for the element, add\n          // it to the list of elements with stable definitions that need to be\n          // upgraded.\n        } else if (this._localNameToDefinition.has(localName)) {\n          elementsWithStableDefinitions.push(element);\n        }\n      },\n    });\n\n    // Upgrade elements with 'stable' definitions first.\n    for (let i = 0; i < elementsWithStableDefinitions.length; i++) {\n      this._internals.upgradeReaction(elementsWithStableDefinitions[i]);\n    }\n\n    // Upgrade elements with 'pending' definitions in the order they were\n    // defined.\n    for (let i = 0; i < unflushedLocalNames.length; i++) {\n      const localName = unflushedLocalNames[i];\n      const pendingUpgradableElements =\n          elementsWithPendingDefinitions.get(localName)!;\n\n      // Attempt to upgrade all applicable elements.\n      for (let i = 0; i < pendingUpgradableElements.length; i++) {\n        this._internals.upgradeReaction(pendingUpgradableElements[i]);\n      }\n\n      // Resolve any promises created by `whenDefined` for the definition.\n      const deferred = this._whenDefinedDeferred.get(localName);\n      if (deferred) {\n        deferred.resolve(undefined);\n      }\n    }\n\n    unflushedLocalNames.length = 0;\n  }\n\n  get(localName: string): undefined|{new(): HTMLElement} {\n    const definition = this.internal_localNameToDefinition(localName);\n    if (definition) {\n      return definition.constructorFunction;\n    }\n\n    return undefined;\n  }\n\n  whenDefined(localName: string): Promise<void> {\n    if (!Utilities.isValidCustomElementName(localName)) {\n      return Promise.reject(new SyntaxError(\n          `'${localName}' is not a valid custom element name.`));\n    }\n\n    const prior = this._whenDefinedDeferred.get(localName);\n    if (prior) {\n      return prior.toPromise();\n    }\n\n    const deferred = new Deferred<undefined>();\n    this._whenDefinedDeferred.set(localName, deferred);\n\n    // Resolve immediately if the given local name has a regular or lazy\n    // definition *and* the full document walk to upgrade elements with that\n    // local name has already happened.\n    //\n    // The behavior of the returned promise differs between the lazy and the\n    // non-lazy cases if the definition fails. Normally, the definition would\n    // fail synchronously and no pending promises would resolve. However, if\n    // the definition is lazy but has not yet been reified, the promise is\n    // resolved early here even though it might fail later when reified.\n    const anyDefinitionExists = this._localNameToDefinition.has(localName) ||\n        this._localNameToConstructorGetter.has(localName);\n    const definitionHasFlushed =\n        this._unflushedLocalNames.indexOf(localName) === -1;\n    if (anyDefinitionExists && definitionHasFlushed) {\n      deferred.resolve(undefined);\n    }\n\n    return deferred.toPromise();\n  }\n\n  polyfillWrapFlushCallback(outer: (fn: () => void) => void) {\n    if (this._documentConstructionObserver) {\n      this._documentConstructionObserver.disconnect();\n    }\n    const inner = this._flushCallback;\n    this._flushCallback = flush => outer(() => inner(flush));\n  }\n\n  internal_localNameToDefinition(localName: string): CustomElementDefinition\n      |undefined {\n    const existingDefinition = this._localNameToDefinition.get(localName);\n    if (existingDefinition) {\n      return existingDefinition;\n    }\n\n    const constructorGetter = this._localNameToConstructorGetter.get(localName);\n    if (constructorGetter) {\n      this._localNameToConstructorGetter.delete(localName);\n      try {\n        return this.internal_reifyDefinition(localName, constructorGetter());\n      } catch (e) {\n        this._internals.reportTheException(e);\n      }\n    }\n\n    return undefined;\n  }\n\n  internal_constructorToDefinition(constructor: ElementConstructor):\n      CustomElementDefinition|undefined {\n    return this._constructorToDefinition.get(constructor);\n  }\n}\n\n// Closure compiler exports.\nwindow['CustomElementRegistry'] =\n    CustomElementRegistry as unknown as typeof window['CustomElementRegistry'];\nCustomElementRegistry.prototype['define'] =\n    CustomElementRegistry.prototype.define;\nCustomElementRegistry.prototype['upgrade'] =\n    CustomElementRegistry.prototype.upgrade;\nCustomElementRegistry.prototype['get'] = CustomElementRegistry.prototype.get;\nCustomElementRegistry.prototype['whenDefined'] =\n    CustomElementRegistry.prototype.whenDefined;\nCustomElementRegistry.prototype['polyfillDefineLazy'] =\n    CustomElementRegistry.prototype.polyfillDefineLazy;\nCustomElementRegistry.prototype['polyfillWrapFlushCallback'] =\n    CustomElementRegistry.prototype.polyfillWrapFlushCallback;\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from '../../CustomElementInternals.js';\nimport * as Utilities from '../../Utilities.js';\n\ntype NativeMethod = (this: Node, ...args: Array<Node|string>) => void;\n\ninterface ParentNodeNativeMethods {\n  prepend: NativeMethod;\n  append: NativeMethod;\n}\n\nexport default function(\n    internals: CustomElementInternals,\n    destination: ParentNode,\n    builtIn: ParentNodeNativeMethods) {\n  function appendPrependPatch(builtInMethod: NativeMethod): NativeMethod {\n    return function(...nodes) {\n      /**\n       * A copy of `nodes`, with any DocumentFragment replaced by its children.\n       */\n      const flattenedNodes: Array<Node|string> = [];\n\n      /**\n       * Elements in `nodes` that were connected before this call.\n       */\n      const connectedElements: Array<Node> = [];\n\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n\n        if (node instanceof Element && Utilities.isConnected(node)) {\n          connectedElements.push(node);\n        }\n\n        if (node instanceof DocumentFragment) {\n          for (let child = node.firstChild; child; child = child.nextSibling) {\n            flattenedNodes.push(child);\n          }\n        } else {\n          flattenedNodes.push(node);\n        }\n      }\n\n      builtInMethod.apply(this, nodes);\n\n      for (let i = 0; i < connectedElements.length; i++) {\n        internals.disconnectTree(connectedElements[i]);\n      }\n\n      if (Utilities.isConnected(this)) {\n        for (let i = 0; i < flattenedNodes.length; i++) {\n          const node = flattenedNodes[i];\n          if (node instanceof Element) {\n            internals.connectTree(node);\n          }\n        }\n      }\n    };\n  }\n\n  if (builtIn.prepend !== undefined) {\n    destination.prepend = appendPrependPatch(builtIn.prepend);\n  }\n\n  if (builtIn.append !== undefined) {\n    destination.append = appendPrependPatch(builtIn.append);\n  }\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from '../CustomElementInternals.js';\n\nimport PatchParentNode from './Interface/ParentNode.js';\nimport * as Native from './Native.js';\n\nexport default function(internals: CustomElementInternals) {\n  Document.prototype.createElement = function(\n                                         this: Document, localName: string) {\n    return internals.createAnElement(this, localName, null);\n  } as typeof Document.prototype.createElement;\n\n  Document.prototype.importNode = function<T extends Node>(\n      this: Document, node: T, deep?: boolean): T {\n    const clone = Native.Document_importNode.call(this, node, !!deep) as T;\n    // Only create custom elements if this document is associated with the\n    // registry.\n    if (!this.__CE_registry) {\n      internals.patchTree(clone);\n    } else {\n      internals.patchAndUpgradeTree(clone);\n    }\n    return clone;\n  };\n\n  Document.prototype.createElementNS =\n      function(this: Document, namespace: string|null, localName: string) {\n    return internals.createAnElement(this, localName, namespace);\n  } as typeof Document.prototype.createElementNS;\n\n  PatchParentNode(internals, Document.prototype, {\n    prepend: Native.Document_prepend,\n    append: Native.Document_append,\n  });\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from '../../CustomElementInternals.js';\nimport * as Utilities from '../../Utilities.js';\n\ntype NativeMethod = (this: ChildNode, ...args: Array<Node|string>) => void;\n\ninterface ChildNodeNativeMethods {\n  before: NativeMethod;\n  after: NativeMethod;\n  replaceWith: NativeMethod;\n  remove: (this: ChildNode) => void;\n}\n\nexport default function(\n    internals: CustomElementInternals,\n    destination: ChildNode,\n    builtIn: ChildNodeNativeMethods) {\n  function beforeAfterPatch(builtInMethod: NativeMethod): NativeMethod {\n    return function(this: ChildNode, ...nodes) {\n      const flattenedNodes: Array<string|Node> = [];\n      const connectedElements: Array<Node> = [];\n\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n\n        if (node instanceof Element && Utilities.isConnected(node)) {\n          connectedElements.push(node);\n        }\n\n        if (node instanceof DocumentFragment) {\n          for (let child = node.firstChild; child; child = child.nextSibling) {\n            flattenedNodes.push(child);\n          }\n        } else {\n          flattenedNodes.push(node);\n        }\n      }\n\n      builtInMethod.apply(this, nodes);\n\n      for (let i = 0; i < connectedElements.length; i++) {\n        internals.disconnectTree(connectedElements[i]);\n      }\n\n      if (Utilities.isConnected(this)) {\n        for (let i = 0; i < flattenedNodes.length; i++) {\n          const node = flattenedNodes[i];\n          if (node instanceof Element) {\n            internals.connectTree(node);\n          }\n        }\n      }\n    };\n  }\n\n  if (builtIn.before !== undefined) {\n    destination.before = beforeAfterPatch(builtIn.before);\n  }\n\n  if (builtIn.after !== undefined) {\n    destination.after = beforeAfterPatch(builtIn.after);\n  }\n\n  if (builtIn.replaceWith !== undefined) {\n    destination.replaceWith = function(\n        this: ChildNode, ...nodes: Array<Node|string>) {\n      /**\n       * A copy of `nodes`, with any DocumentFragment replaced by its children.\n       */\n      const flattenedNodes: Array<Node|string> = [];\n\n      /**\n       * Elements in `nodes` that were connected before this call.\n       */\n      const connectedElements: Array<Node> = [];\n\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n\n        if (node instanceof Element && Utilities.isConnected(node)) {\n          connectedElements.push(node);\n        }\n\n        if (node instanceof DocumentFragment) {\n          for (let child = node.firstChild; child; child = child.nextSibling) {\n            flattenedNodes.push(child);\n          }\n        } else {\n          flattenedNodes.push(node);\n        }\n      }\n\n      const wasConnected = Utilities.isConnected(this);\n\n      builtIn.replaceWith.apply(this, nodes);\n\n      for (let i = 0; i < connectedElements.length; i++) {\n        internals.disconnectTree(connectedElements[i]);\n      }\n\n      if (wasConnected) {\n        internals.disconnectTree(this);\n        for (let i = 0; i < flattenedNodes.length; i++) {\n          const node = flattenedNodes[i];\n          if (node instanceof Element) {\n            internals.connectTree(node);\n          }\n        }\n      }\n    };\n  }\n\n  if (builtIn.remove !== undefined) {\n    destination.remove = function(this: ChildNode) {\n      const wasConnected = Utilities.isConnected(this);\n\n      builtIn.remove.call(this);\n\n      if (wasConnected) {\n        internals.disconnectTree(this);\n      }\n    };\n  }\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from '../CustomElementInternals.js';\nimport CEState from '../CustomElementState.js';\nimport * as Utilities from '../Utilities.js';\n\nimport PatchChildNode from './Interface/ChildNode.js';\nimport PatchParentNode from './Interface/ParentNode.js';\nimport * as Native from './Native.js';\n\nexport default function(internals: CustomElementInternals) {\n  if (Native.Element_attachShadow) {\n    Element.prototype.attachShadow = function(\n        this: Element, init: ShadowRootInit) {\n      const shadowRoot = Native.Element_attachShadow.call(this, init);\n      internals.patchNode(shadowRoot);\n      this.__CE_shadowRoot = shadowRoot;\n      return shadowRoot;\n    };\n  }\n\n\n  function patch_innerHTML(\n      destination: Element, baseDescriptor: PropertyDescriptor) {\n    Object.defineProperty(destination, 'innerHTML', {\n      enumerable: baseDescriptor.enumerable,\n      configurable: true,\n      get: baseDescriptor.get,\n      set: function(this: Element, htmlString) {\n        const isConnected = Utilities.isConnected(this);\n\n        // NOTE: In IE11, when using the native `innerHTML` setter, all nodes\n        // that were previously descendants of the context element have all of\n        // their children removed as part of the set - the entire subtree is\n        // 'disassembled'. This work around walks the subtree *before* using the\n        // native setter.\n        let removedElements: undefined|Array<Element> = undefined;\n        if (isConnected) {\n          removedElements = [];\n          internals.forEachElement(this, element => {\n            if (element !== this) {\n              removedElements!.push(element);\n            }\n          });\n        }\n\n        baseDescriptor.set!.call(this, htmlString);\n\n        if (removedElements) {\n          for (let i = 0; i < removedElements.length; i++) {\n            const element = removedElements[i];\n            if (element.__CE_state === CEState.custom) {\n              internals.disconnectedCallback(element);\n            }\n          }\n        }\n\n        // Only create custom elements if this element's owner document is\n        // associated with the registry.\n        if (!this.ownerDocument!.__CE_registry) {\n          internals.patchTree(this);\n        } else {\n          internals.patchAndUpgradeTree(this);\n        }\n        return htmlString;\n      },\n    });\n  }\n\n  if (Native.Element_innerHTML && Native.Element_innerHTML.get) {\n    patch_innerHTML(Element.prototype, Native.Element_innerHTML);\n  } else if (Native.HTMLElement_innerHTML && Native.HTMLElement_innerHTML.get) {\n    patch_innerHTML(HTMLElement.prototype, Native.HTMLElement_innerHTML);\n  } else {\n    internals.addElementPatch(function(element) {\n      patch_innerHTML(element, {\n        enumerable: true,\n        configurable: true,\n        // Implements getting `innerHTML` by performing an unpatched `cloneNode`\n        // of the element and returning the resulting element's `innerHTML`.\n        // TODO: Is this too expensive?\n        get: function(this: Element) {\n          return (Native.Node_cloneNode.call(this, true) as Element).innerHTML;\n        },\n        // Implements setting `innerHTML` by creating an unpatched element,\n        // setting `innerHTML` of that element and replacing the target\n        // element's children with those of the unpatched element.\n        set: function(this: Element, assignedValue) {\n          // NOTE: re-route to `content` for `template` elements.\n          // We need to do this because `template.appendChild` does not\n          // route into `template.content`.\n          const isTemplate = (this.localName === 'template');\n          const content =\n              isTemplate ? ((this) as HTMLTemplateElement).content : this;\n          const rawElement = Native.Document_createElementNS.call(\n              document, this.namespaceURI, this.localName);\n          rawElement.innerHTML = assignedValue;\n\n          while (content.childNodes.length > 0) {\n            Native.Node_removeChild.call(content, content.childNodes[0]);\n          }\n          const container = isTemplate ?\n              (rawElement as HTMLTemplateElement).content :\n              rawElement;\n          while (container.childNodes.length > 0) {\n            Native.Node_appendChild.call(content, container.childNodes[0]);\n          }\n        },\n      });\n    });\n  }\n\n\n  Element.prototype.setAttribute = function(this: Element, name, newValue) {\n    // Fast path for non-custom elements.\n    if (this.__CE_state !== CEState.custom) {\n      return Native.Element_setAttribute.call(this, name, newValue);\n    }\n\n    const oldValue = Native.Element_getAttribute.call(this, name);\n    Native.Element_setAttribute.call(this, name, newValue);\n    newValue = Native.Element_getAttribute.call(this, name)!;\n    internals.attributeChangedCallback(this, name, oldValue, newValue, null);\n  };\n\n  Element.prototype.setAttributeNS = function(\n      this: Element, namespace, name, newValue) {\n    // Fast path for non-custom elements.\n    if (this.__CE_state !== CEState.custom) {\n      return Native.Element_setAttributeNS.call(\n          this, namespace, name, newValue);\n    }\n\n    const oldValue = Native.Element_getAttributeNS.call(this, namespace, name);\n    Native.Element_setAttributeNS.call(this, namespace, name, newValue);\n    newValue = Native.Element_getAttributeNS.call(this, namespace, name)!;\n    internals.attributeChangedCallback(\n        this, name, oldValue, newValue, namespace);\n  };\n\n  Element.prototype.removeAttribute = function(this: Element, name) {\n    // Fast path for non-custom elements.\n    if (this.__CE_state !== CEState.custom) {\n      return Native.Element_removeAttribute.call(this, name);\n    }\n\n    const oldValue = Native.Element_getAttribute.call(this, name);\n    Native.Element_removeAttribute.call(this, name);\n    if (oldValue !== null) {\n      internals.attributeChangedCallback(this, name, oldValue, null, null);\n    }\n  };\n\n  Element.prototype.removeAttributeNS = function(\n      this: Element, namespace, name) {\n    // Fast path for non-custom elements.\n    if (this.__CE_state !== CEState.custom) {\n      return Native.Element_removeAttributeNS.call(this, namespace, name);\n    }\n\n    const oldValue = Native.Element_getAttributeNS.call(this, namespace, name);\n    Native.Element_removeAttributeNS.call(this, namespace, name);\n    // In older browsers, `Element#getAttributeNS` may return the empty string\n    // instead of null if the attribute does not exist. For details, see;\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS#Notes\n    const newValue = Native.Element_getAttributeNS.call(this, namespace, name);\n    if (oldValue !== newValue) {\n      internals.attributeChangedCallback(\n          this, name, oldValue, newValue, namespace);\n    }\n  };\n\n\n  function patch_insertAdjacentElement(\n      destination: Element, baseMethod: Element['insertAdjacentElement']) {\n    destination.insertAdjacentElement = function(\n        this: Element, position, element) {\n      const wasConnected = Utilities.isConnected(element);\n      const insertedElement = baseMethod.call(this, position, element)!;\n\n      if (wasConnected) {\n        internals.disconnectTree(element);\n      }\n\n      if (Utilities.isConnected(insertedElement)) {\n        internals.connectTree(element);\n      }\n      return insertedElement;\n    };\n  }\n\n  if (Native.HTMLElement_insertAdjacentElement) {\n    patch_insertAdjacentElement(\n        HTMLElement.prototype, Native.HTMLElement_insertAdjacentElement);\n  } else if (Native.Element_insertAdjacentElement) {\n    patch_insertAdjacentElement(\n        Element.prototype, Native.Element_insertAdjacentElement);\n  }\n\n\n  function patch_insertAdjacentHTML(\n      destination: Element, baseMethod: Element['insertAdjacentHTML']) {\n    /**\n     * Patches and upgrades all nodes which are siblings between `start`\n     * (inclusive) and `end` (exclusive). If `end` is `null`, then all siblings\n     * following `start` will be patched and upgraded.\n     */\n    function upgradeNodesInRange(start: Node, end: Node|null) {\n      const nodes = [];\n      for (let node: Node = start; node !== end; node = node.nextSibling!) {\n        nodes.push(node);\n      }\n      for (let i = 0; i < nodes.length; i++) {\n        internals.patchAndUpgradeTree(nodes[i]);\n      }\n    }\n\n    destination.insertAdjacentHTML = function(this: Element, position, text) {\n      const strPosition = position.toLowerCase();\n\n      if (strPosition === 'beforebegin') {\n        const marker = this.previousSibling;\n        baseMethod.call(this, strPosition, text);\n        upgradeNodesInRange(marker || this.parentNode!.firstChild!, this);\n      } else if (strPosition === 'afterbegin') {\n        const marker = this.firstChild;\n        baseMethod.call(this, strPosition, text);\n        upgradeNodesInRange(this.firstChild!, marker);\n      } else if (strPosition === 'beforeend') {\n        const marker = this.lastChild;\n        baseMethod.call(this, strPosition, text);\n        upgradeNodesInRange(marker || this.firstChild!, null);\n      } else if (strPosition === 'afterend') {\n        const marker = this.nextSibling;\n        baseMethod.call(this, strPosition, text);\n        upgradeNodesInRange(this.nextSibling!, marker);\n      } else {\n        throw new SyntaxError(\n            `The value provided (${String(strPosition)}) is ` +\n            'not one of \\'beforebegin\\', \\'afterbegin\\', \\'beforeend\\', or \\'afterend\\'.');\n      }\n    };\n  }\n\n  if (Native.HTMLElement_insertAdjacentHTML) {\n    patch_insertAdjacentHTML(\n        HTMLElement.prototype, Native.HTMLElement_insertAdjacentHTML);\n  } else if (Native.Element_insertAdjacentHTML) {\n    patch_insertAdjacentHTML(\n        Element.prototype, Native.Element_insertAdjacentHTML);\n  }\n\n\n  PatchParentNode(internals, Element.prototype, {\n    prepend: Native.Element_prepend,\n    append: Native.Element_append,\n  });\n\n  PatchChildNode(internals, Element.prototype, {\n    before: Native.Element_before,\n    after: Native.Element_after,\n    replaceWith: Native.Element_replaceWith,\n    remove: Native.Element_remove,\n  });\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nexport const CustomElementState = {\n  custom: 1,\n  failed: 2,\n} as const;\nexport type CustomElementState =\n    typeof CustomElementState.custom|typeof CustomElementState.failed;\n\nexport default CustomElementState;\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Represents the 'already constructed marker' used in custom\n * element construction stacks.\n *\n * https://html.spec.whatwg.org/#concept-already-constructed-marker\n */\nconst alreadyConstructedMarker = {} as {_alreadyConstructedMarker: never};\n\nexport default alreadyConstructedMarker;\nexport type AlreadyConstructedMarkerType = typeof alreadyConstructedMarker;\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport AlreadyConstructedMarker from '../AlreadyConstructedMarker.js';\nimport CustomElementInternals from '../CustomElementInternals.js';\nimport CEState from '../CustomElementState.js';\nimport {Constructor} from '../Externs.js';\nimport * as Native from './Native.js';\n\nexport default function(internals: CustomElementInternals) {\n  const PatchedHTMLElement = function HTMLElement(this: HTMLElement) {\n    // This should really be `new.target` but `new.target` can't be\n    // emulated in ES5. Assuming the user keeps the default value of the\n    // constructor's prototype's `constructor` property, this is\n    // equivalent.\n    const constructor = this.constructor as Constructor<HTMLElement>;\n\n    // Always look up the definition from the global registry.\n    const registry = document.__CE_registry!;\n    const definition = registry.internal_constructorToDefinition(constructor);\n    if (!definition) {\n      throw new Error(\n          'Failed to construct a custom element: ' +\n          'The constructor was not registered with `customElements`.');\n    }\n\n    const constructionStack = definition.constructionStack;\n\n    if (constructionStack.length === 0) {\n      const element = (Native.Document_createElement.call(\n                          document, definition.localName)) as HTMLElement;\n      Object.setPrototypeOf(element, constructor.prototype as typeof element);\n      element.__CE_state = CEState.custom;\n      element.__CE_definition = definition;\n      internals.patchElement(element);\n      return element;\n    }\n\n    const lastIndex = constructionStack.length - 1;\n    const element = constructionStack[lastIndex];\n    if (element === AlreadyConstructedMarker) {\n      const localName = definition.localName;\n      throw new Error(\n          'Failed to construct \\'' + localName + '\\': ' +\n          'This element was already constructed.');\n    }\n    const toConstructElement = element as HTMLElement;\n    constructionStack[lastIndex] = AlreadyConstructedMarker;\n\n    Object.setPrototypeOf(\n        toConstructElement, constructor.prototype as typeof toConstructElement);\n    internals.patchElement(toConstructElement);\n\n    return toConstructElement;\n  };\n\n  PatchedHTMLElement.prototype = Native.HTMLElement.prototype;\n  // Safari 9 has `writable: false` on the propertyDescriptor\n  // Make it writable so that TypeScript can patch up the\n  // constructor in the ES5 compiled code.\n  Object.defineProperty(HTMLElement.prototype, 'constructor', {\n    writable: true,\n    configurable: true,\n    enumerable: false,\n    value: PatchedHTMLElement\n  });\n\n  window['HTMLElement'] = PatchedHTMLElement as unknown as typeof HTMLElement;\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from '../CustomElementInternals.js';\nimport * as Utilities from '../Utilities.js';\n\nimport * as Native from './Native.js';\n\nexport default function(internals: CustomElementInternals) {\n  // `Node#nodeValue` is implemented on `Attr`.\n  // `Node#textContent` is implemented on `Attr`, `Element`.\n\n  Node.prototype.insertBefore = function<T extends Node>(\n      this: Node, node: T, refNode: Node|null) {\n    if (node instanceof DocumentFragment) {\n      const insertedNodes = Utilities.childrenFromFragment(node);\n      const nativeResult = Native.Node_insertBefore.call(this, node, refNode);\n\n      // DocumentFragments can't be connected, so `disconnectTree` will never\n      // need to be called on a DocumentFragment's children after inserting it.\n\n      if (Utilities.isConnected(this)) {\n        for (let i = 0; i < insertedNodes.length; i++) {\n          internals.connectTree(insertedNodes[i]);\n        }\n      }\n\n      return nativeResult as T;\n    }\n\n    const nodeWasConnectedElement =\n        node instanceof Element && Utilities.isConnected(node);\n    const nativeResult =\n        Native.Node_insertBefore.call(this, node, refNode) as T;\n\n    if (nodeWasConnectedElement) {\n      internals.disconnectTree(node);\n    }\n\n    if (Utilities.isConnected(this)) {\n      internals.connectTree(node);\n    }\n\n    return nativeResult;\n  };\n\n  Node.prototype.appendChild = function<T extends Node>(this: Node, node: T) {\n    if (node instanceof DocumentFragment) {\n      const insertedNodes = Utilities.childrenFromFragment(node);\n      const nativeResult = Native.Node_appendChild.call(this, node) as T;\n\n      // DocumentFragments can't be connected, so `disconnectTree` will never\n      // need to be called on a DocumentFragment's children after inserting it.\n\n      if (Utilities.isConnected(this)) {\n        for (let i = 0; i < insertedNodes.length; i++) {\n          internals.connectTree(insertedNodes[i]);\n        }\n      }\n\n      return nativeResult;\n    }\n\n    const nodeWasConnectedElement =\n        node instanceof Element && Utilities.isConnected(node);\n    const nativeResult = Native.Node_appendChild.call(this, node) as T;\n\n    if (nodeWasConnectedElement) {\n      internals.disconnectTree(node);\n    }\n\n    if (Utilities.isConnected(this)) {\n      internals.connectTree(node);\n    }\n\n    return nativeResult;\n  };\n\n  Node.prototype.cloneNode = function(this: Node, deep) {\n    const clone = Native.Node_cloneNode.call(this, !!deep);\n    // Only create custom elements if this element's owner document is\n    // associated with the registry.\n    if (!this.ownerDocument!.__CE_registry) {\n      internals.patchTree(clone);\n    } else {\n      internals.patchAndUpgradeTree(clone);\n    }\n    return clone;\n  };\n\n  Node.prototype.removeChild = function<T extends Node>(this: Node, node: T) {\n    const nodeWasConnectedElement =\n        node instanceof Element && Utilities.isConnected(node);\n    const nativeResult = Native.Node_removeChild.call(this, node) as T;\n\n    if (nodeWasConnectedElement) {\n      internals.disconnectTree(node);\n    }\n\n    return nativeResult;\n  };\n\n  Node.prototype.replaceChild = function<T extends Node>(\n      this: Node, nodeToInsert: Node, nodeToRemove: T) {\n    if (nodeToInsert instanceof DocumentFragment) {\n      const insertedNodes = Utilities.childrenFromFragment(nodeToInsert);\n      const nativeResult =\n          Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove) as T;\n\n      // DocumentFragments can't be connected, so `disconnectTree` will never\n      // need to be called on a DocumentFragment's children after inserting it.\n\n      if (Utilities.isConnected(this)) {\n        internals.disconnectTree(nodeToRemove);\n        for (let i = 0; i < insertedNodes.length; i++) {\n          internals.connectTree(insertedNodes[i]);\n        }\n      }\n\n      return nativeResult;\n    }\n\n    const nodeToInsertWasConnectedElement =\n        nodeToInsert instanceof Element && Utilities.isConnected(nodeToInsert);\n    const nativeResult =\n        Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove) as T;\n    const thisIsConnected = Utilities.isConnected(this);\n\n    if (thisIsConnected) {\n      internals.disconnectTree(nodeToRemove);\n    }\n\n    if (nodeToInsertWasConnectedElement) {\n      internals.disconnectTree(nodeToInsert);\n    }\n\n    if (thisIsConnected) {\n      internals.connectTree(nodeToInsert);\n    }\n\n    return nativeResult;\n  };\n\n\n  function patch_textContent(\n      destination: Node, baseDescriptor: PropertyDescriptor) {\n    Object.defineProperty(destination, 'textContent', {\n      enumerable: baseDescriptor.enumerable,\n      configurable: true,\n      get: baseDescriptor.get,\n      set: function(this: Node, assignedValue) {\n        // If this is a text node then there are no nodes to disconnect.\n        if (this.nodeType === Node.TEXT_NODE) {\n          baseDescriptor.set!.call(this, assignedValue);\n          return;\n        }\n\n        let removedNodes = undefined;\n        // Checking for `firstChild` is faster than reading `childNodes.length`\n        // to compare with 0.\n        if (this.firstChild) {\n          // Using `childNodes` is faster than `children`, even though we only\n          // care about elements.\n          const childNodes = this.childNodes;\n          const childNodesLength = childNodes.length;\n          if (childNodesLength > 0 && Utilities.isConnected(this)) {\n            // Copying an array by iterating is faster than using slice.\n            removedNodes = new Array(childNodesLength);\n            for (let i = 0; i < childNodesLength; i++) {\n              removedNodes[i] = childNodes[i];\n            }\n          }\n        }\n\n        baseDescriptor.set!.call(this, assignedValue);\n\n        if (removedNodes) {\n          for (let i = 0; i < removedNodes.length; i++) {\n            internals.disconnectTree(removedNodes[i]);\n          }\n        }\n      },\n    });\n  }\n\n  if (Native.Node_textContent && Native.Node_textContent.get) {\n    patch_textContent(Node.prototype, Native.Node_textContent);\n  } else {\n    internals.addNodePatch(function(element) {\n      patch_textContent(element, {\n        enumerable: true,\n        configurable: true,\n        // NOTE: This implementation of the `textContent` getter assumes that\n        // text nodes' `textContent` getter will not be patched.\n        get: function(this: Node) {\n          const parts: Array<string|null> = [];\n\n          for (let n = this.firstChild; n; n = n.nextSibling) {\n            if (n.nodeType === Node.COMMENT_NODE) {\n              continue;\n            }\n            parts.push(n.textContent);\n          }\n\n          return parts.join('');\n        },\n        set: function(this: Node, assignedValue) {\n          while (this.firstChild) {\n            Native.Node_removeChild.call(this, this.firstChild);\n          }\n          // `textContent = null | undefined | ''` does not result in\n          // a TextNode childNode\n          if (assignedValue != null && assignedValue !== '') {\n            Native.Node_appendChild.call(\n                this, document.createTextNode(assignedValue));\n          }\n        },\n      });\n    });\n  }\n}\n","/**\n * @license\n * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt The complete set of authors may be found\n * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may\n * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by\n * Google as part of the polymer project is also subject to an additional IP\n * rights grant found at http://polymer.github.io/PATENTS.txt\n */\n\nimport CustomElementInternals from '../CustomElementInternals.js';\n\nimport PatchParentNode from './Interface/ParentNode.js';\nimport * as Native from './Native.js';\n\nexport default function(internals: CustomElementInternals) {\n  PatchParentNode(internals, DocumentFragment.prototype, {\n    prepend: Native.DocumentFragment_prepend,\n    append: Native.DocumentFragment_append,\n  });\n}\n"],"sourceRoot":""}