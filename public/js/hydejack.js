(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

/*! modernizr 3.3.1 (Custom Build) | MIT *
 * https://modernizr.com/download/?-classlist-csspointerevents-cssremunit-csstransforms-documentfragment-eventlistener-history-matchmedia-opacity-queryselector-requestanimationframe-touchevents !*/
!function (e, t, n) {
  function r(e, t) {
    return (typeof e === "undefined" ? "undefined" : _typeof(e)) === t;
  }function o() {
    var e, t, n, o, i, s, a;for (var u in y) {
      if (y.hasOwnProperty(u)) {
        if (e = [], t = y[u], t.name && (e.push(t.name.toLowerCase()), t.options && t.options.aliases && t.options.aliases.length)) for (n = 0; n < t.options.aliases.length; n++) {
          e.push(t.options.aliases[n].toLowerCase());
        }for (o = r(t.fn, "function") ? t.fn() : t.fn, i = 0; i < e.length; i++) {
          s = e[i], a = s.split("."), 1 === a.length ? Modernizr[a[0]] = o : (!Modernizr[a[0]] || Modernizr[a[0]] instanceof Boolean || (Modernizr[a[0]] = new Boolean(Modernizr[a[0]])), Modernizr[a[0]][a[1]] = o), x.push((o ? "" : "no-") + a.join("-"));
        }
      }
    }
  }function i(e) {
    return e.replace(/([a-z])-([a-z])/g, function (e, t, n) {
      return t + n.toUpperCase();
    }).replace(/^-/, "");
  }function s() {
    return "function" != typeof t.createElement ? t.createElement(arguments[0]) : T ? t.createElementNS.call(t, "http://www.w3.org/2000/svg", arguments[0]) : t.createElement.apply(t, arguments);
  }function a() {
    var e = t.body;return e || (e = s(T ? "svg" : "body"), e.fake = !0), e;
  }function u(e, n, r, o) {
    var i,
        u,
        f,
        d,
        l = "modernizr",
        c = s("div"),
        p = a();if (parseInt(r, 10)) for (; r--;) {
      f = s("div"), f.id = o ? o[r] : l + (r + 1), c.appendChild(f);
    }return i = s("style"), i.type = "text/css", i.id = "s" + l, (p.fake ? p : c).appendChild(i), p.appendChild(c), i.styleSheet ? i.styleSheet.cssText = e : i.appendChild(t.createTextNode(e)), c.id = l, p.fake && (p.style.background = "", p.style.overflow = "hidden", d = S.style.overflow, S.style.overflow = "hidden", S.appendChild(p)), u = n(c, e), p.fake ? (p.parentNode.removeChild(p), S.style.overflow = d, S.offsetHeight) : c.parentNode.removeChild(c), !!u;
  }function f(e, t) {
    return !!~("" + e).indexOf(t);
  }function d(e, t) {
    return function () {
      return e.apply(t, arguments);
    };
  }function l(e, t, n) {
    var o;for (var i in e) {
      if (e[i] in t) return n === !1 ? e[i] : (o = t[e[i]], r(o, "function") ? d(o, n || t) : o);
    }return !1;
  }function c(e) {
    return e.replace(/([A-Z])/g, function (e, t) {
      return "-" + t.toLowerCase();
    }).replace(/^ms-/, "-ms-");
  }function p(t, r) {
    var o = t.length;if ("CSS" in e && "supports" in e.CSS) {
      for (; o--;) {
        if (e.CSS.supports(c(t[o]), r)) return !0;
      }return !1;
    }if ("CSSSupportsRule" in e) {
      for (var i = []; o--;) {
        i.push("(" + c(t[o]) + ":" + r + ")");
      }return i = i.join(" or "), u("@supports (" + i + ") { #modernizr { position: absolute; } }", function (e) {
        return "absolute" == getComputedStyle(e, null).position;
      });
    }return n;
  }function m(e, t, o, a) {
    function u() {
      l && (delete O.style, delete O.modElem);
    }if (a = r(a, "undefined") ? !1 : a, !r(o, "undefined")) {
      var d = p(e, o);if (!r(d, "undefined")) return d;
    }for (var l, c, m, v, h, y = ["modernizr", "tspan", "samp"]; !O.style && y.length;) {
      l = !0, O.modElem = s(y.shift()), O.style = O.modElem.style;
    }for (m = e.length, c = 0; m > c; c++) {
      if (v = e[c], h = O.style[v], f(v, "-") && (v = i(v)), O.style[v] !== n) {
        if (a || r(o, "undefined")) return u(), "pfx" == t ? v : !0;try {
          O.style[v] = o;
        } catch (g) {}if (O.style[v] != h) return u(), "pfx" == t ? v : !0;
      }
    }return u(), !1;
  }function v(e, t, n, o, i) {
    var s = e.charAt(0).toUpperCase() + e.slice(1),
        a = (e + " " + z.join(s + " ") + s).split(" ");return r(t, "string") || r(t, "undefined") ? m(a, t, o, i) : (a = (e + " " + b.join(s + " ") + s).split(" "), l(a, t, n));
  }function h(e, t, r) {
    return v(e, n, n, t, r);
  }var y = [],
      g = { _version: "3.3.1", _config: { classPrefix: "", enableClasses: !0, enableJSClass: !0, usePrefixes: !0 }, _q: [], on: function on(e, t) {
      var n = this;setTimeout(function () {
        t(n[e]);
      }, 0);
    }, addTest: function addTest(e, t, n) {
      y.push({ name: e, fn: t, options: n });
    }, addAsyncTest: function addAsyncTest(e) {
      y.push({ name: null, fn: e });
    } },
      Modernizr = function Modernizr() {};Modernizr.prototype = g, Modernizr = new Modernizr(), Modernizr.addTest("eventlistener", "addEventListener" in e), Modernizr.addTest("queryselector", "querySelector" in t && "querySelectorAll" in t), Modernizr.addTest("history", function () {
    var t = navigator.userAgent;return -1 === t.indexOf("Android 2.") && -1 === t.indexOf("Android 4.0") || -1 === t.indexOf("Mobile Safari") || -1 !== t.indexOf("Chrome") || -1 !== t.indexOf("Windows Phone") ? e.history && "pushState" in e.history : !1;
  });var x = [],
      C = g._config.usePrefixes ? " -webkit- -moz- -o- -ms- ".split(" ") : ["", ""];g._prefixes = C;var S = t.documentElement;Modernizr.addTest("classlist", "classList" in S), Modernizr.addTest("documentfragment", function () {
    return "createDocumentFragment" in t && "appendChild" in S;
  });var T = "svg" === S.nodeName.toLowerCase();Modernizr.addTest("opacity", function () {
    var e = s("a").style;return e.cssText = C.join("opacity:.55;"), /^0.55$/.test(e.opacity);
  }), Modernizr.addTest("csspointerevents", function () {
    var e = s("a").style;return e.cssText = "pointer-events:auto", "auto" === e.pointerEvents;
  }), Modernizr.addTest("cssremunit", function () {
    var e = s("a").style;try {
      e.fontSize = "3rem";
    } catch (t) {}return (/rem/.test(e.fontSize)
    );
  });var w = g.testStyles = u;Modernizr.addTest("touchevents", function () {
    var n;if ("ontouchstart" in e || e.DocumentTouch && t instanceof DocumentTouch) n = !0;else {
      var r = ["@media (", C.join("touch-enabled),("), "heartz", ")", "{#modernizr{top:9px;position:absolute}}"].join("");w(r, function (e) {
        n = 9 === e.offsetTop;
      });
    }return n;
  });var _ = "Moz O ms Webkit",
      z = g._config.usePrefixes ? _.split(" ") : [];g._cssomPrefixes = z;var A = function A(t) {
    var r,
        o = C.length,
        i = e.CSSRule;if ("undefined" == typeof i) return n;if (!t) return !1;if (t = t.replace(/^@/, ""), r = t.replace(/-/g, "_").toUpperCase() + "_RULE", r in i) return "@" + t;for (var s = 0; o > s; s++) {
      var a = C[s],
          u = a.toUpperCase() + "_" + r;if (u in i) return "@-" + a.toLowerCase() + "-" + t;
    }return !1;
  };g.atRule = A;var b = g._config.usePrefixes ? _.toLowerCase().split(" ") : [];g._domPrefixes = b;var E = { elem: s("modernizr") };Modernizr._q.push(function () {
    delete E.elem;
  });var O = { style: E.elem.style };Modernizr._q.unshift(function () {
    delete O.style;
  }), g.testAllProps = v;var P = g.prefixed = function (e, t, n) {
    return 0 === e.indexOf("@") ? A(e) : (-1 != e.indexOf("-") && (e = i(e)), t ? v(e, t, n) : v(e, "pfx"));
  };Modernizr.addTest("requestanimationframe", !!P("requestAnimationFrame", e), { aliases: ["raf"] }), Modernizr.addTest("matchmedia", !!P("matchMedia", e)), g.testAllProps = h, Modernizr.addTest("csstransforms", function () {
    return -1 === navigator.userAgent.indexOf("Android 2.") && h("transform", "scale(1)", !0);
  }), o(), delete g.addTest, delete g.addAsyncTest;for (var q = 0; q < Modernizr._q.length; q++) {
    Modernizr._q[q]();
  }e.Modernizr = Modernizr;
}(window, document);

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unhide = undefined;
exports.hasFeatures = hasFeatures;
exports.show = show;
exports.hide = hide;
exports.unshow = unshow;
exports.defineCustomElement = defineCustomElement;
exports.ensureCustomElements = ensureCustomElements;
exports.matches = matches;

require('../lib/modernizr');

function hasFeatures(features) {
  var acc = true;
  for (var i = 0; i < features.length; i += 1) {
    var feature = features[i];
    var hasFeature = window.Modernizr[feature];
    // if (!hasFeature) console.warn('Feature "' + feature + '" missing!');
    acc = acc && hasFeature;
  }
  return acc;
}

function show(el) {
  el.style.display = 'block'; // eslint-disable-line no-param-reassign
  el.style.visibility = 'visible'; // eslint-disable-line no-param-reassign
}

function hide(el) {
  el.style.display = 'none'; // eslint-disable-line no-param-reassign
  el.style.visibility = 'hidden'; // eslint-disable-line no-param-reassign
}

function unshow(el) {
  el.style.display = ''; // eslint-disable-line no-param-reassign
  el.style.visibility = ''; // eslint-disable-line no-param-reassign
}

var unhide = exports.unhide = unshow;

function defineCustomElement(tagName, CustomHTMLElement) {
  if ('customElements' in window) {
    customElements.define(tagName, CustomHTMLElement);
  } else if ('registerElement' in document) {
    document.registerElement(tagName, CustomHTMLElement);
  }
}

function ensureCustomElements(f) {
  if ('customElements' in window || 'registerElement' in document) {
    f();
  } else {
    if (!window.loadingCustomElements) loadJSDeferred('https://unpkg.com/webcomponents.js@0.7.22/CustomElements.min.js');
    window.loadingCustomElements = true;
    window.addEventListener('WebComponentsReady', f);
  }
}

function matches(el, selector) {
  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
}

},{"../lib/modernizr":1}],3:[function(require,module,exports){
'use strict';

var _vanilla = require('y-drawer/src/vanilla');

var _vanilla2 = _interopRequireDefault(_vanilla);

var _common = require('./common');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

var REQUIREMENTS = ['eventlistener', 'queryselector', 'matchmedia', 'requestanimationframe', 'classlist', 'opacity', 'csstransforms', 'csspointerevents', 'cssremunit'];

var MEDIA_QUERY = '(min-width: 801px)';

function resizeCallback() {
  var hasChanged = window.isDesktop !== window.matchMedia(MEDIA_QUERY).matches;
  if (hasChanged) {
    window.isDesktop = !window.isDesktop;
    window.drawer.persistent = window.isDesktop;
    window.drawer.jumpTo(window.isDesktop);
  }
}

function menuClickClallback(e) {
  if (!window.isDesktop) {
    e.preventDefault();
    window.drawer.toggle();
  }
}

function addEventListeners(drawer) {
  window.drawer = drawer;
  window.addEventListener('resize', resizeCallback);
  document.getElementById('_menu').addEventListener('click', menuClickClallback);
}

if ((0, _common.hasFeatures)(REQUIREMENTS)) {
  window.isDesktop = window.matchMedia(MEDIA_QUERY).matches;
  var drawer = document.querySelector('#y-drawer');

  addEventListeners(new _vanilla2.default(drawer, {
    opened: window.isDesktop,
    persistent: window.isDesktop,
    transitionDuration: 150
  }));

  drawer.classList.add('loaded');
}

},{"./common":2,"y-drawer/src/vanilla":141}],4:[function(require,module,exports){
'use strict';

require('core-js/fn/array/for-each');

require('core-js/fn/function/bind');

require('core-js/fn/number/constructor');

require('core-js/fn/object/assign');

require('core-js/fn/object/define-property');

require('core-js/fn/object/keys');

require('core-js/fn/array/reduce');

require('web-animations-js');

require('./style');

require('./katex');

require('./drawer');

require('./push-state');

},{"./drawer":3,"./katex":5,"./push-state":6,"./style":7,"core-js/fn/array/for-each":8,"core-js/fn/array/reduce":9,"core-js/fn/function/bind":10,"core-js/fn/number/constructor":11,"core-js/fn/object/assign":12,"core-js/fn/object/define-property":13,"core-js/fn/object/keys":14,"web-animations-js":137}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = upgradeMathBlocks;

var _loadCSS = require('fg-loadcss/src/loadCSS');

var _katex = require('katex');

var _katex2 = _interopRequireDefault(_katex);

var _common = require('./common');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var REQUIREMENTS = ['eventlistener', 'queryselector', 'requestanimationframe']; /* eslint-disable no-param-reassign */

function willChangeContent(mathBlocks) {
  Array.prototype.forEach.call(mathBlocks, function (el) {
    el.style.willChange = 'content'; // eslint-disable-line no-param-reassign
  });
}

function replaceMathBlock(el, tex) {
  el.outerHTML = _katex2.default.renderToString(tex, {
    displayMode: el.type === 'math/tex; mode=display'
  });
}

function renderKatex(el, tex) {
  try {
    var prev = el.previousElementSibling;
    replaceMathBlock(el, tex);
    if (prev && (0, _common.matches)(prev, '.MathJax_Preview')) (0, _common.hide)(prev);
  } catch (e) {
    // TODO: remove in production builds?
    console.error(e); // eslint-disable-line no-console
  } finally {
    el.style.willChange = '';
  }
}

function readTexSource(el) {
  return el.textContent.replace('% <![CDATA[', '').replace('%]]>', '');
}

function changeContent(mathBlocks) {
  // kramdown generates script tags with type "math/tex"
  Array.prototype.forEach.call(mathBlocks, function (script) {
    var tex = readTexSource(script);
    renderKatex(script, tex);
  });
}

function upgradeMathBlocks() {
  if ((0, _common.hasFeatures)(REQUIREMENTS)) {
    var mathBlocks = document.querySelectorAll('script[type^="math/tex"]');
    if (mathBlocks.length) {
      willChangeContent(mathBlocks);
      requestAnimationFrame(function () {
        return changeContent(mathBlocks);
      });
    }
  }
}

if ((0, _common.hasFeatures)(REQUIREMENTS)) {
  var ref = document.getElementsByTagName('style')[0];
  var style = (0, _loadCSS.loadCSS)('https://unpkg.com/katex@0.6.0/dist/katex.min.css', ref);
  style.addEventListener('load', upgradeMathBlocks);
}

},{"./common":2,"fg-loadcss/src/loadCSS":76,"katex":77}],6:[function(require,module,exports){
'use strict';

var _Observable = require('rxjs/Observable');

require('rxjs/add/observable/fromEvent');

require('rxjs/add/operator/debounceTime');

require('rxjs/add/operator/do');

require('rxjs/add/operator/map');

require('rxjs/add/operator/observeOn');

var _animationFrame = require('rxjs/scheduler/animationFrame');

var _vanilla = require('y-push-state/src/vanilla');

var _vanilla2 = _interopRequireDefault(_vanilla);

var _common = require('./common');

var _katex = require('./katex');

var _katex2 = _interopRequireDefault(_katex);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/* eslint-disable no-param-reassign, import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

var REQUIREMENTS = ['eventlistener', 'queryselector', 'requestanimationframe', 'classlist', 'documentfragment', 'history'];

var DURATION = 200;

var pushState = document.querySelector('#y-push-state');

if ((0, _common.hasFeatures)(REQUIREMENTS)) {
  // pushState.addEventListener('y-push-state-error', errorCallback);

  _Observable.Observable.fromEvent(pushState, 'y-push-state-before').map(function () {
    return document.querySelector('main');
  }).do(function (main) {
    main.style.willChange = 'opacity';
  }).observeOn(_animationFrame.animationFrame).subscribe(function (main) {
    // document.body.classList.add('is-loading');

    main.animate([{ opacity: 1 }, { opacity: 0 }], {
      duration: DURATION,
      easing: 'cubic-bezier(0,0,0.32,1)',
      fill: 'forwards'
    });
    // .addEventListener('finish', () => {
    //   main.style.opacity = 0;
    // });

    // unshow(error);

    // if a link on the drawer has been clicked, close it
    if (!window.isDesktop && window.drawer.opened) {
      window.drawer.close();
    }
  });

  _Observable.Observable.fromEvent(pushState, 'y-push-state-after').map(function () {
    return document.querySelector('main');
  }).do(function (main) {
    main.style.willChange = 'transform, opacity'; // eslint-disable-line no-param-reassign
  }).observeOn(_animationFrame.animationFrame).do(function (main) {
    // document.body.classList.remove('is-loading')
    console.log('afterseq');

    main.animate([{ transform: 'translateY(-2rem)', opacity: 0 }, { transform: 'translateY(0)', opacity: 1 }], {
      duration: DURATION,
      easing: 'cubic-bezier(0,0,0.32,1)'
    }).addEventListener('finish', function () {
      main.style.willChange = '';
    });
  }).debounceTime(200).subscribe(function () {
    // send google analytics pageview
    if (window.ga) window.ga('send', 'pageview');

    // upgrade math blocks
    (0, _katex2.default)();
  });

  new _vanilla2.default(pushState, {
    replaceIds: ['_main', '_asidebar'],
    linkSelector: 'a[href^="/"]',
    scrollRestoration: true,
    duration: DURATION
  }).startHistory();
}

},{"./common":2,"./katex":5,"rxjs/Observable":103,"rxjs/add/observable/fromEvent":108,"rxjs/add/operator/debounceTime":109,"rxjs/add/operator/do":110,"rxjs/add/operator/map":111,"rxjs/add/operator/observeOn":112,"rxjs/scheduler/animationFrame":124,"y-push-state/src/vanilla":238}],7:[function(require,module,exports){
'use strict';

var _loadCSS = require('fg-loadcss/src/loadCSS');

function hasPreloadSupport() {
  try {
    return document.createElement('link').relList.supports('preload');
  } catch (e) {
    return false;
  }
}

// loop preload links and fetch using loadCSS
function polyfill() {
  var links = document.getElementsByTagName('link');

  for (var i = 0; i < links.length; i += 1) {
    var link = links[i];
    if (link.rel === 'preload' && link.getAttribute('as') === 'style') {
      (0, _loadCSS.loadCSS)(link.href, link);
      link.rel = null;
    }
  }
}

if (!hasPreloadSupport()) {
  polyfill();
}

},{"fg-loadcss/src/loadCSS":76}],8:[function(require,module,exports){
require('../../modules/es6.array.for-each');
module.exports = require('../../modules/_core').Array.forEach;
},{"../../modules/_core":24,"../../modules/es6.array.for-each":69}],9:[function(require,module,exports){
require('../../modules/es6.array.reduce');
module.exports = require('../../modules/_core').Array.reduce;
},{"../../modules/_core":24,"../../modules/es6.array.reduce":70}],10:[function(require,module,exports){
require('../../modules/es6.function.bind');
module.exports = require('../../modules/_core').Function.bind;
},{"../../modules/_core":24,"../../modules/es6.function.bind":71}],11:[function(require,module,exports){
require('../../modules/es6.number.constructor');
module.exports = Number;
},{"../../modules/es6.number.constructor":72}],12:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;
},{"../../modules/_core":24,"../../modules/es6.object.assign":73}],13:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};
},{"../../modules/_core":24,"../../modules/es6.object.define-property":74}],14:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/_core').Object.keys;
},{"../../modules/_core":24,"../../modules/es6.object.keys":75}],15:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],16:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":41}],17:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":61,"./_to-iobject":63,"./_to-length":64}],18:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = require('./_ctx')
  , IObject  = require('./_iobject')
  , toObject = require('./_to-object')
  , toLength = require('./_to-length')
  , asc      = require('./_array-species-create');
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./_array-species-create":21,"./_ctx":25,"./_iobject":39,"./_to-length":64,"./_to-object":65}],19:[function(require,module,exports){
var aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , IObject   = require('./_iobject')
  , toLength  = require('./_to-length');

module.exports = function(that, callbackfn, aLen, memo, isRight){
  aFunction(callbackfn);
  var O      = toObject(that)
    , self   = IObject(O)
    , length = toLength(O.length)
    , index  = isRight ? length - 1 : 0
    , i      = isRight ? -1 : 1;
  if(aLen < 2)for(;;){
    if(index in self){
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if(isRight ? index < 0 : length <= index){
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};
},{"./_a-function":15,"./_iobject":39,"./_to-length":64,"./_to-object":65}],20:[function(require,module,exports){
var isObject = require('./_is-object')
  , isArray  = require('./_is-array')
  , SPECIES  = require('./_wks')('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};
},{"./_is-array":40,"./_is-object":41,"./_wks":68}],21:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};
},{"./_array-species-constructor":20}],22:[function(require,module,exports){
'use strict';
var aFunction  = require('./_a-function')
  , isObject   = require('./_is-object')
  , invoke     = require('./_invoke')
  , arraySlice = [].slice
  , factories  = {};

var construct = function(F, len, args){
  if(!(len in factories)){
    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /*, args... */){
  var fn       = aFunction(this)
    , partArgs = arraySlice.call(arguments, 1);
  var bound = function(/* args... */){
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if(isObject(fn.prototype))bound.prototype = fn.prototype;
  return bound;
};
},{"./_a-function":15,"./_invoke":38,"./_is-object":41}],23:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],24:[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],25:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":15}],26:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],27:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":31}],28:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":32,"./_is-object":41}],29:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],30:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , hide      = require('./_hide')
  , redefine  = require('./_redefine')
  , ctx       = require('./_ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":24,"./_ctx":25,"./_global":32,"./_hide":34,"./_redefine":54}],31:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],32:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],33:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],34:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":27,"./_object-dp":44,"./_property-desc":53}],35:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":32}],36:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":27,"./_dom-create":28,"./_fails":31}],37:[function(require,module,exports){
var isObject       = require('./_is-object')
  , setPrototypeOf = require('./_set-proto').set;
module.exports = function(that, target, C){
  var P, S = target.constructor;
  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
    setPrototypeOf(that, P);
  } return that;
};
},{"./_is-object":41,"./_set-proto":55}],38:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],39:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":23}],40:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":23}],41:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],42:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = require('./_object-keys')
  , gOPS     = require('./_object-gops')
  , pIE      = require('./_object-pie')
  , toObject = require('./_to-object')
  , IObject  = require('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":31,"./_iobject":39,"./_object-gops":48,"./_object-keys":50,"./_object-pie":51,"./_to-object":65}],43:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":16,"./_dom-create":28,"./_enum-bug-keys":29,"./_html":35,"./_object-dps":45,"./_shared-key":56}],44:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":16,"./_descriptors":27,"./_ie8-dom-define":36,"./_to-primitive":66}],45:[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":16,"./_descriptors":27,"./_object-dp":44,"./_object-keys":50}],46:[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":27,"./_has":33,"./_ie8-dom-define":36,"./_object-pie":51,"./_property-desc":53,"./_to-iobject":63,"./_to-primitive":66}],47:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":29,"./_object-keys-internal":49}],48:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],49:[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":17,"./_has":33,"./_shared-key":56,"./_to-iobject":63}],50:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":29,"./_object-keys-internal":49}],51:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],52:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export')
  , core    = require('./_core')
  , fails   = require('./_fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./_core":24,"./_export":30,"./_fails":31}],53:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],54:[function(require,module,exports){
var global    = require('./_global')
  , hide      = require('./_hide')
  , has       = require('./_has')
  , SRC       = require('./_uid')('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
},{"./_core":24,"./_global":32,"./_has":33,"./_hide":34,"./_uid":67}],55:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object')
  , anObject = require('./_an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./_an-object":16,"./_ctx":25,"./_is-object":41,"./_object-gopd":46}],56:[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":57,"./_uid":67}],57:[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":32}],58:[function(require,module,exports){
var fails = require('./_fails');

module.exports = function(method, arg){
  return !!method && fails(function(){
    arg ? method.call(null, function(){}, 1) : method.call(null);
  });
};
},{"./_fails":31}],59:[function(require,module,exports){
var $export = require('./_export')
  , defined = require('./_defined')
  , fails   = require('./_fails')
  , spaces  = require('./_string-ws')
  , space   = '[' + spaces + ']'
  , non     = '\u200b\u0085'
  , ltrim   = RegExp('^' + space + space + '*')
  , rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function(string, TYPE){
  string = String(defined(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;
},{"./_defined":26,"./_export":30,"./_fails":31,"./_string-ws":60}],60:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
},{}],61:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":62}],62:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],63:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":26,"./_iobject":39}],64:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":62}],65:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":26}],66:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":41}],67:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],68:[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":32,"./_shared":57,"./_uid":67}],69:[function(require,module,exports){
'use strict';
var $export  = require('./_export')
  , $forEach = require('./_array-methods')(0)
  , STRICT   = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */){
    return $forEach(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":18,"./_export":30,"./_strict-method":58}],70:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});
},{"./_array-reduce":19,"./_export":30,"./_strict-method":58}],71:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', {bind: require('./_bind')});
},{"./_bind":22,"./_export":30}],72:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , has               = require('./_has')
  , cof               = require('./_cof')
  , inheritIfRequired = require('./_inherit-if-required')
  , toPrimitive       = require('./_to-primitive')
  , fails             = require('./_fails')
  , gOPN              = require('./_object-gopn').f
  , gOPD              = require('./_object-gopd').f
  , dP                = require('./_object-dp').f
  , $trim             = require('./_string-trim').trim
  , NUMBER            = 'Number'
  , $Number           = global[NUMBER]
  , Base              = $Number
  , proto             = $Number.prototype
  // Opera ~12 has broken Object#toString
  , BROKEN_COF        = cof(require('./_object-create')(proto)) == NUMBER
  , TRIM              = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function(argument){
  var it = toPrimitive(argument, false);
  if(typeof it == 'string' && it.length > 2){
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0)
      , third, radix, maxCode;
    if(first === 43 || first === 45){
      third = it.charCodeAt(2);
      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if(first === 48){
      switch(it.charCodeAt(1)){
        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default : return +it;
      }
      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if(code < 48 || code > maxCode)return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
  $Number = function Number(value){
    var it = arguments.length < 1 ? 0 : value
      , that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for(var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++){
    if(has(Base, key = keys[j]) && !has($Number, key)){
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}
},{"./_cof":23,"./_descriptors":27,"./_fails":31,"./_global":32,"./_has":33,"./_inherit-if-required":37,"./_object-create":43,"./_object-dp":44,"./_object-gopd":46,"./_object-gopn":47,"./_redefine":54,"./_string-trim":59,"./_to-primitive":66}],73:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});
},{"./_export":30,"./_object-assign":42}],74:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});
},{"./_descriptors":27,"./_export":30,"./_object-dp":44}],75:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object')
  , $keys    = require('./_object-keys');

require('./_object-sap')('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./_object-keys":50,"./_object-sap":52,"./_to-object":65}],76:[function(require,module,exports){
(function (global){
/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
(function(w){
	"use strict";
	/* exported loadCSS */
	var loadCSS = function( href, before, media ){
		// Arguments explained:
		// `href` [REQUIRED] is the URL for your CSS file.
		// `before` [OPTIONAL] is the element the script should use as a reference for injecting our stylesheet <link> before
			// By default, loadCSS attempts to inject the link after the last stylesheet or script in the DOM. However, you might desire a more specific location in your document.
		// `media` [OPTIONAL] is the media type or query of the stylesheet. By default it will be 'all'
		var doc = w.document;
		var ss = doc.createElement( "link" );
		var ref;
		if( before ){
			ref = before;
		}
		else {
			var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
			ref = refs[ refs.length - 1];
		}

		var sheets = doc.styleSheets;
		ss.rel = "stylesheet";
		ss.href = href;
		// temporarily set media to something inapplicable to ensure it'll fetch without blocking render
		ss.media = "only x";

		// wait until body is defined before injecting link. This ensures a non-blocking load in IE11.
		function ready( cb ){
			if( doc.body ){
				return cb();
			}
			setTimeout(function(){
				ready( cb );
			});
		}
		// Inject link
			// Note: the ternary preserves the existing behavior of "before" argument, but we could choose to change the argument to "after" in a later release and standardize on ref.nextSibling for all refs
			// Note: `insertBefore` is used instead of `appendChild`, for safety re: http://www.paulirish.com/2011/surefire-dom-element-insertion/
		ready( function(){
			ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
		});
		// A method (exposed on return object for external use) that mimics onload by polling document.styleSheets until it includes the new sheet.
		var onloadcssdefined = function( cb ){
			var resolvedHref = ss.href;
			var i = sheets.length;
			while( i-- ){
				if( sheets[ i ].href === resolvedHref ){
					return cb();
				}
			}
			setTimeout(function() {
				onloadcssdefined( cb );
			});
		};

		function loadCB(){
			if( ss.addEventListener ){
				ss.removeEventListener( "load", loadCB );
			}
			ss.media = media || "all";
		}

		// once loaded, set link's media back to `all` so that the stylesheet applies once it loads
		if( ss.addEventListener ){
			ss.addEventListener( "load", loadCB);
		}
		ss.onloadcssdefined = onloadcssdefined;
		onloadcssdefined( loadCB );
		return ss;
	};
	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],77:[function(require,module,exports){
/* eslint no-console:0 */
/**
 * This is the main entry point for KaTeX. Here, we expose functions for
 * rendering expressions either to DOM nodes or to markup strings.
 *
 * We also expose the ParseError class to check if errors thrown from KaTeX are
 * errors in the expression, or errors in javascript handling.
 */

var ParseError = require("./src/ParseError");
var Settings = require("./src/Settings");

var buildTree = require("./src/buildTree");
var parseTree = require("./src/parseTree");
var utils = require("./src/utils");

/**
 * Parse and build an expression, and place that expression in the DOM node
 * given.
 */
var render = function(expression, baseNode, options) {
    utils.clearNode(baseNode);

    var settings = new Settings(options);

    var tree = parseTree(expression, settings);
    var node = buildTree(tree, expression, settings).toNode();

    baseNode.appendChild(node);
};

// KaTeX's styles don't work properly in quirks mode. Print out an error, and
// disable rendering.
if (typeof document !== "undefined") {
    if (document.compatMode !== "CSS1Compat") {
        typeof console !== "undefined" && console.warn(
            "Warning: KaTeX doesn't work in quirks mode. Make sure your " +
                "website has a suitable doctype.");

        render = function() {
            throw new ParseError("KaTeX doesn't work in quirks mode.");
        };
    }
}

/**
 * Parse and build an expression, and return the markup for that.
 */
var renderToString = function(expression, options) {
    var settings = new Settings(options);

    var tree = parseTree(expression, settings);
    return buildTree(tree, expression, settings).toMarkup();
};

/**
 * Parse an expression and return the parse tree.
 */
var generateParseTree = function(expression, options) {
    var settings = new Settings(options);
    return parseTree(expression, settings);
};

module.exports = {
    render: render,
    renderToString: renderToString,
    /**
     * NOTE: This method is not currently recommended for public use.
     * The internal tree representation is unstable and is very likely
     * to change. Use at your own risk.
     */
    __parse: generateParseTree,
    ParseError: ParseError
};

},{"./src/ParseError":81,"./src/Settings":83,"./src/buildTree":88,"./src/parseTree":97,"./src/utils":100}],78:[function(require,module,exports){
/**
 * The Lexer class handles tokenizing the input in various ways. Since our
 * parser expects us to be able to backtrack, the lexer allows lexing from any
 * given starting point.
 *
 * Its main exposed function is the `lex` function, which takes a position to
 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
 * function.
 *
 * The various `_innerLex` functions perform the actual lexing of different
 * kinds.
 */

var matchAt = require("match-at");

var ParseError = require("./ParseError");

// The main lexer class
function Lexer(input) {
    this.input = input;
    this.pos = 0;
}

/**
 * The resulting token returned from `lex`.
 *
 * It consists of the token text plus some position information.
 * The position information is essentially a range in an input string,
 * but instead of referencing the bare input string, we refer to the lexer.
 * That way it is possible to attach extra metadata to the input string,
 * like for example a file name or similar.
 *
 * The position information (all three parameters) is optional,
 * so it is OK to construct synthetic tokens if appropriate.
 * Not providing available position information may lead to
 * degraded error reporting, though.
 *
 * @param {string}  text   the text of this token
 * @param {number=} start  the start offset, zero-based inclusive
 * @param {number=} end    the end offset, zero-based exclusive
 * @param {Lexer=}  lexer  the lexer which in turn holds the input string
 */
function Token(text, start, end, lexer) {
    this.text = text;
    this.start = start;
    this.end = end;
    this.lexer = lexer;
}

/**
 * Given a pair of tokens (this and endToken), compute a Token encompassing
 * the whole input range enclosed by these two.
 *
 * @param {Token}  endToken  last token of the range, inclusive
 * @param {string} text      the text of the newly constructed token
 */
Token.prototype.range = function(endToken, text) {
    if (endToken.lexer !== this.lexer) {
        return new Token(text); // sorry, no position information available
    }
    return new Token(text, this.start, endToken.end, this.lexer);
};

/* The following tokenRegex
 * - matches typical whitespace (but not NBSP etc.) using its first group
 * - does not match any control character \x00-\x1f except whitespace
 * - does not match a bare backslash
 * - matches any ASCII character except those just mentioned
 * - does not match the BMP private use area \uE000-\uF8FF
 * - does not match bare surrogate code units
 * - matches any BMP character except for those just described
 * - matches any valid Unicode surrogate pair
 * - matches a backslash followed by one or more letters
 * - matches a backslash followed by any BMP character, including newline
 * Just because the Lexer matches something doesn't mean it's valid input:
 * If there is no matching function or symbol definition, the Parser will
 * still reject the input.
 */
var tokenRegex = new RegExp(
    "([ \r\n\t]+)|" +                                 // whitespace
    "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" +  // single codepoint
    "|[\uD800-\uDBFF][\uDC00-\uDFFF]" +               // surrogate pair
    "|\\\\(?:[a-zA-Z]+|[^\uD800-\uDFFF])" +           // function name
    ")"
);

/**
 * This function lexes a single token.
 */
Lexer.prototype.lex = function() {
    var input = this.input;
    var pos = this.pos;
    if (pos === input.length) {
        return new Token("EOF", pos, pos, this);
    }
    var match = matchAt(tokenRegex, input, pos);
    if (match === null) {
        throw new ParseError(
            "Unexpected character: '" + input[pos] + "'",
            new Token(input[pos], pos, pos + 1, this));
    }
    var text = match[2] || " ";
    var start = this.pos;
    this.pos += match[0].length;
    var end = this.pos;
    return new Token(text, start, end, this);
};

module.exports = Lexer;

},{"./ParseError":81,"match-at":101}],79:[function(require,module,exports){
/**
 * This file contains the gullet where macros are expanded
 * until only non-macro tokens remain.
 */

var Lexer = require("./Lexer");

function MacroExpander(input, macros) {
    this.lexer = new Lexer(input);
    this.macros = macros;
    this.stack = []; // contains tokens in REVERSE order
    this.discardedWhiteSpace = [];
}

/**
 * Recursively expand first token, then return first non-expandable token.
 */
MacroExpander.prototype.nextToken = function() {
    for (;;) {
        if (this.stack.length === 0) {
            this.stack.push(this.lexer.lex());
        }
        var topToken = this.stack.pop();
        var name = topToken.text;
        if (!(name.charAt(0) === "\\" && this.macros.hasOwnProperty(name))) {
            return topToken;
        }
        var expansion = this.macros[name];
        if (typeof expansion === "string") {
            var bodyLexer = new Lexer(expansion);
            expansion = [];
            var tok = bodyLexer.lex();
            while (tok.text !== "EOF") {
                expansion.push(tok);
                tok = bodyLexer.lex();
            }
            expansion.reverse(); // to fit in with stack using push and pop
            this.macros[name] = expansion;
        }
        this.stack = this.stack.concat(expansion);
    }
};

MacroExpander.prototype.get = function(ignoreSpace) {
    this.discardedWhiteSpace = [];
    var token = this.nextToken();
    if (ignoreSpace) {
        while (token.text === " ") {
            this.discardedWhiteSpace.push(token);
            token = this.nextToken();
        }
    }
    return token;
};

/**
 * Undo the effect of the preceding call to the get method.
 * A call to this method MUST be immediately preceded and immediately followed
 * by a call to get.  Only used during mode switching, i.e. after one token
 * was got in the old mode but should get got again in a new mode
 * with possibly different whitespace handling.
 */
MacroExpander.prototype.unget = function(token) {
    this.stack.push(token);
    while (this.discardedWhiteSpace.length !== 0) {
        this.stack.push(this.discardedWhiteSpace.pop());
    }
};

module.exports = MacroExpander;

},{"./Lexer":78}],80:[function(require,module,exports){
/**
 * This file contains information about the options that the Parser carries
 * around with it while parsing. Data is held in an `Options` object, and when
 * recursing, a new `Options` object can be created with the `.with*` and
 * `.reset` functions.
 */

/**
 * This is the main options class. It contains the style, size, color, and font
 * of the current parse level. It also contains the style and size of the parent
 * parse level, so size changes can be handled efficiently.
 *
 * Each of the `.with*` and `.reset` functions passes its current style and size
 * as the parentStyle and parentSize of the new options class, so parent
 * handling is taken care of automatically.
 */
function Options(data) {
    this.style = data.style;
    this.color = data.color;
    this.size = data.size;
    this.phantom = data.phantom;
    this.font = data.font;

    if (data.parentStyle === undefined) {
        this.parentStyle = data.style;
    } else {
        this.parentStyle = data.parentStyle;
    }

    if (data.parentSize === undefined) {
        this.parentSize = data.size;
    } else {
        this.parentSize = data.parentSize;
    }
}

/**
 * Returns a new options object with the same properties as "this".  Properties
 * from "extension" will be copied to the new options object.
 */
Options.prototype.extend = function(extension) {
    var data = {
        style: this.style,
        size: this.size,
        color: this.color,
        parentStyle: this.style,
        parentSize: this.size,
        phantom: this.phantom,
        font: this.font
    };

    for (var key in extension) {
        if (extension.hasOwnProperty(key)) {
            data[key] = extension[key];
        }
    }

    return new Options(data);
};

/**
 * Create a new options object with the given style.
 */
Options.prototype.withStyle = function(style) {
    return this.extend({
        style: style
    });
};

/**
 * Create a new options object with the given size.
 */
Options.prototype.withSize = function(size) {
    return this.extend({
        size: size
    });
};

/**
 * Create a new options object with the given color.
 */
Options.prototype.withColor = function(color) {
    return this.extend({
        color: color
    });
};

/**
 * Create a new options object with "phantom" set to true.
 */
Options.prototype.withPhantom = function() {
    return this.extend({
        phantom: true
    });
};

/**
 * Create a new options objects with the give font.
 */
Options.prototype.withFont = function(font) {
    return this.extend({
        font: font || this.font
    });
};

/**
 * Create a new options object with the same style, size, and color. This is
 * used so that parent style and size changes are handled correctly.
 */
Options.prototype.reset = function() {
    return this.extend({});
};

/**
 * A map of color names to CSS colors.
 * TODO(emily): Remove this when we have real macros
 */
var colorMap = {
    "katex-blue": "#6495ed",
    "katex-orange": "#ffa500",
    "katex-pink": "#ff00af",
    "katex-red": "#df0030",
    "katex-green": "#28ae7b",
    "katex-gray": "gray",
    "katex-purple": "#9d38bd",
    "katex-blueA": "#ccfaff",
    "katex-blueB": "#80f6ff",
    "katex-blueC": "#63d9ea",
    "katex-blueD": "#11accd",
    "katex-blueE": "#0c7f99",
    "katex-tealA": "#94fff5",
    "katex-tealB": "#26edd5",
    "katex-tealC": "#01d1c1",
    "katex-tealD": "#01a995",
    "katex-tealE": "#208170",
    "katex-greenA": "#b6ffb0",
    "katex-greenB": "#8af281",
    "katex-greenC": "#74cf70",
    "katex-greenD": "#1fab54",
    "katex-greenE": "#0d923f",
    "katex-goldA": "#ffd0a9",
    "katex-goldB": "#ffbb71",
    "katex-goldC": "#ff9c39",
    "katex-goldD": "#e07d10",
    "katex-goldE": "#a75a05",
    "katex-redA": "#fca9a9",
    "katex-redB": "#ff8482",
    "katex-redC": "#f9685d",
    "katex-redD": "#e84d39",
    "katex-redE": "#bc2612",
    "katex-maroonA": "#ffbde0",
    "katex-maroonB": "#ff92c6",
    "katex-maroonC": "#ed5fa6",
    "katex-maroonD": "#ca337c",
    "katex-maroonE": "#9e034e",
    "katex-purpleA": "#ddd7ff",
    "katex-purpleB": "#c6b9fc",
    "katex-purpleC": "#aa87ff",
    "katex-purpleD": "#7854ab",
    "katex-purpleE": "#543b78",
    "katex-mintA": "#f5f9e8",
    "katex-mintB": "#edf2df",
    "katex-mintC": "#e0e5cc",
    "katex-grayA": "#f6f7f7",
    "katex-grayB": "#f0f1f2",
    "katex-grayC": "#e3e5e6",
    "katex-grayD": "#d6d8da",
    "katex-grayE": "#babec2",
    "katex-grayF": "#888d93",
    "katex-grayG": "#626569",
    "katex-grayH": "#3b3e40",
    "katex-grayI": "#21242c",
    "katex-kaBlue": "#314453",
    "katex-kaGreen": "#71B307"
};

/**
 * Gets the CSS color of the current options object, accounting for the
 * `colorMap`.
 */
Options.prototype.getColor = function() {
    if (this.phantom) {
        return "transparent";
    } else {
        return colorMap[this.color] || this.color;
    }
};

module.exports = Options;

},{}],81:[function(require,module,exports){
/**
 * This is the ParseError class, which is the main error thrown by KaTeX
 * functions when something has gone wrong. This is used to distinguish internal
 * errors from errors in the expression that the user provided.
 *
 * If possible, a caller should provide a Token or ParseNode with information
 * about where in the source string the problem occurred.
 *
 * @param {string} message  The error message
 * @param {(Token|ParseNode)=} token  An object providing position information
 */
function ParseError(message, token) {
    var error = "KaTeX parse error: " + message;
    var start;
    var end;

    if (token && token.lexer && token.start <= token.end) {
        // If we have the input and a position, make the error a bit fancier

        // Get the input
        var input = token.lexer.input;

        // Prepend some information
        start = token.start;
        end = token.end;
        if (start === input.length) {
            error += " at end of input: ";
        } else {
            error += " at position " + (start + 1) + ": ";
        }

        // Underline token in question using combining underscores
        var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");

        // Extract some context from the input and add it to the error
        var left;
        if (start > 15) {
            left = "" + input.slice(start - 15, start);
        } else {
            left = input.slice(0, start);
        }
        var right;
        if (end + 15 < input.length) {
            right = input.slice(end, end + 15) + "";
        } else {
            right = input.slice(end);
        }
        error += left + underlined + right;
    }

    // Some hackery to make ParseError a prototype of Error
    // See http://stackoverflow.com/a/8460753
    var self = new Error(error);
    self.name = "ParseError";
    self.__proto__ = ParseError.prototype;

    self.position = start;
    return self;
}

// More hackery
ParseError.prototype.__proto__ = Error.prototype;

module.exports = ParseError;

},{}],82:[function(require,module,exports){
/* eslint no-constant-condition:0 */
var functions = require("./functions");
var environments = require("./environments");
var MacroExpander = require("./MacroExpander");
var symbols = require("./symbols");
var utils = require("./utils");
var cjkRegex = require("./unicodeRegexes").cjkRegex;

var parseData = require("./parseData");
var ParseError = require("./ParseError");

/**
 * This file contains the parser used to parse out a TeX expression from the
 * input. Since TeX isn't context-free, standard parsers don't work particularly
 * well.
 *
 * The strategy of this parser is as such:
 *
 * The main functions (the `.parse...` ones) take a position in the current
 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
 * this.lexer) also supports pulling out tokens at arbitrary places. When
 * individual tokens are needed at a position, the lexer is called to pull out a
 * token, which is then used.
 *
 * The parser has a property called "mode" indicating the mode that
 * the parser is currently in. Currently it has to be one of "math" or
 * "text", which denotes whether the current environment is a math-y
 * one or a text-y one (e.g. inside \text). Currently, this serves to
 * limit the functions which can be used in text mode.
 *
 * The main functions then return an object which contains the useful data that
 * was parsed at its given point, and a new position at the end of the parsed
 * data. The main functions can call each other and continue the parsing by
 * using the returned position as a new starting point.
 *
 * There are also extra `.handle...` functions, which pull out some reused
 * functionality into self-contained functions.
 *
 * The earlier functions return ParseNodes.
 * The later functions (which are called deeper in the parse) sometimes return
 * ParseFuncOrArgument, which contain a ParseNode as well as some data about
 * whether the parsed object is a function which is missing some arguments, or a
 * standalone object which can be used as an argument to another function.
 */

/**
 * Main Parser class
 */
function Parser(input, settings) {
    // Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)
    this.gullet = new MacroExpander(input, settings.macros);
    // Store the settings for use in parsing
    this.settings = settings;
    // Count leftright depth (for \middle errors)
    this.leftrightDepth = 0;
}

var ParseNode = parseData.ParseNode;

/**
 * An initial function (without its arguments), or an argument to a function.
 * The `result` argument should be a ParseNode.
 */
function ParseFuncOrArgument(result, isFunction, token) {
    this.result = result;
    // Is this a function (i.e. is it something defined in functions.js)?
    this.isFunction = isFunction;
    this.token = token;
}

/**
 * Checks a result to make sure it has the right type, and throws an
 * appropriate error otherwise.
 *
 * @param {boolean=} consume whether to consume the expected token,
 *                           defaults to true
 */
Parser.prototype.expect = function(text, consume) {
    if (this.nextToken.text !== text) {
        throw new ParseError(
            "Expected '" + text + "', got '" + this.nextToken.text + "'",
            this.nextToken
        );
    }
    if (consume !== false) {
        this.consume();
    }
};

/**
 * Considers the current look ahead token as consumed,
 * and fetches the one after that as the new look ahead.
 */
Parser.prototype.consume = function() {
    this.nextToken = this.gullet.get(this.mode === "math");
};

Parser.prototype.switchMode = function(newMode) {
    this.gullet.unget(this.nextToken);
    this.mode = newMode;
    this.consume();
};

/**
 * Main parsing function, which parses an entire input.
 *
 * @return {?Array.<ParseNode>}
 */
Parser.prototype.parse = function() {
    // Try to parse the input
    this.mode = "math";
    this.consume();
    var parse = this.parseInput();
    return parse;
};

/**
 * Parses an entire input tree.
 */
Parser.prototype.parseInput = function() {
    // Parse an expression
    var expression = this.parseExpression(false);
    // If we succeeded, make sure there's an EOF at the end
    this.expect("EOF", false);
    return expression;
};

var endOfExpression = ["}", "\\end", "\\right", "&", "\\\\", "\\cr"];

/**
 * Parses an "expression", which is a list of atoms.
 *
 * @param {boolean} breakOnInfix  Should the parsing stop when we hit infix
 *                  nodes? This happens when functions have higher precendence
 *                  than infix nodes in implicit parses.
 *
 * @param {?string} breakOnTokenText  The text of the token that the expression
 *                  should end with, or `null` if something else should end the
 *                  expression.
 *
 * @return {ParseNode}
 */
Parser.prototype.parseExpression = function(breakOnInfix, breakOnTokenText) {
    var body = [];
    // Keep adding atoms to the body until we can't parse any more atoms (either
    // we reached the end, a }, or a \right)
    while (true) {
        var lex = this.nextToken;
        if (endOfExpression.indexOf(lex.text) !== -1) {
            break;
        }
        if (breakOnTokenText && lex.text === breakOnTokenText) {
            break;
        }
        if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
            break;
        }
        var atom = this.parseAtom();
        if (!atom) {
            if (!this.settings.throwOnError && lex.text[0] === "\\") {
                var errorNode = this.handleUnsupportedCmd();
                body.push(errorNode);
                continue;
            }

            break;
        }
        body.push(atom);
    }
    return this.handleInfixNodes(body);
};

/**
 * Rewrites infix operators such as \over with corresponding commands such
 * as \frac.
 *
 * There can only be one infix operator per group.  If there's more than one
 * then the expression is ambiguous.  This can be resolved by adding {}.
 *
 * @returns {Array}
 */
Parser.prototype.handleInfixNodes = function(body) {
    var overIndex = -1;
    var funcName;

    for (var i = 0; i < body.length; i++) {
        var node = body[i];
        if (node.type === "infix") {
            if (overIndex !== -1) {
                throw new ParseError(
                    "only one infix operator per group",
                    node.value.token);
            }
            overIndex = i;
            funcName = node.value.replaceWith;
        }
    }

    if (overIndex !== -1) {
        var numerNode;
        var denomNode;

        var numerBody = body.slice(0, overIndex);
        var denomBody = body.slice(overIndex + 1);

        if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
            numerNode = numerBody[0];
        } else {
            numerNode = new ParseNode("ordgroup", numerBody, this.mode);
        }

        if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
            denomNode = denomBody[0];
        } else {
            denomNode = new ParseNode("ordgroup", denomBody, this.mode);
        }

        var value = this.callFunction(
            funcName, [numerNode, denomNode], null);
        return [new ParseNode(value.type, value, this.mode)];
    } else {
        return body;
    }
};

// The greediness of a superscript or subscript
var SUPSUB_GREEDINESS = 1;

/**
 * Handle a subscript or superscript with nice errors.
 */
Parser.prototype.handleSupSubscript = function(name) {
    var symbolToken = this.nextToken;
    var symbol = symbolToken.text;
    this.consume();
    var group = this.parseGroup();

    if (!group) {
        if (!this.settings.throwOnError && this.nextToken.text[0] === "\\") {
            return this.handleUnsupportedCmd();
        } else {
            throw new ParseError(
                "Expected group after '" + symbol + "'",
                symbolToken
            );
        }
    } else if (group.isFunction) {
        // ^ and _ have a greediness, so handle interactions with functions'
        // greediness
        var funcGreediness = functions[group.result].greediness;
        if (funcGreediness > SUPSUB_GREEDINESS) {
            return this.parseFunction(group);
        } else {
            throw new ParseError(
                "Got function '" + group.result + "' with no arguments " +
                    "as " + name, symbolToken);
        }
    } else {
        return group.result;
    }
};

/**
 * Converts the textual input of an unsupported command into a text node
 * contained within a color node whose color is determined by errorColor
 */
Parser.prototype.handleUnsupportedCmd = function() {
    var text = this.nextToken.text;
    var textordArray = [];

    for (var i = 0; i < text.length; i++) {
        textordArray.push(new ParseNode("textord", text[i], "text"));
    }

    var textNode = new ParseNode(
        "text",
        {
            body: textordArray,
            type: "text"
        },
        this.mode);

    var colorNode = new ParseNode(
        "color",
        {
            color: this.settings.errorColor,
            value: [textNode],
            type: "color"
        },
        this.mode);

    this.consume();
    return colorNode;
};

/**
 * Parses a group with optional super/subscripts.
 *
 * @return {?ParseNode}
 */
Parser.prototype.parseAtom = function() {
    // The body of an atom is an implicit group, so that things like
    // \left(x\right)^2 work correctly.
    var base = this.parseImplicitGroup();

    // In text mode, we don't have superscripts or subscripts
    if (this.mode === "text") {
        return base;
    }

    // Note that base may be empty (i.e. null) at this point.

    var superscript;
    var subscript;
    while (true) {
        // Lex the first token
        var lex = this.nextToken;

        if (lex.text === "\\limits" || lex.text === "\\nolimits") {
            // We got a limit control
            if (!base || base.type !== "op") {
                throw new ParseError(
                    "Limit controls must follow a math operator",
                    lex);
            } else {
                var limits = lex.text === "\\limits";
                base.value.limits = limits;
                base.value.alwaysHandleSupSub = true;
            }
            this.consume();
        } else if (lex.text === "^") {
            // We got a superscript start
            if (superscript) {
                throw new ParseError("Double superscript", lex);
            }
            superscript = this.handleSupSubscript("superscript");
        } else if (lex.text === "_") {
            // We got a subscript start
            if (subscript) {
                throw new ParseError("Double subscript", lex);
            }
            subscript = this.handleSupSubscript("subscript");
        } else if (lex.text === "'") {
            // We got a prime
            var prime = new ParseNode("textord", "\\prime", this.mode);

            // Many primes can be grouped together, so we handle this here
            var primes = [prime];
            this.consume();
            // Keep lexing tokens until we get something that's not a prime
            while (this.nextToken.text === "'") {
                // For each one, add another prime to the list
                primes.push(prime);
                this.consume();
            }
            // Put them into an ordgroup as the superscript
            superscript = new ParseNode("ordgroup", primes, this.mode);
        } else {
            // If it wasn't ^, _, or ', stop parsing super/subscripts
            break;
        }
    }

    if (superscript || subscript) {
        // If we got either a superscript or subscript, create a supsub
        return new ParseNode("supsub", {
            base: base,
            sup: superscript,
            sub: subscript
        }, this.mode);
    } else {
        // Otherwise return the original body
        return base;
    }
};

// A list of the size-changing functions, for use in parseImplicitGroup
var sizeFuncs = [
    "\\tiny", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize",
    "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"
];

// A list of the style-changing functions, for use in parseImplicitGroup
var styleFuncs = [
    "\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"
];

/**
 * Parses an implicit group, which is a group that starts at the end of a
 * specified, and ends right before a higher explicit group ends, or at EOL. It
 * is used for functions that appear to affect the current style, like \Large or
 * \textrm, where instead of keeping a style we just pretend that there is an
 * implicit grouping after it until the end of the group. E.g.
 *   small text {\Large large text} small text again
 * It is also used for \left and \right to get the correct grouping.
 *
 * @return {?ParseNode}
 */
Parser.prototype.parseImplicitGroup = function() {
    var start = this.parseSymbol();

    if (start == null) {
        // If we didn't get anything we handle, fall back to parseFunction
        return this.parseFunction();
    }

    var func = start.result;
    var body;

    if (func === "\\left") {
        // If we see a left:
        // Parse the entire left function (including the delimiter)
        var left = this.parseFunction(start);
        // Parse out the implicit body
        ++this.leftrightDepth;
        body = this.parseExpression(false);
        --this.leftrightDepth;
        // Check the next token
        this.expect("\\right", false);
        var right = this.parseFunction();
        return new ParseNode("leftright", {
            body: body,
            left: left.value.value,
            right: right.value.value
        }, this.mode);
    } else if (func === "\\begin") {
        // begin...end is similar to left...right
        var begin = this.parseFunction(start);
        var envName = begin.value.name;
        if (!environments.hasOwnProperty(envName)) {
            throw new ParseError(
                "No such environment: " + envName, begin.value.nameGroup);
        }
        // Build the environment object. Arguments and other information will
        // be made available to the begin and end methods using properties.
        var env = environments[envName];
        var args = this.parseArguments("\\begin{" + envName + "}", env);
        var context = {
            mode: this.mode,
            envName: envName,
            parser: this,
            positions: args.pop()
        };
        var result = env.handler(context, args);
        this.expect("\\end", false);
        var endNameToken = this.nextToken;
        var end = this.parseFunction();
        if (end.value.name !== envName) {
            throw new ParseError(
                "Mismatch: \\begin{" + envName + "} matched " +
                "by \\end{" + end.value.name + "}",
                endNameToken);
        }
        result.position = end.position;
        return result;
    } else if (utils.contains(sizeFuncs, func)) {
        // If we see a sizing function, parse out the implict body
        body = this.parseExpression(false);
        return new ParseNode("sizing", {
            // Figure out what size to use based on the list of functions above
            size: "size" + (utils.indexOf(sizeFuncs, func) + 1),
            value: body
        }, this.mode);
    } else if (utils.contains(styleFuncs, func)) {
        // If we see a styling function, parse out the implict body
        body = this.parseExpression(true);
        return new ParseNode("styling", {
            // Figure out what style to use by pulling out the style from
            // the function name
            style: func.slice(1, func.length - 5),
            value: body
        }, this.mode);
    } else {
        // Defer to parseFunction if it's not a function we handle
        return this.parseFunction(start);
    }
};

/**
 * Parses an entire function, including its base and all of its arguments.
 * The base might either have been parsed already, in which case
 * it is provided as an argument, or it's the next group in the input.
 *
 * @param {ParseFuncOrArgument=} baseGroup optional as described above
 * @return {?ParseNode}
 */
Parser.prototype.parseFunction = function(baseGroup) {
    if (!baseGroup) {
        baseGroup = this.parseGroup();
    }

    if (baseGroup) {
        if (baseGroup.isFunction) {
            var func = baseGroup.result;
            var funcData = functions[func];
            if (this.mode === "text" && !funcData.allowedInText) {
                throw new ParseError(
                    "Can't use function '" + func + "' in text mode",
                    baseGroup.token);
            }

            var args = this.parseArguments(func, funcData);
            var token = baseGroup.token;
            var result = this.callFunction(func, args, args.pop(), token);
            return new ParseNode(result.type, result, this.mode);
        } else {
            return baseGroup.result;
        }
    } else {
        return null;
    }
};

/**
 * Call a function handler with a suitable context and arguments.
 */
Parser.prototype.callFunction = function(name, args, positions, token) {
    var context = {
        funcName: name,
        parser: this,
        positions: positions,
        token: token
    };
    return functions[name].handler(context, args);
};

/**
 * Parses the arguments of a function or environment
 *
 * @param {string} func  "\name" or "\begin{name}"
 * @param {{numArgs:number,numOptionalArgs:number|undefined}} funcData
 * @return the array of arguments, with the list of positions as last element
 */
Parser.prototype.parseArguments = function(func, funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
        return [[this.pos]];
    }

    var baseGreediness = funcData.greediness;
    var positions = [this.pos];
    var args = [];

    for (var i = 0; i < totalArgs; i++) {
        var nextToken = this.nextToken;
        var argType = funcData.argTypes && funcData.argTypes[i];
        var arg;
        if (i < funcData.numOptionalArgs) {
            if (argType) {
                arg = this.parseGroupOfType(argType, true);
            } else {
                arg = this.parseGroup(true);
            }
            if (!arg) {
                args.push(null);
                positions.push(this.pos);
                continue;
            }
        } else {
            if (argType) {
                arg = this.parseGroupOfType(argType);
            } else {
                arg = this.parseGroup();
            }
            if (!arg) {
                if (!this.settings.throwOnError &&
                    this.nextToken.text[0] === "\\") {
                    arg = new ParseFuncOrArgument(
                        this.handleUnsupportedCmd(this.nextToken.text),
                        false);
                } else {
                    throw new ParseError(
                        "Expected group after '" + func + "'", nextToken);
                }
            }
        }
        var argNode;
        if (arg.isFunction) {
            var argGreediness =
                functions[arg.result].greediness;
            if (argGreediness > baseGreediness) {
                argNode = this.parseFunction(arg);
            } else {
                throw new ParseError(
                    "Got function '" + arg.result + "' as " +
                    "argument to '" + func + "'", nextToken);
            }
        } else {
            argNode = arg.result;
        }
        args.push(argNode);
        positions.push(this.pos);
    }

    args.push(positions);

    return args;
};


/**
 * Parses a group when the mode is changing.
 *
 * @return {?ParseFuncOrArgument}
 */
Parser.prototype.parseGroupOfType = function(innerMode, optional) {
    var outerMode = this.mode;
    // Handle `original` argTypes
    if (innerMode === "original") {
        innerMode = outerMode;
    }

    if (innerMode === "color") {
        return this.parseColorGroup(optional);
    }
    if (innerMode === "size") {
        return this.parseSizeGroup(optional);
    }

    this.switchMode(innerMode);
    if (innerMode === "text") {
        // text mode is special because it should ignore the whitespace before
        // it
        while (this.nextToken.text === " ") {
            this.consume();
        }
    }
    // By the time we get here, innerMode is one of "text" or "math".
    // We switch the mode of the parser, recurse, then restore the old mode.
    var res = this.parseGroup(optional);
    this.switchMode(outerMode);
    return res;
};

/**
 * Parses a group, essentially returning the string formed by the
 * brace-enclosed tokens plus some position information.
 *
 * @param {string} modeName  Used to describe the mode in error messages
 * @param {boolean=} optional  Whether the group is optional or required
 */
Parser.prototype.parseStringGroup = function(modeName, optional) {
    if (optional && this.nextToken.text !== "[") {
        return null;
    }
    var outerMode = this.mode;
    this.mode = "text";
    this.expect(optional ? "[" : "{");
    var str = "";
    var firstToken = this.nextToken;
    var lastToken = firstToken;
    while (this.nextToken.text !== (optional ? "]" : "}")) {
        if (this.nextToken.text === "EOF") {
            throw new ParseError(
                "Unexpected end of input in " + modeName,
                firstToken.range(this.nextToken, str));
        }
        lastToken = this.nextToken;
        str += lastToken.text;
        this.consume();
    }
    this.mode = outerMode;
    this.expect(optional ? "]" : "}");
    return firstToken.range(lastToken, str);
};

/**
 * Parses a regex-delimited group: the largest sequence of tokens
 * whose concatenated strings match `regex`. Returns the string
 * formed by the tokens plus some position information.
 *
 * @param {RegExp} regex
 * @param {string} modeName  Used to describe the mode in error messages
 */
Parser.prototype.parseRegexGroup = function(regex, modeName) {
    var outerMode = this.mode;
    this.mode = "text";
    var firstToken = this.nextToken;
    var lastToken = firstToken;
    var str = "";
    while (this.nextToken.text !== "EOF"
           && regex.test(str + this.nextToken.text)) {
        lastToken = this.nextToken;
        str += lastToken.text;
        this.consume();
    }
    if (str === "") {
        throw new ParseError(
            "Invalid " + modeName + ": '" + firstToken.text + "'",
            firstToken);
    }
    this.mode = outerMode;
    return firstToken.range(lastToken, str);
};

/**
 * Parses a color description.
 */
Parser.prototype.parseColorGroup = function(optional) {
    var res = this.parseStringGroup("color", optional);
    if (!res) {
        return null;
    }
    var match = (/^(#[a-z0-9]+|[a-z]+)$/i).exec(res.text);
    if (!match) {
        throw new ParseError("Invalid color: '" + res.text + "'", res);
    }
    return new ParseFuncOrArgument(
        new ParseNode("color", match[0], this.mode),
        false);
};

/**
 * Parses a size specification, consisting of magnitude and unit.
 */
Parser.prototype.parseSizeGroup = function(optional) {
    var res;
    if (!optional && this.nextToken.text !== "{") {
        res = this.parseRegexGroup(
            /^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2}$/, "size");
    } else {
        res = this.parseStringGroup("size", optional);
    }
    if (!res) {
        return null;
    }
    var match = (/([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/).exec(res.text);
    if (!match) {
        throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    var data = {
        number: +(match[1] + match[2]), // sign + magnitude, cast to number
        unit: match[3]
    };
    if (data.unit !== "em" && data.unit !== "ex" && data.unit !== "mu") {
        throw new ParseError("Invalid unit: '" + data.unit + "'", res);
    }
    return new ParseFuncOrArgument(
        new ParseNode("color", data, this.mode),
        false);
};

/**
 * If the argument is false or absent, this parses an ordinary group,
 * which is either a single nucleus (like "x") or an expression
 * in braces (like "{x+y}").
 * If the argument is true, it parses either a bracket-delimited expression
 * (like "[x+y]") or returns null to indicate the absence of a
 * bracket-enclosed group.
 *
 * @param {boolean=} optional  Whether the group is optional or required
 * @return {?ParseFuncOrArgument}
 */
Parser.prototype.parseGroup = function(optional) {
    var firstToken = this.nextToken;
    // Try to parse an open brace
    if (this.nextToken.text === (optional ? "[" : "{")) {
        // If we get a brace, parse an expression
        this.consume();
        var expression = this.parseExpression(false, optional ? "]" : null);
        var lastToken = this.nextToken;
        // Make sure we get a close brace
        this.expect(optional ? "]" : "}");
        if (this.mode === "text") {
            this.formLigatures(expression);
        }
        return new ParseFuncOrArgument(
            new ParseNode("ordgroup", expression, this.mode,
                          firstToken, lastToken),
            false);
    } else {
        // Otherwise, just return a nucleus, or nothing for an optional group
        return optional ? null : this.parseSymbol();
    }
};

/**
 * Form ligature-like combinations of characters for text mode.
 * This includes inputs like "--", "---", "``" and "''".
 * The result will simply replace multiple textord nodes with a single
 * character in each value by a single textord node having multiple
 * characters in its value.  The representation is still ASCII source.
 *
 * @param {Array.<ParseNode>} group  the nodes of this group,
 *                                   list will be moified in place
 */
Parser.prototype.formLigatures = function(group) {
    var i;
    var n = group.length - 1;
    for (i = 0; i < n; ++i) {
        var a = group[i];
        var v = a.value;
        if (v === "-" && group[i + 1].value === "-") {
            if (i + 1 < n && group[i + 2].value === "-") {
                group.splice(i, 3, new ParseNode(
                    "textord", "---", "text", a, group[i + 2]));
                n -= 2;
            } else {
                group.splice(i, 2, new ParseNode(
                    "textord", "--", "text", a, group[i + 1]));
                n -= 1;
            }
        }
        if ((v === "'" || v === "`") && group[i + 1].value === v) {
            group.splice(i, 2, new ParseNode(
                "textord", v + v, "text", a, group[i + 1]));
            n -= 1;
        }
    }
};

/**
 * Parse a single symbol out of the string. Here, we handle both the functions
 * we have defined, as well as the single character symbols
 *
 * @return {?ParseFuncOrArgument}
 */
Parser.prototype.parseSymbol = function() {
    var nucleus = this.nextToken;

    if (functions[nucleus.text]) {
        this.consume();
        // If there exists a function with this name, we return the function and
        // say that it is a function.
        return new ParseFuncOrArgument(
            nucleus.text,
            true, nucleus);
    } else if (symbols[this.mode][nucleus.text]) {
        this.consume();
        // Otherwise if this is a no-argument function, find the type it
        // corresponds to in the symbols map
        return new ParseFuncOrArgument(
            new ParseNode(symbols[this.mode][nucleus.text].group,
                          nucleus.text, this.mode, nucleus),
            false, nucleus);
    } else if (this.mode === "text" && cjkRegex.test(nucleus.text)) {
        this.consume();
        return new ParseFuncOrArgument(
            new ParseNode("textord", nucleus.text, this.mode, nucleus),
            false, nucleus);
    } else {
        return null;
    }
};

Parser.prototype.ParseNode = ParseNode;

module.exports = Parser;

},{"./MacroExpander":79,"./ParseError":81,"./environments":91,"./functions":94,"./parseData":96,"./symbols":98,"./unicodeRegexes":99,"./utils":100}],83:[function(require,module,exports){
/**
 * This is a module for storing settings passed into KaTeX. It correctly handles
 * default settings.
 */

/**
 * Helper function for getting a default value if the value is undefined
 */
function get(option, defaultValue) {
    return option === undefined ? defaultValue : option;
}

/**
 * The main Settings object
 *
 * The current options stored are:
 *  - displayMode: Whether the expression should be typeset by default in
 *                 textstyle or displaystyle (default false)
 */
function Settings(options) {
    // allow null options
    options = options || {};
    this.displayMode = get(options.displayMode, false);
    this.throwOnError = get(options.throwOnError, true);
    this.errorColor = get(options.errorColor, "#cc0000");
    this.macros = options.macros || {};
}

module.exports = Settings;

},{}],84:[function(require,module,exports){
/**
 * This file contains information and classes for the various kinds of styles
 * used in TeX. It provides a generic `Style` class, which holds information
 * about a specific style. It then provides instances of all the different kinds
 * of styles possible, and provides functions to move between them and get
 * information about them.
 */

var sigmas = require("./fontMetrics.js").sigmas;

var metrics = [{}, {}, {}];
var i;
for (var key in sigmas) {
    if (sigmas.hasOwnProperty(key)) {
        for (i = 0; i < 3; i++) {
            metrics[i][key] = sigmas[key][i];
        }
    }
}
for (i = 0; i < 3; i++) {
    metrics[i].emPerEx = sigmas.xHeight[i] / sigmas.quad[i];
}

/**
 * The main style class. Contains a unique id for the style, a size (which is
 * the same for cramped and uncramped version of a style), a cramped flag, and a
 * size multiplier, which gives the size difference between a style and
 * textstyle.
 */
function Style(id, size, multiplier, cramped) {
    this.id = id;
    this.size = size;
    this.cramped = cramped;
    this.sizeMultiplier = multiplier;
    this.metrics = metrics[size > 0 ? size - 1 : 0];
}

/**
 * Get the style of a superscript given a base in the current style.
 */
Style.prototype.sup = function() {
    return styles[sup[this.id]];
};

/**
 * Get the style of a subscript given a base in the current style.
 */
Style.prototype.sub = function() {
    return styles[sub[this.id]];
};

/**
 * Get the style of a fraction numerator given the fraction in the current
 * style.
 */
Style.prototype.fracNum = function() {
    return styles[fracNum[this.id]];
};

/**
 * Get the style of a fraction denominator given the fraction in the current
 * style.
 */
Style.prototype.fracDen = function() {
    return styles[fracDen[this.id]];
};

/**
 * Get the cramped version of a style (in particular, cramping a cramped style
 * doesn't change the style).
 */
Style.prototype.cramp = function() {
    return styles[cramp[this.id]];
};

/**
 * HTML class name, like "displaystyle cramped"
 */
Style.prototype.cls = function() {
    return sizeNames[this.size] + (this.cramped ? " cramped" : " uncramped");
};

/**
 * HTML Reset class name, like "reset-textstyle"
 */
Style.prototype.reset = function() {
    return resetNames[this.size];
};

/**
 * Return if this style is tightly spaced (scriptstyle/scriptscriptstyle)
 */
Style.prototype.isTight = function() {
    return this.size >= 2;
};

// IDs of the different styles
var D = 0;
var Dc = 1;
var T = 2;
var Tc = 3;
var S = 4;
var Sc = 5;
var SS = 6;
var SSc = 7;

// String names for the different sizes
var sizeNames = [
    "displaystyle textstyle",
    "textstyle",
    "scriptstyle",
    "scriptscriptstyle"
];

// Reset names for the different sizes
var resetNames = [
    "reset-textstyle",
    "reset-textstyle",
    "reset-scriptstyle",
    "reset-scriptscriptstyle"
];

// Instances of the different styles
var styles = [
    new Style(D, 0, 1.0, false),
    new Style(Dc, 0, 1.0, true),
    new Style(T, 1, 1.0, false),
    new Style(Tc, 1, 1.0, true),
    new Style(S, 2, 0.7, false),
    new Style(Sc, 2, 0.7, true),
    new Style(SS, 3, 0.5, false),
    new Style(SSc, 3, 0.5, true)
];

// Lookup tables for switching from one style to another
var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];

// We only export some of the styles. Also, we don't export the `Style` class so
// no more styles can be generated.
module.exports = {
    DISPLAY: styles[D],
    TEXT: styles[T],
    SCRIPT: styles[S],
    SCRIPTSCRIPT: styles[SS]
};

},{"./fontMetrics.js":92}],85:[function(require,module,exports){
/* eslint no-console:0 */
/**
 * This module contains general functions that can be used for building
 * different kinds of domTree nodes in a consistent manner.
 */

var domTree = require("./domTree");
var fontMetrics = require("./fontMetrics");
var symbols = require("./symbols");
var utils = require("./utils");

var greekCapitals = [
    "\\Gamma",
    "\\Delta",
    "\\Theta",
    "\\Lambda",
    "\\Xi",
    "\\Pi",
    "\\Sigma",
    "\\Upsilon",
    "\\Phi",
    "\\Psi",
    "\\Omega"
];

// The following have to be loaded from Main-Italic font, using class mainit
var mainitLetters = [
    "\u0131",   // dotless i, \imath
    "\u0237",   // dotless j, \jmath
    "\u00a3"   // \pounds
];

/**
 * Makes a symbolNode after translation via the list of symbols in symbols.js.
 * Correctly pulls out metrics for the character, and optionally takes a list of
 * classes to be attached to the node.
 *
 * TODO: make argument order closer to makeSpan
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 */
var makeSymbol = function(value, fontFamily, mode, options, classes) {
    // Replace the value with its replaced value from symbol.js
    if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var metrics = fontMetrics.getCharacterMetrics(value, fontFamily);

    var symbolNode;
    if (metrics) {
        var italic = metrics.italic;
        if (mode === "text") {
            italic = 0;
        }
        symbolNode = new domTree.symbolNode(
            value, metrics.height, metrics.depth, italic, metrics.skew,
            classes);
    } else {
        // TODO(emily): Figure out a good way to only print this in development
        typeof console !== "undefined" && console.warn(
            "No character metrics for '" + value + "' in style '" +
                fontFamily + "'");
        symbolNode = new domTree.symbolNode(value, 0, 0, 0, 0, classes);
    }

    if (options) {
        if (options.style.isTight()) {
            symbolNode.classes.push("mtight");
        }
        if (options.getColor()) {
            symbolNode.style.color = options.getColor();
        }
    }

    return symbolNode;
};

/**
 * Makes a symbol in Main-Regular or AMS-Regular.
 * Used for rel, bin, open, close, inner, and punct.
 */
var mathsym = function(value, mode, options, classes) {
    // Decide what font to render the symbol in by its entry in the symbols
    // table.
    // Have a special case for when the value = \ because the \ is used as a
    // textord in unsupported command errors but cannot be parsed as a regular
    // text ordinal and is therefore not present as a symbol in the symbols
    // table for text
    if (value === "\\" || symbols[mode][value].font === "main") {
        return makeSymbol(value, "Main-Regular", mode, options, classes);
    } else {
        return makeSymbol(
            value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
    }
};

/**
 * Makes a symbol in the default font for mathords and textords.
 */
var mathDefault = function(value, mode, options, classes, type) {
    if (type === "mathord") {
        return mathit(value, mode, options, classes);
    } else if (type === "textord") {
        return makeSymbol(
            value, "Main-Regular", mode, options, classes.concat(["mathrm"]));
    } else {
        throw new Error("unexpected type: " + type + " in mathDefault");
    }
};

/**
 * Makes a symbol in the italic math font.
 */
var mathit = function(value, mode, options, classes) {
    if (/[0-9]/.test(value.charAt(0)) ||
            // glyphs for \imath and \jmath do not exist in Math-Italic so we
            // need to use Main-Italic instead
            utils.contains(mainitLetters, value) ||
            utils.contains(greekCapitals, value)) {
        return makeSymbol(
            value, "Main-Italic", mode, options, classes.concat(["mainit"]));
    } else {
        return makeSymbol(
            value, "Math-Italic", mode, options, classes.concat(["mathit"]));
    }
};

/**
 * Makes either a mathord or textord in the correct font and color.
 */
var makeOrd = function(group, options, type) {
    var mode = group.mode;
    var value = group.value;
    if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var classes = ["mord"];

    var font = options.font;
    if (font) {
        if (font === "mathit" || utils.contains(mainitLetters, value)) {
            return mathit(value, mode, options, classes);
        } else {
            var fontName = fontMap[font].fontName;
            if (fontMetrics.getCharacterMetrics(value, fontName)) {
                return makeSymbol(
                    value, fontName, mode, options, classes.concat([font]));
            } else {
                return mathDefault(value, mode, options, classes, type);
            }
        }
    } else {
        return mathDefault(value, mode, options, classes, type);
    }
};

/**
 * Calculate the height, depth, and maxFontSize of an element based on its
 * children.
 */
var sizeElementFromChildren = function(elem) {
    var height = 0;
    var depth = 0;
    var maxFontSize = 0;

    if (elem.children) {
        for (var i = 0; i < elem.children.length; i++) {
            if (elem.children[i].height > height) {
                height = elem.children[i].height;
            }
            if (elem.children[i].depth > depth) {
                depth = elem.children[i].depth;
            }
            if (elem.children[i].maxFontSize > maxFontSize) {
                maxFontSize = elem.children[i].maxFontSize;
            }
        }
    }

    elem.height = height;
    elem.depth = depth;
    elem.maxFontSize = maxFontSize;
};

/**
 * Makes a span with the given list of classes, list of children, and options.
 *
 * TODO: Ensure that `options` is always provided (currently some call sites
 * don't pass it).
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 */
var makeSpan = function(classes, children, options) {
    var span = new domTree.span(classes, children, options);

    sizeElementFromChildren(span);

    return span;
};

/**
 * Prepends the given children to the given span, updating height, depth, and
 * maxFontSize.
 */
var prependChildren = function(span, children) {
    span.children = children.concat(span.children);

    sizeElementFromChildren(span);
};

/**
 * Makes a document fragment with the given list of children.
 */
var makeFragment = function(children) {
    var fragment = new domTree.documentFragment(children);

    sizeElementFromChildren(fragment);

    return fragment;
};

/**
 * Makes an element placed in each of the vlist elements to ensure that each
 * element has the same max font size. To do this, we create a zero-width space
 * with the correct font size.
 */
var makeFontSizer = function(options, fontSize) {
    var fontSizeInner = makeSpan([], [new domTree.symbolNode("\u200b")]);
    fontSizeInner.style.fontSize =
        (fontSize / options.style.sizeMultiplier) + "em";

    var fontSizer = makeSpan(
        ["fontsize-ensurer", "reset-" + options.size, "size5"],
        [fontSizeInner]);

    return fontSizer;
};

/**
 * Makes a vertical list by stacking elements and kerns on top of each other.
 * Allows for many different ways of specifying the positioning method.
 *
 * Arguments:
 *  - children: A list of child or kern nodes to be stacked on top of each other
 *              (i.e. the first element will be at the bottom, and the last at
 *              the top). Element nodes are specified as
 *                {type: "elem", elem: node}
 *              while kern nodes are specified as
 *                {type: "kern", size: size}
 *  - positionType: The method by which the vlist should be positioned. Valid
 *                  values are:
 *                   - "individualShift": The children list only contains elem
 *                                        nodes, and each node contains an extra
 *                                        "shift" value of how much it should be
 *                                        shifted (note that shifting is always
 *                                        moving downwards). positionData is
 *                                        ignored.
 *                   - "top": The positionData specifies the topmost point of
 *                            the vlist (note this is expected to be a height,
 *                            so positive values move up)
 *                   - "bottom": The positionData specifies the bottommost point
 *                               of the vlist (note this is expected to be a
 *                               depth, so positive values move down
 *                   - "shift": The vlist will be positioned such that its
 *                              baseline is positionData away from the baseline
 *                              of the first child. Positive values move
 *                              downwards.
 *                   - "firstBaseline": The vlist will be positioned such that
 *                                      its baseline is aligned with the
 *                                      baseline of the first child.
 *                                      positionData is ignored. (this is
 *                                      equivalent to "shift" with
 *                                      positionData=0)
 *  - positionData: Data used in different ways depending on positionType
 *  - options: An Options object
 *
 */
var makeVList = function(children, positionType, positionData, options) {
    var depth;
    var currPos;
    var i;
    if (positionType === "individualShift") {
        var oldChildren = children;
        children = [oldChildren[0]];

        // Add in kerns to the list of children to get each element to be
        // shifted to the correct specified shift
        depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
        currPos = depth;
        for (i = 1; i < oldChildren.length; i++) {
            var diff = -oldChildren[i].shift - currPos -
                oldChildren[i].elem.depth;
            var size = diff -
                (oldChildren[i - 1].elem.height +
                 oldChildren[i - 1].elem.depth);

            currPos = currPos + diff;

            children.push({type: "kern", size: size});
            children.push(oldChildren[i]);
        }
    } else if (positionType === "top") {
        // We always start at the bottom, so calculate the bottom by adding up
        // all the sizes
        var bottom = positionData;
        for (i = 0; i < children.length; i++) {
            if (children[i].type === "kern") {
                bottom -= children[i].size;
            } else {
                bottom -= children[i].elem.height + children[i].elem.depth;
            }
        }
        depth = bottom;
    } else if (positionType === "bottom") {
        depth = -positionData;
    } else if (positionType === "shift") {
        depth = -children[0].elem.depth - positionData;
    } else if (positionType === "firstBaseline") {
        depth = -children[0].elem.depth;
    } else {
        depth = 0;
    }

    // Make the fontSizer
    var maxFontSize = 0;
    for (i = 0; i < children.length; i++) {
        if (children[i].type === "elem") {
            maxFontSize = Math.max(maxFontSize, children[i].elem.maxFontSize);
        }
    }
    var fontSizer = makeFontSizer(options, maxFontSize);

    // Create a new list of actual children at the correct offsets
    var realChildren = [];
    currPos = depth;
    for (i = 0; i < children.length; i++) {
        if (children[i].type === "kern") {
            currPos += children[i].size;
        } else {
            var child = children[i].elem;

            var shift = -child.depth - currPos;
            currPos += child.height + child.depth;

            var childWrap = makeSpan([], [fontSizer, child]);
            childWrap.height -= shift;
            childWrap.depth += shift;
            childWrap.style.top = shift + "em";

            realChildren.push(childWrap);
        }
    }

    // Add in an element at the end with no offset to fix the calculation of
    // baselines in some browsers (namely IE, sometimes safari)
    var baselineFix = makeSpan(
        ["baseline-fix"], [fontSizer, new domTree.symbolNode("\u200b")]);
    realChildren.push(baselineFix);

    var vlist = makeSpan(["vlist"], realChildren);
    // Fix the final height and depth, in case there were kerns at the ends
    // since the makeSpan calculation won't take that in to account.
    vlist.height = Math.max(currPos, vlist.height);
    vlist.depth = Math.max(-depth, vlist.depth);
    return vlist;
};

// A table of size -> font size for the different sizing functions
var sizingMultiplier = {
    size1: 0.5,
    size2: 0.7,
    size3: 0.8,
    size4: 0.9,
    size5: 1.0,
    size6: 1.2,
    size7: 1.44,
    size8: 1.73,
    size9: 2.07,
    size10: 2.49
};

// A map of spacing functions to their attributes, like size and corresponding
// CSS class
var spacingFunctions = {
    "\\qquad": {
        size: "2em",
        className: "qquad"
    },
    "\\quad": {
        size: "1em",
        className: "quad"
    },
    "\\enspace": {
        size: "0.5em",
        className: "enspace"
    },
    "\\;": {
        size: "0.277778em",
        className: "thickspace"
    },
    "\\:": {
        size: "0.22222em",
        className: "mediumspace"
    },
    "\\,": {
        size: "0.16667em",
        className: "thinspace"
    },
    "\\!": {
        size: "-0.16667em",
        className: "negativethinspace"
    }
};

/**
 * Maps TeX font commands to objects containing:
 * - variant: string used for "mathvariant" attribute in buildMathML.js
 * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
 */
// A map between tex font commands an MathML mathvariant attribute values
var fontMap = {
    // styles
    "mathbf": {
        variant: "bold",
        fontName: "Main-Bold"
    },
    "mathrm": {
        variant: "normal",
        fontName: "Main-Regular"
    },
    "textit": {
        variant: "italic",
        fontName: "Main-Italic"
    },

    // "mathit" is missing because it requires the use of two fonts: Main-Italic
    // and Math-Italic.  This is handled by a special case in makeOrd which ends
    // up calling mathit.

    // families
    "mathbb": {
        variant: "double-struck",
        fontName: "AMS-Regular"
    },
    "mathcal": {
        variant: "script",
        fontName: "Caligraphic-Regular"
    },
    "mathfrak": {
        variant: "fraktur",
        fontName: "Fraktur-Regular"
    },
    "mathscr": {
        variant: "script",
        fontName: "Script-Regular"
    },
    "mathsf": {
        variant: "sans-serif",
        fontName: "SansSerif-Regular"
    },
    "mathtt": {
        variant: "monospace",
        fontName: "Typewriter-Regular"
    }
};

module.exports = {
    fontMap: fontMap,
    makeSymbol: makeSymbol,
    mathsym: mathsym,
    makeSpan: makeSpan,
    makeFragment: makeFragment,
    makeVList: makeVList,
    makeOrd: makeOrd,
    prependChildren: prependChildren,
    sizingMultiplier: sizingMultiplier,
    spacingFunctions: spacingFunctions
};

},{"./domTree":90,"./fontMetrics":92,"./symbols":98,"./utils":100}],86:[function(require,module,exports){
/* eslint no-console:0 */
/**
 * This file does the main work of building a domTree structure from a parse
 * tree. The entry point is the `buildHTML` function, which takes a parse tree.
 * Then, the buildExpression, buildGroup, and various groupTypes functions are
 * called, to produce a final HTML tree.
 */

var ParseError = require("./ParseError");
var Style = require("./Style");

var buildCommon = require("./buildCommon");
var delimiter = require("./delimiter");
var domTree = require("./domTree");
var fontMetrics = require("./fontMetrics");
var utils = require("./utils");

var makeSpan = buildCommon.makeSpan;

var isSpace = function(node) {
    return node instanceof domTree.span && node.classes[0] === "mspace";
};

// Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)
// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,
// and the text before Rule 19.

var isBin = function(node) {
    return node && node.classes[0] === "mbin";
};

var isBinLeftCanceller = function(node, isRealGroup) {
    // TODO: This code assumes that a node's math class is the first element
    // of its `classes` array. A later cleanup should ensure this, for
    // instance by changing the signature of `makeSpan`.
    if (node) {
        return utils.contains(["mbin", "mopen", "mrel", "mop", "mpunct"],
                              node.classes[0]);
    } else {
        return isRealGroup;
    }
};

var isBinRightCanceller = function(node, isRealGroup) {
    if (node) {
        return utils.contains(["mrel", "mclose", "mpunct"], node.classes[0]);
    } else {
        return isRealGroup;
    }
};

/**
 * Take a list of nodes, build them in order, and return a list of the built
 * nodes. documentFragments are flattened into their contents, so the
 * returned list contains no fragments. `isRealGroup` is true if `expression`
 * is a real group (no atoms will be added on either side), as opposed to
 * a partial group (e.g. one created by \color).
 */
var buildExpression = function(expression, options, isRealGroup) {
    // Parse expressions into `groups`.
    var groups = [];
    for (var i = 0; i < expression.length; i++) {
        var group = expression[i];
        var output = buildGroup(group, options);
        if (output instanceof domTree.documentFragment) {
            Array.prototype.push.apply(groups, output.children);
        } else {
            groups.push(output);
        }
    }
    // At this point `groups` consists entirely of `symbolNode`s and `span`s.

    // Explicit spaces (e.g., \;, \,) should be ignored with respect to atom
    // spacing (e.g., "add thick space between mord and mrel"). Since CSS
    // adjacency rules implement atom spacing, spaces should be invisible to
    // CSS. So we splice them out of `groups` and into the atoms themselves.
    var spaces = null;
    for (i = 0; i < groups.length; i++) {
        if (isSpace(groups[i])) {
            spaces = spaces || [];
            spaces.push(groups[i]);
            groups.splice(i, 1);
            i--;
        } else if (spaces) {
            if (groups[i] instanceof domTree.symbolNode) {
                groups[i] = makeSpan([].concat(groups[i].classes), [groups[i]]);
            }
            buildCommon.prependChildren(groups[i], spaces);
            spaces = null;
        }
    }
    if (spaces) {
        Array.prototype.push.apply(groups, spaces);
    }

    // Binary operators change to ordinary symbols in some contexts.
    for (i = 0; i < groups.length; i++) {
        if (isBin(groups[i])
            && (isBinLeftCanceller(groups[i - 1], isRealGroup)
                || isBinRightCanceller(groups[i + 1], isRealGroup))) {
            groups[i].classes[0] = "mord";
        }
    }

    return groups;
};

// Return math atom class (mclass) of a domTree.
var getTypeOfDomTree = function(node) {
    if (node instanceof domTree.documentFragment) {
        if (node.children.length) {
            return getTypeOfDomTree(
                node.children[node.children.length - 1]);
        }
    } else {
        if (utils.contains(["mord", "mop", "mbin", "mrel", "mopen", "mclose",
            "mpunct", "minner"], node.classes[0])) {
            return node.classes[0];
        }
    }
    return null;
};

/**
 * Sometimes, groups perform special rules when they have superscripts or
 * subscripts attached to them. This function lets the `supsub` group know that
 * its inner element should handle the superscripts and subscripts instead of
 * handling them itself.
 */
var shouldHandleSupSub = function(group, options) {
    if (!group) {
        return false;
    } else if (group.type === "op") {
        // Operators handle supsubs differently when they have limits
        // (e.g. `\displaystyle\sum_2^3`)
        return group.value.limits &&
            (options.style.size === Style.DISPLAY.size ||
            group.value.alwaysHandleSupSub);
    } else if (group.type === "accent") {
        return isCharacterBox(group.value.base);
    } else {
        return null;
    }
};

/**
 * Sometimes we want to pull out the innermost element of a group. In most
 * cases, this will just be the group itself, but when ordgroups and colors have
 * a single element, we want to pull that out.
 */
var getBaseElem = function(group) {
    if (!group) {
        return false;
    } else if (group.type === "ordgroup") {
        if (group.value.length === 1) {
            return getBaseElem(group.value[0]);
        } else {
            return group;
        }
    } else if (group.type === "color") {
        if (group.value.value.length === 1) {
            return getBaseElem(group.value.value[0]);
        } else {
            return group;
        }
    } else if (group.type === "font") {
        return getBaseElem(group.value.body);
    } else {
        return group;
    }
};

/**
 * TeXbook algorithms often reference "character boxes", which are simply groups
 * with a single character in them. To decide if something is a character box,
 * we find its innermost group, and see if it is a single character.
 */
var isCharacterBox = function(group) {
    var baseElem = getBaseElem(group);

    // These are all they types of groups which hold single characters
    return baseElem.type === "mathord" ||
        baseElem.type === "textord" ||
        baseElem.type === "bin" ||
        baseElem.type === "rel" ||
        baseElem.type === "inner" ||
        baseElem.type === "open" ||
        baseElem.type === "close" ||
        baseElem.type === "punct";
};

var makeNullDelimiter = function(options, classes) {
    return makeSpan(classes.concat([
        "sizing", "reset-" + options.size, "size5",
        options.style.reset(), Style.TEXT.cls(),
        "nulldelimiter"]));
};

/**
 * This is a map of group types to the function used to handle that type.
 * Simpler types come at the beginning, while complicated types come afterwards.
 */
var groupTypes = {};

groupTypes.mathord = function(group, options) {
    return buildCommon.makeOrd(group, options, "mathord");
};

groupTypes.textord = function(group, options) {
    return buildCommon.makeOrd(group, options, "textord");
};

groupTypes.bin = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mbin"]);
};

groupTypes.rel = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mrel"]);
};

groupTypes.open = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mopen"]);
};

groupTypes.close = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mclose"]);
};

groupTypes.inner = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["minner"]);
};

groupTypes.punct = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mpunct"]);
};

groupTypes.ordgroup = function(group, options) {
    return makeSpan(
        ["mord", options.style.cls()],
        buildExpression(group.value, options.reset(), true),
        options
    );
};

groupTypes.text = function(group, options) {
    var newOptions = options.withFont(group.value.style);
    var inner = buildExpression(group.value.body, newOptions, true);
    for (var i = 0; i < inner.length - 1; i++) {
        if (inner[i].tryCombine(inner[i + 1])) {
            inner.splice(i + 1, 1);
            i--;
        }
    }
    return makeSpan(["mord", "text", newOptions.style.cls()],
        inner, newOptions);
};

groupTypes.color = function(group, options) {
    var elements = buildExpression(
        group.value.value,
        options.withColor(group.value.color),
        false
    );

    // \color isn't supposed to affect the type of the elements it contains.
    // To accomplish this, we wrap the results in a fragment, so the inner
    // elements will be able to directly interact with their neighbors. For
    // example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`
    return new buildCommon.makeFragment(elements);
};

groupTypes.supsub = function(group, options) {
    // Superscript and subscripts are handled in the TeXbook on page
    // 445-446, rules 18(a-f).

    // Here is where we defer to the inner group if it should handle
    // superscripts and subscripts itself.
    if (shouldHandleSupSub(group.value.base, options)) {
        return groupTypes[group.value.base.type](group, options);
    }

    var base = buildGroup(group.value.base, options.reset());
    var supmid;
    var submid;
    var sup;
    var sub;

    var style = options.style;
    var newOptions;

    if (group.value.sup) {
        newOptions = options.withStyle(style.sup());
        sup = buildGroup(group.value.sup, newOptions);
        supmid = makeSpan([style.reset(), style.sup().cls()],
            [sup], newOptions);
    }

    if (group.value.sub) {
        newOptions = options.withStyle(style.sub());
        sub = buildGroup(group.value.sub, newOptions);
        submid = makeSpan([style.reset(), style.sub().cls()],
            [sub], newOptions);
    }

    // Rule 18a
    var supShift;
    var subShift;
    if (isCharacterBox(group.value.base)) {
        supShift = 0;
        subShift = 0;
    } else {
        supShift = base.height - style.metrics.supDrop;
        subShift = base.depth + style.metrics.subDrop;
    }

    // Rule 18c
    var minSupShift;
    if (style === Style.DISPLAY) {
        minSupShift = style.metrics.sup1;
    } else if (style.cramped) {
        minSupShift = style.metrics.sup3;
    } else {
        minSupShift = style.metrics.sup2;
    }

    // scriptspace is a font-size-independent size, so scale it
    // appropriately
    var multiplier = Style.TEXT.sizeMultiplier *
            style.sizeMultiplier;
    var scriptspace =
        (0.5 / fontMetrics.metrics.ptPerEm) / multiplier + "em";

    var supsub;
    if (!group.value.sup) {
        // Rule 18b
        subShift = Math.max(
            subShift, style.metrics.sub1,
            sub.height - 0.8 * style.metrics.xHeight);

        supsub = buildCommon.makeVList([
            {type: "elem", elem: submid}
        ], "shift", subShift, options);

        supsub.children[0].style.marginRight = scriptspace;

        // Subscripts shouldn't be shifted by the base's italic correction.
        // Account for that by shifting the subscript back the appropriate
        // amount. Note we only do this when the base is a single symbol.
        if (base instanceof domTree.symbolNode) {
            supsub.children[0].style.marginLeft = -base.italic + "em";
        }
    } else if (!group.value.sub) {
        // Rule 18c, d
        supShift = Math.max(supShift, minSupShift,
            sup.depth + 0.25 * style.metrics.xHeight);

        supsub = buildCommon.makeVList([
            {type: "elem", elem: supmid}
        ], "shift", -supShift, options);

        supsub.children[0].style.marginRight = scriptspace;
    } else {
        supShift = Math.max(
            supShift, minSupShift, sup.depth + 0.25 * style.metrics.xHeight);
        subShift = Math.max(subShift, style.metrics.sub2);

        var ruleWidth = fontMetrics.metrics.defaultRuleThickness;

        // Rule 18e
        if ((supShift - sup.depth) - (sub.height - subShift) <
                4 * ruleWidth) {
            subShift = 4 * ruleWidth - (supShift - sup.depth) + sub.height;
            var psi = 0.8 * style.metrics.xHeight - (supShift - sup.depth);
            if (psi > 0) {
                supShift += psi;
                subShift -= psi;
            }
        }

        supsub = buildCommon.makeVList([
            {type: "elem", elem: submid, shift: subShift},
            {type: "elem", elem: supmid, shift: -supShift}
        ], "individualShift", null, options);

        // See comment above about subscripts not being shifted
        if (base instanceof domTree.symbolNode) {
            supsub.children[0].style.marginLeft = -base.italic + "em";
        }

        supsub.children[0].style.marginRight = scriptspace;
        supsub.children[1].style.marginRight = scriptspace;
    }

    // We ensure to wrap the supsub vlist in a span.msupsub to reset text-align
    var mclass = getTypeOfDomTree(base) || "mord";
    return makeSpan([mclass],
        [base, makeSpan(["msupsub"], [supsub])],
        options);
};

groupTypes.genfrac = function(group, options) {
    // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
    // Figure out what style this fraction should be in based on the
    // function used
    var style = options.style;
    if (group.value.size === "display") {
        style = Style.DISPLAY;
    } else if (group.value.size === "text") {
        style = Style.TEXT;
    }

    var nstyle = style.fracNum();
    var dstyle = style.fracDen();
    var newOptions;

    newOptions = options.withStyle(nstyle);
    var numer = buildGroup(group.value.numer, newOptions);
    var numerreset = makeSpan([style.reset(), nstyle.cls()],
        [numer], newOptions);

    newOptions = options.withStyle(dstyle);
    var denom = buildGroup(group.value.denom, newOptions);
    var denomreset = makeSpan([style.reset(), dstyle.cls()],
        [denom], newOptions);

    var ruleWidth;
    if (group.value.hasBarLine) {
        ruleWidth = fontMetrics.metrics.defaultRuleThickness /
            options.style.sizeMultiplier;
    } else {
        ruleWidth = 0;
    }

    // Rule 15b
    var numShift;
    var clearance;
    var denomShift;
    if (style.size === Style.DISPLAY.size) {
        numShift = style.metrics.num1;
        if (ruleWidth > 0) {
            clearance = 3 * ruleWidth;
        } else {
            clearance = 7 * fontMetrics.metrics.defaultRuleThickness;
        }
        denomShift = style.metrics.denom1;
    } else {
        if (ruleWidth > 0) {
            numShift = style.metrics.num2;
            clearance = ruleWidth;
        } else {
            numShift = style.metrics.num3;
            clearance = 3 * fontMetrics.metrics.defaultRuleThickness;
        }
        denomShift = style.metrics.denom2;
    }

    var frac;
    if (ruleWidth === 0) {
        // Rule 15c
        var candidateClearance =
            (numShift - numer.depth) - (denom.height - denomShift);
        if (candidateClearance < clearance) {
            numShift += 0.5 * (clearance - candidateClearance);
            denomShift += 0.5 * (clearance - candidateClearance);
        }

        frac = buildCommon.makeVList([
            {type: "elem", elem: denomreset, shift: denomShift},
            {type: "elem", elem: numerreset, shift: -numShift}
        ], "individualShift", null, options);
    } else {
        // Rule 15d
        var axisHeight = style.metrics.axisHeight;

        if ((numShift - numer.depth) - (axisHeight + 0.5 * ruleWidth) <
                clearance) {
            numShift +=
                clearance - ((numShift - numer.depth) -
                             (axisHeight + 0.5 * ruleWidth));
        }

        if ((axisHeight - 0.5 * ruleWidth) - (denom.height - denomShift) <
                clearance) {
            denomShift +=
                clearance - ((axisHeight - 0.5 * ruleWidth) -
                             (denom.height - denomShift));
        }

        var mid = makeSpan(
            [options.style.reset(), Style.TEXT.cls(), "frac-line"]);
        // Manually set the height of the line because its height is
        // created in CSS
        mid.height = ruleWidth;

        var midShift = -(axisHeight - 0.5 * ruleWidth);

        frac = buildCommon.makeVList([
            {type: "elem", elem: denomreset, shift: denomShift},
            {type: "elem", elem: mid,        shift: midShift},
            {type: "elem", elem: numerreset, shift: -numShift}
        ], "individualShift", null, options);
    }

    // Since we manually change the style sometimes (with \dfrac or \tfrac),
    // account for the possible size change here.
    frac.height *= style.sizeMultiplier / options.style.sizeMultiplier;
    frac.depth *= style.sizeMultiplier / options.style.sizeMultiplier;

    // Rule 15e
    var delimSize;
    if (style.size === Style.DISPLAY.size) {
        delimSize = style.metrics.delim1;
    } else {
        delimSize = style.metrics.delim2;
    }

    var leftDelim;
    var rightDelim;
    if (group.value.leftDelim == null) {
        leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
        leftDelim = delimiter.customSizedDelim(
            group.value.leftDelim, delimSize, true,
            options.withStyle(style), group.mode, ["mopen"]);
    }
    if (group.value.rightDelim == null) {
        rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
        rightDelim = delimiter.customSizedDelim(
            group.value.rightDelim, delimSize, true,
            options.withStyle(style), group.mode, ["mclose"]);
    }

    return makeSpan(
        ["mord", options.style.reset(), style.cls()],
        [leftDelim, makeSpan(["mfrac"], [frac]), rightDelim],
        options);
};

var calculateSize = function(sizeValue, style) {
    var x = sizeValue.number;
    if (sizeValue.unit === "ex") {
        x *= style.metrics.emPerEx;
    } else if (sizeValue.unit === "mu") {
        x /= 18;
    }
    return x;
};

groupTypes.array = function(group, options) {
    var r;
    var c;
    var nr = group.value.body.length;
    var nc = 0;
    var body = new Array(nr);

    var style = options.style;

    // Horizontal spacing
    var pt = 1 / fontMetrics.metrics.ptPerEm;
    var arraycolsep = 5 * pt; // \arraycolsep in article.cls

    // Vertical spacing
    var baselineskip = 12 * pt; // see size10.clo
    // Default \arraystretch from lttab.dtx
    // TODO(gagern): may get redefined once we have user-defined macros
    var arraystretch = utils.deflt(group.value.arraystretch, 1);
    var arrayskip = arraystretch * baselineskip;
    var arstrutHeight = 0.7 * arrayskip; // \strutbox in ltfsstrc.dtx and
    var arstrutDepth = 0.3 * arrayskip;  // \@arstrutbox in lttab.dtx

    var totalHeight = 0;
    for (r = 0; r < group.value.body.length; ++r) {
        var inrow = group.value.body[r];
        var height = arstrutHeight; // \@array adds an \@arstrut
        var depth = arstrutDepth;   // to each tow (via the template)

        if (nc < inrow.length) {
            nc = inrow.length;
        }

        var outrow = new Array(inrow.length);
        for (c = 0; c < inrow.length; ++c) {
            var elt = buildGroup(inrow[c], options);
            if (depth < elt.depth) {
                depth = elt.depth;
            }
            if (height < elt.height) {
                height = elt.height;
            }
            outrow[c] = elt;
        }

        var gap = 0;
        if (group.value.rowGaps[r]) {
            gap = calculateSize(group.value.rowGaps[r].value, style);
            if (gap > 0) { // \@argarraycr
                gap += arstrutDepth;
                if (depth < gap) {
                    depth = gap; // \@xargarraycr
                }
                gap = 0;
            }
        }

        outrow.height = height;
        outrow.depth = depth;
        totalHeight += height;
        outrow.pos = totalHeight;
        totalHeight += depth + gap; // \@yargarraycr
        body[r] = outrow;
    }

    var offset = totalHeight / 2 + style.metrics.axisHeight;
    var colDescriptions = group.value.cols || [];
    var cols = [];
    var colSep;
    var colDescrNum;
    for (c = 0, colDescrNum = 0;
         // Continue while either there are more columns or more column
         // descriptions, so trailing separators don't get lost.
         c < nc || colDescrNum < colDescriptions.length;
         ++c, ++colDescrNum) {

        var colDescr = colDescriptions[colDescrNum] || {};

        var firstSeparator = true;
        while (colDescr.type === "separator") {
            // If there is more than one separator in a row, add a space
            // between them.
            if (!firstSeparator) {
                colSep = makeSpan(["arraycolsep"], []);
                colSep.style.width =
                    fontMetrics.metrics.doubleRuleSep + "em";
                cols.push(colSep);
            }

            if (colDescr.separator === "|") {
                var separator = makeSpan(
                    ["vertical-separator"],
                    []);
                separator.style.height = totalHeight + "em";
                separator.style.verticalAlign =
                    -(totalHeight - offset) + "em";

                cols.push(separator);
            } else {
                throw new ParseError(
                    "Invalid separator type: " + colDescr.separator);
            }

            colDescrNum++;
            colDescr = colDescriptions[colDescrNum] || {};
            firstSeparator = false;
        }

        if (c >= nc) {
            continue;
        }

        var sepwidth;
        if (c > 0 || group.value.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
            if (sepwidth !== 0) {
                colSep = makeSpan(["arraycolsep"], []);
                colSep.style.width = sepwidth + "em";
                cols.push(colSep);
            }
        }

        var col = [];
        for (r = 0; r < nr; ++r) {
            var row = body[r];
            var elem = row[c];
            if (!elem) {
                continue;
            }
            var shift = row.pos - offset;
            elem.depth = row.depth;
            elem.height = row.height;
            col.push({type: "elem", elem: elem, shift: shift});
        }

        col = buildCommon.makeVList(col, "individualShift", null, options);
        col = makeSpan(
            ["col-align-" + (colDescr.align || "c")],
            [col]);
        cols.push(col);

        if (c < nc - 1 || group.value.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
            if (sepwidth !== 0) {
                colSep = makeSpan(["arraycolsep"], []);
                colSep.style.width = sepwidth + "em";
                cols.push(colSep);
            }
        }
    }
    body = makeSpan(["mtable"], cols);
    return makeSpan(["mord"], [body], options);
};

groupTypes.spacing = function(group, options) {
    if (group.value === "\\ " || group.value === "\\space" ||
        group.value === " " || group.value === "~") {
        // Spaces are generated by adding an actual space. Each of these
        // things has an entry in the symbols table, so these will be turned
        // into appropriate outputs.
        if (group.mode === "text") {
            return buildCommon.makeOrd(group, options, "textord");
        } else {
            return makeSpan(["mspace"],
                [buildCommon.mathsym(group.value, group.mode, options)],
                options);
        }
    } else {
        // Other kinds of spaces are of arbitrary width. We use CSS to
        // generate these.
        return makeSpan(
            ["mspace",
                buildCommon.spacingFunctions[group.value].className],
            [], options);
    }
};

groupTypes.llap = function(group, options) {
    var inner = makeSpan(
        ["inner"], [buildGroup(group.value.body, options.reset())]);
    var fix = makeSpan(["fix"], []);
    return makeSpan(
        ["mord", "llap", options.style.cls()], [inner, fix], options);
};

groupTypes.rlap = function(group, options) {
    var inner = makeSpan(
        ["inner"], [buildGroup(group.value.body, options.reset())]);
    var fix = makeSpan(["fix"], []);
    return makeSpan(
        ["mord", "rlap", options.style.cls()], [inner, fix], options);
};

groupTypes.op = function(group, options) {
    // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
    var supGroup;
    var subGroup;
    var hasLimits = false;
    if (group.type === "supsub") {
        // If we have limits, supsub will pass us its group to handle. Pull
        // out the superscript and subscript and set the group to the op in
        // its base.
        supGroup = group.value.sup;
        subGroup = group.value.sub;
        group = group.value.base;
        hasLimits = true;
    }

    var style = options.style;

    // Most operators have a large successor symbol, but these don't.
    var noSuccessor = [
        "\\smallint"
    ];

    var large = false;
    if (style.size === Style.DISPLAY.size &&
        group.value.symbol &&
        !utils.contains(noSuccessor, group.value.body)) {

        // Most symbol operators get larger in displaystyle (rule 13)
        large = true;
    }

    var base;
    var baseShift = 0;
    var slant = 0;
    if (group.value.symbol) {
        // If this is a symbol, create the symbol.
        var fontName = large ? "Size2-Regular" : "Size1-Regular";
        base = buildCommon.makeSymbol(
            group.value.body, fontName, "math", options,
            ["mop", "op-symbol", large ? "large-op" : "small-op"]);

        // Shift the symbol so its center lies on the axis (rule 13). It
        // appears that our fonts have the centers of the symbols already
        // almost on the axis, so these numbers are very small. Note we
        // don't actually apply this here, but instead it is used either in
        // the vlist creation or separately when there are no limits.
        baseShift = (base.height - base.depth) / 2 -
            style.metrics.axisHeight * style.sizeMultiplier;

        // The slant of the symbol is just its italic correction.
        slant = base.italic;
    } else if (group.value.value) {
        // If this is a list, compose that list.
        var inner = buildExpression(group.value.value, options, true);

        base = makeSpan(["mop"], inner, options);
    } else {
        // Otherwise, this is a text operator. Build the text from the
        // operator's name.
        // TODO(emily): Add a space in the middle of some of these
        // operators, like \limsup
        var output = [];
        for (var i = 1; i < group.value.body.length; i++) {
            output.push(buildCommon.mathsym(group.value.body[i], group.mode));
        }
        base = makeSpan(["mop"], output, options);
    }

    if (hasLimits) {
        // IE 8 clips \int if it is in a display: inline-block. We wrap it
        // in a new span so it is an inline, and works.
        base = makeSpan([], [base]);

        var supmid;
        var supKern;
        var submid;
        var subKern;
        var newOptions;
        // We manually have to handle the superscripts and subscripts. This,
        // aside from the kern calculations, is copied from supsub.
        if (supGroup) {
            newOptions = options.withStyle(style.sup());
            var sup = buildGroup(supGroup, newOptions);
            supmid = makeSpan([style.reset(), style.sup().cls()],
                [sup], newOptions);

            supKern = Math.max(
                fontMetrics.metrics.bigOpSpacing1,
                fontMetrics.metrics.bigOpSpacing3 - sup.depth);
        }

        if (subGroup) {
            newOptions = options.withStyle(style.sub());
            var sub = buildGroup(subGroup, newOptions);
            submid = makeSpan([style.reset(), style.sub().cls()],
                [sub], newOptions);

            subKern = Math.max(
                fontMetrics.metrics.bigOpSpacing2,
                fontMetrics.metrics.bigOpSpacing4 - sub.height);
        }

        // Build the final group as a vlist of the possible subscript, base,
        // and possible superscript.
        var finalGroup;
        var top;
        var bottom;
        if (!supGroup) {
            top = base.height - baseShift;

            finalGroup = buildCommon.makeVList([
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5},
                {type: "elem", elem: submid},
                {type: "kern", size: subKern},
                {type: "elem", elem: base}
            ], "top", top, options);

            // Here, we shift the limits by the slant of the symbol. Note
            // that we are supposed to shift the limits by 1/2 of the slant,
            // but since we are centering the limits adding a full slant of
            // margin will shift by 1/2 that.
            finalGroup.children[0].style.marginLeft = -slant + "em";
        } else if (!subGroup) {
            bottom = base.depth + baseShift;

            finalGroup = buildCommon.makeVList([
                {type: "elem", elem: base},
                {type: "kern", size: supKern},
                {type: "elem", elem: supmid},
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5}
            ], "bottom", bottom, options);

            // See comment above about slants
            finalGroup.children[1].style.marginLeft = slant + "em";
        } else if (!supGroup && !subGroup) {
            // This case probably shouldn't occur (this would mean the
            // supsub was sending us a group with no superscript or
            // subscript) but be safe.
            return base;
        } else {
            bottom = fontMetrics.metrics.bigOpSpacing5 +
                submid.height + submid.depth +
                subKern +
                base.depth + baseShift;

            finalGroup = buildCommon.makeVList([
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5},
                {type: "elem", elem: submid},
                {type: "kern", size: subKern},
                {type: "elem", elem: base},
                {type: "kern", size: supKern},
                {type: "elem", elem: supmid},
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5}
            ], "bottom", bottom, options);

            // See comment above about slants
            finalGroup.children[0].style.marginLeft = -slant + "em";
            finalGroup.children[2].style.marginLeft = slant + "em";
        }

        return makeSpan(["mop", "op-limits"], [finalGroup], options);
    } else {
        if (group.value.symbol) {
            base.style.top = baseShift + "em";
        }

        return base;
    }
};

groupTypes.mod = function(group, options) {
    var inner = [];

    if (group.value.modType === "bmod") {
        // \nonscript\mskip-\medmuskip\mkern5mu
        if (!options.style.isTight()) {
            inner.push(makeSpan(
                ["mspace", "negativemediumspace"], [], options));
        }
        inner.push(makeSpan(["mspace", "thickspace"], [], options));
    } else if (options.style.size === Style.DISPLAY.size) {
        inner.push(makeSpan(["mspace", "quad"], [], options));
    } else if (group.value.modType === "mod") {
        inner.push(makeSpan(["mspace", "twelvemuspace"], [], options));
    } else {
        inner.push(makeSpan(["mspace", "eightmuspace"], [], options));
    }

    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(buildCommon.mathsym("(", group.mode));
    }

    if (group.value.modType !== "pod") {
        var modInner = [
            buildCommon.mathsym("m", group.mode),
            buildCommon.mathsym("o", group.mode),
            buildCommon.mathsym("d", group.mode)];
        if (group.value.modType === "bmod") {
            inner.push(makeSpan(["mbin"], modInner, options));
            // \mkern5mu\nonscript\mskip-\medmuskip
            inner.push(makeSpan(["mspace", "thickspace"], [], options));
            if (!options.style.isTight()) {
                inner.push(makeSpan(
                    ["mspace", "negativemediumspace"], [], options));
            }
        } else {
            Array.prototype.push.apply(inner, modInner);
            inner.push(makeSpan(["mspace", "sixmuspace"], [], options));
        }
    }

    if (group.value.value) {
        Array.prototype.push.apply(inner,
            buildExpression(group.value.value, options, false));
    }

    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(buildCommon.mathsym(")", group.mode));
    }

    return buildCommon.makeFragment(inner);
};

groupTypes.katex = function(group, options) {
    // The KaTeX logo. The offsets for the K and a were chosen to look
    // good, but the offsets for the T, E, and X were taken from the
    // definition of \TeX in TeX (see TeXbook pg. 356)
    var k = makeSpan(
        ["k"], [buildCommon.mathsym("K", group.mode)], options);
    var a = makeSpan(
        ["a"], [buildCommon.mathsym("A", group.mode)], options);

    a.height = (a.height + 0.2) * 0.75;
    a.depth = (a.height - 0.2) * 0.75;

    var t = makeSpan(
        ["t"], [buildCommon.mathsym("T", group.mode)], options);
    var e = makeSpan(
        ["e"], [buildCommon.mathsym("E", group.mode)], options);

    e.height = (e.height - 0.2155);
    e.depth = (e.depth + 0.2155);

    var x = makeSpan(
        ["x"], [buildCommon.mathsym("X", group.mode)], options);

    return makeSpan(
        ["mord", "katex-logo"], [k, a, t, e, x], options);
};

groupTypes.overline = function(group, options) {
    // Overlines are handled in the TeXbook pg 443, Rule 9.
    var style = options.style;

    // Build the inner group in the cramped style.
    var innerGroup = buildGroup(group.value.body,
            options.withStyle(style.cramp()));

    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
        style.sizeMultiplier;

    // Create the line above the body
    var line = makeSpan(
        [style.reset(), Style.TEXT.cls(), "overline-line"]);
    line.height = ruleWidth;
    line.maxFontSize = 1.0;

    // Generate the vlist, with the appropriate kerns
    var vlist = buildCommon.makeVList([
        {type: "elem", elem: innerGroup},
        {type: "kern", size: 3 * ruleWidth},
        {type: "elem", elem: line},
        {type: "kern", size: ruleWidth}
    ], "firstBaseline", null, options);

    return makeSpan(["mord", "overline"], [vlist], options);
};

groupTypes.underline = function(group, options) {
    // Underlines are handled in the TeXbook pg 443, Rule 10.
    var style = options.style;

    // Build the inner group.
    var innerGroup = buildGroup(group.value.body, options);

    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
        style.sizeMultiplier;

    // Create the line above the body
    var line = makeSpan([style.reset(), Style.TEXT.cls(), "underline-line"]);
    line.height = ruleWidth;
    line.maxFontSize = 1.0;

    // Generate the vlist, with the appropriate kerns
    var vlist = buildCommon.makeVList([
        {type: "kern", size: ruleWidth},
        {type: "elem", elem: line},
        {type: "kern", size: 3 * ruleWidth},
        {type: "elem", elem: innerGroup}
    ], "top", innerGroup.height, options);

    return makeSpan(["mord", "underline"], [vlist], options);
};

groupTypes.sqrt = function(group, options) {
    // Square roots are handled in the TeXbook pg. 443, Rule 11.
    var style = options.style;

    // First, we do the same steps as in overline to build the inner group
    // and line
    var inner = buildGroup(group.value.body, options.withStyle(style.cramp()));

    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
        style.sizeMultiplier;

    var line = makeSpan(
        [style.reset(), Style.TEXT.cls(), "sqrt-line"], [],
        options);
    line.height = ruleWidth;
    line.maxFontSize = 1.0;

    var phi = ruleWidth;
    if (style.id < Style.TEXT.id) {
        phi = style.metrics.xHeight;
    }

    // Calculate the clearance between the body and line
    var lineClearance = ruleWidth + phi / 4;

    var innerHeight = (inner.height + inner.depth) * style.sizeMultiplier;
    var minDelimiterHeight = innerHeight + lineClearance + ruleWidth;

    // Create a \surd delimiter of the required minimum size
    var delim = makeSpan(["sqrt-sign"], [
        delimiter.customSizedDelim("\\surd", minDelimiterHeight,
                                   false, options, group.mode)],
                         options);

    var delimDepth = (delim.height + delim.depth) - ruleWidth;

    // Adjust the clearance based on the delimiter size
    if (delimDepth > inner.height + inner.depth + lineClearance) {
        lineClearance =
            (lineClearance + delimDepth - inner.height - inner.depth) / 2;
    }

    // Shift the delimiter so that its top lines up with the top of the line
    var delimShift = -(inner.height + lineClearance + ruleWidth) + delim.height;
    delim.style.top = delimShift + "em";
    delim.height -= delimShift;
    delim.depth += delimShift;

    // We add a special case here, because even when `inner` is empty, we
    // still get a line. So, we use a simple heuristic to decide if we
    // should omit the body entirely. (note this doesn't work for something
    // like `\sqrt{\rlap{x}}`, but if someone is doing that they deserve for
    // it not to work.
    var body;
    if (inner.height === 0 && inner.depth === 0) {
        body = makeSpan();
    } else {
        body = buildCommon.makeVList([
            {type: "elem", elem: inner},
            {type: "kern", size: lineClearance},
            {type: "elem", elem: line},
            {type: "kern", size: ruleWidth}
        ], "firstBaseline", null, options);
    }

    if (!group.value.index) {
        return makeSpan(["mord", "sqrt"], [delim, body], options);
    } else {
        // Handle the optional root index

        // The index is always in scriptscript style
        var newOptions = options.withStyle(Style.SCRIPTSCRIPT);
        var root = buildGroup(group.value.index, newOptions);
        var rootWrap = makeSpan(
            [style.reset(), Style.SCRIPTSCRIPT.cls()],
            [root],
            newOptions);

        // Figure out the height and depth of the inner part
        var innerRootHeight = Math.max(delim.height, body.height);
        var innerRootDepth = Math.max(delim.depth, body.depth);

        // The amount the index is shifted by. This is taken from the TeX
        // source, in the definition of `\r@@t`.
        var toShift = 0.6 * (innerRootHeight - innerRootDepth);

        // Build a VList with the superscript shifted up correctly
        var rootVList = buildCommon.makeVList(
            [{type: "elem", elem: rootWrap}],
            "shift", -toShift, options);
        // Add a class surrounding it so we can add on the appropriate
        // kerning
        var rootVListWrap = makeSpan(["root"], [rootVList]);

        return makeSpan(["mord", "sqrt"],
            [rootVListWrap, delim, body], options);
    }
};

groupTypes.sizing = function(group, options) {
    // Handle sizing operators like \Huge. Real TeX doesn't actually allow
    // these functions inside of math expressions, so we do some special
    // handling.
    var inner = buildExpression(group.value.value,
            options.withSize(group.value.size), false);

    // Compute the correct maxFontSize.
    var style = options.style;
    var fontSize = buildCommon.sizingMultiplier[group.value.size];
    fontSize = fontSize * style.sizeMultiplier;

    // Add size-resetting classes to the inner list and set maxFontSize
    // manually. Handle nested size changes.
    for (var i = 0; i < inner.length; i++) {
        var pos = utils.indexOf(inner[i].classes, "sizing");
        if (pos < 0) {
            inner[i].classes.push("sizing", "reset-" + options.size,
                                  group.value.size, style.cls());
            inner[i].maxFontSize = fontSize;
        } else if (inner[i].classes[pos + 1] === "reset-" + group.value.size) {
            // This is a nested size change: e.g., inner[i] is the "b" in
            // `\Huge a \small b`. Override the old size (the `reset-` class)
            // but not the new size.
            inner[i].classes[pos + 1] = "reset-" + options.size;
        }
    }

    return buildCommon.makeFragment(inner);
};

groupTypes.styling = function(group, options) {
    // Style changes are handled in the TeXbook on pg. 442, Rule 3.

    // Figure out what style we're changing to.
    var styleMap = {
        "display": Style.DISPLAY,
        "text": Style.TEXT,
        "script": Style.SCRIPT,
        "scriptscript": Style.SCRIPTSCRIPT
    };

    var newStyle = styleMap[group.value.style];
    var newOptions = options.withStyle(newStyle);

    // Build the inner expression in the new style.
    var inner = buildExpression(
        group.value.value, newOptions, false);

    // Add style-resetting classes to the inner list. Handle nested changes.
    for (var i = 0; i < inner.length; i++) {
        var pos = utils.indexOf(inner[i].classes, newStyle.reset());
        if (pos < 0) {
            inner[i].classes.push(options.style.reset(), newStyle.cls());
        } else {
            // This is a nested style change, as `\textstyle a\scriptstyle b`.
            // Only override the old style (the reset class).
            inner[i].classes[pos] = options.style.reset();
        }
    }

    return new buildCommon.makeFragment(inner);
};

groupTypes.font = function(group, options) {
    var font = group.value.font;
    return buildGroup(group.value.body, options.withFont(font));
};

groupTypes.delimsizing = function(group, options) {
    var delim = group.value.value;

    if (delim === ".") {
        // Empty delimiters still count as elements, even though they don't
        // show anything.
        return makeSpan([group.value.mclass]);
    }

    // Use delimiter.sizedDelim to generate the delimiter.
    return delimiter.sizedDelim(
            delim, group.value.size, options, group.mode,
            [group.value.mclass]);
};

groupTypes.leftright = function(group, options) {
    // Build the inner expression
    var inner = buildExpression(group.value.body, options.reset(), true);

    var innerHeight = 0;
    var innerDepth = 0;
    var hadMiddle = false;

    // Calculate its height and depth
    for (var i = 0; i < inner.length; i++) {
        if (inner[i].isMiddle) {
            hadMiddle = true;
        } else {
            innerHeight = Math.max(inner[i].height, innerHeight);
            innerDepth = Math.max(inner[i].depth, innerDepth);
        }
    }

    var style = options.style;

    // The size of delimiters is the same, regardless of what style we are
    // in. Thus, to correctly calculate the size of delimiter we need around
    // a group, we scale down the inner size based on the size.
    innerHeight *= style.sizeMultiplier;
    innerDepth *= style.sizeMultiplier;

    var leftDelim;
    if (group.value.left === ".") {
        // Empty delimiters in \left and \right make null delimiter spaces.
        leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
        // Otherwise, use leftRightDelim to generate the correct sized
        // delimiter.
        leftDelim = delimiter.leftRightDelim(
            group.value.left, innerHeight, innerDepth, options,
            group.mode, ["mopen"]);
    }
    // Add it to the beginning of the expression
    inner.unshift(leftDelim);

    // Handle middle delimiters
    if (hadMiddle) {
        for (i = 1; i < inner.length; i++) {
            if (inner[i].isMiddle) {
                // Apply the options that were active when \middle was called
                inner[i] = delimiter.leftRightDelim(
                    inner[i].isMiddle.value, innerHeight, innerDepth,
                    inner[i].isMiddle.options, group.mode, []);
            }
        }
    }

    var rightDelim;
    // Same for the right delimiter
    if (group.value.right === ".") {
        rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
        rightDelim = delimiter.leftRightDelim(
            group.value.right, innerHeight, innerDepth, options,
            group.mode, ["mclose"]);
    }
    // Add it to the end of the expression.
    inner.push(rightDelim);

    return makeSpan(
        ["minner", style.cls()], inner, options);
};

groupTypes.middle = function(group, options) {
    var middleDelim;
    if (group.value.value === ".") {
        middleDelim = makeNullDelimiter(options, []);
    } else {
        middleDelim = delimiter.sizedDelim(
            group.value.value, 1, options,
            group.mode, []);
        middleDelim.isMiddle = {value: group.value.value, options: options};
    }
    return middleDelim;
};

groupTypes.rule = function(group, options) {
    // Make an empty span for the rule
    var rule = makeSpan(["mord", "rule"], [], options);
    var style = options.style;

    // Calculate the shift, width, and height of the rule, and account for units
    var shift = 0;
    if (group.value.shift) {
        shift = calculateSize(group.value.shift, style);
    }

    var width = calculateSize(group.value.width, style);
    var height = calculateSize(group.value.height, style);

    // The sizes of rules are absolute, so make it larger if we are in a
    // smaller style.
    shift /= style.sizeMultiplier;
    width /= style.sizeMultiplier;
    height /= style.sizeMultiplier;

    // Style the rule to the right size
    rule.style.borderRightWidth = width + "em";
    rule.style.borderTopWidth = height + "em";
    rule.style.bottom = shift + "em";

    // Record the height and width
    rule.width = width;
    rule.height = height + shift;
    rule.depth = -shift;

    return rule;
};

groupTypes.kern = function(group, options) {
    // Make an empty span for the rule
    var rule = makeSpan(["mord", "rule"], [], options);
    var style = options.style;

    var dimension = 0;
    if (group.value.dimension) {
        dimension = calculateSize(group.value.dimension, style);
    }

    dimension /= style.sizeMultiplier;

    rule.style.marginLeft = dimension + "em";

    return rule;
};

groupTypes.accent = function(group, options) {
    // Accents are handled in the TeXbook pg. 443, rule 12.
    var base = group.value.base;
    var style = options.style;

    var supsubGroup;
    if (group.type === "supsub") {
        // If our base is a character box, and we have superscripts and
        // subscripts, the supsub will defer to us. In particular, we want
        // to attach the superscripts and subscripts to the inner body (so
        // that the position of the superscripts and subscripts won't be
        // affected by the height of the accent). We accomplish this by
        // sticking the base of the accent into the base of the supsub, and
        // rendering that, while keeping track of where the accent is.

        // The supsub group is the group that was passed in
        var supsub = group;
        // The real accent group is the base of the supsub group
        group = supsub.value.base;
        // The character box is the base of the accent group
        base = group.value.base;
        // Stick the character box into the base of the supsub group
        supsub.value.base = base;

        // Rerender the supsub group with its new base, and store that
        // result.
        supsubGroup = buildGroup(
            supsub, options.reset());
    }

    // Build the base group
    var body = buildGroup(
        base, options.withStyle(style.cramp()));

    // Calculate the skew of the accent. This is based on the line "If the
    // nucleus is not a single character, let s = 0; otherwise set s to the
    // kern amount for the nucleus followed by the \skewchar of its font."
    // Note that our skew metrics are just the kern between each character
    // and the skewchar.
    var skew;
    if (isCharacterBox(base)) {
        // If the base is a character box, then we want the skew of the
        // innermost character. To do that, we find the innermost character:
        var baseChar = getBaseElem(base);
        // Then, we render its group to get the symbol inside it
        var baseGroup = buildGroup(
            baseChar, options.withStyle(style.cramp()));
        // Finally, we pull the skew off of the symbol.
        skew = baseGroup.skew;
        // Note that we now throw away baseGroup, because the layers we
        // removed with getBaseElem might contain things like \color which
        // we can't get rid of.
        // TODO(emily): Find a better way to get the skew
    } else {
        skew = 0;
    }

    // calculate the amount of space between the body and the accent
    var clearance = Math.min(
        body.height,
        style.metrics.xHeight);

    // Build the accent
    var accent = buildCommon.makeSymbol(
        group.value.accent, "Main-Regular", "math", options);
    // Remove the italic correction of the accent, because it only serves to
    // shift the accent over to a place we don't want.
    accent.italic = 0;

    // The \vec character that the fonts use is a combining character, and
    // thus shows up much too far to the left. To account for this, we add a
    // specific class which shifts the accent over to where we want it.
    // TODO(emily): Fix this in a better way, like by changing the font
    var vecClass = group.value.accent === "\\vec" ? "accent-vec" : null;

    var accentBody = makeSpan(["accent-body", vecClass], [
        makeSpan([], [accent])]);

    accentBody = buildCommon.makeVList([
        {type: "elem", elem: body},
        {type: "kern", size: -clearance},
        {type: "elem", elem: accentBody}
    ], "firstBaseline", null, options);

    // Shift the accent over by the skew. Note we shift by twice the skew
    // because we are centering the accent, so by adding 2*skew to the left,
    // we shift it to the right by 1*skew.
    accentBody.children[1].style.marginLeft = 2 * skew + "em";

    var accentWrap = makeSpan(["mord", "accent"], [accentBody], options);

    if (supsubGroup) {
        // Here, we replace the "base" child of the supsub with our newly
        // generated accent.
        supsubGroup.children[0] = accentWrap;

        // Since we don't rerun the height calculation after replacing the
        // accent, we manually recalculate height.
        supsubGroup.height = Math.max(accentWrap.height, supsubGroup.height);

        // Accents should always be ords, even when their innards are not.
        supsubGroup.classes[0] = "mord";

        return supsubGroup;
    } else {
        return accentWrap;
    }
};

groupTypes.phantom = function(group, options) {
    var elements = buildExpression(
        group.value.value,
        options.withPhantom(),
        false
    );

    // \phantom isn't supposed to affect the elements it contains.
    // See "color" for more details.
    return new buildCommon.makeFragment(elements);
};

groupTypes.mclass = function(group, options) {
    var elements = buildExpression(group.value.value, options, true);

    return makeSpan([group.value.mclass], elements, options);
};

/**
 * buildGroup is the function that takes a group and calls the correct groupType
 * function for it. It also handles the interaction of size and style changes
 * between parents and children.
 */
var buildGroup = function(group, options) {
    if (!group) {
        return makeSpan();
    }

    if (groupTypes[group.type]) {
        // Call the groupTypes function
        var groupNode = groupTypes[group.type](group, options);
        var multiplier;

        // If the style changed between the parent and the current group,
        // account for the size difference
        if (options.style !== options.parentStyle) {
            multiplier = options.style.sizeMultiplier /
                    options.parentStyle.sizeMultiplier;

            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
        }

        // If the size changed between the parent and the current group, account
        // for that size difference.
        if (options.size !== options.parentSize) {
            multiplier = buildCommon.sizingMultiplier[options.size] /
                    buildCommon.sizingMultiplier[options.parentSize];

            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
        }

        return groupNode;
    } else {
        throw new ParseError(
            "Got group of unknown type: '" + group.type + "'");
    }
};

/**
 * Take an entire parse tree, and build it into an appropriate set of HTML
 * nodes.
 */
var buildHTML = function(tree, options) {
    // buildExpression is destructive, so we need to make a clone
    // of the incoming tree so that it isn't accidentally changed
    tree = JSON.parse(JSON.stringify(tree));

    // Build the expression contained in the tree
    var expression = buildExpression(tree, options, true);
    var body = makeSpan(["base", options.style.cls()], expression, options);

    // Add struts, which ensure that the top of the HTML element falls at the
    // height of the expression, and the bottom of the HTML element falls at the
    // depth of the expression.
    var topStrut = makeSpan(["strut"]);
    var bottomStrut = makeSpan(["strut", "bottom"]);

    topStrut.style.height = body.height + "em";
    bottomStrut.style.height = (body.height + body.depth) + "em";
    // We'd like to use `vertical-align: top` but in IE 9 this lowers the
    // baseline of the box to the bottom of this strut (instead staying in the
    // normal place) so we use an absolute value for vertical-align instead
    bottomStrut.style.verticalAlign = -body.depth + "em";

    // Wrap the struts and body together
    var htmlNode = makeSpan(["katex-html"], [topStrut, bottomStrut, body]);

    htmlNode.setAttribute("aria-hidden", "true");

    return htmlNode;
};

module.exports = buildHTML;

},{"./ParseError":81,"./Style":84,"./buildCommon":85,"./delimiter":89,"./domTree":90,"./fontMetrics":92,"./utils":100}],87:[function(require,module,exports){
/**
 * This file converts a parse tree into a cooresponding MathML tree. The main
 * entry point is the `buildMathML` function, which takes a parse tree from the
 * parser.
 */

var buildCommon = require("./buildCommon");
var fontMetrics = require("./fontMetrics");
var mathMLTree = require("./mathMLTree");
var ParseError = require("./ParseError");
var symbols = require("./symbols");
var utils = require("./utils");

var makeSpan = buildCommon.makeSpan;
var fontMap = buildCommon.fontMap;

/**
 * Takes a symbol and converts it into a MathML text node after performing
 * optional replacement from symbols.js.
 */
var makeText = function(text, mode) {
    if (symbols[mode][text] && symbols[mode][text].replace) {
        text = symbols[mode][text].replace;
    }

    return new mathMLTree.TextNode(text);
};

/**
 * Returns the math variant as a string or null if none is required.
 */
var getVariant = function(group, options) {
    var font = options.font;
    if (!font) {
        return null;
    }

    var mode = group.mode;
    if (font === "mathit") {
        return "italic";
    }

    var value = group.value;
    if (utils.contains(["\\imath", "\\jmath"], value)) {
        return null;
    }

    if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var fontName = fontMap[font].fontName;
    if (fontMetrics.getCharacterMetrics(value, fontName)) {
        return fontMap[options.font].variant;
    }

    return null;
};

/**
 * Functions for handling the different types of groups found in the parse
 * tree. Each function should take a parse group and return a MathML node.
 */
var groupTypes = {};

groupTypes.mathord = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mi",
        [makeText(group.value, group.mode)]);

    var variant = getVariant(group, options);
    if (variant) {
        node.setAttribute("mathvariant", variant);
    }
    return node;
};

groupTypes.textord = function(group, options) {
    var text = makeText(group.value, group.mode);

    var variant = getVariant(group, options) || "normal";

    var node;
    if (/[0-9]/.test(group.value)) {
        // TODO(kevinb) merge adjacent <mn> nodes
        // do it as a post processing step
        node = new mathMLTree.MathNode("mn", [text]);
        if (options.font) {
            node.setAttribute("mathvariant", variant);
        }
    } else {
        node = new mathMLTree.MathNode("mi", [text]);
        node.setAttribute("mathvariant", variant);
    }

    return node;
};

groupTypes.bin = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.rel = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.open = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.close = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.inner = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.punct = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    node.setAttribute("separator", "true");

    return node;
};

groupTypes.ordgroup = function(group, options) {
    var inner = buildExpression(group.value, options);

    var node = new mathMLTree.MathNode("mrow", inner);

    return node;
};

groupTypes.text = function(group, options) {
    var inner = buildExpression(group.value.body, options);

    var node = new mathMLTree.MathNode("mtext", inner);

    return node;
};

groupTypes.color = function(group, options) {
    var inner = buildExpression(group.value.value, options);

    var node = new mathMLTree.MathNode("mstyle", inner);

    node.setAttribute("mathcolor", group.value.color);

    return node;
};

groupTypes.supsub = function(group, options) {
    var children = [buildGroup(group.value.base, options)];

    if (group.value.sub) {
        children.push(buildGroup(group.value.sub, options));
    }

    if (group.value.sup) {
        children.push(buildGroup(group.value.sup, options));
    }

    var nodeType;
    if (!group.value.sub) {
        nodeType = "msup";
    } else if (!group.value.sup) {
        nodeType = "msub";
    } else {
        nodeType = "msubsup";
    }

    var node = new mathMLTree.MathNode(nodeType, children);

    return node;
};

groupTypes.genfrac = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mfrac",
        [buildGroup(group.value.numer, options),
            buildGroup(group.value.denom, options)]);

    if (!group.value.hasBarLine) {
        node.setAttribute("linethickness", "0px");
    }

    if (group.value.leftDelim != null || group.value.rightDelim != null) {
        var withDelims = [];

        if (group.value.leftDelim != null) {
            var leftOp = new mathMLTree.MathNode(
                "mo", [new mathMLTree.TextNode(group.value.leftDelim)]);

            leftOp.setAttribute("fence", "true");

            withDelims.push(leftOp);
        }

        withDelims.push(node);

        if (group.value.rightDelim != null) {
            var rightOp = new mathMLTree.MathNode(
                "mo", [new mathMLTree.TextNode(group.value.rightDelim)]);

            rightOp.setAttribute("fence", "true");

            withDelims.push(rightOp);
        }

        var outerNode = new mathMLTree.MathNode("mrow", withDelims);

        return outerNode;
    }

    return node;
};

groupTypes.array = function(group, options) {
    return new mathMLTree.MathNode(
        "mtable", group.value.body.map(function(row) {
            return new mathMLTree.MathNode(
                "mtr", row.map(function(cell) {
                    return new mathMLTree.MathNode(
                        "mtd", [buildGroup(cell, options)]);
                }));
        }));
};

groupTypes.sqrt = function(group, options) {
    var node;
    if (group.value.index) {
        node = new mathMLTree.MathNode(
            "mroot", [
                buildGroup(group.value.body, options),
                buildGroup(group.value.index, options)
            ]);
    } else {
        node = new mathMLTree.MathNode(
            "msqrt", [buildGroup(group.value.body, options)]);
    }

    return node;
};

groupTypes.leftright = function(group, options) {
    var inner = buildExpression(group.value.body, options);

    if (group.value.left !== ".") {
        var leftNode = new mathMLTree.MathNode(
            "mo", [makeText(group.value.left, group.mode)]);

        leftNode.setAttribute("fence", "true");

        inner.unshift(leftNode);
    }

    if (group.value.right !== ".") {
        var rightNode = new mathMLTree.MathNode(
            "mo", [makeText(group.value.right, group.mode)]);

        rightNode.setAttribute("fence", "true");

        inner.push(rightNode);
    }

    var outerNode = new mathMLTree.MathNode("mrow", inner);

    return outerNode;
};

groupTypes.middle = function(group, options) {
    var middleNode = new mathMLTree.MathNode(
        "mo", [makeText(group.value.middle, group.mode)]);
    middleNode.setAttribute("fence", "true");
    return middleNode;
};

groupTypes.accent = function(group, options) {
    var accentNode = new mathMLTree.MathNode(
        "mo", [makeText(group.value.accent, group.mode)]);

    var node = new mathMLTree.MathNode(
        "mover",
        [buildGroup(group.value.base, options),
            accentNode]);

    node.setAttribute("accent", "true");

    return node;
};

groupTypes.spacing = function(group) {
    var node;

    if (group.value === "\\ " || group.value === "\\space" ||
        group.value === " " || group.value === "~") {
        node = new mathMLTree.MathNode(
            "mtext", [new mathMLTree.TextNode("\u00a0")]);
    } else {
        node = new mathMLTree.MathNode("mspace");

        node.setAttribute(
            "width", buildCommon.spacingFunctions[group.value].size);
    }

    return node;
};

groupTypes.op = function(group, options) {
    var node;

    // TODO(emily): handle big operators using the `largeop` attribute

    if (group.value.symbol) {
        // This is a symbol. Just add the symbol.
        node = new mathMLTree.MathNode(
            "mo", [makeText(group.value.body, group.mode)]);
    } else if (group.value.value) {
        // This is an operator with children. Add them.
        node = new mathMLTree.MathNode(
            "mo", buildExpression(group.value.value, options));
    } else {
        // This is a text operator. Add all of the characters from the
        // operator's name.
        // TODO(emily): Add a space in the middle of some of these
        // operators, like \limsup.
        node = new mathMLTree.MathNode(
            "mi", [new mathMLTree.TextNode(group.value.body.slice(1))]);
    }

    return node;
};

groupTypes.mod = function(group, options) {
    var inner = [];

    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(new mathMLTree.MathNode(
            "mo", [makeText("(", group.mode)]));
    }
    if (group.value.modType !== "pod") {
        inner.push(new mathMLTree.MathNode(
            "mo", [makeText("mod", group.mode)]));
    }
    if (group.value.value) {
        var space = new mathMLTree.MathNode("mspace");
        space.setAttribute("width", "0.333333em");
        inner.push(space);
        inner = inner.concat(buildExpression(group.value.value, options));
    }
    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(new mathMLTree.MathNode(
            "mo", [makeText(")", group.mode)]));
    }

    return new mathMLTree.MathNode("mo", inner);
};

groupTypes.katex = function(group) {
    var node = new mathMLTree.MathNode(
        "mtext", [new mathMLTree.TextNode("KaTeX")]);

    return node;
};

groupTypes.font = function(group, options) {
    var font = group.value.font;
    return buildGroup(group.value.body, options.withFont(font));
};

groupTypes.delimsizing = function(group) {
    var children = [];

    if (group.value.value !== ".") {
        children.push(makeText(group.value.value, group.mode));
    }

    var node = new mathMLTree.MathNode("mo", children);

    if (group.value.mclass === "mopen" ||
        group.value.mclass === "mclose") {
        // Only some of the delimsizing functions act as fences, and they
        // return "mopen" or "mclose" mclass.
        node.setAttribute("fence", "true");
    } else {
        // Explicitly disable fencing if it's not a fence, to override the
        // defaults.
        node.setAttribute("fence", "false");
    }

    return node;
};

groupTypes.styling = function(group, options) {
    var inner = buildExpression(group.value.value, options);

    var node = new mathMLTree.MathNode("mstyle", inner);

    var styleAttributes = {
        "display": ["0", "true"],
        "text": ["0", "false"],
        "script": ["1", "false"],
        "scriptscript": ["2", "false"]
    };

    var attr = styleAttributes[group.value.style];

    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);

    return node;
};

groupTypes.sizing = function(group, options) {
    var inner = buildExpression(group.value.value, options);

    var node = new mathMLTree.MathNode("mstyle", inner);

    // TODO(emily): This doesn't produce the correct size for nested size
    // changes, because we don't keep state of what style we're currently
    // in, so we can't reset the size to normal before changing it.  Now
    // that we're passing an options parameter we should be able to fix
    // this.
    node.setAttribute(
        "mathsize", buildCommon.sizingMultiplier[group.value.size] + "em");

    return node;
};

groupTypes.overline = function(group, options) {
    var operator = new mathMLTree.MathNode(
        "mo", [new mathMLTree.TextNode("\u203e")]);
    operator.setAttribute("stretchy", "true");

    var node = new mathMLTree.MathNode(
        "mover",
        [buildGroup(group.value.body, options),
            operator]);
    node.setAttribute("accent", "true");

    return node;
};

groupTypes.underline = function(group, options) {
    var operator = new mathMLTree.MathNode(
        "mo", [new mathMLTree.TextNode("\u203e")]);
    operator.setAttribute("stretchy", "true");

    var node = new mathMLTree.MathNode(
        "munder",
        [buildGroup(group.value.body, options),
            operator]);
    node.setAttribute("accentunder", "true");

    return node;
};

groupTypes.rule = function(group) {
    // TODO(emily): Figure out if there's an actual way to draw black boxes
    // in MathML.
    var node = new mathMLTree.MathNode("mrow");

    return node;
};

groupTypes.kern = function(group) {
    // TODO(kevin): Figure out if there's a way to add space in MathML
    var node = new mathMLTree.MathNode("mrow");

    return node;
};

groupTypes.llap = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mpadded", [buildGroup(group.value.body, options)]);

    node.setAttribute("lspace", "-1width");
    node.setAttribute("width", "0px");

    return node;
};

groupTypes.rlap = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mpadded", [buildGroup(group.value.body, options)]);

    node.setAttribute("width", "0px");

    return node;
};

groupTypes.phantom = function(group, options) {
    var inner = buildExpression(group.value.value, options);
    return new mathMLTree.MathNode("mphantom", inner);
};

groupTypes.mclass = function(group, options) {
    var inner = buildExpression(group.value.value, options);
    return new mathMLTree.MathNode("mstyle", inner);
};

/**
 * Takes a list of nodes, builds them, and returns a list of the generated
 * MathML nodes. A little simpler than the HTML version because we don't do any
 * previous-node handling.
 */
var buildExpression = function(expression, options) {
    var groups = [];
    for (var i = 0; i < expression.length; i++) {
        var group = expression[i];
        groups.push(buildGroup(group, options));
    }
    return groups;
};

/**
 * Takes a group from the parser and calls the appropriate groupTypes function
 * on it to produce a MathML node.
 */
var buildGroup = function(group, options) {
    if (!group) {
        return new mathMLTree.MathNode("mrow");
    }

    if (groupTypes[group.type]) {
        // Call the groupTypes function
        return groupTypes[group.type](group, options);
    } else {
        throw new ParseError(
            "Got group of unknown type: '" + group.type + "'");
    }
};

/**
 * Takes a full parse tree and settings and builds a MathML representation of
 * it. In particular, we put the elements from building the parse tree into a
 * <semantics> tag so we can also include that TeX source as an annotation.
 *
 * Note that we actually return a domTree element with a `<math>` inside it so
 * we can do appropriate styling.
 */
var buildMathML = function(tree, texExpression, options) {
    var expression = buildExpression(tree, options);

    // Wrap up the expression in an mrow so it is presented in the semantics
    // tag correctly.
    var wrapper = new mathMLTree.MathNode("mrow", expression);

    // Build a TeX annotation of the source
    var annotation = new mathMLTree.MathNode(
        "annotation", [new mathMLTree.TextNode(texExpression)]);

    annotation.setAttribute("encoding", "application/x-tex");

    var semantics = new mathMLTree.MathNode(
        "semantics", [wrapper, annotation]);

    var math = new mathMLTree.MathNode("math", [semantics]);

    // You can't style <math> nodes, so we wrap the node in a span.
    return makeSpan(["katex-mathml"], [math]);
};

module.exports = buildMathML;

},{"./ParseError":81,"./buildCommon":85,"./fontMetrics":92,"./mathMLTree":95,"./symbols":98,"./utils":100}],88:[function(require,module,exports){
var buildHTML = require("./buildHTML");
var buildMathML = require("./buildMathML");
var buildCommon = require("./buildCommon");
var Options = require("./Options");
var Settings = require("./Settings");
var Style = require("./Style");

var makeSpan = buildCommon.makeSpan;

var buildTree = function(tree, expression, settings) {
    settings = settings || new Settings({});

    var startStyle = Style.TEXT;
    if (settings.displayMode) {
        startStyle = Style.DISPLAY;
    }

    // Setup the default options
    var options = new Options({
        style: startStyle,
        size: "size5"
    });

    // `buildHTML` sometimes messes with the parse tree (like turning bins ->
    // ords), so we build the MathML version first.
    var mathMLNode = buildMathML(tree, expression, options);
    var htmlNode = buildHTML(tree, options);

    var katexNode = makeSpan(["katex"], [
        mathMLNode, htmlNode
    ]);

    if (settings.displayMode) {
        return makeSpan(["katex-display"], [katexNode]);
    } else {
        return katexNode;
    }
};

module.exports = buildTree;

},{"./Options":80,"./Settings":83,"./Style":84,"./buildCommon":85,"./buildHTML":86,"./buildMathML":87}],89:[function(require,module,exports){
/**
 * This file deals with creating delimiters of various sizes. The TeXbook
 * discusses these routines on page 441-442, in the "Another subroutine sets box
 * x to a specified variable delimiter" paragraph.
 *
 * There are three main routines here. `makeSmallDelim` makes a delimiter in the
 * normal font, but in either text, script, or scriptscript style.
 * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
 * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
 * smaller pieces that are stacked on top of one another.
 *
 * The functions take a parameter `center`, which determines if the delimiter
 * should be centered around the axis.
 *
 * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
 * one of the given sizes. This is used for things like `\bigl`.
 * `customSizedDelim` makes a delimiter with a given total height+depth. It is
 * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
 * delimiter which surrounds an expression of a given height an depth. It is
 * used in `\left` and `\right`.
 */

var ParseError = require("./ParseError");
var Style = require("./Style");

var buildCommon = require("./buildCommon");
var fontMetrics = require("./fontMetrics");
var symbols = require("./symbols");
var utils = require("./utils");

var makeSpan = buildCommon.makeSpan;

/**
 * Get the metrics for a given symbol and font, after transformation (i.e.
 * after following replacement from symbols.js)
 */
var getMetrics = function(symbol, font) {
    if (symbols.math[symbol] && symbols.math[symbol].replace) {
        return fontMetrics.getCharacterMetrics(
            symbols.math[symbol].replace, font);
    } else {
        return fontMetrics.getCharacterMetrics(
            symbol, font);
    }
};

/**
 * Builds a symbol in the given font size (note size is an integer)
 */
var mathrmSize = function(value, size, mode, options) {
    return buildCommon.makeSymbol(value, "Size" + size + "-Regular",
        mode, options);
};

/**
 * Puts a delimiter span in a given style, and adds appropriate height, depth,
 * and maxFontSizes.
 */
var styleWrap = function(delim, toStyle, options, classes) {
    classes = classes || [];
    var span = makeSpan(
        classes.concat(["style-wrap", options.style.reset(), toStyle.cls()]),
        [delim], options);

    var multiplier = toStyle.sizeMultiplier / options.style.sizeMultiplier;

    span.height *= multiplier;
    span.depth *= multiplier;
    span.maxFontSize = toStyle.sizeMultiplier;

    return span;
};

/**
 * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
 * font, but is restyled to either be in textstyle, scriptstyle, or
 * scriptscriptstyle.
 */
var makeSmallDelim = function(delim, style, center, options, mode, classes) {
    var text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);

    var span = styleWrap(text, style, options, classes);

    if (center) {
        var shift =
            (1 - options.style.sizeMultiplier / style.sizeMultiplier) *
            options.style.metrics.axisHeight;

        span.style.top = shift + "em";
        span.height -= shift;
        span.depth += shift;
    }

    return span;
};

/**
 * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
 * Size3, or Size4 fonts. It is always rendered in textstyle.
 */
var makeLargeDelim = function(delim, size, center, options, mode, classes) {
    var inner = mathrmSize(delim, size, mode, options);

    var span = styleWrap(
        makeSpan(["delimsizing", "size" + size], [inner], options),
        Style.TEXT, options, classes);

    if (center) {
        var shift = (1 - options.style.sizeMultiplier) *
            options.style.metrics.axisHeight;

        span.style.top = shift + "em";
        span.height -= shift;
        span.depth += shift;
    }

    return span;
};

/**
 * Make an inner span with the given offset and in the given font. This is used
 * in `makeStackedDelim` to make the stacking pieces for the delimiter.
 */
var makeInner = function(symbol, font, mode) {
    var sizeClass;
    // Apply the correct CSS class to choose the right font.
    if (font === "Size1-Regular") {
        sizeClass = "delim-size1";
    } else if (font === "Size4-Regular") {
        sizeClass = "delim-size4";
    }

    var inner = makeSpan(
        ["delimsizinginner", sizeClass],
        [makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);

    // Since this will be passed into `makeVList` in the end, wrap the element
    // in the appropriate tag that VList uses.
    return {type: "elem", elem: inner};
};

/**
 * Make a stacked delimiter out of a given delimiter, with the total height at
 * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
 */
var makeStackedDelim = function(delim, heightTotal, center, options, mode,
                                classes) {
    // There are four parts, the top, an optional middle, a repeated part, and a
    // bottom.
    var top;
    var middle;
    var repeat;
    var bottom;
    top = repeat = bottom = delim;
    middle = null;
    // Also keep track of what font the delimiters are in
    var font = "Size1-Regular";

    // We set the parts and font based on the symbol. Note that we use
    // '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
    // repeats of the arrows
    if (delim === "\\uparrow") {
        repeat = bottom = "\u23d0";
    } else if (delim === "\\Uparrow") {
        repeat = bottom = "\u2016";
    } else if (delim === "\\downarrow") {
        top = repeat = "\u23d0";
    } else if (delim === "\\Downarrow") {
        top = repeat = "\u2016";
    } else if (delim === "\\updownarrow") {
        top = "\\uparrow";
        repeat = "\u23d0";
        bottom = "\\downarrow";
    } else if (delim === "\\Updownarrow") {
        top = "\\Uparrow";
        repeat = "\u2016";
        bottom = "\\Downarrow";
    } else if (delim === "[" || delim === "\\lbrack") {
        top = "\u23a1";
        repeat = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
    } else if (delim === "]" || delim === "\\rbrack") {
        top = "\u23a4";
        repeat = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
    } else if (delim === "\\lfloor") {
        repeat = top = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
    } else if (delim === "\\lceil") {
        top = "\u23a1";
        repeat = bottom = "\u23a2";
        font = "Size4-Regular";
    } else if (delim === "\\rfloor") {
        repeat = top = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
    } else if (delim === "\\rceil") {
        top = "\u23a4";
        repeat = bottom = "\u23a5";
        font = "Size4-Regular";
    } else if (delim === "(") {
        top = "\u239b";
        repeat = "\u239c";
        bottom = "\u239d";
        font = "Size4-Regular";
    } else if (delim === ")") {
        top = "\u239e";
        repeat = "\u239f";
        bottom = "\u23a0";
        font = "Size4-Regular";
    } else if (delim === "\\{" || delim === "\\lbrace") {
        top = "\u23a7";
        middle = "\u23a8";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\}" || delim === "\\rbrace") {
        top = "\u23ab";
        middle = "\u23ac";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\lgroup") {
        top = "\u23a7";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\rgroup") {
        top = "\u23ab";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\lmoustache") {
        top = "\u23a7";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\rmoustache") {
        top = "\u23ab";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\surd") {
        top = "\ue001";
        bottom = "\u23b7";
        repeat = "\ue000";
        font = "Size4-Regular";
    }

    // Get the metrics of the four sections
    var topMetrics = getMetrics(top, font);
    var topHeightTotal = topMetrics.height + topMetrics.depth;
    var repeatMetrics = getMetrics(repeat, font);
    var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
    var bottomMetrics = getMetrics(bottom, font);
    var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
    var middleHeightTotal = 0;
    var middleFactor = 1;
    if (middle !== null) {
        var middleMetrics = getMetrics(middle, font);
        middleHeightTotal = middleMetrics.height + middleMetrics.depth;
        middleFactor = 2; // repeat symmetrically above and below middle
    }

    // Calcuate the minimal height that the delimiter can have.
    // It is at least the size of the top, bottom, and optional middle combined.
    var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;

    // Compute the number of copies of the repeat symbol we will need
    var repeatCount = Math.ceil(
        (heightTotal - minHeight) / (middleFactor * repeatHeightTotal));

    // Compute the total height of the delimiter including all the symbols
    var realHeightTotal =
        minHeight + repeatCount * middleFactor * repeatHeightTotal;

    // The center of the delimiter is placed at the center of the axis. Note
    // that in this context, "center" means that the delimiter should be
    // centered around the axis in the current style, while normally it is
    // centered around the axis in textstyle.
    var axisHeight = options.style.metrics.axisHeight;
    if (center) {
        axisHeight *= options.style.sizeMultiplier;
    }
    // Calculate the depth
    var depth = realHeightTotal / 2 - axisHeight;

    // Now, we start building the pieces that will go into the vlist

    // Keep a list of the inner pieces
    var inners = [];

    // Add the bottom symbol
    inners.push(makeInner(bottom, font, mode));

    var i;
    if (middle === null) {
        // Add that many symbols
        for (i = 0; i < repeatCount; i++) {
            inners.push(makeInner(repeat, font, mode));
        }
    } else {
        // When there is a middle bit, we need the middle part and two repeated
        // sections
        for (i = 0; i < repeatCount; i++) {
            inners.push(makeInner(repeat, font, mode));
        }
        inners.push(makeInner(middle, font, mode));
        for (i = 0; i < repeatCount; i++) {
            inners.push(makeInner(repeat, font, mode));
        }
    }

    // Add the top symbol
    inners.push(makeInner(top, font, mode));

    // Finally, build the vlist
    var inner = buildCommon.makeVList(inners, "bottom", depth, options);

    return styleWrap(
        makeSpan(["delimsizing", "mult"], [inner], options),
        Style.TEXT, options, classes);
};

// There are three kinds of delimiters, delimiters that stack when they become
// too large
var stackLargeDelimiters = [
    "(", ")", "[", "\\lbrack", "]", "\\rbrack",
    "\\{", "\\lbrace", "\\}", "\\rbrace",
    "\\lfloor", "\\rfloor", "\\lceil", "\\rceil",
    "\\surd"
];

// delimiters that always stack
var stackAlwaysDelimiters = [
    "\\uparrow", "\\downarrow", "\\updownarrow",
    "\\Uparrow", "\\Downarrow", "\\Updownarrow",
    "|", "\\|", "\\vert", "\\Vert",
    "\\lvert", "\\rvert", "\\lVert", "\\rVert",
    "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache"
];

// and delimiters that never stack
var stackNeverDelimiters = [
    "<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"
];

// Metrics of the different sizes. Found by looking at TeX's output of
// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.
var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];

/**
 * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
 */
var makeSizedDelim = function(delim, size, options, mode, classes) {
    // < and > turn into \langle and \rangle in delimiters
    if (delim === "<" || delim === "\\lt") {
        delim = "\\langle";
    } else if (delim === ">" || delim === "\\gt") {
        delim = "\\rangle";
    }

    // Sized delimiters are never centered.
    if (utils.contains(stackLargeDelimiters, delim) ||
        utils.contains(stackNeverDelimiters, delim)) {
        return makeLargeDelim(delim, size, false, options, mode, classes);
    } else if (utils.contains(stackAlwaysDelimiters, delim)) {
        return makeStackedDelim(
            delim, sizeToMaxHeight[size], false, options, mode, classes);
    } else {
        throw new ParseError("Illegal delimiter: '" + delim + "'");
    }
};

/**
 * There are three different sequences of delimiter sizes that the delimiters
 * follow depending on the kind of delimiter. This is used when creating custom
 * sized delimiters to decide whether to create a small, large, or stacked
 * delimiter.
 *
 * In real TeX, these sequences aren't explicitly defined, but are instead
 * defined inside the font metrics. Since there are only three sequences that
 * are possible for the delimiters that TeX defines, it is easier to just encode
 * them explicitly here.
 */

// Delimiters that never stack try small delimiters and large delimiters only
var stackNeverDelimiterSequence = [
    {type: "small", style: Style.SCRIPTSCRIPT},
    {type: "small", style: Style.SCRIPT},
    {type: "small", style: Style.TEXT},
    {type: "large", size: 1},
    {type: "large", size: 2},
    {type: "large", size: 3},
    {type: "large", size: 4}
];

// Delimiters that always stack try the small delimiters first, then stack
var stackAlwaysDelimiterSequence = [
    {type: "small", style: Style.SCRIPTSCRIPT},
    {type: "small", style: Style.SCRIPT},
    {type: "small", style: Style.TEXT},
    {type: "stack"}
];

// Delimiters that stack when large try the small and then large delimiters, and
// stack afterwards
var stackLargeDelimiterSequence = [
    {type: "small", style: Style.SCRIPTSCRIPT},
    {type: "small", style: Style.SCRIPT},
    {type: "small", style: Style.TEXT},
    {type: "large", size: 1},
    {type: "large", size: 2},
    {type: "large", size: 3},
    {type: "large", size: 4},
    {type: "stack"}
];

/**
 * Get the font used in a delimiter based on what kind of delimiter it is.
 */
var delimTypeToFont = function(type) {
    if (type.type === "small") {
        return "Main-Regular";
    } else if (type.type === "large") {
        return "Size" + type.size + "-Regular";
    } else if (type.type === "stack") {
        return "Size4-Regular";
    }
};

/**
 * Traverse a sequence of types of delimiters to decide what kind of delimiter
 * should be used to create a delimiter of the given height+depth.
 */
var traverseSequence = function(delim, height, sequence, options) {
    // Here, we choose the index we should start at in the sequences. In smaller
    // sizes (which correspond to larger numbers in style.size) we start earlier
    // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
    // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
    var start = Math.min(2, 3 - options.style.size);
    for (var i = start; i < sequence.length; i++) {
        if (sequence[i].type === "stack") {
            // This is always the last delimiter, so we just break the loop now.
            break;
        }

        var metrics = getMetrics(delim, delimTypeToFont(sequence[i]));
        var heightDepth = metrics.height + metrics.depth;

        // Small delimiters are scaled down versions of the same font, so we
        // account for the style change size.

        if (sequence[i].type === "small") {
            heightDepth *= sequence[i].style.sizeMultiplier;
        }

        // Check if the delimiter at this size works for the given height.
        if (heightDepth > height) {
            return sequence[i];
        }
    }

    // If we reached the end of the sequence, return the last sequence element.
    return sequence[sequence.length - 1];
};

/**
 * Make a delimiter of a given height+depth, with optional centering. Here, we
 * traverse the sequences, and create a delimiter that the sequence tells us to.
 */
var makeCustomSizedDelim = function(delim, height, center, options, mode,
                                    classes) {
    if (delim === "<" || delim === "\\lt") {
        delim = "\\langle";
    } else if (delim === ">" || delim === "\\gt") {
        delim = "\\rangle";
    }

    // Decide what sequence to use
    var sequence;
    if (utils.contains(stackNeverDelimiters, delim)) {
        sequence = stackNeverDelimiterSequence;
    } else if (utils.contains(stackLargeDelimiters, delim)) {
        sequence = stackLargeDelimiterSequence;
    } else {
        sequence = stackAlwaysDelimiterSequence;
    }

    // Look through the sequence
    var delimType = traverseSequence(delim, height, sequence, options);

    // Depending on the sequence element we decided on, call the appropriate
    // function.
    if (delimType.type === "small") {
        return makeSmallDelim(delim, delimType.style, center, options, mode,
                              classes);
    } else if (delimType.type === "large") {
        return makeLargeDelim(delim, delimType.size, center, options, mode,
                              classes);
    } else if (delimType.type === "stack") {
        return makeStackedDelim(delim, height, center, options, mode, classes);
    }
};

/**
 * Make a delimiter for use with `\left` and `\right`, given a height and depth
 * of an expression that the delimiters surround.
 */
var makeLeftRightDelim = function(delim, height, depth, options, mode,
                                  classes) {
    // We always center \left/\right delimiters, so the axis is always shifted
    var axisHeight =
        options.style.metrics.axisHeight * options.style.sizeMultiplier;

    // Taken from TeX source, tex.web, function make_left_right
    var delimiterFactor = 901;
    var delimiterExtend = 5.0 / fontMetrics.metrics.ptPerEm;

    var maxDistFromAxis = Math.max(
        height - axisHeight, depth + axisHeight);

    var totalHeight = Math.max(
        // In real TeX, calculations are done using integral values which are
        // 65536 per pt, or 655360 per em. So, the division here truncates in
        // TeX but doesn't here, producing different results. If we wanted to
        // exactly match TeX's calculation, we could do
        //   Math.floor(655360 * maxDistFromAxis / 500) *
        //    delimiterFactor / 655360
        // (To see the difference, compare
        //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
        // in TeX and KaTeX)
        maxDistFromAxis / 500 * delimiterFactor,
        2 * maxDistFromAxis - delimiterExtend);

    // Finally, we defer to `makeCustomSizedDelim` with our calculated total
    // height
    return makeCustomSizedDelim(delim, totalHeight, true, options, mode,
                                classes);
};

module.exports = {
    sizedDelim: makeSizedDelim,
    customSizedDelim: makeCustomSizedDelim,
    leftRightDelim: makeLeftRightDelim
};

},{"./ParseError":81,"./Style":84,"./buildCommon":85,"./fontMetrics":92,"./symbols":98,"./utils":100}],90:[function(require,module,exports){
/**
 * These objects store the data about the DOM nodes we create, as well as some
 * extra data. They can then be transformed into real DOM nodes with the
 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
 * storing extra properties on the nodes, as well as providing a way to easily
 * work with the DOM.
 *
 * Similar functions for working with MathML nodes exist in mathMLTree.js.
 */
var unicodeRegexes = require("./unicodeRegexes");
var utils = require("./utils");

/**
 * Create an HTML className based on a list of classes. In addition to joining
 * with spaces, we also remove null or empty classes.
 */
var createClass = function(classes) {
    classes = classes.slice();
    for (var i = classes.length - 1; i >= 0; i--) {
        if (!classes[i]) {
            classes.splice(i, 1);
        }
    }

    return classes.join(" ");
};

/**
 * This node represents a span node, with a className, a list of children, and
 * an inline style. It also contains information about its height, depth, and
 * maxFontSize.
 */
function span(classes, children, options) {
    this.classes = classes || [];
    this.children = children || [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
    this.attributes = {};
    if (options) {
        if (options.style.isTight()) {
            this.classes.push("mtight");
        }
        if (options.getColor()) {
            this.style.color = options.getColor();
        }
    }
}

/**
 * Sets an arbitrary attribute on the span. Warning: use this wisely. Not all
 * browsers support attributes the same, and having too many custom attributes
 * is probably bad.
 */
span.prototype.setAttribute = function(attribute, value) {
    this.attributes[attribute] = value;
};

span.prototype.tryCombine = function(sibling) {
    return false;
};

/**
 * Convert the span into an HTML node
 */
span.prototype.toNode = function() {
    var span = document.createElement("span");

    // Apply the class
    span.className = createClass(this.classes);

    // Apply inline styles
    for (var style in this.style) {
        if (Object.prototype.hasOwnProperty.call(this.style, style)) {
            span.style[style] = this.style[style];
        }
    }

    // Apply attributes
    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            span.setAttribute(attr, this.attributes[attr]);
        }
    }

    // Append the children, also as HTML nodes
    for (var i = 0; i < this.children.length; i++) {
        span.appendChild(this.children[i].toNode());
    }

    return span;
};

/**
 * Convert the span into an HTML markup string
 */
span.prototype.toMarkup = function() {
    var markup = "<span";

    // Add the class
    if (this.classes.length) {
        markup += " class=\"";
        markup += utils.escape(createClass(this.classes));
        markup += "\"";
    }

    var styles = "";

    // Add the styles, after hyphenation
    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
    }

    if (styles) {
        markup += " style=\"" + utils.escape(styles) + "\"";
    }

    // Add the attributes
    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "=\"";
            markup += utils.escape(this.attributes[attr]);
            markup += "\"";
        }
    }

    markup += ">";

    // Add the markup of the children, also as markup
    for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
    }

    markup += "</span>";

    return markup;
};

/**
 * This node represents a document fragment, which contains elements, but when
 * placed into the DOM doesn't have any representation itself. Thus, it only
 * contains children and doesn't have any HTML properties. It also keeps track
 * of a height, depth, and maxFontSize.
 */
function documentFragment(children) {
    this.children = children || [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
}

/**
 * Convert the fragment into a node
 */
documentFragment.prototype.toNode = function() {
    // Create a fragment
    var frag = document.createDocumentFragment();

    // Append the children
    for (var i = 0; i < this.children.length; i++) {
        frag.appendChild(this.children[i].toNode());
    }

    return frag;
};

/**
 * Convert the fragment into HTML markup
 */
documentFragment.prototype.toMarkup = function() {
    var markup = "";

    // Simply concatenate the markup for the children together
    for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
    }

    return markup;
};

var iCombinations = {
    '': '\u0131\u0302',
    '': '\u0131\u0308',
    '': '\u0131\u0301',
    // '': '\u0131\u0304', // enable when we add Extended Latin
    '': '\u0131\u0300'
};

/**
 * A symbol node contains information about a single symbol. It either renders
 * to a single text node, or a span with a single text node in it, depending on
 * whether it has CSS classes, styles, or needs italic correction.
 */
function symbolNode(value, height, depth, italic, skew, classes, style) {
    this.value = value || "";
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.classes = classes || [];
    this.style = style || {};
    this.maxFontSize = 0;

    // Mark CJK characters with specific classes so that we can specify which
    // fonts to use.  This allows us to render these characters with a serif
    // font in situations where the browser would either default to a sans serif
    // or render a placeholder character.
    if (unicodeRegexes.cjkRegex.test(value)) {
        // I couldn't find any fonts that contained Hangul as well as all of
        // the other characters we wanted to test there for it gets its own
        // CSS class.
        if (unicodeRegexes.hangulRegex.test(value)) {
            this.classes.push('hangul_fallback');
        } else {
            this.classes.push('cjk_fallback');
        }
    }

    if (/[]/.test(this.value)) {    // add  when we add Extended Latin
        this.value = iCombinations[this.value];
    }
}

symbolNode.prototype.tryCombine = function(sibling) {
    if (!sibling
        || !(sibling instanceof symbolNode)
        || this.italic > 0
        || createClass(this.classes) !== createClass(sibling.classes)
        || this.skew !== sibling.skew
        || this.maxFontSize !== sibling.maxFontSize) {
        return false;
    }
    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)
            && this.style[style] !== sibling.style[style]) {
            return false;
        }
    }
    for (style in sibling.style) {
        if (sibling.style.hasOwnProperty(style)
            && this.style[style] !== sibling.style[style]) {
            return false;
        }
    }
    this.value += sibling.value;
    this.height = Math.max(this.height, sibling.height);
    this.depth = Math.max(this.depth, sibling.depth);
    this.italic = sibling.italic;
    return true;
};

/**
 * Creates a text node or span from a symbol node. Note that a span is only
 * created if it is needed.
 */
symbolNode.prototype.toNode = function() {
    var node = document.createTextNode(this.value);
    var span = null;

    if (this.italic > 0) {
        span = document.createElement("span");
        span.style.marginRight = this.italic + "em";
    }

    if (this.classes.length > 0) {
        span = span || document.createElement("span");
        span.className = createClass(this.classes);
    }

    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
            span = span || document.createElement("span");
            span.style[style] = this.style[style];
        }
    }

    if (span) {
        span.appendChild(node);
        return span;
    } else {
        return node;
    }
};

/**
 * Creates markup for a symbol node.
 */
symbolNode.prototype.toMarkup = function() {
    // TODO(alpert): More duplication than I'd like from
    // span.prototype.toMarkup and symbolNode.prototype.toNode...
    var needsSpan = false;

    var markup = "<span";

    if (this.classes.length) {
        needsSpan = true;
        markup += " class=\"";
        markup += utils.escape(createClass(this.classes));
        markup += "\"";
    }

    var styles = "";

    if (this.italic > 0) {
        styles += "margin-right:" + this.italic + "em;";
    }
    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
    }

    if (styles) {
        needsSpan = true;
        markup += " style=\"" + utils.escape(styles) + "\"";
    }

    var escaped = utils.escape(this.value);
    if (needsSpan) {
        markup += ">";
        markup += escaped;
        markup += "</span>";
        return markup;
    } else {
        return escaped;
    }
};

module.exports = {
    span: span,
    documentFragment: documentFragment,
    symbolNode: symbolNode
};

},{"./unicodeRegexes":99,"./utils":100}],91:[function(require,module,exports){
/* eslint no-constant-condition:0 */
var parseData = require("./parseData");
var ParseError = require("./ParseError");
var Style = require("./Style");

var ParseNode = parseData.ParseNode;

/**
 * Parse the body of the environment, with rows delimited by \\ and
 * columns delimited by &, and create a nested list in row-major order
 * with one group per cell.
 */
function parseArray(parser, result) {
    var row = [];
    var body = [row];
    var rowGaps = [];
    while (true) {
        var cell = parser.parseExpression(false, null);
        row.push(new ParseNode("ordgroup", cell, parser.mode));
        var next = parser.nextToken.text;
        if (next === "&") {
            parser.consume();
        } else if (next === "\\end") {
            break;
        } else if (next === "\\\\" || next === "\\cr") {
            var cr = parser.parseFunction();
            rowGaps.push(cr.value.size);
            row = [];
            body.push(row);
        } else {
            throw new ParseError("Expected & or \\\\ or \\end",
                                 parser.nextToken);
        }
    }
    result.body = body;
    result.rowGaps = rowGaps;
    return new ParseNode(result.type, result, parser.mode);
}

/*
 * An environment definition is very similar to a function definition:
 * it is declared with a name or a list of names, a set of properties
 * and a handler containing the actual implementation.
 *
 * The properties include:
 *  - numArgs: The number of arguments after the \begin{name} function.
 *  - argTypes: (optional) Just like for a function
 *  - allowedInText: (optional) Whether or not the environment is allowed inside
 *                   text mode (default false) (not enforced yet)
 *  - numOptionalArgs: (optional) Just like for a function
 * A bare number instead of that object indicates the numArgs value.
 *
 * The handler function will receive two arguments
 *  - context: information and references provided by the parser
 *  - args: an array of arguments passed to \begin{name}
 * The context contains the following properties:
 *  - envName: the name of the environment, one of the listed names.
 *  - parser: the parser object
 *  - lexer: the lexer object
 *  - positions: the positions associated with these arguments from args.
 * The handler must return a ParseResult.
 */

function defineEnvironment(names, props, handler) {
    if (typeof names === "string") {
        names = [names];
    }
    if (typeof props === "number") {
        props = { numArgs: props };
    }
    // Set default values of environments
    var data = {
        numArgs: props.numArgs || 0,
        argTypes: props.argTypes,
        greediness: 1,
        allowedInText: !!props.allowedInText,
        numOptionalArgs: props.numOptionalArgs || 0,
        handler: handler
    };
    for (var i = 0; i < names.length; ++i) {
        module.exports[names[i]] = data;
    }
}

// Arrays are part of LaTeX, defined in lttab.dtx so its documentation
// is part of the source2e.pdf file of LaTeX2e source documentation.
defineEnvironment("array", {
    numArgs: 1
}, function(context, args) {
    var colalign = args[0];
    colalign = colalign.value.map ? colalign.value : [colalign];
    var cols = colalign.map(function(node) {
        var ca = node.value;
        if ("lcr".indexOf(ca) !== -1) {
            return {
                type: "align",
                align: ca
            };
        } else if (ca === "|") {
            return {
                type: "separator",
                separator: "|"
            };
        }
        throw new ParseError(
            "Unknown column alignment: " + node.value,
            node);
    });
    var res = {
        type: "array",
        cols: cols,
        hskipBeforeAndAfter: true // \@preamble in lttab.dtx
    };
    res = parseArray(context.parser, res);
    return res;
});

// The matrix environments of amsmath builds on the array environment
// of LaTeX, which is discussed above.
defineEnvironment([
    "matrix",
    "pmatrix",
    "bmatrix",
    "Bmatrix",
    "vmatrix",
    "Vmatrix"
], {
}, function(context) {
    var delimiters = {
        "matrix": null,
        "pmatrix": ["(", ")"],
        "bmatrix": ["[", "]"],
        "Bmatrix": ["\\{", "\\}"],
        "vmatrix": ["|", "|"],
        "Vmatrix": ["\\Vert", "\\Vert"]
    }[context.envName];
    var res = {
        type: "array",
        hskipBeforeAndAfter: false // \hskip -\arraycolsep in amsmath
    };
    res = parseArray(context.parser, res);
    if (delimiters) {
        res = new ParseNode("leftright", {
            body: [res],
            left: delimiters[0],
            right: delimiters[1]
        }, context.mode);
    }
    return res;
});

// A cases environment (in amsmath.sty) is almost equivalent to
// \def\arraystretch{1.2}%
// \left\{\begin{array}{@{}l@{\quad}l@{}}  \end{array}\right.
defineEnvironment("cases", {
}, function(context) {
    var res = {
        type: "array",
        arraystretch: 1.2,
        cols: [{
            type: "align",
            align: "l",
            pregap: 0,
            // TODO(kevinb) get the current style.
            // For now we use the metrics for TEXT style which is what we were
            // doing before.  Before attempting to get the current style we
            // should look at TeX's behavior especially for \over and matrices.
            postgap: Style.TEXT.metrics.quad
        }, {
            type: "align",
            align: "l",
            pregap: 0,
            postgap: 0
        }]
    };
    res = parseArray(context.parser, res);
    res = new ParseNode("leftright", {
        body: [res],
        left: "\\{",
        right: "."
    }, context.mode);
    return res;
});

// An aligned environment is like the align* environment
// except it operates within math mode.
// Note that we assume \nomallineskiplimit to be zero,
// so that \strut@ is the same as \strut.
defineEnvironment("aligned", {
}, function(context) {
    var res = {
        type: "array",
        cols: []
    };
    res = parseArray(context.parser, res);
    var emptyGroup = new ParseNode("ordgroup", [], context.mode);
    var numCols = 0;
    res.value.body.forEach(function(row) {
        var i;
        for (i = 1; i < row.length; i += 2) {
            row[i].value.unshift(emptyGroup);
        }
        if (numCols < row.length) {
            numCols = row.length;
        }
    });
    for (var i = 0; i < numCols; ++i) {
        var align = "r";
        var pregap = 0;
        if (i % 2 === 1) {
            align = "l";
        } else if (i > 0) {
            pregap = 2; // one \qquad between columns
        }
        res.value.cols[i] = {
            type: "align",
            align: align,
            pregap: pregap,
            postgap: 0
        };
    }
    return res;
});

},{"./ParseError":81,"./Style":84,"./parseData":96}],92:[function(require,module,exports){
/* eslint no-unused-vars:0 */

var Style = require("./Style");
var cjkRegex = require("./unicodeRegexes").cjkRegex;

/**
 * This file contains metrics regarding fonts and individual symbols. The sigma
 * and xi variables, as well as the metricMap map contain data extracted from
 * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
 * `metrics` variable and the getCharacterMetrics function.
 */

// In TeX, there are actually three sets of dimensions, one for each of
// textstyle, scriptstyle, and scriptscriptstyle.  These are provided in the
// the arrays below, in that order.
//
// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respsectively.
// This was determined by running the folllowing script:
//
//     latex -interaction=nonstopmode \
//     '\documentclass{article}\usepackage{amsmath}\begin{document}' \
//     '$a$ \expandafter\show\the\textfont2' \
//     '\expandafter\show\the\scriptfont2' \
//     '\expandafter\show\the\scriptscriptfont2' \
//     '\stop'
//
// The metrics themselves were retreived using the following commands:
//
//     tftopl cmsy10
//     tftopl cmsy7
//     tftopl cmsy5
//
// The output of each of these commands is quite lengthy.  The only part we
// care about is the FONTDIMEN section. Each value is measured in EMs.
var sigmas = {
    slant: [0.250, 0.250, 0.250],       // sigma1
    space: [0.000, 0.000, 0.000],       // sigma2
    stretch: [0.000, 0.000, 0.000],     // sigma3
    shrink: [0.000, 0.000, 0.000],      // sigma4
    xHeight: [0.431, 0.431, 0.431],     // sigma5
    quad: [1.000, 1.171, 1.472],        // sigma6
    extraSpace: [0.000, 0.000, 0.000],  // sigma7
    num1: [0.677, 0.732, 0.925],        // sigma8
    num2: [0.394, 0.384, 0.387],        // sigma9
    num3: [0.444, 0.471, 0.504],        // sigma10
    denom1: [0.686, 0.752, 1.025],      // sigma11
    denom2: [0.345, 0.344, 0.532],      // sigma12
    sup1: [0.413, 0.503, 0.504],        // sigma13
    sup2: [0.363, 0.431, 0.404],        // sigma14
    sup3: [0.289, 0.286, 0.294],        // sigma15
    sub1: [0.150, 0.143, 0.200],        // sigma16
    sub2: [0.247, 0.286, 0.400],        // sigma17
    supDrop: [0.386, 0.353, 0.494],     // sigma18
    subDrop: [0.050, 0.071, 0.100],     // sigma19
    delim1: [2.390, 1.700, 1.980],      // sigma20
    delim2: [1.010, 1.157, 1.420],      // sigma21
    axisHeight: [0.250, 0.250, 0.250]  // sigma22
};

// These font metrics are extracted from TeX by using
// \font\a=cmex10
// \showthe\fontdimenX\a
// where X is the corresponding variable number. These correspond to the font
// parameters of the extension fonts (family 3). See the TeXbook, page 441.
var xi1 = 0;
var xi2 = 0;
var xi3 = 0;
var xi4 = 0;
var xi5 = 0.431;
var xi6 = 1;
var xi7 = 0;
var xi8 = 0.04;
var xi9 = 0.111;
var xi10 = 0.166;
var xi11 = 0.2;
var xi12 = 0.6;
var xi13 = 0.1;

// This value determines how large a pt is, for metrics which are defined in
// terms of pts.
// This value is also used in katex.less; if you change it make sure the values
// match.
var ptPerEm = 10.0;

// The space between adjacent `|` columns in an array definition. From
// `\showthe\doublerulesep` in LaTeX.
var doubleRuleSep = 2.0 / ptPerEm;

/**
 * This is just a mapping from common names to real metrics
 */
var metrics = {
    defaultRuleThickness: xi8,
    bigOpSpacing1: xi9,
    bigOpSpacing2: xi10,
    bigOpSpacing3: xi11,
    bigOpSpacing4: xi12,
    bigOpSpacing5: xi13,
    ptPerEm: ptPerEm,
    doubleRuleSep: doubleRuleSep
};

// This map contains a mapping from font name and character code to character
// metrics, including height, depth, italic correction, and skew (kern from the
// character to the corresponding \skewchar)
// This map is generated via `make metrics`. It should not be changed manually.
var metricMap = require("./fontMetricsData");

// These are very rough approximations.  We default to Times New Roman which
// should have Latin-1 and Cyrillic characters, but may not depending on the
// operating system.  The metrics do not account for extra height from the
// accents.  In the case of Cyrillic characters which have both ascenders and
// descenders we prefer approximations with ascenders, primarily to prevent
// the fraction bar or root line from intersecting the glyph.
// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.
var extraCharacterMap = {
    // Latin-1
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'C',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'D',
    '': 'N',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'Y',
    '': 'o',
    '': 'B',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'c',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'd',
    '': 'n',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'y',
    '': 'o',
    '': 'y',

    // Cyrillic
    '': 'A',
    '': 'B',
    '': 'B',
    '': 'F',
    '': 'A',
    '': 'E',
    '': 'K',
    '': '3',
    '': 'N',
    '': 'N',
    '': 'K',
    '': 'N',
    '': 'M',
    '': 'H',
    '': 'O',
    '': 'N',
    '': 'P',
    '': 'C',
    '': 'T',
    '': 'y',
    '': 'O',
    '': 'X',
    '': 'U',
    '': 'h',
    '': 'W',
    '': 'W',
    '': 'B',
    '': 'X',
    '': 'B',
    '': '3',
    '': 'X',
    '': 'R',
    '': 'a',
    '': 'b',
    '': 'a',
    '': 'r',
    '': 'y',
    '': 'e',
    '': 'm',
    '': 'e',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'm',
    '': 'n',
    '': 'o',
    '': 'n',
    '': 'p',
    '': 'c',
    '': 'o',
    '': 'y',
    '': 'b',
    '': 'x',
    '': 'n',
    '': 'n',
    '': 'w',
    '': 'w',
    '': 'a',
    '': 'm',
    '': 'a',
    '': 'e',
    '': 'm',
    '': 'r'
};

/**
 * This function is a convenience function for looking up information in the
 * metricMap table. It takes a character as a string, and a style.
 *
 * Note: the `width` property may be undefined if fontMetricsData.js wasn't
 * built using `Make extended_metrics`.
 */
var getCharacterMetrics = function(character, style) {
    var ch = character.charCodeAt(0);
    if (character[0] in extraCharacterMap) {
        ch = extraCharacterMap[character[0]].charCodeAt(0);
    } else if (cjkRegex.test(character[0])) {
        ch = 'M'.charCodeAt(0);
    }
    var metrics = metricMap[style][ch];
    if (metrics) {
        return {
            depth: metrics[0],
            height: metrics[1],
            italic: metrics[2],
            skew: metrics[3],
            width: metrics[4]
        };
    }
};

module.exports = {
    metrics: metrics,
    sigmas: sigmas,
    getCharacterMetrics: getCharacterMetrics
};

},{"./Style":84,"./fontMetricsData":93,"./unicodeRegexes":99}],93:[function(require,module,exports){
module.exports = {
    "AMS-Regular": {
        "65": [0, 0.68889, 0, 0],
        "66": [0, 0.68889, 0, 0],
        "67": [0, 0.68889, 0, 0],
        "68": [0, 0.68889, 0, 0],
        "69": [0, 0.68889, 0, 0],
        "70": [0, 0.68889, 0, 0],
        "71": [0, 0.68889, 0, 0],
        "72": [0, 0.68889, 0, 0],
        "73": [0, 0.68889, 0, 0],
        "74": [0.16667, 0.68889, 0, 0],
        "75": [0, 0.68889, 0, 0],
        "76": [0, 0.68889, 0, 0],
        "77": [0, 0.68889, 0, 0],
        "78": [0, 0.68889, 0, 0],
        "79": [0.16667, 0.68889, 0, 0],
        "80": [0, 0.68889, 0, 0],
        "81": [0.16667, 0.68889, 0, 0],
        "82": [0, 0.68889, 0, 0],
        "83": [0, 0.68889, 0, 0],
        "84": [0, 0.68889, 0, 0],
        "85": [0, 0.68889, 0, 0],
        "86": [0, 0.68889, 0, 0],
        "87": [0, 0.68889, 0, 0],
        "88": [0, 0.68889, 0, 0],
        "89": [0, 0.68889, 0, 0],
        "90": [0, 0.68889, 0, 0],
        "107": [0, 0.68889, 0, 0],
        "165": [0, 0.675, 0.025, 0],
        "174": [0.15559, 0.69224, 0, 0],
        "240": [0, 0.68889, 0, 0],
        "295": [0, 0.68889, 0, 0],
        "710": [0, 0.825, 0, 0],
        "732": [0, 0.9, 0, 0],
        "770": [0, 0.825, 0, 0],
        "771": [0, 0.9, 0, 0],
        "989": [0.08167, 0.58167, 0, 0],
        "1008": [0, 0.43056, 0.04028, 0],
        "8245": [0, 0.54986, 0, 0],
        "8463": [0, 0.68889, 0, 0],
        "8487": [0, 0.68889, 0, 0],
        "8498": [0, 0.68889, 0, 0],
        "8502": [0, 0.68889, 0, 0],
        "8503": [0, 0.68889, 0, 0],
        "8504": [0, 0.68889, 0, 0],
        "8513": [0, 0.68889, 0, 0],
        "8592": [-0.03598, 0.46402, 0, 0],
        "8594": [-0.03598, 0.46402, 0, 0],
        "8602": [-0.13313, 0.36687, 0, 0],
        "8603": [-0.13313, 0.36687, 0, 0],
        "8606": [0.01354, 0.52239, 0, 0],
        "8608": [0.01354, 0.52239, 0, 0],
        "8610": [0.01354, 0.52239, 0, 0],
        "8611": [0.01354, 0.52239, 0, 0],
        "8619": [0, 0.54986, 0, 0],
        "8620": [0, 0.54986, 0, 0],
        "8621": [-0.13313, 0.37788, 0, 0],
        "8622": [-0.13313, 0.36687, 0, 0],
        "8624": [0, 0.69224, 0, 0],
        "8625": [0, 0.69224, 0, 0],
        "8630": [0, 0.43056, 0, 0],
        "8631": [0, 0.43056, 0, 0],
        "8634": [0.08198, 0.58198, 0, 0],
        "8635": [0.08198, 0.58198, 0, 0],
        "8638": [0.19444, 0.69224, 0, 0],
        "8639": [0.19444, 0.69224, 0, 0],
        "8642": [0.19444, 0.69224, 0, 0],
        "8643": [0.19444, 0.69224, 0, 0],
        "8644": [0.1808, 0.675, 0, 0],
        "8646": [0.1808, 0.675, 0, 0],
        "8647": [0.1808, 0.675, 0, 0],
        "8648": [0.19444, 0.69224, 0, 0],
        "8649": [0.1808, 0.675, 0, 0],
        "8650": [0.19444, 0.69224, 0, 0],
        "8651": [0.01354, 0.52239, 0, 0],
        "8652": [0.01354, 0.52239, 0, 0],
        "8653": [-0.13313, 0.36687, 0, 0],
        "8654": [-0.13313, 0.36687, 0, 0],
        "8655": [-0.13313, 0.36687, 0, 0],
        "8666": [0.13667, 0.63667, 0, 0],
        "8667": [0.13667, 0.63667, 0, 0],
        "8669": [-0.13313, 0.37788, 0, 0],
        "8672": [-0.064, 0.437, 0, 0],
        "8674": [-0.064, 0.437, 0, 0],
        "8705": [0, 0.825, 0, 0],
        "8708": [0, 0.68889, 0, 0],
        "8709": [0.08167, 0.58167, 0, 0],
        "8717": [0, 0.43056, 0, 0],
        "8722": [-0.03598, 0.46402, 0, 0],
        "8724": [0.08198, 0.69224, 0, 0],
        "8726": [0.08167, 0.58167, 0, 0],
        "8733": [0, 0.69224, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8737": [0, 0.69224, 0, 0],
        "8738": [0.03517, 0.52239, 0, 0],
        "8739": [0.08167, 0.58167, 0, 0],
        "8740": [0.25142, 0.74111, 0, 0],
        "8741": [0.08167, 0.58167, 0, 0],
        "8742": [0.25142, 0.74111, 0, 0],
        "8756": [0, 0.69224, 0, 0],
        "8757": [0, 0.69224, 0, 0],
        "8764": [-0.13313, 0.36687, 0, 0],
        "8765": [-0.13313, 0.37788, 0, 0],
        "8769": [-0.13313, 0.36687, 0, 0],
        "8770": [-0.03625, 0.46375, 0, 0],
        "8774": [0.30274, 0.79383, 0, 0],
        "8776": [-0.01688, 0.48312, 0, 0],
        "8778": [0.08167, 0.58167, 0, 0],
        "8782": [0.06062, 0.54986, 0, 0],
        "8783": [0.06062, 0.54986, 0, 0],
        "8785": [0.08198, 0.58198, 0, 0],
        "8786": [0.08198, 0.58198, 0, 0],
        "8787": [0.08198, 0.58198, 0, 0],
        "8790": [0, 0.69224, 0, 0],
        "8791": [0.22958, 0.72958, 0, 0],
        "8796": [0.08198, 0.91667, 0, 0],
        "8806": [0.25583, 0.75583, 0, 0],
        "8807": [0.25583, 0.75583, 0, 0],
        "8808": [0.25142, 0.75726, 0, 0],
        "8809": [0.25142, 0.75726, 0, 0],
        "8812": [0.25583, 0.75583, 0, 0],
        "8814": [0.20576, 0.70576, 0, 0],
        "8815": [0.20576, 0.70576, 0, 0],
        "8816": [0.30274, 0.79383, 0, 0],
        "8817": [0.30274, 0.79383, 0, 0],
        "8818": [0.22958, 0.72958, 0, 0],
        "8819": [0.22958, 0.72958, 0, 0],
        "8822": [0.1808, 0.675, 0, 0],
        "8823": [0.1808, 0.675, 0, 0],
        "8828": [0.13667, 0.63667, 0, 0],
        "8829": [0.13667, 0.63667, 0, 0],
        "8830": [0.22958, 0.72958, 0, 0],
        "8831": [0.22958, 0.72958, 0, 0],
        "8832": [0.20576, 0.70576, 0, 0],
        "8833": [0.20576, 0.70576, 0, 0],
        "8840": [0.30274, 0.79383, 0, 0],
        "8841": [0.30274, 0.79383, 0, 0],
        "8842": [0.13597, 0.63597, 0, 0],
        "8843": [0.13597, 0.63597, 0, 0],
        "8847": [0.03517, 0.54986, 0, 0],
        "8848": [0.03517, 0.54986, 0, 0],
        "8858": [0.08198, 0.58198, 0, 0],
        "8859": [0.08198, 0.58198, 0, 0],
        "8861": [0.08198, 0.58198, 0, 0],
        "8862": [0, 0.675, 0, 0],
        "8863": [0, 0.675, 0, 0],
        "8864": [0, 0.675, 0, 0],
        "8865": [0, 0.675, 0, 0],
        "8872": [0, 0.69224, 0, 0],
        "8873": [0, 0.69224, 0, 0],
        "8874": [0, 0.69224, 0, 0],
        "8876": [0, 0.68889, 0, 0],
        "8877": [0, 0.68889, 0, 0],
        "8878": [0, 0.68889, 0, 0],
        "8879": [0, 0.68889, 0, 0],
        "8882": [0.03517, 0.54986, 0, 0],
        "8883": [0.03517, 0.54986, 0, 0],
        "8884": [0.13667, 0.63667, 0, 0],
        "8885": [0.13667, 0.63667, 0, 0],
        "8888": [0, 0.54986, 0, 0],
        "8890": [0.19444, 0.43056, 0, 0],
        "8891": [0.19444, 0.69224, 0, 0],
        "8892": [0.19444, 0.69224, 0, 0],
        "8901": [0, 0.54986, 0, 0],
        "8903": [0.08167, 0.58167, 0, 0],
        "8905": [0.08167, 0.58167, 0, 0],
        "8906": [0.08167, 0.58167, 0, 0],
        "8907": [0, 0.69224, 0, 0],
        "8908": [0, 0.69224, 0, 0],
        "8909": [-0.03598, 0.46402, 0, 0],
        "8910": [0, 0.54986, 0, 0],
        "8911": [0, 0.54986, 0, 0],
        "8912": [0.03517, 0.54986, 0, 0],
        "8913": [0.03517, 0.54986, 0, 0],
        "8914": [0, 0.54986, 0, 0],
        "8915": [0, 0.54986, 0, 0],
        "8916": [0, 0.69224, 0, 0],
        "8918": [0.0391, 0.5391, 0, 0],
        "8919": [0.0391, 0.5391, 0, 0],
        "8920": [0.03517, 0.54986, 0, 0],
        "8921": [0.03517, 0.54986, 0, 0],
        "8922": [0.38569, 0.88569, 0, 0],
        "8923": [0.38569, 0.88569, 0, 0],
        "8926": [0.13667, 0.63667, 0, 0],
        "8927": [0.13667, 0.63667, 0, 0],
        "8928": [0.30274, 0.79383, 0, 0],
        "8929": [0.30274, 0.79383, 0, 0],
        "8934": [0.23222, 0.74111, 0, 0],
        "8935": [0.23222, 0.74111, 0, 0],
        "8936": [0.23222, 0.74111, 0, 0],
        "8937": [0.23222, 0.74111, 0, 0],
        "8938": [0.20576, 0.70576, 0, 0],
        "8939": [0.20576, 0.70576, 0, 0],
        "8940": [0.30274, 0.79383, 0, 0],
        "8941": [0.30274, 0.79383, 0, 0],
        "8994": [0.19444, 0.69224, 0, 0],
        "8995": [0.19444, 0.69224, 0, 0],
        "9416": [0.15559, 0.69224, 0, 0],
        "9484": [0, 0.69224, 0, 0],
        "9488": [0, 0.69224, 0, 0],
        "9492": [0, 0.37788, 0, 0],
        "9496": [0, 0.37788, 0, 0],
        "9585": [0.19444, 0.68889, 0, 0],
        "9586": [0.19444, 0.74111, 0, 0],
        "9632": [0, 0.675, 0, 0],
        "9633": [0, 0.675, 0, 0],
        "9650": [0, 0.54986, 0, 0],
        "9651": [0, 0.54986, 0, 0],
        "9654": [0.03517, 0.54986, 0, 0],
        "9660": [0, 0.54986, 0, 0],
        "9661": [0, 0.54986, 0, 0],
        "9664": [0.03517, 0.54986, 0, 0],
        "9674": [0.11111, 0.69224, 0, 0],
        "9733": [0.19444, 0.69224, 0, 0],
        "10003": [0, 0.69224, 0, 0],
        "10016": [0, 0.69224, 0, 0],
        "10731": [0.11111, 0.69224, 0, 0],
        "10846": [0.19444, 0.75583, 0, 0],
        "10877": [0.13667, 0.63667, 0, 0],
        "10878": [0.13667, 0.63667, 0, 0],
        "10885": [0.25583, 0.75583, 0, 0],
        "10886": [0.25583, 0.75583, 0, 0],
        "10887": [0.13597, 0.63597, 0, 0],
        "10888": [0.13597, 0.63597, 0, 0],
        "10889": [0.26167, 0.75726, 0, 0],
        "10890": [0.26167, 0.75726, 0, 0],
        "10891": [0.48256, 0.98256, 0, 0],
        "10892": [0.48256, 0.98256, 0, 0],
        "10901": [0.13667, 0.63667, 0, 0],
        "10902": [0.13667, 0.63667, 0, 0],
        "10933": [0.25142, 0.75726, 0, 0],
        "10934": [0.25142, 0.75726, 0, 0],
        "10935": [0.26167, 0.75726, 0, 0],
        "10936": [0.26167, 0.75726, 0, 0],
        "10937": [0.26167, 0.75726, 0, 0],
        "10938": [0.26167, 0.75726, 0, 0],
        "10949": [0.25583, 0.75583, 0, 0],
        "10950": [0.25583, 0.75583, 0, 0],
        "10955": [0.28481, 0.79383, 0, 0],
        "10956": [0.28481, 0.79383, 0, 0],
        "57350": [0.08167, 0.58167, 0, 0],
        "57351": [0.08167, 0.58167, 0, 0],
        "57352": [0.08167, 0.58167, 0, 0],
        "57353": [0, 0.43056, 0.04028, 0],
        "57356": [0.25142, 0.75726, 0, 0],
        "57357": [0.25142, 0.75726, 0, 0],
        "57358": [0.41951, 0.91951, 0, 0],
        "57359": [0.30274, 0.79383, 0, 0],
        "57360": [0.30274, 0.79383, 0, 0],
        "57361": [0.41951, 0.91951, 0, 0],
        "57366": [0.25142, 0.75726, 0, 0],
        "57367": [0.25142, 0.75726, 0, 0],
        "57368": [0.25142, 0.75726, 0, 0],
        "57369": [0.25142, 0.75726, 0, 0],
        "57370": [0.13597, 0.63597, 0, 0],
        "57371": [0.13597, 0.63597, 0, 0]
    },
    "Caligraphic-Regular": {
        "48": [0, 0.43056, 0, 0],
        "49": [0, 0.43056, 0, 0],
        "50": [0, 0.43056, 0, 0],
        "51": [0.19444, 0.43056, 0, 0],
        "52": [0.19444, 0.43056, 0, 0],
        "53": [0.19444, 0.43056, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0.19444, 0.43056, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0.19444, 0.43056, 0, 0],
        "65": [0, 0.68333, 0, 0.19445],
        "66": [0, 0.68333, 0.03041, 0.13889],
        "67": [0, 0.68333, 0.05834, 0.13889],
        "68": [0, 0.68333, 0.02778, 0.08334],
        "69": [0, 0.68333, 0.08944, 0.11111],
        "70": [0, 0.68333, 0.09931, 0.11111],
        "71": [0.09722, 0.68333, 0.0593, 0.11111],
        "72": [0, 0.68333, 0.00965, 0.11111],
        "73": [0, 0.68333, 0.07382, 0],
        "74": [0.09722, 0.68333, 0.18472, 0.16667],
        "75": [0, 0.68333, 0.01445, 0.05556],
        "76": [0, 0.68333, 0, 0.13889],
        "77": [0, 0.68333, 0, 0.13889],
        "78": [0, 0.68333, 0.14736, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.11111],
        "80": [0, 0.68333, 0.08222, 0.08334],
        "81": [0.09722, 0.68333, 0, 0.11111],
        "82": [0, 0.68333, 0, 0.08334],
        "83": [0, 0.68333, 0.075, 0.13889],
        "84": [0, 0.68333, 0.25417, 0],
        "85": [0, 0.68333, 0.09931, 0.08334],
        "86": [0, 0.68333, 0.08222, 0],
        "87": [0, 0.68333, 0.08222, 0.08334],
        "88": [0, 0.68333, 0.14643, 0.13889],
        "89": [0.09722, 0.68333, 0.08222, 0.08334],
        "90": [0, 0.68333, 0.07944, 0.13889]
    },
    "Fraktur-Regular": {
        "33": [0, 0.69141, 0, 0],
        "34": [0, 0.69141, 0, 0],
        "38": [0, 0.69141, 0, 0],
        "39": [0, 0.69141, 0, 0],
        "40": [0.24982, 0.74947, 0, 0],
        "41": [0.24982, 0.74947, 0, 0],
        "42": [0, 0.62119, 0, 0],
        "43": [0.08319, 0.58283, 0, 0],
        "44": [0, 0.10803, 0, 0],
        "45": [0.08319, 0.58283, 0, 0],
        "46": [0, 0.10803, 0, 0],
        "47": [0.24982, 0.74947, 0, 0],
        "48": [0, 0.47534, 0, 0],
        "49": [0, 0.47534, 0, 0],
        "50": [0, 0.47534, 0, 0],
        "51": [0.18906, 0.47534, 0, 0],
        "52": [0.18906, 0.47534, 0, 0],
        "53": [0.18906, 0.47534, 0, 0],
        "54": [0, 0.69141, 0, 0],
        "55": [0.18906, 0.47534, 0, 0],
        "56": [0, 0.69141, 0, 0],
        "57": [0.18906, 0.47534, 0, 0],
        "58": [0, 0.47534, 0, 0],
        "59": [0.12604, 0.47534, 0, 0],
        "61": [-0.13099, 0.36866, 0, 0],
        "63": [0, 0.69141, 0, 0],
        "65": [0, 0.69141, 0, 0],
        "66": [0, 0.69141, 0, 0],
        "67": [0, 0.69141, 0, 0],
        "68": [0, 0.69141, 0, 0],
        "69": [0, 0.69141, 0, 0],
        "70": [0.12604, 0.69141, 0, 0],
        "71": [0, 0.69141, 0, 0],
        "72": [0.06302, 0.69141, 0, 0],
        "73": [0, 0.69141, 0, 0],
        "74": [0.12604, 0.69141, 0, 0],
        "75": [0, 0.69141, 0, 0],
        "76": [0, 0.69141, 0, 0],
        "77": [0, 0.69141, 0, 0],
        "78": [0, 0.69141, 0, 0],
        "79": [0, 0.69141, 0, 0],
        "80": [0.18906, 0.69141, 0, 0],
        "81": [0.03781, 0.69141, 0, 0],
        "82": [0, 0.69141, 0, 0],
        "83": [0, 0.69141, 0, 0],
        "84": [0, 0.69141, 0, 0],
        "85": [0, 0.69141, 0, 0],
        "86": [0, 0.69141, 0, 0],
        "87": [0, 0.69141, 0, 0],
        "88": [0, 0.69141, 0, 0],
        "89": [0.18906, 0.69141, 0, 0],
        "90": [0.12604, 0.69141, 0, 0],
        "91": [0.24982, 0.74947, 0, 0],
        "93": [0.24982, 0.74947, 0, 0],
        "94": [0, 0.69141, 0, 0],
        "97": [0, 0.47534, 0, 0],
        "98": [0, 0.69141, 0, 0],
        "99": [0, 0.47534, 0, 0],
        "100": [0, 0.62119, 0, 0],
        "101": [0, 0.47534, 0, 0],
        "102": [0.18906, 0.69141, 0, 0],
        "103": [0.18906, 0.47534, 0, 0],
        "104": [0.18906, 0.69141, 0, 0],
        "105": [0, 0.69141, 0, 0],
        "106": [0, 0.69141, 0, 0],
        "107": [0, 0.69141, 0, 0],
        "108": [0, 0.69141, 0, 0],
        "109": [0, 0.47534, 0, 0],
        "110": [0, 0.47534, 0, 0],
        "111": [0, 0.47534, 0, 0],
        "112": [0.18906, 0.52396, 0, 0],
        "113": [0.18906, 0.47534, 0, 0],
        "114": [0, 0.47534, 0, 0],
        "115": [0, 0.47534, 0, 0],
        "116": [0, 0.62119, 0, 0],
        "117": [0, 0.47534, 0, 0],
        "118": [0, 0.52396, 0, 0],
        "119": [0, 0.52396, 0, 0],
        "120": [0.18906, 0.47534, 0, 0],
        "121": [0.18906, 0.47534, 0, 0],
        "122": [0.18906, 0.47534, 0, 0],
        "8216": [0, 0.69141, 0, 0],
        "8217": [0, 0.69141, 0, 0],
        "58112": [0, 0.62119, 0, 0],
        "58113": [0, 0.62119, 0, 0],
        "58114": [0.18906, 0.69141, 0, 0],
        "58115": [0.18906, 0.69141, 0, 0],
        "58116": [0.18906, 0.47534, 0, 0],
        "58117": [0, 0.69141, 0, 0],
        "58118": [0, 0.62119, 0, 0],
        "58119": [0, 0.47534, 0, 0]
    },
    "Main-Bold": {
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.13333, 0.63333, 0, 0],
        "44": [0.19444, 0.15556, 0, 0],
        "45": [0, 0.44444, 0, 0],
        "46": [0, 0.15556, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.64444, 0, 0],
        "49": [0, 0.64444, 0, 0],
        "50": [0, 0.64444, 0, 0],
        "51": [0, 0.64444, 0, 0],
        "52": [0, 0.64444, 0, 0],
        "53": [0, 0.64444, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0, 0.64444, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0, 0.64444, 0, 0],
        "58": [0, 0.44444, 0, 0],
        "59": [0.19444, 0.44444, 0, 0],
        "60": [0.08556, 0.58556, 0, 0],
        "61": [-0.10889, 0.39111, 0, 0],
        "62": [0.08556, 0.58556, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.68611, 0, 0],
        "66": [0, 0.68611, 0, 0],
        "67": [0, 0.68611, 0, 0],
        "68": [0, 0.68611, 0, 0],
        "69": [0, 0.68611, 0, 0],
        "70": [0, 0.68611, 0, 0],
        "71": [0, 0.68611, 0, 0],
        "72": [0, 0.68611, 0, 0],
        "73": [0, 0.68611, 0, 0],
        "74": [0, 0.68611, 0, 0],
        "75": [0, 0.68611, 0, 0],
        "76": [0, 0.68611, 0, 0],
        "77": [0, 0.68611, 0, 0],
        "78": [0, 0.68611, 0, 0],
        "79": [0, 0.68611, 0, 0],
        "80": [0, 0.68611, 0, 0],
        "81": [0.19444, 0.68611, 0, 0],
        "82": [0, 0.68611, 0, 0],
        "83": [0, 0.68611, 0, 0],
        "84": [0, 0.68611, 0, 0],
        "85": [0, 0.68611, 0, 0],
        "86": [0, 0.68611, 0.01597, 0],
        "87": [0, 0.68611, 0.01597, 0],
        "88": [0, 0.68611, 0, 0],
        "89": [0, 0.68611, 0.02875, 0],
        "90": [0, 0.68611, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "92": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.31, 0.13444, 0.03194, 0],
        "96": [0, 0.69444, 0, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0, 0.69444, 0.10903, 0],
        "103": [0.19444, 0.44444, 0.01597, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.69444, 0, 0],
        "106": [0.19444, 0.69444, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0, 0],
        "114": [0, 0.44444, 0, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.63492, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.01597, 0],
        "119": [0, 0.44444, 0.01597, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.01597, 0],
        "122": [0, 0.44444, 0, 0],
        "123": [0.25, 0.75, 0, 0],
        "124": [0.25, 0.75, 0, 0],
        "125": [0.25, 0.75, 0, 0],
        "126": [0.35, 0.34444, 0, 0],
        "168": [0, 0.69444, 0, 0],
        "172": [0, 0.44444, 0, 0],
        "175": [0, 0.59611, 0, 0],
        "176": [0, 0.69444, 0, 0],
        "177": [0.13333, 0.63333, 0, 0],
        "180": [0, 0.69444, 0, 0],
        "215": [0.13333, 0.63333, 0, 0],
        "247": [0.13333, 0.63333, 0, 0],
        "305": [0, 0.44444, 0, 0],
        "567": [0.19444, 0.44444, 0, 0],
        "710": [0, 0.69444, 0, 0],
        "711": [0, 0.63194, 0, 0],
        "713": [0, 0.59611, 0, 0],
        "714": [0, 0.69444, 0, 0],
        "715": [0, 0.69444, 0, 0],
        "728": [0, 0.69444, 0, 0],
        "729": [0, 0.69444, 0, 0],
        "730": [0, 0.69444, 0, 0],
        "732": [0, 0.69444, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.69444, 0, 0],
        "772": [0, 0.59611, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.69444, 0, 0],
        "776": [0, 0.69444, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.63194, 0, 0],
        "824": [0.19444, 0.69444, 0, 0],
        "915": [0, 0.68611, 0, 0],
        "916": [0, 0.68611, 0, 0],
        "920": [0, 0.68611, 0, 0],
        "923": [0, 0.68611, 0, 0],
        "926": [0, 0.68611, 0, 0],
        "928": [0, 0.68611, 0, 0],
        "931": [0, 0.68611, 0, 0],
        "933": [0, 0.68611, 0, 0],
        "934": [0, 0.68611, 0, 0],
        "936": [0, 0.68611, 0, 0],
        "937": [0, 0.68611, 0, 0],
        "8211": [0, 0.44444, 0.03194, 0],
        "8212": [0, 0.44444, 0.03194, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0],
        "8224": [0.19444, 0.69444, 0, 0],
        "8225": [0.19444, 0.69444, 0, 0],
        "8242": [0, 0.55556, 0, 0],
        "8407": [0, 0.72444, 0.15486, 0],
        "8463": [0, 0.69444, 0, 0],
        "8465": [0, 0.69444, 0, 0],
        "8467": [0, 0.69444, 0, 0],
        "8472": [0.19444, 0.44444, 0, 0],
        "8476": [0, 0.69444, 0, 0],
        "8501": [0, 0.69444, 0, 0],
        "8592": [-0.10889, 0.39111, 0, 0],
        "8593": [0.19444, 0.69444, 0, 0],
        "8594": [-0.10889, 0.39111, 0, 0],
        "8595": [0.19444, 0.69444, 0, 0],
        "8596": [-0.10889, 0.39111, 0, 0],
        "8597": [0.25, 0.75, 0, 0],
        "8598": [0.19444, 0.69444, 0, 0],
        "8599": [0.19444, 0.69444, 0, 0],
        "8600": [0.19444, 0.69444, 0, 0],
        "8601": [0.19444, 0.69444, 0, 0],
        "8636": [-0.10889, 0.39111, 0, 0],
        "8637": [-0.10889, 0.39111, 0, 0],
        "8640": [-0.10889, 0.39111, 0, 0],
        "8641": [-0.10889, 0.39111, 0, 0],
        "8656": [-0.10889, 0.39111, 0, 0],
        "8657": [0.19444, 0.69444, 0, 0],
        "8658": [-0.10889, 0.39111, 0, 0],
        "8659": [0.19444, 0.69444, 0, 0],
        "8660": [-0.10889, 0.39111, 0, 0],
        "8661": [0.25, 0.75, 0, 0],
        "8704": [0, 0.69444, 0, 0],
        "8706": [0, 0.69444, 0.06389, 0],
        "8707": [0, 0.69444, 0, 0],
        "8709": [0.05556, 0.75, 0, 0],
        "8711": [0, 0.68611, 0, 0],
        "8712": [0.08556, 0.58556, 0, 0],
        "8715": [0.08556, 0.58556, 0, 0],
        "8722": [0.13333, 0.63333, 0, 0],
        "8723": [0.13333, 0.63333, 0, 0],
        "8725": [0.25, 0.75, 0, 0],
        "8726": [0.25, 0.75, 0, 0],
        "8727": [-0.02778, 0.47222, 0, 0],
        "8728": [-0.02639, 0.47361, 0, 0],
        "8729": [-0.02639, 0.47361, 0, 0],
        "8730": [0.18, 0.82, 0, 0],
        "8733": [0, 0.44444, 0, 0],
        "8734": [0, 0.44444, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8739": [0.25, 0.75, 0, 0],
        "8741": [0.25, 0.75, 0, 0],
        "8743": [0, 0.55556, 0, 0],
        "8744": [0, 0.55556, 0, 0],
        "8745": [0, 0.55556, 0, 0],
        "8746": [0, 0.55556, 0, 0],
        "8747": [0.19444, 0.69444, 0.12778, 0],
        "8764": [-0.10889, 0.39111, 0, 0],
        "8768": [0.19444, 0.69444, 0, 0],
        "8771": [0.00222, 0.50222, 0, 0],
        "8776": [0.02444, 0.52444, 0, 0],
        "8781": [0.00222, 0.50222, 0, 0],
        "8801": [0.00222, 0.50222, 0, 0],
        "8804": [0.19667, 0.69667, 0, 0],
        "8805": [0.19667, 0.69667, 0, 0],
        "8810": [0.08556, 0.58556, 0, 0],
        "8811": [0.08556, 0.58556, 0, 0],
        "8826": [0.08556, 0.58556, 0, 0],
        "8827": [0.08556, 0.58556, 0, 0],
        "8834": [0.08556, 0.58556, 0, 0],
        "8835": [0.08556, 0.58556, 0, 0],
        "8838": [0.19667, 0.69667, 0, 0],
        "8839": [0.19667, 0.69667, 0, 0],
        "8846": [0, 0.55556, 0, 0],
        "8849": [0.19667, 0.69667, 0, 0],
        "8850": [0.19667, 0.69667, 0, 0],
        "8851": [0, 0.55556, 0, 0],
        "8852": [0, 0.55556, 0, 0],
        "8853": [0.13333, 0.63333, 0, 0],
        "8854": [0.13333, 0.63333, 0, 0],
        "8855": [0.13333, 0.63333, 0, 0],
        "8856": [0.13333, 0.63333, 0, 0],
        "8857": [0.13333, 0.63333, 0, 0],
        "8866": [0, 0.69444, 0, 0],
        "8867": [0, 0.69444, 0, 0],
        "8868": [0, 0.69444, 0, 0],
        "8869": [0, 0.69444, 0, 0],
        "8900": [-0.02639, 0.47361, 0, 0],
        "8901": [-0.02639, 0.47361, 0, 0],
        "8902": [-0.02778, 0.47222, 0, 0],
        "8968": [0.25, 0.75, 0, 0],
        "8969": [0.25, 0.75, 0, 0],
        "8970": [0.25, 0.75, 0, 0],
        "8971": [0.25, 0.75, 0, 0],
        "8994": [-0.13889, 0.36111, 0, 0],
        "8995": [-0.13889, 0.36111, 0, 0],
        "9651": [0.19444, 0.69444, 0, 0],
        "9657": [-0.02778, 0.47222, 0, 0],
        "9661": [0.19444, 0.69444, 0, 0],
        "9667": [-0.02778, 0.47222, 0, 0],
        "9711": [0.19444, 0.69444, 0, 0],
        "9824": [0.12963, 0.69444, 0, 0],
        "9825": [0.12963, 0.69444, 0, 0],
        "9826": [0.12963, 0.69444, 0, 0],
        "9827": [0.12963, 0.69444, 0, 0],
        "9837": [0, 0.75, 0, 0],
        "9838": [0.19444, 0.69444, 0, 0],
        "9839": [0.19444, 0.69444, 0, 0],
        "10216": [0.25, 0.75, 0, 0],
        "10217": [0.25, 0.75, 0, 0],
        "10815": [0, 0.68611, 0, 0],
        "10927": [0.19667, 0.69667, 0, 0],
        "10928": [0.19667, 0.69667, 0, 0]
    },
    "Main-Italic": {
        "33": [0, 0.69444, 0.12417, 0],
        "34": [0, 0.69444, 0.06961, 0],
        "35": [0.19444, 0.69444, 0.06616, 0],
        "37": [0.05556, 0.75, 0.13639, 0],
        "38": [0, 0.69444, 0.09694, 0],
        "39": [0, 0.69444, 0.12417, 0],
        "40": [0.25, 0.75, 0.16194, 0],
        "41": [0.25, 0.75, 0.03694, 0],
        "42": [0, 0.75, 0.14917, 0],
        "43": [0.05667, 0.56167, 0.03694, 0],
        "44": [0.19444, 0.10556, 0, 0],
        "45": [0, 0.43056, 0.02826, 0],
        "46": [0, 0.10556, 0, 0],
        "47": [0.25, 0.75, 0.16194, 0],
        "48": [0, 0.64444, 0.13556, 0],
        "49": [0, 0.64444, 0.13556, 0],
        "50": [0, 0.64444, 0.13556, 0],
        "51": [0, 0.64444, 0.13556, 0],
        "52": [0.19444, 0.64444, 0.13556, 0],
        "53": [0, 0.64444, 0.13556, 0],
        "54": [0, 0.64444, 0.13556, 0],
        "55": [0.19444, 0.64444, 0.13556, 0],
        "56": [0, 0.64444, 0.13556, 0],
        "57": [0, 0.64444, 0.13556, 0],
        "58": [0, 0.43056, 0.0582, 0],
        "59": [0.19444, 0.43056, 0.0582, 0],
        "61": [-0.13313, 0.36687, 0.06616, 0],
        "63": [0, 0.69444, 0.1225, 0],
        "64": [0, 0.69444, 0.09597, 0],
        "65": [0, 0.68333, 0, 0],
        "66": [0, 0.68333, 0.10257, 0],
        "67": [0, 0.68333, 0.14528, 0],
        "68": [0, 0.68333, 0.09403, 0],
        "69": [0, 0.68333, 0.12028, 0],
        "70": [0, 0.68333, 0.13305, 0],
        "71": [0, 0.68333, 0.08722, 0],
        "72": [0, 0.68333, 0.16389, 0],
        "73": [0, 0.68333, 0.15806, 0],
        "74": [0, 0.68333, 0.14028, 0],
        "75": [0, 0.68333, 0.14528, 0],
        "76": [0, 0.68333, 0, 0],
        "77": [0, 0.68333, 0.16389, 0],
        "78": [0, 0.68333, 0.16389, 0],
        "79": [0, 0.68333, 0.09403, 0],
        "80": [0, 0.68333, 0.10257, 0],
        "81": [0.19444, 0.68333, 0.09403, 0],
        "82": [0, 0.68333, 0.03868, 0],
        "83": [0, 0.68333, 0.11972, 0],
        "84": [0, 0.68333, 0.13305, 0],
        "85": [0, 0.68333, 0.16389, 0],
        "86": [0, 0.68333, 0.18361, 0],
        "87": [0, 0.68333, 0.18361, 0],
        "88": [0, 0.68333, 0.15806, 0],
        "89": [0, 0.68333, 0.19383, 0],
        "90": [0, 0.68333, 0.14528, 0],
        "91": [0.25, 0.75, 0.1875, 0],
        "93": [0.25, 0.75, 0.10528, 0],
        "94": [0, 0.69444, 0.06646, 0],
        "95": [0.31, 0.12056, 0.09208, 0],
        "97": [0, 0.43056, 0.07671, 0],
        "98": [0, 0.69444, 0.06312, 0],
        "99": [0, 0.43056, 0.05653, 0],
        "100": [0, 0.69444, 0.10333, 0],
        "101": [0, 0.43056, 0.07514, 0],
        "102": [0.19444, 0.69444, 0.21194, 0],
        "103": [0.19444, 0.43056, 0.08847, 0],
        "104": [0, 0.69444, 0.07671, 0],
        "105": [0, 0.65536, 0.1019, 0],
        "106": [0.19444, 0.65536, 0.14467, 0],
        "107": [0, 0.69444, 0.10764, 0],
        "108": [0, 0.69444, 0.10333, 0],
        "109": [0, 0.43056, 0.07671, 0],
        "110": [0, 0.43056, 0.07671, 0],
        "111": [0, 0.43056, 0.06312, 0],
        "112": [0.19444, 0.43056, 0.06312, 0],
        "113": [0.19444, 0.43056, 0.08847, 0],
        "114": [0, 0.43056, 0.10764, 0],
        "115": [0, 0.43056, 0.08208, 0],
        "116": [0, 0.61508, 0.09486, 0],
        "117": [0, 0.43056, 0.07671, 0],
        "118": [0, 0.43056, 0.10764, 0],
        "119": [0, 0.43056, 0.10764, 0],
        "120": [0, 0.43056, 0.12042, 0],
        "121": [0.19444, 0.43056, 0.08847, 0],
        "122": [0, 0.43056, 0.12292, 0],
        "126": [0.35, 0.31786, 0.11585, 0],
        "163": [0, 0.69444, 0, 0],
        "305": [0, 0.43056, 0, 0.02778],
        "567": [0.19444, 0.43056, 0, 0.08334],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0.09694, 0],
        "770": [0, 0.69444, 0.06646, 0],
        "771": [0, 0.66786, 0.11585, 0],
        "772": [0, 0.56167, 0.10333, 0],
        "774": [0, 0.69444, 0.10806, 0],
        "775": [0, 0.66786, 0.11752, 0],
        "776": [0, 0.66786, 0.10474, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0.1225, 0],
        "780": [0, 0.62847, 0.08295, 0],
        "915": [0, 0.68333, 0.13305, 0],
        "916": [0, 0.68333, 0, 0],
        "920": [0, 0.68333, 0.09403, 0],
        "923": [0, 0.68333, 0, 0],
        "926": [0, 0.68333, 0.15294, 0],
        "928": [0, 0.68333, 0.16389, 0],
        "931": [0, 0.68333, 0.12028, 0],
        "933": [0, 0.68333, 0.11111, 0],
        "934": [0, 0.68333, 0.05986, 0],
        "936": [0, 0.68333, 0.11111, 0],
        "937": [0, 0.68333, 0.10257, 0],
        "8211": [0, 0.43056, 0.09208, 0],
        "8212": [0, 0.43056, 0.09208, 0],
        "8216": [0, 0.69444, 0.12417, 0],
        "8217": [0, 0.69444, 0.12417, 0],
        "8220": [0, 0.69444, 0.1685, 0],
        "8221": [0, 0.69444, 0.06961, 0],
        "8463": [0, 0.68889, 0, 0]
    },
    "Main-Regular": {
        "32": [0, 0, 0, 0],
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.08333, 0.58333, 0, 0],
        "44": [0.19444, 0.10556, 0, 0],
        "45": [0, 0.43056, 0, 0],
        "46": [0, 0.10556, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.64444, 0, 0],
        "49": [0, 0.64444, 0, 0],
        "50": [0, 0.64444, 0, 0],
        "51": [0, 0.64444, 0, 0],
        "52": [0, 0.64444, 0, 0],
        "53": [0, 0.64444, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0, 0.64444, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0, 0.64444, 0, 0],
        "58": [0, 0.43056, 0, 0],
        "59": [0.19444, 0.43056, 0, 0],
        "60": [0.0391, 0.5391, 0, 0],
        "61": [-0.13313, 0.36687, 0, 0],
        "62": [0.0391, 0.5391, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.68333, 0, 0],
        "66": [0, 0.68333, 0, 0],
        "67": [0, 0.68333, 0, 0],
        "68": [0, 0.68333, 0, 0],
        "69": [0, 0.68333, 0, 0],
        "70": [0, 0.68333, 0, 0],
        "71": [0, 0.68333, 0, 0],
        "72": [0, 0.68333, 0, 0],
        "73": [0, 0.68333, 0, 0],
        "74": [0, 0.68333, 0, 0],
        "75": [0, 0.68333, 0, 0],
        "76": [0, 0.68333, 0, 0],
        "77": [0, 0.68333, 0, 0],
        "78": [0, 0.68333, 0, 0],
        "79": [0, 0.68333, 0, 0],
        "80": [0, 0.68333, 0, 0],
        "81": [0.19444, 0.68333, 0, 0],
        "82": [0, 0.68333, 0, 0],
        "83": [0, 0.68333, 0, 0],
        "84": [0, 0.68333, 0, 0],
        "85": [0, 0.68333, 0, 0],
        "86": [0, 0.68333, 0.01389, 0],
        "87": [0, 0.68333, 0.01389, 0],
        "88": [0, 0.68333, 0, 0],
        "89": [0, 0.68333, 0.025, 0],
        "90": [0, 0.68333, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "92": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.31, 0.12056, 0.02778, 0],
        "96": [0, 0.69444, 0, 0],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.43056, 0, 0],
        "102": [0, 0.69444, 0.07778, 0],
        "103": [0.19444, 0.43056, 0.01389, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.66786, 0, 0],
        "106": [0.19444, 0.66786, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0],
        "112": [0.19444, 0.43056, 0, 0],
        "113": [0.19444, 0.43056, 0, 0],
        "114": [0, 0.43056, 0, 0],
        "115": [0, 0.43056, 0, 0],
        "116": [0, 0.61508, 0, 0],
        "117": [0, 0.43056, 0, 0],
        "118": [0, 0.43056, 0.01389, 0],
        "119": [0, 0.43056, 0.01389, 0],
        "120": [0, 0.43056, 0, 0],
        "121": [0.19444, 0.43056, 0.01389, 0],
        "122": [0, 0.43056, 0, 0],
        "123": [0.25, 0.75, 0, 0],
        "124": [0.25, 0.75, 0, 0],
        "125": [0.25, 0.75, 0, 0],
        "126": [0.35, 0.31786, 0, 0],
        "160": [0, 0, 0, 0],
        "168": [0, 0.66786, 0, 0],
        "172": [0, 0.43056, 0, 0],
        "175": [0, 0.56778, 0, 0],
        "176": [0, 0.69444, 0, 0],
        "177": [0.08333, 0.58333, 0, 0],
        "180": [0, 0.69444, 0, 0],
        "215": [0.08333, 0.58333, 0, 0],
        "247": [0.08333, 0.58333, 0, 0],
        "305": [0, 0.43056, 0, 0],
        "567": [0.19444, 0.43056, 0, 0],
        "710": [0, 0.69444, 0, 0],
        "711": [0, 0.62847, 0, 0],
        "713": [0, 0.56778, 0, 0],
        "714": [0, 0.69444, 0, 0],
        "715": [0, 0.69444, 0, 0],
        "728": [0, 0.69444, 0, 0],
        "729": [0, 0.66786, 0, 0],
        "730": [0, 0.69444, 0, 0],
        "732": [0, 0.66786, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.66786, 0, 0],
        "772": [0, 0.56778, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.66786, 0, 0],
        "776": [0, 0.66786, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.62847, 0, 0],
        "824": [0.19444, 0.69444, 0, 0],
        "915": [0, 0.68333, 0, 0],
        "916": [0, 0.68333, 0, 0],
        "920": [0, 0.68333, 0, 0],
        "923": [0, 0.68333, 0, 0],
        "926": [0, 0.68333, 0, 0],
        "928": [0, 0.68333, 0, 0],
        "931": [0, 0.68333, 0, 0],
        "933": [0, 0.68333, 0, 0],
        "934": [0, 0.68333, 0, 0],
        "936": [0, 0.68333, 0, 0],
        "937": [0, 0.68333, 0, 0],
        "8211": [0, 0.43056, 0.02778, 0],
        "8212": [0, 0.43056, 0.02778, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0],
        "8224": [0.19444, 0.69444, 0, 0],
        "8225": [0.19444, 0.69444, 0, 0],
        "8230": [0, 0.12, 0, 0],
        "8242": [0, 0.55556, 0, 0],
        "8407": [0, 0.71444, 0.15382, 0],
        "8463": [0, 0.68889, 0, 0],
        "8465": [0, 0.69444, 0, 0],
        "8467": [0, 0.69444, 0, 0.11111],
        "8472": [0.19444, 0.43056, 0, 0.11111],
        "8476": [0, 0.69444, 0, 0],
        "8501": [0, 0.69444, 0, 0],
        "8592": [-0.13313, 0.36687, 0, 0],
        "8593": [0.19444, 0.69444, 0, 0],
        "8594": [-0.13313, 0.36687, 0, 0],
        "8595": [0.19444, 0.69444, 0, 0],
        "8596": [-0.13313, 0.36687, 0, 0],
        "8597": [0.25, 0.75, 0, 0],
        "8598": [0.19444, 0.69444, 0, 0],
        "8599": [0.19444, 0.69444, 0, 0],
        "8600": [0.19444, 0.69444, 0, 0],
        "8601": [0.19444, 0.69444, 0, 0],
        "8614": [0.011, 0.511, 0, 0],
        "8617": [0.011, 0.511, 0, 0],
        "8618": [0.011, 0.511, 0, 0],
        "8636": [-0.13313, 0.36687, 0, 0],
        "8637": [-0.13313, 0.36687, 0, 0],
        "8640": [-0.13313, 0.36687, 0, 0],
        "8641": [-0.13313, 0.36687, 0, 0],
        "8652": [0.011, 0.671, 0, 0],
        "8656": [-0.13313, 0.36687, 0, 0],
        "8657": [0.19444, 0.69444, 0, 0],
        "8658": [-0.13313, 0.36687, 0, 0],
        "8659": [0.19444, 0.69444, 0, 0],
        "8660": [-0.13313, 0.36687, 0, 0],
        "8661": [0.25, 0.75, 0, 0],
        "8704": [0, 0.69444, 0, 0],
        "8706": [0, 0.69444, 0.05556, 0.08334],
        "8707": [0, 0.69444, 0, 0],
        "8709": [0.05556, 0.75, 0, 0],
        "8711": [0, 0.68333, 0, 0],
        "8712": [0.0391, 0.5391, 0, 0],
        "8715": [0.0391, 0.5391, 0, 0],
        "8722": [0.08333, 0.58333, 0, 0],
        "8723": [0.08333, 0.58333, 0, 0],
        "8725": [0.25, 0.75, 0, 0],
        "8726": [0.25, 0.75, 0, 0],
        "8727": [-0.03472, 0.46528, 0, 0],
        "8728": [-0.05555, 0.44445, 0, 0],
        "8729": [-0.05555, 0.44445, 0, 0],
        "8730": [0.2, 0.8, 0, 0],
        "8733": [0, 0.43056, 0, 0],
        "8734": [0, 0.43056, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8739": [0.25, 0.75, 0, 0],
        "8741": [0.25, 0.75, 0, 0],
        "8743": [0, 0.55556, 0, 0],
        "8744": [0, 0.55556, 0, 0],
        "8745": [0, 0.55556, 0, 0],
        "8746": [0, 0.55556, 0, 0],
        "8747": [0.19444, 0.69444, 0.11111, 0],
        "8764": [-0.13313, 0.36687, 0, 0],
        "8768": [0.19444, 0.69444, 0, 0],
        "8771": [-0.03625, 0.46375, 0, 0],
        "8773": [-0.022, 0.589, 0, 0],
        "8776": [-0.01688, 0.48312, 0, 0],
        "8781": [-0.03625, 0.46375, 0, 0],
        "8784": [-0.133, 0.67, 0, 0],
        "8800": [0.215, 0.716, 0, 0],
        "8801": [-0.03625, 0.46375, 0, 0],
        "8804": [0.13597, 0.63597, 0, 0],
        "8805": [0.13597, 0.63597, 0, 0],
        "8810": [0.0391, 0.5391, 0, 0],
        "8811": [0.0391, 0.5391, 0, 0],
        "8826": [0.0391, 0.5391, 0, 0],
        "8827": [0.0391, 0.5391, 0, 0],
        "8834": [0.0391, 0.5391, 0, 0],
        "8835": [0.0391, 0.5391, 0, 0],
        "8838": [0.13597, 0.63597, 0, 0],
        "8839": [0.13597, 0.63597, 0, 0],
        "8846": [0, 0.55556, 0, 0],
        "8849": [0.13597, 0.63597, 0, 0],
        "8850": [0.13597, 0.63597, 0, 0],
        "8851": [0, 0.55556, 0, 0],
        "8852": [0, 0.55556, 0, 0],
        "8853": [0.08333, 0.58333, 0, 0],
        "8854": [0.08333, 0.58333, 0, 0],
        "8855": [0.08333, 0.58333, 0, 0],
        "8856": [0.08333, 0.58333, 0, 0],
        "8857": [0.08333, 0.58333, 0, 0],
        "8866": [0, 0.69444, 0, 0],
        "8867": [0, 0.69444, 0, 0],
        "8868": [0, 0.69444, 0, 0],
        "8869": [0, 0.69444, 0, 0],
        "8872": [0.249, 0.75, 0, 0],
        "8900": [-0.05555, 0.44445, 0, 0],
        "8901": [-0.05555, 0.44445, 0, 0],
        "8902": [-0.03472, 0.46528, 0, 0],
        "8904": [0.005, 0.505, 0, 0],
        "8942": [0.03, 0.9, 0, 0],
        "8943": [-0.19, 0.31, 0, 0],
        "8945": [-0.1, 0.82, 0, 0],
        "8968": [0.25, 0.75, 0, 0],
        "8969": [0.25, 0.75, 0, 0],
        "8970": [0.25, 0.75, 0, 0],
        "8971": [0.25, 0.75, 0, 0],
        "8994": [-0.14236, 0.35764, 0, 0],
        "8995": [-0.14236, 0.35764, 0, 0],
        "9136": [0.244, 0.744, 0, 0],
        "9137": [0.244, 0.744, 0, 0],
        "9651": [0.19444, 0.69444, 0, 0],
        "9657": [-0.03472, 0.46528, 0, 0],
        "9661": [0.19444, 0.69444, 0, 0],
        "9667": [-0.03472, 0.46528, 0, 0],
        "9711": [0.19444, 0.69444, 0, 0],
        "9824": [0.12963, 0.69444, 0, 0],
        "9825": [0.12963, 0.69444, 0, 0],
        "9826": [0.12963, 0.69444, 0, 0],
        "9827": [0.12963, 0.69444, 0, 0],
        "9837": [0, 0.75, 0, 0],
        "9838": [0.19444, 0.69444, 0, 0],
        "9839": [0.19444, 0.69444, 0, 0],
        "10216": [0.25, 0.75, 0, 0],
        "10217": [0.25, 0.75, 0, 0],
        "10222": [0.244, 0.744, 0, 0],
        "10223": [0.244, 0.744, 0, 0],
        "10229": [0.011, 0.511, 0, 0],
        "10230": [0.011, 0.511, 0, 0],
        "10231": [0.011, 0.511, 0, 0],
        "10232": [0.024, 0.525, 0, 0],
        "10233": [0.024, 0.525, 0, 0],
        "10234": [0.024, 0.525, 0, 0],
        "10236": [0.011, 0.511, 0, 0],
        "10815": [0, 0.68333, 0, 0],
        "10927": [0.13597, 0.63597, 0, 0],
        "10928": [0.13597, 0.63597, 0, 0]
    },
    "Math-BoldItalic": {
        "47": [0.19444, 0.69444, 0, 0],
        "65": [0, 0.68611, 0, 0],
        "66": [0, 0.68611, 0.04835, 0],
        "67": [0, 0.68611, 0.06979, 0],
        "68": [0, 0.68611, 0.03194, 0],
        "69": [0, 0.68611, 0.05451, 0],
        "70": [0, 0.68611, 0.15972, 0],
        "71": [0, 0.68611, 0, 0],
        "72": [0, 0.68611, 0.08229, 0],
        "73": [0, 0.68611, 0.07778, 0],
        "74": [0, 0.68611, 0.10069, 0],
        "75": [0, 0.68611, 0.06979, 0],
        "76": [0, 0.68611, 0, 0],
        "77": [0, 0.68611, 0.11424, 0],
        "78": [0, 0.68611, 0.11424, 0],
        "79": [0, 0.68611, 0.03194, 0],
        "80": [0, 0.68611, 0.15972, 0],
        "81": [0.19444, 0.68611, 0, 0],
        "82": [0, 0.68611, 0.00421, 0],
        "83": [0, 0.68611, 0.05382, 0],
        "84": [0, 0.68611, 0.15972, 0],
        "85": [0, 0.68611, 0.11424, 0],
        "86": [0, 0.68611, 0.25555, 0],
        "87": [0, 0.68611, 0.15972, 0],
        "88": [0, 0.68611, 0.07778, 0],
        "89": [0, 0.68611, 0.25555, 0],
        "90": [0, 0.68611, 0.06979, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0.19444, 0.69444, 0.11042, 0],
        "103": [0.19444, 0.44444, 0.03704, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.69326, 0, 0],
        "106": [0.19444, 0.69326, 0.0622, 0],
        "107": [0, 0.69444, 0.01852, 0],
        "108": [0, 0.69444, 0.0088, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0.03704, 0],
        "114": [0, 0.44444, 0.03194, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.63492, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.03704, 0],
        "119": [0, 0.44444, 0.02778, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.03704, 0],
        "122": [0, 0.44444, 0.04213, 0],
        "915": [0, 0.68611, 0.15972, 0],
        "916": [0, 0.68611, 0, 0],
        "920": [0, 0.68611, 0.03194, 0],
        "923": [0, 0.68611, 0, 0],
        "926": [0, 0.68611, 0.07458, 0],
        "928": [0, 0.68611, 0.08229, 0],
        "931": [0, 0.68611, 0.05451, 0],
        "933": [0, 0.68611, 0.15972, 0],
        "934": [0, 0.68611, 0, 0],
        "936": [0, 0.68611, 0.11653, 0],
        "937": [0, 0.68611, 0.04835, 0],
        "945": [0, 0.44444, 0, 0],
        "946": [0.19444, 0.69444, 0.03403, 0],
        "947": [0.19444, 0.44444, 0.06389, 0],
        "948": [0, 0.69444, 0.03819, 0],
        "949": [0, 0.44444, 0, 0],
        "950": [0.19444, 0.69444, 0.06215, 0],
        "951": [0.19444, 0.44444, 0.03704, 0],
        "952": [0, 0.69444, 0.03194, 0],
        "953": [0, 0.44444, 0, 0],
        "954": [0, 0.44444, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.44444, 0, 0],
        "957": [0, 0.44444, 0.06898, 0],
        "958": [0.19444, 0.69444, 0.03021, 0],
        "959": [0, 0.44444, 0, 0],
        "960": [0, 0.44444, 0.03704, 0],
        "961": [0.19444, 0.44444, 0, 0],
        "962": [0.09722, 0.44444, 0.07917, 0],
        "963": [0, 0.44444, 0.03704, 0],
        "964": [0, 0.44444, 0.13472, 0],
        "965": [0, 0.44444, 0.03704, 0],
        "966": [0.19444, 0.44444, 0, 0],
        "967": [0.19444, 0.44444, 0, 0],
        "968": [0.19444, 0.69444, 0.03704, 0],
        "969": [0, 0.44444, 0.03704, 0],
        "977": [0, 0.69444, 0, 0],
        "981": [0.19444, 0.69444, 0, 0],
        "982": [0, 0.44444, 0.03194, 0],
        "1009": [0.19444, 0.44444, 0, 0],
        "1013": [0, 0.44444, 0, 0]
    },
    "Math-Italic": {
        "47": [0.19444, 0.69444, 0, 0],
        "65": [0, 0.68333, 0, 0.13889],
        "66": [0, 0.68333, 0.05017, 0.08334],
        "67": [0, 0.68333, 0.07153, 0.08334],
        "68": [0, 0.68333, 0.02778, 0.05556],
        "69": [0, 0.68333, 0.05764, 0.08334],
        "70": [0, 0.68333, 0.13889, 0.08334],
        "71": [0, 0.68333, 0, 0.08334],
        "72": [0, 0.68333, 0.08125, 0.05556],
        "73": [0, 0.68333, 0.07847, 0.11111],
        "74": [0, 0.68333, 0.09618, 0.16667],
        "75": [0, 0.68333, 0.07153, 0.05556],
        "76": [0, 0.68333, 0, 0.02778],
        "77": [0, 0.68333, 0.10903, 0.08334],
        "78": [0, 0.68333, 0.10903, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.08334],
        "80": [0, 0.68333, 0.13889, 0.08334],
        "81": [0.19444, 0.68333, 0, 0.08334],
        "82": [0, 0.68333, 0.00773, 0.08334],
        "83": [0, 0.68333, 0.05764, 0.08334],
        "84": [0, 0.68333, 0.13889, 0.08334],
        "85": [0, 0.68333, 0.10903, 0.02778],
        "86": [0, 0.68333, 0.22222, 0],
        "87": [0, 0.68333, 0.13889, 0],
        "88": [0, 0.68333, 0.07847, 0.08334],
        "89": [0, 0.68333, 0.22222, 0],
        "90": [0, 0.68333, 0.07153, 0.08334],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0.05556],
        "100": [0, 0.69444, 0, 0.16667],
        "101": [0, 0.43056, 0, 0.05556],
        "102": [0.19444, 0.69444, 0.10764, 0.16667],
        "103": [0.19444, 0.43056, 0.03588, 0.02778],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.65952, 0, 0],
        "106": [0.19444, 0.65952, 0.05724, 0],
        "107": [0, 0.69444, 0.03148, 0],
        "108": [0, 0.69444, 0.01968, 0.08334],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0.05556],
        "112": [0.19444, 0.43056, 0, 0.08334],
        "113": [0.19444, 0.43056, 0.03588, 0.08334],
        "114": [0, 0.43056, 0.02778, 0.05556],
        "115": [0, 0.43056, 0, 0.05556],
        "116": [0, 0.61508, 0, 0.08334],
        "117": [0, 0.43056, 0, 0.02778],
        "118": [0, 0.43056, 0.03588, 0.02778],
        "119": [0, 0.43056, 0.02691, 0.08334],
        "120": [0, 0.43056, 0, 0.02778],
        "121": [0.19444, 0.43056, 0.03588, 0.05556],
        "122": [0, 0.43056, 0.04398, 0.05556],
        "915": [0, 0.68333, 0.13889, 0.08334],
        "916": [0, 0.68333, 0, 0.16667],
        "920": [0, 0.68333, 0.02778, 0.08334],
        "923": [0, 0.68333, 0, 0.16667],
        "926": [0, 0.68333, 0.07569, 0.08334],
        "928": [0, 0.68333, 0.08125, 0.05556],
        "931": [0, 0.68333, 0.05764, 0.08334],
        "933": [0, 0.68333, 0.13889, 0.05556],
        "934": [0, 0.68333, 0, 0.08334],
        "936": [0, 0.68333, 0.11, 0.05556],
        "937": [0, 0.68333, 0.05017, 0.08334],
        "945": [0, 0.43056, 0.0037, 0.02778],
        "946": [0.19444, 0.69444, 0.05278, 0.08334],
        "947": [0.19444, 0.43056, 0.05556, 0],
        "948": [0, 0.69444, 0.03785, 0.05556],
        "949": [0, 0.43056, 0, 0.08334],
        "950": [0.19444, 0.69444, 0.07378, 0.08334],
        "951": [0.19444, 0.43056, 0.03588, 0.05556],
        "952": [0, 0.69444, 0.02778, 0.08334],
        "953": [0, 0.43056, 0, 0.05556],
        "954": [0, 0.43056, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.43056, 0, 0.02778],
        "957": [0, 0.43056, 0.06366, 0.02778],
        "958": [0.19444, 0.69444, 0.04601, 0.11111],
        "959": [0, 0.43056, 0, 0.05556],
        "960": [0, 0.43056, 0.03588, 0],
        "961": [0.19444, 0.43056, 0, 0.08334],
        "962": [0.09722, 0.43056, 0.07986, 0.08334],
        "963": [0, 0.43056, 0.03588, 0],
        "964": [0, 0.43056, 0.1132, 0.02778],
        "965": [0, 0.43056, 0.03588, 0.02778],
        "966": [0.19444, 0.43056, 0, 0.08334],
        "967": [0.19444, 0.43056, 0, 0.05556],
        "968": [0.19444, 0.69444, 0.03588, 0.11111],
        "969": [0, 0.43056, 0.03588, 0],
        "977": [0, 0.69444, 0, 0.08334],
        "981": [0.19444, 0.69444, 0, 0.08334],
        "982": [0, 0.43056, 0.02778, 0],
        "1009": [0.19444, 0.43056, 0, 0.08334],
        "1013": [0, 0.43056, 0, 0.05556]
    },
    "Math-Regular": {
        "65": [0, 0.68333, 0, 0.13889],
        "66": [0, 0.68333, 0.05017, 0.08334],
        "67": [0, 0.68333, 0.07153, 0.08334],
        "68": [0, 0.68333, 0.02778, 0.05556],
        "69": [0, 0.68333, 0.05764, 0.08334],
        "70": [0, 0.68333, 0.13889, 0.08334],
        "71": [0, 0.68333, 0, 0.08334],
        "72": [0, 0.68333, 0.08125, 0.05556],
        "73": [0, 0.68333, 0.07847, 0.11111],
        "74": [0, 0.68333, 0.09618, 0.16667],
        "75": [0, 0.68333, 0.07153, 0.05556],
        "76": [0, 0.68333, 0, 0.02778],
        "77": [0, 0.68333, 0.10903, 0.08334],
        "78": [0, 0.68333, 0.10903, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.08334],
        "80": [0, 0.68333, 0.13889, 0.08334],
        "81": [0.19444, 0.68333, 0, 0.08334],
        "82": [0, 0.68333, 0.00773, 0.08334],
        "83": [0, 0.68333, 0.05764, 0.08334],
        "84": [0, 0.68333, 0.13889, 0.08334],
        "85": [0, 0.68333, 0.10903, 0.02778],
        "86": [0, 0.68333, 0.22222, 0],
        "87": [0, 0.68333, 0.13889, 0],
        "88": [0, 0.68333, 0.07847, 0.08334],
        "89": [0, 0.68333, 0.22222, 0],
        "90": [0, 0.68333, 0.07153, 0.08334],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0.05556],
        "100": [0, 0.69444, 0, 0.16667],
        "101": [0, 0.43056, 0, 0.05556],
        "102": [0.19444, 0.69444, 0.10764, 0.16667],
        "103": [0.19444, 0.43056, 0.03588, 0.02778],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.65952, 0, 0],
        "106": [0.19444, 0.65952, 0.05724, 0],
        "107": [0, 0.69444, 0.03148, 0],
        "108": [0, 0.69444, 0.01968, 0.08334],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0.05556],
        "112": [0.19444, 0.43056, 0, 0.08334],
        "113": [0.19444, 0.43056, 0.03588, 0.08334],
        "114": [0, 0.43056, 0.02778, 0.05556],
        "115": [0, 0.43056, 0, 0.05556],
        "116": [0, 0.61508, 0, 0.08334],
        "117": [0, 0.43056, 0, 0.02778],
        "118": [0, 0.43056, 0.03588, 0.02778],
        "119": [0, 0.43056, 0.02691, 0.08334],
        "120": [0, 0.43056, 0, 0.02778],
        "121": [0.19444, 0.43056, 0.03588, 0.05556],
        "122": [0, 0.43056, 0.04398, 0.05556],
        "915": [0, 0.68333, 0.13889, 0.08334],
        "916": [0, 0.68333, 0, 0.16667],
        "920": [0, 0.68333, 0.02778, 0.08334],
        "923": [0, 0.68333, 0, 0.16667],
        "926": [0, 0.68333, 0.07569, 0.08334],
        "928": [0, 0.68333, 0.08125, 0.05556],
        "931": [0, 0.68333, 0.05764, 0.08334],
        "933": [0, 0.68333, 0.13889, 0.05556],
        "934": [0, 0.68333, 0, 0.08334],
        "936": [0, 0.68333, 0.11, 0.05556],
        "937": [0, 0.68333, 0.05017, 0.08334],
        "945": [0, 0.43056, 0.0037, 0.02778],
        "946": [0.19444, 0.69444, 0.05278, 0.08334],
        "947": [0.19444, 0.43056, 0.05556, 0],
        "948": [0, 0.69444, 0.03785, 0.05556],
        "949": [0, 0.43056, 0, 0.08334],
        "950": [0.19444, 0.69444, 0.07378, 0.08334],
        "951": [0.19444, 0.43056, 0.03588, 0.05556],
        "952": [0, 0.69444, 0.02778, 0.08334],
        "953": [0, 0.43056, 0, 0.05556],
        "954": [0, 0.43056, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.43056, 0, 0.02778],
        "957": [0, 0.43056, 0.06366, 0.02778],
        "958": [0.19444, 0.69444, 0.04601, 0.11111],
        "959": [0, 0.43056, 0, 0.05556],
        "960": [0, 0.43056, 0.03588, 0],
        "961": [0.19444, 0.43056, 0, 0.08334],
        "962": [0.09722, 0.43056, 0.07986, 0.08334],
        "963": [0, 0.43056, 0.03588, 0],
        "964": [0, 0.43056, 0.1132, 0.02778],
        "965": [0, 0.43056, 0.03588, 0.02778],
        "966": [0.19444, 0.43056, 0, 0.08334],
        "967": [0.19444, 0.43056, 0, 0.05556],
        "968": [0.19444, 0.69444, 0.03588, 0.11111],
        "969": [0, 0.43056, 0.03588, 0],
        "977": [0, 0.69444, 0, 0.08334],
        "981": [0.19444, 0.69444, 0, 0.08334],
        "982": [0, 0.43056, 0.02778, 0],
        "1009": [0.19444, 0.43056, 0, 0.08334],
        "1013": [0, 0.43056, 0, 0.05556]
    },
    "SansSerif-Regular": {
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.08333, 0.58333, 0, 0],
        "44": [0.125, 0.08333, 0, 0],
        "45": [0, 0.44444, 0, 0],
        "46": [0, 0.08333, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.65556, 0, 0],
        "49": [0, 0.65556, 0, 0],
        "50": [0, 0.65556, 0, 0],
        "51": [0, 0.65556, 0, 0],
        "52": [0, 0.65556, 0, 0],
        "53": [0, 0.65556, 0, 0],
        "54": [0, 0.65556, 0, 0],
        "55": [0, 0.65556, 0, 0],
        "56": [0, 0.65556, 0, 0],
        "57": [0, 0.65556, 0, 0],
        "58": [0, 0.44444, 0, 0],
        "59": [0.125, 0.44444, 0, 0],
        "61": [-0.13, 0.37, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.69444, 0, 0],
        "66": [0, 0.69444, 0, 0],
        "67": [0, 0.69444, 0, 0],
        "68": [0, 0.69444, 0, 0],
        "69": [0, 0.69444, 0, 0],
        "70": [0, 0.69444, 0, 0],
        "71": [0, 0.69444, 0, 0],
        "72": [0, 0.69444, 0, 0],
        "73": [0, 0.69444, 0, 0],
        "74": [0, 0.69444, 0, 0],
        "75": [0, 0.69444, 0, 0],
        "76": [0, 0.69444, 0, 0],
        "77": [0, 0.69444, 0, 0],
        "78": [0, 0.69444, 0, 0],
        "79": [0, 0.69444, 0, 0],
        "80": [0, 0.69444, 0, 0],
        "81": [0.125, 0.69444, 0, 0],
        "82": [0, 0.69444, 0, 0],
        "83": [0, 0.69444, 0, 0],
        "84": [0, 0.69444, 0, 0],
        "85": [0, 0.69444, 0, 0],
        "86": [0, 0.69444, 0.01389, 0],
        "87": [0, 0.69444, 0.01389, 0],
        "88": [0, 0.69444, 0, 0],
        "89": [0, 0.69444, 0.025, 0],
        "90": [0, 0.69444, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.35, 0.09444, 0.02778, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0, 0.69444, 0.06944, 0],
        "103": [0.19444, 0.44444, 0.01389, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.67937, 0, 0],
        "106": [0.19444, 0.67937, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0, 0],
        "114": [0, 0.44444, 0.01389, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.57143, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.01389, 0],
        "119": [0, 0.44444, 0.01389, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.01389, 0],
        "122": [0, 0.44444, 0, 0],
        "126": [0.35, 0.32659, 0, 0],
        "305": [0, 0.44444, 0, 0],
        "567": [0.19444, 0.44444, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.67659, 0, 0],
        "772": [0, 0.60889, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.67937, 0, 0],
        "776": [0, 0.67937, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.63194, 0, 0],
        "915": [0, 0.69444, 0, 0],
        "916": [0, 0.69444, 0, 0],
        "920": [0, 0.69444, 0, 0],
        "923": [0, 0.69444, 0, 0],
        "926": [0, 0.69444, 0, 0],
        "928": [0, 0.69444, 0, 0],
        "931": [0, 0.69444, 0, 0],
        "933": [0, 0.69444, 0, 0],
        "934": [0, 0.69444, 0, 0],
        "936": [0, 0.69444, 0, 0],
        "937": [0, 0.69444, 0, 0],
        "8211": [0, 0.44444, 0.02778, 0],
        "8212": [0, 0.44444, 0.02778, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0]
    },
    "Script-Regular": {
        "65": [0, 0.7, 0.22925, 0],
        "66": [0, 0.7, 0.04087, 0],
        "67": [0, 0.7, 0.1689, 0],
        "68": [0, 0.7, 0.09371, 0],
        "69": [0, 0.7, 0.18583, 0],
        "70": [0, 0.7, 0.13634, 0],
        "71": [0, 0.7, 0.17322, 0],
        "72": [0, 0.7, 0.29694, 0],
        "73": [0, 0.7, 0.19189, 0],
        "74": [0.27778, 0.7, 0.19189, 0],
        "75": [0, 0.7, 0.31259, 0],
        "76": [0, 0.7, 0.19189, 0],
        "77": [0, 0.7, 0.15981, 0],
        "78": [0, 0.7, 0.3525, 0],
        "79": [0, 0.7, 0.08078, 0],
        "80": [0, 0.7, 0.08078, 0],
        "81": [0, 0.7, 0.03305, 0],
        "82": [0, 0.7, 0.06259, 0],
        "83": [0, 0.7, 0.19189, 0],
        "84": [0, 0.7, 0.29087, 0],
        "85": [0, 0.7, 0.25815, 0],
        "86": [0, 0.7, 0.27523, 0],
        "87": [0, 0.7, 0.27523, 0],
        "88": [0, 0.7, 0.26006, 0],
        "89": [0, 0.7, 0.2939, 0],
        "90": [0, 0.7, 0.24037, 0]
    },
    "Size1-Regular": {
        "40": [0.35001, 0.85, 0, 0],
        "41": [0.35001, 0.85, 0, 0],
        "47": [0.35001, 0.85, 0, 0],
        "91": [0.35001, 0.85, 0, 0],
        "92": [0.35001, 0.85, 0, 0],
        "93": [0.35001, 0.85, 0, 0],
        "123": [0.35001, 0.85, 0, 0],
        "125": [0.35001, 0.85, 0, 0],
        "710": [0, 0.72222, 0, 0],
        "732": [0, 0.72222, 0, 0],
        "770": [0, 0.72222, 0, 0],
        "771": [0, 0.72222, 0, 0],
        "8214": [-0.00099, 0.601, 0, 0],
        "8593": [1e-05, 0.6, 0, 0],
        "8595": [1e-05, 0.6, 0, 0],
        "8657": [1e-05, 0.6, 0, 0],
        "8659": [1e-05, 0.6, 0, 0],
        "8719": [0.25001, 0.75, 0, 0],
        "8720": [0.25001, 0.75, 0, 0],
        "8721": [0.25001, 0.75, 0, 0],
        "8730": [0.35001, 0.85, 0, 0],
        "8739": [-0.00599, 0.606, 0, 0],
        "8741": [-0.00599, 0.606, 0, 0],
        "8747": [0.30612, 0.805, 0.19445, 0],
        "8748": [0.306, 0.805, 0.19445, 0],
        "8749": [0.306, 0.805, 0.19445, 0],
        "8750": [0.30612, 0.805, 0.19445, 0],
        "8896": [0.25001, 0.75, 0, 0],
        "8897": [0.25001, 0.75, 0, 0],
        "8898": [0.25001, 0.75, 0, 0],
        "8899": [0.25001, 0.75, 0, 0],
        "8968": [0.35001, 0.85, 0, 0],
        "8969": [0.35001, 0.85, 0, 0],
        "8970": [0.35001, 0.85, 0, 0],
        "8971": [0.35001, 0.85, 0, 0],
        "9168": [-0.00099, 0.601, 0, 0],
        "10216": [0.35001, 0.85, 0, 0],
        "10217": [0.35001, 0.85, 0, 0],
        "10752": [0.25001, 0.75, 0, 0],
        "10753": [0.25001, 0.75, 0, 0],
        "10754": [0.25001, 0.75, 0, 0],
        "10756": [0.25001, 0.75, 0, 0],
        "10758": [0.25001, 0.75, 0, 0]
    },
    "Size2-Regular": {
        "40": [0.65002, 1.15, 0, 0],
        "41": [0.65002, 1.15, 0, 0],
        "47": [0.65002, 1.15, 0, 0],
        "91": [0.65002, 1.15, 0, 0],
        "92": [0.65002, 1.15, 0, 0],
        "93": [0.65002, 1.15, 0, 0],
        "123": [0.65002, 1.15, 0, 0],
        "125": [0.65002, 1.15, 0, 0],
        "710": [0, 0.75, 0, 0],
        "732": [0, 0.75, 0, 0],
        "770": [0, 0.75, 0, 0],
        "771": [0, 0.75, 0, 0],
        "8719": [0.55001, 1.05, 0, 0],
        "8720": [0.55001, 1.05, 0, 0],
        "8721": [0.55001, 1.05, 0, 0],
        "8730": [0.65002, 1.15, 0, 0],
        "8747": [0.86225, 1.36, 0.44445, 0],
        "8748": [0.862, 1.36, 0.44445, 0],
        "8749": [0.862, 1.36, 0.44445, 0],
        "8750": [0.86225, 1.36, 0.44445, 0],
        "8896": [0.55001, 1.05, 0, 0],
        "8897": [0.55001, 1.05, 0, 0],
        "8898": [0.55001, 1.05, 0, 0],
        "8899": [0.55001, 1.05, 0, 0],
        "8968": [0.65002, 1.15, 0, 0],
        "8969": [0.65002, 1.15, 0, 0],
        "8970": [0.65002, 1.15, 0, 0],
        "8971": [0.65002, 1.15, 0, 0],
        "10216": [0.65002, 1.15, 0, 0],
        "10217": [0.65002, 1.15, 0, 0],
        "10752": [0.55001, 1.05, 0, 0],
        "10753": [0.55001, 1.05, 0, 0],
        "10754": [0.55001, 1.05, 0, 0],
        "10756": [0.55001, 1.05, 0, 0],
        "10758": [0.55001, 1.05, 0, 0]
    },
    "Size3-Regular": {
        "40": [0.95003, 1.45, 0, 0],
        "41": [0.95003, 1.45, 0, 0],
        "47": [0.95003, 1.45, 0, 0],
        "91": [0.95003, 1.45, 0, 0],
        "92": [0.95003, 1.45, 0, 0],
        "93": [0.95003, 1.45, 0, 0],
        "123": [0.95003, 1.45, 0, 0],
        "125": [0.95003, 1.45, 0, 0],
        "710": [0, 0.75, 0, 0],
        "732": [0, 0.75, 0, 0],
        "770": [0, 0.75, 0, 0],
        "771": [0, 0.75, 0, 0],
        "8730": [0.95003, 1.45, 0, 0],
        "8968": [0.95003, 1.45, 0, 0],
        "8969": [0.95003, 1.45, 0, 0],
        "8970": [0.95003, 1.45, 0, 0],
        "8971": [0.95003, 1.45, 0, 0],
        "10216": [0.95003, 1.45, 0, 0],
        "10217": [0.95003, 1.45, 0, 0]
    },
    "Size4-Regular": {
        "40": [1.25003, 1.75, 0, 0],
        "41": [1.25003, 1.75, 0, 0],
        "47": [1.25003, 1.75, 0, 0],
        "91": [1.25003, 1.75, 0, 0],
        "92": [1.25003, 1.75, 0, 0],
        "93": [1.25003, 1.75, 0, 0],
        "123": [1.25003, 1.75, 0, 0],
        "125": [1.25003, 1.75, 0, 0],
        "710": [0, 0.825, 0, 0],
        "732": [0, 0.825, 0, 0],
        "770": [0, 0.825, 0, 0],
        "771": [0, 0.825, 0, 0],
        "8730": [1.25003, 1.75, 0, 0],
        "8968": [1.25003, 1.75, 0, 0],
        "8969": [1.25003, 1.75, 0, 0],
        "8970": [1.25003, 1.75, 0, 0],
        "8971": [1.25003, 1.75, 0, 0],
        "9115": [0.64502, 1.155, 0, 0],
        "9116": [1e-05, 0.6, 0, 0],
        "9117": [0.64502, 1.155, 0, 0],
        "9118": [0.64502, 1.155, 0, 0],
        "9119": [1e-05, 0.6, 0, 0],
        "9120": [0.64502, 1.155, 0, 0],
        "9121": [0.64502, 1.155, 0, 0],
        "9122": [-0.00099, 0.601, 0, 0],
        "9123": [0.64502, 1.155, 0, 0],
        "9124": [0.64502, 1.155, 0, 0],
        "9125": [-0.00099, 0.601, 0, 0],
        "9126": [0.64502, 1.155, 0, 0],
        "9127": [1e-05, 0.9, 0, 0],
        "9128": [0.65002, 1.15, 0, 0],
        "9129": [0.90001, 0, 0, 0],
        "9130": [0, 0.3, 0, 0],
        "9131": [1e-05, 0.9, 0, 0],
        "9132": [0.65002, 1.15, 0, 0],
        "9133": [0.90001, 0, 0, 0],
        "9143": [0.88502, 0.915, 0, 0],
        "10216": [1.25003, 1.75, 0, 0],
        "10217": [1.25003, 1.75, 0, 0],
        "57344": [-0.00499, 0.605, 0, 0],
        "57345": [-0.00499, 0.605, 0, 0],
        "57680": [0, 0.12, 0, 0],
        "57681": [0, 0.12, 0, 0],
        "57682": [0, 0.12, 0, 0],
        "57683": [0, 0.12, 0, 0]
    },
    "Typewriter-Regular": {
        "33": [0, 0.61111, 0, 0],
        "34": [0, 0.61111, 0, 0],
        "35": [0, 0.61111, 0, 0],
        "36": [0.08333, 0.69444, 0, 0],
        "37": [0.08333, 0.69444, 0, 0],
        "38": [0, 0.61111, 0, 0],
        "39": [0, 0.61111, 0, 0],
        "40": [0.08333, 0.69444, 0, 0],
        "41": [0.08333, 0.69444, 0, 0],
        "42": [0, 0.52083, 0, 0],
        "43": [-0.08056, 0.53055, 0, 0],
        "44": [0.13889, 0.125, 0, 0],
        "45": [-0.08056, 0.53055, 0, 0],
        "46": [0, 0.125, 0, 0],
        "47": [0.08333, 0.69444, 0, 0],
        "48": [0, 0.61111, 0, 0],
        "49": [0, 0.61111, 0, 0],
        "50": [0, 0.61111, 0, 0],
        "51": [0, 0.61111, 0, 0],
        "52": [0, 0.61111, 0, 0],
        "53": [0, 0.61111, 0, 0],
        "54": [0, 0.61111, 0, 0],
        "55": [0, 0.61111, 0, 0],
        "56": [0, 0.61111, 0, 0],
        "57": [0, 0.61111, 0, 0],
        "58": [0, 0.43056, 0, 0],
        "59": [0.13889, 0.43056, 0, 0],
        "60": [-0.05556, 0.55556, 0, 0],
        "61": [-0.19549, 0.41562, 0, 0],
        "62": [-0.05556, 0.55556, 0, 0],
        "63": [0, 0.61111, 0, 0],
        "64": [0, 0.61111, 0, 0],
        "65": [0, 0.61111, 0, 0],
        "66": [0, 0.61111, 0, 0],
        "67": [0, 0.61111, 0, 0],
        "68": [0, 0.61111, 0, 0],
        "69": [0, 0.61111, 0, 0],
        "70": [0, 0.61111, 0, 0],
        "71": [0, 0.61111, 0, 0],
        "72": [0, 0.61111, 0, 0],
        "73": [0, 0.61111, 0, 0],
        "74": [0, 0.61111, 0, 0],
        "75": [0, 0.61111, 0, 0],
        "76": [0, 0.61111, 0, 0],
        "77": [0, 0.61111, 0, 0],
        "78": [0, 0.61111, 0, 0],
        "79": [0, 0.61111, 0, 0],
        "80": [0, 0.61111, 0, 0],
        "81": [0.13889, 0.61111, 0, 0],
        "82": [0, 0.61111, 0, 0],
        "83": [0, 0.61111, 0, 0],
        "84": [0, 0.61111, 0, 0],
        "85": [0, 0.61111, 0, 0],
        "86": [0, 0.61111, 0, 0],
        "87": [0, 0.61111, 0, 0],
        "88": [0, 0.61111, 0, 0],
        "89": [0, 0.61111, 0, 0],
        "90": [0, 0.61111, 0, 0],
        "91": [0.08333, 0.69444, 0, 0],
        "92": [0.08333, 0.69444, 0, 0],
        "93": [0.08333, 0.69444, 0, 0],
        "94": [0, 0.61111, 0, 0],
        "95": [0.09514, 0, 0, 0],
        "96": [0, 0.61111, 0, 0],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.61111, 0, 0],
        "99": [0, 0.43056, 0, 0],
        "100": [0, 0.61111, 0, 0],
        "101": [0, 0.43056, 0, 0],
        "102": [0, 0.61111, 0, 0],
        "103": [0.22222, 0.43056, 0, 0],
        "104": [0, 0.61111, 0, 0],
        "105": [0, 0.61111, 0, 0],
        "106": [0.22222, 0.61111, 0, 0],
        "107": [0, 0.61111, 0, 0],
        "108": [0, 0.61111, 0, 0],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0],
        "112": [0.22222, 0.43056, 0, 0],
        "113": [0.22222, 0.43056, 0, 0],
        "114": [0, 0.43056, 0, 0],
        "115": [0, 0.43056, 0, 0],
        "116": [0, 0.55358, 0, 0],
        "117": [0, 0.43056, 0, 0],
        "118": [0, 0.43056, 0, 0],
        "119": [0, 0.43056, 0, 0],
        "120": [0, 0.43056, 0, 0],
        "121": [0.22222, 0.43056, 0, 0],
        "122": [0, 0.43056, 0, 0],
        "123": [0.08333, 0.69444, 0, 0],
        "124": [0.08333, 0.69444, 0, 0],
        "125": [0.08333, 0.69444, 0, 0],
        "126": [0, 0.61111, 0, 0],
        "127": [0, 0.61111, 0, 0],
        "305": [0, 0.43056, 0, 0],
        "567": [0.22222, 0.43056, 0, 0],
        "768": [0, 0.61111, 0, 0],
        "769": [0, 0.61111, 0, 0],
        "770": [0, 0.61111, 0, 0],
        "771": [0, 0.61111, 0, 0],
        "772": [0, 0.56555, 0, 0],
        "774": [0, 0.61111, 0, 0],
        "776": [0, 0.61111, 0, 0],
        "778": [0, 0.61111, 0, 0],
        "780": [0, 0.56597, 0, 0],
        "915": [0, 0.61111, 0, 0],
        "916": [0, 0.61111, 0, 0],
        "920": [0, 0.61111, 0, 0],
        "923": [0, 0.61111, 0, 0],
        "926": [0, 0.61111, 0, 0],
        "928": [0, 0.61111, 0, 0],
        "931": [0, 0.61111, 0, 0],
        "933": [0, 0.61111, 0, 0],
        "934": [0, 0.61111, 0, 0],
        "936": [0, 0.61111, 0, 0],
        "937": [0, 0.61111, 0, 0],
        "2018": [0, 0.61111, 0, 0],
        "2019": [0, 0.61111, 0, 0],
        "8242": [0, 0.61111, 0, 0]
    }
};

},{}],94:[function(require,module,exports){
var utils = require("./utils");
var ParseError = require("./ParseError");
var parseData = require("./parseData");
var ParseNode = parseData.ParseNode;

/* This file contains a list of functions that we parse, identified by
 * the calls to defineFunction.
 *
 * The first argument to defineFunction is a single name or a list of names.
 * All functions named in such a list will share a single implementation.
 *
 * Each declared function can have associated properties, which
 * include the following:
 *
 *  - numArgs: The number of arguments the function takes.
 *             If this is the only property, it can be passed as a number
 *             instead of an element of a properties object.
 *  - argTypes: (optional) An array corresponding to each argument of the
 *              function, giving the type of argument that should be parsed. Its
 *              length should be equal to `numArgs + numOptionalArgs`. Valid
 *              types:
 *               - "size": A size-like thing, such as "1em" or "5ex"
 *               - "color": An html color, like "#abc" or "blue"
 *               - "original": The same type as the environment that the
 *                             function being parsed is in (e.g. used for the
 *                             bodies of functions like \color where the first
 *                             argument is special and the second argument is
 *                             parsed normally)
 *              Other possible types (probably shouldn't be used)
 *               - "text": Text-like (e.g. \text)
 *               - "math": Normal math
 *              If undefined, this will be treated as an appropriate length
 *              array of "original" strings
 *  - greediness: (optional) The greediness of the function to use ungrouped
 *                arguments.
 *
 *                E.g. if you have an expression
 *                  \sqrt \frac 1 2
 *                since \frac has greediness=2 vs \sqrt's greediness=1, \frac
 *                will use the two arguments '1' and '2' as its two arguments,
 *                then that whole function will be used as the argument to
 *                \sqrt. On the other hand, the expressions
 *                  \frac \frac 1 2 3
 *                and
 *                  \frac \sqrt 1 2
 *                will fail because \frac and \frac have equal greediness
 *                and \sqrt has a lower greediness than \frac respectively. To
 *                make these parse, we would have to change them to:
 *                  \frac {\frac 1 2} 3
 *                and
 *                  \frac {\sqrt 1} 2
 *
 *                The default value is `1`
 *  - allowedInText: (optional) Whether or not the function is allowed inside
 *                   text mode (default false)
 *  - numOptionalArgs: (optional) The number of optional arguments the function
 *                     should parse. If the optional arguments aren't found,
 *                     `null` will be passed to the handler in their place.
 *                     (default 0)
 *  - infix: (optional) Must be true if the function is an infix operator.
 *
 * The last argument is that implementation, the handler for the function(s).
 * It is called to handle these functions and their arguments.
 * It receives two arguments:
 *  - context contains information and references provided by the parser
 *  - args is an array of arguments obtained from TeX input
 * The context contains the following properties:
 *  - funcName: the text (i.e. name) of the function, including \
 *  - parser: the parser object
 *  - lexer: the lexer object
 *  - positions: the positions in the overall string of the function
 *               and the arguments.
 * The latter three should only be used to produce error messages.
 *
 * The function should return an object with the following keys:
 *  - type: The type of element that this is. This is then used in
 *          buildHTML/buildMathML to determine which function
 *          should be called to build this node into a DOM node
 * Any other data can be added to the object, which will be passed
 * in to the function in buildHTML/buildMathML as `group.value`.
 */

function defineFunction(names, props, handler) {
    if (typeof names === "string") {
        names = [names];
    }
    if (typeof props === "number") {
        props = { numArgs: props };
    }
    // Set default values of functions
    var data = {
        numArgs: props.numArgs,
        argTypes: props.argTypes,
        greediness: (props.greediness === undefined) ? 1 : props.greediness,
        allowedInText: !!props.allowedInText,
        numOptionalArgs: props.numOptionalArgs || 0,
        infix: !!props.infix,
        handler: handler
    };
    for (var i = 0; i < names.length; ++i) {
        module.exports[names[i]] = data;
    }
}

// Since the corresponding buildHTML/buildMathML function expects a
// list of elements, we normalize for different kinds of arguments
var ordargument = function(arg) {
    if (arg.type === "ordgroup") {
        return arg.value;
    } else {
        return [arg];
    }
};

// A normal square root
defineFunction("\\sqrt", {
    numArgs: 1,
    numOptionalArgs: 1
}, function(context, args) {
    var index = args[0];
    var body = args[1];
    return {
        type: "sqrt",
        body: body,
        index: index
    };
});

// Non-mathy text, possibly in a font
var textFunctionStyles = {
    "\\text": undefined, "\\textrm": "mathrm", "\\textsf": "mathsf",
    "\\texttt": "mathtt", "\\textnormal": "mathrm", "\\textbf": "mathbf",
    "\\textit": "textit"
};

defineFunction([
    "\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal",
    "\\textbf", "\\textit"
], {
    numArgs: 1,
    argTypes: ["text"],
    greediness: 2,
    allowedInText: true
}, function(context, args) {
    var body = args[0];
    return {
        type: "text",
        body: ordargument(body),
        style: textFunctionStyles[context.funcName]
    };
});

// A two-argument custom color
defineFunction("\\color", {
    numArgs: 2,
    allowedInText: true,
    greediness: 3,
    argTypes: ["color", "original"]
}, function(context, args) {
    var color = args[0];
    var body = args[1];
    return {
        type: "color",
        color: color.value,
        value: ordargument(body)
    };
});

// An overline
defineFunction("\\overline", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "overline",
        body: body
    };
});

// An underline
defineFunction("\\underline", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "underline",
        body: body
    };
});

// A box of the width and height
defineFunction("\\rule", {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
}, function(context, args) {
    var shift = args[0];
    var width = args[1];
    var height = args[2];
    return {
        type: "rule",
        shift: shift && shift.value,
        width: width.value,
        height: height.value
    };
});

// TODO: In TeX, \mkern only accepts mu-units, and \kern does not accept
// mu-units. In current KaTeX we relax this; both commands accept any unit.
defineFunction(["\\kern", "\\mkern"], {
    numArgs: 1,
    argTypes: ["size"]
}, function(context, args) {
    return {
        type: "kern",
        dimension: args[0].value
    };
});

// A KaTeX logo
defineFunction("\\KaTeX", {
    numArgs: 0
}, function(context) {
    return {
        type: "katex"
    };
});

defineFunction("\\phantom", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "phantom",
        value: ordargument(body)
    };
});

// Math class commands except \mathop
defineFunction([
    "\\mathord", "\\mathbin", "\\mathrel", "\\mathopen",
    "\\mathclose", "\\mathpunct", "\\mathinner"
], {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "mclass",
        mclass: "m" + context.funcName.substr(5),
        value: ordargument(body)
    };
});

// Build a relation by placing one symbol on top of another
defineFunction("\\stackrel", {
    numArgs: 2
}, function(context, args) {
    var top = args[0];
    var bottom = args[1];

    var bottomop = new ParseNode("op", {
        type: "op",
        limits: true,
        alwaysHandleSupSub: true,
        symbol: false,
        value: ordargument(bottom)
    }, bottom.mode);

    var supsub = new ParseNode("supsub", {
        base: bottomop,
        sup: top,
        sub: null
    }, top.mode);

    return {
        type: "mclass",
        mclass: "mrel",
        value: [supsub]
    };
});

// \mod-type functions
defineFunction("\\bmod", {
    numArgs: 0
}, function(context, args) {
    return {
        type: "mod",
        modType: "bmod",
        value: null
    };
});

defineFunction(["\\pod", "\\pmod", "\\mod"], {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "mod",
        modType: context.funcName.substr(1),
        value: ordargument(body)
    };
});

// Extra data needed for the delimiter handler down below
var delimiterSizes = {
    "\\bigl" : {mclass: "mopen",    size: 1},
    "\\Bigl" : {mclass: "mopen",    size: 2},
    "\\biggl": {mclass: "mopen",    size: 3},
    "\\Biggl": {mclass: "mopen",    size: 4},
    "\\bigr" : {mclass: "mclose",   size: 1},
    "\\Bigr" : {mclass: "mclose",   size: 2},
    "\\biggr": {mclass: "mclose",   size: 3},
    "\\Biggr": {mclass: "mclose",   size: 4},
    "\\bigm" : {mclass: "mrel",     size: 1},
    "\\Bigm" : {mclass: "mrel",     size: 2},
    "\\biggm": {mclass: "mrel",     size: 3},
    "\\Biggm": {mclass: "mrel",     size: 4},
    "\\big"  : {mclass: "mord",     size: 1},
    "\\Big"  : {mclass: "mord",     size: 2},
    "\\bigg" : {mclass: "mord",     size: 3},
    "\\Bigg" : {mclass: "mord",     size: 4}
};

var delimiters = [
    "(", ")", "[", "\\lbrack", "]", "\\rbrack",
    "\\{", "\\lbrace", "\\}", "\\rbrace",
    "\\lfloor", "\\rfloor", "\\lceil", "\\rceil",
    "<", ">", "\\langle", "\\rangle", "\\lt", "\\gt",
    "\\lvert", "\\rvert", "\\lVert", "\\rVert",
    "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache",
    "/", "\\backslash",
    "|", "\\vert", "\\|", "\\Vert",
    "\\uparrow", "\\Uparrow",
    "\\downarrow", "\\Downarrow",
    "\\updownarrow", "\\Updownarrow",
    "."
];

var fontAliases = {
    "\\Bbb": "\\mathbb",
    "\\bold": "\\mathbf",
    "\\frak": "\\mathfrak"
};

// Single-argument color functions
defineFunction([
    "\\blue", "\\orange", "\\pink", "\\red",
    "\\green", "\\gray", "\\purple",
    "\\blueA", "\\blueB", "\\blueC", "\\blueD", "\\blueE",
    "\\tealA", "\\tealB", "\\tealC", "\\tealD", "\\tealE",
    "\\greenA", "\\greenB", "\\greenC", "\\greenD", "\\greenE",
    "\\goldA", "\\goldB", "\\goldC", "\\goldD", "\\goldE",
    "\\redA", "\\redB", "\\redC", "\\redD", "\\redE",
    "\\maroonA", "\\maroonB", "\\maroonC", "\\maroonD", "\\maroonE",
    "\\purpleA", "\\purpleB", "\\purpleC", "\\purpleD", "\\purpleE",
    "\\mintA", "\\mintB", "\\mintC",
    "\\grayA", "\\grayB", "\\grayC", "\\grayD", "\\grayE",
    "\\grayF", "\\grayG", "\\grayH", "\\grayI",
    "\\kaBlue", "\\kaGreen"
], {
    numArgs: 1,
    allowedInText: true,
    greediness: 3
}, function(context, args) {
    var body = args[0];
    return {
        type: "color",
        color: "katex-" + context.funcName.slice(1),
        value: ordargument(body)
    };
});

// There are 2 flags for operators; whether they produce limits in
// displaystyle, and whether they are symbols and should grow in
// displaystyle. These four groups cover the four possible choices.

// No limits, not symbols
defineFunction([
    "\\arcsin", "\\arccos", "\\arctan", "\\arg", "\\cos", "\\cosh",
    "\\cot", "\\coth", "\\csc", "\\deg", "\\dim", "\\exp", "\\hom",
    "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh",
    "\\tan", "\\tanh"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: false,
        symbol: false,
        body: context.funcName
    };
});

// Limits, not symbols
defineFunction([
    "\\det", "\\gcd", "\\inf", "\\lim", "\\liminf", "\\limsup", "\\max",
    "\\min", "\\Pr", "\\sup"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: true,
        symbol: false,
        body: context.funcName
    };
});

// No limits, symbols
defineFunction([
    "\\int", "\\iint", "\\iiint", "\\oint"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: false,
        symbol: true,
        body: context.funcName
    };
});

// Limits, symbols
defineFunction([
    "\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap",
    "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes",
    "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: true,
        symbol: true,
        body: context.funcName
    };
});

// \mathop class command
defineFunction("\\mathop", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "op",
        limits: false,
        symbol: false,
        value: ordargument(body)
    };
});

// Fractions
defineFunction([
    "\\dfrac", "\\frac", "\\tfrac",
    "\\dbinom", "\\binom", "\\tbinom",
    "\\\\atopfrac" // cant be entered directly
], {
    numArgs: 2,
    greediness: 2
}, function(context, args) {
    var numer = args[0];
    var denom = args[1];
    var hasBarLine;
    var leftDelim = null;
    var rightDelim = null;
    var size = "auto";

    switch (context.funcName) {
        case "\\dfrac":
        case "\\frac":
        case "\\tfrac":
            hasBarLine = true;
            break;
        case "\\\\atopfrac":
            hasBarLine = false;
            break;
        case "\\dbinom":
        case "\\binom":
        case "\\tbinom":
            hasBarLine = false;
            leftDelim = "(";
            rightDelim = ")";
            break;
        default:
            throw new Error("Unrecognized genfrac command");
    }

    switch (context.funcName) {
        case "\\dfrac":
        case "\\dbinom":
            size = "display";
            break;
        case "\\tfrac":
        case "\\tbinom":
            size = "text";
            break;
    }

    return {
        type: "genfrac",
        numer: numer,
        denom: denom,
        hasBarLine: hasBarLine,
        leftDelim: leftDelim,
        rightDelim: rightDelim,
        size: size
    };
});

// Left and right overlap functions
defineFunction(["\\llap", "\\rlap"], {
    numArgs: 1,
    allowedInText: true
}, function(context, args) {
    var body = args[0];
    return {
        type: context.funcName.slice(1),
        body: body
    };
});

// Delimiter functions
var checkDelimiter = function(delim, context) {
    if (utils.contains(delimiters, delim.value)) {
        return delim;
    } else {
        throw new ParseError(
            "Invalid delimiter: '" + delim.value + "' after '" +
            context.funcName + "'", delim);
    }
};

defineFunction([
    "\\bigl", "\\Bigl", "\\biggl", "\\Biggl",
    "\\bigr", "\\Bigr", "\\biggr", "\\Biggr",
    "\\bigm", "\\Bigm", "\\biggm", "\\Biggm",
    "\\big",  "\\Big",  "\\bigg",  "\\Bigg"
], {
    numArgs: 1
}, function(context, args) {
    var delim = checkDelimiter(args[0], context);

    return {
        type: "delimsizing",
        size: delimiterSizes[context.funcName].size,
        mclass: delimiterSizes[context.funcName].mclass,
        value: delim.value
    };
});

defineFunction([
    "\\left", "\\right"
], {
    numArgs: 1
}, function(context, args) {
    var delim = checkDelimiter(args[0], context);

    // \left and \right are caught somewhere in Parser.js, which is
    // why this data doesn't match what is in buildHTML.
    return {
        type: "leftright",
        value: delim.value
    };
});

defineFunction("\\middle", {
    numArgs: 1
}, function(context, args) {
    var delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
        throw new ParseError("\\middle without preceding \\left", delim);
    }

    return {
        type: "middle",
        value: delim.value
    };
});

// Sizing functions (handled in Parser.js explicitly, hence no handler)
defineFunction([
    "\\tiny", "\\scriptsize", "\\footnotesize", "\\small",
    "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"
], 0, null);

// Style changing functions (handled in Parser.js explicitly, hence no
// handler)
defineFunction([
    "\\displaystyle", "\\textstyle", "\\scriptstyle",
    "\\scriptscriptstyle"
], 0, null);

defineFunction([
    // styles
    "\\mathrm", "\\mathit", "\\mathbf",

    // families
    "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf",
    "\\mathtt",

    // aliases
    "\\Bbb", "\\bold", "\\frak"
], {
    numArgs: 1,
    greediness: 2
}, function(context, args) {
    var body = args[0];
    var func = context.funcName;
    if (func in fontAliases) {
        func = fontAliases[func];
    }
    return {
        type: "font",
        font: func.slice(1),
        body: body
    };
});

// Accents
defineFunction([
    "\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve",
    "\\check", "\\hat", "\\vec", "\\dot"
    // We don't support expanding accents yet
    // "\\widetilde", "\\widehat"
], {
    numArgs: 1
}, function(context, args) {
    var base = args[0];
    return {
        type: "accent",
        accent: context.funcName,
        base: base
    };
});

// Infix generalized fractions
defineFunction(["\\over", "\\choose", "\\atop"], {
    numArgs: 0,
    infix: true
}, function(context) {
    var replaceWith;
    switch (context.funcName) {
        case "\\over":
            replaceWith = "\\frac";
            break;
        case "\\choose":
            replaceWith = "\\binom";
            break;
        case "\\atop":
            replaceWith = "\\\\atopfrac";
            break;
        default:
            throw new Error("Unrecognized infix genfrac command");
    }
    return {
        type: "infix",
        replaceWith: replaceWith,
        token: context.token
    };
});

// Row breaks for aligned data
defineFunction(["\\\\", "\\cr"], {
    numArgs: 0,
    numOptionalArgs: 1,
    argTypes: ["size"]
}, function(context, args) {
    var size = args[0];
    return {
        type: "cr",
        size: size
    };
});

// Environment delimiters
defineFunction(["\\begin", "\\end"], {
    numArgs: 1,
    argTypes: ["text"]
}, function(context, args) {
    var nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
        throw new ParseError("Invalid environment name", nameGroup);
    }
    var name = "";
    for (var i = 0; i < nameGroup.value.length; ++i) {
        name += nameGroup.value[i].value;
    }
    return {
        type: "environment",
        name: name,
        nameGroup: nameGroup
    };
});

},{"./ParseError":81,"./parseData":96,"./utils":100}],95:[function(require,module,exports){
/**
 * These objects store data about MathML nodes. This is the MathML equivalent
 * of the types in domTree.js. Since MathML handles its own rendering, and
 * since we're mainly using MathML to improve accessibility, we don't manage
 * any of the styling state that the plain DOM nodes do.
 *
 * The `toNode` and `toMarkup` functions work simlarly to how they do in
 * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
 */

var utils = require("./utils");

/**
 * This node represents a general purpose MathML node of any type. The
 * constructor requires the type of node to create (for example, `"mo"` or
 * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
 */
function MathNode(type, children) {
    this.type = type;
    this.attributes = {};
    this.children = children || [];
}

/**
 * Sets an attribute on a MathML node. MathML depends on attributes to convey a
 * semantic content, so this is used heavily.
 */
MathNode.prototype.setAttribute = function(name, value) {
    this.attributes[name] = value;
};

/**
 * Converts the math node into a MathML-namespaced DOM element.
 */
MathNode.prototype.toNode = function() {
    var node = document.createElementNS(
        "http://www.w3.org/1998/Math/MathML", this.type);

    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            node.setAttribute(attr, this.attributes[attr]);
        }
    }

    for (var i = 0; i < this.children.length; i++) {
        node.appendChild(this.children[i].toNode());
    }

    return node;
};

/**
 * Converts the math node into an HTML markup string.
 */
MathNode.prototype.toMarkup = function() {
    var markup = "<" + this.type;

    // Add the attributes
    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "=\"";
            markup += utils.escape(this.attributes[attr]);
            markup += "\"";
        }
    }

    markup += ">";

    for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
    }

    markup += "</" + this.type + ">";

    return markup;
};

/**
 * This node represents a piece of text.
 */
function TextNode(text) {
    this.text = text;
}

/**
 * Converts the text node into a DOM text node.
 */
TextNode.prototype.toNode = function() {
    return document.createTextNode(this.text);
};

/**
 * Converts the text node into HTML markup (which is just the text itself).
 */
TextNode.prototype.toMarkup = function() {
    return utils.escape(this.text);
};

module.exports = {
    MathNode: MathNode,
    TextNode: TextNode
};

},{"./utils":100}],96:[function(require,module,exports){
/**
 * The resulting parse tree nodes of the parse tree.
 *
 * It is possible to provide position information, so that a ParseNode can
 * fulfil a role similar to a Token in error reporting.
 * For details on the corresponding properties see Token constructor.
 * Providing such information can lead to better error reporting.
 *
 * @param {string}  type       type of node, like e.g. "ordgroup"
 * @param {?object} value      type-specific representation of the node
 * @param {string}  mode       parse mode in action for this node,
 *                             "math" or "text"
 * @param {Token=} firstToken  first token of the input for this node,
 *                             will omit position information if unset
 * @param {Token=} lastToken   last token of the input for this node,
 *                             will default to firstToken if unset
 */
function ParseNode(type, value, mode, firstToken, lastToken) {
    this.type = type;
    this.value = value;
    this.mode = mode;
    if (firstToken && (!lastToken || lastToken.lexer === firstToken.lexer)) {
        this.lexer = firstToken.lexer;
        this.start = firstToken.start;
        this.end = (lastToken || firstToken).end;
    }
}

module.exports = {
    ParseNode: ParseNode
};


},{}],97:[function(require,module,exports){
/**
 * Provides a single function for parsing an expression using a Parser
 * TODO(emily): Remove this
 */

var Parser = require("./Parser");

/**
 * Parses an expression using a Parser, then returns the parsed result.
 */
var parseTree = function(toParse, settings) {
    if (!(typeof toParse === 'string' || toParse instanceof String)) {
        throw new TypeError('KaTeX can only parse string typed expression');
    }
    var parser = new Parser(toParse, settings);

    return parser.parse();
};

module.exports = parseTree;

},{"./Parser":82}],98:[function(require,module,exports){
/**
 * This file holds a list of all no-argument functions and single-character
 * symbols (like 'a' or ';').
 *
 * For each of the symbols, there are three properties they can have:
 * - font (required): the font to be used for this symbol. Either "main" (the
     normal font), or "ams" (the ams fonts).
 * - group (required): the ParseNode group type the symbol should have (i.e.
     "textord", "mathord", etc).
     See https://github.com/Khan/KaTeX/wiki/Examining-TeX#group-types
 * - replace: the character that this symbol or function should be
 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
 *   character in the main font).
 *
 * The outermost map in the table indicates what mode the symbols should be
 * accepted in (e.g. "math" or "text").
 */

module.exports = {
    math: {},
    text: {}
};

function defineSymbol(mode, font, group, replace, name) {
    module.exports[mode][name] = {
        font: font,
        group: group,
        replace: replace
    };
}

// Some abbreviations for commonly used strings.
// This helps minify the code, and also spotting typos using jshint.

// modes:
var math = "math";
var text = "text";

// fonts:
var main = "main";
var ams = "ams";

// groups:
var accent = "accent";
var bin = "bin";
var close = "close";
var inner = "inner";
var mathord = "mathord";
var op = "op";
var open = "open";
var punct = "punct";
var rel = "rel";
var spacing = "spacing";
var textord = "textord";

// Now comes the symbol table

// Relation Symbols
defineSymbol(math, main, rel, "\u2261", "\\equiv");
defineSymbol(math, main, rel, "\u227a", "\\prec");
defineSymbol(math, main, rel, "\u227b", "\\succ");
defineSymbol(math, main, rel, "\u223c", "\\sim");
defineSymbol(math, main, rel, "\u22a5", "\\perp");
defineSymbol(math, main, rel, "\u2aaf", "\\preceq");
defineSymbol(math, main, rel, "\u2ab0", "\\succeq");
defineSymbol(math, main, rel, "\u2243", "\\simeq");
defineSymbol(math, main, rel, "\u2223", "\\mid");
defineSymbol(math, main, rel, "\u226a", "\\ll");
defineSymbol(math, main, rel, "\u226b", "\\gg");
defineSymbol(math, main, rel, "\u224d", "\\asymp");
defineSymbol(math, main, rel, "\u2225", "\\parallel");
defineSymbol(math, main, rel, "\u22c8", "\\bowtie");
defineSymbol(math, main, rel, "\u2323", "\\smile");
defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq");
defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq");
defineSymbol(math, main, rel, "\u2250", "\\doteq");
defineSymbol(math, main, rel, "\u2322", "\\frown");
defineSymbol(math, main, rel, "\u220b", "\\ni");
defineSymbol(math, main, rel, "\u221d", "\\propto");
defineSymbol(math, main, rel, "\u22a2", "\\vdash");
defineSymbol(math, main, rel, "\u22a3", "\\dashv");
defineSymbol(math, main, rel, "\u220b", "\\owns");

// Punctuation
defineSymbol(math, main, punct, "\u002e", "\\ldotp");
defineSymbol(math, main, punct, "\u22c5", "\\cdotp");

// Misc Symbols
defineSymbol(math, main, textord, "\u0023", "\\#");
defineSymbol(text, main, textord, "\u0023", "\\#");
defineSymbol(math, main, textord, "\u0026", "\\&");
defineSymbol(text, main, textord, "\u0026", "\\&");
defineSymbol(math, main, textord, "\u2135", "\\aleph");
defineSymbol(math, main, textord, "\u2200", "\\forall");
defineSymbol(math, main, textord, "\u210f", "\\hbar");
defineSymbol(math, main, textord, "\u2203", "\\exists");
defineSymbol(math, main, textord, "\u2207", "\\nabla");
defineSymbol(math, main, textord, "\u266d", "\\flat");
defineSymbol(math, main, textord, "\u2113", "\\ell");
defineSymbol(math, main, textord, "\u266e", "\\natural");
defineSymbol(math, main, textord, "\u2663", "\\clubsuit");
defineSymbol(math, main, textord, "\u2118", "\\wp");
defineSymbol(math, main, textord, "\u266f", "\\sharp");
defineSymbol(math, main, textord, "\u2662", "\\diamondsuit");
defineSymbol(math, main, textord, "\u211c", "\\Re");
defineSymbol(math, main, textord, "\u2661", "\\heartsuit");
defineSymbol(math, main, textord, "\u2111", "\\Im");
defineSymbol(math, main, textord, "\u2660", "\\spadesuit");

// Math and Text
defineSymbol(math, main, textord, "\u2020", "\\dag");
defineSymbol(math, main, textord, "\u2021", "\\ddag");

// Large Delimiters
defineSymbol(math, main, close, "\u23b1", "\\rmoustache");
defineSymbol(math, main, open, "\u23b0", "\\lmoustache");
defineSymbol(math, main, close, "\u27ef", "\\rgroup");
defineSymbol(math, main, open, "\u27ee", "\\lgroup");

// Binary Operators
defineSymbol(math, main, bin, "\u2213", "\\mp");
defineSymbol(math, main, bin, "\u2296", "\\ominus");
defineSymbol(math, main, bin, "\u228e", "\\uplus");
defineSymbol(math, main, bin, "\u2293", "\\sqcap");
defineSymbol(math, main, bin, "\u2217", "\\ast");
defineSymbol(math, main, bin, "\u2294", "\\sqcup");
defineSymbol(math, main, bin, "\u25ef", "\\bigcirc");
defineSymbol(math, main, bin, "\u2219", "\\bullet");
defineSymbol(math, main, bin, "\u2021", "\\ddagger");
defineSymbol(math, main, bin, "\u2240", "\\wr");
defineSymbol(math, main, bin, "\u2a3f", "\\amalg");

// Arrow Symbols
defineSymbol(math, main, rel, "\u27f5", "\\longleftarrow");
defineSymbol(math, main, rel, "\u21d0", "\\Leftarrow");
defineSymbol(math, main, rel, "\u27f8", "\\Longleftarrow");
defineSymbol(math, main, rel, "\u27f6", "\\longrightarrow");
defineSymbol(math, main, rel, "\u21d2", "\\Rightarrow");
defineSymbol(math, main, rel, "\u27f9", "\\Longrightarrow");
defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow");
defineSymbol(math, main, rel, "\u27f7", "\\longleftrightarrow");
defineSymbol(math, main, rel, "\u21d4", "\\Leftrightarrow");
defineSymbol(math, main, rel, "\u27fa", "\\Longleftrightarrow");
defineSymbol(math, main, rel, "\u21a6", "\\mapsto");
defineSymbol(math, main, rel, "\u27fc", "\\longmapsto");
defineSymbol(math, main, rel, "\u2197", "\\nearrow");
defineSymbol(math, main, rel, "\u21a9", "\\hookleftarrow");
defineSymbol(math, main, rel, "\u21aa", "\\hookrightarrow");
defineSymbol(math, main, rel, "\u2198", "\\searrow");
defineSymbol(math, main, rel, "\u21bc", "\\leftharpoonup");
defineSymbol(math, main, rel, "\u21c0", "\\rightharpoonup");
defineSymbol(math, main, rel, "\u2199", "\\swarrow");
defineSymbol(math, main, rel, "\u21bd", "\\leftharpoondown");
defineSymbol(math, main, rel, "\u21c1", "\\rightharpoondown");
defineSymbol(math, main, rel, "\u2196", "\\nwarrow");
defineSymbol(math, main, rel, "\u21cc", "\\rightleftharpoons");

// AMS Negated Binary Relations
defineSymbol(math, ams, rel, "\u226e", "\\nless");
defineSymbol(math, ams, rel, "\ue010", "\\nleqslant");
defineSymbol(math, ams, rel, "\ue011", "\\nleqq");
defineSymbol(math, ams, rel, "\u2a87", "\\lneq");
defineSymbol(math, ams, rel, "\u2268", "\\lneqq");
defineSymbol(math, ams, rel, "\ue00c", "\\lvertneqq");
defineSymbol(math, ams, rel, "\u22e6", "\\lnsim");
defineSymbol(math, ams, rel, "\u2a89", "\\lnapprox");
defineSymbol(math, ams, rel, "\u2280", "\\nprec");
defineSymbol(math, ams, rel, "\u22e0", "\\npreceq");
defineSymbol(math, ams, rel, "\u22e8", "\\precnsim");
defineSymbol(math, ams, rel, "\u2ab9", "\\precnapprox");
defineSymbol(math, ams, rel, "\u2241", "\\nsim");
defineSymbol(math, ams, rel, "\ue006", "\\nshortmid");
defineSymbol(math, ams, rel, "\u2224", "\\nmid");
defineSymbol(math, ams, rel, "\u22ac", "\\nvdash");
defineSymbol(math, ams, rel, "\u22ad", "\\nvDash");
defineSymbol(math, ams, rel, "\u22ea", "\\ntriangleleft");
defineSymbol(math, ams, rel, "\u22ec", "\\ntrianglelefteq");
defineSymbol(math, ams, rel, "\u228a", "\\subsetneq");
defineSymbol(math, ams, rel, "\ue01a", "\\varsubsetneq");
defineSymbol(math, ams, rel, "\u2acb", "\\subsetneqq");
defineSymbol(math, ams, rel, "\ue017", "\\varsubsetneqq");
defineSymbol(math, ams, rel, "\u226f", "\\ngtr");
defineSymbol(math, ams, rel, "\ue00f", "\\ngeqslant");
defineSymbol(math, ams, rel, "\ue00e", "\\ngeqq");
defineSymbol(math, ams, rel, "\u2a88", "\\gneq");
defineSymbol(math, ams, rel, "\u2269", "\\gneqq");
defineSymbol(math, ams, rel, "\ue00d", "\\gvertneqq");
defineSymbol(math, ams, rel, "\u22e7", "\\gnsim");
defineSymbol(math, ams, rel, "\u2a8a", "\\gnapprox");
defineSymbol(math, ams, rel, "\u2281", "\\nsucc");
defineSymbol(math, ams, rel, "\u22e1", "\\nsucceq");
defineSymbol(math, ams, rel, "\u22e9", "\\succnsim");
defineSymbol(math, ams, rel, "\u2aba", "\\succnapprox");
defineSymbol(math, ams, rel, "\u2246", "\\ncong");
defineSymbol(math, ams, rel, "\ue007", "\\nshortparallel");
defineSymbol(math, ams, rel, "\u2226", "\\nparallel");
defineSymbol(math, ams, rel, "\u22af", "\\nVDash");
defineSymbol(math, ams, rel, "\u22eb", "\\ntriangleright");
defineSymbol(math, ams, rel, "\u22ed", "\\ntrianglerighteq");
defineSymbol(math, ams, rel, "\ue018", "\\nsupseteqq");
defineSymbol(math, ams, rel, "\u228b", "\\supsetneq");
defineSymbol(math, ams, rel, "\ue01b", "\\varsupsetneq");
defineSymbol(math, ams, rel, "\u2acc", "\\supsetneqq");
defineSymbol(math, ams, rel, "\ue019", "\\varsupsetneqq");
defineSymbol(math, ams, rel, "\u22ae", "\\nVdash");
defineSymbol(math, ams, rel, "\u2ab5", "\\precneqq");
defineSymbol(math, ams, rel, "\u2ab6", "\\succneqq");
defineSymbol(math, ams, rel, "\ue016", "\\nsubseteqq");
defineSymbol(math, ams, bin, "\u22b4", "\\unlhd");
defineSymbol(math, ams, bin, "\u22b5", "\\unrhd");

// AMS Negated Arrows
defineSymbol(math, ams, rel, "\u219a", "\\nleftarrow");
defineSymbol(math, ams, rel, "\u219b", "\\nrightarrow");
defineSymbol(math, ams, rel, "\u21cd", "\\nLeftarrow");
defineSymbol(math, ams, rel, "\u21cf", "\\nRightarrow");
defineSymbol(math, ams, rel, "\u21ae", "\\nleftrightarrow");
defineSymbol(math, ams, rel, "\u21ce", "\\nLeftrightarrow");

// AMS Misc
defineSymbol(math, ams, rel, "\u25b3", "\\vartriangle");
defineSymbol(math, ams, textord, "\u210f", "\\hslash");
defineSymbol(math, ams, textord, "\u25bd", "\\triangledown");
defineSymbol(math, ams, textord, "\u25ca", "\\lozenge");
defineSymbol(math, ams, textord, "\u24c8", "\\circledS");
defineSymbol(math, ams, textord, "\u00ae", "\\circledR");
defineSymbol(math, ams, textord, "\u2221", "\\measuredangle");
defineSymbol(math, ams, textord, "\u2204", "\\nexists");
defineSymbol(math, ams, textord, "\u2127", "\\mho");
defineSymbol(math, ams, textord, "\u2132", "\\Finv");
defineSymbol(math, ams, textord, "\u2141", "\\Game");
defineSymbol(math, ams, textord, "\u006b", "\\Bbbk");
defineSymbol(math, ams, textord, "\u2035", "\\backprime");
defineSymbol(math, ams, textord, "\u25b2", "\\blacktriangle");
defineSymbol(math, ams, textord, "\u25bc", "\\blacktriangledown");
defineSymbol(math, ams, textord, "\u25a0", "\\blacksquare");
defineSymbol(math, ams, textord, "\u29eb", "\\blacklozenge");
defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle");
defineSymbol(math, ams, textord, "\u2201", "\\complement");
defineSymbol(math, ams, textord, "\u00f0", "\\eth");
defineSymbol(math, ams, textord, "\u2571", "\\diagup");
defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
defineSymbol(math, ams, textord, "\u25a1", "\\square");
defineSymbol(math, ams, textord, "\u25a1", "\\Box");
defineSymbol(math, ams, textord, "\u25ca", "\\Diamond");
defineSymbol(math, ams, textord, "\u00a5", "\\yen");
defineSymbol(math, ams, textord, "\u2713", "\\checkmark");

// AMS Hebrew
defineSymbol(math, ams, textord, "\u2136", "\\beth");
defineSymbol(math, ams, textord, "\u2138", "\\daleth");
defineSymbol(math, ams, textord, "\u2137", "\\gimel");

// AMS Greek
defineSymbol(math, ams, textord, "\u03dd", "\\digamma");
defineSymbol(math, ams, textord, "\u03f0", "\\varkappa");

// AMS Delimiters
defineSymbol(math, ams, open, "\u250c", "\\ulcorner");
defineSymbol(math, ams, close, "\u2510", "\\urcorner");
defineSymbol(math, ams, open, "\u2514", "\\llcorner");
defineSymbol(math, ams, close, "\u2518", "\\lrcorner");

// AMS Binary Relations
defineSymbol(math, ams, rel, "\u2266", "\\leqq");
defineSymbol(math, ams, rel, "\u2a7d", "\\leqslant");
defineSymbol(math, ams, rel, "\u2a95", "\\eqslantless");
defineSymbol(math, ams, rel, "\u2272", "\\lesssim");
defineSymbol(math, ams, rel, "\u2a85", "\\lessapprox");
defineSymbol(math, ams, rel, "\u224a", "\\approxeq");
defineSymbol(math, ams, bin, "\u22d6", "\\lessdot");
defineSymbol(math, ams, rel, "\u22d8", "\\lll");
defineSymbol(math, ams, rel, "\u2276", "\\lessgtr");
defineSymbol(math, ams, rel, "\u22da", "\\lesseqgtr");
defineSymbol(math, ams, rel, "\u2a8b", "\\lesseqqgtr");
defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq");
defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq");
defineSymbol(math, ams, rel, "\u223d", "\\backsim");
defineSymbol(math, ams, rel, "\u22cd", "\\backsimeq");
defineSymbol(math, ams, rel, "\u2ac5", "\\subseteqq");
defineSymbol(math, ams, rel, "\u22d0", "\\Subset");
defineSymbol(math, ams, rel, "\u228f", "\\sqsubset");
defineSymbol(math, ams, rel, "\u227c", "\\preccurlyeq");
defineSymbol(math, ams, rel, "\u22de", "\\curlyeqprec");
defineSymbol(math, ams, rel, "\u227e", "\\precsim");
defineSymbol(math, ams, rel, "\u2ab7", "\\precapprox");
defineSymbol(math, ams, rel, "\u22b2", "\\vartriangleleft");
defineSymbol(math, ams, rel, "\u22b4", "\\trianglelefteq");
defineSymbol(math, ams, rel, "\u22a8", "\\vDash");
defineSymbol(math, ams, rel, "\u22aa", "\\Vvdash");
defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
defineSymbol(math, ams, rel, "\u224f", "\\bumpeq");
defineSymbol(math, ams, rel, "\u224e", "\\Bumpeq");
defineSymbol(math, ams, rel, "\u2267", "\\geqq");
defineSymbol(math, ams, rel, "\u2a7e", "\\geqslant");
defineSymbol(math, ams, rel, "\u2a96", "\\eqslantgtr");
defineSymbol(math, ams, rel, "\u2273", "\\gtrsim");
defineSymbol(math, ams, rel, "\u2a86", "\\gtrapprox");
defineSymbol(math, ams, bin, "\u22d7", "\\gtrdot");
defineSymbol(math, ams, rel, "\u22d9", "\\ggg");
defineSymbol(math, ams, rel, "\u2277", "\\gtrless");
defineSymbol(math, ams, rel, "\u22db", "\\gtreqless");
defineSymbol(math, ams, rel, "\u2a8c", "\\gtreqqless");
defineSymbol(math, ams, rel, "\u2256", "\\eqcirc");
defineSymbol(math, ams, rel, "\u2257", "\\circeq");
defineSymbol(math, ams, rel, "\u225c", "\\triangleq");
defineSymbol(math, ams, rel, "\u223c", "\\thicksim");
defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
defineSymbol(math, ams, rel, "\u2ac6", "\\supseteqq");
defineSymbol(math, ams, rel, "\u22d1", "\\Supset");
defineSymbol(math, ams, rel, "\u2290", "\\sqsupset");
defineSymbol(math, ams, rel, "\u227d", "\\succcurlyeq");
defineSymbol(math, ams, rel, "\u22df", "\\curlyeqsucc");
defineSymbol(math, ams, rel, "\u227f", "\\succsim");
defineSymbol(math, ams, rel, "\u2ab8", "\\succapprox");
defineSymbol(math, ams, rel, "\u22b3", "\\vartriangleright");
defineSymbol(math, ams, rel, "\u22b5", "\\trianglerighteq");
defineSymbol(math, ams, rel, "\u22a9", "\\Vdash");
defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
defineSymbol(math, ams, rel, "\u226c", "\\between");
defineSymbol(math, ams, rel, "\u22d4", "\\pitchfork");
defineSymbol(math, ams, rel, "\u221d", "\\varpropto");
defineSymbol(math, ams, rel, "\u25c0", "\\blacktriangleleft");
defineSymbol(math, ams, rel, "\u2234", "\\therefore");
defineSymbol(math, ams, rel, "\u220d", "\\backepsilon");
defineSymbol(math, ams, rel, "\u25b6", "\\blacktriangleright");
defineSymbol(math, ams, rel, "\u2235", "\\because");
defineSymbol(math, ams, rel, "\u22d8", "\\llless");
defineSymbol(math, ams, rel, "\u22d9", "\\gggtr");
defineSymbol(math, ams, bin, "\u22b2", "\\lhd");
defineSymbol(math, ams, bin, "\u22b3", "\\rhd");
defineSymbol(math, ams, rel, "\u2242", "\\eqsim");
defineSymbol(math, main, rel, "\u22c8", "\\Join");
defineSymbol(math, ams, rel, "\u2251", "\\Doteq");

// AMS Binary Operators
defineSymbol(math, ams, bin, "\u2214", "\\dotplus");
defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
defineSymbol(math, ams, bin, "\u22d2", "\\Cap");
defineSymbol(math, ams, bin, "\u22d3", "\\Cup");
defineSymbol(math, ams, bin, "\u2a5e", "\\doublebarwedge");
defineSymbol(math, ams, bin, "\u229f", "\\boxminus");
defineSymbol(math, ams, bin, "\u229e", "\\boxplus");
defineSymbol(math, ams, bin, "\u22c7", "\\divideontimes");
defineSymbol(math, ams, bin, "\u22c9", "\\ltimes");
defineSymbol(math, ams, bin, "\u22ca", "\\rtimes");
defineSymbol(math, ams, bin, "\u22cb", "\\leftthreetimes");
defineSymbol(math, ams, bin, "\u22cc", "\\rightthreetimes");
defineSymbol(math, ams, bin, "\u22cf", "\\curlywedge");
defineSymbol(math, ams, bin, "\u22ce", "\\curlyvee");
defineSymbol(math, ams, bin, "\u229d", "\\circleddash");
defineSymbol(math, ams, bin, "\u229b", "\\circledast");
defineSymbol(math, ams, bin, "\u22c5", "\\centerdot");
defineSymbol(math, ams, bin, "\u22ba", "\\intercal");
defineSymbol(math, ams, bin, "\u22d2", "\\doublecap");
defineSymbol(math, ams, bin, "\u22d3", "\\doublecup");
defineSymbol(math, ams, bin, "\u22a0", "\\boxtimes");

// AMS Arrows
defineSymbol(math, ams, rel, "\u21e2", "\\dashrightarrow");
defineSymbol(math, ams, rel, "\u21e0", "\\dashleftarrow");
defineSymbol(math, ams, rel, "\u21c7", "\\leftleftarrows");
defineSymbol(math, ams, rel, "\u21c6", "\\leftrightarrows");
defineSymbol(math, ams, rel, "\u21da", "\\Lleftarrow");
defineSymbol(math, ams, rel, "\u219e", "\\twoheadleftarrow");
defineSymbol(math, ams, rel, "\u21a2", "\\leftarrowtail");
defineSymbol(math, ams, rel, "\u21ab", "\\looparrowleft");
defineSymbol(math, ams, rel, "\u21cb", "\\leftrightharpoons");
defineSymbol(math, ams, rel, "\u21b6", "\\curvearrowleft");
defineSymbol(math, ams, rel, "\u21ba", "\\circlearrowleft");
defineSymbol(math, ams, rel, "\u21b0", "\\Lsh");
defineSymbol(math, ams, rel, "\u21c8", "\\upuparrows");
defineSymbol(math, ams, rel, "\u21bf", "\\upharpoonleft");
defineSymbol(math, ams, rel, "\u21c3", "\\downharpoonleft");
defineSymbol(math, ams, rel, "\u22b8", "\\multimap");
defineSymbol(math, ams, rel, "\u21ad", "\\leftrightsquigarrow");
defineSymbol(math, ams, rel, "\u21c9", "\\rightrightarrows");
defineSymbol(math, ams, rel, "\u21c4", "\\rightleftarrows");
defineSymbol(math, ams, rel, "\u21a0", "\\twoheadrightarrow");
defineSymbol(math, ams, rel, "\u21a3", "\\rightarrowtail");
defineSymbol(math, ams, rel, "\u21ac", "\\looparrowright");
defineSymbol(math, ams, rel, "\u21b7", "\\curvearrowright");
defineSymbol(math, ams, rel, "\u21bb", "\\circlearrowright");
defineSymbol(math, ams, rel, "\u21b1", "\\Rsh");
defineSymbol(math, ams, rel, "\u21ca", "\\downdownarrows");
defineSymbol(math, ams, rel, "\u21be", "\\upharpoonright");
defineSymbol(math, ams, rel, "\u21c2", "\\downharpoonright");
defineSymbol(math, ams, rel, "\u21dd", "\\rightsquigarrow");
defineSymbol(math, ams, rel, "\u21dd", "\\leadsto");
defineSymbol(math, ams, rel, "\u21db", "\\Rrightarrow");
defineSymbol(math, ams, rel, "\u21be", "\\restriction");

defineSymbol(math, main, textord, "\u2018", "`");
defineSymbol(math, main, textord, "$", "\\$");
defineSymbol(text, main, textord, "$", "\\$");
defineSymbol(math, main, textord, "%", "\\%");
defineSymbol(text, main, textord, "%", "\\%");
defineSymbol(math, main, textord, "_", "\\_");
defineSymbol(text, main, textord, "_", "\\_");
defineSymbol(math, main, textord, "\u2220", "\\angle");
defineSymbol(math, main, textord, "\u221e", "\\infty");
defineSymbol(math, main, textord, "\u2032", "\\prime");
defineSymbol(math, main, textord, "\u25b3", "\\triangle");
defineSymbol(math, main, textord, "\u0393", "\\Gamma");
defineSymbol(math, main, textord, "\u0394", "\\Delta");
defineSymbol(math, main, textord, "\u0398", "\\Theta");
defineSymbol(math, main, textord, "\u039b", "\\Lambda");
defineSymbol(math, main, textord, "\u039e", "\\Xi");
defineSymbol(math, main, textord, "\u03a0", "\\Pi");
defineSymbol(math, main, textord, "\u03a3", "\\Sigma");
defineSymbol(math, main, textord, "\u03a5", "\\Upsilon");
defineSymbol(math, main, textord, "\u03a6", "\\Phi");
defineSymbol(math, main, textord, "\u03a8", "\\Psi");
defineSymbol(math, main, textord, "\u03a9", "\\Omega");
defineSymbol(math, main, textord, "\u00ac", "\\neg");
defineSymbol(math, main, textord, "\u00ac", "\\lnot");
defineSymbol(math, main, textord, "\u22a4", "\\top");
defineSymbol(math, main, textord, "\u22a5", "\\bot");
defineSymbol(math, main, textord, "\u2205", "\\emptyset");
defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
defineSymbol(math, main, mathord, "\u03b1", "\\alpha");
defineSymbol(math, main, mathord, "\u03b2", "\\beta");
defineSymbol(math, main, mathord, "\u03b3", "\\gamma");
defineSymbol(math, main, mathord, "\u03b4", "\\delta");
defineSymbol(math, main, mathord, "\u03f5", "\\epsilon");
defineSymbol(math, main, mathord, "\u03b6", "\\zeta");
defineSymbol(math, main, mathord, "\u03b7", "\\eta");
defineSymbol(math, main, mathord, "\u03b8", "\\theta");
defineSymbol(math, main, mathord, "\u03b9", "\\iota");
defineSymbol(math, main, mathord, "\u03ba", "\\kappa");
defineSymbol(math, main, mathord, "\u03bb", "\\lambda");
defineSymbol(math, main, mathord, "\u03bc", "\\mu");
defineSymbol(math, main, mathord, "\u03bd", "\\nu");
defineSymbol(math, main, mathord, "\u03be", "\\xi");
defineSymbol(math, main, mathord, "o", "\\omicron");
defineSymbol(math, main, mathord, "\u03c0", "\\pi");
defineSymbol(math, main, mathord, "\u03c1", "\\rho");
defineSymbol(math, main, mathord, "\u03c3", "\\sigma");
defineSymbol(math, main, mathord, "\u03c4", "\\tau");
defineSymbol(math, main, mathord, "\u03c5", "\\upsilon");
defineSymbol(math, main, mathord, "\u03d5", "\\phi");
defineSymbol(math, main, mathord, "\u03c7", "\\chi");
defineSymbol(math, main, mathord, "\u03c8", "\\psi");
defineSymbol(math, main, mathord, "\u03c9", "\\omega");
defineSymbol(math, main, mathord, "\u03b5", "\\varepsilon");
defineSymbol(math, main, mathord, "\u03d1", "\\vartheta");
defineSymbol(math, main, mathord, "\u03d6", "\\varpi");
defineSymbol(math, main, mathord, "\u03f1", "\\varrho");
defineSymbol(math, main, mathord, "\u03c2", "\\varsigma");
defineSymbol(math, main, mathord, "\u03c6", "\\varphi");
defineSymbol(math, main, bin, "\u2217", "*");
defineSymbol(math, main, bin, "+", "+");
defineSymbol(math, main, bin, "\u2212", "-");
defineSymbol(math, main, bin, "\u22c5", "\\cdot");
defineSymbol(math, main, bin, "\u2218", "\\circ");
defineSymbol(math, main, bin, "\u00f7", "\\div");
defineSymbol(math, main, bin, "\u00b1", "\\pm");
defineSymbol(math, main, bin, "\u00d7", "\\times");
defineSymbol(math, main, bin, "\u2229", "\\cap");
defineSymbol(math, main, bin, "\u222a", "\\cup");
defineSymbol(math, main, bin, "\u2216", "\\setminus");
defineSymbol(math, main, bin, "\u2227", "\\land");
defineSymbol(math, main, bin, "\u2228", "\\lor");
defineSymbol(math, main, bin, "\u2227", "\\wedge");
defineSymbol(math, main, bin, "\u2228", "\\vee");
defineSymbol(math, main, textord, "\u221a", "\\surd");
defineSymbol(math, main, open, "(", "(");
defineSymbol(math, main, open, "[", "[");
defineSymbol(math, main, open, "\u27e8", "\\langle");
defineSymbol(math, main, open, "\u2223", "\\lvert");
defineSymbol(math, main, open, "\u2225", "\\lVert");
defineSymbol(math, main, close, ")", ")");
defineSymbol(math, main, close, "]", "]");
defineSymbol(math, main, close, "?", "?");
defineSymbol(math, main, close, "!", "!");
defineSymbol(math, main, close, "\u27e9", "\\rangle");
defineSymbol(math, main, close, "\u2223", "\\rvert");
defineSymbol(math, main, close, "\u2225", "\\rVert");
defineSymbol(math, main, rel, "=", "=");
defineSymbol(math, main, rel, "<", "<");
defineSymbol(math, main, rel, ">", ">");
defineSymbol(math, main, rel, ":", ":");
defineSymbol(math, main, rel, "\u2248", "\\approx");
defineSymbol(math, main, rel, "\u2245", "\\cong");
defineSymbol(math, main, rel, "\u2265", "\\ge");
defineSymbol(math, main, rel, "\u2265", "\\geq");
defineSymbol(math, main, rel, "\u2190", "\\gets");
defineSymbol(math, main, rel, ">", "\\gt");
defineSymbol(math, main, rel, "\u2208", "\\in");
defineSymbol(math, main, rel, "\u2209", "\\notin");
defineSymbol(math, main, rel, "\u2282", "\\subset");
defineSymbol(math, main, rel, "\u2283", "\\supset");
defineSymbol(math, main, rel, "\u2286", "\\subseteq");
defineSymbol(math, main, rel, "\u2287", "\\supseteq");
defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq");
defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq");
defineSymbol(math, main, rel, "\u22a8", "\\models");
defineSymbol(math, main, rel, "\u2190", "\\leftarrow");
defineSymbol(math, main, rel, "\u2264", "\\le");
defineSymbol(math, main, rel, "\u2264", "\\leq");
defineSymbol(math, main, rel, "<", "\\lt");
defineSymbol(math, main, rel, "\u2260", "\\ne");
defineSymbol(math, main, rel, "\u2260", "\\neq");
defineSymbol(math, main, rel, "\u2192", "\\rightarrow");
defineSymbol(math, main, rel, "\u2192", "\\to");
defineSymbol(math, ams, rel, "\u2271", "\\ngeq");
defineSymbol(math, ams, rel, "\u2270", "\\nleq");
defineSymbol(math, main, spacing, null, "\\!");
defineSymbol(math, main, spacing, "\u00a0", "\\ ");
defineSymbol(math, main, spacing, "\u00a0", "~");
defineSymbol(math, main, spacing, null, "\\,");
defineSymbol(math, main, spacing, null, "\\:");
defineSymbol(math, main, spacing, null, "\\;");
defineSymbol(math, main, spacing, null, "\\enspace");
defineSymbol(math, main, spacing, null, "\\qquad");
defineSymbol(math, main, spacing, null, "\\quad");
defineSymbol(math, main, spacing, "\u00a0", "\\space");
defineSymbol(math, main, punct, ",", ",");
defineSymbol(math, main, punct, ";", ";");
defineSymbol(math, main, punct, ":", "\\colon");
defineSymbol(math, ams, bin, "\u22bc", "\\barwedge");
defineSymbol(math, ams, bin, "\u22bb", "\\veebar");
defineSymbol(math, main, bin, "\u2299", "\\odot");
defineSymbol(math, main, bin, "\u2295", "\\oplus");
defineSymbol(math, main, bin, "\u2297", "\\otimes");
defineSymbol(math, main, textord, "\u2202", "\\partial");
defineSymbol(math, main, bin, "\u2298", "\\oslash");
defineSymbol(math, ams, bin, "\u229a", "\\circledcirc");
defineSymbol(math, ams, bin, "\u22a1", "\\boxdot");
defineSymbol(math, main, bin, "\u25b3", "\\bigtriangleup");
defineSymbol(math, main, bin, "\u25bd", "\\bigtriangledown");
defineSymbol(math, main, bin, "\u2020", "\\dagger");
defineSymbol(math, main, bin, "\u22c4", "\\diamond");
defineSymbol(math, main, bin, "\u22c6", "\\star");
defineSymbol(math, main, bin, "\u25c3", "\\triangleleft");
defineSymbol(math, main, bin, "\u25b9", "\\triangleright");
defineSymbol(math, main, open, "{", "\\{");
defineSymbol(text, main, textord, "{", "\\{");
defineSymbol(math, main, close, "}", "\\}");
defineSymbol(text, main, textord, "}", "\\}");
defineSymbol(math, main, open, "{", "\\lbrace");
defineSymbol(math, main, close, "}", "\\rbrace");
defineSymbol(math, main, open, "[", "\\lbrack");
defineSymbol(math, main, close, "]", "\\rbrack");
defineSymbol(math, main, open, "\u230a", "\\lfloor");
defineSymbol(math, main, close, "\u230b", "\\rfloor");
defineSymbol(math, main, open, "\u2308", "\\lceil");
defineSymbol(math, main, close, "\u2309", "\\rceil");
defineSymbol(math, main, textord, "\\", "\\backslash");
defineSymbol(math, main, textord, "\u2223", "|");
defineSymbol(math, main, textord, "\u2223", "\\vert");
defineSymbol(math, main, textord, "\u2225", "\\|");
defineSymbol(math, main, textord, "\u2225", "\\Vert");
defineSymbol(math, main, rel, "\u2191", "\\uparrow");
defineSymbol(math, main, rel, "\u21d1", "\\Uparrow");
defineSymbol(math, main, rel, "\u2193", "\\downarrow");
defineSymbol(math, main, rel, "\u21d3", "\\Downarrow");
defineSymbol(math, main, rel, "\u2195", "\\updownarrow");
defineSymbol(math, main, rel, "\u21d5", "\\Updownarrow");
defineSymbol(math, math, op, "\u2210", "\\coprod");
defineSymbol(math, math, op, "\u22c1", "\\bigvee");
defineSymbol(math, math, op, "\u22c0", "\\bigwedge");
defineSymbol(math, math, op, "\u2a04", "\\biguplus");
defineSymbol(math, math, op, "\u22c2", "\\bigcap");
defineSymbol(math, math, op, "\u22c3", "\\bigcup");
defineSymbol(math, math, op, "\u222b", "\\int");
defineSymbol(math, math, op, "\u222b", "\\intop");
defineSymbol(math, math, op, "\u222c", "\\iint");
defineSymbol(math, math, op, "\u222d", "\\iiint");
defineSymbol(math, math, op, "\u220f", "\\prod");
defineSymbol(math, math, op, "\u2211", "\\sum");
defineSymbol(math, math, op, "\u2a02", "\\bigotimes");
defineSymbol(math, math, op, "\u2a01", "\\bigoplus");
defineSymbol(math, math, op, "\u2a00", "\\bigodot");
defineSymbol(math, math, op, "\u222e", "\\oint");
defineSymbol(math, math, op, "\u2a06", "\\bigsqcup");
defineSymbol(math, math, op, "\u222b", "\\smallint");
defineSymbol(text, main, inner, "\u2026", "\\textellipsis");
defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
defineSymbol(text, main, inner, "\u2026", "\\ldots");
defineSymbol(math, main, inner, "\u2026", "\\ldots");
defineSymbol(math, main, inner, "\u22ef", "\\cdots");
defineSymbol(math, main, inner, "\u22f1", "\\ddots");
defineSymbol(math, main, textord, "\u22ee", "\\vdots");
defineSymbol(math, main, accent, "\u00b4", "\\acute");
defineSymbol(math, main, accent, "\u0060", "\\grave");
defineSymbol(math, main, accent, "\u00a8", "\\ddot");
defineSymbol(math, main, accent, "\u007e", "\\tilde");
defineSymbol(math, main, accent, "\u00af", "\\bar");
defineSymbol(math, main, accent, "\u02d8", "\\breve");
defineSymbol(math, main, accent, "\u02c7", "\\check");
defineSymbol(math, main, accent, "\u005e", "\\hat");
defineSymbol(math, main, accent, "\u20d7", "\\vec");
defineSymbol(math, main, accent, "\u02d9", "\\dot");
defineSymbol(math, main, mathord, "\u0131", "\\imath");
defineSymbol(math, main, mathord, "\u0237", "\\jmath");

defineSymbol(text, main, textord, "\u2013", "--");
defineSymbol(text, main, textord, "\u2014", "---");
defineSymbol(text, main, textord, "\u2018", "`");
defineSymbol(text, main, textord, "\u2019", "'");
defineSymbol(text, main, textord, "\u201c", "``");
defineSymbol(text, main, textord, "\u201d", "''");
defineSymbol(math, main, textord, "\u00b0", "\\degree");
defineSymbol(text, main, textord, "\u00b0", "\\degree");
defineSymbol(math, main, mathord, "\u00a3", "\\pounds");
defineSymbol(math, ams, textord, "\u2720", "\\maltese");
defineSymbol(text, ams, textord, "\u2720", "\\maltese");

defineSymbol(text, main, spacing, "\u00a0", "\\ ");
defineSymbol(text, main, spacing, "\u00a0", " ");
defineSymbol(text, main, spacing, "\u00a0", "~");

// There are lots of symbols which are the same, so we add them in afterwards.
var i;
var ch;

// All of these are textords in math mode
var mathTextSymbols = "0123456789/@.\"";
for (i = 0; i < mathTextSymbols.length; i++) {
    ch = mathTextSymbols.charAt(i);
    defineSymbol(math, main, textord, ch, ch);
}

// All of these are textords in text mode
var textSymbols = "0123456789!@*()-=+[]\";:?/.,";
for (i = 0; i < textSymbols.length; i++) {
    ch = textSymbols.charAt(i);
    defineSymbol(text, main, textord, ch, ch);
}

// All of these are textords in text mode, and mathords in math mode
var letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
for (i = 0; i < letters.length; i++) {
    ch = letters.charAt(i);
    defineSymbol(math, main, mathord, ch, ch);
    defineSymbol(text, main, textord, ch, ch);
}

// Latin-1 letters
for (i = 0x00C0; i <= 0x00D6; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

for (i = 0x00D8; i <= 0x00F6; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

for (i = 0x00F8; i <= 0x00FF; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

// Cyrillic
for (i = 0x0410; i <= 0x044F; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

// Unicode versions of existing characters
defineSymbol(text, main, textord, "\u2013", "");
defineSymbol(text, main, textord, "\u2014", "");
defineSymbol(text, main, textord, "\u2018", "");
defineSymbol(text, main, textord, "\u2019", "");
defineSymbol(text, main, textord, "\u201c", "");
defineSymbol(text, main, textord, "\u201d", "");

},{}],99:[function(require,module,exports){
var hangulRegex = /[\uAC00-\uD7AF]/;

// This regex combines
// - Hiragana: [\u3040-\u309F]
// - Katakana: [\u30A0-\u30FF]
// - CJK ideograms: [\u4E00-\u9FAF]
// - Hangul syllables: [\uAC00-\uD7AF]
// Notably missing are halfwidth Katakana and Romanji glyphs.
var cjkRegex =
    /[\u3040-\u309F]|[\u30A0-\u30FF]|[\u4E00-\u9FAF]|[\uAC00-\uD7AF]/;

module.exports = {
    cjkRegex: cjkRegex,
    hangulRegex: hangulRegex
};

},{}],100:[function(require,module,exports){
/**
 * This file contains a list of utility functions which are useful in other
 * files.
 */

/**
 * Provide an `indexOf` function which works in IE8, but defers to native if
 * possible.
 */
var nativeIndexOf = Array.prototype.indexOf;
var indexOf = function(list, elem) {
    if (list == null) {
        return -1;
    }
    if (nativeIndexOf && list.indexOf === nativeIndexOf) {
        return list.indexOf(elem);
    }
    var i = 0;
    var l = list.length;
    for (; i < l; i++) {
        if (list[i] === elem) {
            return i;
        }
    }
    return -1;
};

/**
 * Return whether an element is contained in a list
 */
var contains = function(list, elem) {
    return indexOf(list, elem) !== -1;
};

/**
 * Provide a default value if a setting is undefined
 */
var deflt = function(setting, defaultIfUndefined) {
    return setting === undefined ? defaultIfUndefined : setting;
};

// hyphenate and escape adapted from Facebook's React under Apache 2 license

var uppercase = /([A-Z])/g;
var hyphenate = function(str) {
    return str.replace(uppercase, "-$1").toLowerCase();
};

var ESCAPE_LOOKUP = {
    "&": "&amp;",
    ">": "&gt;",
    "<": "&lt;",
    "\"": "&quot;",
    "'": "&#x27;"
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
    return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escape(text) {
    return ("" + text).replace(ESCAPE_REGEX, escaper);
}

/**
 * A function to set the text content of a DOM element in all supported
 * browsers. Note that we don't define this if there is no document.
 */
var setTextContent;
if (typeof document !== "undefined") {
    var testNode = document.createElement("span");
    if ("textContent" in testNode) {
        setTextContent = function(node, text) {
            node.textContent = text;
        };
    } else {
        setTextContent = function(node, text) {
            node.innerText = text;
        };
    }
}

/**
 * A function to clear a node.
 */
function clearNode(node) {
    setTextContent(node, "");
}

module.exports = {
    contains: contains,
    deflt: deflt,
    escape: escape,
    hyphenate: hyphenate,
    indexOf: indexOf,
    setTextContent: setTextContent,
    clearNode: clearNode
};

},{}],101:[function(require,module,exports){
/** @flow */

"use strict";

function getRelocatable(re) {
  // In the future, this could use a WeakMap instead of an expando.
  if (!re.__matchAtRelocatable) {
    // Disjunctions are the lowest-precedence operator, so we can make any
    // pattern match the empty string by appending `|()` to it:
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-patterns
    var source = re.source + "|()";

    // We always make the new regex global.
    var flags = "g" + (re.ignoreCase ? "i" : "") + (re.multiline ? "m" : "") + (re.unicode ? "u" : "")
    // sticky (/.../y) doesn't make sense in conjunction with our relocation
    // logic, so we ignore it here.
    ;

    re.__matchAtRelocatable = new RegExp(source, flags);
  }
  return re.__matchAtRelocatable;
}

function matchAt(re, str, pos) {
  if (re.global || re.sticky) {
    throw new Error("matchAt(...): Only non-global regexes are supported");
  }
  var reloc = getRelocatable(re);
  reloc.lastIndex = pos;
  var match = reloc.exec(str);
  // Last capturing group is our sentinel that indicates whether the regex
  // matched at the given location.
  if (match[match.length - 1] == null) {
    // Original regex matched.
    match.length = match.length - 1;
    return match;
  } else {
    return null;
  }
}

module.exports = matchAt;
},{}],102:[function(require,module,exports){
"use strict";

var Observable_1 = require('./Observable');
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        } else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return this.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return this.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}();
exports.Notification = Notification;


},{"./Observable":103}],103:[function(require,module,exports){
"use strict";

var root_1 = require('./util/root');
var toSubscriber_1 = require('./util/toSubscriber');
var observable_1 = require('./symbol/observable');
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        } else {
            sink.add(this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        } catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            } else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    } catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                } else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.$$observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}();
exports.Observable = Observable;


},{"./symbol/observable":126,"./util/root":134,"./util/toSubscriber":135}],104:[function(require,module,exports){
"use strict";

exports.empty = {
    closed: true,
    next: function next(value) {},
    error: function error(err) {
        throw err;
    },
    complete: function complete() {}
};


},{}],105:[function(require,module,exports){
"use strict";
/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */

var Scheduler = function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () {
        return +new Date();
    };
    return Scheduler;
}();
exports.Scheduler = Scheduler;


},{}],106:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if ((typeof destinationOrNext === 'undefined' ? 'undefined' : _typeof(destinationOrNext)) === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    } else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return this;
    };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription);
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        } else if (observerOrNext) {
            context = observerOrNext;
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (isFunction_1.isFunction(context.unsubscribe)) {
                this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            } else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            } else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._complete);
                    this.unsubscribe();
                }
            } else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber);


},{"./Observer":104,"./Subscription":107,"./symbol/rxSubscriber":127,"./util/isFunction":132}],107:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents,
            _unsubscribe = _a._unsubscribe,
            _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        } else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || teardown === Subscription.EMPTY) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown === 'undefined' ? 'undefined' : _typeof(teardown)) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                } else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                } else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        } else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        } else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription());
    return Subscription;
}();
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) {
        return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
    }, []);
}


},{"./util/UnsubscriptionError":129,"./util/errorObject":130,"./util/isArray":131,"./util/isFunction":132,"./util/isObject":133,"./util/tryCatch":136}],108:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var fromEvent_1 = require('../../observable/fromEvent');
Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;


},{"../../Observable":103,"../../observable/fromEvent":114}],109:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var debounceTime_1 = require('../../operator/debounceTime');
Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;


},{"../../Observable":103,"../../operator/debounceTime":115}],110:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var do_1 = require('../../operator/do');
Observable_1.Observable.prototype.do = do_1._do;
Observable_1.Observable.prototype._do = do_1._do;


},{"../../Observable":103,"../../operator/do":116}],111:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var map_1 = require('../../operator/map');
Observable_1.Observable.prototype.map = map_1.map;


},{"../../Observable":103,"../../operator/map":117}],112:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var observeOn_1 = require('../../operator/observeOn');
Observable_1.Observable.prototype.observeOn = observeOn_1.observeOn;


},{"../../Observable":103,"../../operator/observeOn":118}],113:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var tryCatch_1 = require('../util/tryCatch');
var isFunction_1 = require('../util/isFunction');
var errorObject_1 = require('../util/errorObject');
var Subscription_1 = require('../Subscription');
var toString = Object.prototype.toString;
function isNodeStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isNodeList(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
}
function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
}
function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventObservable = function (_super) {
    __extends(FromEventObservable, _super);
    function FromEventObservable(sourceObj, eventName, selector, options) {
        _super.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
        this.options = options;
    }
    /* tslint:enable:max-line-length */
    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * Creates an Observable by attaching an event listener to an "event target",
     * which may be an object with `addEventListener` and `removeEventListener`,
     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
     * the output Observable is subscribed, and removed when the Subscription is
     * unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console everytime a click
     * // occurs on the document.
     *
     * @see {@link from}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOMElement, event target, Node.js
     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @param {SelectorMethodSignature<T>} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    FromEventObservable.create = function (target, eventName, options, selector) {
        if (isFunction_1.isFunction(options)) {
            selector = options;
            options = undefined;
        }
        return new FromEventObservable(target, eventName, selector, options);
    };
    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        } else if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function unsubscribe() {
                return source_1.removeEventListener(eventName, handler);
            };
        } else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function unsubscribe() {
                return source_2.off(eventName, handler);
            };
        } else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function unsubscribe() {
                return source_3.removeListener(eventName, handler);
            };
        } else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(new Subscription_1.Subscription(unsubscribe));
    };
    FromEventObservable.prototype._subscribe = function (subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var options = this.options;
        var selector = this.selector;
        var handler = selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
            if (result === errorObject_1.errorObject) {
                subscriber.error(errorObject_1.errorObject.e);
            } else {
                subscriber.next(result);
            }
        } : function (e) {
            return subscriber.next(e);
        };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
    };
    return FromEventObservable;
}(Observable_1.Observable);
exports.FromEventObservable = FromEventObservable;


},{"../Observable":103,"../Subscription":107,"../util/errorObject":130,"../util/isFunction":132,"../util/tryCatch":136}],114:[function(require,module,exports){
"use strict";

var FromEventObservable_1 = require('./FromEventObservable');
exports.fromEvent = FromEventObservable_1.FromEventObservable.create;


},{"./FromEventObservable":113}],115:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var async_1 = require('../scheduler/async');
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber);
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}


},{"../Subscriber":106,"../scheduler/async":125}],116:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
function _do(nextOrObserver, error, complete) {
    return this.lift(new DoOperator(nextOrObserver, error, complete));
}
exports._do = _do;
var DoOperator = function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":106}],117:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return this.lift(new MapOperator(project, thisArg));
}
exports.map = map;
var MapOperator = function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}();
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":106}],118:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var Notification_1 = require('../Notification');
/**
 * @see {@link Notification}
 *
 * @param scheduler
 * @param delay
 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
 * @method observeOn
 * @owner Observable
 */
function observeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return this.lift(new ObserveOnOperator(scheduler, delay));
}
exports.observeOn = observeOn;
var ObserveOnOperator = function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}();
exports.ObserveOnOperator = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        _super.call(this, destination);
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification,
            destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber);
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}();
exports.ObserveOnMessage = ObserveOnMessage;


},{"../Notification":102,"../Subscriber":106}],119:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('../Subscription');
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription_1.Subscription);
exports.Action = Action;


},{"../Subscription":107}],120:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncAction_1 = require('./AsyncAction');
var AnimationFrame_1 = require('../util/AnimationFrame');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AnimationFrameAction = function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay is greater than 0, request as an async action.
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Push the action to the end of the scheduler queue.
        scheduler.actions.push(this);
        // If an animation frame has already been requested, don't request another
        // one. If an animation frame hasn't been requested yet, request one. Return
        // the current animation frame request id.
        return scheduler.scheduled || (scheduler.scheduled = AnimationFrame_1.AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        // If the scheduler queue is empty, cancel the requested animation frame and
        // set the scheduled flag to undefined so the next AnimationFrameAction will
        // request its own.
        if (scheduler.actions.length === 0) {
            AnimationFrame_1.AnimationFrame.cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        // Return undefined so the action knows to request a new async id if it's rescheduled.
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction_1.AsyncAction);
exports.AnimationFrameAction = AnimationFrameAction;


},{"../util/AnimationFrame":128,"./AsyncAction":122}],121:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1 = require('./AsyncScheduler');
var AnimationFrameScheduler = function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        _super.apply(this, arguments);
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler_1.AsyncScheduler);
exports.AnimationFrameScheduler = AnimationFrameScheduler;


},{"./AsyncScheduler":123}],122:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Action_1 = require('./Action');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        } else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        } catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.delay = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
    };
    return AsyncAction;
}(Action_1.Action);
exports.AsyncAction = AsyncAction;


},{"../util/root":134,"./Action":119}],123:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = require('../Scheduler');
var AsyncScheduler = function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler);
exports.AsyncScheduler = AsyncScheduler;


},{"../Scheduler":105}],124:[function(require,module,exports){
"use strict";

var AnimationFrameAction_1 = require('./AnimationFrameAction');
var AnimationFrameScheduler_1 = require('./AnimationFrameScheduler');
/**
 *
 * Animation Frame Scheduler
 *
 * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
 *
 * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler
 * behaviour.
 *
 * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
 * It makes sure scheduled task will happen just before next browser content repaint,
 * thus performing animations as efficiently as possible.
 *
 * @example <caption>Schedule div height animation</caption>
 * const div = document.querySelector('.some-div');
 *
 * Rx.Scheduler.schedule(function(height) {
 *   div.style.height = height + "px";
 *
 *   this.schedule(height + 1);  // `this` references currently executing Action,
 *                               // which we reschedule with new state
 * }, 0, 0);
 *
 * // You will see .some-div element growing in height
 *
 *
 * @static true
 * @name animationFrame
 * @owner Scheduler
 */
exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);


},{"./AnimationFrameAction":120,"./AnimationFrameScheduler":121}],125:[function(require,module,exports){
"use strict";

var AsyncAction_1 = require('./AsyncAction');
var AsyncScheduler_1 = require('./AsyncScheduler');
/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);


},{"./AsyncAction":122,"./AsyncScheduler":123}],126:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function getSymbolObservable(context) {
    var $$observable;
    var _Symbol = context.Symbol;
    if (typeof _Symbol === 'function') {
        if (_Symbol.observable) {
            $$observable = _Symbol.observable;
        } else {
            $$observable = _Symbol('observable');
            _Symbol.observable = $$observable;
        }
    } else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.$$observable = getSymbolObservable(root_1.root);


},{"../util/root":134}],127:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
var _Symbol = root_1.root.Symbol;
exports.$$rxSubscriber = typeof _Symbol === 'function' && typeof _Symbol.for === 'function' ? _Symbol.for('rxSubscriber') : '@@rxSubscriber';


},{"../util/root":134}],128:[function(require,module,exports){
"use strict";

var root_1 = require('./root');
var RequestAnimationFrameDefinition = function () {
    function RequestAnimationFrameDefinition(root) {
        if (root.requestAnimationFrame) {
            this.cancelAnimationFrame = root.cancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.requestAnimationFrame.bind(root);
        } else if (root.mozRequestAnimationFrame) {
            this.cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);
        } else if (root.webkitRequestAnimationFrame) {
            this.cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);
        } else if (root.msRequestAnimationFrame) {
            this.cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.msRequestAnimationFrame.bind(root);
        } else if (root.oRequestAnimationFrame) {
            this.cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);
            this.requestAnimationFrame = root.oRequestAnimationFrame.bind(root);
        } else {
            this.cancelAnimationFrame = root.clearTimeout.bind(root);
            this.requestAnimationFrame = function (cb) {
                return root.setTimeout(cb, 1000 / 60);
            };
        }
    }
    return RequestAnimationFrameDefinition;
}();
exports.RequestAnimationFrameDefinition = RequestAnimationFrameDefinition;
exports.AnimationFrame = new RequestAnimationFrameDefinition(root_1.root);


},{"./root":134}],129:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) {
            return i + 1 + ") " + err.toString();
        }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error);
exports.UnsubscriptionError = UnsubscriptionError;


},{}],130:[function(require,module,exports){
"use strict";
// typeof any so that it we don't have to cast when comparing a result to the error object

exports.errorObject = { e: {} };


},{}],131:[function(require,module,exports){
"use strict";

exports.isArray = Array.isArray || function (x) {
  return x && typeof x.length === 'number';
};


},{}],132:[function(require,module,exports){
"use strict";

function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;


},{}],133:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isObject(x) {
    return x != null && (typeof x === "undefined" ? "undefined" : _typeof(x)) === 'object';
}
exports.isObject = isObject;


},{}],134:[function(require,module,exports){
(function (global){
"use strict";
/**
 * window: browser in DOM main thread
 * self: browser in WebWorker
 * global: Node.js/other
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.root = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object' && window.window === window && window || (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self.self === self && self || (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global.global === global && global;
if (!exports.root) {
    throw new Error('RxJS could not find any global context (window, self, global)');
}


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],135:[function(require,module,exports){
"use strict";

var Subscriber_1 = require('../Subscriber');
var rxSubscriber_1 = require('../symbol/rxSubscriber');
var Observer_1 = require('../Observer');
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;


},{"../Observer":104,"../Subscriber":106,"../symbol/rxSubscriber":127}],136:[function(require,module,exports){
"use strict";

var errorObject_1 = require('./errorObject');
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    } catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;


},{"./errorObject":130}],137:[function(require,module,exports){
// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//     You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//     See the License for the specific language governing permissions and
// limitations under the License.

!function(a,b){var c={},d={},e={},f=null;!function(a,b){function c(a){if("number"==typeof a)return a;var b={};for(var c in a)b[c]=a[c];return b}function d(){this._delay=0,this._endDelay=0,this._fill="none",this._iterationStart=0,this._iterations=1,this._duration=0,this._playbackRate=1,this._direction="normal",this._easing="linear",this._easingFunction=x}function e(){return a.isDeprecated("Invalid timing inputs","2016-03-02","TypeError exceptions will be thrown instead.",!0)}function f(b,c,e){var f=new d;return c&&(f.fill="both",f.duration="auto"),"number"!=typeof b||isNaN(b)?void 0!==b&&Object.getOwnPropertyNames(b).forEach(function(c){if("auto"!=b[c]){if(("number"==typeof f[c]||"duration"==c)&&("number"!=typeof b[c]||isNaN(b[c])))return;if("fill"==c&&v.indexOf(b[c])==-1)return;if("direction"==c&&w.indexOf(b[c])==-1)return;if("playbackRate"==c&&1!==b[c]&&a.isDeprecated("AnimationEffectTiming.playbackRate","2014-11-28","Use Animation.playbackRate instead."))return;f[c]=b[c]}}):f.duration=b,f}function g(a){return"number"==typeof a&&(a=isNaN(a)?{duration:0}:{duration:a}),a}function h(b,c){return b=a.numericTimingToObject(b),f(b,c)}function i(a,b,c,d){return a<0||a>1||c<0||c>1?x:function(e){function f(a,b,c){return 3*a*(1-c)*(1-c)*c+3*b*(1-c)*c*c+c*c*c}if(e<=0){var g=0;return a>0?g=b/a:!b&&c>0&&(g=d/c),g*e}if(e>=1){var h=0;return c<1?h=(d-1)/(c-1):1==c&&a<1&&(h=(b-1)/(a-1)),1+h*(e-1)}for(var i=0,j=1;i<j;){var k=(i+j)/2,l=f(a,c,k);if(Math.abs(e-l)<1e-5)return f(b,d,k);l<e?i=k:j=k}return f(b,d,k)}}function j(a,b){return function(c){if(c>=1)return 1;var d=1/a;return c+=b*d,c-c%d}}function k(a){C||(C=document.createElement("div").style),C.animationTimingFunction="",C.animationTimingFunction=a;var b=C.animationTimingFunction;if(""==b&&e())throw new TypeError(a+" is not a valid value for easing");return b}function l(a){if("linear"==a)return x;var b=E.exec(a);if(b)return i.apply(this,b.slice(1).map(Number));var c=F.exec(a);if(c)return j(Number(c[1]),{start:y,middle:z,end:A}[c[2]]);var d=B[a];return d?d:x}function m(a){return Math.abs(n(a)/a.playbackRate)}function n(a){return 0===a.duration||0===a.iterations?0:a.duration*a.iterations}function o(a,b,c){if(null==b)return G;var d=c.delay+a+c.endDelay;return b<Math.min(c.delay,d)?H:b>=Math.min(c.delay+a,d)?I:J}function p(a,b,c,d,e){switch(d){case H:return"backwards"==b||"both"==b?0:null;case J:return c-e;case I:return"forwards"==b||"both"==b?a:null;case G:return null}}function q(a,b,c,d,e){var f=e;return 0===a?b!==H&&(f+=c):f+=d/a,f}function r(a,b,c,d,e,f){var g=a===1/0?b%1:a%1;return 0!==g||c!==I||0===d||0===e&&0!==f||(g=1),g}function s(a,b,c,d){return a===I&&b===1/0?1/0:1===c?Math.floor(d)-1:Math.floor(d)}function t(a,b,c){var d=a;if("normal"!==a&&"reverse"!==a){var e=b;"alternate-reverse"===a&&(e+=1),d="normal",e!==1/0&&e%2!==0&&(d="reverse")}return"normal"===d?c:1-c}function u(a,b,c){var d=o(a,b,c),e=p(a,c.fill,b,d,c.delay);if(null===e)return null;var f=q(c.duration,d,c.iterations,e,c.iterationStart),g=r(f,c.iterationStart,d,c.iterations,e,c.duration),h=s(d,c.iterations,g,f),i=t(c.direction,h,g);return c._easingFunction(i)}var v="backwards|forwards|both|none".split("|"),w="reverse|alternate|alternate-reverse".split("|"),x=function(a){return a};d.prototype={_setMember:function(b,c){this["_"+b]=c,this._effect&&(this._effect._timingInput[b]=c,this._effect._timing=a.normalizeTimingInput(this._effect._timingInput),this._effect.activeDuration=a.calculateActiveDuration(this._effect._timing),this._effect._animation&&this._effect._animation._rebuildUnderlyingAnimation())},get playbackRate(){return this._playbackRate},set delay(a){this._setMember("delay",a)},get delay(){return this._delay},set endDelay(a){this._setMember("endDelay",a)},get endDelay(){return this._endDelay},set fill(a){this._setMember("fill",a)},get fill(){return this._fill},set iterationStart(a){if((isNaN(a)||a<0)&&e())throw new TypeError("iterationStart must be a non-negative number, received: "+timing.iterationStart);this._setMember("iterationStart",a)},get iterationStart(){return this._iterationStart},set duration(a){if("auto"!=a&&(isNaN(a)||a<0)&&e())throw new TypeError("duration must be non-negative or auto, received: "+a);this._setMember("duration",a)},get duration(){return this._duration},set direction(a){this._setMember("direction",a)},get direction(){return this._direction},set easing(a){this._easingFunction=l(k(a)),this._setMember("easing",a)},get easing(){return this._easing},set iterations(a){if((isNaN(a)||a<0)&&e())throw new TypeError("iterations must be non-negative, received: "+a);this._setMember("iterations",a)},get iterations(){return this._iterations}};var y=1,z=.5,A=0,B={ease:i(.25,.1,.25,1),"ease-in":i(.42,0,1,1),"ease-out":i(0,0,.58,1),"ease-in-out":i(.42,0,.58,1),"step-start":j(1,y),"step-middle":j(1,z),"step-end":j(1,A)},C=null,D="\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*",E=new RegExp("cubic-bezier\\("+D+","+D+","+D+","+D+"\\)"),F=/steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/,G=0,H=1,I=2,J=3;a.cloneTimingInput=c,a.makeTiming=f,a.numericTimingToObject=g,a.normalizeTimingInput=h,a.calculateActiveDuration=m,a.calculateIterationProgress=u,a.calculatePhase=o,a.normalizeEasing=k,a.parseEasingFunction=l}(c,f),function(a,b){function c(a,b){return a in k?k[a][b]||b:b}function d(a){return"display"===a||0===a.lastIndexOf("animation",0)||0===a.lastIndexOf("transition",0)}function e(a,b,e){if(!d(a)){var f=h[a];if(f){i.style[a]=b;for(var g in f){var j=f[g],k=i.style[j];e[j]=c(j,k)}}else e[a]=c(a,b)}}function f(a){var b=[];for(var c in a)if(!(c in["easing","offset","composite"])){var d=a[c];Array.isArray(d)||(d=[d]);for(var e,f=d.length,g=0;g<f;g++)e={},"offset"in a?e.offset=a.offset:1==f?e.offset=1:e.offset=g/(f-1),"easing"in a&&(e.easing=a.easing),"composite"in a&&(e.composite=a.composite),e[c]=d[g],b.push(e)}return b.sort(function(a,b){return a.offset-b.offset}),b}function g(b){function c(){var a=d.length;null==d[a-1].offset&&(d[a-1].offset=1),a>1&&null==d[0].offset&&(d[0].offset=0);for(var b=0,c=d[0].offset,e=1;e<a;e++){var f=d[e].offset;if(null!=f){for(var g=1;g<e-b;g++)d[b+g].offset=c+(f-c)*g/(e-b);b=e,c=f}}}if(null==b)return[];window.Symbol&&Symbol.iterator&&Array.prototype.from&&b[Symbol.iterator]&&(b=Array.from(b)),Array.isArray(b)||(b=f(b));for(var d=b.map(function(b){var c={};for(var d in b){var f=b[d];if("offset"==d){if(null!=f){if(f=Number(f),!isFinite(f))throw new TypeError("Keyframe offsets must be numbers.");if(f<0||f>1)throw new TypeError("Keyframe offsets must be between 0 and 1.")}}else if("composite"==d){if("add"==f||"accumulate"==f)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"add compositing is not supported"};if("replace"!=f)throw new TypeError("Invalid composite mode "+f+".")}else f="easing"==d?a.normalizeEasing(f):""+f;e(d,f,c)}return void 0==c.offset&&(c.offset=null),void 0==c.easing&&(c.easing="linear"),c}),g=!0,h=-(1/0),i=0;i<d.length;i++){var j=d[i].offset;if(null!=j){if(j<h)throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");h=j}else g=!1}return d=d.filter(function(a){return a.offset>=0&&a.offset<=1}),g||c(),d}var h={background:["backgroundImage","backgroundPosition","backgroundSize","backgroundRepeat","backgroundAttachment","backgroundOrigin","backgroundClip","backgroundColor"],border:["borderTopColor","borderTopStyle","borderTopWidth","borderRightColor","borderRightStyle","borderRightWidth","borderBottomColor","borderBottomStyle","borderBottomWidth","borderLeftColor","borderLeftStyle","borderLeftWidth"],borderBottom:["borderBottomWidth","borderBottomStyle","borderBottomColor"],borderColor:["borderTopColor","borderRightColor","borderBottomColor","borderLeftColor"],borderLeft:["borderLeftWidth","borderLeftStyle","borderLeftColor"],borderRadius:["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],borderRight:["borderRightWidth","borderRightStyle","borderRightColor"],borderTop:["borderTopWidth","borderTopStyle","borderTopColor"],borderWidth:["borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth"],flex:["flexGrow","flexShrink","flexBasis"],font:["fontFamily","fontSize","fontStyle","fontVariant","fontWeight","lineHeight"],margin:["marginTop","marginRight","marginBottom","marginLeft"],outline:["outlineColor","outlineStyle","outlineWidth"],padding:["paddingTop","paddingRight","paddingBottom","paddingLeft"]},i=document.createElementNS("http://www.w3.org/1999/xhtml","div"),j={thin:"1px",medium:"3px",thick:"5px"},k={borderBottomWidth:j,borderLeftWidth:j,borderRightWidth:j,borderTopWidth:j,fontSize:{"xx-small":"60%","x-small":"75%",small:"89%",medium:"100%",large:"120%","x-large":"150%","xx-large":"200%"},fontWeight:{normal:"400",bold:"700"},outlineWidth:j,textShadow:{none:"0px 0px 0px transparent"},boxShadow:{none:"0px 0px 0px 0px transparent"}};a.convertToArrayForm=f,a.normalizeKeyframes=g}(c,f),function(a){var b={};a.isDeprecated=function(a,c,d,e){var f=e?"are":"is",g=new Date,h=new Date(c);return h.setMonth(h.getMonth()+3),!(g<h&&(a in b||console.warn("Web Animations: "+a+" "+f+" deprecated and will stop working on "+h.toDateString()+". "+d),b[a]=!0,1))},a.deprecated=function(b,c,d,e){var f=e?"are":"is";if(a.isDeprecated(b,c,d,e))throw new Error(b+" "+f+" no longer supported. "+d)}}(c),function(){if(document.documentElement.animate){var a=document.documentElement.animate([],0),b=!0;if(a&&(b=!1,"play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState".split("|").forEach(function(c){void 0===a[c]&&(b=!0)})),!b)return}!function(a,b,c){function d(a){for(var b={},c=0;c<a.length;c++)for(var d in a[c])if("offset"!=d&&"easing"!=d&&"composite"!=d){var e={offset:a[c].offset,easing:a[c].easing,value:a[c][d]};b[d]=b[d]||[],b[d].push(e)}for(var f in b){var g=b[f];if(0!=g[0].offset||1!=g[g.length-1].offset)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"Partial keyframes are not supported"}}return b}function e(c){var d=[];for(var e in c)for(var f=c[e],g=0;g<f.length-1;g++){var h=g,i=g+1,j=f[h].offset,k=f[i].offset,l=j,m=k;0==g&&(l=-(1/0),0==k&&(i=h)),g==f.length-2&&(m=1/0,1==j&&(h=i)),d.push({applyFrom:l,applyTo:m,startOffset:f[h].offset,endOffset:f[i].offset,easingFunction:a.parseEasingFunction(f[h].easing),property:e,interpolation:b.propertyInterpolation(e,f[h].value,f[i].value)})}return d.sort(function(a,b){return a.startOffset-b.startOffset}),d}b.convertEffectInput=function(c){var f=a.normalizeKeyframes(c),g=d(f),h=e(g);return function(a,c){if(null!=c)h.filter(function(a){return c>=a.applyFrom&&c<a.applyTo}).forEach(function(d){var e=c-d.startOffset,f=d.endOffset-d.startOffset,g=0==f?0:d.easingFunction(e/f);b.apply(a,d.property,d.interpolation(g))});else for(var d in g)"offset"!=d&&"easing"!=d&&"composite"!=d&&b.clear(a,d)}}}(c,d,f),function(a,b,c){function d(a){return a.replace(/-(.)/g,function(a,b){return b.toUpperCase()})}function e(a,b,c){h[c]=h[c]||[],h[c].push([a,b])}function f(a,b,c){for(var f=0;f<c.length;f++){var g=c[f];e(a,b,d(g))}}function g(c,e,f){var g=c;/-/.test(c)&&!a.isDeprecated("Hyphenated property names","2016-03-22","Use camelCase instead.",!0)&&(g=d(c)),"initial"!=e&&"initial"!=f||("initial"==e&&(e=i[g]),"initial"==f&&(f=i[g]));for(var j=e==f?[]:h[g],k=0;j&&k<j.length;k++){var l=j[k][0](e),m=j[k][0](f);if(void 0!==l&&void 0!==m){var n=j[k][1](l,m);if(n){var o=b.Interpolation.apply(null,n);return function(a){return 0==a?e:1==a?f:o(a)}}}}return b.Interpolation(!1,!0,function(a){return a?f:e})}var h={};b.addPropertiesHandler=f;var i={backgroundColor:"transparent",backgroundPosition:"0% 0%",borderBottomColor:"currentColor",borderBottomLeftRadius:"0px",borderBottomRightRadius:"0px",borderBottomWidth:"3px",borderLeftColor:"currentColor",borderLeftWidth:"3px",borderRightColor:"currentColor",borderRightWidth:"3px",borderSpacing:"2px",borderTopColor:"currentColor",borderTopLeftRadius:"0px",borderTopRightRadius:"0px",borderTopWidth:"3px",bottom:"auto",clip:"rect(0px, 0px, 0px, 0px)",color:"black",fontSize:"100%",fontWeight:"400",height:"auto",left:"auto",letterSpacing:"normal",lineHeight:"120%",marginBottom:"0px",marginLeft:"0px",marginRight:"0px",marginTop:"0px",maxHeight:"none",maxWidth:"none",minHeight:"0px",minWidth:"0px",opacity:"1.0",outlineColor:"invert",outlineOffset:"0px",outlineWidth:"3px",paddingBottom:"0px",paddingLeft:"0px",paddingRight:"0px",paddingTop:"0px",right:"auto",textIndent:"0px",textShadow:"0px 0px 0px transparent",top:"auto",transform:"",verticalAlign:"0px",visibility:"visible",width:"auto",wordSpacing:"normal",zIndex:"auto"};b.propertyInterpolation=g}(c,d,f),function(a,b,c){function d(b){var c=a.calculateActiveDuration(b),d=function(d){return a.calculateIterationProgress(c,d,b)};return d._totalDuration=b.delay+c+b.endDelay,d}b.KeyframeEffect=function(c,e,f,g){var h,i=d(a.normalizeTimingInput(f)),j=b.convertEffectInput(e),k=function(){j(c,h)};return k._update=function(a){return h=i(a),null!==h},k._clear=function(){j(c,null)},k._hasSameTarget=function(a){return c===a},k._target=c,k._totalDuration=i._totalDuration,k._id=g,k},b.NullEffect=function(a){var b=function(){a&&(a(),a=null)};return b._update=function(){return null},b._totalDuration=0,b._hasSameTarget=function(){return!1},b}}(c,d,f),function(a,b){function c(a,b,c){c.enumerable=!0,c.configurable=!0,Object.defineProperty(a,b,c)}function d(a){this._surrogateStyle=document.createElementNS("http://www.w3.org/1999/xhtml","div").style,this._style=a.style,this._length=0,this._isAnimatedProperty={};for(var b=0;b<this._style.length;b++){var c=this._style[b];this._surrogateStyle[c]=this._style[c]}this._updateIndices()}function e(a){if(!a._webAnimationsPatchedStyle){var b=new d(a);try{c(a,"style",{get:function(){return b}})}catch(b){a.style._set=function(b,c){a.style[b]=c},a.style._clear=function(b){a.style[b]=""}}a._webAnimationsPatchedStyle=a.style}}var f={cssText:1,length:1,parentRule:1},g={getPropertyCSSValue:1,getPropertyPriority:1,getPropertyValue:1,item:1,removeProperty:1,setProperty:1},h={removeProperty:1,setProperty:1};d.prototype={get cssText(){return this._surrogateStyle.cssText},set cssText(a){for(var b={},c=0;c<this._surrogateStyle.length;c++)b[this._surrogateStyle[c]]=!0;this._surrogateStyle.cssText=a,this._updateIndices();for(var c=0;c<this._surrogateStyle.length;c++)b[this._surrogateStyle[c]]=!0;for(var d in b)this._isAnimatedProperty[d]||this._style.setProperty(d,this._surrogateStyle.getPropertyValue(d))},get length(){return this._surrogateStyle.length},get parentRule(){return this._style.parentRule},_updateIndices:function(){for(;this._length<this._surrogateStyle.length;)Object.defineProperty(this,this._length,{configurable:!0,enumerable:!1,get:function(a){return function(){return this._surrogateStyle[a]}}(this._length)}),this._length++;for(;this._length>this._surrogateStyle.length;)this._length--,Object.defineProperty(this,this._length,{configurable:!0,enumerable:!1,value:void 0})},_set:function(a,b){this._style[a]=b,this._isAnimatedProperty[a]=!0},_clear:function(a){this._style[a]=this._surrogateStyle[a],delete this._isAnimatedProperty[a]}};for(var i in g)d.prototype[i]=function(a,b){return function(){var c=this._surrogateStyle[a].apply(this._surrogateStyle,arguments);return b&&(this._isAnimatedProperty[arguments[0]]||this._style[a].apply(this._style,arguments),this._updateIndices()),c}}(i,i in h);for(var j in document.documentElement.style)j in f||j in g||!function(a){c(d.prototype,a,{get:function(){return this._surrogateStyle[a]},set:function(b){this._surrogateStyle[a]=b,this._updateIndices(),this._isAnimatedProperty[a]||(this._style[a]=b)}})}(j);a.apply=function(b,c,d){e(b),b.style._set(a.propertyName(c),d)},a.clear=function(b,c){b._webAnimationsPatchedStyle&&b.style._clear(a.propertyName(c))}}(d,f),function(a){window.Element.prototype.animate=function(b,c){var d="";return c&&c.id&&(d=c.id),a.timeline._play(a.KeyframeEffect(this,b,c,d))}}(d),function(a,b){function c(a,b,d){if("number"==typeof a&&"number"==typeof b)return a*(1-d)+b*d;if("boolean"==typeof a&&"boolean"==typeof b)return d<.5?a:b;if(a.length==b.length){for(var e=[],f=0;f<a.length;f++)e.push(c(a[f],b[f],d));return e}throw"Mismatched interpolation arguments "+a+":"+b}a.Interpolation=function(a,b,d){return function(e){return d(c(a,b,e))}}}(d,f),function(a,b){function c(a,b,c){return Math.max(Math.min(a,c),b)}function d(b,d,e){var f=a.dot(b,d);f=c(f,-1,1);var g=[];if(1===f)g=b;else for(var h=Math.acos(f),i=1*Math.sin(e*h)/Math.sqrt(1-f*f),j=0;j<4;j++)g.push(b[j]*(Math.cos(e*h)-f*i)+d[j]*i);return g}var e=function(){function a(a,b){for(var c=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]],d=0;d<4;d++)for(var e=0;e<4;e++)for(var f=0;f<4;f++)c[d][e]+=b[d][f]*a[f][e];return c}function b(a){return 0==a[0][2]&&0==a[0][3]&&0==a[1][2]&&0==a[1][3]&&0==a[2][0]&&0==a[2][1]&&1==a[2][2]&&0==a[2][3]&&0==a[3][2]&&1==a[3][3]}function c(c,d,e,f,g){for(var h=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],i=0;i<4;i++)h[i][3]=g[i];for(var i=0;i<3;i++)for(var j=0;j<3;j++)h[3][i]+=c[j]*h[j][i];var k=f[0],l=f[1],m=f[2],n=f[3],o=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];o[0][0]=1-2*(l*l+m*m),o[0][1]=2*(k*l-m*n),o[0][2]=2*(k*m+l*n),o[1][0]=2*(k*l+m*n),o[1][1]=1-2*(k*k+m*m),o[1][2]=2*(l*m-k*n),o[2][0]=2*(k*m-l*n),o[2][1]=2*(l*m+k*n),o[2][2]=1-2*(k*k+l*l),h=a(h,o);var p=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];e[2]&&(p[2][1]=e[2],h=a(h,p)),e[1]&&(p[2][1]=0,p[2][0]=e[0],h=a(h,p)),e[0]&&(p[2][0]=0,p[1][0]=e[0],h=a(h,p));for(var i=0;i<3;i++)for(var j=0;j<3;j++)h[i][j]*=d[i];return b(h)?[h[0][0],h[0][1],h[1][0],h[1][1],h[3][0],h[3][1]]:h[0].concat(h[1],h[2],h[3])}return c}();a.composeMatrix=e,a.quat=d}(d,f),function(a,b,c){a.sequenceNumber=0;var d=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="finish",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()};b.Animation=function(b){this.id="",b&&b._id&&(this.id=b._id),this._sequenceNumber=a.sequenceNumber++,this._currentTime=0,this._startTime=null,this._paused=!1,this._playbackRate=1,this._inTimeline=!0,this._finishedFlag=!0,this.onfinish=null,this._finishHandlers=[],this._effect=b,this._inEffect=this._effect._update(0),this._idle=!0,this._currentTimePending=!1},b.Animation.prototype={_ensureAlive:function(){this.playbackRate<0&&0===this.currentTime?this._inEffect=this._effect._update(-1):this._inEffect=this._effect._update(this.currentTime),this._inTimeline||!this._inEffect&&this._finishedFlag||(this._inTimeline=!0,b.timeline._animations.push(this))},_tickCurrentTime:function(a,b){a!=this._currentTime&&(this._currentTime=a,this._isFinished&&!b&&(this._currentTime=this._playbackRate>0?this._totalDuration:0),this._ensureAlive())},get currentTime(){return this._idle||this._currentTimePending?null:this._currentTime},set currentTime(a){a=+a,isNaN(a)||(b.restart(),this._paused||null==this._startTime||(this._startTime=this._timeline.currentTime-a/this._playbackRate),this._currentTimePending=!1,this._currentTime!=a&&(this._idle&&(this._idle=!1,this._paused=!0),this._tickCurrentTime(a,!0),b.applyDirtiedAnimation(this)))},get startTime(){return this._startTime},set startTime(a){a=+a,isNaN(a)||this._paused||this._idle||(this._startTime=a,this._tickCurrentTime((this._timeline.currentTime-this._startTime)*this.playbackRate),b.applyDirtiedAnimation(this))},get playbackRate(){return this._playbackRate},set playbackRate(a){if(a!=this._playbackRate){var c=this.currentTime;this._playbackRate=a,this._startTime=null,"paused"!=this.playState&&"idle"!=this.playState&&(this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),b.applyDirtiedAnimation(this)),null!=c&&(this.currentTime=c)}},get _isFinished(){return!this._idle&&(this._playbackRate>0&&this._currentTime>=this._totalDuration||this._playbackRate<0&&this._currentTime<=0)},get _totalDuration(){return this._effect._totalDuration},get playState(){return this._idle?"idle":null==this._startTime&&!this._paused&&0!=this.playbackRate||this._currentTimePending?"pending":this._paused?"paused":this._isFinished?"finished":"running"},_rewind:function(){if(this._playbackRate>=0)this._currentTime=0;else{if(!(this._totalDuration<1/0))throw new DOMException("Unable to rewind negative playback rate animation with infinite duration","InvalidStateError");this._currentTime=this._totalDuration}},play:function(){this._paused=!1,(this._isFinished||this._idle)&&(this._rewind(),this._startTime=null),this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),b.applyDirtiedAnimation(this)},pause:function(){this._isFinished||this._paused||this._idle?this._idle&&(this._rewind(),this._idle=!1):this._currentTimePending=!0,this._startTime=null,this._paused=!0},finish:function(){this._idle||(this.currentTime=this._playbackRate>0?this._totalDuration:0,this._startTime=this._totalDuration-this.currentTime,this._currentTimePending=!1,b.applyDirtiedAnimation(this))},cancel:function(){this._inEffect&&(this._inEffect=!1,this._idle=!0,this._paused=!1,this._isFinished=!0,this._finishedFlag=!0,this._currentTime=0,this._startTime=null,this._effect._update(null),b.applyDirtiedAnimation(this))},reverse:function(){this.playbackRate*=-1,this.play()},addEventListener:function(a,b){"function"==typeof b&&"finish"==a&&this._finishHandlers.push(b)},removeEventListener:function(a,b){if("finish"==a){var c=this._finishHandlers.indexOf(b);c>=0&&this._finishHandlers.splice(c,1)}},_fireEvents:function(a){if(this._isFinished){if(!this._finishedFlag){var b=new d(this,this._currentTime,a),c=this._finishHandlers.concat(this.onfinish?[this.onfinish]:[]);setTimeout(function(){c.forEach(function(a){a.call(b.target,b)})},0),this._finishedFlag=!0}}else this._finishedFlag=!1},_tick:function(a,b){this._idle||this._paused||(null==this._startTime?b&&(this.startTime=a-this._currentTime/this.playbackRate):this._isFinished||this._tickCurrentTime((a-this._startTime)*this.playbackRate)),b&&(this._currentTimePending=!1,this._fireEvents(a))},get _needsTick(){return this.playState in{pending:1,running:1}||!this._finishedFlag},_targetAnimations:function(){var a=this._effect._target;return a._activeAnimations||(a._activeAnimations=[]),a._activeAnimations},_markTarget:function(){var a=this._targetAnimations();a.indexOf(this)===-1&&a.push(this)},_unmarkTarget:function(){var a=this._targetAnimations(),b=a.indexOf(this);b!==-1&&a.splice(b,1)}}}(c,d,f),function(a,b,c){function d(a){var b=j;j=[],a<q.currentTime&&(a=q.currentTime),q._animations.sort(e),q._animations=h(a,!0,q._animations)[0],b.forEach(function(b){b[1](a)}),g(),l=void 0}function e(a,b){return a._sequenceNumber-b._sequenceNumber}function f(){this._animations=[],this.currentTime=window.performance&&performance.now?performance.now():0}function g(){o.forEach(function(a){a()}),o.length=0}function h(a,c,d){p=!0,n=!1;var e=b.timeline;e.currentTime=a,m=!1;var f=[],g=[],h=[],i=[];return d.forEach(function(b){b._tick(a,c),b._inEffect?(g.push(b._effect),b._markTarget()):(f.push(b._effect),b._unmarkTarget()),b._needsTick&&(m=!0);var d=b._inEffect||b._needsTick;b._inTimeline=d,d?h.push(b):i.push(b)}),o.push.apply(o,f),o.push.apply(o,g),m&&requestAnimationFrame(function(){}),p=!1,[h,i]}var i=window.requestAnimationFrame,j=[],k=0;window.requestAnimationFrame=function(a){var b=k++;return 0==j.length&&i(d),j.push([b,a]),b},window.cancelAnimationFrame=function(a){j.forEach(function(b){b[0]==a&&(b[1]=function(){})})},f.prototype={_play:function(c){c._timing=a.normalizeTimingInput(c.timing);var d=new b.Animation(c);return d._idle=!1,d._timeline=this,this._animations.push(d),b.restart(),b.applyDirtiedAnimation(d),d}};var l=void 0,m=!1,n=!1;b.restart=function(){return m||(m=!0,requestAnimationFrame(function(){}),n=!0),n},b.applyDirtiedAnimation=function(a){if(!p){a._markTarget();var c=a._targetAnimations();c.sort(e);var d=h(b.timeline.currentTime,!1,c.slice())[1];d.forEach(function(a){var b=q._animations.indexOf(a);b!==-1&&q._animations.splice(b,1)}),g()}};var o=[],p=!1,q=new f;b.timeline=q}(c,d,f),function(a,b){function c(a,b){for(var c=0,d=0;d<a.length;d++)c+=a[d]*b[d];return c}function d(a,b){return[a[0]*b[0]+a[4]*b[1]+a[8]*b[2]+a[12]*b[3],a[1]*b[0]+a[5]*b[1]+a[9]*b[2]+a[13]*b[3],a[2]*b[0]+a[6]*b[1]+a[10]*b[2]+a[14]*b[3],a[3]*b[0]+a[7]*b[1]+a[11]*b[2]+a[15]*b[3],a[0]*b[4]+a[4]*b[5]+a[8]*b[6]+a[12]*b[7],a[1]*b[4]+a[5]*b[5]+a[9]*b[6]+a[13]*b[7],a[2]*b[4]+a[6]*b[5]+a[10]*b[6]+a[14]*b[7],a[3]*b[4]+a[7]*b[5]+a[11]*b[6]+a[15]*b[7],a[0]*b[8]+a[4]*b[9]+a[8]*b[10]+a[12]*b[11],a[1]*b[8]+a[5]*b[9]+a[9]*b[10]+a[13]*b[11],a[2]*b[8]+a[6]*b[9]+a[10]*b[10]+a[14]*b[11],a[3]*b[8]+a[7]*b[9]+a[11]*b[10]+a[15]*b[11],a[0]*b[12]+a[4]*b[13]+a[8]*b[14]+a[12]*b[15],a[1]*b[12]+a[5]*b[13]+a[9]*b[14]+a[13]*b[15],a[2]*b[12]+a[6]*b[13]+a[10]*b[14]+a[14]*b[15],a[3]*b[12]+a[7]*b[13]+a[11]*b[14]+a[15]*b[15]]}function e(a){var b=a.rad||0,c=a.deg||0,d=a.grad||0,e=a.turn||0,f=(c/360+d/400+e)*(2*Math.PI)+b;return f}function f(a){switch(a.t){case"rotatex":var b=e(a.d[0]);return[1,0,0,0,0,Math.cos(b),Math.sin(b),0,0,-Math.sin(b),Math.cos(b),0,0,0,0,1];case"rotatey":var b=e(a.d[0]);return[Math.cos(b),0,-Math.sin(b),0,0,1,0,0,Math.sin(b),0,Math.cos(b),0,0,0,0,1];case"rotate":case"rotatez":var b=e(a.d[0]);return[Math.cos(b),Math.sin(b),0,0,-Math.sin(b),Math.cos(b),0,0,0,0,1,0,0,0,0,1];case"rotate3d":var c=a.d[0],d=a.d[1],f=a.d[2],b=e(a.d[3]),g=c*c+d*d+f*f;if(0===g)c=1,d=0,f=0;else if(1!==g){var h=Math.sqrt(g);c/=h,d/=h,f/=h}var i=Math.sin(b/2),j=i*Math.cos(b/2),k=i*i;return[1-2*(d*d+f*f)*k,2*(c*d*k+f*j),2*(c*f*k-d*j),0,2*(c*d*k-f*j),1-2*(c*c+f*f)*k,2*(d*f*k+c*j),0,2*(c*f*k+d*j),2*(d*f*k-c*j),1-2*(c*c+d*d)*k,0,0,0,0,1];case"scale":return[a.d[0],0,0,0,0,a.d[1],0,0,0,0,1,0,0,0,0,1];case"scalex":return[a.d[0],0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];case"scaley":return[1,0,0,0,0,a.d[0],0,0,0,0,1,0,0,0,0,1];case"scalez":return[1,0,0,0,0,1,0,0,0,0,a.d[0],0,0,0,0,1];case"scale3d":return[a.d[0],0,0,0,0,a.d[1],0,0,0,0,a.d[2],0,0,0,0,1];case"skew":var l=e(a.d[0]),m=e(a.d[1]);return[1,Math.tan(m),0,0,Math.tan(l),1,0,0,0,0,1,0,0,0,0,1];case"skewx":var b=e(a.d[0]);return[1,0,0,0,Math.tan(b),1,0,0,0,0,1,0,0,0,0,1];case"skewy":var b=e(a.d[0]);return[1,Math.tan(b),0,0,0,1,0,0,0,0,1,0,0,0,0,1];case"translate":var c=a.d[0].px||0,d=a.d[1].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,d,0,1];case"translatex":var c=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,0,0,1];case"translatey":var d=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,0,d,0,1];case"translatez":var f=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,f,1];case"translate3d":var c=a.d[0].px||0,d=a.d[1].px||0,f=a.d[2].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,d,f,1];case"perspective":var n=a.d[0].px?-1/a.d[0].px:0;return[1,0,0,0,0,1,0,0,0,0,1,n,0,0,0,1];case"matrix":return[a.d[0],a.d[1],0,0,a.d[2],a.d[3],0,0,0,0,1,0,a.d[4],a.d[5],0,1];case"matrix3d":return a.d}}function g(a){return 0===a.length?[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]:a.map(f).reduce(d)}function h(a){return[i(g(a))]}var i=function(){function a(a){return a[0][0]*a[1][1]*a[2][2]+a[1][0]*a[2][1]*a[0][2]+a[2][0]*a[0][1]*a[1][2]-a[0][2]*a[1][1]*a[2][0]-a[1][2]*a[2][1]*a[0][0]-a[2][2]*a[0][1]*a[1][0]}function b(b){for(var c=1/a(b),d=b[0][0],e=b[0][1],f=b[0][2],g=b[1][0],h=b[1][1],i=b[1][2],j=b[2][0],k=b[2][1],l=b[2][2],m=[[(h*l-i*k)*c,(f*k-e*l)*c,(e*i-f*h)*c,0],[(i*j-g*l)*c,(d*l-f*j)*c,(f*g-d*i)*c,0],[(g*k-h*j)*c,(j*e-d*k)*c,(d*h-e*g)*c,0]],n=[],o=0;o<3;o++){for(var p=0,q=0;q<3;q++)p+=b[3][q]*m[q][o];n.push(p)}return n.push(1),m.push(n),m}function d(a){return[[a[0][0],a[1][0],a[2][0],a[3][0]],[a[0][1],a[1][1],a[2][1],a[3][1]],[a[0][2],a[1][2],a[2][2],a[3][2]],[a[0][3],a[1][3],a[2][3],a[3][3]]]}function e(a,b){for(var c=[],d=0;d<4;d++){for(var e=0,f=0;f<4;f++)e+=a[f]*b[f][d];c.push(e)}return c}function f(a){var b=g(a);return[a[0]/b,a[1]/b,a[2]/b]}function g(a){return Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2])}function h(a,b,c,d){return[c*a[0]+d*b[0],c*a[1]+d*b[1],c*a[2]+d*b[2]]}function i(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]}function j(j){var k=[j.slice(0,4),j.slice(4,8),j.slice(8,12),j.slice(12,16)];if(1!==k[3][3])return null;for(var l=[],m=0;m<4;m++)l.push(k[m].slice());for(var m=0;m<3;m++)l[m][3]=0;if(0===a(l))return!1;var n,o=[];if(k[0][3]||k[1][3]||k[2][3]){o.push(k[0][3]),o.push(k[1][3]),o.push(k[2][3]),o.push(k[3][3]);var p=b(l),q=d(p);n=e(o,q)}else n=[0,0,0,1];var r=k[3].slice(0,3),s=[];s.push(k[0].slice(0,3));var t=[];t.push(g(s[0])),s[0]=f(s[0]);var u=[];s.push(k[1].slice(0,3)),u.push(c(s[0],s[1])),s[1]=h(s[1],s[0],1,-u[0]),t.push(g(s[1])),s[1]=f(s[1]),u[0]/=t[1],s.push(k[2].slice(0,3)),u.push(c(s[0],s[2])),s[2]=h(s[2],s[0],1,-u[1]),u.push(c(s[1],s[2])),s[2]=h(s[2],s[1],1,-u[2]),t.push(g(s[2])),s[2]=f(s[2]),u[1]/=t[2],u[2]/=t[2];var v=i(s[1],s[2]);if(c(s[0],v)<0)for(var m=0;m<3;m++)t[m]*=-1,s[m][0]*=-1,s[m][1]*=-1,s[m][2]*=-1;var w,x,y=s[0][0]+s[1][1]+s[2][2]+1;return y>1e-4?(w=.5/Math.sqrt(y),x=[(s[2][1]-s[1][2])*w,(s[0][2]-s[2][0])*w,(s[1][0]-s[0][1])*w,.25/w]):s[0][0]>s[1][1]&&s[0][0]>s[2][2]?(w=2*Math.sqrt(1+s[0][0]-s[1][1]-s[2][2]),x=[.25*w,(s[0][1]+s[1][0])/w,(s[0][2]+s[2][0])/w,(s[2][1]-s[1][2])/w]):s[1][1]>s[2][2]?(w=2*Math.sqrt(1+s[1][1]-s[0][0]-s[2][2]),x=[(s[0][1]+s[1][0])/w,.25*w,(s[1][2]+s[2][1])/w,(s[0][2]-s[2][0])/w]):(w=2*Math.sqrt(1+s[2][2]-s[0][0]-s[1][1]),x=[(s[0][2]+s[2][0])/w,(s[1][2]+s[2][1])/w,.25*w,(s[1][0]-s[0][1])/w]),[r,t,u,x,n]}return j}();a.dot=c,a.makeMatrixDecomposition=h}(d,f),function(a){function b(a,b){var c=a.exec(b);if(c)return c=a.ignoreCase?c[0].toLowerCase():c[0],[c,b.substr(c.length)]}function c(a,b){b=b.replace(/^\s*/,"");var c=a(b);if(c)return[c[0],c[1].replace(/^\s*/,"")]}function d(a,d,e){a=c.bind(null,a);for(var f=[];;){var g=a(e);if(!g)return[f,e];if(f.push(g[0]),e=g[1],g=b(d,e),!g||""==g[1])return[f,e];e=g[1]}}function e(a,b){for(var c=0,d=0;d<b.length&&(!/\s|,/.test(b[d])||0!=c);d++)if("("==b[d])c++;else if(")"==b[d]&&(c--,0==c&&d++,c<=0))break;var e=a(b.substr(0,d));return void 0==e?void 0:[e,b.substr(d)]}function f(a,b){for(var c=a,d=b;c&&d;)c>d?c%=d:d%=c;return c=a*b/(c+d)}function g(a){return function(b){var c=a(b);return c&&(c[0]=void 0),c}}function h(a,b){return function(c){var d=a(c);return d?d:[b,c]}}function i(b,c){for(var d=[],e=0;e<b.length;e++){var f=a.consumeTrimmed(b[e],c);if(!f||""==f[0])return;void 0!==f[0]&&d.push(f[0]),c=f[1]}if(""==c)return d}function j(a,b,c,d,e){for(var g=[],h=[],i=[],j=f(d.length,e.length),k=0;k<j;k++){var l=b(d[k%d.length],e[k%e.length]);if(!l)return;g.push(l[0]),h.push(l[1]),i.push(l[2])}return[g,h,function(b){var d=b.map(function(a,b){return i[b](a)}).join(c);return a?a(d):d}]}function k(a,b,c){for(var d=[],e=[],f=[],g=0,h=0;h<c.length;h++)if("function"==typeof c[h]){var i=c[h](a[g],b[g++]);d.push(i[0]),e.push(i[1]),f.push(i[2])}else!function(a){d.push(!1),e.push(!1),f.push(function(){return c[a]})}(h);return[d,e,function(a){for(var b="",c=0;c<a.length;c++)b+=f[c](a[c]);return b}]}a.consumeToken=b,a.consumeTrimmed=c,a.consumeRepeated=d,a.consumeParenthesised=e,a.ignore=g,a.optional=h,a.consumeList=i,a.mergeNestedRepeated=j.bind(null,null),a.mergeWrappedNestedRepeated=j,a.mergeList=k}(d),function(a){function b(b){function c(b){var c=a.consumeToken(/^inset/i,b);if(c)return d.inset=!0,c;var c=a.consumeLengthOrPercent(b);if(c)return d.lengths.push(c[0]),c;var c=a.consumeColor(b);return c?(d.color=c[0],c):void 0}var d={inset:!1,lengths:[],color:null},e=a.consumeRepeated(c,/^/,b);if(e&&e[0].length)return[d,e[1]]}function c(c){var d=a.consumeRepeated(b,/^,/,c);if(d&&""==d[1])return d[0]}function d(b,c){for(;b.lengths.length<Math.max(b.lengths.length,c.lengths.length);)b.lengths.push({px:0});for(;c.lengths.length<Math.max(b.lengths.length,c.lengths.length);)c.lengths.push({px:0});if(b.inset==c.inset&&!!b.color==!!c.color){for(var d,e=[],f=[[],0],g=[[],0],h=0;h<b.lengths.length;h++){var i=a.mergeDimensions(b.lengths[h],c.lengths[h],2==h);f[0].push(i[0]),g[0].push(i[1]),e.push(i[2])}if(b.color&&c.color){var j=a.mergeColors(b.color,c.color);f[1]=j[0],g[1]=j[1],d=j[2];
}return[f,g,function(a){for(var c=b.inset?"inset ":" ",f=0;f<e.length;f++)c+=e[f](a[0][f])+" ";return d&&(c+=d(a[1])),c}]}}function e(b,c,d,e){function f(a){return{inset:a,color:[0,0,0,0],lengths:[{px:0},{px:0},{px:0},{px:0}]}}for(var g=[],h=[],i=0;i<d.length||i<e.length;i++){var j=d[i]||f(e[i].inset),k=e[i]||f(d[i].inset);g.push(j),h.push(k)}return a.mergeNestedRepeated(b,c,g,h)}var f=e.bind(null,d,", ");a.addPropertiesHandler(c,f,["box-shadow","text-shadow"])}(d),function(a,b){function c(a){return a.toFixed(3).replace(".000","")}function d(a,b,c){return Math.min(b,Math.max(a,c))}function e(a){if(/^\s*[-+]?(\d*\.)?\d+\s*$/.test(a))return Number(a)}function f(a,b){return[a,b,c]}function g(a,b){if(0!=a)return i(0,1/0)(a,b)}function h(a,b){return[a,b,function(a){return Math.round(d(1,1/0,a))}]}function i(a,b){return function(e,f){return[e,f,function(e){return c(d(a,b,e))}]}}function j(a,b){return[a,b,Math.round]}a.clamp=d,a.addPropertiesHandler(e,i(0,1/0),["border-image-width","line-height"]),a.addPropertiesHandler(e,i(0,1),["opacity","shape-image-threshold"]),a.addPropertiesHandler(e,g,["flex-grow","flex-shrink"]),a.addPropertiesHandler(e,h,["orphans","widows"]),a.addPropertiesHandler(e,j,["z-index"]),a.parseNumber=e,a.mergeNumbers=f,a.numberToString=c}(d,f),function(a,b){function c(a,b){if("visible"==a||"visible"==b)return[0,1,function(c){return c<=0?a:c>=1?b:"visible"}]}a.addPropertiesHandler(String,c,["visibility"])}(d),function(a,b){function c(a){a=a.trim(),f.fillStyle="#000",f.fillStyle=a;var b=f.fillStyle;if(f.fillStyle="#fff",f.fillStyle=a,b==f.fillStyle){f.fillRect(0,0,1,1);var c=f.getImageData(0,0,1,1).data;f.clearRect(0,0,1,1);var d=c[3]/255;return[c[0]*d,c[1]*d,c[2]*d,d]}}function d(b,c){return[b,c,function(b){function c(a){return Math.max(0,Math.min(255,a))}if(b[3])for(var d=0;d<3;d++)b[d]=Math.round(c(b[d]/b[3]));return b[3]=a.numberToString(a.clamp(0,1,b[3])),"rgba("+b.join(",")+")"}]}var e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");e.width=e.height=1;var f=e.getContext("2d");a.addPropertiesHandler(c,d,["background-color","border-bottom-color","border-left-color","border-right-color","border-top-color","color","outline-color","text-decoration-color"]),a.consumeColor=a.consumeParenthesised.bind(null,c),a.mergeColors=d}(d,f),function(a,b){function c(a,b){if(b=b.trim().toLowerCase(),"0"==b&&"px".search(a)>=0)return{px:0};if(/^[^(]*$|^calc/.test(b)){b=b.replace(/calc\(/g,"(");var c={};b=b.replace(a,function(a){return c[a]=null,"U"+a});for(var d="U("+a.source+")",e=b.replace(/[-+]?(\d*\.)?\d+/g,"N").replace(new RegExp("N"+d,"g"),"D").replace(/\s[+-]\s/g,"O").replace(/\s/g,""),f=[/N\*(D)/g,/(N|D)[*\/]N/g,/(N|D)O\1/g,/\((N|D)\)/g],g=0;g<f.length;)f[g].test(e)?(e=e.replace(f[g],"$1"),g=0):g++;if("D"==e){for(var h in c){var i=eval(b.replace(new RegExp("U"+h,"g"),"").replace(new RegExp(d,"g"),"*0"));if(!isFinite(i))return;c[h]=i}return c}}}function d(a,b){return e(a,b,!0)}function e(b,c,d){var e,f=[];for(e in b)f.push(e);for(e in c)f.indexOf(e)<0&&f.push(e);return b=f.map(function(a){return b[a]||0}),c=f.map(function(a){return c[a]||0}),[b,c,function(b){var c=b.map(function(c,e){return 1==b.length&&d&&(c=Math.max(c,0)),a.numberToString(c)+f[e]}).join(" + ");return b.length>1?"calc("+c+")":c}]}var f="px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc",g=c.bind(null,new RegExp(f,"g")),h=c.bind(null,new RegExp(f+"|%","g")),i=c.bind(null,/deg|rad|grad|turn/g);a.parseLength=g,a.parseLengthOrPercent=h,a.consumeLengthOrPercent=a.consumeParenthesised.bind(null,h),a.parseAngle=i,a.mergeDimensions=e;var j=a.consumeParenthesised.bind(null,g),k=a.consumeRepeated.bind(void 0,j,/^/),l=a.consumeRepeated.bind(void 0,k,/^,/);a.consumeSizePairList=l;var m=function(a){var b=l(a);if(b&&""==b[1])return b[0]},n=a.mergeNestedRepeated.bind(void 0,d," "),o=a.mergeNestedRepeated.bind(void 0,n,",");a.mergeNonNegativeSizePair=n,a.addPropertiesHandler(m,o,["background-size"]),a.addPropertiesHandler(h,d,["border-bottom-width","border-image-width","border-left-width","border-right-width","border-top-width","flex-basis","font-size","height","line-height","max-height","max-width","outline-width","width"]),a.addPropertiesHandler(h,e,["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius","bottom","left","letter-spacing","margin-bottom","margin-left","margin-right","margin-top","min-height","min-width","outline-offset","padding-bottom","padding-left","padding-right","padding-top","perspective","right","shape-margin","text-indent","top","vertical-align","word-spacing"])}(d,f),function(a,b){function c(b){return a.consumeLengthOrPercent(b)||a.consumeToken(/^auto/,b)}function d(b){var d=a.consumeList([a.ignore(a.consumeToken.bind(null,/^rect/)),a.ignore(a.consumeToken.bind(null,/^\(/)),a.consumeRepeated.bind(null,c,/^,/),a.ignore(a.consumeToken.bind(null,/^\)/))],b);if(d&&4==d[0].length)return d[0]}function e(b,c){return"auto"==b||"auto"==c?[!0,!1,function(d){var e=d?b:c;if("auto"==e)return"auto";var f=a.mergeDimensions(e,e);return f[2](f[0])}]:a.mergeDimensions(b,c)}function f(a){return"rect("+a+")"}var g=a.mergeWrappedNestedRepeated.bind(null,f,e,", ");a.parseBox=d,a.mergeBoxes=g,a.addPropertiesHandler(d,g,["clip"])}(d,f),function(a,b){function c(a){return function(b){var c=0;return a.map(function(a){return a===k?b[c++]:a})}}function d(a){return a}function e(b){if(b=b.toLowerCase().trim(),"none"==b)return[];for(var c,d=/\s*(\w+)\(([^)]*)\)/g,e=[],f=0;c=d.exec(b);){if(c.index!=f)return;f=c.index+c[0].length;var g=c[1],h=n[g];if(!h)return;var i=c[2].split(","),j=h[0];if(j.length<i.length)return;for(var k=[],o=0;o<j.length;o++){var p,q=i[o],r=j[o];if(p=q?{A:function(b){return"0"==b.trim()?m:a.parseAngle(b)},N:a.parseNumber,T:a.parseLengthOrPercent,L:a.parseLength}[r.toUpperCase()](q):{a:m,n:k[0],t:l}[r],void 0===p)return;k.push(p)}if(e.push({t:g,d:k}),d.lastIndex==b.length)return e}}function f(a){return a.toFixed(6).replace(".000000","")}function g(b,c){if(b.decompositionPair!==c){b.decompositionPair=c;var d=a.makeMatrixDecomposition(b)}if(c.decompositionPair!==b){c.decompositionPair=b;var e=a.makeMatrixDecomposition(c)}return null==d[0]||null==e[0]?[[!1],[!0],function(a){return a?c[0].d:b[0].d}]:(d[0].push(0),e[0].push(1),[d,e,function(b){var c=a.quat(d[0][3],e[0][3],b[5]),g=a.composeMatrix(b[0],b[1],b[2],c,b[4]),h=g.map(f).join(",");return h}])}function h(a){return a.replace(/[xy]/,"")}function i(a){return a.replace(/(x|y|z|3d)?$/,"3d")}function j(b,c){var d=a.makeMatrixDecomposition&&!0,e=!1;if(!b.length||!c.length){b.length||(e=!0,b=c,c=[]);for(var f=0;f<b.length;f++){var j=b[f].t,k=b[f].d,l="scale"==j.substr(0,5)?1:0;c.push({t:j,d:k.map(function(a){if("number"==typeof a)return l;var b={};for(var c in a)b[c]=l;return b})})}}var m=function(a,b){return"perspective"==a&&"perspective"==b||("matrix"==a||"matrix3d"==a)&&("matrix"==b||"matrix3d"==b)},o=[],p=[],q=[];if(b.length!=c.length){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]]}else for(var f=0;f<b.length;f++){var j,s=b[f].t,t=c[f].t,u=b[f].d,v=c[f].d,w=n[s],x=n[t];if(m(s,t)){if(!d)return;var r=g([b[f]],[c[f]]);o.push(r[0]),p.push(r[1]),q.push(["matrix",[r[2]]])}else{if(s==t)j=s;else if(w[2]&&x[2]&&h(s)==h(t))j=h(s),u=w[2](u),v=x[2](v);else{if(!w[1]||!x[1]||i(s)!=i(t)){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]];break}j=i(s),u=w[1](u),v=x[1](v)}for(var y=[],z=[],A=[],B=0;B<u.length;B++){var C="number"==typeof u[B]?a.mergeNumbers:a.mergeDimensions,r=C(u[B],v[B]);y[B]=r[0],z[B]=r[1],A.push(r[2])}o.push(y),p.push(z),q.push([j,A])}}if(e){var D=o;o=p,p=D}return[o,p,function(a){return a.map(function(a,b){var c=a.map(function(a,c){return q[b][1][c](a)}).join(",");return"matrix"==q[b][0]&&16==c.split(",").length&&(q[b][0]="matrix3d"),q[b][0]+"("+c+")"}).join(" ")}]}var k=null,l={px:0},m={deg:0},n={matrix:["NNNNNN",[k,k,0,0,k,k,0,0,0,0,1,0,k,k,0,1],d],matrix3d:["NNNNNNNNNNNNNNNN",d],rotate:["A"],rotatex:["A"],rotatey:["A"],rotatez:["A"],rotate3d:["NNNA"],perspective:["L"],scale:["Nn",c([k,k,1]),d],scalex:["N",c([k,1,1]),c([k,1])],scaley:["N",c([1,k,1]),c([1,k])],scalez:["N",c([1,1,k])],scale3d:["NNN",d],skew:["Aa",null,d],skewx:["A",null,c([k,m])],skewy:["A",null,c([m,k])],translate:["Tt",c([k,k,l]),d],translatex:["T",c([k,l,l]),c([k,l])],translatey:["T",c([l,k,l]),c([l,k])],translatez:["L",c([l,l,k])],translate3d:["TTL",d]};a.addPropertiesHandler(e,j,["transform"])}(d,f),function(a){function b(a){var b=Number(a);if(!(isNaN(b)||b<100||b>900||b%100!==0))return b}function c(b){return b=100*Math.round(b/100),b=a.clamp(100,900,b),400===b?"normal":700===b?"bold":String(b)}function d(a,b){return[a,b,c]}a.addPropertiesHandler(b,d,["font-weight"])}(d),function(a){function b(a){var b={};for(var c in a)b[c]=-a[c];return b}function c(b){return a.consumeToken(/^(left|center|right|top|bottom)\b/i,b)||a.consumeLengthOrPercent(b)}function d(b,d){var e=a.consumeRepeated(c,/^/,d);if(e&&""==e[1]){var f=e[0];if(f[0]=f[0]||"center",f[1]=f[1]||"center",3==b&&(f[2]=f[2]||{px:0}),f.length==b){if(/top|bottom/.test(f[0])||/left|right/.test(f[1])){var h=f[0];f[0]=f[1],f[1]=h}if(/left|right|center|Object/.test(f[0])&&/top|bottom|center|Object/.test(f[1]))return f.map(function(a){return"object"==typeof a?a:g[a]})}}}function e(d){var e=a.consumeRepeated(c,/^/,d);if(e){for(var f=e[0],h=[{"%":50},{"%":50}],i=0,j=!1,k=0;k<f.length;k++){var l=f[k];"string"==typeof l?(j=/bottom|right/.test(l),i={left:0,right:0,center:i,top:1,bottom:1}[l],h[i]=g[l],"center"==l&&i++):(j&&(l=b(l),l["%"]=(l["%"]||0)+100),h[i]=l,i++,j=!1)}return[h,e[1]]}}function f(b){var c=a.consumeRepeated(e,/^,/,b);if(c&&""==c[1])return c[0]}var g={left:{"%":0},center:{"%":50},right:{"%":100},top:{"%":0},bottom:{"%":100}},h=a.mergeNestedRepeated.bind(null,a.mergeDimensions," ");a.addPropertiesHandler(d.bind(null,3),h,["transform-origin"]),a.addPropertiesHandler(d.bind(null,2),h,["perspective-origin"]),a.consumePosition=e,a.mergeOffsetList=h;var i=a.mergeNestedRepeated.bind(null,h,", ");a.addPropertiesHandler(f,i,["background-position","object-position"])}(d),function(a){function b(b){var c=a.consumeToken(/^circle/,b);if(c&&c[0])return["circle"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),d,a.ignore(a.consumeToken.bind(void 0,/^at/)),a.consumePosition,a.ignore(a.consumeToken.bind(void 0,/^\)/))],c[1]));var f=a.consumeToken(/^ellipse/,b);if(f&&f[0])return["ellipse"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),e,a.ignore(a.consumeToken.bind(void 0,/^at/)),a.consumePosition,a.ignore(a.consumeToken.bind(void 0,/^\)/))],f[1]));var g=a.consumeToken(/^polygon/,b);return g&&g[0]?["polygon"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),a.optional(a.consumeToken.bind(void 0,/^nonzero\s*,|^evenodd\s*,/),"nonzero,"),a.consumeSizePairList,a.ignore(a.consumeToken.bind(void 0,/^\)/))],g[1])):void 0}function c(b,c){if(b[0]===c[0])return"circle"==b[0]?a.mergeList(b.slice(1),c.slice(1),["circle(",a.mergeDimensions," at ",a.mergeOffsetList,")"]):"ellipse"==b[0]?a.mergeList(b.slice(1),c.slice(1),["ellipse(",a.mergeNonNegativeSizePair," at ",a.mergeOffsetList,")"]):"polygon"==b[0]&&b[1]==c[1]?a.mergeList(b.slice(2),c.slice(2),["polygon(",b[1],g,")"]):void 0}var d=a.consumeParenthesised.bind(null,a.parseLengthOrPercent),e=a.consumeRepeated.bind(void 0,d,/^/),f=a.mergeNestedRepeated.bind(void 0,a.mergeDimensions," "),g=a.mergeNestedRepeated.bind(void 0,f,",");a.addPropertiesHandler(b,c,["shape-outside"])}(d),function(a,b){function c(a,b){b.concat([a]).forEach(function(b){b in document.documentElement.style&&(d[a]=b)})}var d={};c("transform",["webkitTransform","msTransform"]),c("transformOrigin",["webkitTransformOrigin"]),c("perspective",["webkitPerspective"]),c("perspectiveOrigin",["webkitPerspectiveOrigin"]),a.propertyName=function(a){return d[a]||a}}(d,f)}(),!function(){if(void 0===document.createElement("div").animate([]).oncancel){var a;if(window.performance&&performance.now)var a=function(){return performance.now()};else var a=function(){return Date.now()};var b=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="cancel",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()},c=window.Element.prototype.animate;window.Element.prototype.animate=function(d,e){var f=c.call(this,d,e);f._cancelHandlers=[],f.oncancel=null;var g=f.cancel;f.cancel=function(){g.call(this);var c=new b(this,null,a()),d=this._cancelHandlers.concat(this.oncancel?[this.oncancel]:[]);setTimeout(function(){d.forEach(function(a){a.call(c.target,c)})},0)};var h=f.addEventListener;f.addEventListener=function(a,b){"function"==typeof b&&"cancel"==a?this._cancelHandlers.push(b):h.call(this,a,b)};var i=f.removeEventListener;return f.removeEventListener=function(a,b){if("cancel"==a){var c=this._cancelHandlers.indexOf(b);c>=0&&this._cancelHandlers.splice(c,1)}else i.call(this,a,b)},f}}}(),function(a){var b=document.documentElement,c=null,d=!1;try{var e=getComputedStyle(b).getPropertyValue("opacity"),f="0"==e?"1":"0";c=b.animate({opacity:[f,f]},{duration:1}),c.currentTime=0,d=getComputedStyle(b).getPropertyValue("opacity")==f}catch(a){}finally{c&&c.cancel()}if(!d){var g=window.Element.prototype.animate;window.Element.prototype.animate=function(b,c){return window.Symbol&&Symbol.iterator&&Array.prototype.from&&b[Symbol.iterator]&&(b=Array.from(b)),Array.isArray(b)||null===b||(b=a.convertToArrayForm(b)),g.call(this,b,c)}}}(c),b.true=a}({},function(){return this}());

},{}],138:[function(require,module,exports){
(function (global){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/*
 * Copyright (c) 2016 Florian Klampfer
 * Licensed under MIT
 */

// const JS_FEATURES = [
//   'fn/array/for-each',
//   'fn/function/bind',
//   'fn/number/constructor',
//   'fn/object/assign',
//   'fn/object/define-property',
//   'fn/object/keys',
// ];

// const MODERNIZR_TESTS = [
//   'customevent',
// ];

var Mix = function Mix() {
  _classCallCheck(this, Mix);
};

var _Symbol = global.Symbol || function (x) {
  return '_' + x;
};

var def = Object.defineProperty.bind(Object);

var ROOT = _Symbol('root');
var STATE = _Symbol('state');

function createEvent(eventName) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  try {
    return new CustomEvent(eventName, data);
  } catch (e) {
    var event = document.createEvent('CustomEvent');
    event.initCustomEvent(eventName, true, true, data.detail);
    return event;
  }
}

function setupProperty(key, sideEffect) {
  var _this = this;

  def(this, key, {
    enumerable: true,
    get: function get() {
      return _this[STATE][key];
    },
    set: function set(value) {
      if (sideEffect != null) {
        sideEffect(value);
      } else {
        _this.setState(key, value);
      }
    }
  });
}

// TODO: study how native elements deal with attributes/properites
function setupProperties() {
  var _this2 = this;

  var sideEffects = this.sideEffects();

  Object.keys(this[STATE]).forEach(function (key) {
    if (typeof _this2[key] === 'undefined') {
      var sideEffect = sideEffects[key];
      setupProperty.call(_this2, key, sideEffect);
    }
  });
}

exports.default = function () {
  var C = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Mix;
  return function (_C) {
    _inherits(_class, _C);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'getComponentName',
      value: function getComponentName() {
        throw Error('Component needs to have a name, e.g. `my-tag`. Override `getComponentName`');
      }
    }, {
      key: 'setupComponent',
      value: function setupComponent(el, state) {
        def(this, STATE, { value: Object.assign({}, this.defaults(), state) });
        setupProperties.call(this);
        def(this, ROOT, { value: this.setupDOM(el) });
        return this;
      }
    }, {
      key: 'setupDOM',
      value: function setupDOM(el) {
        return el;
      }
    }, {
      key: 'getRoot',
      value: function getRoot() {
        return this[ROOT];
      }
    }, {
      key: 'getEl',
      value: function getEl() {
        return this[ROOT];
      }
    }, {
      key: 'fireEvent',
      value: function fireEvent(eventName, data) {
        var eventNameNS = this.componentName + '-' + eventName;
        this.el.dispatchEvent(createEvent(eventNameNS, data));
      }
    }, {
      key: 'defaults',
      value: function defaults() {
        // TODO: production builds with preprocess?
        console.warn('defaults not provided'); // eslint-disable-line no-console
        return {};
      }
    }, {
      key: 'sideEffects',
      value: function sideEffects() {
        // TODO: production builds with preprocess?
        console.warn('sideEffects not provided'); // eslint-disable-line no-console
        return {};
      }
    }, {
      key: 'setState',
      value: function setState(keyOrMap, value) {
        if (typeof keyOrMap === 'string') {
          this.setStateKV(keyOrMap, value);
        } else if ((typeof keyOrMap === 'undefined' ? 'undefined' : _typeof(keyOrMap)) === 'object') {
          this.setStateMap(keyOrMap);
        } else {
          throw Error('setState needs argument');
        }
      }
    }, {
      key: 'setStateKV',
      value: function setStateKV(key, value) {
        this[STATE][key] = value;
      }
    }, {
      key: 'setStateMap',
      value: function setStateMap(map) {
        var _this4 = this;

        Object.keys(this[STATE]).forEach(function (key) {
          _this4.setStateKV(key, map[key]);
        });
      }
    }, {
      key: 'componentName',
      get: function get() {
        return this.getComponentName();
      }
    }, {
      key: 'root',
      get: function get() {
        return this.getRoot();
      }
    }, {
      key: 'el',
      get: function get() {
        return this.getEl();
      }
    }]);

    return _class;
  }(C);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],139:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
  * @param t current time
  * @param b start value
  * @param c change in value
  * @param d duration
  * @returns {number}
  */
function linearTween(t, b, c, d) {
  return c * t / d + b;
}

function pageDist(p1, p2) {
  return Math.sqrt(Math.pow(p1.pageX - p2.pageX, 2) + Math.pow(p1.pageY - p2.pageY, 2));
}

function contains(target, className) {
  var t = target;
  while (t != null) {
    if (t.classList && t.classList.contains(className)) {
      return true;
    }
    t = t.parentNode;
  }
  return false;
}

exports.linearTween = linearTween;
exports.pageDist = pageDist;
exports.contains = contains;

},{}],140:[function(require,module,exports){
(function (global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _componentCore2 = require('y-component/src/component-core');

var _componentCore3 = _interopRequireDefault(_componentCore2);

var _common = require('../common');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /*
   * Adapted from Ratchet's sliders.js
   * http://goratchet.com/components#sliders
   *
   * Adapted from Brad Birdsall's Swipe
   * https://github.com/thebird/Swipe
   *
   * Copyright (c) 2016 Florian Klampfer
   * Licensed under MIT
   */
/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

// const JS_FEATURES = [
//   'fn/array/for-each',
//   'fn/function/bind',
//   'fn/number/constructor',
//   'fn/object/assign',
//   'fn/object/define-property',
//   'fn/object/keys',
//   'fn/array/reduce',
// ];
//
// const MODERNIZR_TESTS = [
//   'customevent',
//   'eventlistener',
//   'queryselector',
//   'requestanimationframe',
//   'classlist',
//   'opacity',
//   'csstransforms',
//   'csspointerevents',
// ];

var _Symbol = global.Symbol || function (x) {
  return '_' + x;
};

var IDLE = _Symbol('idle');
var TOUCHING = _Symbol('touching');
var START_ANIMATING = _Symbol('startAnimating');
var ANIMATING = _Symbol('animating');

var VELOCITY_THRESHOLD = 0.2;
var VELOCITY_LINEAR_COMBINATION = 0.8;

var def = Object.defineProperty.bind(Object);

exports.default = function (C) {
  return function (_componentCore) {
    _inherits(_class, _componentCore);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'getComponentName',

      // @override
      value: function getComponentName() {
        return 'y-drawer';
      }

      // @override

    }, {
      key: 'setupComponent',
      value: function setupComponent(el, props) {
        _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'setupComponent', this).call(this, el, props);

        this.cacheDOMElements();
        this.defProperties();
        this.bindCallbacks();

        this.jumpTo(this.opened);
        if (!this.persistent) this.addEventListeners();
        if (this.persistent) this.scrim.style.display = 'none';

        return this;
      }
    }, {
      key: 'setupDOM',
      value: function setupDOM(el) {
        return el;
      }
    }, {
      key: 'cacheDOMElements',
      value: function cacheDOMElements() {
        def(this, 'scrim', { value: this.root.querySelector('.y-drawer-scrim') });
        def(this, 'content', { value: this.root.querySelector('.y-drawer-content') });
      }
    }, {
      key: 'defProperties',
      value: function defProperties() {
        def(this, 'startX', { value: 0, writable: true });
        def(this, 'startY', { value: 0, writable: true });
        def(this, 'pageX', { value: 0, writable: true });
        def(this, 'pageY', { value: 0, writable: true });
        def(this, 'lastPageX', { value: 0, writable: true });
        def(this, 'lastPageY', { value: 0, writable: true });
        def(this, 'isScrolling', { writable: true });
        def(this, 'startedMoving', { value: false, writable: true });
        def(this, 'loopState', { value: IDLE, writable: true });
        def(this, 'velocity', { value: 0, writable: true });
        def(this, 'startTranslateX', { value: 0, writable: true });
        def(this, 'translateX', { value: 0, writable: true });
        def(this, 'animationFrameRequested', { value: false, writable: true });
        def(this, 'touching', { value: false, writable: true });
        def(this, 'lastTime', { writable: true });
        def(this, 'sliderWidth', { writable: true });
        def(this, 'animation', { writable: true, configurable: true });
      }
    }, {
      key: 'bindCallbacks',
      value: function bindCallbacks() {
        def(this, 'touchStartCallback', { value: this.touchStartCallback.bind(this) });
        def(this, 'touchMoveCallback', { value: this.touchMoveCallback.bind(this) });
        def(this, 'touchEndCallback', { value: this.touchEndCallback.bind(this) });
        def(this, 'scrimClickCallback', { value: this.scrimClickCallback.bind(this) });
        def(this, 'animationFrameCallback', { value: this.animationFrameCallback.bind(this) });
      }
    }, {
      key: 'addEventListeners',
      value: function addEventListeners() {
        document.addEventListener('touchstart', this.touchStartCallback, { passive: false });
        document.addEventListener('touchmove', this.touchMoveCallback, { passive: false });
        document.addEventListener('touchend', this.touchEndCallback, { passive: false });

        this.scrim.addEventListener('click', this.scrimClickCallback);
      }
    }, {
      key: 'removeEventListeners',
      value: function removeEventListeners() {
        document.removeEventListener('touchstart', this.touchStartCallback, { passive: false });
        document.removeEventListener('touchmove', this.touchMoveCallback, { passive: false });
        document.removeEventListener('touchend', this.touchEndCallback, { passive: false });

        this.scrim.removeEventListener('click', this.scrimClickCallback);
      }
    }, {
      key: 'requestAnimationLoop',
      value: function requestAnimationLoop() {
        if (!this.animationFrameRequested) {
          this.animationFrameRequested = true;
          requestAnimationFrame(this.animationFrameCallback);
        }
      }
    }, {
      key: 'getNearestTouch',
      value: function getNearestTouch(touches) {
        var _this2 = this;

        if (touches.length === 1) return touches[0];
        return Array.prototype.reduce.call(touches, function (acc, touch) {
          var dist = (0, _common.pageDist)(_this2, touch);
          return dist < acc.dist ? {
            dist: dist,
            touch: touch
          } : acc;
        }, {
          dist: Number.POSITIVE_INFINITY,
          touch: null
        }).touch;
      }
    }, {
      key: 'touchStartCallback',
      value: function touchStartCallback(e) {
        if (e.touches.length === 1) {
          this.isScrolling = undefined;

          var touch = e.touches[0];
          this.startX = touch.pageX;
          this.startY = touch.pageY;
          this.pageX = touch.pageX;
          this.pageY = touch.pageY;
          this.lastPageX = touch.pageX;
          this.lastPageY = touch.pageY;

          if (this.opened || this.pageX < window.innerWidth / 3) {
            this.prepInteraction();
            this.touching = true;
            this.loopState = TOUCHING;
          }
        }
      }
    }, {
      key: 'touchMoveCallback',
      value: function touchMoveCallback(e) {
        if (this.touching) {
          var touch = this.getNearestTouch(e.touches);
          this.pageX = touch.pageX;
          this.pageY = touch.pageY;

          if (typeof this.isScrolling === 'undefined' && this.startedMoving) {
            this.isScrolling = Math.abs(this.startY - this.pageY) > Math.abs(this.startX - this.pageX);
            if (!this.isScrolling) {
              this.loopState = TOUCHING;
              this.requestAnimationLoop();
            }
          }

          if (this.isScrolling) {
            return;
          }

          e.preventDefault();

          this.startedMoving = true;
        }
      }
    }, {
      key: 'updateMenuOpen',
      value: function updateMenuOpen() {
        if (this.velocity > VELOCITY_THRESHOLD) {
          this.setState('opened', true);
        } else if (this.velocity < -VELOCITY_THRESHOLD) {
          this.setState('opened', false);
        } else if (this.translateX >= this.sliderWidth / 2) {
          this.setState('opened', true);
        } else {
          this.setState('opened', false);
        }
      }
    }, {
      key: 'touchEndCallback',
      value: function touchEndCallback(e) {
        if (this.touching) {
          if (this.isScrolling || e.touches.length > 0) {
            return;
          }

          if (this.startedMoving) {
            this.updateMenuOpen();
          }

          if (this.opened) {
            this.scrim.style.pointerEvents = 'all';
          } else {
            this.scrim.style.pointerEvents = '';
          }

          this.loopState = START_ANIMATING;
          this.startedMoving = false;
          this.touching = false;
        }
      }
    }, {
      key: 'scrimClickCallback',
      value: function scrimClickCallback() {
        this.close();
      }
    }, {
      key: 'prepInteraction',
      value: function prepInteraction() {
        this.content.style.willChange = 'transform';
        this.scrim.style.willChange = 'opacity';
        this.content.classList.remove('y-drawer-opened');
        this.sliderWidth = this.getMovableSliderWidth();
      }
    }, {
      key: 'getMovableSliderWidth',
      value: function getMovableSliderWidth() {
        // Since part of the slider could be visible,
        // the width that is "movable" is less than the complete slider width
        // and given by
        return -this.content.offsetLeft;
      }
    }, {
      key: 'animateTo',
      value: function animateTo(opened) {
        this.prepInteraction();
        this.setState('opened', opened);
        this.loopState = START_ANIMATING;
        this.requestAnimationLoop();
      }
    }, {
      key: 'jumpTo',
      value: function jumpTo(opened) {
        var _this3 = this;

        this.prepInteraction();
        this.setState('opened', opened);
        this.loopState = IDLE;
        requestAnimationFrame(function () {
          _this3.startTranslateX = opened * _this3.sliderWidth;
          _this3.endAnimating();
          _this3.updateDOM(_this3.startTranslateX, _this3.sliderWidth);
        });
      }
    }, {
      key: 'updateTranslateX',
      value: function updateTranslateX() {
        var deltaX = this.pageX - this.startX;
        this.translateX = this.startTranslateX + deltaX;
        this.translateX = Math.max(0, Math.min(this.sliderWidth, this.translateX));
        return deltaX;
      }
    }, {
      key: 'animationFrameCallback',
      value: function animationFrameCallback(time) {
        switch (this.loopState) {
          case TOUCHING:
            {
              this.touchingFrame(time);
              break;
            }

          case START_ANIMATING:
            {
              this.startAnimatingFrame(time);
              this.loopState = ANIMATING;
              this.animationFrameCallback(time); // jump to next case block
              break;
            }

          case ANIMATING:
            {
              this.animatingFrame(time);
              break;
            }

          default:
            {
              break;
            }
        }
      }
    }, {
      key: 'touchingFrame',
      value: function touchingFrame(time) {
        var timeDiff = time - this.lastTime;

        if (timeDiff > 0) {
          var pageXDiff = this.pageX - this.lastPageX;
          this.velocity = VELOCITY_LINEAR_COMBINATION * (pageXDiff / timeDiff) + (1 - VELOCITY_LINEAR_COMBINATION) * this.velocity;
        }

        this.updateTranslateX();
        this.updateDOM(this.translateX, this.sliderWidth);

        this.lastTime = time;
        this.lastPageX = this.pageX;
        this.lastPageY = this.pageY;

        requestAnimationFrame(this.animationFrameCallback);
      }
    }, {
      key: 'startAnimatingFrame',
      value: function startAnimatingFrame(time) {
        this.updateTranslateX();

        // store all animation related data in this object,
        // delete after animation is completed
        var animation = {};
        animation.startX = this.translateX;
        animation.endX = (this.opened ? 1 : 0) * this.sliderWidth;
        animation.changeInValue = animation.endX - animation.startX;
        animation.startTime = time;
        this.animation = animation;
      }
    }, {
      key: 'animatingFrame',
      value: function animatingFrame(time) {
        var timeInAnimation = time - this.animation.startTime;

        if (timeInAnimation < this.transitionDuration) {
          this.animatingCont(timeInAnimation);
        } else {
          this.animatingEnd();
        }

        this.updateDOM(this.startTranslateX, this.sliderWidth);
      }
    }, {
      key: 'animatingCont',
      value: function animatingCont(timeInAnimation) {
        var startValue = this.animation.startX;
        var changeInValue = this.animation.changeInValue;
        this.startTranslateX = (0, _common.linearTween)(timeInAnimation, startValue, changeInValue, this.transitionDuration);
        requestAnimationFrame(this.animationFrameCallback);
      }
    }, {
      key: 'animatingEnd',
      value: function animatingEnd() {
        // end animation
        this.startTranslateX = this.animation.endX;
        delete this.animation;
        this.endAnimating();
      }
    }, {
      key: 'endAnimating',
      value: function endAnimating() {
        this.animationFrameRequested = false;
        this.loopState = IDLE;
        this.velocity = 0;

        if (this.opened) {
          // document.body.style.overflowY = 'hidden';
          this.scrim.style.pointerEvents = 'all';
          this.content.classList.add('y-drawer-opened');
        } else {
          // document.body.style.overflowY = '';
          this.scrim.style.pointerEvents = '';

          // only remove the styles when closing the drawer,
          // since we eitehr expect a navigation (page reload)
          // or closing the drawer again, ie more changes
          this.content.style.willChange = '';
          this.scrim.style.willChange = '';
        }

        this.fireEvent('transitioned');
      }
    }, {
      key: 'updateDOM',
      value: function updateDOM(translateX, sliderWidth) {
        this.content.style.transform = 'translateX(' + translateX + 'px)';
        this.scrim.style.opacity = translateX / sliderWidth;
      }

      // @override

    }, {
      key: 'defaults',
      value: function defaults() {
        return {
          opened: false,
          transitionDuration: 200,
          persistent: false
        };
      }

      // @override

    }, {
      key: 'sideEffects',
      value: function sideEffects() {
        var _this4 = this;

        return {
          opened: function opened(o) {
            if (o === true) _this4.open();else _this4.close();
          },
          persistent: function persistent(d) {
            if (d === true) _this4.persist();else _this4.unpersist();
          }
        };
      }
    }, {
      key: 'close',
      value: function close() {
        this.animateTo(false);
        return this;
      }
    }, {
      key: 'open',
      value: function open() {
        this.animateTo(true);
        return this;
      }
    }, {
      key: 'toggle',
      value: function toggle() {
        if (this.opened) {
          this.close();
        } else {
          this.open();
        }
        return this;
      }
    }, {
      key: 'persist',
      value: function persist() {
        this.scrim.style.display = 'none';
        this.removeEventListeners();
        this.setState('persistent', true);
      }
    }, {
      key: 'unpersist',
      value: function unpersist() {
        this.scrim.style.display = '';
        this.addEventListeners();
        this.setState('persistent', false);
      }
    }]);

    return _class;
  }((0, _componentCore3.default)(C));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common":139,"y-component/src/component-core":138}],141:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /*
   * Copyright (c) 2016 Florian Klampfer
   * Licensed under MIT
   */

/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

var style = '\n<style>\n.y-drawer-scrim {\n  display: block;\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  opacity: 0;\n  z-index: 0;\n  pointer-events: none;\n  transform: translate3d(0,0,0);\n  -webkit-tap-highlight-color: transparent;\n  contain: content;\n\n  background: rgba(0, 0, 0, 0.67);\n}\n\n.y-drawer-content {\n  position: fixed;\n  left: 0;\n  bottom: 0;\n  top: 0;\n  z-index: 1;\n  overflow-x: hidden;\n  overflow-y: auto;\n  transform: translate3d(0,0,0);\n  -webkit-overflow-scrolling: touch;\n  contain: content;\n\n  left: -18rem;\n  width: 18rem;\n  background: #e8e8e8;\n}\n\n.y-drawer-content.y-drawer-opened {\n  left: 0!important;\n  transform: translate3d(0,0,0)!important;\n}\n\n</style>';

function fragmentFromString(strHTML) {
  return document.createRange().createContextualFragment(strHTML);
}

var Drawer = function (_drawerCore) {
  _inherits(Drawer, _drawerCore);

  function Drawer(el, props) {
    _classCallCheck(this, Drawer);

    var _this = _possibleConstructorReturn(this, (Drawer.__proto__ || Object.getPrototypeOf(Drawer)).call(this));

    _this.setupComponent(el, props);
    return _this;
  }

  // @override


  _createClass(Drawer, [{
    key: 'setupDOM',
    value: function setupDOM(el) {
      if (!el) throw Error('No element provided');

      var scrim = document.createElement('div');
      scrim.classList.add('y-drawer-scrim');

      var content = document.createElement('div');
      content.classList.add('y-drawer-content');
      while (el.children.length > 0) {
        content.appendChild(el.children[0]);
      }

      el.appendChild(scrim);
      el.appendChild(content);

      var ref = document.getElementsByTagName('style')[0];
      ref.parentNode.insertBefore(fragmentFromString(style), ref);

      return el;
    }
  }]);

  return Drawer;
}((0, _core2.default)());

exports.default = Drawer;

},{"../core":140}],142:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber);
exports.InnerSubscriber = InnerSubscriber;


},{"./Subscriber":150}],143:[function(require,module,exports){
arguments[4][102][0].apply(exports,arguments)
},{"./Observable":144,"dup":102}],144:[function(require,module,exports){
arguments[4][103][0].apply(exports,arguments)
},{"./symbol/observable":217,"./util/root":231,"./util/toSubscriber":233,"dup":103}],145:[function(require,module,exports){
arguments[4][104][0].apply(exports,arguments)
},{"dup":104}],146:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber);
exports.OuterSubscriber = OuterSubscriber;


},{"./Subscriber":150}],147:[function(require,module,exports){
arguments[4][105][0].apply(exports,arguments)
},{"dup":105}],148:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber);
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        } else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable);
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        } else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject);
exports.AnonymousSubject = AnonymousSubject;


},{"./Observable":144,"./SubjectSubscription":149,"./Subscriber":150,"./Subscription":151,"./symbol/rxSubscriber":218,"./util/ObjectUnsubscribedError":221}],149:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription);
exports.SubjectSubscription = SubjectSubscription;


},{"./Subscription":151}],150:[function(require,module,exports){
arguments[4][106][0].apply(exports,arguments)
},{"./Observer":145,"./Subscription":151,"./symbol/rxSubscriber":218,"./util/isFunction":227,"dup":106}],151:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"./util/UnsubscriptionError":222,"./util/errorObject":223,"./util/isArray":224,"./util/isFunction":227,"./util/isObject":228,"./util/tryCatch":234,"dup":107}],152:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var defer_1 = require('../../observable/defer');
Observable_1.Observable.defer = defer_1.defer;


},{"../../Observable":144,"../../observable/defer":182}],153:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../../Observable');
var ajax_1 = require('../../../observable/dom/ajax');
Observable_1.Observable.ajax = ajax_1.ajax;


},{"../../../Observable":144,"../../../observable/dom/ajax":184}],154:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var empty_1 = require('../../observable/empty');
Observable_1.Observable.empty = empty_1.empty;


},{"../../Observable":144,"../../observable/empty":185}],155:[function(require,module,exports){
arguments[4][108][0].apply(exports,arguments)
},{"../../Observable":144,"../../observable/fromEvent":186,"dup":108}],156:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var merge_1 = require('../../observable/merge');
Observable_1.Observable.merge = merge_1.merge;


},{"../../Observable":144,"../../observable/merge":187}],157:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var of_1 = require('../../observable/of');
Observable_1.Observable.of = of_1.of;


},{"../../Observable":144,"../../observable/of":188}],158:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var throw_1 = require('../../observable/throw');
Observable_1.Observable.throw = throw_1._throw;


},{"../../Observable":144,"../../observable/throw":189}],159:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var catch_1 = require('../../operator/catch');
Observable_1.Observable.prototype.catch = catch_1._catch;
Observable_1.Observable.prototype._catch = catch_1._catch;


},{"../../Observable":144,"../../operator/catch":190}],160:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var delay_1 = require('../../operator/delay');
Observable_1.Observable.prototype.delay = delay_1.delay;


},{"../../Observable":144,"../../operator/delay":192}],161:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var distinctUntilKeyChanged_1 = require('../../operator/distinctUntilKeyChanged');
Observable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;


},{"../../Observable":144,"../../operator/distinctUntilKeyChanged":194}],162:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"../../Observable":144,"../../operator/do":195,"dup":110}],163:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var filter_1 = require('../../operator/filter');
Observable_1.Observable.prototype.filter = filter_1.filter;


},{"../../Observable":144,"../../operator/filter":196}],164:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"../../Observable":144,"../../operator/map":197,"dup":111}],165:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var merge_1 = require('../../operator/merge');
Observable_1.Observable.prototype.merge = merge_1.merge;


},{"../../Observable":144,"../../operator/merge":198}],166:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var mergeAll_1 = require('../../operator/mergeAll');
Observable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;


},{"../../Observable":144,"../../operator/mergeAll":199}],167:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"../../Observable":144,"../../operator/observeOn":201,"dup":112}],168:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var share_1 = require('../../operator/share');
Observable_1.Observable.prototype.share = share_1.share;


},{"../../Observable":144,"../../operator/share":202}],169:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var startWith_1 = require('../../operator/startWith');
Observable_1.Observable.prototype.startWith = startWith_1.startWith;


},{"../../Observable":144,"../../operator/startWith":203}],170:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var switch_1 = require('../../operator/switch');
Observable_1.Observable.prototype.switch = switch_1._switch;
Observable_1.Observable.prototype._switch = switch_1._switch;


},{"../../Observable":144,"../../operator/switch":204}],171:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var switchMap_1 = require('../../operator/switchMap');
Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;


},{"../../Observable":144,"../../operator/switchMap":205}],172:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var take_1 = require('../../operator/take');
Observable_1.Observable.prototype.take = take_1.take;


},{"../../Observable":144,"../../operator/take":206}],173:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var withLatestFrom_1 = require('../../operator/withLatestFrom');
Observable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;


},{"../../Observable":144,"../../operator/withLatestFrom":207}],174:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var zip_1 = require('../../operator/zip');
Observable_1.Observable.prototype.zip = zip_1.zipProto;


},{"../../Observable":144,"../../operator/zip":208}],175:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var ScalarObservable_1 = require('./ScalarObservable');
var EmptyObservable_1 = require('./EmptyObservable');
var isScheduler_1 = require('../util/isScheduler');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        } else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        } else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        } else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array,
            index = state.index,
            count = state.count,
            subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable);
exports.ArrayObservable = ArrayObservable;


},{"../Observable":144,"../util/isScheduler":230,"./EmptyObservable":178,"./ScalarObservable":181}],176:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('../Subject');
var Observable_1 = require('../Observable');
var Subscriber_1 = require('../Subscriber');
var Subscription_1 = require('../Subscription');
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            } else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return this.lift(new RefCountOperator(this));
    };
    return ConnectableObservable;
}(Observable_1.Observable);
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subscribe: { value: ConnectableObservable.prototype._subscribe },
    getSubject: { value: ConnectableObservable.prototype.getSubject },
    connect: { value: ConnectableObservable.prototype.connect },
    refCount: { value: ConnectableObservable.prototype.refCount }
};
var ConnectableSubscriber = function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber);
var RefCountOperator = function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}();
var RefCountSubscriber = function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber);


},{"../Observable":144,"../Subject":148,"../Subscriber":150,"../Subscription":151}],177:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var subscribeToResult_1 = require('../util/subscribeToResult');
var OuterSubscriber_1 = require('../OuterSubscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var DeferObservable = function (_super) {
    __extends(DeferObservable, _super);
    function DeferObservable(observableFactory) {
        _super.call(this);
        this.observableFactory = observableFactory;
    }
    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * // Results in the following behavior:
     * // If the result of Math.random() is greater than 0.5 it will listen
     * // for clicks anywhere on the "document"; when document is clicked it
     * // will log a MouseEvent object to the console. If the result is less
     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
     *
     * @see {@link create}
     *
     * @param {function(): SubscribableOrPromise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */
    DeferObservable.create = function (observableFactory) {
        return new DeferObservable(observableFactory);
    };
    DeferObservable.prototype._subscribe = function (subscriber) {
        return new DeferSubscriber(subscriber, this.observableFactory);
    };
    return DeferObservable;
}(Observable_1.Observable);
exports.DeferObservable = DeferObservable;
var DeferSubscriber = function (_super) {
    __extends(DeferSubscriber, _super);
    function DeferSubscriber(destination, factory) {
        _super.call(this, destination);
        this.factory = factory;
        this.tryDefer();
    }
    DeferSubscriber.prototype.tryDefer = function () {
        try {
            this._callFactory();
        } catch (err) {
            this._error(err);
        }
    };
    DeferSubscriber.prototype._callFactory = function () {
        var result = this.factory();
        if (result) {
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return DeferSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../Observable":144,"../OuterSubscriber":146,"../util/subscribeToResult":232}],178:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        } else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable);
exports.EmptyObservable = EmptyObservable;


},{"../Observable":144}],179:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ErrorObservable = function (_super) {
    __extends(ErrorObservable, _super);
    function ErrorObservable(error, scheduler) {
        _super.call(this);
        this.error = error;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x === 13 ?
     *     Rx.Observable.throw('Thirteens are bad') :
     *     Rx.Observable.of('a', 'b', 'c')
     * );
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */
    ErrorObservable.create = function (error, scheduler) {
        return new ErrorObservable(error, scheduler);
    };
    ErrorObservable.dispatch = function (arg) {
        var error = arg.error,
            subscriber = arg.subscriber;
        subscriber.error(error);
    };
    ErrorObservable.prototype._subscribe = function (subscriber) {
        var error = this.error;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ErrorObservable.dispatch, 0, {
                error: error, subscriber: subscriber
            });
        } else {
            subscriber.error(error);
        }
    };
    return ErrorObservable;
}(Observable_1.Observable);
exports.ErrorObservable = ErrorObservable;


},{"../Observable":144}],180:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"../Observable":144,"../Subscription":151,"../util/errorObject":223,"../util/isFunction":227,"../util/tryCatch":234,"dup":113}],181:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done,
            value = state.value,
            subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        } else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable);
exports.ScalarObservable = ScalarObservable;


},{"../Observable":144}],182:[function(require,module,exports){
"use strict";

var DeferObservable_1 = require('./DeferObservable');
exports.defer = DeferObservable_1.DeferObservable.create;


},{"./DeferObservable":177}],183:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../../util/root');
var tryCatch_1 = require('../../util/tryCatch');
var errorObject_1 = require('../../util/errorObject');
var Observable_1 = require('../../Observable');
var Subscriber_1 = require('../../Subscriber');
var map_1 = require('../../operator/map');
function getCORSRequest() {
    if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
    } else if (!!root_1.root.XDomainRequest) {
        return new root_1.root.XDomainRequest();
    } else {
        throw new Error('CORS is not supported by your browser');
    }
}
function getXMLHttpRequest() {
    if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
    } else {
        var progId = void 0;
        try {
            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
            for (var i = 0; i < 3; i++) {
                try {
                    progId = progIds[i];
                    if (new root_1.root.ActiveXObject(progId)) {
                        break;
                    }
                } catch (e) {}
            }
            return new root_1.root.ActiveXObject(progId);
        } catch (e) {
            throw new Error('XMLHttpRequest is not supported by your browser');
        }
    }
}
function ajaxGet(url, headers) {
    if (headers === void 0) {
        headers = null;
    }
    return new AjaxObservable({ method: 'GET', url: url, headers: headers });
}
exports.ajaxGet = ajaxGet;
;
function ajaxPost(url, body, headers) {
    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });
}
exports.ajaxPost = ajaxPost;
;
function ajaxDelete(url, headers) {
    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });
}
exports.ajaxDelete = ajaxDelete;
;
function ajaxPut(url, body, headers) {
    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });
}
exports.ajaxPut = ajaxPut;
;
function ajaxPatch(url, body, headers) {
    return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });
}
exports.ajaxPatch = ajaxPatch;
;
function ajaxGetJSON(url, headers) {
    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers }).lift(new map_1.MapOperator(function (x, index) {
        return x.response;
    }, null));
}
exports.ajaxGetJSON = ajaxGetJSON;
;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var AjaxObservable = function (_super) {
    __extends(AjaxObservable, _super);
    function AjaxObservable(urlOrRequest) {
        _super.call(this);
        var request = {
            async: true,
            createXHR: function createXHR() {
                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();
            },
            crossDomain: false,
            withCredentials: false,
            headers: {},
            method: 'GET',
            responseType: 'json',
            timeout: 0
        };
        if (typeof urlOrRequest === 'string') {
            request.url = urlOrRequest;
        } else {
            for (var prop in urlOrRequest) {
                if (urlOrRequest.hasOwnProperty(prop)) {
                    request[prop] = urlOrRequest[prop];
                }
            }
        }
        this.request = request;
    }
    AjaxObservable.prototype._subscribe = function (subscriber) {
        return new AjaxSubscriber(subscriber, this.request);
    };
    /**
     * Creates an observable for an Ajax request with either a request object with
     * url, headers, etc or a string for a URL.
     *
     * @example
     * source = Rx.Observable.ajax('/products');
     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });
     *
     * @param {string|Object} request Can be one of the following:
     *   A string of the URL to make the Ajax call.
     *   An object with the following properties
     *   - url: URL of the request
     *   - body: The body of the request
     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
     *   - async: Whether the request is async
     *   - headers: Optional headers
     *   - crossDomain: true if a cross domain request, else false
     *   - createXHR: a function to override if you need to use an alternate
     *   XMLHttpRequest implementation.
     *   - resultSelector: a function to use to alter the output value type of
     *   the Observable. Gets {@link AjaxResponse} as an argument.
     * @return {Observable} An observable sequence containing the XMLHttpRequest.
     * @static true
     * @name ajax
     * @owner Observable
    */
    AjaxObservable.create = function () {
        var create = function create(urlOrRequest) {
            return new AjaxObservable(urlOrRequest);
        };
        create.get = ajaxGet;
        create.post = ajaxPost;
        create.delete = ajaxDelete;
        create.put = ajaxPut;
        create.patch = ajaxPatch;
        create.getJSON = ajaxGetJSON;
        return create;
    }();
    return AjaxObservable;
}(Observable_1.Observable);
exports.AjaxObservable = AjaxObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AjaxSubscriber = function (_super) {
    __extends(AjaxSubscriber, _super);
    function AjaxSubscriber(destination, request) {
        _super.call(this, destination);
        this.request = request;
        this.done = false;
        var headers = request.headers = request.headers || {};
        // force CORS if requested
        if (!request.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
        }
        // ensure content type is set
        if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {
            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
        }
        // properly serialize body
        request.body = this.serializeBody(request.body, request.headers['Content-Type']);
        this.send();
    }
    AjaxSubscriber.prototype.next = function (e) {
        this.done = true;
        var _a = this,
            xhr = _a.xhr,
            request = _a.request,
            destination = _a.destination;
        var response = new AjaxResponse(e, xhr, request);
        destination.next(response);
    };
    AjaxSubscriber.prototype.send = function () {
        var _a = this,
            request = _a.request,
            _b = _a.request,
            user = _b.user,
            method = _b.method,
            url = _b.url,
            async = _b.async,
            password = _b.password,
            headers = _b.headers,
            body = _b.body;
        var createXHR = request.createXHR;
        var xhr = tryCatch_1.tryCatch(createXHR).call(request);
        if (xhr === errorObject_1.errorObject) {
            this.error(errorObject_1.errorObject.e);
        } else {
            this.xhr = xhr;
            // set up the events before open XHR
            // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
            // You need to add the event listeners before calling open() on the request.
            // Otherwise the progress events will not fire.
            this.setupEvents(xhr, request);
            // open XHR
            var result = void 0;
            if (user) {
                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);
            } else {
                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);
            }
            if (result === errorObject_1.errorObject) {
                this.error(errorObject_1.errorObject.e);
                return null;
            }
            // timeout, responseType and withCredentials can be set once the XHR is open
            xhr.timeout = request.timeout;
            xhr.responseType = request.responseType;
            if ('withCredentials' in xhr) {
                xhr.withCredentials = !!request.withCredentials;
            }
            // set headers
            this.setHeaders(xhr, headers);
            // finally send the request
            result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);
            if (result === errorObject_1.errorObject) {
                this.error(errorObject_1.errorObject.e);
                return null;
            }
        }
        return xhr;
    };
    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {
        if (!body || typeof body === 'string') {
            return body;
        } else if (root_1.root.FormData && body instanceof root_1.root.FormData) {
            return body;
        }
        if (contentType) {
            var splitIndex = contentType.indexOf(';');
            if (splitIndex !== -1) {
                contentType = contentType.substring(0, splitIndex);
            }
        }
        switch (contentType) {
            case 'application/x-www-form-urlencoded':
                return Object.keys(body).map(function (key) {
                    return encodeURI(key) + "=" + encodeURI(body[key]);
                }).join('&');
            case 'application/json':
                return JSON.stringify(body);
            default:
                return body;
        }
    };
    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {
        for (var key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
    };
    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {
        var progressSubscriber = request.progressSubscriber;
        function xhrTimeout(e) {
            var _a = xhrTimeout,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
            if (progressSubscriber) {
                progressSubscriber.error(e);
            }
            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.
        }
        ;
        xhr.ontimeout = xhrTimeout;
        xhrTimeout.request = request;
        xhrTimeout.subscriber = this;
        xhrTimeout.progressSubscriber = progressSubscriber;
        if (xhr.upload && 'withCredentials' in xhr) {
            if (progressSubscriber) {
                var _xhrProgress_;
                _xhrProgress_ = function xhrProgress_1(e) {
                    var progressSubscriber = _xhrProgress_.progressSubscriber;
                    progressSubscriber.next(e);
                };
                if (root_1.root.XDomainRequest) {
                    xhr.onprogress = _xhrProgress_;
                } else {
                    xhr.upload.onprogress = _xhrProgress_;
                }
                _xhrProgress_.progressSubscriber = progressSubscriber;
            }
            var _xhrError_;
            _xhrError_ = function xhrError_1(e) {
                var _a = _xhrError_,
                    progressSubscriber = _a.progressSubscriber,
                    subscriber = _a.subscriber,
                    request = _a.request;
                if (progressSubscriber) {
                    progressSubscriber.error(e);
                }
                subscriber.error(new AjaxError('ajax error', this, request));
            };
            xhr.onerror = _xhrError_;
            _xhrError_.request = request;
            _xhrError_.subscriber = this;
            _xhrError_.progressSubscriber = progressSubscriber;
        }
        function xhrReadyStateChange(e) {
            var _a = xhrReadyStateChange,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
            if (this.readyState === 4) {
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                var status_1 = this.status === 1223 ? 204 : this.status;
                var response = this.responseType === 'text' ? this.response || this.responseText : this.response;
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status_1 === 0) {
                    status_1 = response ? 200 : 0;
                }
                if (200 <= status_1 && status_1 < 300) {
                    if (progressSubscriber) {
                        progressSubscriber.complete();
                    }
                    subscriber.next(e);
                    subscriber.complete();
                } else {
                    if (progressSubscriber) {
                        progressSubscriber.error(e);
                    }
                    subscriber.error(new AjaxError('ajax error ' + status_1, this, request));
                }
            }
        }
        ;
        xhr.onreadystatechange = xhrReadyStateChange;
        xhrReadyStateChange.subscriber = this;
        xhrReadyStateChange.progressSubscriber = progressSubscriber;
        xhrReadyStateChange.request = request;
    };
    AjaxSubscriber.prototype.unsubscribe = function () {
        var _a = this,
            done = _a.done,
            xhr = _a.xhr;
        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {
            xhr.abort();
        }
        _super.prototype.unsubscribe.call(this);
    };
    return AjaxSubscriber;
}(Subscriber_1.Subscriber);
exports.AjaxSubscriber = AjaxSubscriber;
/**
 * A normalized AJAX response.
 *
 * @see {@link ajax}
 *
 * @class AjaxResponse
 */
var AjaxResponse = function () {
    function AjaxResponse(originalEvent, xhr, request) {
        this.originalEvent = originalEvent;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
        this.responseType = xhr.responseType || request.responseType;
        switch (this.responseType) {
            case 'json':
                if ('response' in xhr) {
                    //IE does not support json as responseType, parse it internally
                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
                } else {
                    this.response = JSON.parse(xhr.responseText || 'null');
                }
                break;
            case 'xml':
                this.response = xhr.responseXML;
                break;
            case 'text':
            default:
                this.response = 'response' in xhr ? xhr.response : xhr.responseText;
                break;
        }
    }
    return AjaxResponse;
}();
exports.AjaxResponse = AjaxResponse;
/**
 * A normalized AJAX error.
 *
 * @see {@link ajax}
 *
 * @class AjaxError
 */
var AjaxError = function (_super) {
    __extends(AjaxError, _super);
    function AjaxError(message, xhr, request) {
        _super.call(this, message);
        this.message = message;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
    }
    return AjaxError;
}(Error);
exports.AjaxError = AjaxError;
/**
 * @see {@link ajax}
 *
 * @class AjaxTimeoutError
 */
var AjaxTimeoutError = function (_super) {
    __extends(AjaxTimeoutError, _super);
    function AjaxTimeoutError(xhr, request) {
        _super.call(this, 'ajax timeout', xhr, request);
    }
    return AjaxTimeoutError;
}(AjaxError);
exports.AjaxTimeoutError = AjaxTimeoutError;


},{"../../Observable":144,"../../Subscriber":150,"../../operator/map":197,"../../util/errorObject":223,"../../util/root":231,"../../util/tryCatch":234}],184:[function(require,module,exports){
"use strict";

var AjaxObservable_1 = require('./AjaxObservable');
exports.ajax = AjaxObservable_1.AjaxObservable.create;


},{"./AjaxObservable":183}],185:[function(require,module,exports){
"use strict";

var EmptyObservable_1 = require('./EmptyObservable');
exports.empty = EmptyObservable_1.EmptyObservable.create;


},{"./EmptyObservable":178}],186:[function(require,module,exports){
arguments[4][114][0].apply(exports,arguments)
},{"./FromEventObservable":180,"dup":114}],187:[function(require,module,exports){
"use strict";

var merge_1 = require('../operator/merge');
exports.merge = merge_1.mergeStatic;


},{"../operator/merge":198}],188:[function(require,module,exports){
"use strict";

var ArrayObservable_1 = require('./ArrayObservable');
exports.of = ArrayObservable_1.ArrayObservable.of;


},{"./ArrayObservable":175}],189:[function(require,module,exports){
"use strict";

var ErrorObservable_1 = require('./ErrorObservable');
exports._throw = ErrorObservable_1.ErrorObservable.create;


},{"./ErrorObservable":179}],190:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @name catch
 * @owner Observable
 */
function _catch(selector) {
    var operator = new CatchOperator(selector);
    var caught = this.lift(operator);
    return operator.caught = caught;
}
exports._catch = _catch;
var CatchOperator = function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            } catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":146,"../util/subscribeToResult":232}],191:[function(require,module,exports){
"use strict";

var Observable_1 = require('../Observable');
var isScheduler_1 = require('../util/isScheduler');
var ArrayObservable_1 = require('../observable/ArrayObservable');
var mergeAll_1 = require('./mergeAll');
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));
}
exports.concat = concat;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from given
 * Observable and then moves on to the next.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * `concat` joins multiple Observables together, by subscribing to them one at a time and
 * merging their results into the output Observable. You can pass either an array of
 * Observables, or put them directly as arguments. Passing an empty array will result
 * in Observable that completes immediately.
 *
 * `concat` will subscribe to first input Observable and emit all its values, without
 * changing or affecting them in any way. When that Observable completes, it will
 * subscribe to then next Observable passed and, again, emit its values. This will be
 * repeated, until the operator runs out of Observables. When last input Observable completes,
 * `concat` will complete as well. At any given moment only one Observable passed to operator
 * emits values. If you would like to emit values from passed Observables concurrently, check out
 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
 *
 * Note that if some input Observable never completes, `concat` will also never complete
 * and Observables following the one that did not complete will never be subscribed. On the other
 * hand, if some Observable simply completes immediately after it is subscribed, it will be
 * invisible for `concat`, which will just move on to the next Observable.
 *
 * If any Observable in chain errors, instead of passing control to the next Observable,
 * `concat` will error immediately as well. Observables that would be subscribed after
 * the one that emitted error, never will.
 *
 * If you pass to `concat` the same Observable many times, its stream of values
 * will be "replayed" on every subscription, which means you can repeat given Observable
 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
 * you can always use {@link repeat}.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 *
 * @example <caption>Concatenate an array of 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 *
 * @example <caption>Concatenate the same Observable to repeat it</caption>
 * const timer = Rx.Observable.interval(1000).take(2);
 *
 * Rx.Observable.concat(timer, timer) // concating the same Observable!
 * .subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('...and it is done!')
 * );
 *
 * // Logs:
 * // 0 after 1s
 * // 1 after 2s
 * // 0 after 3s
 * // 1 after 4s
 * // "...and it is done!" also after 4s
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} input1 An input Observable to concatenate with others.
 * @param {ObservableInput} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */
function concatStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var scheduler = null;
    var args = observables;
    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
        scheduler = args.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
}
exports.concatStatic = concatStatic;


},{"../Observable":144,"../observable/ArrayObservable":175,"../util/isScheduler":230,"./mergeAll":199}],192:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = require('../scheduler/async');
var isDate_1 = require('../util/isDate');
var Subscriber_1 = require('../Subscriber');
var Notification_1 = require('../Notification');
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * <img src="./img/delay.png" width="100%">
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * @example <caption>Delay each click by one second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @example <caption>Delay all clicks until a future date happens</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var date = new Date('March 15, 2050 12:00:00'); // in the future
 * var delayedClicks = clicks.delay(date); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {Scheduler} [scheduler=async] The IScheduler to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */
function delay(delay, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);
    return this.lift(new DelayOperator(delayFor, scheduler));
}
exports.delay = delay;
var DelayOperator = function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        _super.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        } else {
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber);
var DelayMessage = function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}();


},{"../Notification":143,"../Subscriber":150,"../scheduler/async":215,"../util/isDate":226}],193:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var tryCatch_1 = require('../util/tryCatch');
var errorObject_1 = require('../util/errorObject');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        } else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":150,"../util/errorObject":223,"../util/tryCatch":234}],194:[function(require,module,exports){
"use strict";

var distinctUntilChanged_1 = require('./distinctUntilChanged');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
 * using a property accessed by using the key provided to check if the two items are distinct.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>An example comparing the name of persons</caption>
 *
 *  interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'},
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilKeyChanged('name')
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @example <caption>An example comparing the first letters of the name</caption>
 *
 * interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo1'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo2'},
 *     { age: 6, name: 'Foo3'})
 *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo1' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo2' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 *
 * @param {string} key String key for object property lookup on each item.
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.
 * @method distinctUntilKeyChanged
 * @owner Observable
 */
function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged.call(this, function (x, y) {
        if (compare) {
            return compare(x[key], y[key]);
        }
        return x[key] === y[key];
    });
}
exports.distinctUntilKeyChanged = distinctUntilKeyChanged;


},{"./distinctUntilChanged":193}],195:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"../Subscriber":150,"dup":116}],196:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return this.lift(new FilterOperator(predicate, thisArg));
}
exports.filter = filter;
var FilterOperator = function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
        this.predicate = predicate;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":150}],197:[function(require,module,exports){
arguments[4][117][0].apply(exports,arguments)
},{"../Subscriber":150,"dup":117}],198:[function(require,module,exports){
"use strict";

var Observable_1 = require('../Observable');
var ArrayObservable_1 = require('../observable/ArrayObservable');
var mergeAll_1 = require('./mergeAll');
var isScheduler_1 = require('../util/isScheduler');
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {ObservableInput} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} An Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
}
exports.merge = merge;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (as arguments), and simply
 * forwards (without doing any transformation) all the values from all the input
 * Observables to the output Observable. The output Observable only completes
 * once all input Observables have completed. Any error delivered by an input
 * Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // timer will emit ascending values, one every second(1000ms) to console
 * // clicks logs MouseEvents to console everytime the "document" is clicked
 * // Since the two streams are merged you see these happening
 * // as they occur.
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - First timer1 and timer2 will run concurrently
 * // - timer1 will emit a value every 1000ms for 10 iterations
 * // - timer2 will emit a value every 2000ms for 6 iterations
 * // - after timer1 hits it's max iteration, timer2 will
 * //   continue, and timer3 will start to run concurrently with timer2
 * // - when timer2 hits it's max iteration it terminates, and
 * //   timer3 will continue to emit a value every 500ms until it is complete
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {...ObservableInput} observables Input Observables to merge together.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @static true
 * @name merge
 * @owner Observable
 */
function mergeStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    } else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
}
exports.mergeStatic = mergeStatic;


},{"../Observable":144,"../observable/ArrayObservable":175,"../util/isScheduler":230,"./mergeAll":199}],199:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return this.lift(new MergeAllOperator(concurrent));
}
exports.mergeAll = mergeAll;
var MergeAllOperator = function () {
    function MergeAllOperator(concurrent) {
        this.concurrent = concurrent;
    }
    MergeAllOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
    };
    return MergeAllOperator;
}();
exports.MergeAllOperator = MergeAllOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeAllSubscriber = function (_super) {
    __extends(MergeAllSubscriber, _super);
    function MergeAllSubscriber(destination, concurrent) {
        _super.call(this, destination);
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
    }
    MergeAllSubscriber.prototype._next = function (observable) {
        if (this.active < this.concurrent) {
            this.active++;
            this.add(subscribeToResult_1.subscribeToResult(this, observable));
        } else {
            this.buffer.push(observable);
        }
    };
    MergeAllSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeAllSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeAllSubscriber = MergeAllSubscriber;


},{"../OuterSubscriber":146,"../util/subscribeToResult":232}],200:[function(require,module,exports){
"use strict";

var ConnectableObservable_1 = require('../observable/ConnectableObservable');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} An Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
function multicast(subjectOrSubjectFactory, selector) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === 'function') {
        subjectFactory = subjectOrSubjectFactory;
    } else {
        subjectFactory = function subjectFactory() {
            return subjectOrSubjectFactory;
        };
    }
    if (typeof selector === 'function') {
        return this.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);
    connectable.source = this;
    connectable.subjectFactory = subjectFactory;
    return connectable;
}
exports.multicast = multicast;
var MulticastOperator = function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}();
exports.MulticastOperator = MulticastOperator;


},{"../observable/ConnectableObservable":176}],201:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"../Notification":143,"../Subscriber":150,"dup":118}],202:[function(require,module,exports){
"use strict";

var multicast_1 = require('./multicast');
var Subject_1 = require('../Subject');
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .publish().refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */
function share() {
    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();
}
exports.share = share;
;


},{"../Subject":148,"./multicast":200}],203:[function(require,module,exports){
"use strict";

var ArrayObservable_1 = require('../observable/ArrayObservable');
var ScalarObservable_1 = require('../observable/ScalarObservable');
var EmptyObservable_1 = require('../observable/EmptyObservable');
var concat_1 = require('./concat');
var isScheduler_1 = require('../util/isScheduler');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
    } else {
        scheduler = null;
    }
    var len = array.length;
    if (len === 1) {
        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
    } else if (len > 1) {
        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
    } else {
        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
    }
}
exports.startWith = startWith;


},{"../observable/ArrayObservable":175,"../observable/EmptyObservable":178,"../observable/ScalarObservable":181,"../util/isScheduler":230,"./concat":191}],204:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Converts a higher-order Observable into a first-order Observable by
 * subscribing to only the most recently emitted of those inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * previous inner Observable once a new one appears.</span>
 *
 * <img src="./img/switch.png" width="100%">
 *
 * `switch` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable subscribes to the inner Observable and
 * begins emitting the items emitted by that. So far, it behaves
 * like {@link mergeAll}. However, when a new inner Observable is emitted,
 * `switch` unsubscribes from the earlier-emitted inner Observable and
 * subscribes to the new inner Observable and begins emitting items from it. It
 * continues to behave like this for subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * // Each click event is mapped to an Observable that ticks every second
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var switched = higherOrder.switch();
 * // The outcome is that `switched` is essentially a timer that restarts
 * // on every click. The interval Observables from older clicks do not merge
 * // with the current interval Observable.
 * switched.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switchMap}
 * @see {@link switchMapTo}
 * @see {@link zipAll}
 *
 * @return {Observable<T>} An Observable that emits the items emitted by the
 * Observable most recently emitted by the source Observable.
 * @method switch
 * @name switch
 * @owner Observable
 */
function _switch() {
    return this.lift(new SwitchOperator());
}
exports._switch = _switch;
var SwitchOperator = function () {
    function SwitchOperator() {}
    SwitchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchSubscriber(subscriber));
    };
    return SwitchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchSubscriber = function (_super) {
    __extends(SwitchSubscriber, _super);
    function SwitchSubscriber(destination) {
        _super.call(this, destination);
        this.active = 0;
        this.hasCompleted = false;
    }
    SwitchSubscriber.prototype._next = function (value) {
        this.unsubscribeInner();
        this.active++;
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, value));
    };
    SwitchSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    SwitchSubscriber.prototype.unsubscribeInner = function () {
        this.active = this.active > 0 ? this.active - 1 : 0;
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
            this.remove(innerSubscription);
        }
    };
    SwitchSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    SwitchSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchSubscriber.prototype.notifyComplete = function () {
        this.unsubscribeInner();
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return SwitchSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":146,"../util/subscribeToResult":232}],205:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return this.lift(new SwitchMapOperator(project, resultSelector));
}
exports.switchMap = switchMap;
var SwitchMapOperator = function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":146,"../util/subscribeToResult":232}],206:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');
var EmptyObservable_1 = require('../observable/EmptyObservable');
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    } else {
        return this.lift(new TakeOperator(count));
    }
}
exports.take = take;
var TakeOperator = function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":150,"../observable/EmptyObservable":178,"../util/ArgumentOutOfRangeError":219}],207:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var project;
    if (typeof args[args.length - 1] === 'function') {
        project = args.pop();
    }
    var observables = args;
    return this.lift(new WithLatestFromOperator(observables, project));
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WithLatestFromSubscriber = function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        _super.call(this, destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        var len = observables.length;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
        }
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            } else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":146,"../util/subscribeToResult":232}],208:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = require('../observable/ArrayObservable');
var isArray_1 = require('../util/isArray');
var Subscriber_1 = require('../Subscriber');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
var iterator_1 = require('../symbol/iterator');
/* tslint:enable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
function zipProto() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));
}
exports.zipProto = zipProto;
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the latest parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * @example <caption>Combine age and name from different sources</caption>
 *
 * let age$ = Observable.of<number>(27, 25, 29);
 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
 * let isDev$ = Observable.of<boolean>(true, true, false);
 *
 * Observable
 *     .zip(age$,
 *          name$,
 *          isDev$,
 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
 *     .subscribe(x => console.log(x));
 *
 * // outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 *
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */
function zipStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}
exports.zipStatic = zipStatic;
var ZipOperator = function () {
    function ZipOperator(project) {
        this.project = project;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.project));
    };
    return ZipOperator;
}();
exports.ZipOperator = ZipOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = typeof project === 'function' ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[iterator_1.$$iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.$$iterator]()));
        } else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                this.add(iterator.subscribe(iterator, i));
            } else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        } else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber);
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}();
var StaticArrayIterator = function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.$$iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator_1.$$iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        } else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        } else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":146,"../Subscriber":150,"../observable/ArrayObservable":175,"../symbol/iterator":216,"../util/isArray":224,"../util/subscribeToResult":232}],209:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"../Subscription":151,"dup":119}],210:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Immediate_1 = require('../util/Immediate');
var AsyncAction_1 = require('./AsyncAction');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsapAction = function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay is greater than 0, request as an async action.
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Push the action to the end of the scheduler queue.
        scheduler.actions.push(this);
        // If a microtask has already been scheduled, don't schedule another
        // one. If a microtask hasn't been scheduled yet, schedule one now. Return
        // the current scheduled microtask id.
        return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        // If the scheduler queue is empty, cancel the requested microtask and
        // set the scheduled flag to undefined so the next AsapAction will schedule
        // its own.
        if (scheduler.actions.length === 0) {
            Immediate_1.Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        // Return undefined so the action knows to request a new async id if it's rescheduled.
        return undefined;
    };
    return AsapAction;
}(AsyncAction_1.AsyncAction);
exports.AsapAction = AsapAction;


},{"../util/Immediate":220,"./AsyncAction":212}],211:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var AsyncScheduler_1 = require('./AsyncScheduler');
var AsapScheduler = function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        _super.apply(this, arguments);
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler_1.AsyncScheduler);
exports.AsapScheduler = AsapScheduler;


},{"./AsyncScheduler":213}],212:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"../util/root":231,"./Action":209,"dup":122}],213:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"../Scheduler":147,"dup":123}],214:[function(require,module,exports){
"use strict";

var AsapAction_1 = require('./AsapAction');
var AsapScheduler_1 = require('./AsapScheduler');
/**
 *
 * Asap Scheduler
 *
 * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
 *
 * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task
 * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
 * code to end and then it will try to execute given task as fast as possible.
 *
 * `asap` scheduler will do its best to minimize time between end of currently executing code
 * and start of scheduled task. This makes it best candidate for performing so called "deferring".
 * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
 * some (although minimal) unwanted delay.
 *
 * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
 * after currently executing code. In particular, if some task was also scheduled with `asap` before,
 * that task will execute first. That being said, if you need to schedule task asynchronously, but
 * as soon as possible, `asap` scheduler is your best bet.
 *
 * @example <caption>Compare async and asap scheduler</caption>
 *
 * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...
 * Rx.Scheduler.asap.schedule(() => console.log('asap'));
 *
 * // Logs:
 * // "asap"
 * // "async"
 * // ... but 'asap' goes first!
 *
 * @static true
 * @name asap
 * @owner Scheduler
 */
exports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);


},{"./AsapAction":210,"./AsapScheduler":211}],215:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"./AsyncAction":212,"./AsyncScheduler":213,"dup":125}],216:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function symbolIteratorPonyfill(root) {
    var _Symbol = root.Symbol;
    if (typeof _Symbol === 'function') {
        if (!_Symbol.iterator) {
            _Symbol.iterator = _Symbol('iterator polyfill');
        }
        return _Symbol.iterator;
    } else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.$$iterator = symbolIteratorPonyfill(root_1.root);


},{"../util/root":231}],217:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"../util/root":231,"dup":126}],218:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"../util/root":231,"dup":127}],219:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = function (_super) {
    __extends(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var err = _super.call(this, 'argument out of range');
        this.name = err.name = 'ArgumentOutOfRangeError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ArgumentOutOfRangeError;
}(Error);
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;


},{}],220:[function(require,module,exports){
/**
Some credit for this helper goes to http://github.com/YuzuJS/setImmediate
*/
"use strict";

var root_1 = require('./root');
var ImmediateDefinition = function () {
    function ImmediateDefinition(root) {
        this.root = root;
        if (root.setImmediate && typeof root.setImmediate === 'function') {
            this.setImmediate = root.setImmediate.bind(root);
            this.clearImmediate = root.clearImmediate.bind(root);
        } else {
            this.nextHandle = 1;
            this.tasksByHandle = {};
            this.currentlyRunningATask = false;
            // Don't get fooled by e.g. browserify environments.
            if (this.canUseProcessNextTick()) {
                // For Node.js before 0.9
                this.setImmediate = this.createProcessNextTickSetImmediate();
            } else if (this.canUsePostMessage()) {
                // For non-IE10 modern browsers
                this.setImmediate = this.createPostMessageSetImmediate();
            } else if (this.canUseMessageChannel()) {
                // For web workers, where supported
                this.setImmediate = this.createMessageChannelSetImmediate();
            } else if (this.canUseReadyStateChange()) {
                // For IE 68
                this.setImmediate = this.createReadyStateChangeSetImmediate();
            } else {
                // For older browsers
                this.setImmediate = this.createSetTimeoutSetImmediate();
            }
            var ci = function clearImmediate(handle) {
                delete clearImmediate.instance.tasksByHandle[handle];
            };
            ci.instance = this;
            this.clearImmediate = ci;
        }
    }
    ImmediateDefinition.prototype.identify = function (o) {
        return this.root.Object.prototype.toString.call(o);
    };
    ImmediateDefinition.prototype.canUseProcessNextTick = function () {
        return this.identify(this.root.process) === '[object process]';
    };
    ImmediateDefinition.prototype.canUseMessageChannel = function () {
        return Boolean(this.root.MessageChannel);
    };
    ImmediateDefinition.prototype.canUseReadyStateChange = function () {
        var document = this.root.document;
        return Boolean(document && 'onreadystatechange' in document.createElement('script'));
    };
    ImmediateDefinition.prototype.canUsePostMessage = function () {
        var root = this.root;
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `root.postMessage` means something completely different and can't be used for this purpose.
        if (root.postMessage && !root.importScripts) {
            var postMessageIsAsynchronous_1 = true;
            var oldOnMessage = root.onmessage;
            root.onmessage = function () {
                postMessageIsAsynchronous_1 = false;
            };
            root.postMessage('', '*');
            root.onmessage = oldOnMessage;
            return postMessageIsAsynchronous_1;
        }
        return false;
    };
    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    ImmediateDefinition.prototype.partiallyApplied = function (handler) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var fn = function result() {
            var _a = result,
                handler = _a.handler,
                args = _a.args;
            if (typeof handler === 'function') {
                handler.apply(undefined, args);
            } else {
                new Function('' + handler)();
            }
        };
        fn.handler = handler;
        fn.args = args;
        return fn;
    };
    ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {
        this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);
        return this.nextHandle++;
    };
    ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {
        var fn = function setImmediate() {
            var instance = setImmediate.instance;
            var handle = instance.addFromSetImmediateArguments(arguments);
            instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));
            return handle;
        };
        fn.instance = this;
        return fn;
    };
    ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
        var root = this.root;
        var messagePrefix = 'setImmediate$' + root.Math.random() + '$';
        var onGlobalMessage = function globalMessageHandler(event) {
            var instance = globalMessageHandler.instance;
            if (event.source === root && typeof event.data === 'string' && event.data.indexOf(messagePrefix) === 0) {
                instance.runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };
        onGlobalMessage.instance = this;
        root.addEventListener('message', onGlobalMessage, false);
        var fn = function setImmediate() {
            var _a = setImmediate,
                messagePrefix = _a.messagePrefix,
                instance = _a.instance;
            var handle = instance.addFromSetImmediateArguments(arguments);
            instance.root.postMessage(messagePrefix + handle, '*');
            return handle;
        };
        fn.instance = this;
        fn.messagePrefix = messagePrefix;
        return fn;
    };
    ImmediateDefinition.prototype.runIfPresent = function (handle) {
        // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'
        // So if we're currently running a task, we'll need to delay this invocation.
        if (this.currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // 'too much recursion' error.
            this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);
        } else {
            var task = this.tasksByHandle[handle];
            if (task) {
                this.currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    this.clearImmediate(handle);
                    this.currentlyRunningATask = false;
                }
            }
        }
    };
    ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {
        var _this = this;
        var channel = new this.root.MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            _this.runIfPresent(handle);
        };
        var fn = function setImmediate() {
            var _a = setImmediate,
                channel = _a.channel,
                instance = _a.instance;
            var handle = instance.addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
        fn.channel = channel;
        fn.instance = this;
        return fn;
    };
    ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {
        var fn = function setImmediate() {
            var instance = setImmediate.instance;
            var root = instance.root;
            var doc = root.document;
            var html = doc.documentElement;
            var handle = instance.addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement('script');
            script.onreadystatechange = function () {
                instance.runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
        fn.instance = this;
        return fn;
    };
    ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {
        var fn = function setImmediate() {
            var instance = setImmediate.instance;
            var handle = instance.addFromSetImmediateArguments(arguments);
            instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);
            return handle;
        };
        fn.instance = this;
        return fn;
    };
    return ImmediateDefinition;
}();
exports.ImmediateDefinition = ImmediateDefinition;
exports.Immediate = new ImmediateDefinition(root_1.root);


},{"./root":231}],221:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error);
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;


},{}],222:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129}],223:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"dup":130}],224:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"dup":131}],225:[function(require,module,exports){
"use strict";

exports.isArrayLike = function (x) {
  return x && typeof x.length === 'number';
};


},{}],226:[function(require,module,exports){
"use strict";

function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;


},{}],227:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"dup":132}],228:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"dup":133}],229:[function(require,module,exports){
"use strict";

function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;


},{}],230:[function(require,module,exports){
"use strict";

function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;


},{}],231:[function(require,module,exports){
(function (global){
"use strict";
/**
 * window: browser in DOM main thread
 * self: browser in WebWorker
 * global: Node.js/other
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.root = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object' && window.window === window && window || (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self.self === self && self || (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global.global === global && global;
if (!exports.root) {
    throw new Error('RxJS could not find any global context (window, self, global)');
}


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],232:[function(require,module,exports){
"use strict";

var root_1 = require('./root');
var isArrayLike_1 = require('./isArrayLike');
var isPromise_1 = require('./isPromise');
var isObject_1 = require('./isObject');
var Observable_1 = require('../Observable');
var iterator_1 = require('../symbol/iterator');
var InnerSubscriber_1 = require('../InnerSubscriber');
var observable_1 = require('../symbol/observable');
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        } else {
            return result.subscribe(destination);
        }
    } else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    } else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) {
            return destination.error(err);
        }).then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () {
                throw err;
            });
        });
        return destination;
    } else if (result && typeof result[iterator_1.$$iterator] === 'function') {
        var iterator = result[iterator_1.$$iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    } else if (result && typeof result[observable_1.$$observable] === 'function') {
        var obs = result[observable_1.$$observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        } else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    } else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;


},{"../InnerSubscriber":142,"../Observable":144,"../symbol/iterator":216,"../symbol/observable":217,"./isArrayLike":225,"./isObject":228,"./isPromise":229,"./root":231}],233:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"../Observer":145,"../Subscriber":150,"../symbol/rxSubscriber":218,"dup":135}],234:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"./errorObject":223,"dup":136}],235:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isExternal = isExternal;
exports.stripHash = stripHash;
exports.isHash = isHash;
exports.matches = matches;
exports.querySelectorInv = querySelectorInv;
exports.shouldLoadAnchor = shouldLoadAnchor;
exports.getScrollHeight = getScrollHeight;
exports.getScrollTop = getScrollTop;
/**
 * Checks to see if the url is external
 *
 * @param   {string}    url - url being evaluated
 * @see     http://stackoverflow.com/questions/6238351/fastest-way-to-detect-external-urls
 */
function isExternal(url) {
  var match = url.match(/^([^:\/?#]+:)?(?:\/\/([^\/?#]*))?([^?#]+)?(\?[^#]*)?(#.*)?/); // eslint-disable-line no-useless-escape

  if (typeof match[1] === 'string' && match[1].length > 0 && match[1].toLowerCase() !== window.location.protocol) {
    return true;
  }

  var port = { http: 80, https: 443 }[window.location.protocol];

  if (typeof match[2] === 'string' && match[2].length > 0 && match[2].replace(new RegExp(':(' + port + ')?$'), '') !== window.location.host) {
    return true;
  }

  return false;
}

/**
 * Strips the hash from a url and returns the new href
 *
 * @param   {string}    href - url being evaluated
 */
function stripHash(href) {
  return href.replace(/#.*/, '');
}

/**
 * Checks to see if the url is an internal hash
 *
 * @param   {string}    href - url being evaluated
 * @param   {string}    prev - previous url (optional)
 */
function isHash(href, prev) {
  var p = prev || window.location.href;

  var hasHash = href.indexOf('#') > -1;
  var samePath = stripHash(href) === stripHash(p);

  return hasHash && samePath;
}

function matches(el, selector) {
  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
  // if (!matches.memo) {
  //   matches.memo =
  //     el.matches ||
  //     el.matchesSelector ||
  //     el.msMatchesSelector ||
  //     el.mozMatchesSelector ||
  //     el.webkitMatchesSelector ||
  //     el.oMatchesSelector;
  // }
  // return matches.memo.call(el, selector);
}

function querySelectorInv(el, selector) {
  var curr = el;
  while (curr !== document && curr !== document.documentElement) {
    if (matches(curr, selector)) return curr;
    curr = curr.parentNode;
  }
  return null;
}

/**
 * Checks to see if we should be loading this URL
 *
 * @param   {string}    url - url being evaluated
 * @param   {string}    blacklist - jquery selector
 */
function shouldLoadAnchor(anchor, blacklist, hrefRegex) {
  var href = anchor.href;
  // URL will only be loaded if it's not an external link, hash, or
  // blacklisted
  return !isExternal(href) && !isHash(href) && !matches(anchor, blacklist) && anchor.target === '' && (hrefRegex === null || href.search(hrefRegex) !== -1);
}

function getScrollHeight() {
  var h = document.documentElement;
  var b = document.body;
  var sh = 'scrollHeight';
  return h[sh] || b[sh];
}

function getScrollTop() {
  return window.pageYOffset;
}

},{}],236:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;_e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }return _arr;
  }return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _Observable = require('rxjs/Observable');

var _Subject = require('rxjs/Subject');

var _asap = require('rxjs/scheduler/asap');

require('rxjs/add/observable/defer');

require('rxjs/add/observable/empty');

require('rxjs/add/observable/fromEvent');

require('rxjs/add/observable/merge');

require('rxjs/add/observable/of');

require('rxjs/add/observable/throw');

require('rxjs/add/observable/dom/ajax');

require('rxjs/add/operator/catch');

require('rxjs/add/operator/delay');

require('rxjs/add/operator/distinctUntilKeyChanged');

require('rxjs/add/operator/do');

require('rxjs/add/operator/filter');

require('rxjs/add/operator/map');

require('rxjs/add/operator/merge');

require('rxjs/add/operator/mergeAll');

require('rxjs/add/operator/observeOn');

require('rxjs/add/operator/share');

require('rxjs/add/operator/startWith');

require('rxjs/add/operator/switch');

require('rxjs/add/operator/switchMap');

require('rxjs/add/operator/take');

require('rxjs/add/operator/withLatestFrom');

require('rxjs/add/operator/zip');

var _componentCore2 = require('y-component/src/component-core');

var _componentCore3 = _interopRequireDefault(_componentCore2);

var _common = require('../common');

var _kind = require('./kind');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /*
   * Adapted from Miguel ngel Prez's smoothState.js
   * https://github.com/miguel-perez/smoothState.js
   *
   * Copyright (c) 2016 Florian Klampfer
   * Licensed under MIT
   */
/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

// const JS_FEATURES = [
//   'fn/array/for-each',
//   'fn/function/bind',
//   'fn/number/constructor',
//   'fn/object/assign',
//   'fn/object/define-property',
//   'fn/object/keys',
// ];
//
// const MODERNIZR_TESTS = [
//   'customevent',
//   'documentfragment',
//   'eventlistener',
//   'history',
//   'requestanimationframe',
//   'queryselector',
// ];

var def = Object.defineProperty.bind(Object);

function fragmentFromString(strHTML) {
  return document.createRange().createContextualFragment(strHTML);
}

// ~ mixin pushStateCore with componentCore { ...

exports.default = function (C) {
  return function (_componentCore) {
    _inherits(_class, _componentCore);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'getComponentName',

      // @override
      value: function getComponentName() {
        return 'y-push-state';
      }

      // @override

    }, {
      key: 'defaults',
      value: function defaults() {
        return {
          replaceIds: [],
          linkSelector: 'a[href]',
          scrollRestoration: false,
          hrefRegex: null,
          blacklist: null,
          duration: 0
        };
      }

      // @override

    }, {
      key: 'sideEffects',
      value: function sideEffects() {
        return {};
      }
    }, {
      key: 'startHistory',
      value: function startHistory() {
        this.checkPreCondition();
        this.setupScrollRestoration();
        this.resetScrollPostion();
        this.cacheTitleElement();
        this.setupObservables();
        return this;
      }
    }, {
      key: 'checkPreCondition',
      value: function checkPreCondition() {
        if (this.replaceIds.length === 0) {
          var id = this.el.id;
          if (id) {
            console.warn('No replace ids provided. Will replace entire content of #' + id); // eslint-disable-line no-console
          } else {
            throw Error('No replace ids provided nor does this component have and id'); // eslint-disable-line no-console
          }
        }
      }
    }, {
      key: 'setupScrollRestoration',
      value: function setupScrollRestoration() {
        var _this2 = this;

        if ('scrollRestoration' in history) {
          if (this.scrollRestoration) history.scrollRestoration = 'manual';else history.scrollRestoration = 'auto';
        }

        if (this.scrollRestoration) {
          this.resetScrollPostion();
          window.addEventListener('beforeunload', function () {
            _this2.updateHistoryState();
          });
        }
      }
    }, {
      key: 'cacheTitleElement',
      value: function cacheTitleElement() {
        def(this, 'titleElement', { value: document.querySelector('title') || {} });
      }
    }, {
      key: 'bindPushEvents',
      value: function bindPushEvents(link$) {
        var _this3 = this;

        return this.fromEvents(link$, 'click').map(function (event) {
          return new _kind.Push(event);
        }).filter(function (kind) {
          return _this3.isPageChangeEvent(kind);
        }).do(function (_ref) {
          var event = _ref.event;

          _this3.updateHistoryState();
          event.preventDefault();
        });
      }
    }, {
      key: 'bindHintEvents',
      value: function bindHintEvents(link$) {
        var _this4 = this;

        return _Observable.Observable.merge(this.fromEvents(link$, 'mouseenter'), this.fromEvents(link$, 'touchstart')).merge(this.fromEvents(link$, 'focus')).map(function (event) {
          return new _kind.Hint(event);
        }).filter(function (kind) {
          return _this4.isPageChangeAnchor(kind);
        });
      }
    }, {
      key: 'bindPopstateEvent',
      value: function bindPopstateEvent() {
        return _Observable.Observable.fromEvent(window, 'popstate').map(function (event) {
          return new _kind.Pop(event);
        }).filter(function () {
          return window.history.state != null;
        });
      }
    }, {
      key: 'linkObservable',
      value: function linkObservable() {
        return _Observable.Observable.of(this.el.querySelectorAll(this.linkSelector));
      }
    }, {
      key: 'fromEvents',
      value: function fromEvents(link$, event) {
        return link$.map(function (link) {
          return _Observable.Observable.fromEvent(link, event);
        }).mergeAll();
      }
    }, {
      key: 'fetchPage',
      value: function fetchPage(kind) {
        var _this5 = this;

        var requestData = this.hrefToRequestData(kind);
        return _Observable.Observable.ajax(requestData).map(function (_ref2) {
          var response = _ref2.response;
          return Object.assign(kind, { response: response });
        }).catch(function (error) {
          return _this5.recoverWhenResponse(kind, error);
        });
      }
    }, {
      key: 'hrefToRequestData',
      value: function hrefToRequestData(_ref3) {
        var href = _ref3.href;

        return {
          method: 'GET',
          url: href,
          responseType: 'text'
        };
      }
    }, {
      key: 'recoverWhenResponse',
      value: function recoverWhenResponse(kind, error) {
        var status = error.status,
            xhr = error.xhr;

        if (status && status > 400 && xhr) {
          // Recover with error page returned from server.
          // Assumes error page contains the same ids as other pages.
          return _Observable.Observable.of(Object.assign(kind, { response: xhr.response }));
        }

        // TODO: Don't throw here?
        return _Observable.Observable.throw(error);
      }
    }, {
      key: 'setupObservables',
      value: function setupObservables() {
        var _this6 = this;

        // See `renewEventListeners`
        // TODO: Possible without subjects?
        this.push$$ = new _Subject.Subject();
        this.hint$$ = new _Subject.Subject();

        var push$ = this.push$$.switch();
        var pop$ = this.bindPopstateEvent();

        // Definitive page change (i.e. either push or pop event)
        this.page$ = _Observable.Observable.merge(push$, pop$);

        // Wait at least as long as it takes for the animation to finish before changing the DOM
        // (default = 0ms)
        this.animation$ = this.page$.delay(this.duration);

        // We don't want to prefetch (i.e. use bandwidth) for a _probabilistic_ page load,
        // while a _definitive_ page load is going on => `pauser$` stream.
        // Needs to be deferred b/c of "cyclical" dependency.
        var pauser$ = _Observable.Observable.defer(function () {
          return _Observable.Observable.merge(
          // A page change event means we want to pause prefetching
          _this6.page$.map(function () {
            return true;
          }),
          // A render complete event means we want to resume prefetching
          _this6.render$.map(function () {
            return false;
          }))
          // Start with prefetching
          .startWith(false);
        });

        // The stream of hint (prefetch) events, possibly paused.
        // Dream syntax (not supported, yet): `this.hint$$.switch().pauseable(pauser$)`
        this.hint$ = this.hint$$.switch().withLatestFrom(pauser$).switchMap(function (_ref4) {
          var _ref5 = _slicedToArray(_ref4, 2),
              hint = _ref5[0],
              paused = _ref5[1];

          return paused ? _Observable.Observable.empty() : _Observable.Observable.of(hint);
        });

        // The stream of (pre-)fetch events.
        // Includes definitive page change events do deal with unexpected page changes.
        var prefetch$ = _Observable.Observable.merge(this.hint$, this.page$).distinctUntilKeyChanged('href') // Don't abort a request if the user "jiggles" over a link
        .switchMap(function (kind) {
          return _this6.fetchPage(kind);
        }).startWith({}) // Start with some value so `withLatestFrom` below doesn't "block"
        .share();

        this.render$ = this.page$.do(this.setWillChange.bind(this)).do(this.onBefore.bind(this)).withLatestFrom(prefetch$).switchMap(function (_ref6) {
          var _ref7 = _slicedToArray(_ref6, 2),
              kind = _ref7[0],
              prefetch = _ref7[1];

          return kind.href === prefetch.href ?
          // Prefetch already complete, use result
          _Observable.Observable.of([kind, prefetch]) :
          // Prefetch in progress, use next result (this is why `prefetch$` had to be `share`d)
          prefetch$.take(1).map(function (fetch) {
            return [kind, fetch];
          });
        })
        // ensure `duration` ms have passed since the event
        .zip(this.animation$, function (x) {
          return x;
        }).do(function (_ref8) {
          var _ref9 = _slicedToArray(_ref8, 2),
              kind = _ref9[0],
              prefetch = _ref9[1];

          return _this6.updateDOM(kind, prefetch);
        }).do(this.onAfter.bind(this))
        // Push renewing event listeners out after layout/painting is complete
        .observeOn(_asap.asap).do(this.unsetWillChange.bind(this)).do(this.renewEventListeners.bind(this))
        // `share`ing the stream between the subscription below and `pauser$`.
        .share();

        // Start pulling values
        this.render$.subscribe(function () {});

        // Push streams into `push$$` and `hint$$`
        this.renewEventListeners();
      }
    }, {
      key: 'renewEventListeners',
      value: function renewEventListeners() {
        var link$ = this.linkObservable();
        this.push$$.next(this.bindPushEvents(link$));
        this.hint$$.next(this.bindHintEvents(link$));
      }
    }, {
      key: 'updateDOM',
      value: function updateDOM(kind, _ref10) {
        var response = _ref10.response;
        var href = kind.href;

        var _responseToHTML = this.responseToHTML(response),
            title = _responseToHTML.title,
            content = _responseToHTML.content;

        if (kind instanceof _kind.Push) {
          window.history.pushState({ id: this.componentName }, title, href);
        }

        this.titleElement.textContent = title;
        this.resetScrollPostion();
        this.replaceContent(content);
      }
    }, {
      key: 'responseToHTML',
      value: function responseToHTML(response) {
        var documentFragment = fragmentFromString(response);
        var title = this.getTitleFromDocumentFragment(documentFragment);
        var content = this.getContentFromDocumentFragment(documentFragment);
        return { title: title, content: content };
      }
    }, {
      key: 'onBefore',
      value: function onBefore() {
        this.fireEvent('before');
      }
    }, {
      key: 'onAfter',
      value: function onAfter() {
        this.fireEvent('after');
      }

      // onError() {
      //   this.el.style.willChange = '';
      //   document.body.style.willChange = '';
      //   this.fireEvent('error');
      // }

    }, {
      key: 'setWillChange',
      value: function setWillChange() {
        // this.el.style.willChange = 'content';
        document.body.style.willChange = 'scroll-position';
      }
    }, {
      key: 'unsetWillChange',
      value: function unsetWillChange() {
        // this.el.style.willChange = '';
        document.body.style.willChange = '';
      }
    }, {
      key: 'isPageChangeEvent',
      value: function isPageChangeEvent(kind) {
        var event = kind.event;

        return !event.metaKey && !event.ctrlKey && this.isPageChangeAnchor(kind);
      }
    }, {
      key: 'isPageChangeAnchor',
      value: function isPageChangeAnchor(_ref11) {
        var anchor = _ref11.event.currentTarget;

        return anchor != null && (0, _common.shouldLoadAnchor)(anchor, this.blacklist, this.hrefRegex);
      }
    }, {
      key: 'getTitleFromDocumentFragment',
      value: function getTitleFromDocumentFragment(documentFragment) {
        return (documentFragment.querySelector('title') || {}).textContent;
      }
    }, {
      key: 'getContentFromDocumentFragment',
      value: function getContentFromDocumentFragment(documentFragment) {
        if (this.replaceIds.length > 0) {
          return this.replaceIds.map(function (id) {
            return documentFragment.querySelector('#' + id);
          });
        }

        return documentFragment.getElementById(this.el.id);
      }
    }, {
      key: 'replaceContent',
      value: function replaceContent(content) {
        if (this.replaceIds.length > 0) {
          this.replaceContentByIds(content);
        } else {
          this.replaceContentWholesale(content);
        }
      }

      // TODO: Rename

    }, {
      key: 'checkCondition',
      value: function checkCondition(oldElements, content) {
        // TODO: Just replace existing ids, remove missing ides
        // TODO: Remove in production builds
        if (content.length !== oldElements.length) {
          throw Error("New document doesn't contain the same number of ids");
        }
      }
    }, {
      key: 'replaceContentByIds',
      value: function replaceContentByIds(content) {
        var oldElements = this.replaceIds.map(function (id) {
          return document.getElementById(id);
        });

        this.checkCondition(oldElements, content);

        Array.prototype.forEach.call(oldElements, function (oldElement) {
          oldElement.parentNode.replaceChild(content.shift(), oldElement);
        });
      }
    }, {
      key: 'replaceContentWholesale',
      value: function replaceContentWholesale(content) {
        this.el.innerHTML = content.innerHTML;
      }
    }, {
      key: 'saveScrollPosition',
      value: function saveScrollPosition(state) {
        if (this.scrollRestoration) {
          return Object.assign(state, {
            scrollTop: (0, _common.getScrollTop)(),
            scrollHeight: (0, _common.getScrollHeight)()
          });
        }
        return state;
      }
    }, {
      key: 'updateHistoryState',
      value: function updateHistoryState() {
        var state = history.state || { id: this.componentName };
        var stateWithScrollPosition = this.saveScrollPosition(state);
        history.replaceState(stateWithScrollPosition, document.title, window.location.href);
      }
    }, {
      key: 'resetScrollPostion',
      value: function resetScrollPostion() {
        if (this.scrollRestoration) {
          var state = history.state || {};
          document.body.style.minHeight = (state.scrollHeight || 0) + 'px';
          window.scrollTo(window.pageXOffset, state.scrollTop || 0);
        }
      }
    }]);

    return _class;
  }((0, _componentCore3.default)(C));
};

},{"../common":235,"./kind":237,"rxjs/Observable":144,"rxjs/Subject":148,"rxjs/add/observable/defer":152,"rxjs/add/observable/dom/ajax":153,"rxjs/add/observable/empty":154,"rxjs/add/observable/fromEvent":155,"rxjs/add/observable/merge":156,"rxjs/add/observable/of":157,"rxjs/add/observable/throw":158,"rxjs/add/operator/catch":159,"rxjs/add/operator/delay":160,"rxjs/add/operator/distinctUntilKeyChanged":161,"rxjs/add/operator/do":162,"rxjs/add/operator/filter":163,"rxjs/add/operator/map":164,"rxjs/add/operator/merge":165,"rxjs/add/operator/mergeAll":166,"rxjs/add/operator/observeOn":167,"rxjs/add/operator/share":168,"rxjs/add/operator/startWith":169,"rxjs/add/operator/switch":170,"rxjs/add/operator/switchMap":171,"rxjs/add/operator/take":172,"rxjs/add/operator/withLatestFrom":173,"rxjs/add/operator/zip":174,"rxjs/scheduler/asap":214,"y-component/src/component-core":138}],237:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Kind = exports.Kind = function Kind(event) {
  _classCallCheck(this, Kind);

  this.event = event;
};

var Push = exports.Push = function (_Kind) {
  _inherits(Push, _Kind);

  function Push(event) {
    _classCallCheck(this, Push);

    var _this = _possibleConstructorReturn(this, (Push.__proto__ || Object.getPrototypeOf(Push)).call(this, event));

    _this.href = event.currentTarget.href;
    return _this;
  }

  return Push;
}(Kind);

var Hint = exports.Hint = function (_Kind2) {
  _inherits(Hint, _Kind2);

  function Hint(event) {
    _classCallCheck(this, Hint);

    var _this2 = _possibleConstructorReturn(this, (Hint.__proto__ || Object.getPrototypeOf(Hint)).call(this, event));

    _this2.href = event.currentTarget.href;
    return _this2;
  }

  return Hint;
}(Kind);

var Pop = exports.Pop = function (_Kind3) {
  _inherits(Pop, _Kind3);

  function Pop(event) {
    _classCallCheck(this, Pop);

    var _this3 = _possibleConstructorReturn(this, (Pop.__proto__ || Object.getPrototypeOf(Pop)).call(this, event));

    _this3.href = window.location.href;
    return _this3;
  }

  return Pop;
}(Kind);

},{}],238:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /*
   * Copyright (c) 2016 Florian Klampfer
   * Licensed under MIT
   */

var PushState = function (_pushStateCore) {
  _inherits(PushState, _pushStateCore);

  function PushState(el, props) {
    _classCallCheck(this, PushState);

    var _this = _possibleConstructorReturn(this, (PushState.__proto__ || Object.getPrototypeOf(PushState)).call(this));

    _this.setupComponent(el, props);
    return _this;
  }

  // @override


  _createClass(PushState, [{
    key: 'setupDOM',
    value: function setupDOM(el) {
      if (!el) throw Error('No element provided');
      return el;
    }
  }]);

  return PushState;
}((0, _core2.default)());

exports.default = PushState;

},{"../core":236}]},{},[4])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJfanMvbGliL21vZGVybml6ci5qcyIsIl9qcy9zcmMvY29tbW9uLmpzIiwiX2pzL3NyYy9kcmF3ZXIuanMiLCJfanMvc3JjL2luZGV4LmpzIiwiX2pzL3NyYy9rYXRleC5qcyIsIl9qcy9zcmMvcHVzaC1zdGF0ZS5qcyIsIl9qcy9zcmMvc3R5bGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9hcnJheS9mb3ItZWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL2FycmF5L3JlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL2Z1bmN0aW9uL2JpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9udW1iZXIvY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9vYmplY3QvYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL29iamVjdC9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYS1mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FuLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktbWV0aG9kcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1zcGVjaWVzLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2JpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fY3R4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVmaW5lZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZG9tLWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2VudW0tYnVnLWtleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2dsb2JhbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hhcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2hpZGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faWU4LWRvbS1kZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW52b2tlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2lzLWFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1jcmVhdGUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wbi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1waWUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qtc2FwLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcHJvcGVydHktZGVzYy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3JlZGVmaW5lLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2V0LXByb3RvLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLWtleS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3NoYXJlZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmljdC1tZXRob2QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctdHJpbS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy13cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWlvYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5mb3ItZWFjaC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LnJlZHVjZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmZ1bmN0aW9uLmJpbmQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3IuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2ZnLWxvYWRjc3Mvc3JjL2xvYWRDU1MuanMiLCJub2RlX21vZHVsZXMva2F0ZXgva2F0ZXguanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL0xleGVyLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9NYWNyb0V4cGFuZGVyLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9PcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9QYXJzZUVycm9yLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9QYXJzZXIuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL1NldHRpbmdzLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9TdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvYnVpbGRDb21tb24uanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2J1aWxkSFRNTC5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvYnVpbGRNYXRoTUwuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2J1aWxkVHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvZGVsaW1pdGVyLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9kb21UcmVlLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9lbnZpcm9ubWVudHMuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2ZvbnRNZXRyaWNzLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9mb250TWV0cmljc0RhdGEuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2Z1bmN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvbWF0aE1MVHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvcGFyc2VEYXRhLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9wYXJzZVRyZWUuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL3N5bWJvbHMuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL3VuaWNvZGVSZWdleGVzLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9tYXRjaC1hdC9saWIvbWF0Y2hBdC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL05vdGlmaWNhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL09ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvcnhqcy9PYnNlcnZlci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL1NjaGVkdWxlci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL1N1YnNjcmliZXIuanMiLCJub2RlX21vZHVsZXMvcnhqcy9TdWJzY3JpcHRpb24uanMiLCJub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS9mcm9tRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvZGVib3VuY2VUaW1lLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2RvLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9vYnNlcnZlT24uanMiLCJub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0Zyb21FdmVudE9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2RlYm91bmNlVGltZS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2RvLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWFwLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3Ivb2JzZXJ2ZU9uLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL0FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9BbmltYXRpb25GcmFtZUFjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9BbmltYXRpb25GcmFtZVNjaGVkdWxlci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9Bc3luY0FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9Bc3luY1NjaGVkdWxlci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9hbmltYXRpb25GcmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9hc3luYy5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3N5bWJvbC9vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvc3ltYm9sL3J4U3Vic2NyaWJlci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvQW5pbWF0aW9uRnJhbWUuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL2Vycm9yT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc09iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvcm9vdC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvdG9TdWJzY3JpYmVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC90cnlDYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy93ZWItYW5pbWF0aW9ucy1qcy93ZWItYW5pbWF0aW9ucy5taW4uanMiLCIuLi8ubnBtLXBhY2thZ2VzL2xpYi9ub2RlX21vZHVsZXMveS1jb21wb25lbnQvc3JjL2NvbXBvbmVudC1jb3JlLmpzIiwiLi4veS1kcmF3ZXIvc3JjL2NvbW1vbi5qcyIsIi4uL3ktZHJhd2VyL3NyYy9jb3JlL2luZGV4LmpzIiwiLi4veS1kcmF3ZXIvc3JjL3ZhbmlsbGEvaW5kZXguanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvSW5uZXJTdWJzY3JpYmVyLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL091dGVyU3Vic2NyaWJlci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9TdWJqZWN0LmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL1N1YmplY3RTdWJzY3JpcHRpb24uanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvZGVmZXIuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvZG9tL2FqYXguanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvZW1wdHkuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvbWVyZ2UuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvb2YuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29ic2VydmFibGUvdGhyb3cuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2NhdGNoLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9kZWxheS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvZGlzdGluY3RVbnRpbEtleUNoYW5nZWQuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2ZpbHRlci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvbWVyZ2UuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL21lcmdlQWxsLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9zaGFyZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3Ivc3RhcnRXaXRoLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9zd2l0Y2guanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaE1hcC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvdGFrZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3Ivd2l0aExhdGVzdEZyb20uanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3ppcC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0RlZmVyT2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0Vycm9yT2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL1NjYWxhck9ic2VydmFibGUuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9kZWZlci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL2RvbS9BamF4T2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL2RvbS9hamF4LmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvZW1wdHkuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9tZXJnZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL29mLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvdGhyb3cuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvY2F0Y2guanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvY29uY2F0LmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2RlbGF5LmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxDaGFuZ2VkLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2ZpbHRlci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9tZXJnZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9tZXJnZUFsbC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9tdWx0aWNhc3QuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3Ivc2hhcmUuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3Ivc3RhcnRXaXRoLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3N3aXRjaC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9zd2l0Y2hNYXAuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvdGFrZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci93aXRoTGF0ZXN0RnJvbS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci96aXAuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL0FzYXBBY3Rpb24uanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL0FzYXBTY2hlZHVsZXIuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL2FzYXAuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9JbW1lZGlhdGUuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzQXJyYXlMaWtlLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNEYXRlLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNQcm9taXNlLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNTY2hlZHVsZXIuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9yb290LmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQuanMiLCIuLi95LXB1c2gtc3RhdGUvc3JjL2NvbW1vbi5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9zcmMvY29yZS9pbmRleC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9zcmMvY29yZS9raW5kLmpzIiwiLi4veS1wdXNoLXN0YXRlL3NyYy92YW5pbGxhL2luZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7OztBQ0FBOztBQUVBLENBQUMsVUFBQSxBQUFTLEdBQVQsQUFBVyxHQUFYLEFBQWEsR0FBRSxBQUFDO1dBQUEsQUFBUyxFQUFULEFBQVcsR0FBWCxBQUFhLEdBQUUsQUFBQztXQUFPLFFBQUEsQUFBTywwQ0FBUCxBQUFPLFFBQWQsQUFBa0IsQUFBRTtZQUFBLEFBQVMsSUFBRyxBQUFDO1FBQUEsQUFBSSxHQUFKLEFBQU0sR0FBTixBQUFRLEdBQVIsQUFBVSxHQUFWLEFBQVksR0FBWixBQUFjLEdBQWQsQUFBZ0IsRUFBRSxLQUFJLElBQUosQUFBUSxLQUFSLEFBQWEsR0FBRTtVQUFHLEVBQUEsQUFBRSxlQUFMLEFBQUcsQUFBaUIsSUFBRyxBQUFDO1lBQUcsSUFBQSxBQUFFLElBQUcsSUFBRSxFQUFQLEFBQU8sQUFBRSxJQUFHLEVBQUEsQUFBRSxTQUFPLEVBQUEsQUFBRSxLQUFLLEVBQUEsQUFBRSxLQUFULEFBQU8sQUFBTyxnQkFBZSxFQUFBLEFBQUUsV0FBUyxFQUFBLEFBQUUsUUFBYixBQUFxQixXQUFTLEVBQUEsQUFBRSxRQUFGLEFBQVUsUUFBN0YsQUFBZSxBQUFzRixTQUFRLEtBQUksSUFBSixBQUFNLEdBQUUsSUFBRSxFQUFBLEFBQUUsUUFBRixBQUFVLFFBQXBCLEFBQTRCLFFBQTVCLEFBQW1DLEtBQUk7WUFBQSxBQUFFLEtBQUssRUFBQSxBQUFFLFFBQUYsQUFBVSxRQUFWLEFBQWtCLEdBQWhFLEFBQXVDLEFBQU8sQUFBcUI7QUFBZSxjQUFJLElBQUUsRUFBRSxFQUFGLEFBQUksSUFBSixBQUFPLGNBQVksRUFBbkIsQUFBbUIsQUFBRSxPQUFLLEVBQTVCLEFBQThCLElBQUcsSUFBckMsQUFBdUMsR0FBRSxJQUFFLEVBQTNDLEFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBOztBQ0FBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEVBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDajFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ppREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3h0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcnJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LElBQUksTUFBTSxNQUFOLEFBQU0sQUFBTSxBQUNyQjthQUFBLEFBQU8sQUFDUjs7Ozs7RUFWb0MsVzs7a0IsQUFBbEIiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyohIG1vZGVybml6ciAzLjMuMSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVCAqXG4gKiBodHRwczovL21vZGVybml6ci5jb20vZG93bmxvYWQvPy1jbGFzc2xpc3QtY3NzcG9pbnRlcmV2ZW50cy1jc3NyZW11bml0LWNzc3RyYW5zZm9ybXMtZG9jdW1lbnRmcmFnbWVudC1ldmVudGxpc3RlbmVyLWhpc3RvcnktbWF0Y2htZWRpYS1vcGFjaXR5LXF1ZXJ5c2VsZWN0b3ItcmVxdWVzdGFuaW1hdGlvbmZyYW1lLXRvdWNoZXZlbnRzICEqL1xuIWZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUsdCl7cmV0dXJuIHR5cGVvZiBlPT09dH1mdW5jdGlvbiBvKCl7dmFyIGUsdCxuLG8saSxzLGE7Zm9yKHZhciB1IGluIHkpaWYoeS5oYXNPd25Qcm9wZXJ0eSh1KSl7aWYoZT1bXSx0PXlbdV0sdC5uYW1lJiYoZS5wdXNoKHQubmFtZS50b0xvd2VyQ2FzZSgpKSx0Lm9wdGlvbnMmJnQub3B0aW9ucy5hbGlhc2VzJiZ0Lm9wdGlvbnMuYWxpYXNlcy5sZW5ndGgpKWZvcihuPTA7bjx0Lm9wdGlvbnMuYWxpYXNlcy5sZW5ndGg7bisrKWUucHVzaCh0Lm9wdGlvbnMuYWxpYXNlc1tuXS50b0xvd2VyQ2FzZSgpKTtmb3Iobz1yKHQuZm4sXCJmdW5jdGlvblwiKT90LmZuKCk6dC5mbixpPTA7aTxlLmxlbmd0aDtpKyspcz1lW2ldLGE9cy5zcGxpdChcIi5cIiksMT09PWEubGVuZ3RoP01vZGVybml6clthWzBdXT1vOighTW9kZXJuaXpyW2FbMF1dfHxNb2Rlcm5penJbYVswXV1pbnN0YW5jZW9mIEJvb2xlYW58fChNb2Rlcm5penJbYVswXV09bmV3IEJvb2xlYW4oTW9kZXJuaXpyW2FbMF1dKSksTW9kZXJuaXpyW2FbMF1dW2FbMV1dPW8pLHgucHVzaCgobz9cIlwiOlwibm8tXCIpK2Euam9pbihcIi1cIikpfX1mdW5jdGlvbiBpKGUpe3JldHVybiBlLnJlcGxhY2UoLyhbYS16XSktKFthLXpdKS9nLGZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdCtuLnRvVXBwZXJDYXNlKCl9KS5yZXBsYWNlKC9eLS8sXCJcIil9ZnVuY3Rpb24gcygpe3JldHVyblwiZnVuY3Rpb25cIiE9dHlwZW9mIHQuY3JlYXRlRWxlbWVudD90LmNyZWF0ZUVsZW1lbnQoYXJndW1lbnRzWzBdKTpUP3QuY3JlYXRlRWxlbWVudE5TLmNhbGwodCxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsYXJndW1lbnRzWzBdKTp0LmNyZWF0ZUVsZW1lbnQuYXBwbHkodCxhcmd1bWVudHMpfWZ1bmN0aW9uIGEoKXt2YXIgZT10LmJvZHk7cmV0dXJuIGV8fChlPXMoVD9cInN2Z1wiOlwiYm9keVwiKSxlLmZha2U9ITApLGV9ZnVuY3Rpb24gdShlLG4scixvKXt2YXIgaSx1LGYsZCxsPVwibW9kZXJuaXpyXCIsYz1zKFwiZGl2XCIpLHA9YSgpO2lmKHBhcnNlSW50KHIsMTApKWZvcig7ci0tOylmPXMoXCJkaXZcIiksZi5pZD1vP29bcl06bCsocisxKSxjLmFwcGVuZENoaWxkKGYpO3JldHVybiBpPXMoXCJzdHlsZVwiKSxpLnR5cGU9XCJ0ZXh0L2Nzc1wiLGkuaWQ9XCJzXCIrbCwocC5mYWtlP3A6YykuYXBwZW5kQ2hpbGQoaSkscC5hcHBlbmRDaGlsZChjKSxpLnN0eWxlU2hlZXQ/aS5zdHlsZVNoZWV0LmNzc1RleHQ9ZTppLmFwcGVuZENoaWxkKHQuY3JlYXRlVGV4dE5vZGUoZSkpLGMuaWQ9bCxwLmZha2UmJihwLnN0eWxlLmJhY2tncm91bmQ9XCJcIixwLnN0eWxlLm92ZXJmbG93PVwiaGlkZGVuXCIsZD1TLnN0eWxlLm92ZXJmbG93LFMuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIixTLmFwcGVuZENoaWxkKHApKSx1PW4oYyxlKSxwLmZha2U/KHAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwKSxTLnN0eWxlLm92ZXJmbG93PWQsUy5vZmZzZXRIZWlnaHQpOmMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjKSwhIXV9ZnVuY3Rpb24gZihlLHQpe3JldHVybiEhfihcIlwiK2UpLmluZGV4T2YodCl9ZnVuY3Rpb24gZChlLHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLmFwcGx5KHQsYXJndW1lbnRzKX19ZnVuY3Rpb24gbChlLHQsbil7dmFyIG87Zm9yKHZhciBpIGluIGUpaWYoZVtpXWluIHQpcmV0dXJuIG49PT0hMT9lW2ldOihvPXRbZVtpXV0scihvLFwiZnVuY3Rpb25cIik/ZChvLG58fHQpOm8pO3JldHVybiExfWZ1bmN0aW9uIGMoZSl7cmV0dXJuIGUucmVwbGFjZSgvKFtBLVpdKS9nLGZ1bmN0aW9uKGUsdCl7cmV0dXJuXCItXCIrdC50b0xvd2VyQ2FzZSgpfSkucmVwbGFjZSgvXm1zLS8sXCItbXMtXCIpfWZ1bmN0aW9uIHAodCxyKXt2YXIgbz10Lmxlbmd0aDtpZihcIkNTU1wiaW4gZSYmXCJzdXBwb3J0c1wiaW4gZS5DU1Mpe2Zvcig7by0tOylpZihlLkNTUy5zdXBwb3J0cyhjKHRbb10pLHIpKXJldHVybiEwO3JldHVybiExfWlmKFwiQ1NTU3VwcG9ydHNSdWxlXCJpbiBlKXtmb3IodmFyIGk9W107by0tOylpLnB1c2goXCIoXCIrYyh0W29dKStcIjpcIityK1wiKVwiKTtyZXR1cm4gaT1pLmpvaW4oXCIgb3IgXCIpLHUoXCJAc3VwcG9ydHMgKFwiK2krXCIpIHsgI21vZGVybml6ciB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgfSB9XCIsZnVuY3Rpb24oZSl7cmV0dXJuXCJhYnNvbHV0ZVwiPT1nZXRDb21wdXRlZFN0eWxlKGUsbnVsbCkucG9zaXRpb259KX1yZXR1cm4gbn1mdW5jdGlvbiBtKGUsdCxvLGEpe2Z1bmN0aW9uIHUoKXtsJiYoZGVsZXRlIE8uc3R5bGUsZGVsZXRlIE8ubW9kRWxlbSl9aWYoYT1yKGEsXCJ1bmRlZmluZWRcIik/ITE6YSwhcihvLFwidW5kZWZpbmVkXCIpKXt2YXIgZD1wKGUsbyk7aWYoIXIoZCxcInVuZGVmaW5lZFwiKSlyZXR1cm4gZH1mb3IodmFyIGwsYyxtLHYsaCx5PVtcIm1vZGVybml6clwiLFwidHNwYW5cIixcInNhbXBcIl07IU8uc3R5bGUmJnkubGVuZ3RoOylsPSEwLE8ubW9kRWxlbT1zKHkuc2hpZnQoKSksTy5zdHlsZT1PLm1vZEVsZW0uc3R5bGU7Zm9yKG09ZS5sZW5ndGgsYz0wO20+YztjKyspaWYodj1lW2NdLGg9Ty5zdHlsZVt2XSxmKHYsXCItXCIpJiYodj1pKHYpKSxPLnN0eWxlW3ZdIT09bil7aWYoYXx8cihvLFwidW5kZWZpbmVkXCIpKXJldHVybiB1KCksXCJwZnhcIj09dD92OiEwO3RyeXtPLnN0eWxlW3ZdPW99Y2F0Y2goZyl7fWlmKE8uc3R5bGVbdl0hPWgpcmV0dXJuIHUoKSxcInBmeFwiPT10P3Y6ITB9cmV0dXJuIHUoKSwhMX1mdW5jdGlvbiB2KGUsdCxuLG8saSl7dmFyIHM9ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKStlLnNsaWNlKDEpLGE9KGUrXCIgXCIrei5qb2luKHMrXCIgXCIpK3MpLnNwbGl0KFwiIFwiKTtyZXR1cm4gcih0LFwic3RyaW5nXCIpfHxyKHQsXCJ1bmRlZmluZWRcIik/bShhLHQsbyxpKTooYT0oZStcIiBcIitiLmpvaW4ocytcIiBcIikrcykuc3BsaXQoXCIgXCIpLGwoYSx0LG4pKX1mdW5jdGlvbiBoKGUsdCxyKXtyZXR1cm4gdihlLG4sbix0LHIpfXZhciB5PVtdLGc9e192ZXJzaW9uOlwiMy4zLjFcIixfY29uZmlnOntjbGFzc1ByZWZpeDpcIlwiLGVuYWJsZUNsYXNzZXM6ITAsZW5hYmxlSlNDbGFzczohMCx1c2VQcmVmaXhlczohMH0sX3E6W10sb246ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzO3NldFRpbWVvdXQoZnVuY3Rpb24oKXt0KG5bZV0pfSwwKX0sYWRkVGVzdDpmdW5jdGlvbihlLHQsbil7eS5wdXNoKHtuYW1lOmUsZm46dCxvcHRpb25zOm59KX0sYWRkQXN5bmNUZXN0OmZ1bmN0aW9uKGUpe3kucHVzaCh7bmFtZTpudWxsLGZuOmV9KX19LE1vZGVybml6cj1mdW5jdGlvbigpe307TW9kZXJuaXpyLnByb3RvdHlwZT1nLE1vZGVybml6cj1uZXcgTW9kZXJuaXpyLE1vZGVybml6ci5hZGRUZXN0KFwiZXZlbnRsaXN0ZW5lclwiLFwiYWRkRXZlbnRMaXN0ZW5lclwiaW4gZSksTW9kZXJuaXpyLmFkZFRlc3QoXCJxdWVyeXNlbGVjdG9yXCIsXCJxdWVyeVNlbGVjdG9yXCJpbiB0JiZcInF1ZXJ5U2VsZWN0b3JBbGxcImluIHQpLE1vZGVybml6ci5hZGRUZXN0KFwiaGlzdG9yeVwiLGZ1bmN0aW9uKCl7dmFyIHQ9bmF2aWdhdG9yLnVzZXJBZ2VudDtyZXR1cm4tMT09PXQuaW5kZXhPZihcIkFuZHJvaWQgMi5cIikmJi0xPT09dC5pbmRleE9mKFwiQW5kcm9pZCA0LjBcIil8fC0xPT09dC5pbmRleE9mKFwiTW9iaWxlIFNhZmFyaVwiKXx8LTEhPT10LmluZGV4T2YoXCJDaHJvbWVcIil8fC0xIT09dC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKT9lLmhpc3RvcnkmJlwicHVzaFN0YXRlXCJpbiBlLmhpc3Rvcnk6ITF9KTt2YXIgeD1bXSxDPWcuX2NvbmZpZy51c2VQcmVmaXhlcz9cIiAtd2Via2l0LSAtbW96LSAtby0gLW1zLSBcIi5zcGxpdChcIiBcIik6W1wiXCIsXCJcIl07Zy5fcHJlZml4ZXM9Qzt2YXIgUz10LmRvY3VtZW50RWxlbWVudDtNb2Rlcm5penIuYWRkVGVzdChcImNsYXNzbGlzdFwiLFwiY2xhc3NMaXN0XCJpbiBTKSxNb2Rlcm5penIuYWRkVGVzdChcImRvY3VtZW50ZnJhZ21lbnRcIixmdW5jdGlvbigpe3JldHVyblwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudFwiaW4gdCYmXCJhcHBlbmRDaGlsZFwiaW4gU30pO3ZhciBUPVwic3ZnXCI9PT1TLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7TW9kZXJuaXpyLmFkZFRlc3QoXCJvcGFjaXR5XCIsZnVuY3Rpb24oKXt2YXIgZT1zKFwiYVwiKS5zdHlsZTtyZXR1cm4gZS5jc3NUZXh0PUMuam9pbihcIm9wYWNpdHk6LjU1O1wiKSwvXjAuNTUkLy50ZXN0KGUub3BhY2l0eSl9KSxNb2Rlcm5penIuYWRkVGVzdChcImNzc3BvaW50ZXJldmVudHNcIixmdW5jdGlvbigpe3ZhciBlPXMoXCJhXCIpLnN0eWxlO3JldHVybiBlLmNzc1RleHQ9XCJwb2ludGVyLWV2ZW50czphdXRvXCIsXCJhdXRvXCI9PT1lLnBvaW50ZXJFdmVudHN9KSxNb2Rlcm5penIuYWRkVGVzdChcImNzc3JlbXVuaXRcIixmdW5jdGlvbigpe3ZhciBlPXMoXCJhXCIpLnN0eWxlO3RyeXtlLmZvbnRTaXplPVwiM3JlbVwifWNhdGNoKHQpe31yZXR1cm4vcmVtLy50ZXN0KGUuZm9udFNpemUpfSk7dmFyIHc9Zy50ZXN0U3R5bGVzPXU7TW9kZXJuaXpyLmFkZFRlc3QoXCJ0b3VjaGV2ZW50c1wiLGZ1bmN0aW9uKCl7dmFyIG47aWYoXCJvbnRvdWNoc3RhcnRcImluIGV8fGUuRG9jdW1lbnRUb3VjaCYmdCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2gpbj0hMDtlbHNle3ZhciByPVtcIkBtZWRpYSAoXCIsQy5qb2luKFwidG91Y2gtZW5hYmxlZCksKFwiKSxcImhlYXJ0elwiLFwiKVwiLFwieyNtb2Rlcm5penJ7dG9wOjlweDtwb3NpdGlvbjphYnNvbHV0ZX19XCJdLmpvaW4oXCJcIik7dyhyLGZ1bmN0aW9uKGUpe249OT09PWUub2Zmc2V0VG9wfSl9cmV0dXJuIG59KTt2YXIgXz1cIk1veiBPIG1zIFdlYmtpdFwiLHo9Zy5fY29uZmlnLnVzZVByZWZpeGVzP18uc3BsaXQoXCIgXCIpOltdO2cuX2Nzc29tUHJlZml4ZXM9ejt2YXIgQT1mdW5jdGlvbih0KXt2YXIgcixvPUMubGVuZ3RoLGk9ZS5DU1NSdWxlO2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBpKXJldHVybiBuO2lmKCF0KXJldHVybiExO2lmKHQ9dC5yZXBsYWNlKC9eQC8sXCJcIikscj10LnJlcGxhY2UoLy0vZyxcIl9cIikudG9VcHBlckNhc2UoKStcIl9SVUxFXCIsciBpbiBpKXJldHVyblwiQFwiK3Q7Zm9yKHZhciBzPTA7bz5zO3MrKyl7dmFyIGE9Q1tzXSx1PWEudG9VcHBlckNhc2UoKStcIl9cIityO2lmKHUgaW4gaSlyZXR1cm5cIkAtXCIrYS50b0xvd2VyQ2FzZSgpK1wiLVwiK3R9cmV0dXJuITF9O2cuYXRSdWxlPUE7dmFyIGI9Zy5fY29uZmlnLnVzZVByZWZpeGVzP18udG9Mb3dlckNhc2UoKS5zcGxpdChcIiBcIik6W107Zy5fZG9tUHJlZml4ZXM9Yjt2YXIgRT17ZWxlbTpzKFwibW9kZXJuaXpyXCIpfTtNb2Rlcm5penIuX3EucHVzaChmdW5jdGlvbigpe2RlbGV0ZSBFLmVsZW19KTt2YXIgTz17c3R5bGU6RS5lbGVtLnN0eWxlfTtNb2Rlcm5penIuX3EudW5zaGlmdChmdW5jdGlvbigpe2RlbGV0ZSBPLnN0eWxlfSksZy50ZXN0QWxsUHJvcHM9djt2YXIgUD1nLnByZWZpeGVkPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gMD09PWUuaW5kZXhPZihcIkBcIik/QShlKTooLTEhPWUuaW5kZXhPZihcIi1cIikmJihlPWkoZSkpLHQ/dihlLHQsbik6dihlLFwicGZ4XCIpKX07TW9kZXJuaXpyLmFkZFRlc3QoXCJyZXF1ZXN0YW5pbWF0aW9uZnJhbWVcIiwhIVAoXCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWVcIixlKSx7YWxpYXNlczpbXCJyYWZcIl19KSxNb2Rlcm5penIuYWRkVGVzdChcIm1hdGNobWVkaWFcIiwhIVAoXCJtYXRjaE1lZGlhXCIsZSkpLGcudGVzdEFsbFByb3BzPWgsTW9kZXJuaXpyLmFkZFRlc3QoXCJjc3N0cmFuc2Zvcm1zXCIsZnVuY3Rpb24oKXtyZXR1cm4tMT09PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkFuZHJvaWQgMi5cIikmJmgoXCJ0cmFuc2Zvcm1cIixcInNjYWxlKDEpXCIsITApfSksbygpLGRlbGV0ZSBnLmFkZFRlc3QsZGVsZXRlIGcuYWRkQXN5bmNUZXN0O2Zvcih2YXIgcT0wO3E8TW9kZXJuaXpyLl9xLmxlbmd0aDtxKyspTW9kZXJuaXpyLl9xW3FdKCk7ZS5Nb2Rlcm5penI9TW9kZXJuaXpyfSh3aW5kb3csZG9jdW1lbnQpO1xuIiwiaW1wb3J0ICcuLi9saWIvbW9kZXJuaXpyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ZlYXR1cmVzKGZlYXR1cmVzKSB7XG4gIGxldCBhY2MgPSB0cnVlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgIGNvbnN0IGhhc0ZlYXR1cmUgPSB3aW5kb3cuTW9kZXJuaXpyW2ZlYXR1cmVdO1xuICAgIC8vIGlmICghaGFzRmVhdHVyZSkgY29uc29sZS53YXJuKCdGZWF0dXJlIFwiJyArIGZlYXR1cmUgKyAnXCIgbWlzc2luZyEnKTtcbiAgICBhY2MgPSBhY2MgJiYgaGFzRmVhdHVyZTtcbiAgfVxuICByZXR1cm4gYWNjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdyhlbCkge1xuICBlbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoaWRlKGVsKSB7XG4gIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgZWwuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnNob3coZWwpIHtcbiAgZWwuc3R5bGUuZGlzcGxheSA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGVsLnN0eWxlLnZpc2liaWxpdHkgPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxufVxuXG5leHBvcnQgY29uc3QgdW5oaWRlID0gdW5zaG93O1xuXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lQ3VzdG9tRWxlbWVudCh0YWdOYW1lLCBDdXN0b21IVE1MRWxlbWVudCkge1xuICBpZiAoJ2N1c3RvbUVsZW1lbnRzJyBpbiB3aW5kb3cpIHtcbiAgICBjdXN0b21FbGVtZW50cy5kZWZpbmUodGFnTmFtZSwgQ3VzdG9tSFRNTEVsZW1lbnQpO1xuICB9IGVsc2UgaWYgKCdyZWdpc3RlckVsZW1lbnQnIGluIGRvY3VtZW50KSB7XG4gICAgZG9jdW1lbnQucmVnaXN0ZXJFbGVtZW50KHRhZ05hbWUsIEN1c3RvbUhUTUxFbGVtZW50KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQ3VzdG9tRWxlbWVudHMoZikge1xuICBpZiAoJ2N1c3RvbUVsZW1lbnRzJyBpbiB3aW5kb3cgfHwgJ3JlZ2lzdGVyRWxlbWVudCcgaW4gZG9jdW1lbnQpIHtcbiAgICBmKCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCF3aW5kb3cubG9hZGluZ0N1c3RvbUVsZW1lbnRzKSBsb2FkSlNEZWZlcnJlZCgnaHR0cHM6Ly91bnBrZy5jb20vd2ViY29tcG9uZW50cy5qc0AwLjcuMjIvQ3VzdG9tRWxlbWVudHMubWluLmpzJyk7XG4gICAgd2luZG93LmxvYWRpbmdDdXN0b21FbGVtZW50cyA9IHRydWU7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ1dlYkNvbXBvbmVudHNSZWFkeScsIGYpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGVzKGVsLCBzZWxlY3Rvcikge1xuICByZXR1cm4gKGVsLm1hdGNoZXMgfHwgZWwubWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBlbC5vTWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGVsLCBzZWxlY3Rvcik7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXMsIGltcG9ydC9uby11bnJlc29sdmVkLCBpbXBvcnQvZXh0ZW5zaW9ucyAqL1xuXG5pbXBvcnQgWURyYXdlciBmcm9tICd5LWRyYXdlci9zcmMvdmFuaWxsYSc7XG5cbmltcG9ydCB7IGhhc0ZlYXR1cmVzIH0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCBSRVFVSVJFTUVOVFMgPSBbXG4gICdldmVudGxpc3RlbmVyJyxcbiAgJ3F1ZXJ5c2VsZWN0b3InLFxuICAnbWF0Y2htZWRpYScsXG4gICdyZXF1ZXN0YW5pbWF0aW9uZnJhbWUnLFxuICAnY2xhc3NsaXN0JyxcbiAgJ29wYWNpdHknLFxuICAnY3NzdHJhbnNmb3JtcycsXG4gICdjc3Nwb2ludGVyZXZlbnRzJyxcbiAgJ2Nzc3JlbXVuaXQnLFxuXTtcblxuY29uc3QgTUVESUFfUVVFUlkgPSAnKG1pbi13aWR0aDogODAxcHgpJztcblxuZnVuY3Rpb24gcmVzaXplQ2FsbGJhY2soKSB7XG4gIGNvbnN0IGhhc0NoYW5nZWQgPSB3aW5kb3cuaXNEZXNrdG9wICE9PSB3aW5kb3cubWF0Y2hNZWRpYShNRURJQV9RVUVSWSkubWF0Y2hlcztcbiAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICB3aW5kb3cuaXNEZXNrdG9wID0gIXdpbmRvdy5pc0Rlc2t0b3A7XG4gICAgd2luZG93LmRyYXdlci5wZXJzaXN0ZW50ID0gd2luZG93LmlzRGVza3RvcDtcbiAgICB3aW5kb3cuZHJhd2VyLmp1bXBUbyh3aW5kb3cuaXNEZXNrdG9wKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtZW51Q2xpY2tDbGFsbGJhY2soZSkge1xuICBpZiAoIXdpbmRvdy5pc0Rlc2t0b3ApIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgd2luZG93LmRyYXdlci50b2dnbGUoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyhkcmF3ZXIpIHtcbiAgd2luZG93LmRyYXdlciA9IGRyYXdlcjtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHJlc2l6ZUNhbGxiYWNrKTtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19tZW51JykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBtZW51Q2xpY2tDbGFsbGJhY2spO1xufVxuXG5pZiAoaGFzRmVhdHVyZXMoUkVRVUlSRU1FTlRTKSkge1xuICB3aW5kb3cuaXNEZXNrdG9wID0gd2luZG93Lm1hdGNoTWVkaWEoTUVESUFfUVVFUlkpLm1hdGNoZXM7XG4gIGNvbnN0IGRyYXdlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyN5LWRyYXdlcicpO1xuXG4gIGFkZEV2ZW50TGlzdGVuZXJzKG5ldyBZRHJhd2VyKGRyYXdlciwge1xuICAgIG9wZW5lZDogd2luZG93LmlzRGVza3RvcCxcbiAgICBwZXJzaXN0ZW50OiB3aW5kb3cuaXNEZXNrdG9wLFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMTUwLFxuICB9KSk7XG5cbiAgZHJhd2VyLmNsYXNzTGlzdC5hZGQoJ2xvYWRlZCcpO1xufVxuIiwiaW1wb3J0ICdjb3JlLWpzL2ZuL2FycmF5L2Zvci1lYWNoJztcbmltcG9ydCAnY29yZS1qcy9mbi9mdW5jdGlvbi9iaW5kJztcbmltcG9ydCAnY29yZS1qcy9mbi9udW1iZXIvY29uc3RydWN0b3InO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL29iamVjdC9hc3NpZ24nO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHknO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL29iamVjdC9rZXlzJztcbmltcG9ydCAnY29yZS1qcy9mbi9hcnJheS9yZWR1Y2UnO1xuXG5pbXBvcnQgJ3dlYi1hbmltYXRpb25zLWpzJztcblxuaW1wb3J0ICcuL3N0eWxlJztcbmltcG9ydCAnLi9rYXRleCc7XG5pbXBvcnQgJy4vZHJhd2VyJztcbmltcG9ydCAnLi9wdXNoLXN0YXRlJztcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5cbmltcG9ydCB7IGxvYWRDU1MgfSBmcm9tICdmZy1sb2FkY3NzL3NyYy9sb2FkQ1NTJztcbmltcG9ydCBrYXRleCBmcm9tICdrYXRleCc7XG5cbmltcG9ydCB7IGhhc0ZlYXR1cmVzLCBoaWRlLCBtYXRjaGVzIH0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCBSRVFVSVJFTUVOVFMgPSBbXG4gICdldmVudGxpc3RlbmVyJyxcbiAgJ3F1ZXJ5c2VsZWN0b3InLFxuICAncmVxdWVzdGFuaW1hdGlvbmZyYW1lJyxcbl07XG5cbmZ1bmN0aW9uIHdpbGxDaGFuZ2VDb250ZW50KG1hdGhCbG9ja3MpIHtcbiAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChtYXRoQmxvY2tzLCAoZWwpID0+IHtcbiAgICBlbC5zdHlsZS53aWxsQ2hhbmdlID0gJ2NvbnRlbnQnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlTWF0aEJsb2NrKGVsLCB0ZXgpIHtcbiAgZWwub3V0ZXJIVE1MID0ga2F0ZXgucmVuZGVyVG9TdHJpbmcodGV4LCB7XG4gICAgZGlzcGxheU1vZGU6IGVsLnR5cGUgPT09ICdtYXRoL3RleDsgbW9kZT1kaXNwbGF5JyxcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckthdGV4KGVsLCB0ZXgpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwcmV2ID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICByZXBsYWNlTWF0aEJsb2NrKGVsLCB0ZXgpO1xuICAgIGlmIChwcmV2ICYmIG1hdGNoZXMocHJldiwgJy5NYXRoSmF4X1ByZXZpZXcnKSkgaGlkZShwcmV2KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBwcm9kdWN0aW9uIGJ1aWxkcz9cbiAgICBjb25zb2xlLmVycm9yKGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgfSBmaW5hbGx5IHtcbiAgICBlbC5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFRleFNvdXJjZShlbCkge1xuICByZXR1cm4gZWwudGV4dENvbnRlbnQucmVwbGFjZSgnJSA8IVtDREFUQVsnLCAnJykucmVwbGFjZSgnJV1dPicsICcnKTtcbn1cblxuZnVuY3Rpb24gY2hhbmdlQ29udGVudChtYXRoQmxvY2tzKSB7XG4gIC8vIGtyYW1kb3duIGdlbmVyYXRlcyBzY3JpcHQgdGFncyB3aXRoIHR5cGUgXCJtYXRoL3RleFwiXG4gIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobWF0aEJsb2NrcywgKHNjcmlwdCkgPT4ge1xuICAgIGNvbnN0IHRleCA9IHJlYWRUZXhTb3VyY2Uoc2NyaXB0KTtcbiAgICByZW5kZXJLYXRleChzY3JpcHQsIHRleCk7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cGdyYWRlTWF0aEJsb2NrcygpIHtcbiAgaWYgKGhhc0ZlYXR1cmVzKFJFUVVJUkVNRU5UUykpIHtcbiAgICBjb25zdCBtYXRoQmxvY2tzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc2NyaXB0W3R5cGVePVwibWF0aC90ZXhcIl0nKTtcbiAgICBpZiAobWF0aEJsb2Nrcy5sZW5ndGgpIHtcbiAgICAgIHdpbGxDaGFuZ2VDb250ZW50KG1hdGhCbG9ja3MpO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGNoYW5nZUNvbnRlbnQobWF0aEJsb2NrcykpO1xuICAgIH1cbiAgfVxufVxuXG5pZiAoaGFzRmVhdHVyZXMoUkVRVUlSRU1FTlRTKSkge1xuICBjb25zdCByZWYgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGUnKVswXTtcbiAgY29uc3Qgc3R5bGUgPSBsb2FkQ1NTKCdodHRwczovL3VucGtnLmNvbS9rYXRleEAwLjYuMC9kaXN0L2thdGV4Lm1pbi5jc3MnLCByZWYpO1xuICBzdHlsZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdXBncmFkZU1hdGhCbG9ja3MpO1xufVxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24sIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcywgaW1wb3J0L25vLXVucmVzb2x2ZWQsIGltcG9ydC9leHRlbnNpb25zICovXG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5cbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvZGVib3VuY2VUaW1lJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvZG8nO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tYXAnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9vYnNlcnZlT24nO1xuXG5pbXBvcnQgeyBhbmltYXRpb25GcmFtZSB9IGZyb20gJ3J4anMvc2NoZWR1bGVyL2FuaW1hdGlvbkZyYW1lJztcblxuaW1wb3J0IFB1c2hTdGF0ZSBmcm9tICd5LXB1c2gtc3RhdGUvc3JjL3ZhbmlsbGEnO1xuXG5pbXBvcnQgeyBoYXNGZWF0dXJlcyB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB1cGdyYWRlTWF0aEJsb2NrcyBmcm9tICcuL2thdGV4JztcblxuY29uc3QgUkVRVUlSRU1FTlRTID0gW1xuICAnZXZlbnRsaXN0ZW5lcicsXG4gICdxdWVyeXNlbGVjdG9yJyxcbiAgJ3JlcXVlc3RhbmltYXRpb25mcmFtZScsXG4gICdjbGFzc2xpc3QnLFxuICAnZG9jdW1lbnRmcmFnbWVudCcsXG4gICdoaXN0b3J5Jyxcbl07XG5cbmNvbnN0IERVUkFUSU9OID0gMjAwO1xuXG5jb25zdCBwdXNoU3RhdGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjeS1wdXNoLXN0YXRlJyk7XG5cbmlmIChoYXNGZWF0dXJlcyhSRVFVSVJFTUVOVFMpKSB7XG4gIC8vIHB1c2hTdGF0ZS5hZGRFdmVudExpc3RlbmVyKCd5LXB1c2gtc3RhdGUtZXJyb3InLCBlcnJvckNhbGxiYWNrKTtcblxuICBPYnNlcnZhYmxlLmZyb21FdmVudChwdXNoU3RhdGUsICd5LXB1c2gtc3RhdGUtYmVmb3JlJylcbiAgICAubWFwKCgpID0+IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21haW4nKSlcbiAgICAuZG8oKG1haW4pID0+IHtcbiAgICAgIG1haW4uc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICB9KVxuICAgIC5vYnNlcnZlT24oYW5pbWF0aW9uRnJhbWUpXG4gICAgLnN1YnNjcmliZSgobWFpbikgPT4ge1xuICAgICAgLy8gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdpcy1sb2FkaW5nJyk7XG5cbiAgICAgIG1haW4uYW5pbWF0ZShbXG4gICAgICAgIHsgb3BhY2l0eTogMSB9LFxuICAgICAgICB7IG9wYWNpdHk6IDAgfSxcbiAgICAgIF0sIHtcbiAgICAgICAgZHVyYXRpb246IERVUkFUSU9OLFxuICAgICAgICBlYXNpbmc6ICdjdWJpYy1iZXppZXIoMCwwLDAuMzIsMSknLFxuICAgICAgICBmaWxsOiAnZm9yd2FyZHMnLFxuICAgICAgfSk7XG4gICAgICAgIC8vIC5hZGRFdmVudExpc3RlbmVyKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICAgIC8vICAgbWFpbi5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgLy8gfSk7XG5cbiAgICAgIC8vIHVuc2hvdyhlcnJvcik7XG5cbiAgICAgIC8vIGlmIGEgbGluayBvbiB0aGUgZHJhd2VyIGhhcyBiZWVuIGNsaWNrZWQsIGNsb3NlIGl0XG4gICAgICBpZiAoIXdpbmRvdy5pc0Rlc2t0b3AgJiYgd2luZG93LmRyYXdlci5vcGVuZWQpIHtcbiAgICAgICAgd2luZG93LmRyYXdlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIE9ic2VydmFibGUuZnJvbUV2ZW50KHB1c2hTdGF0ZSwgJ3ktcHVzaC1zdGF0ZS1hZnRlcicpXG4gICAgLm1hcCgoKSA9PiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtYWluJykpXG4gICAgLmRvKChtYWluKSA9PiB7XG4gICAgICBtYWluLnN0eWxlLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtLCBvcGFjaXR5JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIH0pXG4gICAgLm9ic2VydmVPbihhbmltYXRpb25GcmFtZSlcbiAgICAuZG8oKG1haW4pID0+IHtcbiAgICAgIC8vIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZSgnaXMtbG9hZGluZycpXG4gICAgICBjb25zb2xlLmxvZygnYWZ0ZXJzZXEnKTtcblxuICAgICAgbWFpbi5hbmltYXRlKFtcbiAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC0ycmVtKScsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDApJywgb3BhY2l0eTogMSB9LFxuICAgICAgXSwge1xuICAgICAgICBkdXJhdGlvbjogRFVSQVRJT04sXG4gICAgICAgIGVhc2luZzogJ2N1YmljLWJlemllcigwLDAsMC4zMiwxKScsXG4gICAgICAgIC8vIGZpbGw6ICdmb3J3YXJkcycsXG4gICAgICB9KS5hZGRFdmVudExpc3RlbmVyKCdmaW5pc2gnLCAoKSA9PiB7IG1haW4uc3R5bGUud2lsbENoYW5nZSA9ICcnOyB9KTtcbiAgICB9KVxuICAgIC5kZWJvdW5jZVRpbWUoMjAwKVxuICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgLy8gc2VuZCBnb29nbGUgYW5hbHl0aWNzIHBhZ2V2aWV3XG4gICAgICBpZiAod2luZG93LmdhKSB3aW5kb3cuZ2EoJ3NlbmQnLCAncGFnZXZpZXcnKTtcblxuICAgICAgLy8gdXBncmFkZSBtYXRoIGJsb2Nrc1xuICAgICAgdXBncmFkZU1hdGhCbG9ja3MoKTtcbiAgICB9KTtcblxuICBuZXcgUHVzaFN0YXRlKHB1c2hTdGF0ZSwge1xuICAgIHJlcGxhY2VJZHM6IFsnX21haW4nLCAnX2FzaWRlYmFyJ10sXG4gICAgbGlua1NlbGVjdG9yOiAnYVtocmVmXj1cIi9cIl0nLFxuICAgIHNjcm9sbFJlc3RvcmF0aW9uOiB0cnVlLFxuICAgIGR1cmF0aW9uOiBEVVJBVElPTixcbiAgfSkuc3RhcnRIaXN0b3J5KCk7XG59XG4iLCJpbXBvcnQgeyBsb2FkQ1NTIH0gZnJvbSAnZmctbG9hZGNzcy9zcmMvbG9hZENTUyc7XG5cbmZ1bmN0aW9uIGhhc1ByZWxvYWRTdXBwb3J0KCkge1xuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJykucmVsTGlzdC5zdXBwb3J0cygncHJlbG9hZCcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIGxvb3AgcHJlbG9hZCBsaW5rcyBhbmQgZmV0Y2ggdXNpbmcgbG9hZENTU1xuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIGNvbnN0IGxpbmtzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpbmsnKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgbGluayA9IGxpbmtzW2ldO1xuICAgIGlmIChsaW5rLnJlbCA9PT0gJ3ByZWxvYWQnICYmIGxpbmsuZ2V0QXR0cmlidXRlKCdhcycpID09PSAnc3R5bGUnKSB7XG4gICAgICBsb2FkQ1NTKGxpbmsuaHJlZiwgbGluayk7XG4gICAgICBsaW5rLnJlbCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmlmICghaGFzUHJlbG9hZFN1cHBvcnQoKSkge1xuICBwb2x5ZmlsbCgpO1xufVxuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2gnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLkFycmF5LmZvckVhY2g7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5yZWR1Y2U7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuRnVuY3Rpb24uYmluZDsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKXtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Qua2V5czsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07IiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgYXNjICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUWVBFLCAkY3JlYXRlKXtcbiAgdmFyIElTX01BUCAgICAgICAgPSBUWVBFID09IDFcbiAgICAsIElTX0ZJTFRFUiAgICAgPSBUWVBFID09IDJcbiAgICAsIElTX1NPTUUgICAgICAgPSBUWVBFID09IDNcbiAgICAsIElTX0VWRVJZICAgICAgPSBUWVBFID09IDRcbiAgICAsIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDZcbiAgICAsIE5PX0hPTEVTICAgICAgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWFxuICAgICwgY3JlYXRlICAgICAgICA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpe1xuICAgIHZhciBPICAgICAgPSB0b09iamVjdCgkdGhpcylcbiAgICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICAgLCBmICAgICAgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IDBcbiAgICAgICwgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZFxuICAgICAgLCB2YWwsIHJlcztcbiAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpe1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYoVFlQRSl7XG4gICAgICAgIGlmKElTX01BUClyZXN1bHRbaW5kZXhdID0gcmVzOyAgICAgICAgICAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmKHJlcylzd2l0Y2goVFlQRSl7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZihJU19FVkVSWSlyZXR1cm4gZmFsc2U7ICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59OyIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpe1xuICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGF0KVxuICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBpbmRleCAgPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDBcbiAgICAsIGkgICAgICA9IGlzUmlnaHQgPyAtMSA6IDE7XG4gIGlmKGFMZW4gPCAyKWZvcig7Oyl7XG4gICAgaWYoaW5kZXggaW4gc2VsZil7XG4gICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4ICs9IGk7XG4gICAgaWYoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yKDtpc1JpZ2h0ID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKWlmKGluZGV4IGluIHNlbGYpe1xuICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gIH1cbiAgcmV0dXJuIG1lbW87XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaXNBcnJheSAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgU1BFQ0lFUyAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsKXtcbiAgdmFyIEM7XG4gIGlmKGlzQXJyYXkob3JpZ2luYWwpKXtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZih0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpQyA9IHVuZGVmaW5lZDtcbiAgICBpZihpc09iamVjdChDKSl7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmKEMgPT09IG51bGwpQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07IiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCwgbGVuZ3RoKXtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2VcbiAgLCBmYWN0b3JpZXMgID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbihGLCBsZW4sIGFyZ3Mpe1xuICBpZighKGxlbiBpbiBmYWN0b3JpZXMpKXtcbiAgICBmb3IodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKyluW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyosIGFyZ3MuLi4gKi8pe1xuICB2YXIgZm4gICAgICAgPSBhRnVuY3Rpb24odGhpcylcbiAgICAsIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uKC8qIGFyZ3MuLi4gKi8pe1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZihpc09iamVjdChmbi5wcm90b3R5cGUpKWJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07IiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmUgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pXG4gICAgLCBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYodGFyZ2V0KXJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmKGV4cG9ydHNba2V5XSAhPSBvdXQpaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59OyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIHRhcmdldCwgQyl7XG4gIHZhciBQLCBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICBpZihTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKXtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfSByZXR1cm4gdGhhdDtcbn07IiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59OyIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59OyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247IiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxuICAgICwgbHQgICAgID0gJzwnXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XG4gIHZhciByZXN1bHQ7XG4gIGlmKE8gIT09IG51bGwpe1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTsiLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIFA7XG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59OyIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTsiLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59OyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7IiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59OyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59OyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlOyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgU1JDICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpXG4gICwgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR11cbiAgLCBUUEwgICAgICAgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywga2V5LCB2YWwsIHNhZmUpe1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmKE9ba2V5XSA9PT0gdmFsKXJldHVybjtcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYoTyA9PT0gZ2xvYmFsKXtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaWYoIXNhZmUpe1xuICAgICAgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihPW2tleV0pT1trZXldID0gdmFsO1xuICAgICAgZWxzZSBoaWRlKE8sIGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pOyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTsiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59OyIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0aG9kLCBhcmcpe1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBhcmcgPyBtZXRob2QuY2FsbChudWxsLCBmdW5jdGlvbigpe30sIDEpIDogbWV0aG9kLmNhbGwobnVsbCk7XG4gIH0pO1xufTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgc3BhY2VzICA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpXG4gICwgc3BhY2UgICA9ICdbJyArIHNwYWNlcyArICddJ1xuICAsIG5vbiAgICAgPSAnXFx1MjAwYlxcdTAwODUnXG4gICwgbHRyaW0gICA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKVxuICAsIHJ0cmltICAgPSBSZWdFeHAoc3BhY2UgKyBzcGFjZSArICcqJCcpO1xuXG52YXIgZXhwb3J0ZXIgPSBmdW5jdGlvbihLRVksIGV4ZWMsIEFMSUFTKXtcbiAgdmFyIGV4cCAgID0ge307XG4gIHZhciBGT1JDRSA9IGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICEhc3BhY2VzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogc3BhY2VzW0tFWV07XG4gIGlmKEFMSUFTKWV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbihzdHJpbmcsIFRZUEUpe1xuICBzdHJpbmcgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgaWYoVFlQRSAmIDEpc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgaWYoVFlQRSAmIDIpc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7IiwibW9kdWxlLmV4cG9ydHMgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnOyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heFxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07IiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59OyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07IiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59OyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59OyIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMClcbiAgLCBTVFJJQ1QgICA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE4IC8gMTUuNC40LjIxIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKXtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7IiwiLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHtiaW5kOiByZXF1aXJlKCcuL19iaW5kJyl9KTsiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBjb2YgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZmFpbHMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBnT1BEICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGRQICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsICR0cmltICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgTlVNQkVSICAgICAgICAgICAgPSAnTnVtYmVyJ1xuICAsICROdW1iZXIgICAgICAgICAgID0gZ2xvYmFsW05VTUJFUl1cbiAgLCBCYXNlICAgICAgICAgICAgICA9ICROdW1iZXJcbiAgLCBwcm90byAgICAgICAgICAgICA9ICROdW1iZXIucHJvdG90eXBlXG4gIC8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xuICAsIEJST0tFTl9DT0YgICAgICAgID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUlxuICAsIFRSSU0gICAgICAgICAgICAgID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24oYXJndW1lbnQpe1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuICBpZih0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMil7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMClcbiAgICAgICwgdGhpcmQsIHJhZGl4LCBtYXhDb2RlO1xuICAgIGlmKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpe1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZihmaXJzdCA9PT0gNDgpe1xuICAgICAgc3dpdGNoKGl0LmNoYXJDb2RlQXQoMSkpe1xuICAgICAgICBjYXNlIDY2IDogY2FzZSA5OCAgOiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzkgOiBjYXNlIDExMSA6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQgOiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yKHZhciBkaWdpdHMgPSBpdC5zbGljZSgyKSwgaSA9IDAsIGwgPSBkaWdpdHMubGVuZ3RoLCBjb2RlOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKXJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbmlmKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSl7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpe1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlXG4gICAgICAsIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uKCl7IHByb3RvLnZhbHVlT2YuY2FsbCh0aGF0KTsgfSkgOiBjb2YodGhhdCkgIT0gTlVNQkVSKVxuICAgICAgICA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKHRvTnVtYmVyKGl0KSksIHRoYXQsICROdW1iZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICBmb3IodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspe1xuICAgIGlmKGhhcyhCYXNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKCROdW1iZXIsIGtleSkpe1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufSIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pOyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAka2V5cyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KXtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pOyIsIi8qISBsb2FkQ1NTLiBbY10yMDE3IEZpbGFtZW50IEdyb3VwLCBJbmMuIE1JVCBMaWNlbnNlICovXG4oZnVuY3Rpb24odyl7XG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiBleHBvcnRlZCBsb2FkQ1NTICovXG5cdHZhciBsb2FkQ1NTID0gZnVuY3Rpb24oIGhyZWYsIGJlZm9yZSwgbWVkaWEgKXtcblx0XHQvLyBBcmd1bWVudHMgZXhwbGFpbmVkOlxuXHRcdC8vIGBocmVmYCBbUkVRVUlSRURdIGlzIHRoZSBVUkwgZm9yIHlvdXIgQ1NTIGZpbGUuXG5cdFx0Ly8gYGJlZm9yZWAgW09QVElPTkFMXSBpcyB0aGUgZWxlbWVudCB0aGUgc2NyaXB0IHNob3VsZCB1c2UgYXMgYSByZWZlcmVuY2UgZm9yIGluamVjdGluZyBvdXIgc3R5bGVzaGVldCA8bGluaz4gYmVmb3JlXG5cdFx0XHQvLyBCeSBkZWZhdWx0LCBsb2FkQ1NTIGF0dGVtcHRzIHRvIGluamVjdCB0aGUgbGluayBhZnRlciB0aGUgbGFzdCBzdHlsZXNoZWV0IG9yIHNjcmlwdCBpbiB0aGUgRE9NLiBIb3dldmVyLCB5b3UgbWlnaHQgZGVzaXJlIGEgbW9yZSBzcGVjaWZpYyBsb2NhdGlvbiBpbiB5b3VyIGRvY3VtZW50LlxuXHRcdC8vIGBtZWRpYWAgW09QVElPTkFMXSBpcyB0aGUgbWVkaWEgdHlwZSBvciBxdWVyeSBvZiB0aGUgc3R5bGVzaGVldC4gQnkgZGVmYXVsdCBpdCB3aWxsIGJlICdhbGwnXG5cdFx0dmFyIGRvYyA9IHcuZG9jdW1lbnQ7XG5cdFx0dmFyIHNzID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwibGlua1wiICk7XG5cdFx0dmFyIHJlZjtcblx0XHRpZiggYmVmb3JlICl7XG5cdFx0XHRyZWYgPSBiZWZvcmU7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIHJlZnMgPSAoIGRvYy5ib2R5IHx8IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJoZWFkXCIgKVsgMCBdICkuY2hpbGROb2Rlcztcblx0XHRcdHJlZiA9IHJlZnNbIHJlZnMubGVuZ3RoIC0gMV07XG5cdFx0fVxuXG5cdFx0dmFyIHNoZWV0cyA9IGRvYy5zdHlsZVNoZWV0cztcblx0XHRzcy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblx0XHRzcy5ocmVmID0gaHJlZjtcblx0XHQvLyB0ZW1wb3JhcmlseSBzZXQgbWVkaWEgdG8gc29tZXRoaW5nIGluYXBwbGljYWJsZSB0byBlbnN1cmUgaXQnbGwgZmV0Y2ggd2l0aG91dCBibG9ja2luZyByZW5kZXJcblx0XHRzcy5tZWRpYSA9IFwib25seSB4XCI7XG5cblx0XHQvLyB3YWl0IHVudGlsIGJvZHkgaXMgZGVmaW5lZCBiZWZvcmUgaW5qZWN0aW5nIGxpbmsuIFRoaXMgZW5zdXJlcyBhIG5vbi1ibG9ja2luZyBsb2FkIGluIElFMTEuXG5cdFx0ZnVuY3Rpb24gcmVhZHkoIGNiICl7XG5cdFx0XHRpZiggZG9jLmJvZHkgKXtcblx0XHRcdFx0cmV0dXJuIGNiKCk7XG5cdFx0XHR9XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJlYWR5KCBjYiApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdC8vIEluamVjdCBsaW5rXG5cdFx0XHQvLyBOb3RlOiB0aGUgdGVybmFyeSBwcmVzZXJ2ZXMgdGhlIGV4aXN0aW5nIGJlaGF2aW9yIG9mIFwiYmVmb3JlXCIgYXJndW1lbnQsIGJ1dCB3ZSBjb3VsZCBjaG9vc2UgdG8gY2hhbmdlIHRoZSBhcmd1bWVudCB0byBcImFmdGVyXCIgaW4gYSBsYXRlciByZWxlYXNlIGFuZCBzdGFuZGFyZGl6ZSBvbiByZWYubmV4dFNpYmxpbmcgZm9yIGFsbCByZWZzXG5cdFx0XHQvLyBOb3RlOiBgaW5zZXJ0QmVmb3JlYCBpcyB1c2VkIGluc3RlYWQgb2YgYGFwcGVuZENoaWxkYCwgZm9yIHNhZmV0eSByZTogaHR0cDovL3d3dy5wYXVsaXJpc2guY29tLzIwMTEvc3VyZWZpcmUtZG9tLWVsZW1lbnQtaW5zZXJ0aW9uL1xuXHRcdHJlYWR5KCBmdW5jdGlvbigpe1xuXHRcdFx0cmVmLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBzcywgKCBiZWZvcmUgPyByZWYgOiByZWYubmV4dFNpYmxpbmcgKSApO1xuXHRcdH0pO1xuXHRcdC8vIEEgbWV0aG9kIChleHBvc2VkIG9uIHJldHVybiBvYmplY3QgZm9yIGV4dGVybmFsIHVzZSkgdGhhdCBtaW1pY3Mgb25sb2FkIGJ5IHBvbGxpbmcgZG9jdW1lbnQuc3R5bGVTaGVldHMgdW50aWwgaXQgaW5jbHVkZXMgdGhlIG5ldyBzaGVldC5cblx0XHR2YXIgb25sb2FkY3NzZGVmaW5lZCA9IGZ1bmN0aW9uKCBjYiApe1xuXHRcdFx0dmFyIHJlc29sdmVkSHJlZiA9IHNzLmhyZWY7XG5cdFx0XHR2YXIgaSA9IHNoZWV0cy5sZW5ndGg7XG5cdFx0XHR3aGlsZSggaS0tICl7XG5cdFx0XHRcdGlmKCBzaGVldHNbIGkgXS5ocmVmID09PSByZXNvbHZlZEhyZWYgKXtcblx0XHRcdFx0XHRyZXR1cm4gY2IoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0b25sb2FkY3NzZGVmaW5lZCggY2IgKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBsb2FkQ0IoKXtcblx0XHRcdGlmKCBzcy5hZGRFdmVudExpc3RlbmVyICl7XG5cdFx0XHRcdHNzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBsb2FkQ0IgKTtcblx0XHRcdH1cblx0XHRcdHNzLm1lZGlhID0gbWVkaWEgfHwgXCJhbGxcIjtcblx0XHR9XG5cblx0XHQvLyBvbmNlIGxvYWRlZCwgc2V0IGxpbmsncyBtZWRpYSBiYWNrIHRvIGBhbGxgIHNvIHRoYXQgdGhlIHN0eWxlc2hlZXQgYXBwbGllcyBvbmNlIGl0IGxvYWRzXG5cdFx0aWYoIHNzLmFkZEV2ZW50TGlzdGVuZXIgKXtcblx0XHRcdHNzLmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBsb2FkQ0IpO1xuXHRcdH1cblx0XHRzcy5vbmxvYWRjc3NkZWZpbmVkID0gb25sb2FkY3NzZGVmaW5lZDtcblx0XHRvbmxvYWRjc3NkZWZpbmVkKCBsb2FkQ0IgKTtcblx0XHRyZXR1cm4gc3M7XG5cdH07XG5cdC8vIGNvbW1vbmpzXG5cdGlmKCB0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIiApe1xuXHRcdGV4cG9ydHMubG9hZENTUyA9IGxvYWRDU1M7XG5cdH1cblx0ZWxzZSB7XG5cdFx0dy5sb2FkQ1NTID0gbG9hZENTUztcblx0fVxufSggdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHRoaXMgKSk7XG4iLCIvKiBlc2xpbnQgbm8tY29uc29sZTowICovXG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIEthVGVYLiBIZXJlLCB3ZSBleHBvc2UgZnVuY3Rpb25zIGZvclxuICogcmVuZGVyaW5nIGV4cHJlc3Npb25zIGVpdGhlciB0byBET00gbm9kZXMgb3IgdG8gbWFya3VwIHN0cmluZ3MuXG4gKlxuICogV2UgYWxzbyBleHBvc2UgdGhlIFBhcnNlRXJyb3IgY2xhc3MgdG8gY2hlY2sgaWYgZXJyb3JzIHRocm93biBmcm9tIEthVGVYIGFyZVxuICogZXJyb3JzIGluIHRoZSBleHByZXNzaW9uLCBvciBlcnJvcnMgaW4gamF2YXNjcmlwdCBoYW5kbGluZy5cbiAqL1xuXG52YXIgUGFyc2VFcnJvciA9IHJlcXVpcmUoXCIuL3NyYy9QYXJzZUVycm9yXCIpO1xudmFyIFNldHRpbmdzID0gcmVxdWlyZShcIi4vc3JjL1NldHRpbmdzXCIpO1xuXG52YXIgYnVpbGRUcmVlID0gcmVxdWlyZShcIi4vc3JjL2J1aWxkVHJlZVwiKTtcbnZhciBwYXJzZVRyZWUgPSByZXF1aXJlKFwiLi9zcmMvcGFyc2VUcmVlXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vc3JjL3V0aWxzXCIpO1xuXG4vKipcbiAqIFBhcnNlIGFuZCBidWlsZCBhbiBleHByZXNzaW9uLCBhbmQgcGxhY2UgdGhhdCBleHByZXNzaW9uIGluIHRoZSBET00gbm9kZVxuICogZ2l2ZW4uXG4gKi9cbnZhciByZW5kZXIgPSBmdW5jdGlvbihleHByZXNzaW9uLCBiYXNlTm9kZSwgb3B0aW9ucykge1xuICAgIHV0aWxzLmNsZWFyTm9kZShiYXNlTm9kZSk7XG5cbiAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3Mob3B0aW9ucyk7XG5cbiAgICB2YXIgdHJlZSA9IHBhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gICAgdmFyIG5vZGUgPSBidWlsZFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpLnRvTm9kZSgpO1xuXG4gICAgYmFzZU5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG59O1xuXG4vLyBLYVRlWCdzIHN0eWxlcyBkb24ndCB3b3JrIHByb3Blcmx5IGluIHF1aXJrcyBtb2RlLiBQcmludCBvdXQgYW4gZXJyb3IsIGFuZFxuLy8gZGlzYWJsZSByZW5kZXJpbmcuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKGRvY3VtZW50LmNvbXBhdE1vZGUgIT09IFwiQ1NTMUNvbXBhdFwiKSB7XG4gICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiV2FybmluZzogS2FUZVggZG9lc24ndCB3b3JrIGluIHF1aXJrcyBtb2RlLiBNYWtlIHN1cmUgeW91ciBcIiArXG4gICAgICAgICAgICAgICAgXCJ3ZWJzaXRlIGhhcyBhIHN1aXRhYmxlIGRvY3R5cGUuXCIpO1xuXG4gICAgICAgIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJLYVRlWCBkb2Vzbid0IHdvcmsgaW4gcXVpcmtzIG1vZGUuXCIpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbmQgYnVpbGQgYW4gZXhwcmVzc2lvbiwgYW5kIHJldHVybiB0aGUgbWFya3VwIGZvciB0aGF0LlxuICovXG52YXIgcmVuZGVyVG9TdHJpbmcgPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpO1xuXG4gICAgdmFyIHRyZWUgPSBwYXJzZVRyZWUoZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICAgIHJldHVybiBidWlsZFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpLnRvTWFya3VwKCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gYW5kIHJldHVybiB0aGUgcGFyc2UgdHJlZS5cbiAqL1xudmFyIGdlbmVyYXRlUGFyc2VUcmVlID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhvcHRpb25zKTtcbiAgICByZXR1cm4gcGFyc2VUcmVlKGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlbmRlcjogcmVuZGVyLFxuICAgIHJlbmRlclRvU3RyaW5nOiByZW5kZXJUb1N0cmluZyxcbiAgICAvKipcbiAgICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgICAqIFRoZSBpbnRlcm5hbCB0cmVlIHJlcHJlc2VudGF0aW9uIGlzIHVuc3RhYmxlIGFuZCBpcyB2ZXJ5IGxpa2VseVxuICAgICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAgICovXG4gICAgX19wYXJzZTogZ2VuZXJhdGVQYXJzZVRyZWUsXG4gICAgUGFyc2VFcnJvcjogUGFyc2VFcnJvclxufTtcbiIsIi8qKlxuICogVGhlIExleGVyIGNsYXNzIGhhbmRsZXMgdG9rZW5pemluZyB0aGUgaW5wdXQgaW4gdmFyaW91cyB3YXlzLiBTaW5jZSBvdXJcbiAqIHBhcnNlciBleHBlY3RzIHVzIHRvIGJlIGFibGUgdG8gYmFja3RyYWNrLCB0aGUgbGV4ZXIgYWxsb3dzIGxleGluZyBmcm9tIGFueVxuICogZ2l2ZW4gc3RhcnRpbmcgcG9pbnQuXG4gKlxuICogSXRzIG1haW4gZXhwb3NlZCBmdW5jdGlvbiBpcyB0aGUgYGxleGAgZnVuY3Rpb24sIHdoaWNoIHRha2VzIGEgcG9zaXRpb24gdG9cbiAqIGxleCBmcm9tIGFuZCBhIHR5cGUgb2YgdG9rZW4gdG8gbGV4LiBJdCBkZWZlcnMgdG8gdGhlIGFwcHJvcHJpYXRlIGBfaW5uZXJMZXhgXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgdmFyaW91cyBgX2lubmVyTGV4YCBmdW5jdGlvbnMgcGVyZm9ybSB0aGUgYWN0dWFsIGxleGluZyBvZiBkaWZmZXJlbnRcbiAqIGtpbmRzLlxuICovXG5cbnZhciBtYXRjaEF0ID0gcmVxdWlyZShcIm1hdGNoLWF0XCIpO1xuXG52YXIgUGFyc2VFcnJvciA9IHJlcXVpcmUoXCIuL1BhcnNlRXJyb3JcIik7XG5cbi8vIFRoZSBtYWluIGxleGVyIGNsYXNzXG5mdW5jdGlvbiBMZXhlcihpbnB1dCkge1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLnBvcyA9IDA7XG59XG5cbi8qKlxuICogVGhlIHJlc3VsdGluZyB0b2tlbiByZXR1cm5lZCBmcm9tIGBsZXhgLlxuICpcbiAqIEl0IGNvbnNpc3RzIG9mIHRoZSB0b2tlbiB0ZXh0IHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqIFRoZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpcyBlc3NlbnRpYWxseSBhIHJhbmdlIGluIGFuIGlucHV0IHN0cmluZyxcbiAqIGJ1dCBpbnN0ZWFkIG9mIHJlZmVyZW5jaW5nIHRoZSBiYXJlIGlucHV0IHN0cmluZywgd2UgcmVmZXIgdG8gdGhlIGxleGVyLlxuICogVGhhdCB3YXkgaXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGV4dHJhIG1ldGFkYXRhIHRvIHRoZSBpbnB1dCBzdHJpbmcsXG4gKiBsaWtlIGZvciBleGFtcGxlIGEgZmlsZSBuYW1lIG9yIHNpbWlsYXIuXG4gKlxuICogVGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIChhbGwgdGhyZWUgcGFyYW1ldGVycykgaXMgb3B0aW9uYWwsXG4gKiBzbyBpdCBpcyBPSyB0byBjb25zdHJ1Y3Qgc3ludGhldGljIHRva2VucyBpZiBhcHByb3ByaWF0ZS5cbiAqIE5vdCBwcm92aWRpbmcgYXZhaWxhYmxlIHBvc2l0aW9uIGluZm9ybWF0aW9uIG1heSBsZWFkIHRvXG4gKiBkZWdyYWRlZCBlcnJvciByZXBvcnRpbmcsIHRob3VnaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gIHRleHQgICB0aGUgdGV4dCBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0ge251bWJlcj19IHN0YXJ0ICB0aGUgc3RhcnQgb2Zmc2V0LCB6ZXJvLWJhc2VkIGluY2x1c2l2ZVxuICogQHBhcmFtIHtudW1iZXI9fSBlbmQgICAgdGhlIGVuZCBvZmZzZXQsIHplcm8tYmFzZWQgZXhjbHVzaXZlXG4gKiBAcGFyYW0ge0xleGVyPX0gIGxleGVyICB0aGUgbGV4ZXIgd2hpY2ggaW4gdHVybiBob2xkcyB0aGUgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIFRva2VuKHRleHQsIHN0YXJ0LCBlbmQsIGxleGVyKSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgdGhpcy5sZXhlciA9IGxleGVyO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgcGFpciBvZiB0b2tlbnMgKHRoaXMgYW5kIGVuZFRva2VuKSwgY29tcHV0ZSBhIOKAnFRva2Vu4oCdIGVuY29tcGFzc2luZ1xuICogdGhlIHdob2xlIGlucHV0IHJhbmdlIGVuY2xvc2VkIGJ5IHRoZXNlIHR3by5cbiAqXG4gKiBAcGFyYW0ge1Rva2VufSAgZW5kVG9rZW4gIGxhc3QgdG9rZW4gb2YgdGhlIHJhbmdlLCBpbmNsdXNpdmVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICAgICAgdGhlIHRleHQgb2YgdGhlIG5ld2x5IGNvbnN0cnVjdGVkIHRva2VuXG4gKi9cblRva2VuLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uKGVuZFRva2VuLCB0ZXh0KSB7XG4gICAgaWYgKGVuZFRva2VuLmxleGVyICE9PSB0aGlzLmxleGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW4odGV4dCk7IC8vIHNvcnJ5LCBubyBwb3NpdGlvbiBpbmZvcm1hdGlvbiBhdmFpbGFibGVcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUb2tlbih0ZXh0LCB0aGlzLnN0YXJ0LCBlbmRUb2tlbi5lbmQsIHRoaXMubGV4ZXIpO1xufTtcblxuLyogVGhlIGZvbGxvd2luZyB0b2tlblJlZ2V4XG4gKiAtIG1hdGNoZXMgdHlwaWNhbCB3aGl0ZXNwYWNlIChidXQgbm90IE5CU1AgZXRjLikgdXNpbmcgaXRzIGZpcnN0IGdyb3VwXG4gKiAtIGRvZXMgbm90IG1hdGNoIGFueSBjb250cm9sIGNoYXJhY3RlciBcXHgwMC1cXHgxZiBleGNlcHQgd2hpdGVzcGFjZVxuICogLSBkb2VzIG5vdCBtYXRjaCBhIGJhcmUgYmFja3NsYXNoXG4gKiAtIG1hdGNoZXMgYW55IEFTQ0lJIGNoYXJhY3RlciBleGNlcHQgdGhvc2UganVzdCBtZW50aW9uZWRcbiAqIC0gZG9lcyBub3QgbWF0Y2ggdGhlIEJNUCBwcml2YXRlIHVzZSBhcmVhIFxcdUUwMDAtXFx1RjhGRlxuICogLSBkb2VzIG5vdCBtYXRjaCBiYXJlIHN1cnJvZ2F0ZSBjb2RlIHVuaXRzXG4gKiAtIG1hdGNoZXMgYW55IEJNUCBjaGFyYWN0ZXIgZXhjZXB0IGZvciB0aG9zZSBqdXN0IGRlc2NyaWJlZFxuICogLSBtYXRjaGVzIGFueSB2YWxpZCBVbmljb2RlIHN1cnJvZ2F0ZSBwYWlyXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgbGV0dGVyc1xuICogLSBtYXRjaGVzIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IGFueSBCTVAgY2hhcmFjdGVyLCBpbmNsdWRpbmcgbmV3bGluZVxuICogSnVzdCBiZWNhdXNlIHRoZSBMZXhlciBtYXRjaGVzIHNvbWV0aGluZyBkb2Vzbid0IG1lYW4gaXQncyB2YWxpZCBpbnB1dDpcbiAqIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIGZ1bmN0aW9uIG9yIHN5bWJvbCBkZWZpbml0aW9uLCB0aGUgUGFyc2VyIHdpbGxcbiAqIHN0aWxsIHJlamVjdCB0aGUgaW5wdXQuXG4gKi9cbnZhciB0b2tlblJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICBcIihbIFxcclxcblxcdF0rKXxcIiArICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpdGVzcGFjZVxuICAgIFwiKFshLVxcXFxbXFxcXF0tXFx1MjAyN1xcdTIwMkEtXFx1RDdGRlxcdUY5MDAtXFx1RkZGRl1cIiArICAvLyBzaW5nbGUgY29kZXBvaW50XG4gICAgXCJ8W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXVwiICsgICAgICAgICAgICAgICAvLyBzdXJyb2dhdGUgcGFpclxuICAgIFwifFxcXFxcXFxcKD86W2EtekEtWl0rfFteXFx1RDgwMC1cXHVERkZGXSlcIiArICAgICAgICAgICAvLyBmdW5jdGlvbiBuYW1lXG4gICAgXCIpXCJcbik7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBsZXhlcyBhIHNpbmdsZSB0b2tlbi5cbiAqL1xuTGV4ZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICAgIGlmIChwb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuKFwiRU9GXCIsIHBvcywgcG9zLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gbWF0Y2hBdCh0b2tlblJlZ2V4LCBpbnB1dCwgcG9zKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAnXCIgKyBpbnB1dFtwb3NdICsgXCInXCIsXG4gICAgICAgICAgICBuZXcgVG9rZW4oaW5wdXRbcG9zXSwgcG9zLCBwb3MgKyAxLCB0aGlzKSk7XG4gICAgfVxuICAgIHZhciB0ZXh0ID0gbWF0Y2hbMl0gfHwgXCIgXCI7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIHZhciBlbmQgPSB0aGlzLnBvcztcbiAgICByZXR1cm4gbmV3IFRva2VuKHRleHQsIHN0YXJ0LCBlbmQsIHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZXhlcjtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSDigJxndWxsZXTigJ0gd2hlcmUgbWFjcm9zIGFyZSBleHBhbmRlZFxuICogdW50aWwgb25seSBub24tbWFjcm8gdG9rZW5zIHJlbWFpbi5cbiAqL1xuXG52YXIgTGV4ZXIgPSByZXF1aXJlKFwiLi9MZXhlclwiKTtcblxuZnVuY3Rpb24gTWFjcm9FeHBhbmRlcihpbnB1dCwgbWFjcm9zKSB7XG4gICAgdGhpcy5sZXhlciA9IG5ldyBMZXhlcihpbnB1dCk7XG4gICAgdGhpcy5tYWNyb3MgPSBtYWNyb3M7XG4gICAgdGhpcy5zdGFjayA9IFtdOyAvLyBjb250YWlucyB0b2tlbnMgaW4gUkVWRVJTRSBvcmRlclxuICAgIHRoaXMuZGlzY2FyZGVkV2hpdGVTcGFjZSA9IFtdO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGV4cGFuZCBmaXJzdCB0b2tlbiwgdGhlbiByZXR1cm4gZmlyc3Qgbm9uLWV4cGFuZGFibGUgdG9rZW4uXG4gKi9cbk1hY3JvRXhwYW5kZXIucHJvdG90eXBlLm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5sZXhlci5sZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvcFRva2VuID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0b3BUb2tlbi50ZXh0O1xuICAgICAgICBpZiAoIShuYW1lLmNoYXJBdCgwKSA9PT0gXCJcXFxcXCIgJiYgdGhpcy5tYWNyb3MuaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9wVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IHRoaXMubWFjcm9zW25hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIGV4cGFuc2lvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGJvZHlMZXhlciA9IG5ldyBMZXhlcihleHBhbnNpb24pO1xuICAgICAgICAgICAgZXhwYW5zaW9uID0gW107XG4gICAgICAgICAgICB2YXIgdG9rID0gYm9keUxleGVyLmxleCgpO1xuICAgICAgICAgICAgd2hpbGUgKHRvay50ZXh0ICE9PSBcIkVPRlwiKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5zaW9uLnB1c2godG9rKTtcbiAgICAgICAgICAgICAgICB0b2sgPSBib2R5TGV4ZXIubGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBhbnNpb24ucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayB1c2luZyBwdXNoIGFuZCBwb3BcbiAgICAgICAgICAgIHRoaXMubWFjcm9zW25hbWVdID0gZXhwYW5zaW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLmNvbmNhdChleHBhbnNpb24pO1xuICAgIH1cbn07XG5cbk1hY3JvRXhwYW5kZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGlnbm9yZVNwYWNlKSB7XG4gICAgdGhpcy5kaXNjYXJkZWRXaGl0ZVNwYWNlID0gW107XG4gICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICBpZiAoaWdub3JlU3BhY2UpIHtcbiAgICAgICAgd2hpbGUgKHRva2VuLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2NhcmRlZFdoaXRlU3BhY2UucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2VuO1xufTtcblxuLyoqXG4gKiBVbmRvIHRoZSBlZmZlY3Qgb2YgdGhlIHByZWNlZGluZyBjYWxsIHRvIHRoZSBnZXQgbWV0aG9kLlxuICogQSBjYWxsIHRvIHRoaXMgbWV0aG9kIE1VU1QgYmUgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYW5kIGltbWVkaWF0ZWx5IGZvbGxvd2VkXG4gKiBieSBhIGNhbGwgdG8gZ2V0LiAgT25seSB1c2VkIGR1cmluZyBtb2RlIHN3aXRjaGluZywgaS5lLiBhZnRlciBvbmUgdG9rZW5cbiAqIHdhcyBnb3QgaW4gdGhlIG9sZCBtb2RlIGJ1dCBzaG91bGQgZ2V0IGdvdCBhZ2FpbiBpbiBhIG5ldyBtb2RlXG4gKiB3aXRoIHBvc3NpYmx5IGRpZmZlcmVudCB3aGl0ZXNwYWNlIGhhbmRsaW5nLlxuICovXG5NYWNyb0V4cGFuZGVyLnByb3RvdHlwZS51bmdldCA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHRva2VuKTtcbiAgICB3aGlsZSAodGhpcy5kaXNjYXJkZWRXaGl0ZVNwYWNlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5kaXNjYXJkZWRXaGl0ZVNwYWNlLnBvcCgpKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hY3JvRXhwYW5kZXI7XG4iLCIvKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3B0aW9ucyB0aGF0IHRoZSBQYXJzZXIgY2Fycmllc1xuICogYXJvdW5kIHdpdGggaXQgd2hpbGUgcGFyc2luZy4gRGF0YSBpcyBoZWxkIGluIGFuIGBPcHRpb25zYCBvYmplY3QsIGFuZCB3aGVuXG4gKiByZWN1cnNpbmcsIGEgbmV3IGBPcHRpb25zYCBvYmplY3QgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGUgYC53aXRoKmAgYW5kXG4gKiBgLnJlc2V0YCBmdW5jdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIG9wdGlvbnMgY2xhc3MuIEl0IGNvbnRhaW5zIHRoZSBzdHlsZSwgc2l6ZSwgY29sb3IsIGFuZCBmb250XG4gKiBvZiB0aGUgY3VycmVudCBwYXJzZSBsZXZlbC4gSXQgYWxzbyBjb250YWlucyB0aGUgc3R5bGUgYW5kIHNpemUgb2YgdGhlIHBhcmVudFxuICogcGFyc2UgbGV2ZWwsIHNvIHNpemUgY2hhbmdlcyBjYW4gYmUgaGFuZGxlZCBlZmZpY2llbnRseS5cbiAqXG4gKiBFYWNoIG9mIHRoZSBgLndpdGgqYCBhbmQgYC5yZXNldGAgZnVuY3Rpb25zIHBhc3NlcyBpdHMgY3VycmVudCBzdHlsZSBhbmQgc2l6ZVxuICogYXMgdGhlIHBhcmVudFN0eWxlIGFuZCBwYXJlbnRTaXplIG9mIHRoZSBuZXcgb3B0aW9ucyBjbGFzcywgc28gcGFyZW50XG4gKiBoYW5kbGluZyBpcyB0YWtlbiBjYXJlIG9mIGF1dG9tYXRpY2FsbHkuXG4gKi9cbmZ1bmN0aW9uIE9wdGlvbnMoZGF0YSkge1xuICAgIHRoaXMuc3R5bGUgPSBkYXRhLnN0eWxlO1xuICAgIHRoaXMuY29sb3IgPSBkYXRhLmNvbG9yO1xuICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB0aGlzLnBoYW50b20gPSBkYXRhLnBoYW50b207XG4gICAgdGhpcy5mb250ID0gZGF0YS5mb250O1xuXG4gICAgaWYgKGRhdGEucGFyZW50U3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBhcmVudFN0eWxlID0gZGF0YS5zdHlsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudFN0eWxlID0gZGF0YS5wYXJlbnRTdHlsZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5wYXJlbnRTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRTaXplID0gZGF0YS5zaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50U2l6ZSA9IGRhdGEucGFyZW50U2l6ZTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgXCJ0aGlzXCIuICBQcm9wZXJ0aWVzXG4gKiBmcm9tIFwiZXh0ZW5zaW9uXCIgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBvcHRpb25zIG9iamVjdC5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24oZXh0ZW5zaW9uKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLFxuICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBwYXJlbnRTdHlsZTogdGhpcy5zdHlsZSxcbiAgICAgICAgcGFyZW50U2l6ZTogdGhpcy5zaXplLFxuICAgICAgICBwaGFudG9tOiB0aGlzLnBoYW50b20sXG4gICAgICAgIGZvbnQ6IHRoaXMuZm9udFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZXh0ZW5zaW9uKSB7XG4gICAgICAgIGlmIChleHRlbnNpb24uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgZGF0YVtrZXldID0gZXh0ZW5zaW9uW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE9wdGlvbnMoZGF0YSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBzdHlsZS5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUud2l0aFN0eWxlID0gZnVuY3Rpb24oc3R5bGUpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBzdHlsZTogc3R5bGVcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIHNpemUuXG4gKi9cbk9wdGlvbnMucHJvdG90eXBlLndpdGhTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIHNpemU6IHNpemVcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvbG9yLlxuICovXG5PcHRpb25zLnByb3RvdHlwZS53aXRoQ29sb3IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIGNvbG9yOiBjb2xvclxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCBcInBoYW50b21cIiBzZXQgdG8gdHJ1ZS5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUud2l0aFBoYW50b20gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBwaGFudG9tOiB0cnVlXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdHMgd2l0aCB0aGUgZ2l2ZSBmb250LlxuICovXG5PcHRpb25zLnByb3RvdHlwZS53aXRoRm9udCA9IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBmb250OiBmb250IHx8IHRoaXMuZm9udFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzdHlsZSwgc2l6ZSwgYW5kIGNvbG9yLiBUaGlzIGlzXG4gKiB1c2VkIHNvIHRoYXQgcGFyZW50IHN0eWxlIGFuZCBzaXplIGNoYW5nZXMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICovXG5PcHRpb25zLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7fSk7XG59O1xuXG4vKipcbiAqIEEgbWFwIG9mIGNvbG9yIG5hbWVzIHRvIENTUyBjb2xvcnMuXG4gKiBUT0RPKGVtaWx5KTogUmVtb3ZlIHRoaXMgd2hlbiB3ZSBoYXZlIHJlYWwgbWFjcm9zXG4gKi9cbnZhciBjb2xvck1hcCA9IHtcbiAgICBcImthdGV4LWJsdWVcIjogXCIjNjQ5NWVkXCIsXG4gICAgXCJrYXRleC1vcmFuZ2VcIjogXCIjZmZhNTAwXCIsXG4gICAgXCJrYXRleC1waW5rXCI6IFwiI2ZmMDBhZlwiLFxuICAgIFwia2F0ZXgtcmVkXCI6IFwiI2RmMDAzMFwiLFxuICAgIFwia2F0ZXgtZ3JlZW5cIjogXCIjMjhhZTdiXCIsXG4gICAgXCJrYXRleC1ncmF5XCI6IFwiZ3JheVwiLFxuICAgIFwia2F0ZXgtcHVycGxlXCI6IFwiIzlkMzhiZFwiLFxuICAgIFwia2F0ZXgtYmx1ZUFcIjogXCIjY2NmYWZmXCIsXG4gICAgXCJrYXRleC1ibHVlQlwiOiBcIiM4MGY2ZmZcIixcbiAgICBcImthdGV4LWJsdWVDXCI6IFwiIzYzZDllYVwiLFxuICAgIFwia2F0ZXgtYmx1ZURcIjogXCIjMTFhY2NkXCIsXG4gICAgXCJrYXRleC1ibHVlRVwiOiBcIiMwYzdmOTlcIixcbiAgICBcImthdGV4LXRlYWxBXCI6IFwiIzk0ZmZmNVwiLFxuICAgIFwia2F0ZXgtdGVhbEJcIjogXCIjMjZlZGQ1XCIsXG4gICAgXCJrYXRleC10ZWFsQ1wiOiBcIiMwMWQxYzFcIixcbiAgICBcImthdGV4LXRlYWxEXCI6IFwiIzAxYTk5NVwiLFxuICAgIFwia2F0ZXgtdGVhbEVcIjogXCIjMjA4MTcwXCIsXG4gICAgXCJrYXRleC1ncmVlbkFcIjogXCIjYjZmZmIwXCIsXG4gICAgXCJrYXRleC1ncmVlbkJcIjogXCIjOGFmMjgxXCIsXG4gICAgXCJrYXRleC1ncmVlbkNcIjogXCIjNzRjZjcwXCIsXG4gICAgXCJrYXRleC1ncmVlbkRcIjogXCIjMWZhYjU0XCIsXG4gICAgXCJrYXRleC1ncmVlbkVcIjogXCIjMGQ5MjNmXCIsXG4gICAgXCJrYXRleC1nb2xkQVwiOiBcIiNmZmQwYTlcIixcbiAgICBcImthdGV4LWdvbGRCXCI6IFwiI2ZmYmI3MVwiLFxuICAgIFwia2F0ZXgtZ29sZENcIjogXCIjZmY5YzM5XCIsXG4gICAgXCJrYXRleC1nb2xkRFwiOiBcIiNlMDdkMTBcIixcbiAgICBcImthdGV4LWdvbGRFXCI6IFwiI2E3NWEwNVwiLFxuICAgIFwia2F0ZXgtcmVkQVwiOiBcIiNmY2E5YTlcIixcbiAgICBcImthdGV4LXJlZEJcIjogXCIjZmY4NDgyXCIsXG4gICAgXCJrYXRleC1yZWRDXCI6IFwiI2Y5Njg1ZFwiLFxuICAgIFwia2F0ZXgtcmVkRFwiOiBcIiNlODRkMzlcIixcbiAgICBcImthdGV4LXJlZEVcIjogXCIjYmMyNjEyXCIsXG4gICAgXCJrYXRleC1tYXJvb25BXCI6IFwiI2ZmYmRlMFwiLFxuICAgIFwia2F0ZXgtbWFyb29uQlwiOiBcIiNmZjkyYzZcIixcbiAgICBcImthdGV4LW1hcm9vbkNcIjogXCIjZWQ1ZmE2XCIsXG4gICAgXCJrYXRleC1tYXJvb25EXCI6IFwiI2NhMzM3Y1wiLFxuICAgIFwia2F0ZXgtbWFyb29uRVwiOiBcIiM5ZTAzNGVcIixcbiAgICBcImthdGV4LXB1cnBsZUFcIjogXCIjZGRkN2ZmXCIsXG4gICAgXCJrYXRleC1wdXJwbGVCXCI6IFwiI2M2YjlmY1wiLFxuICAgIFwia2F0ZXgtcHVycGxlQ1wiOiBcIiNhYTg3ZmZcIixcbiAgICBcImthdGV4LXB1cnBsZURcIjogXCIjNzg1NGFiXCIsXG4gICAgXCJrYXRleC1wdXJwbGVFXCI6IFwiIzU0M2I3OFwiLFxuICAgIFwia2F0ZXgtbWludEFcIjogXCIjZjVmOWU4XCIsXG4gICAgXCJrYXRleC1taW50QlwiOiBcIiNlZGYyZGZcIixcbiAgICBcImthdGV4LW1pbnRDXCI6IFwiI2UwZTVjY1wiLFxuICAgIFwia2F0ZXgtZ3JheUFcIjogXCIjZjZmN2Y3XCIsXG4gICAgXCJrYXRleC1ncmF5QlwiOiBcIiNmMGYxZjJcIixcbiAgICBcImthdGV4LWdyYXlDXCI6IFwiI2UzZTVlNlwiLFxuICAgIFwia2F0ZXgtZ3JheURcIjogXCIjZDZkOGRhXCIsXG4gICAgXCJrYXRleC1ncmF5RVwiOiBcIiNiYWJlYzJcIixcbiAgICBcImthdGV4LWdyYXlGXCI6IFwiIzg4OGQ5M1wiLFxuICAgIFwia2F0ZXgtZ3JheUdcIjogXCIjNjI2NTY5XCIsXG4gICAgXCJrYXRleC1ncmF5SFwiOiBcIiMzYjNlNDBcIixcbiAgICBcImthdGV4LWdyYXlJXCI6IFwiIzIxMjQyY1wiLFxuICAgIFwia2F0ZXgta2FCbHVlXCI6IFwiIzMxNDQ1M1wiLFxuICAgIFwia2F0ZXgta2FHcmVlblwiOiBcIiM3MUIzMDdcIlxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBDU1MgY29sb3Igb2YgdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QsIGFjY291bnRpbmcgZm9yIHRoZVxuICogYGNvbG9yTWFwYC5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5waGFudG9tKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zcGFyZW50XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yTWFwW3RoaXMuY29sb3JdIHx8IHRoaXMuY29sb3I7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcHRpb25zO1xuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSBQYXJzZUVycm9yIGNsYXNzLCB3aGljaCBpcyB0aGUgbWFpbiBlcnJvciB0aHJvd24gYnkgS2FUZVhcbiAqIGZ1bmN0aW9ucyB3aGVuIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZy4gVGhpcyBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGludGVybmFsXG4gKiBlcnJvcnMgZnJvbSBlcnJvcnMgaW4gdGhlIGV4cHJlc3Npb24gdGhhdCB0aGUgdXNlciBwcm92aWRlZC5cbiAqXG4gKiBJZiBwb3NzaWJsZSwgYSBjYWxsZXIgc2hvdWxkIHByb3ZpZGUgYSBUb2tlbiBvciBQYXJzZU5vZGUgd2l0aCBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hlcmUgaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlIHByb2JsZW0gb2NjdXJyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0geyhUb2tlbnxQYXJzZU5vZGUpPX0gdG9rZW4gIEFuIG9iamVjdCBwcm92aWRpbmcgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAqL1xuZnVuY3Rpb24gUGFyc2VFcnJvcihtZXNzYWdlLCB0b2tlbikge1xuICAgIHZhciBlcnJvciA9IFwiS2FUZVggcGFyc2UgZXJyb3I6IFwiICsgbWVzc2FnZTtcbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIGVuZDtcblxuICAgIGlmICh0b2tlbiAmJiB0b2tlbi5sZXhlciAmJiB0b2tlbi5zdGFydCA8PSB0b2tlbi5lbmQpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSB0aGUgaW5wdXQgYW5kIGEgcG9zaXRpb24sIG1ha2UgdGhlIGVycm9yIGEgYml0IGZhbmNpZXJcblxuICAgICAgICAvLyBHZXQgdGhlIGlucHV0XG4gICAgICAgIHZhciBpbnB1dCA9IHRva2VuLmxleGVyLmlucHV0O1xuXG4gICAgICAgIC8vIFByZXBlbmQgc29tZSBpbmZvcm1hdGlvblxuICAgICAgICBzdGFydCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICBlbmQgPSB0b2tlbi5lbmQ7XG4gICAgICAgIGlmIChzdGFydCA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBlcnJvciArPSBcIiBhdCBlbmQgb2YgaW5wdXQ6IFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgKz0gXCIgYXQgcG9zaXRpb24gXCIgKyAoc3RhcnQgKyAxKSArIFwiOiBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuZGVybGluZSB0b2tlbiBpbiBxdWVzdGlvbiB1c2luZyBjb21iaW5pbmcgdW5kZXJzY29yZXNcbiAgICAgICAgdmFyIHVuZGVybGluZWQgPSBpbnB1dC5zbGljZShzdGFydCwgZW5kKS5yZXBsYWNlKC9bXl0vZywgXCIkJlxcdTAzMzJcIik7XG5cbiAgICAgICAgLy8gRXh0cmFjdCBzb21lIGNvbnRleHQgZnJvbSB0aGUgaW5wdXQgYW5kIGFkZCBpdCB0byB0aGUgZXJyb3JcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIGlmIChzdGFydCA+IDE1KSB7XG4gICAgICAgICAgICBsZWZ0ID0gXCLigKZcIiArIGlucHV0LnNsaWNlKHN0YXJ0IC0gMTUsIHN0YXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBpbnB1dC5zbGljZSgwLCBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJpZ2h0O1xuICAgICAgICBpZiAoZW5kICsgMTUgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gaW5wdXQuc2xpY2UoZW5kLCBlbmQgKyAxNSkgKyBcIuKAplwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmlnaHQgPSBpbnB1dC5zbGljZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yICs9IGxlZnQgKyB1bmRlcmxpbmVkICsgcmlnaHQ7XG4gICAgfVxuXG4gICAgLy8gU29tZSBoYWNrZXJ5IHRvIG1ha2UgUGFyc2VFcnJvciBhIHByb3RvdHlwZSBvZiBFcnJvclxuICAgIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84NDYwNzUzXG4gICAgdmFyIHNlbGYgPSBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIHNlbGYubmFtZSA9IFwiUGFyc2VFcnJvclwiO1xuICAgIHNlbGYuX19wcm90b19fID0gUGFyc2VFcnJvci5wcm90b3R5cGU7XG5cbiAgICBzZWxmLnBvc2l0aW9uID0gc3RhcnQ7XG4gICAgcmV0dXJuIHNlbGY7XG59XG5cbi8vIE1vcmUgaGFja2VyeVxuUGFyc2VFcnJvci5wcm90b3R5cGUuX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlRXJyb3I7XG4iLCIvKiBlc2xpbnQgbm8tY29uc3RhbnQtY29uZGl0aW9uOjAgKi9cbnZhciBmdW5jdGlvbnMgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnNcIik7XG52YXIgZW52aXJvbm1lbnRzID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRzXCIpO1xudmFyIE1hY3JvRXhwYW5kZXIgPSByZXF1aXJlKFwiLi9NYWNyb0V4cGFuZGVyXCIpO1xudmFyIHN5bWJvbHMgPSByZXF1aXJlKFwiLi9zeW1ib2xzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgY2prUmVnZXggPSByZXF1aXJlKFwiLi91bmljb2RlUmVnZXhlc1wiKS5jamtSZWdleDtcblxudmFyIHBhcnNlRGF0YSA9IHJlcXVpcmUoXCIuL3BhcnNlRGF0YVwiKTtcbnZhciBQYXJzZUVycm9yID0gcmVxdWlyZShcIi4vUGFyc2VFcnJvclwiKTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIHBhcnNlciB1c2VkIHRvIHBhcnNlIG91dCBhIFRlWCBleHByZXNzaW9uIGZyb20gdGhlXG4gKiBpbnB1dC4gU2luY2UgVGVYIGlzbid0IGNvbnRleHQtZnJlZSwgc3RhbmRhcmQgcGFyc2VycyBkb24ndCB3b3JrIHBhcnRpY3VsYXJseVxuICogd2VsbC5cbiAqXG4gKiBUaGUgc3RyYXRlZ3kgb2YgdGhpcyBwYXJzZXIgaXMgYXMgc3VjaDpcbiAqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbnMgKHRoZSBgLnBhcnNlLi4uYCBvbmVzKSB0YWtlIGEgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcbiAqIHBhcnNlIHN0cmluZyB0byBwYXJzZSB0b2tlbnMgZnJvbS4gVGhlIGxleGVyIChmb3VuZCBpbiBMZXhlci5qcywgc3RvcmVkIGF0XG4gKiB0aGlzLmxleGVyKSBhbHNvIHN1cHBvcnRzIHB1bGxpbmcgb3V0IHRva2VucyBhdCBhcmJpdHJhcnkgcGxhY2VzLiBXaGVuXG4gKiBpbmRpdmlkdWFsIHRva2VucyBhcmUgbmVlZGVkIGF0IGEgcG9zaXRpb24sIHRoZSBsZXhlciBpcyBjYWxsZWQgdG8gcHVsbCBvdXQgYVxuICogdG9rZW4sIHdoaWNoIGlzIHRoZW4gdXNlZC5cbiAqXG4gKiBUaGUgcGFyc2VyIGhhcyBhIHByb3BlcnR5IGNhbGxlZCBcIm1vZGVcIiBpbmRpY2F0aW5nIHRoZSBtb2RlIHRoYXRcbiAqIHRoZSBwYXJzZXIgaXMgY3VycmVudGx5IGluLiBDdXJyZW50bHkgaXQgaGFzIHRvIGJlIG9uZSBvZiBcIm1hdGhcIiBvclxuICogXCJ0ZXh0XCIsIHdoaWNoIGRlbm90ZXMgd2hldGhlciB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBhIG1hdGgteVxuICogb25lIG9yIGEgdGV4dC15IG9uZSAoZS5nLiBpbnNpZGUgXFx0ZXh0KS4gQ3VycmVudGx5LCB0aGlzIHNlcnZlcyB0b1xuICogbGltaXQgdGhlIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgdXNlZCBpbiB0ZXh0IG1vZGUuXG4gKlxuICogVGhlIG1haW4gZnVuY3Rpb25zIHRoZW4gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgdXNlZnVsIGRhdGEgdGhhdFxuICogd2FzIHBhcnNlZCBhdCBpdHMgZ2l2ZW4gcG9pbnQsIGFuZCBhIG5ldyBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJzZWRcbiAqIGRhdGEuIFRoZSBtYWluIGZ1bmN0aW9ucyBjYW4gY2FsbCBlYWNoIG90aGVyIGFuZCBjb250aW51ZSB0aGUgcGFyc2luZyBieVxuICogdXNpbmcgdGhlIHJldHVybmVkIHBvc2l0aW9uIGFzIGEgbmV3IHN0YXJ0aW5nIHBvaW50LlxuICpcbiAqIFRoZXJlIGFyZSBhbHNvIGV4dHJhIGAuaGFuZGxlLi4uYCBmdW5jdGlvbnMsIHdoaWNoIHB1bGwgb3V0IHNvbWUgcmV1c2VkXG4gKiBmdW5jdGlvbmFsaXR5IGludG8gc2VsZi1jb250YWluZWQgZnVuY3Rpb25zLlxuICpcbiAqIFRoZSBlYXJsaWVyIGZ1bmN0aW9ucyByZXR1cm4gUGFyc2VOb2Rlcy5cbiAqIFRoZSBsYXRlciBmdW5jdGlvbnMgKHdoaWNoIGFyZSBjYWxsZWQgZGVlcGVyIGluIHRoZSBwYXJzZSkgc29tZXRpbWVzIHJldHVyblxuICogUGFyc2VGdW5jT3JBcmd1bWVudCwgd2hpY2ggY29udGFpbiBhIFBhcnNlTm9kZSBhcyB3ZWxsIGFzIHNvbWUgZGF0YSBhYm91dFxuICogd2hldGhlciB0aGUgcGFyc2VkIG9iamVjdCBpcyBhIGZ1bmN0aW9uIHdoaWNoIGlzIG1pc3Npbmcgc29tZSBhcmd1bWVudHMsIG9yIGFcbiAqIHN0YW5kYWxvbmUgb2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIGFzIGFuIGFyZ3VtZW50IHRvIGFub3RoZXIgZnVuY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBNYWluIFBhcnNlciBjbGFzc1xuICovXG5mdW5jdGlvbiBQYXJzZXIoaW5wdXQsIHNldHRpbmdzKSB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IG1hY3JvIGV4cGFuZGVyIChndWxsZXQpIGFuZCAoaW5kaXJlY3RseSB2aWEgdGhhdCkgYWxzbyBhXG4gICAgLy8gbmV3IGxleGVyIChtb3V0aCkgZm9yIHRoaXMgcGFyc2VyIChzdG9tYWNoLCBpbiB0aGUgbGFuZ3VhZ2Ugb2YgVGVYKVxuICAgIHRoaXMuZ3VsbGV0ID0gbmV3IE1hY3JvRXhwYW5kZXIoaW5wdXQsIHNldHRpbmdzLm1hY3Jvcyk7XG4gICAgLy8gU3RvcmUgdGhlIHNldHRpbmdzIGZvciB1c2UgaW4gcGFyc2luZ1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAvLyBDb3VudCBsZWZ0cmlnaHQgZGVwdGggKGZvciBcXG1pZGRsZSBlcnJvcnMpXG4gICAgdGhpcy5sZWZ0cmlnaHREZXB0aCA9IDA7XG59XG5cbnZhciBQYXJzZU5vZGUgPSBwYXJzZURhdGEuUGFyc2VOb2RlO1xuXG4vKipcbiAqIEFuIGluaXRpYWwgZnVuY3Rpb24gKHdpdGhvdXQgaXRzIGFyZ3VtZW50cyksIG9yIGFuIGFyZ3VtZW50IHRvIGEgZnVuY3Rpb24uXG4gKiBUaGUgYHJlc3VsdGAgYXJndW1lbnQgc2hvdWxkIGJlIGEgUGFyc2VOb2RlLlxuICovXG5mdW5jdGlvbiBQYXJzZUZ1bmNPckFyZ3VtZW50KHJlc3VsdCwgaXNGdW5jdGlvbiwgdG9rZW4pIHtcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAvLyBJcyB0aGlzIGEgZnVuY3Rpb24gKGkuZS4gaXMgaXQgc29tZXRoaW5nIGRlZmluZWQgaW4gZnVuY3Rpb25zLmpzKT9cbiAgICB0aGlzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSByZXN1bHQgdG8gbWFrZSBzdXJlIGl0IGhhcyB0aGUgcmlnaHQgdHlwZSwgYW5kIHRocm93cyBhblxuICogYXBwcm9wcmlhdGUgZXJyb3Igb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGNvbnN1bWUgd2hldGhlciB0byBjb25zdW1lIHRoZSBleHBlY3RlZCB0b2tlbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG5QYXJzZXIucHJvdG90eXBlLmV4cGVjdCA9IGZ1bmN0aW9uKHRleHQsIGNvbnN1bWUpIHtcbiAgICBpZiAodGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gdGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgJ1wiICsgdGV4dCArIFwiJywgZ290ICdcIiArIHRoaXMubmV4dFRva2VuLnRleHQgKyBcIidcIixcbiAgICAgICAgICAgIHRoaXMubmV4dFRva2VuXG4gICAgICAgICk7XG4gICAgfVxuICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnNpZGVycyB0aGUgY3VycmVudCBsb29rIGFoZWFkIHRva2VuIGFzIGNvbnN1bWVkLFxuICogYW5kIGZldGNoZXMgdGhlIG9uZSBhZnRlciB0aGF0IGFzIHRoZSBuZXcgbG9vayBhaGVhZC5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5uZXh0VG9rZW4gPSB0aGlzLmd1bGxldC5nZXQodGhpcy5tb2RlID09PSBcIm1hdGhcIik7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnN3aXRjaE1vZGUgPSBmdW5jdGlvbihuZXdNb2RlKSB7XG4gICAgdGhpcy5ndWxsZXQudW5nZXQodGhpcy5uZXh0VG9rZW4pO1xuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgdGhpcy5jb25zdW1lKCk7XG59O1xuXG4vKipcbiAqIE1haW4gcGFyc2luZyBmdW5jdGlvbiwgd2hpY2ggcGFyc2VzIGFuIGVudGlyZSBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHs/QXJyYXkuPFBhcnNlTm9kZT59XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUcnkgdG8gcGFyc2UgdGhlIGlucHV0XG4gICAgdGhpcy5tb2RlID0gXCJtYXRoXCI7XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgdmFyIHBhcnNlID0gdGhpcy5wYXJzZUlucHV0KCk7XG4gICAgcmV0dXJuIHBhcnNlO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYW4gZW50aXJlIGlucHV0IHRyZWUuXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VJbnB1dCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFBhcnNlIGFuIGV4cHJlc3Npb25cbiAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcbiAgICAvLyBJZiB3ZSBzdWNjZWVkZWQsIG1ha2Ugc3VyZSB0aGVyZSdzIGFuIEVPRiBhdCB0aGUgZW5kXG4gICAgdGhpcy5leHBlY3QoXCJFT0ZcIiwgZmFsc2UpO1xuICAgIHJldHVybiBleHByZXNzaW9uO1xufTtcblxudmFyIGVuZE9mRXhwcmVzc2lvbiA9IFtcIn1cIiwgXCJcXFxcZW5kXCIsIFwiXFxcXHJpZ2h0XCIsIFwiJlwiLCBcIlxcXFxcXFxcXCIsIFwiXFxcXGNyXCJdO1xuXG4vKipcbiAqIFBhcnNlcyBhbiBcImV4cHJlc3Npb25cIiwgd2hpY2ggaXMgYSBsaXN0IG9mIGF0b21zLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYnJlYWtPbkluZml4ICBTaG91bGQgdGhlIHBhcnNpbmcgc3RvcCB3aGVuIHdlIGhpdCBpbmZpeFxuICogICAgICAgICAgICAgICAgICBub2Rlcz8gVGhpcyBoYXBwZW5zIHdoZW4gZnVuY3Rpb25zIGhhdmUgaGlnaGVyIHByZWNlbmRlbmNlXG4gKiAgICAgICAgICAgICAgICAgIHRoYW4gaW5maXggbm9kZXMgaW4gaW1wbGljaXQgcGFyc2VzLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gYnJlYWtPblRva2VuVGV4dCAgVGhlIHRleHQgb2YgdGhlIHRva2VuIHRoYXQgdGhlIGV4cHJlc3Npb25cbiAqICAgICAgICAgICAgICAgICAgc2hvdWxkIGVuZCB3aXRoLCBvciBgbnVsbGAgaWYgc29tZXRoaW5nIGVsc2Ugc2hvdWxkIGVuZCB0aGVcbiAqICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcmV0dXJuIHtQYXJzZU5vZGV9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24oYnJlYWtPbkluZml4LCBicmVha09uVG9rZW5UZXh0KSB7XG4gICAgdmFyIGJvZHkgPSBbXTtcbiAgICAvLyBLZWVwIGFkZGluZyBhdG9tcyB0byB0aGUgYm9keSB1bnRpbCB3ZSBjYW4ndCBwYXJzZSBhbnkgbW9yZSBhdG9tcyAoZWl0aGVyXG4gICAgLy8gd2UgcmVhY2hlZCB0aGUgZW5kLCBhIH0sIG9yIGEgXFxyaWdodClcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgbGV4ID0gdGhpcy5uZXh0VG9rZW47XG4gICAgICAgIGlmIChlbmRPZkV4cHJlc3Npb24uaW5kZXhPZihsZXgudGV4dCkgIT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJlYWtPblRva2VuVGV4dCAmJiBsZXgudGV4dCA9PT0gYnJlYWtPblRva2VuVGV4dCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJyZWFrT25JbmZpeCAmJiBmdW5jdGlvbnNbbGV4LnRleHRdICYmIGZ1bmN0aW9uc1tsZXgudGV4dF0uaW5maXgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdG9tID0gdGhpcy5wYXJzZUF0b20oKTtcbiAgICAgICAgaWYgKCFhdG9tKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MudGhyb3dPbkVycm9yICYmIGxleC50ZXh0WzBdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvck5vZGUgPSB0aGlzLmhhbmRsZVVuc3VwcG9ydGVkQ21kKCk7XG4gICAgICAgICAgICAgICAgYm9keS5wdXNoKGVycm9yTm9kZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJvZHkucHVzaChhdG9tKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlSW5maXhOb2Rlcyhib2R5KTtcbn07XG5cbi8qKlxuICogUmV3cml0ZXMgaW5maXggb3BlcmF0b3JzIHN1Y2ggYXMgXFxvdmVyIHdpdGggY29ycmVzcG9uZGluZyBjb21tYW5kcyBzdWNoXG4gKiBhcyBcXGZyYWMuXG4gKlxuICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGluZml4IG9wZXJhdG9yIHBlciBncm91cC4gIElmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZVxuICogdGhlbiB0aGUgZXhwcmVzc2lvbiBpcyBhbWJpZ3VvdXMuICBUaGlzIGNhbiBiZSByZXNvbHZlZCBieSBhZGRpbmcge30uXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICovXG5QYXJzZXIucHJvdG90eXBlLmhhbmRsZUluZml4Tm9kZXMgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgdmFyIG92ZXJJbmRleCA9IC0xO1xuICAgIHZhciBmdW5jTmFtZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGJvZHlbaV07XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiaW5maXhcIikge1xuICAgICAgICAgICAgaWYgKG92ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJvbmx5IG9uZSBpbmZpeCBvcGVyYXRvciBwZXIgZ3JvdXBcIixcbiAgICAgICAgICAgICAgICAgICAgbm9kZS52YWx1ZS50b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdmVySW5kZXggPSBpO1xuICAgICAgICAgICAgZnVuY05hbWUgPSBub2RlLnZhbHVlLnJlcGxhY2VXaXRoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG92ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdmFyIG51bWVyTm9kZTtcbiAgICAgICAgdmFyIGRlbm9tTm9kZTtcblxuICAgICAgICB2YXIgbnVtZXJCb2R5ID0gYm9keS5zbGljZSgwLCBvdmVySW5kZXgpO1xuICAgICAgICB2YXIgZGVub21Cb2R5ID0gYm9keS5zbGljZShvdmVySW5kZXggKyAxKTtcblxuICAgICAgICBpZiAobnVtZXJCb2R5Lmxlbmd0aCA9PT0gMSAmJiBudW1lckJvZHlbMF0udHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICAgICAgICBudW1lck5vZGUgPSBudW1lckJvZHlbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1lck5vZGUgPSBuZXcgUGFyc2VOb2RlKFwib3JkZ3JvdXBcIiwgbnVtZXJCb2R5LCB0aGlzLm1vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbm9tQm9keS5sZW5ndGggPT09IDEgJiYgZGVub21Cb2R5WzBdLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgICAgICAgZGVub21Ob2RlID0gZGVub21Cb2R5WzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVub21Ob2RlID0gbmV3IFBhcnNlTm9kZShcIm9yZGdyb3VwXCIsIGRlbm9tQm9keSwgdGhpcy5tb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY2FsbEZ1bmN0aW9uKFxuICAgICAgICAgICAgZnVuY05hbWUsIFtudW1lck5vZGUsIGRlbm9tTm9kZV0sIG51bGwpO1xuICAgICAgICByZXR1cm4gW25ldyBQYXJzZU5vZGUodmFsdWUudHlwZSwgdmFsdWUsIHRoaXMubW9kZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH1cbn07XG5cbi8vIFRoZSBncmVlZGluZXNzIG9mIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0XG52YXIgU1VQU1VCX0dSRUVESU5FU1MgPSAxO1xuXG4vKipcbiAqIEhhbmRsZSBhIHN1YnNjcmlwdCBvciBzdXBlcnNjcmlwdCB3aXRoIG5pY2UgZXJyb3JzLlxuICovXG5QYXJzZXIucHJvdG90eXBlLmhhbmRsZVN1cFN1YnNjcmlwdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgc3ltYm9sVG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB2YXIgc3ltYm9sID0gc3ltYm9sVG9rZW4udGV4dDtcbiAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLnBhcnNlR3JvdXAoKTtcblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnRocm93T25FcnJvciAmJiB0aGlzLm5leHRUb2tlbi50ZXh0WzBdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlVW5zdXBwb3J0ZWRDbWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgZ3JvdXAgYWZ0ZXIgJ1wiICsgc3ltYm9sICsgXCInXCIsXG4gICAgICAgICAgICAgICAgc3ltYm9sVG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLmlzRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gXiBhbmQgXyBoYXZlIGEgZ3JlZWRpbmVzcywgc28gaGFuZGxlIGludGVyYWN0aW9ucyB3aXRoIGZ1bmN0aW9ucydcbiAgICAgICAgLy8gZ3JlZWRpbmVzc1xuICAgICAgICB2YXIgZnVuY0dyZWVkaW5lc3MgPSBmdW5jdGlvbnNbZ3JvdXAucmVzdWx0XS5ncmVlZGluZXNzO1xuICAgICAgICBpZiAoZnVuY0dyZWVkaW5lc3MgPiBTVVBTVUJfR1JFRURJTkVTUykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihncm91cCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICBcIkdvdCBmdW5jdGlvbiAnXCIgKyBncm91cC5yZXN1bHQgKyBcIicgd2l0aCBubyBhcmd1bWVudHMgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImFzIFwiICsgbmFtZSwgc3ltYm9sVG9rZW4pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwLnJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSB0ZXh0dWFsIGlucHV0IG9mIGFuIHVuc3VwcG9ydGVkIGNvbW1hbmQgaW50byBhIHRleHQgbm9kZVxuICogY29udGFpbmVkIHdpdGhpbiBhIGNvbG9yIG5vZGUgd2hvc2UgY29sb3IgaXMgZGV0ZXJtaW5lZCBieSBlcnJvckNvbG9yXG4gKi9cblBhcnNlci5wcm90b3R5cGUuaGFuZGxlVW5zdXBwb3J0ZWRDbWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGV4dCA9IHRoaXMubmV4dFRva2VuLnRleHQ7XG4gICAgdmFyIHRleHRvcmRBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRleHRvcmRBcnJheS5wdXNoKG5ldyBQYXJzZU5vZGUoXCJ0ZXh0b3JkXCIsIHRleHRbaV0sIFwidGV4dFwiKSk7XG4gICAgfVxuXG4gICAgdmFyIHRleHROb2RlID0gbmV3IFBhcnNlTm9kZShcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJvZHk6IHRleHRvcmRBcnJheSxcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMubW9kZSk7XG5cbiAgICB2YXIgY29sb3JOb2RlID0gbmV3IFBhcnNlTm9kZShcbiAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICB7XG4gICAgICAgICAgICBjb2xvcjogdGhpcy5zZXR0aW5ncy5lcnJvckNvbG9yLFxuICAgICAgICAgICAgdmFsdWU6IFt0ZXh0Tm9kZV0sXG4gICAgICAgICAgICB0eXBlOiBcImNvbG9yXCJcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy5tb2RlKTtcblxuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHJldHVybiBjb2xvck5vZGU7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIGdyb3VwIHdpdGggb3B0aW9uYWwgc3VwZXIvc3Vic2NyaXB0cy5cbiAqXG4gKiBAcmV0dXJuIHs/UGFyc2VOb2RlfVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRoZSBib2R5IG9mIGFuIGF0b20gaXMgYW4gaW1wbGljaXQgZ3JvdXAsIHNvIHRoYXQgdGhpbmdzIGxpa2VcbiAgICAvLyBcXGxlZnQoeFxccmlnaHQpXjIgd29yayBjb3JyZWN0bHkuXG4gICAgdmFyIGJhc2UgPSB0aGlzLnBhcnNlSW1wbGljaXRHcm91cCgpO1xuXG4gICAgLy8gSW4gdGV4dCBtb2RlLCB3ZSBkb24ndCBoYXZlIHN1cGVyc2NyaXB0cyBvciBzdWJzY3JpcHRzXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuXG4gICAgLy8gTm90ZSB0aGF0IGJhc2UgbWF5IGJlIGVtcHR5IChpLmUuIG51bGwpIGF0IHRoaXMgcG9pbnQuXG5cbiAgICB2YXIgc3VwZXJzY3JpcHQ7XG4gICAgdmFyIHN1YnNjcmlwdDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyBMZXggdGhlIGZpcnN0IHRva2VuXG4gICAgICAgIHZhciBsZXggPSB0aGlzLm5leHRUb2tlbjtcblxuICAgICAgICBpZiAobGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiIHx8IGxleC50ZXh0ID09PSBcIlxcXFxub2xpbWl0c1wiKSB7XG4gICAgICAgICAgICAvLyBXZSBnb3QgYSBsaW1pdCBjb250cm9sXG4gICAgICAgICAgICBpZiAoIWJhc2UgfHwgYmFzZS50eXBlICE9PSBcIm9wXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJMaW1pdCBjb250cm9scyBtdXN0IGZvbGxvdyBhIG1hdGggb3BlcmF0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgbGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbWl0cyA9IGxleC50ZXh0ID09PSBcIlxcXFxsaW1pdHNcIjtcbiAgICAgICAgICAgICAgICBiYXNlLnZhbHVlLmxpbWl0cyA9IGxpbWl0cztcbiAgICAgICAgICAgICAgICBiYXNlLnZhbHVlLmFsd2F5c0hhbmRsZVN1cFN1YiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCJeXCIpIHtcbiAgICAgICAgICAgIC8vIFdlIGdvdCBhIHN1cGVyc2NyaXB0IHN0YXJ0XG4gICAgICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkRvdWJsZSBzdXBlcnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VwZXJzY3JpcHQgPSB0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1cGVyc2NyaXB0XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIl9cIikge1xuICAgICAgICAgICAgLy8gV2UgZ290IGEgc3Vic2NyaXB0IHN0YXJ0XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJEb3VibGUgc3Vic2NyaXB0XCIsIGxleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpcHQgPSB0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1YnNjcmlwdFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIC8vIFdlIGdvdCBhIHByaW1lXG4gICAgICAgICAgICB2YXIgcHJpbWUgPSBuZXcgUGFyc2VOb2RlKFwidGV4dG9yZFwiLCBcIlxcXFxwcmltZVwiLCB0aGlzLm1vZGUpO1xuXG4gICAgICAgICAgICAvLyBNYW55IHByaW1lcyBjYW4gYmUgZ3JvdXBlZCB0b2dldGhlciwgc28gd2UgaGFuZGxlIHRoaXMgaGVyZVxuICAgICAgICAgICAgdmFyIHByaW1lcyA9IFtwcmltZV07XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgIC8vIEtlZXAgbGV4aW5nIHRva2VucyB1bnRpbCB3ZSBnZXQgc29tZXRoaW5nIHRoYXQncyBub3QgYSBwcmltZVxuICAgICAgICAgICAgd2hpbGUgKHRoaXMubmV4dFRva2VuLnRleHQgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggb25lLCBhZGQgYW5vdGhlciBwcmltZSB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIHByaW1lcy5wdXNoKHByaW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFB1dCB0aGVtIGludG8gYW4gb3JkZ3JvdXAgYXMgdGhlIHN1cGVyc2NyaXB0XG4gICAgICAgICAgICBzdXBlcnNjcmlwdCA9IG5ldyBQYXJzZU5vZGUoXCJvcmRncm91cFwiLCBwcmltZXMsIHRoaXMubW9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBpdCB3YXNuJ3QgXiwgXywgb3IgJywgc3RvcCBwYXJzaW5nIHN1cGVyL3N1YnNjcmlwdHNcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cGVyc2NyaXB0IHx8IHN1YnNjcmlwdCkge1xuICAgICAgICAvLyBJZiB3ZSBnb3QgZWl0aGVyIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0LCBjcmVhdGUgYSBzdXBzdWJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZU5vZGUoXCJzdXBzdWJcIiwge1xuICAgICAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgICAgIHN1cDogc3VwZXJzY3JpcHQsXG4gICAgICAgICAgICBzdWI6IHN1YnNjcmlwdFxuICAgICAgICB9LCB0aGlzLm1vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIG9yaWdpbmFsIGJvZHlcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufTtcblxuLy8gQSBsaXN0IG9mIHRoZSBzaXplLWNoYW5naW5nIGZ1bmN0aW9ucywgZm9yIHVzZSBpbiBwYXJzZUltcGxpY2l0R3JvdXBcbnZhciBzaXplRnVuY3MgPSBbXG4gICAgXCJcXFxcdGlueVwiLCBcIlxcXFxzY3JpcHRzaXplXCIsIFwiXFxcXGZvb3Rub3Rlc2l6ZVwiLCBcIlxcXFxzbWFsbFwiLCBcIlxcXFxub3JtYWxzaXplXCIsXG4gICAgXCJcXFxcbGFyZ2VcIiwgXCJcXFxcTGFyZ2VcIiwgXCJcXFxcTEFSR0VcIiwgXCJcXFxcaHVnZVwiLCBcIlxcXFxIdWdlXCJcbl07XG5cbi8vIEEgbGlzdCBvZiB0aGUgc3R5bGUtY2hhbmdpbmcgZnVuY3Rpb25zLCBmb3IgdXNlIGluIHBhcnNlSW1wbGljaXRHcm91cFxudmFyIHN0eWxlRnVuY3MgPSBbXG4gICAgXCJcXFxcZGlzcGxheXN0eWxlXCIsIFwiXFxcXHRleHRzdHlsZVwiLCBcIlxcXFxzY3JpcHRzdHlsZVwiLCBcIlxcXFxzY3JpcHRzY3JpcHRzdHlsZVwiXG5dO1xuXG4vKipcbiAqIFBhcnNlcyBhbiBpbXBsaWNpdCBncm91cCwgd2hpY2ggaXMgYSBncm91cCB0aGF0IHN0YXJ0cyBhdCB0aGUgZW5kIG9mIGFcbiAqIHNwZWNpZmllZCwgYW5kIGVuZHMgcmlnaHQgYmVmb3JlIGEgaGlnaGVyIGV4cGxpY2l0IGdyb3VwIGVuZHMsIG9yIGF0IEVPTC4gSXRcbiAqIGlzIHVzZWQgZm9yIGZ1bmN0aW9ucyB0aGF0IGFwcGVhciB0byBhZmZlY3QgdGhlIGN1cnJlbnQgc3R5bGUsIGxpa2UgXFxMYXJnZSBvclxuICogXFx0ZXh0cm0sIHdoZXJlIGluc3RlYWQgb2Yga2VlcGluZyBhIHN0eWxlIHdlIGp1c3QgcHJldGVuZCB0aGF0IHRoZXJlIGlzIGFuXG4gKiBpbXBsaWNpdCBncm91cGluZyBhZnRlciBpdCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBncm91cC4gRS5nLlxuICogICBzbWFsbCB0ZXh0IHtcXExhcmdlIGxhcmdlIHRleHR9IHNtYWxsIHRleHQgYWdhaW5cbiAqIEl0IGlzIGFsc28gdXNlZCBmb3IgXFxsZWZ0IGFuZCBcXHJpZ2h0IHRvIGdldCB0aGUgY29ycmVjdCBncm91cGluZy5cbiAqXG4gKiBAcmV0dXJuIHs/UGFyc2VOb2RlfVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wbGljaXRHcm91cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucGFyc2VTeW1ib2woKTtcblxuICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHdlIGRpZG4ndCBnZXQgYW55dGhpbmcgd2UgaGFuZGxlLCBmYWxsIGJhY2sgdG8gcGFyc2VGdW5jdGlvblxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bmMgPSBzdGFydC5yZXN1bHQ7XG4gICAgdmFyIGJvZHk7XG5cbiAgICBpZiAoZnVuYyA9PT0gXCJcXFxcbGVmdFwiKSB7XG4gICAgICAgIC8vIElmIHdlIHNlZSBhIGxlZnQ6XG4gICAgICAgIC8vIFBhcnNlIHRoZSBlbnRpcmUgbGVmdCBmdW5jdGlvbiAoaW5jbHVkaW5nIHRoZSBkZWxpbWl0ZXIpXG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5wYXJzZUZ1bmN0aW9uKHN0YXJ0KTtcbiAgICAgICAgLy8gUGFyc2Ugb3V0IHRoZSBpbXBsaWNpdCBib2R5XG4gICAgICAgICsrdGhpcy5sZWZ0cmlnaHREZXB0aDtcbiAgICAgICAgYm9keSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcbiAgICAgICAgLS10aGlzLmxlZnRyaWdodERlcHRoO1xuICAgICAgICAvLyBDaGVjayB0aGUgbmV4dCB0b2tlblxuICAgICAgICB0aGlzLmV4cGVjdChcIlxcXFxyaWdodFwiLCBmYWxzZSk7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VGdW5jdGlvbigpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlTm9kZShcImxlZnRyaWdodFwiLCB7XG4gICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgbGVmdDogbGVmdC52YWx1ZS52YWx1ZSxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodC52YWx1ZS52YWx1ZVxuICAgICAgICB9LCB0aGlzLm1vZGUpO1xuICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gXCJcXFxcYmVnaW5cIikge1xuICAgICAgICAvLyBiZWdpbi4uLmVuZCBpcyBzaW1pbGFyIHRvIGxlZnQuLi5yaWdodFxuICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLnBhcnNlRnVuY3Rpb24oc3RhcnQpO1xuICAgICAgICB2YXIgZW52TmFtZSA9IGJlZ2luLnZhbHVlLm5hbWU7XG4gICAgICAgIGlmICghZW52aXJvbm1lbnRzLmhhc093blByb3BlcnR5KGVudk5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICBcIk5vIHN1Y2ggZW52aXJvbm1lbnQ6IFwiICsgZW52TmFtZSwgYmVnaW4udmFsdWUubmFtZUdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgZW52aXJvbm1lbnQgb2JqZWN0LiBBcmd1bWVudHMgYW5kIG90aGVyIGluZm9ybWF0aW9uIHdpbGxcbiAgICAgICAgLy8gYmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGJlZ2luIGFuZCBlbmQgbWV0aG9kcyB1c2luZyBwcm9wZXJ0aWVzLlxuICAgICAgICB2YXIgZW52ID0gZW52aXJvbm1lbnRzW2Vudk5hbWVdO1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VBcmd1bWVudHMoXCJcXFxcYmVnaW57XCIgKyBlbnZOYW1lICsgXCJ9XCIsIGVudik7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgICAgZW52TmFtZTogZW52TmFtZSxcbiAgICAgICAgICAgIHBhcnNlcjogdGhpcyxcbiAgICAgICAgICAgIHBvc2l0aW9uczogYXJncy5wb3AoKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gZW52LmhhbmRsZXIoY29udGV4dCwgYXJncyk7XG4gICAgICAgIHRoaXMuZXhwZWN0KFwiXFxcXGVuZFwiLCBmYWxzZSk7XG4gICAgICAgIHZhciBlbmROYW1lVG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucGFyc2VGdW5jdGlvbigpO1xuICAgICAgICBpZiAoZW5kLnZhbHVlLm5hbWUgIT09IGVudk5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiTWlzbWF0Y2g6IFxcXFxiZWdpbntcIiArIGVudk5hbWUgKyBcIn0gbWF0Y2hlZCBcIiArXG4gICAgICAgICAgICAgICAgXCJieSBcXFxcZW5ke1wiICsgZW5kLnZhbHVlLm5hbWUgKyBcIn1cIixcbiAgICAgICAgICAgICAgICBlbmROYW1lVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wb3NpdGlvbiA9IGVuZC5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmNvbnRhaW5zKHNpemVGdW5jcywgZnVuYykpIHtcbiAgICAgICAgLy8gSWYgd2Ugc2VlIGEgc2l6aW5nIGZ1bmN0aW9uLCBwYXJzZSBvdXQgdGhlIGltcGxpY3QgYm9keVxuICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlTm9kZShcInNpemluZ1wiLCB7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc2l6ZSB0byB1c2UgYmFzZWQgb24gdGhlIGxpc3Qgb2YgZnVuY3Rpb25zIGFib3ZlXG4gICAgICAgICAgICBzaXplOiBcInNpemVcIiArICh1dGlscy5pbmRleE9mKHNpemVGdW5jcywgZnVuYykgKyAxKSxcbiAgICAgICAgICAgIHZhbHVlOiBib2R5XG4gICAgICAgIH0sIHRoaXMubW9kZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyhzdHlsZUZ1bmNzLCBmdW5jKSkge1xuICAgICAgICAvLyBJZiB3ZSBzZWUgYSBzdHlsaW5nIGZ1bmN0aW9uLCBwYXJzZSBvdXQgdGhlIGltcGxpY3QgYm9keVxuICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VOb2RlKFwic3R5bGluZ1wiLCB7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc3R5bGUgdG8gdXNlIGJ5IHB1bGxpbmcgb3V0IHRoZSBzdHlsZSBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgZnVuY3Rpb24gbmFtZVxuICAgICAgICAgICAgc3R5bGU6IGZ1bmMuc2xpY2UoMSwgZnVuYy5sZW5ndGggLSA1KSxcbiAgICAgICAgICAgIHZhbHVlOiBib2R5XG4gICAgICAgIH0sIHRoaXMubW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGVmZXIgdG8gcGFyc2VGdW5jdGlvbiBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uIHdlIGhhbmRsZVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKHN0YXJ0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhbiBlbnRpcmUgZnVuY3Rpb24sIGluY2x1ZGluZyBpdHMgYmFzZSBhbmQgYWxsIG9mIGl0cyBhcmd1bWVudHMuXG4gKiBUaGUgYmFzZSBtaWdodCBlaXRoZXIgaGF2ZSBiZWVuIHBhcnNlZCBhbHJlYWR5LCBpbiB3aGljaCBjYXNlXG4gKiBpdCBpcyBwcm92aWRlZCBhcyBhbiBhcmd1bWVudCwgb3IgaXQncyB0aGUgbmV4dCBncm91cCBpbiB0aGUgaW5wdXQuXG4gKlxuICogQHBhcmFtIHtQYXJzZUZ1bmNPckFyZ3VtZW50PX0gYmFzZUdyb3VwIG9wdGlvbmFsIGFzIGRlc2NyaWJlZCBhYm92ZVxuICogQHJldHVybiB7P1BhcnNlTm9kZX1cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZ1bmN0aW9uID0gZnVuY3Rpb24oYmFzZUdyb3VwKSB7XG4gICAgaWYgKCFiYXNlR3JvdXApIHtcbiAgICAgICAgYmFzZUdyb3VwID0gdGhpcy5wYXJzZUdyb3VwKCk7XG4gICAgfVxuXG4gICAgaWYgKGJhc2VHcm91cCkge1xuICAgICAgICBpZiAoYmFzZUdyb3VwLmlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBmdW5jID0gYmFzZUdyb3VwLnJlc3VsdDtcbiAgICAgICAgICAgIHZhciBmdW5jRGF0YSA9IGZ1bmN0aW9uc1tmdW5jXTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiICYmICFmdW5jRGF0YS5hbGxvd2VkSW5UZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiQ2FuJ3QgdXNlIGZ1bmN0aW9uICdcIiArIGZ1bmMgKyBcIicgaW4gdGV4dCBtb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VHcm91cC50b2tlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZUFyZ3VtZW50cyhmdW5jLCBmdW5jRGF0YSk7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBiYXNlR3JvdXAudG9rZW47XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jYWxsRnVuY3Rpb24oZnVuYywgYXJncywgYXJncy5wb3AoKSwgdG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZU5vZGUocmVzdWx0LnR5cGUsIHJlc3VsdCwgdGhpcy5tb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlR3JvdXAucmVzdWx0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gaGFuZGxlciB3aXRoIGEgc3VpdGFibGUgY29udGV4dCBhbmQgYXJndW1lbnRzLlxuICovXG5QYXJzZXIucHJvdG90eXBlLmNhbGxGdW5jdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3MsIHBvc2l0aW9ucywgdG9rZW4pIHtcbiAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgZnVuY05hbWU6IG5hbWUsXG4gICAgICAgIHBhcnNlcjogdGhpcyxcbiAgICAgICAgcG9zaXRpb25zOiBwb3NpdGlvbnMsXG4gICAgICAgIHRva2VuOiB0b2tlblxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uc1tuYW1lXS5oYW5kbGVyKGNvbnRleHQsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIG9yIGVudmlyb25tZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZ1bmMgIFwiXFxuYW1lXCIgb3IgXCJcXGJlZ2lue25hbWV9XCJcbiAqIEBwYXJhbSB7e251bUFyZ3M6bnVtYmVyLG51bU9wdGlvbmFsQXJnczpudW1iZXJ8dW5kZWZpbmVkfX0gZnVuY0RhdGFcbiAqIEByZXR1cm4gdGhlIGFycmF5IG9mIGFyZ3VtZW50cywgd2l0aCB0aGUgbGlzdCBvZiBwb3NpdGlvbnMgYXMgbGFzdCBlbGVtZW50XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VBcmd1bWVudHMgPSBmdW5jdGlvbihmdW5jLCBmdW5jRGF0YSkge1xuICAgIHZhciB0b3RhbEFyZ3MgPSBmdW5jRGF0YS5udW1BcmdzICsgZnVuY0RhdGEubnVtT3B0aW9uYWxBcmdzO1xuICAgIGlmICh0b3RhbEFyZ3MgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtbdGhpcy5wb3NdXTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZUdyZWVkaW5lc3MgPSBmdW5jRGF0YS5ncmVlZGluZXNzO1xuICAgIHZhciBwb3NpdGlvbnMgPSBbdGhpcy5wb3NdO1xuICAgIHZhciBhcmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsQXJnczsgaSsrKSB7XG4gICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICAgICAgdmFyIGFyZ1R5cGUgPSBmdW5jRGF0YS5hcmdUeXBlcyAmJiBmdW5jRGF0YS5hcmdUeXBlc1tpXTtcbiAgICAgICAgdmFyIGFyZztcbiAgICAgICAgaWYgKGkgPCBmdW5jRGF0YS5udW1PcHRpb25hbEFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChhcmdUeXBlKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gdGhpcy5wYXJzZUdyb3VwT2ZUeXBlKGFyZ1R5cGUsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmcgPSB0aGlzLnBhcnNlR3JvdXAodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaCh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnVHlwZSkge1xuICAgICAgICAgICAgICAgIGFyZyA9IHRoaXMucGFyc2VHcm91cE9mVHlwZShhcmdUeXBlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJnID0gdGhpcy5wYXJzZUdyb3VwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy50aHJvd09uRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4udGV4dFswXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gbmV3IFBhcnNlRnVuY09yQXJndW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVVuc3VwcG9ydGVkQ21kKHRoaXMubmV4dFRva2VuLnRleHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCBncm91cCBhZnRlciAnXCIgKyBmdW5jICsgXCInXCIsIG5leHRUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdOb2RlO1xuICAgICAgICBpZiAoYXJnLmlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBhcmdHcmVlZGluZXNzID1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbnNbYXJnLnJlc3VsdF0uZ3JlZWRpbmVzcztcbiAgICAgICAgICAgIGlmIChhcmdHcmVlZGluZXNzID4gYmFzZUdyZWVkaW5lc3MpIHtcbiAgICAgICAgICAgICAgICBhcmdOb2RlID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGFyZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkdvdCBmdW5jdGlvbiAnXCIgKyBhcmcucmVzdWx0ICsgXCInIGFzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJhcmd1bWVudCB0byAnXCIgKyBmdW5jICsgXCInXCIsIG5leHRUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdOb2RlID0gYXJnLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnB1c2goYXJnTm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHRoaXMucG9zKTtcbiAgICB9XG5cbiAgICBhcmdzLnB1c2gocG9zaXRpb25zKTtcblxuICAgIHJldHVybiBhcmdzO1xufTtcblxuXG4vKipcbiAqIFBhcnNlcyBhIGdyb3VwIHdoZW4gdGhlIG1vZGUgaXMgY2hhbmdpbmcuXG4gKlxuICogQHJldHVybiB7P1BhcnNlRnVuY09yQXJndW1lbnR9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VHcm91cE9mVHlwZSA9IGZ1bmN0aW9uKGlubmVyTW9kZSwgb3B0aW9uYWwpIHtcbiAgICB2YXIgb3V0ZXJNb2RlID0gdGhpcy5tb2RlO1xuICAgIC8vIEhhbmRsZSBgb3JpZ2luYWxgIGFyZ1R5cGVzXG4gICAgaWYgKGlubmVyTW9kZSA9PT0gXCJvcmlnaW5hbFwiKSB7XG4gICAgICAgIGlubmVyTW9kZSA9IG91dGVyTW9kZTtcbiAgICB9XG5cbiAgICBpZiAoaW5uZXJNb2RlID09PSBcImNvbG9yXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb2xvckdyb3VwKG9wdGlvbmFsKTtcbiAgICB9XG4gICAgaWYgKGlubmVyTW9kZSA9PT0gXCJzaXplXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTaXplR3JvdXAob3B0aW9uYWwpO1xuICAgIH1cblxuICAgIHRoaXMuc3dpdGNoTW9kZShpbm5lck1vZGUpO1xuICAgIGlmIChpbm5lck1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIC8vIHRleHQgbW9kZSBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgc2hvdWxkIGlnbm9yZSB0aGUgd2hpdGVzcGFjZSBiZWZvcmVcbiAgICAgICAgLy8gaXRcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dFRva2VuLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCeSB0aGUgdGltZSB3ZSBnZXQgaGVyZSwgaW5uZXJNb2RlIGlzIG9uZSBvZiBcInRleHRcIiBvciBcIm1hdGhcIi5cbiAgICAvLyBXZSBzd2l0Y2ggdGhlIG1vZGUgb2YgdGhlIHBhcnNlciwgcmVjdXJzZSwgdGhlbiByZXN0b3JlIHRoZSBvbGQgbW9kZS5cbiAgICB2YXIgcmVzID0gdGhpcy5wYXJzZUdyb3VwKG9wdGlvbmFsKTtcbiAgICB0aGlzLnN3aXRjaE1vZGUob3V0ZXJNb2RlKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBncm91cCwgZXNzZW50aWFsbHkgcmV0dXJuaW5nIHRoZSBzdHJpbmcgZm9ybWVkIGJ5IHRoZVxuICogYnJhY2UtZW5jbG9zZWQgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kZU5hbWUgIFVzZWQgdG8gZGVzY3JpYmUgdGhlIG1vZGUgaW4gZXJyb3IgbWVzc2FnZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdGlvbmFsICBXaGV0aGVyIHRoZSBncm91cCBpcyBvcHRpb25hbCBvciByZXF1aXJlZFxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nR3JvdXAgPSBmdW5jdGlvbihtb2RlTmFtZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgdGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gXCJbXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvdXRlck1vZGUgPSB0aGlzLm1vZGU7XG4gICAgdGhpcy5tb2RlID0gXCJ0ZXh0XCI7XG4gICAgdGhpcy5leHBlY3Qob3B0aW9uYWwgPyBcIltcIiA6IFwie1wiKTtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgZmlyc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgIHZhciBsYXN0VG9rZW4gPSBmaXJzdFRva2VuO1xuICAgIHdoaWxlICh0aGlzLm5leHRUb2tlbi50ZXh0ICE9PSAob3B0aW9uYWwgPyBcIl1cIiA6IFwifVwiKSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0VG9rZW4udGV4dCA9PT0gXCJFT0ZcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCBpbiBcIiArIG1vZGVOYW1lLFxuICAgICAgICAgICAgICAgIGZpcnN0VG9rZW4ucmFuZ2UodGhpcy5uZXh0VG9rZW4sIHN0cikpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgICAgICBzdHIgKz0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgICB0aGlzLm1vZGUgPSBvdXRlck1vZGU7XG4gICAgdGhpcy5leHBlY3Qob3B0aW9uYWwgPyBcIl1cIiA6IFwifVwiKTtcbiAgICByZXR1cm4gZmlyc3RUb2tlbi5yYW5nZShsYXN0VG9rZW4sIHN0cik7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHJlZ2V4LWRlbGltaXRlZCBncm91cDogdGhlIGxhcmdlc3Qgc2VxdWVuY2Ugb2YgdG9rZW5zXG4gKiB3aG9zZSBjb25jYXRlbmF0ZWQgc3RyaW5ncyBtYXRjaCBgcmVnZXhgLiBSZXR1cm5zIHRoZSBzdHJpbmdcbiAqIGZvcm1lZCBieSB0aGUgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlTmFtZSAgVXNlZCB0byBkZXNjcmliZSB0aGUgbW9kZSBpbiBlcnJvciBtZXNzYWdlc1xuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlUmVnZXhHcm91cCA9IGZ1bmN0aW9uKHJlZ2V4LCBtb2RlTmFtZSkge1xuICAgIHZhciBvdXRlck1vZGUgPSB0aGlzLm1vZGU7XG4gICAgdGhpcy5tb2RlID0gXCJ0ZXh0XCI7XG4gICAgdmFyIGZpcnN0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB2YXIgbGFzdFRva2VuID0gZmlyc3RUb2tlbjtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB3aGlsZSAodGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gXCJFT0ZcIlxuICAgICAgICAgICAmJiByZWdleC50ZXN0KHN0ciArIHRoaXMubmV4dFRva2VuLnRleHQpKSB7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgICAgICBzdHIgKz0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIFwiICsgbW9kZU5hbWUgKyBcIjogJ1wiICsgZmlyc3RUb2tlbi50ZXh0ICsgXCInXCIsXG4gICAgICAgICAgICBmaXJzdFRva2VuKTtcbiAgICB9XG4gICAgdGhpcy5tb2RlID0gb3V0ZXJNb2RlO1xuICAgIHJldHVybiBmaXJzdFRva2VuLnJhbmdlKGxhc3RUb2tlbiwgc3RyKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgY29sb3IgZGVzY3JpcHRpb24uXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VDb2xvckdyb3VwID0gZnVuY3Rpb24ob3B0aW9uYWwpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwiY29sb3JcIiwgb3B0aW9uYWwpO1xuICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSAoL14oI1thLXowLTldK3xbYS16XSspJC9pKS5leGVjKHJlcy50ZXh0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBjb2xvcjogJ1wiICsgcmVzLnRleHQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICBuZXcgUGFyc2VOb2RlKFwiY29sb3JcIiwgbWF0Y2hbMF0sIHRoaXMubW9kZSksXG4gICAgICAgIGZhbHNlKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2l6ZSBzcGVjaWZpY2F0aW9uLCBjb25zaXN0aW5nIG9mIG1hZ25pdHVkZSBhbmQgdW5pdC5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNpemVHcm91cCA9IGZ1bmN0aW9uKG9wdGlvbmFsKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAoIW9wdGlvbmFsICYmIHRoaXMubmV4dFRva2VuLnRleHQgIT09IFwie1wiKSB7XG4gICAgICAgIHJlcyA9IHRoaXMucGFyc2VSZWdleEdyb3VwKFxuICAgICAgICAgICAgL15bLStdPyAqKD86JHxcXGQrfFxcZCtcXC5cXGQqfFxcLlxcZCopICpbYS16XXswLDJ9JC8sIFwic2l6ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJzaXplXCIsIG9wdGlvbmFsKTtcbiAgICB9XG4gICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBtYXRjaCA9ICgvKFstK10/KSAqKFxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykgKihbYS16XXsyfSkvKS5leGVjKHJlcy50ZXh0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBzaXplOiAnXCIgKyByZXMudGV4dCArIFwiJ1wiLCByZXMpO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgbnVtYmVyOiArKG1hdGNoWzFdICsgbWF0Y2hbMl0pLCAvLyBzaWduICsgbWFnbml0dWRlLCBjYXN0IHRvIG51bWJlclxuICAgICAgICB1bml0OiBtYXRjaFszXVxuICAgIH07XG4gICAgaWYgKGRhdGEudW5pdCAhPT0gXCJlbVwiICYmIGRhdGEudW5pdCAhPT0gXCJleFwiICYmIGRhdGEudW5pdCAhPT0gXCJtdVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyBkYXRhLnVuaXQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICBuZXcgUGFyc2VOb2RlKFwiY29sb3JcIiwgZGF0YSwgdGhpcy5tb2RlKSxcbiAgICAgICAgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgZmFsc2Ugb3IgYWJzZW50LCB0aGlzIHBhcnNlcyBhbiBvcmRpbmFyeSBncm91cCxcbiAqIHdoaWNoIGlzIGVpdGhlciBhIHNpbmdsZSBudWNsZXVzIChsaWtlIFwieFwiKSBvciBhbiBleHByZXNzaW9uXG4gKiBpbiBicmFjZXMgKGxpa2UgXCJ7eCt5fVwiKS5cbiAqIElmIHRoZSBhcmd1bWVudCBpcyB0cnVlLCBpdCBwYXJzZXMgZWl0aGVyIGEgYnJhY2tldC1kZWxpbWl0ZWQgZXhwcmVzc2lvblxuICogKGxpa2UgXCJbeCt5XVwiKSBvciByZXR1cm5zIG51bGwgdG8gaW5kaWNhdGUgdGhlIGFic2VuY2Ugb2YgYVxuICogYnJhY2tldC1lbmNsb3NlZCBncm91cC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRpb25hbCAgV2hldGhlciB0aGUgZ3JvdXAgaXMgb3B0aW9uYWwgb3IgcmVxdWlyZWRcbiAqIEByZXR1cm4gez9QYXJzZUZ1bmNPckFyZ3VtZW50fVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlR3JvdXAgPSBmdW5jdGlvbihvcHRpb25hbCkge1xuICAgIHZhciBmaXJzdFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG4gICAgLy8gVHJ5IHRvIHBhcnNlIGFuIG9wZW4gYnJhY2VcbiAgICBpZiAodGhpcy5uZXh0VG9rZW4udGV4dCA9PT0gKG9wdGlvbmFsID8gXCJbXCIgOiBcIntcIikpIHtcbiAgICAgICAgLy8gSWYgd2UgZ2V0IGEgYnJhY2UsIHBhcnNlIGFuIGV4cHJlc3Npb25cbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIG9wdGlvbmFsID8gXCJdXCIgOiBudWxsKTtcbiAgICAgICAgdmFyIGxhc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZ2V0IGEgY2xvc2UgYnJhY2VcbiAgICAgICAgdGhpcy5leHBlY3Qob3B0aW9uYWwgPyBcIl1cIiA6IFwifVwiKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUxpZ2F0dXJlcyhleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlRnVuY09yQXJndW1lbnQoXG4gICAgICAgICAgICBuZXcgUGFyc2VOb2RlKFwib3JkZ3JvdXBcIiwgZXhwcmVzc2lvbiwgdGhpcy5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFRva2VuLCBsYXN0VG9rZW4pLFxuICAgICAgICAgICAgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwganVzdCByZXR1cm4gYSBudWNsZXVzLCBvciBub3RoaW5nIGZvciBhbiBvcHRpb25hbCBncm91cFxuICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyBudWxsIDogdGhpcy5wYXJzZVN5bWJvbCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRm9ybSBsaWdhdHVyZS1saWtlIGNvbWJpbmF0aW9ucyBvZiBjaGFyYWN0ZXJzIGZvciB0ZXh0IG1vZGUuXG4gKiBUaGlzIGluY2x1ZGVzIGlucHV0cyBsaWtlIFwiLS1cIiwgXCItLS1cIiwgXCJgYFwiIGFuZCBcIicnXCIuXG4gKiBUaGUgcmVzdWx0IHdpbGwgc2ltcGx5IHJlcGxhY2UgbXVsdGlwbGUgdGV4dG9yZCBub2RlcyB3aXRoIGEgc2luZ2xlXG4gKiBjaGFyYWN0ZXIgaW4gZWFjaCB2YWx1ZSBieSBhIHNpbmdsZSB0ZXh0b3JkIG5vZGUgaGF2aW5nIG11bHRpcGxlXG4gKiBjaGFyYWN0ZXJzIGluIGl0cyB2YWx1ZS4gIFRoZSByZXByZXNlbnRhdGlvbiBpcyBzdGlsbCBBU0NJSSBzb3VyY2UuXG4gKlxuICogQHBhcmFtIHtBcnJheS48UGFyc2VOb2RlPn0gZ3JvdXAgIHRoZSBub2RlcyBvZiB0aGlzIGdyb3VwLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Qgd2lsbCBiZSBtb2lmaWVkIGluIHBsYWNlXG4gKi9cblBhcnNlci5wcm90b3R5cGUuZm9ybUxpZ2F0dXJlcyA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIG4gPSBncm91cC5sZW5ndGggLSAxO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdmFyIGEgPSBncm91cFtpXTtcbiAgICAgICAgdmFyIHYgPSBhLnZhbHVlO1xuICAgICAgICBpZiAodiA9PT0gXCItXCIgJiYgZ3JvdXBbaSArIDFdLnZhbHVlID09PSBcIi1cIikge1xuICAgICAgICAgICAgaWYgKGkgKyAxIDwgbiAmJiBncm91cFtpICsgMl0udmFsdWUgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDMsIG5ldyBQYXJzZU5vZGUoXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dG9yZFwiLCBcIi0tLVwiLCBcInRleHRcIiwgYSwgZ3JvdXBbaSArIDJdKSk7XG4gICAgICAgICAgICAgICAgbiAtPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncm91cC5zcGxpY2UoaSwgMiwgbmV3IFBhcnNlTm9kZShcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0b3JkXCIsIFwiLS1cIiwgXCJ0ZXh0XCIsIGEsIGdyb3VwW2kgKyAxXSkpO1xuICAgICAgICAgICAgICAgIG4gLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHYgPT09IFwiJ1wiIHx8IHYgPT09IFwiYFwiKSAmJiBncm91cFtpICsgMV0udmFsdWUgPT09IHYpIHtcbiAgICAgICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCBuZXcgUGFyc2VOb2RlKFxuICAgICAgICAgICAgICAgIFwidGV4dG9yZFwiLCB2ICsgdiwgXCJ0ZXh0XCIsIGEsIGdyb3VwW2kgKyAxXSkpO1xuICAgICAgICAgICAgbiAtPSAxO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBQYXJzZSBhIHNpbmdsZSBzeW1ib2wgb3V0IG9mIHRoZSBzdHJpbmcuIEhlcmUsIHdlIGhhbmRsZSBib3RoIHRoZSBmdW5jdGlvbnNcbiAqIHdlIGhhdmUgZGVmaW5lZCwgYXMgd2VsbCBhcyB0aGUgc2luZ2xlIGNoYXJhY3RlciBzeW1ib2xzXG4gKlxuICogQHJldHVybiB7P1BhcnNlRnVuY09yQXJndW1lbnR9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VTeW1ib2wgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbnVjbGV1cyA9IHRoaXMubmV4dFRva2VuO1xuXG4gICAgaWYgKGZ1bmN0aW9uc1tudWNsZXVzLnRleHRdKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAvLyBJZiB0aGVyZSBleGlzdHMgYSBmdW5jdGlvbiB3aXRoIHRoaXMgbmFtZSwgd2UgcmV0dXJuIHRoZSBmdW5jdGlvbiBhbmRcbiAgICAgICAgLy8gc2F5IHRoYXQgaXQgaXMgYSBmdW5jdGlvbi5cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICAgICAgbnVjbGV1cy50ZXh0LFxuICAgICAgICAgICAgdHJ1ZSwgbnVjbGV1cyk7XG4gICAgfSBlbHNlIGlmIChzeW1ib2xzW3RoaXMubW9kZV1bbnVjbGV1cy50ZXh0XSkge1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIHRoaXMgaXMgYSBuby1hcmd1bWVudCBmdW5jdGlvbiwgZmluZCB0aGUgdHlwZSBpdFxuICAgICAgICAvLyBjb3JyZXNwb25kcyB0byBpbiB0aGUgc3ltYm9scyBtYXBcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICAgICAgbmV3IFBhcnNlTm9kZShzeW1ib2xzW3RoaXMubW9kZV1bbnVjbGV1cy50ZXh0XS5ncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVjbGV1cy50ZXh0LCB0aGlzLm1vZGUsIG51Y2xldXMpLFxuICAgICAgICAgICAgZmFsc2UsIG51Y2xldXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIiAmJiBjamtSZWdleC50ZXN0KG51Y2xldXMudGV4dCkpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VGdW5jT3JBcmd1bWVudChcbiAgICAgICAgICAgIG5ldyBQYXJzZU5vZGUoXCJ0ZXh0b3JkXCIsIG51Y2xldXMudGV4dCwgdGhpcy5tb2RlLCBudWNsZXVzKSxcbiAgICAgICAgICAgIGZhbHNlLCBudWNsZXVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLlBhcnNlTm9kZSA9IFBhcnNlTm9kZTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXI7XG4iLCIvKipcbiAqIFRoaXMgaXMgYSBtb2R1bGUgZm9yIHN0b3Jpbmcgc2V0dGluZ3MgcGFzc2VkIGludG8gS2FUZVguIEl0IGNvcnJlY3RseSBoYW5kbGVzXG4gKiBkZWZhdWx0IHNldHRpbmdzLlxuICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIGEgZGVmYXVsdCB2YWx1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGdldChvcHRpb24sIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBvcHRpb24gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IG9wdGlvbjtcbn1cblxuLyoqXG4gKiBUaGUgbWFpbiBTZXR0aW5ncyBvYmplY3RcbiAqXG4gKiBUaGUgY3VycmVudCBvcHRpb25zIHN0b3JlZCBhcmU6XG4gKiAgLSBkaXNwbGF5TW9kZTogV2hldGhlciB0aGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgdHlwZXNldCBieSBkZWZhdWx0IGluXG4gKiAgICAgICAgICAgICAgICAgdGV4dHN0eWxlIG9yIGRpc3BsYXlzdHlsZSAoZGVmYXVsdCBmYWxzZSlcbiAqL1xuZnVuY3Rpb24gU2V0dGluZ3Mob3B0aW9ucykge1xuICAgIC8vIGFsbG93IG51bGwgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZGlzcGxheU1vZGUgPSBnZXQob3B0aW9ucy5kaXNwbGF5TW9kZSwgZmFsc2UpO1xuICAgIHRoaXMudGhyb3dPbkVycm9yID0gZ2V0KG9wdGlvbnMudGhyb3dPbkVycm9yLCB0cnVlKTtcbiAgICB0aGlzLmVycm9yQ29sb3IgPSBnZXQob3B0aW9ucy5lcnJvckNvbG9yLCBcIiNjYzAwMDBcIik7XG4gICAgdGhpcy5tYWNyb3MgPSBvcHRpb25zLm1hY3JvcyB8fCB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXR0aW5ncztcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFuZCBjbGFzc2VzIGZvciB0aGUgdmFyaW91cyBraW5kcyBvZiBzdHlsZXNcbiAqIHVzZWQgaW4gVGVYLiBJdCBwcm92aWRlcyBhIGdlbmVyaWMgYFN0eWxlYCBjbGFzcywgd2hpY2ggaG9sZHMgaW5mb3JtYXRpb25cbiAqIGFib3V0IGEgc3BlY2lmaWMgc3R5bGUuIEl0IHRoZW4gcHJvdmlkZXMgaW5zdGFuY2VzIG9mIGFsbCB0aGUgZGlmZmVyZW50IGtpbmRzXG4gKiBvZiBzdHlsZXMgcG9zc2libGUsIGFuZCBwcm92aWRlcyBmdW5jdGlvbnMgdG8gbW92ZSBiZXR3ZWVuIHRoZW0gYW5kIGdldFxuICogaW5mb3JtYXRpb24gYWJvdXQgdGhlbS5cbiAqL1xuXG52YXIgc2lnbWFzID0gcmVxdWlyZShcIi4vZm9udE1ldHJpY3MuanNcIikuc2lnbWFzO1xuXG52YXIgbWV0cmljcyA9IFt7fSwge30sIHt9XTtcbnZhciBpO1xuZm9yICh2YXIga2V5IGluIHNpZ21hcykge1xuICAgIGlmIChzaWdtYXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICBtZXRyaWNzW2ldW2tleV0gPSBzaWdtYXNba2V5XVtpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBtZXRyaWNzW2ldLmVtUGVyRXggPSBzaWdtYXMueEhlaWdodFtpXSAvIHNpZ21hcy5xdWFkW2ldO1xufVxuXG4vKipcbiAqIFRoZSBtYWluIHN0eWxlIGNsYXNzLiBDb250YWlucyBhIHVuaXF1ZSBpZCBmb3IgdGhlIHN0eWxlLCBhIHNpemUgKHdoaWNoIGlzXG4gKiB0aGUgc2FtZSBmb3IgY3JhbXBlZCBhbmQgdW5jcmFtcGVkIHZlcnNpb24gb2YgYSBzdHlsZSksIGEgY3JhbXBlZCBmbGFnLCBhbmQgYVxuICogc2l6ZSBtdWx0aXBsaWVyLCB3aGljaCBnaXZlcyB0aGUgc2l6ZSBkaWZmZXJlbmNlIGJldHdlZW4gYSBzdHlsZSBhbmRcbiAqIHRleHRzdHlsZS5cbiAqL1xuZnVuY3Rpb24gU3R5bGUoaWQsIHNpemUsIG11bHRpcGxpZXIsIGNyYW1wZWQpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmNyYW1wZWQgPSBjcmFtcGVkO1xuICAgIHRoaXMuc2l6ZU11bHRpcGxpZXIgPSBtdWx0aXBsaWVyO1xuICAgIHRoaXMubWV0cmljcyA9IG1ldHJpY3Nbc2l6ZSA+IDAgPyBzaXplIC0gMSA6IDBdO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3R5bGUgb2YgYSBzdXBlcnNjcmlwdCBnaXZlbiBhIGJhc2UgaW4gdGhlIGN1cnJlbnQgc3R5bGUuXG4gKi9cblN0eWxlLnByb3RvdHlwZS5zdXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3R5bGVzW3N1cFt0aGlzLmlkXV07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3R5bGUgb2YgYSBzdWJzY3JpcHQgZ2l2ZW4gYSBiYXNlIGluIHRoZSBjdXJyZW50IHN0eWxlLlxuICovXG5TdHlsZS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tzdWJbdGhpcy5pZF1dO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHN0eWxlIG9mIGEgZnJhY3Rpb24gbnVtZXJhdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudFxuICogc3R5bGUuXG4gKi9cblN0eWxlLnByb3RvdHlwZS5mcmFjTnVtID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tmcmFjTnVtW3RoaXMuaWRdXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzdHlsZSBvZiBhIGZyYWN0aW9uIGRlbm9taW5hdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudFxuICogc3R5bGUuXG4gKi9cblN0eWxlLnByb3RvdHlwZS5mcmFjRGVuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tmcmFjRGVuW3RoaXMuaWRdXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjcmFtcGVkIHZlcnNpb24gb2YgYSBzdHlsZSAoaW4gcGFydGljdWxhciwgY3JhbXBpbmcgYSBjcmFtcGVkIHN0eWxlXG4gKiBkb2Vzbid0IGNoYW5nZSB0aGUgc3R5bGUpLlxuICovXG5TdHlsZS5wcm90b3R5cGUuY3JhbXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3R5bGVzW2NyYW1wW3RoaXMuaWRdXTtcbn07XG5cbi8qKlxuICogSFRNTCBjbGFzcyBuYW1lLCBsaWtlIFwiZGlzcGxheXN0eWxlIGNyYW1wZWRcIlxuICovXG5TdHlsZS5wcm90b3R5cGUuY2xzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNpemVOYW1lc1t0aGlzLnNpemVdICsgKHRoaXMuY3JhbXBlZCA/IFwiIGNyYW1wZWRcIiA6IFwiIHVuY3JhbXBlZFwiKTtcbn07XG5cbi8qKlxuICogSFRNTCBSZXNldCBjbGFzcyBuYW1lLCBsaWtlIFwicmVzZXQtdGV4dHN0eWxlXCJcbiAqL1xuU3R5bGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHJlc2V0TmFtZXNbdGhpcy5zaXplXTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGlmIHRoaXMgc3R5bGUgaXMgdGlnaHRseSBzcGFjZWQgKHNjcmlwdHN0eWxlL3NjcmlwdHNjcmlwdHN0eWxlKVxuICovXG5TdHlsZS5wcm90b3R5cGUuaXNUaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUgPj0gMjtcbn07XG5cbi8vIElEcyBvZiB0aGUgZGlmZmVyZW50IHN0eWxlc1xudmFyIEQgPSAwO1xudmFyIERjID0gMTtcbnZhciBUID0gMjtcbnZhciBUYyA9IDM7XG52YXIgUyA9IDQ7XG52YXIgU2MgPSA1O1xudmFyIFNTID0gNjtcbnZhciBTU2MgPSA3O1xuXG4vLyBTdHJpbmcgbmFtZXMgZm9yIHRoZSBkaWZmZXJlbnQgc2l6ZXNcbnZhciBzaXplTmFtZXMgPSBbXG4gICAgXCJkaXNwbGF5c3R5bGUgdGV4dHN0eWxlXCIsXG4gICAgXCJ0ZXh0c3R5bGVcIixcbiAgICBcInNjcmlwdHN0eWxlXCIsXG4gICAgXCJzY3JpcHRzY3JpcHRzdHlsZVwiXG5dO1xuXG4vLyBSZXNldCBuYW1lcyBmb3IgdGhlIGRpZmZlcmVudCBzaXplc1xudmFyIHJlc2V0TmFtZXMgPSBbXG4gICAgXCJyZXNldC10ZXh0c3R5bGVcIixcbiAgICBcInJlc2V0LXRleHRzdHlsZVwiLFxuICAgIFwicmVzZXQtc2NyaXB0c3R5bGVcIixcbiAgICBcInJlc2V0LXNjcmlwdHNjcmlwdHN0eWxlXCJcbl07XG5cbi8vIEluc3RhbmNlcyBvZiB0aGUgZGlmZmVyZW50IHN0eWxlc1xudmFyIHN0eWxlcyA9IFtcbiAgICBuZXcgU3R5bGUoRCwgMCwgMS4wLCBmYWxzZSksXG4gICAgbmV3IFN0eWxlKERjLCAwLCAxLjAsIHRydWUpLFxuICAgIG5ldyBTdHlsZShULCAxLCAxLjAsIGZhbHNlKSxcbiAgICBuZXcgU3R5bGUoVGMsIDEsIDEuMCwgdHJ1ZSksXG4gICAgbmV3IFN0eWxlKFMsIDIsIDAuNywgZmFsc2UpLFxuICAgIG5ldyBTdHlsZShTYywgMiwgMC43LCB0cnVlKSxcbiAgICBuZXcgU3R5bGUoU1MsIDMsIDAuNSwgZmFsc2UpLFxuICAgIG5ldyBTdHlsZShTU2MsIDMsIDAuNSwgdHJ1ZSlcbl07XG5cbi8vIExvb2t1cCB0YWJsZXMgZm9yIHN3aXRjaGluZyBmcm9tIG9uZSBzdHlsZSB0byBhbm90aGVyXG52YXIgc3VwID0gW1MsIFNjLCBTLCBTYywgU1MsIFNTYywgU1MsIFNTY107XG52YXIgc3ViID0gW1NjLCBTYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xudmFyIGZyYWNOdW0gPSBbVCwgVGMsIFMsIFNjLCBTUywgU1NjLCBTUywgU1NjXTtcbnZhciBmcmFjRGVuID0gW1RjLCBUYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xudmFyIGNyYW1wID0gW0RjLCBEYywgVGMsIFRjLCBTYywgU2MsIFNTYywgU1NjXTtcblxuLy8gV2Ugb25seSBleHBvcnQgc29tZSBvZiB0aGUgc3R5bGVzLiBBbHNvLCB3ZSBkb24ndCBleHBvcnQgdGhlIGBTdHlsZWAgY2xhc3Mgc29cbi8vIG5vIG1vcmUgc3R5bGVzIGNhbiBiZSBnZW5lcmF0ZWQuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBESVNQTEFZOiBzdHlsZXNbRF0sXG4gICAgVEVYVDogc3R5bGVzW1RdLFxuICAgIFNDUklQVDogc3R5bGVzW1NdLFxuICAgIFNDUklQVFNDUklQVDogc3R5bGVzW1NTXVxufTtcbiIsIi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbi8qKlxuICogVGhpcyBtb2R1bGUgY29udGFpbnMgZ2VuZXJhbCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYnVpbGRpbmdcbiAqIGRpZmZlcmVudCBraW5kcyBvZiBkb21UcmVlIG5vZGVzIGluIGEgY29uc2lzdGVudCBtYW5uZXIuXG4gKi9cblxudmFyIGRvbVRyZWUgPSByZXF1aXJlKFwiLi9kb21UcmVlXCIpO1xudmFyIGZvbnRNZXRyaWNzID0gcmVxdWlyZShcIi4vZm9udE1ldHJpY3NcIik7XG52YXIgc3ltYm9scyA9IHJlcXVpcmUoXCIuL3N5bWJvbHNcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxudmFyIGdyZWVrQ2FwaXRhbHMgPSBbXG4gICAgXCJcXFxcR2FtbWFcIixcbiAgICBcIlxcXFxEZWx0YVwiLFxuICAgIFwiXFxcXFRoZXRhXCIsXG4gICAgXCJcXFxcTGFtYmRhXCIsXG4gICAgXCJcXFxcWGlcIixcbiAgICBcIlxcXFxQaVwiLFxuICAgIFwiXFxcXFNpZ21hXCIsXG4gICAgXCJcXFxcVXBzaWxvblwiLFxuICAgIFwiXFxcXFBoaVwiLFxuICAgIFwiXFxcXFBzaVwiLFxuICAgIFwiXFxcXE9tZWdhXCJcbl07XG5cbi8vIFRoZSBmb2xsb3dpbmcgaGF2ZSB0byBiZSBsb2FkZWQgZnJvbSBNYWluLUl0YWxpYyBmb250LCB1c2luZyBjbGFzcyBtYWluaXRcbnZhciBtYWluaXRMZXR0ZXJzID0gW1xuICAgIFwiXFx1MDEzMVwiLCAgIC8vIGRvdGxlc3MgaSwgXFxpbWF0aFxuICAgIFwiXFx1MDIzN1wiLCAgIC8vIGRvdGxlc3MgaiwgXFxqbWF0aFxuICAgIFwiXFx1MDBhM1wiICAgLy8gXFxwb3VuZHNcbl07XG5cbi8qKlxuICogTWFrZXMgYSBzeW1ib2xOb2RlIGFmdGVyIHRyYW5zbGF0aW9uIHZpYSB0aGUgbGlzdCBvZiBzeW1ib2xzIGluIHN5bWJvbHMuanMuXG4gKiBDb3JyZWN0bHkgcHVsbHMgb3V0IG1ldHJpY3MgZm9yIHRoZSBjaGFyYWN0ZXIsIGFuZCBvcHRpb25hbGx5IHRha2VzIGEgbGlzdCBvZlxuICogY2xhc3NlcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbm9kZS5cbiAqXG4gKiBUT0RPOiBtYWtlIGFyZ3VtZW50IG9yZGVyIGNsb3NlciB0byBtYWtlU3BhblxuICogVE9ETzogYWRkIGEgc2VwYXJhdGUgYXJndW1lbnQgZm9yIG1hdGggY2xhc3MgKGUuZy4gYG1vcGAsIGBtYmluYCksIHdoaWNoXG4gKiBzaG91bGQgaWYgcHJlc2VudCBjb21lIGZpcnN0IGluIGBjbGFzc2VzYC5cbiAqL1xudmFyIG1ha2VTeW1ib2wgPSBmdW5jdGlvbih2YWx1ZSwgZm9udEZhbWlseSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICAgIC8vIFJlcGxhY2UgdGhlIHZhbHVlIHdpdGggaXRzIHJlcGxhY2VkIHZhbHVlIGZyb20gc3ltYm9sLmpzXG4gICAgaWYgKHN5bWJvbHNbbW9kZV1bdmFsdWVdICYmIHN5bWJvbHNbbW9kZV1bdmFsdWVdLnJlcGxhY2UpIHtcbiAgICAgICAgdmFsdWUgPSBzeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlO1xuICAgIH1cblxuICAgIHZhciBtZXRyaWNzID0gZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljcyh2YWx1ZSwgZm9udEZhbWlseSk7XG5cbiAgICB2YXIgc3ltYm9sTm9kZTtcbiAgICBpZiAobWV0cmljcykge1xuICAgICAgICB2YXIgaXRhbGljID0gbWV0cmljcy5pdGFsaWM7XG4gICAgICAgIGlmIChtb2RlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgaXRhbGljID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2xOb2RlID0gbmV3IGRvbVRyZWUuc3ltYm9sTm9kZShcbiAgICAgICAgICAgIHZhbHVlLCBtZXRyaWNzLmhlaWdodCwgbWV0cmljcy5kZXB0aCwgaXRhbGljLCBtZXRyaWNzLnNrZXcsXG4gICAgICAgICAgICBjbGFzc2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPKGVtaWx5KTogRmlndXJlIG91dCBhIGdvb2Qgd2F5IHRvIG9ubHkgcHJpbnQgdGhpcyBpbiBkZXZlbG9wbWVudFxuICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIk5vIGNoYXJhY3RlciBtZXRyaWNzIGZvciAnXCIgKyB2YWx1ZSArIFwiJyBpbiBzdHlsZSAnXCIgK1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgKyBcIidcIik7XG4gICAgICAgIHN5bWJvbE5vZGUgPSBuZXcgZG9tVHJlZS5zeW1ib2xOb2RlKHZhbHVlLCAwLCAwLCAwLCAwLCBjbGFzc2VzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5zdHlsZS5pc1RpZ2h0KCkpIHtcbiAgICAgICAgICAgIHN5bWJvbE5vZGUuY2xhc3Nlcy5wdXNoKFwibXRpZ2h0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmdldENvbG9yKCkpIHtcbiAgICAgICAgICAgIHN5bWJvbE5vZGUuc3R5bGUuY29sb3IgPSBvcHRpb25zLmdldENvbG9yKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3ltYm9sTm9kZTtcbn07XG5cbi8qKlxuICogTWFrZXMgYSBzeW1ib2wgaW4gTWFpbi1SZWd1bGFyIG9yIEFNUy1SZWd1bGFyLlxuICogVXNlZCBmb3IgcmVsLCBiaW4sIG9wZW4sIGNsb3NlLCBpbm5lciwgYW5kIHB1bmN0LlxuICovXG52YXIgbWF0aHN5bSA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gICAgLy8gRGVjaWRlIHdoYXQgZm9udCB0byByZW5kZXIgdGhlIHN5bWJvbCBpbiBieSBpdHMgZW50cnkgaW4gdGhlIHN5bWJvbHNcbiAgICAvLyB0YWJsZS5cbiAgICAvLyBIYXZlIGEgc3BlY2lhbCBjYXNlIGZvciB3aGVuIHRoZSB2YWx1ZSA9IFxcIGJlY2F1c2UgdGhlIFxcIGlzIHVzZWQgYXMgYVxuICAgIC8vIHRleHRvcmQgaW4gdW5zdXBwb3J0ZWQgY29tbWFuZCBlcnJvcnMgYnV0IGNhbm5vdCBiZSBwYXJzZWQgYXMgYSByZWd1bGFyXG4gICAgLy8gdGV4dCBvcmRpbmFsIGFuZCBpcyB0aGVyZWZvcmUgbm90IHByZXNlbnQgYXMgYSBzeW1ib2wgaW4gdGhlIHN5bWJvbHNcbiAgICAvLyB0YWJsZSBmb3IgdGV4dFxuICAgIGlmICh2YWx1ZSA9PT0gXCJcXFxcXCIgfHwgc3ltYm9sc1ttb2RlXVt2YWx1ZV0uZm9udCA9PT0gXCJtYWluXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTeW1ib2wodmFsdWUsIFwiTWFpbi1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYWtlU3ltYm9sKFxuICAgICAgICAgICAgdmFsdWUsIFwiQU1TLVJlZ3VsYXJcIiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoW1wiYW1zcm1cIl0pKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2VzIGEgc3ltYm9sIGluIHRoZSBkZWZhdWx0IGZvbnQgZm9yIG1hdGhvcmRzIGFuZCB0ZXh0b3Jkcy5cbiAqL1xudmFyIG1hdGhEZWZhdWx0ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJtYXRob3JkXCIpIHtcbiAgICAgICAgcmV0dXJuIG1hdGhpdCh2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcInRleHRvcmRcIikge1xuICAgICAgICByZXR1cm4gbWFrZVN5bWJvbChcbiAgICAgICAgICAgIHZhbHVlLCBcIk1haW4tUmVndWxhclwiLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbXCJtYXRocm1cIl0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIHR5cGU6IFwiICsgdHlwZSArIFwiIGluIG1hdGhEZWZhdWx0XCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTWFrZXMgYSBzeW1ib2wgaW4gdGhlIGl0YWxpYyBtYXRoIGZvbnQuXG4gKi9cbnZhciBtYXRoaXQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICAgIGlmICgvWzAtOV0vLnRlc3QodmFsdWUuY2hhckF0KDApKSB8fFxuICAgICAgICAgICAgLy8gZ2x5cGhzIGZvciBcXGltYXRoIGFuZCBcXGptYXRoIGRvIG5vdCBleGlzdCBpbiBNYXRoLUl0YWxpYyBzbyB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byB1c2UgTWFpbi1JdGFsaWMgaW5zdGVhZFxuICAgICAgICAgICAgdXRpbHMuY29udGFpbnMobWFpbml0TGV0dGVycywgdmFsdWUpIHx8XG4gICAgICAgICAgICB1dGlscy5jb250YWlucyhncmVla0NhcGl0YWxzLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTeW1ib2woXG4gICAgICAgICAgICB2YWx1ZSwgXCJNYWluLUl0YWxpY1wiLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbXCJtYWluaXRcIl0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWFrZVN5bWJvbChcbiAgICAgICAgICAgIHZhbHVlLCBcIk1hdGgtSXRhbGljXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFtcIm1hdGhpdFwiXSkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTWFrZXMgZWl0aGVyIGEgbWF0aG9yZCBvciB0ZXh0b3JkIGluIHRoZSBjb3JyZWN0IGZvbnQgYW5kIGNvbG9yLlxuICovXG52YXIgbWFrZU9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zLCB0eXBlKSB7XG4gICAgdmFyIG1vZGUgPSBncm91cC5tb2RlO1xuICAgIHZhciB2YWx1ZSA9IGdyb3VwLnZhbHVlO1xuICAgIGlmIChzeW1ib2xzW21vZGVdW3ZhbHVlXSAmJiBzeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlKSB7XG4gICAgICAgIHZhbHVlID0gc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZTtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NlcyA9IFtcIm1vcmRcIl07XG5cbiAgICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgICBpZiAoZm9udCkge1xuICAgICAgICBpZiAoZm9udCA9PT0gXCJtYXRoaXRcIiB8fCB1dGlscy5jb250YWlucyhtYWluaXRMZXR0ZXJzLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoaXQodmFsdWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZvbnROYW1lID0gZm9udE1hcFtmb250XS5mb250TmFtZTtcbiAgICAgICAgICAgIGlmIChmb250TWV0cmljcy5nZXRDaGFyYWN0ZXJNZXRyaWNzKHZhbHVlLCBmb250TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVN5bWJvbChcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsIGZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbZm9udF0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGhEZWZhdWx0KHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYXRoRGVmYXVsdCh2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3NlcywgdHlwZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGhlaWdodCwgZGVwdGgsIGFuZCBtYXhGb250U2l6ZSBvZiBhbiBlbGVtZW50IGJhc2VkIG9uIGl0c1xuICogY2hpbGRyZW4uXG4gKi9cbnZhciBzaXplRWxlbWVudEZyb21DaGlsZHJlbiA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHZhciBtYXhGb250U2l6ZSA9IDA7XG5cbiAgICBpZiAoZWxlbS5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW0uY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlbGVtLmNoaWxkcmVuW2ldLmhlaWdodCA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGVsZW0uY2hpbGRyZW5baV0uaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW0uY2hpbGRyZW5baV0uZGVwdGggPiBkZXB0aCkge1xuICAgICAgICAgICAgICAgIGRlcHRoID0gZWxlbS5jaGlsZHJlbltpXS5kZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtLmNoaWxkcmVuW2ldLm1heEZvbnRTaXplID4gbWF4Rm9udFNpemUpIHtcbiAgICAgICAgICAgICAgICBtYXhGb250U2l6ZSA9IGVsZW0uY2hpbGRyZW5baV0ubWF4Rm9udFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtLmhlaWdodCA9IGhlaWdodDtcbiAgICBlbGVtLmRlcHRoID0gZGVwdGg7XG4gICAgZWxlbS5tYXhGb250U2l6ZSA9IG1heEZvbnRTaXplO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIHNwYW4gd2l0aCB0aGUgZ2l2ZW4gbGlzdCBvZiBjbGFzc2VzLCBsaXN0IG9mIGNoaWxkcmVuLCBhbmQgb3B0aW9ucy5cbiAqXG4gKiBUT0RPOiBFbnN1cmUgdGhhdCBgb3B0aW9uc2AgaXMgYWx3YXlzIHByb3ZpZGVkIChjdXJyZW50bHkgc29tZSBjYWxsIHNpdGVzXG4gKiBkb24ndCBwYXNzIGl0KS5cbiAqIFRPRE86IGFkZCBhIHNlcGFyYXRlIGFyZ3VtZW50IGZvciBtYXRoIGNsYXNzIChlLmcuIGBtb3BgLCBgbWJpbmApLCB3aGljaFxuICogc2hvdWxkIGlmIHByZXNlbnQgY29tZSBmaXJzdCBpbiBgY2xhc3Nlc2AuXG4gKi9cbnZhciBtYWtlU3BhbiA9IGZ1bmN0aW9uKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gICAgdmFyIHNwYW4gPSBuZXcgZG9tVHJlZS5zcGFuKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKTtcblxuICAgIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKHNwYW4pO1xuXG4gICAgcmV0dXJuIHNwYW47XG59O1xuXG4vKipcbiAqIFByZXBlbmRzIHRoZSBnaXZlbiBjaGlsZHJlbiB0byB0aGUgZ2l2ZW4gc3BhbiwgdXBkYXRpbmcgaGVpZ2h0LCBkZXB0aCwgYW5kXG4gKiBtYXhGb250U2l6ZS5cbiAqL1xudmFyIHByZXBlbmRDaGlsZHJlbiA9IGZ1bmN0aW9uKHNwYW4sIGNoaWxkcmVuKSB7XG4gICAgc3Bhbi5jaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdChzcGFuLmNoaWxkcmVuKTtcblxuICAgIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKHNwYW4pO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIGRvY3VtZW50IGZyYWdtZW50IHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgY2hpbGRyZW4uXG4gKi9cbnZhciBtYWtlRnJhZ21lbnQgPSBmdW5jdGlvbihjaGlsZHJlbikge1xuICAgIHZhciBmcmFnbWVudCA9IG5ldyBkb21UcmVlLmRvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pO1xuXG4gICAgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oZnJhZ21lbnQpO1xuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xufTtcblxuLyoqXG4gKiBNYWtlcyBhbiBlbGVtZW50IHBsYWNlZCBpbiBlYWNoIG9mIHRoZSB2bGlzdCBlbGVtZW50cyB0byBlbnN1cmUgdGhhdCBlYWNoXG4gKiBlbGVtZW50IGhhcyB0aGUgc2FtZSBtYXggZm9udCBzaXplLiBUbyBkbyB0aGlzLCB3ZSBjcmVhdGUgYSB6ZXJvLXdpZHRoIHNwYWNlXG4gKiB3aXRoIHRoZSBjb3JyZWN0IGZvbnQgc2l6ZS5cbiAqL1xudmFyIG1ha2VGb250U2l6ZXIgPSBmdW5jdGlvbihvcHRpb25zLCBmb250U2l6ZSkge1xuICAgIHZhciBmb250U2l6ZUlubmVyID0gbWFrZVNwYW4oW10sIFtuZXcgZG9tVHJlZS5zeW1ib2xOb2RlKFwiXFx1MjAwYlwiKV0pO1xuICAgIGZvbnRTaXplSW5uZXIuc3R5bGUuZm9udFNpemUgPVxuICAgICAgICAoZm9udFNpemUgLyBvcHRpb25zLnN0eWxlLnNpemVNdWx0aXBsaWVyKSArIFwiZW1cIjtcblxuICAgIHZhciBmb250U2l6ZXIgPSBtYWtlU3BhbihcbiAgICAgICAgW1wiZm9udHNpemUtZW5zdXJlclwiLCBcInJlc2V0LVwiICsgb3B0aW9ucy5zaXplLCBcInNpemU1XCJdLFxuICAgICAgICBbZm9udFNpemVJbm5lcl0pO1xuXG4gICAgcmV0dXJuIGZvbnRTaXplcjtcbn07XG5cbi8qKlxuICogTWFrZXMgYSB2ZXJ0aWNhbCBsaXN0IGJ5IHN0YWNraW5nIGVsZW1lbnRzIGFuZCBrZXJucyBvbiB0b3Agb2YgZWFjaCBvdGhlci5cbiAqIEFsbG93cyBmb3IgbWFueSBkaWZmZXJlbnQgd2F5cyBvZiBzcGVjaWZ5aW5nIHRoZSBwb3NpdGlvbmluZyBtZXRob2QuXG4gKlxuICogQXJndW1lbnRzOlxuICogIC0gY2hpbGRyZW46IEEgbGlzdCBvZiBjaGlsZCBvciBrZXJuIG5vZGVzIHRvIGJlIHN0YWNrZWQgb24gdG9wIG9mIGVhY2ggb3RoZXJcbiAqICAgICAgICAgICAgICAoaS5lLiB0aGUgZmlyc3QgZWxlbWVudCB3aWxsIGJlIGF0IHRoZSBib3R0b20sIGFuZCB0aGUgbGFzdCBhdFxuICogICAgICAgICAgICAgIHRoZSB0b3ApLiBFbGVtZW50IG5vZGVzIGFyZSBzcGVjaWZpZWQgYXNcbiAqICAgICAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogbm9kZX1cbiAqICAgICAgICAgICAgICB3aGlsZSBrZXJuIG5vZGVzIGFyZSBzcGVjaWZpZWQgYXNcbiAqICAgICAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogc2l6ZX1cbiAqICAtIHBvc2l0aW9uVHlwZTogVGhlIG1ldGhvZCBieSB3aGljaCB0aGUgdmxpc3Qgc2hvdWxkIGJlIHBvc2l0aW9uZWQuIFZhbGlkXG4gKiAgICAgICAgICAgICAgICAgIHZhbHVlcyBhcmU6XG4gKiAgICAgICAgICAgICAgICAgICAtIFwiaW5kaXZpZHVhbFNoaWZ0XCI6IFRoZSBjaGlsZHJlbiBsaXN0IG9ubHkgY29udGFpbnMgZWxlbVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMsIGFuZCBlYWNoIG5vZGUgY29udGFpbnMgYW4gZXh0cmFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2hpZnRcIiB2YWx1ZSBvZiBob3cgbXVjaCBpdCBzaG91bGQgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ZWQgKG5vdGUgdGhhdCBzaGlmdGluZyBpcyBhbHdheXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmluZyBkb3dud2FyZHMpLiBwb3NpdGlvbkRhdGEgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZWQuXG4gKiAgICAgICAgICAgICAgICAgICAtIFwidG9wXCI6IFRoZSBwb3NpdGlvbkRhdGEgc3BlY2lmaWVzIHRoZSB0b3Btb3N0IHBvaW50IG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdmxpc3QgKG5vdGUgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhIGhlaWdodCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvIHBvc2l0aXZlIHZhbHVlcyBtb3ZlIHVwKVxuICogICAgICAgICAgICAgICAgICAgLSBcImJvdHRvbVwiOiBUaGUgcG9zaXRpb25EYXRhIHNwZWNpZmllcyB0aGUgYm90dG9tbW9zdCBwb2ludFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIHZsaXN0IChub3RlIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgsIHNvIHBvc2l0aXZlIHZhbHVlcyBtb3ZlIGRvd25cbiAqICAgICAgICAgICAgICAgICAgIC0gXCJzaGlmdFwiOiBUaGUgdmxpc3Qgd2lsbCBiZSBwb3NpdGlvbmVkIHN1Y2ggdGhhdCBpdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmUgaXMgcG9zaXRpb25EYXRhIGF3YXkgZnJvbSB0aGUgYmFzZWxpbmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGZpcnN0IGNoaWxkLiBQb3NpdGl2ZSB2YWx1ZXMgbW92ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3dud2FyZHMuXG4gKiAgICAgICAgICAgICAgICAgICAtIFwiZmlyc3RCYXNlbGluZVwiOiBUaGUgdmxpc3Qgd2lsbCBiZSBwb3NpdGlvbmVkIHN1Y2ggdGhhdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0cyBiYXNlbGluZSBpcyBhbGlnbmVkIHdpdGggdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmUgb2YgdGhlIGZpcnN0IGNoaWxkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uRGF0YSBpcyBpZ25vcmVkLiAodGhpcyBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gXCJzaGlmdFwiIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkRhdGE9MClcbiAqICAtIHBvc2l0aW9uRGF0YTogRGF0YSB1c2VkIGluIGRpZmZlcmVudCB3YXlzIGRlcGVuZGluZyBvbiBwb3NpdGlvblR5cGVcbiAqICAtIG9wdGlvbnM6IEFuIE9wdGlvbnMgb2JqZWN0XG4gKlxuICovXG52YXIgbWFrZVZMaXN0ID0gZnVuY3Rpb24oY2hpbGRyZW4sIHBvc2l0aW9uVHlwZSwgcG9zaXRpb25EYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIGRlcHRoO1xuICAgIHZhciBjdXJyUG9zO1xuICAgIHZhciBpO1xuICAgIGlmIChwb3NpdGlvblR5cGUgPT09IFwiaW5kaXZpZHVhbFNoaWZ0XCIpIHtcbiAgICAgICAgdmFyIG9sZENoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIGNoaWxkcmVuID0gW29sZENoaWxkcmVuWzBdXTtcblxuICAgICAgICAvLyBBZGQgaW4ga2VybnMgdG8gdGhlIGxpc3Qgb2YgY2hpbGRyZW4gdG8gZ2V0IGVhY2ggZWxlbWVudCB0byBiZVxuICAgICAgICAvLyBzaGlmdGVkIHRvIHRoZSBjb3JyZWN0IHNwZWNpZmllZCBzaGlmdFxuICAgICAgICBkZXB0aCA9IC1vbGRDaGlsZHJlblswXS5zaGlmdCAtIG9sZENoaWxkcmVuWzBdLmVsZW0uZGVwdGg7XG4gICAgICAgIGN1cnJQb3MgPSBkZXB0aDtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IC1vbGRDaGlsZHJlbltpXS5zaGlmdCAtIGN1cnJQb3MgLVxuICAgICAgICAgICAgICAgIG9sZENoaWxkcmVuW2ldLmVsZW0uZGVwdGg7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGRpZmYgLVxuICAgICAgICAgICAgICAgIChvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5oZWlnaHQgK1xuICAgICAgICAgICAgICAgICBvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5kZXB0aCk7XG5cbiAgICAgICAgICAgIGN1cnJQb3MgPSBjdXJyUG9zICsgZGlmZjtcblxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh7dHlwZTogXCJrZXJuXCIsIHNpemU6IHNpemV9KTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gob2xkQ2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblR5cGUgPT09IFwidG9wXCIpIHtcbiAgICAgICAgLy8gV2UgYWx3YXlzIHN0YXJ0IGF0IHRoZSBib3R0b20sIHNvIGNhbGN1bGF0ZSB0aGUgYm90dG9tIGJ5IGFkZGluZyB1cFxuICAgICAgICAvLyBhbGwgdGhlIHNpemVzXG4gICAgICAgIHZhciBib3R0b20gPSBwb3NpdGlvbkRhdGE7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IFwia2VyblwiKSB7XG4gICAgICAgICAgICAgICAgYm90dG9tIC09IGNoaWxkcmVuW2ldLnNpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvdHRvbSAtPSBjaGlsZHJlbltpXS5lbGVtLmhlaWdodCArIGNoaWxkcmVuW2ldLmVsZW0uZGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVwdGggPSBib3R0b207XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblR5cGUgPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgZGVwdGggPSAtcG9zaXRpb25EYXRhO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb25UeXBlID09PSBcInNoaWZ0XCIpIHtcbiAgICAgICAgZGVwdGggPSAtY2hpbGRyZW5bMF0uZWxlbS5kZXB0aCAtIHBvc2l0aW9uRGF0YTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uVHlwZSA9PT0gXCJmaXJzdEJhc2VsaW5lXCIpIHtcbiAgICAgICAgZGVwdGggPSAtY2hpbGRyZW5bMF0uZWxlbS5kZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgfVxuXG4gICAgLy8gTWFrZSB0aGUgZm9udFNpemVyXG4gICAgdmFyIG1heEZvbnRTaXplID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IFwiZWxlbVwiKSB7XG4gICAgICAgICAgICBtYXhGb250U2l6ZSA9IE1hdGgubWF4KG1heEZvbnRTaXplLCBjaGlsZHJlbltpXS5lbGVtLm1heEZvbnRTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZm9udFNpemVyID0gbWFrZUZvbnRTaXplcihvcHRpb25zLCBtYXhGb250U2l6ZSk7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgbGlzdCBvZiBhY3R1YWwgY2hpbGRyZW4gYXQgdGhlIGNvcnJlY3Qgb2Zmc2V0c1xuICAgIHZhciByZWFsQ2hpbGRyZW4gPSBbXTtcbiAgICBjdXJyUG9zID0gZGVwdGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSBcImtlcm5cIikge1xuICAgICAgICAgICAgY3VyclBvcyArPSBjaGlsZHJlbltpXS5zaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV0uZWxlbTtcblxuICAgICAgICAgICAgdmFyIHNoaWZ0ID0gLWNoaWxkLmRlcHRoIC0gY3VyclBvcztcbiAgICAgICAgICAgIGN1cnJQb3MgKz0gY2hpbGQuaGVpZ2h0ICsgY2hpbGQuZGVwdGg7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZFdyYXAgPSBtYWtlU3BhbihbXSwgW2ZvbnRTaXplciwgY2hpbGRdKTtcbiAgICAgICAgICAgIGNoaWxkV3JhcC5oZWlnaHQgLT0gc2hpZnQ7XG4gICAgICAgICAgICBjaGlsZFdyYXAuZGVwdGggKz0gc2hpZnQ7XG4gICAgICAgICAgICBjaGlsZFdyYXAuc3R5bGUudG9wID0gc2hpZnQgKyBcImVtXCI7XG5cbiAgICAgICAgICAgIHJlYWxDaGlsZHJlbi5wdXNoKGNoaWxkV3JhcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaW4gYW4gZWxlbWVudCBhdCB0aGUgZW5kIHdpdGggbm8gb2Zmc2V0IHRvIGZpeCB0aGUgY2FsY3VsYXRpb24gb2ZcbiAgICAvLyBiYXNlbGluZXMgaW4gc29tZSBicm93c2VycyAobmFtZWx5IElFLCBzb21ldGltZXMgc2FmYXJpKVxuICAgIHZhciBiYXNlbGluZUZpeCA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJiYXNlbGluZS1maXhcIl0sIFtmb250U2l6ZXIsIG5ldyBkb21UcmVlLnN5bWJvbE5vZGUoXCJcXHUyMDBiXCIpXSk7XG4gICAgcmVhbENoaWxkcmVuLnB1c2goYmFzZWxpbmVGaXgpO1xuXG4gICAgdmFyIHZsaXN0ID0gbWFrZVNwYW4oW1widmxpc3RcIl0sIHJlYWxDaGlsZHJlbik7XG4gICAgLy8gRml4IHRoZSBmaW5hbCBoZWlnaHQgYW5kIGRlcHRoLCBpbiBjYXNlIHRoZXJlIHdlcmUga2VybnMgYXQgdGhlIGVuZHNcbiAgICAvLyBzaW5jZSB0aGUgbWFrZVNwYW4gY2FsY3VsYXRpb24gd29uJ3QgdGFrZSB0aGF0IGluIHRvIGFjY291bnQuXG4gICAgdmxpc3QuaGVpZ2h0ID0gTWF0aC5tYXgoY3VyclBvcywgdmxpc3QuaGVpZ2h0KTtcbiAgICB2bGlzdC5kZXB0aCA9IE1hdGgubWF4KC1kZXB0aCwgdmxpc3QuZGVwdGgpO1xuICAgIHJldHVybiB2bGlzdDtcbn07XG5cbi8vIEEgdGFibGUgb2Ygc2l6ZSAtPiBmb250IHNpemUgZm9yIHRoZSBkaWZmZXJlbnQgc2l6aW5nIGZ1bmN0aW9uc1xudmFyIHNpemluZ011bHRpcGxpZXIgPSB7XG4gICAgc2l6ZTE6IDAuNSxcbiAgICBzaXplMjogMC43LFxuICAgIHNpemUzOiAwLjgsXG4gICAgc2l6ZTQ6IDAuOSxcbiAgICBzaXplNTogMS4wLFxuICAgIHNpemU2OiAxLjIsXG4gICAgc2l6ZTc6IDEuNDQsXG4gICAgc2l6ZTg6IDEuNzMsXG4gICAgc2l6ZTk6IDIuMDcsXG4gICAgc2l6ZTEwOiAyLjQ5XG59O1xuXG4vLyBBIG1hcCBvZiBzcGFjaW5nIGZ1bmN0aW9ucyB0byB0aGVpciBhdHRyaWJ1dGVzLCBsaWtlIHNpemUgYW5kIGNvcnJlc3BvbmRpbmdcbi8vIENTUyBjbGFzc1xudmFyIHNwYWNpbmdGdW5jdGlvbnMgPSB7XG4gICAgXCJcXFxccXF1YWRcIjoge1xuICAgICAgICBzaXplOiBcIjJlbVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwicXF1YWRcIlxuICAgIH0sXG4gICAgXCJcXFxccXVhZFwiOiB7XG4gICAgICAgIHNpemU6IFwiMWVtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJxdWFkXCJcbiAgICB9LFxuICAgIFwiXFxcXGVuc3BhY2VcIjoge1xuICAgICAgICBzaXplOiBcIjAuNWVtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJlbnNwYWNlXCJcbiAgICB9LFxuICAgIFwiXFxcXDtcIjoge1xuICAgICAgICBzaXplOiBcIjAuMjc3Nzc4ZW1cIixcbiAgICAgICAgY2xhc3NOYW1lOiBcInRoaWNrc3BhY2VcIlxuICAgIH0sXG4gICAgXCJcXFxcOlwiOiB7XG4gICAgICAgIHNpemU6IFwiMC4yMjIyMmVtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJtZWRpdW1zcGFjZVwiXG4gICAgfSxcbiAgICBcIlxcXFwsXCI6IHtcbiAgICAgICAgc2l6ZTogXCIwLjE2NjY3ZW1cIixcbiAgICAgICAgY2xhc3NOYW1lOiBcInRoaW5zcGFjZVwiXG4gICAgfSxcbiAgICBcIlxcXFwhXCI6IHtcbiAgICAgICAgc2l6ZTogXCItMC4xNjY2N2VtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJuZWdhdGl2ZXRoaW5zcGFjZVwiXG4gICAgfVxufTtcblxuLyoqXG4gKiBNYXBzIFRlWCBmb250IGNvbW1hbmRzIHRvIG9iamVjdHMgY29udGFpbmluZzpcbiAqIC0gdmFyaWFudDogc3RyaW5nIHVzZWQgZm9yIFwibWF0aHZhcmlhbnRcIiBhdHRyaWJ1dGUgaW4gYnVpbGRNYXRoTUwuanNcbiAqIC0gZm9udE5hbWU6IHRoZSBcInN0eWxlXCIgcGFyYW1ldGVyIHRvIGZvbnRNZXRyaWNzLmdldENoYXJhY3Rlck1ldHJpY3NcbiAqL1xuLy8gQSBtYXAgYmV0d2VlbiB0ZXggZm9udCBjb21tYW5kcyBhbiBNYXRoTUwgbWF0aHZhcmlhbnQgYXR0cmlidXRlIHZhbHVlc1xudmFyIGZvbnRNYXAgPSB7XG4gICAgLy8gc3R5bGVzXG4gICAgXCJtYXRoYmZcIjoge1xuICAgICAgICB2YXJpYW50OiBcImJvbGRcIixcbiAgICAgICAgZm9udE5hbWU6IFwiTWFpbi1Cb2xkXCJcbiAgICB9LFxuICAgIFwibWF0aHJtXCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJub3JtYWxcIixcbiAgICAgICAgZm9udE5hbWU6IFwiTWFpbi1SZWd1bGFyXCJcbiAgICB9LFxuICAgIFwidGV4dGl0XCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJpdGFsaWNcIixcbiAgICAgICAgZm9udE5hbWU6IFwiTWFpbi1JdGFsaWNcIlxuICAgIH0sXG5cbiAgICAvLyBcIm1hdGhpdFwiIGlzIG1pc3NpbmcgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgdXNlIG9mIHR3byBmb250czogTWFpbi1JdGFsaWNcbiAgICAvLyBhbmQgTWF0aC1JdGFsaWMuICBUaGlzIGlzIGhhbmRsZWQgYnkgYSBzcGVjaWFsIGNhc2UgaW4gbWFrZU9yZCB3aGljaCBlbmRzXG4gICAgLy8gdXAgY2FsbGluZyBtYXRoaXQuXG5cbiAgICAvLyBmYW1pbGllc1xuICAgIFwibWF0aGJiXCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJkb3VibGUtc3RydWNrXCIsXG4gICAgICAgIGZvbnROYW1lOiBcIkFNUy1SZWd1bGFyXCJcbiAgICB9LFxuICAgIFwibWF0aGNhbFwiOiB7XG4gICAgICAgIHZhcmlhbnQ6IFwic2NyaXB0XCIsXG4gICAgICAgIGZvbnROYW1lOiBcIkNhbGlncmFwaGljLVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRoZnJha1wiOiB7XG4gICAgICAgIHZhcmlhbnQ6IFwiZnJha3R1clwiLFxuICAgICAgICBmb250TmFtZTogXCJGcmFrdHVyLVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRoc2NyXCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJzY3JpcHRcIixcbiAgICAgICAgZm9udE5hbWU6IFwiU2NyaXB0LVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRoc2ZcIjoge1xuICAgICAgICB2YXJpYW50OiBcInNhbnMtc2VyaWZcIixcbiAgICAgICAgZm9udE5hbWU6IFwiU2Fuc1NlcmlmLVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRodHRcIjoge1xuICAgICAgICB2YXJpYW50OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICBmb250TmFtZTogXCJUeXBld3JpdGVyLVJlZ3VsYXJcIlxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvbnRNYXA6IGZvbnRNYXAsXG4gICAgbWFrZVN5bWJvbDogbWFrZVN5bWJvbCxcbiAgICBtYXRoc3ltOiBtYXRoc3ltLFxuICAgIG1ha2VTcGFuOiBtYWtlU3BhbixcbiAgICBtYWtlRnJhZ21lbnQ6IG1ha2VGcmFnbWVudCxcbiAgICBtYWtlVkxpc3Q6IG1ha2VWTGlzdCxcbiAgICBtYWtlT3JkOiBtYWtlT3JkLFxuICAgIHByZXBlbmRDaGlsZHJlbjogcHJlcGVuZENoaWxkcmVuLFxuICAgIHNpemluZ011bHRpcGxpZXI6IHNpemluZ011bHRpcGxpZXIsXG4gICAgc3BhY2luZ0Z1bmN0aW9uczogc3BhY2luZ0Z1bmN0aW9uc1xufTtcbiIsIi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbi8qKlxuICogVGhpcyBmaWxlIGRvZXMgdGhlIG1haW4gd29yayBvZiBidWlsZGluZyBhIGRvbVRyZWUgc3RydWN0dXJlIGZyb20gYSBwYXJzZVxuICogdHJlZS4gVGhlIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRIVE1MYCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwYXJzZSB0cmVlLlxuICogVGhlbiwgdGhlIGJ1aWxkRXhwcmVzc2lvbiwgYnVpbGRHcm91cCwgYW5kIHZhcmlvdXMgZ3JvdXBUeXBlcyBmdW5jdGlvbnMgYXJlXG4gKiBjYWxsZWQsIHRvIHByb2R1Y2UgYSBmaW5hbCBIVE1MIHRyZWUuXG4gKi9cblxudmFyIFBhcnNlRXJyb3IgPSByZXF1aXJlKFwiLi9QYXJzZUVycm9yXCIpO1xudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vU3R5bGVcIik7XG5cbnZhciBidWlsZENvbW1vbiA9IHJlcXVpcmUoXCIuL2J1aWxkQ29tbW9uXCIpO1xudmFyIGRlbGltaXRlciA9IHJlcXVpcmUoXCIuL2RlbGltaXRlclwiKTtcbnZhciBkb21UcmVlID0gcmVxdWlyZShcIi4vZG9tVHJlZVwiKTtcbnZhciBmb250TWV0cmljcyA9IHJlcXVpcmUoXCIuL2ZvbnRNZXRyaWNzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbnZhciBtYWtlU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuO1xuXG52YXIgaXNTcGFjZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIGRvbVRyZWUuc3BhbiAmJiBub2RlLmNsYXNzZXNbMF0gPT09IFwibXNwYWNlXCI7XG59O1xuXG4vLyBCaW5hcnkgYXRvbXMgKGZpcnN0IGNsYXNzIGBtYmluYCkgY2hhbmdlIGludG8gb3JkaW5hcnkgYXRvbXMgKGBtb3JkYClcbi8vIGRlcGVuZGluZyBvbiB0aGVpciBzdXJyb3VuZGluZ3MuIFNlZSBUZVhib29rIHBnLiA0NDItNDQ2LCBSdWxlcyA1IGFuZCA2LFxuLy8gYW5kIHRoZSB0ZXh0IGJlZm9yZSBSdWxlIDE5LlxuXG52YXIgaXNCaW4gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5jbGFzc2VzWzBdID09PSBcIm1iaW5cIjtcbn07XG5cbnZhciBpc0JpbkxlZnRDYW5jZWxsZXIgPSBmdW5jdGlvbihub2RlLCBpc1JlYWxHcm91cCkge1xuICAgIC8vIFRPRE86IFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgYSBub2RlJ3MgbWF0aCBjbGFzcyBpcyB0aGUgZmlyc3QgZWxlbWVudFxuICAgIC8vIG9mIGl0cyBgY2xhc3Nlc2AgYXJyYXkuIEEgbGF0ZXIgY2xlYW51cCBzaG91bGQgZW5zdXJlIHRoaXMsIGZvclxuICAgIC8vIGluc3RhbmNlIGJ5IGNoYW5naW5nIHRoZSBzaWduYXR1cmUgb2YgYG1ha2VTcGFuYC5cbiAgICBpZiAobm9kZSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuY29udGFpbnMoW1wibWJpblwiLCBcIm1vcGVuXCIsIFwibXJlbFwiLCBcIm1vcFwiLCBcIm1wdW5jdFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3Nlc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzUmVhbEdyb3VwO1xuICAgIH1cbn07XG5cbnZhciBpc0JpblJpZ2h0Q2FuY2VsbGVyID0gZnVuY3Rpb24obm9kZSwgaXNSZWFsR3JvdXApIHtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuY29udGFpbnMoW1wibXJlbFwiLCBcIm1jbG9zZVwiLCBcIm1wdW5jdFwiXSwgbm9kZS5jbGFzc2VzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNSZWFsR3JvdXA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUYWtlIGEgbGlzdCBvZiBub2RlcywgYnVpbGQgdGhlbSBpbiBvcmRlciwgYW5kIHJldHVybiBhIGxpc3Qgb2YgdGhlIGJ1aWx0XG4gKiBub2Rlcy4gZG9jdW1lbnRGcmFnbWVudHMgYXJlIGZsYXR0ZW5lZCBpbnRvIHRoZWlyIGNvbnRlbnRzLCBzbyB0aGVcbiAqIHJldHVybmVkIGxpc3QgY29udGFpbnMgbm8gZnJhZ21lbnRzLiBgaXNSZWFsR3JvdXBgIGlzIHRydWUgaWYgYGV4cHJlc3Npb25gXG4gKiBpcyBhIHJlYWwgZ3JvdXAgKG5vIGF0b21zIHdpbGwgYmUgYWRkZWQgb24gZWl0aGVyIHNpZGUpLCBhcyBvcHBvc2VkIHRvXG4gKiBhIHBhcnRpYWwgZ3JvdXAgKGUuZy4gb25lIGNyZWF0ZWQgYnkgXFxjb2xvcikuXG4gKi9cbnZhciBidWlsZEV4cHJlc3Npb24gPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zLCBpc1JlYWxHcm91cCkge1xuICAgIC8vIFBhcnNlIGV4cHJlc3Npb25zIGludG8gYGdyb3Vwc2AuXG4gICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBleHByZXNzaW9uW2ldO1xuICAgICAgICB2YXIgb3V0cHV0ID0gYnVpbGRHcm91cChncm91cCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvdXRwdXQgaW5zdGFuY2VvZiBkb21UcmVlLmRvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGdyb3Vwcywgb3V0cHV0LmNoaWxkcmVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCBgZ3JvdXBzYCBjb25zaXN0cyBlbnRpcmVseSBvZiBgc3ltYm9sTm9kZWBzIGFuZCBgc3BhbmBzLlxuXG4gICAgLy8gRXhwbGljaXQgc3BhY2VzIChlLmcuLCBcXDssIFxcLCkgc2hvdWxkIGJlIGlnbm9yZWQgd2l0aCByZXNwZWN0IHRvIGF0b21cbiAgICAvLyBzcGFjaW5nIChlLmcuLCBcImFkZCB0aGljayBzcGFjZSBiZXR3ZWVuIG1vcmQgYW5kIG1yZWxcIikuIFNpbmNlIENTU1xuICAgIC8vIGFkamFjZW5jeSBydWxlcyBpbXBsZW1lbnQgYXRvbSBzcGFjaW5nLCBzcGFjZXMgc2hvdWxkIGJlIGludmlzaWJsZSB0b1xuICAgIC8vIENTUy4gU28gd2Ugc3BsaWNlIHRoZW0gb3V0IG9mIGBncm91cHNgIGFuZCBpbnRvIHRoZSBhdG9tcyB0aGVtc2VsdmVzLlxuICAgIHZhciBzcGFjZXMgPSBudWxsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzU3BhY2UoZ3JvdXBzW2ldKSkge1xuICAgICAgICAgICAgc3BhY2VzID0gc3BhY2VzIHx8IFtdO1xuICAgICAgICAgICAgc3BhY2VzLnB1c2goZ3JvdXBzW2ldKTtcbiAgICAgICAgICAgIGdyb3Vwcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH0gZWxzZSBpZiAoc3BhY2VzKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXBzW2ldIGluc3RhbmNlb2YgZG9tVHJlZS5zeW1ib2xOb2RlKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW2ldID0gbWFrZVNwYW4oW10uY29uY2F0KGdyb3Vwc1tpXS5jbGFzc2VzKSwgW2dyb3Vwc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVpbGRDb21tb24ucHJlcGVuZENoaWxkcmVuKGdyb3Vwc1tpXSwgc3BhY2VzKTtcbiAgICAgICAgICAgIHNwYWNlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNwYWNlcykge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShncm91cHMsIHNwYWNlcyk7XG4gICAgfVxuXG4gICAgLy8gQmluYXJ5IG9wZXJhdG9ycyBjaGFuZ2UgdG8gb3JkaW5hcnkgc3ltYm9scyBpbiBzb21lIGNvbnRleHRzLlxuICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzQmluKGdyb3Vwc1tpXSlcbiAgICAgICAgICAgICYmIChpc0JpbkxlZnRDYW5jZWxsZXIoZ3JvdXBzW2kgLSAxXSwgaXNSZWFsR3JvdXApXG4gICAgICAgICAgICAgICAgfHwgaXNCaW5SaWdodENhbmNlbGxlcihncm91cHNbaSArIDFdLCBpc1JlYWxHcm91cCkpKSB7XG4gICAgICAgICAgICBncm91cHNbaV0uY2xhc3Nlc1swXSA9IFwibW9yZFwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3Vwcztcbn07XG5cbi8vIFJldHVybiBtYXRoIGF0b20gY2xhc3MgKG1jbGFzcykgb2YgYSBkb21UcmVlLlxudmFyIGdldFR5cGVPZkRvbVRyZWUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBkb21UcmVlLmRvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VHlwZU9mRG9tVHJlZShcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHV0aWxzLmNvbnRhaW5zKFtcIm1vcmRcIiwgXCJtb3BcIiwgXCJtYmluXCIsIFwibXJlbFwiLCBcIm1vcGVuXCIsIFwibWNsb3NlXCIsXG4gICAgICAgICAgICBcIm1wdW5jdFwiLCBcIm1pbm5lclwiXSwgbm9kZS5jbGFzc2VzWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2xhc3Nlc1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogc3Vic2NyaXB0cyBhdHRhY2hlZCB0byB0aGVtLiBUaGlzIGZ1bmN0aW9uIGxldHMgdGhlIGBzdXBzdWJgIGdyb3VwIGtub3cgdGhhdFxuICogaXRzIGlubmVyIGVsZW1lbnQgc2hvdWxkIGhhbmRsZSB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGluc3RlYWQgb2ZcbiAqIGhhbmRsaW5nIHRoZW0gaXRzZWxmLlxuICovXG52YXIgc2hvdWxkSGFuZGxlU3VwU3ViID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwib3BcIikge1xuICAgICAgICAvLyBPcGVyYXRvcnMgaGFuZGxlIHN1cHN1YnMgZGlmZmVyZW50bHkgd2hlbiB0aGV5IGhhdmUgbGltaXRzXG4gICAgICAgIC8vIChlLmcuIGBcXGRpc3BsYXlzdHlsZVxcc3VtXzJeM2ApXG4gICAgICAgIHJldHVybiBncm91cC52YWx1ZS5saW1pdHMgJiZcbiAgICAgICAgICAgIChvcHRpb25zLnN0eWxlLnNpemUgPT09IFN0eWxlLkRJU1BMQVkuc2l6ZSB8fFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUuYWx3YXlzSGFuZGxlU3VwU3ViKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiYWNjZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIGlzQ2hhcmFjdGVyQm94KGdyb3VwLnZhbHVlLmJhc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogU29tZXRpbWVzIHdlIHdhbnQgdG8gcHVsbCBvdXQgdGhlIGlubmVybW9zdCBlbGVtZW50IG9mIGEgZ3JvdXAuIEluIG1vc3RcbiAqIGNhc2VzLCB0aGlzIHdpbGwganVzdCBiZSB0aGUgZ3JvdXAgaXRzZWxmLCBidXQgd2hlbiBvcmRncm91cHMgYW5kIGNvbG9ycyBoYXZlXG4gKiBhIHNpbmdsZSBlbGVtZW50LCB3ZSB3YW50IHRvIHB1bGwgdGhhdCBvdXQuXG4gKi9cbnZhciBnZXRCYXNlRWxlbSA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgaWYgKGdyb3VwLnZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJhc2VFbGVtKGdyb3VwLnZhbHVlWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgIGlmIChncm91cC52YWx1ZS52YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC52YWx1ZS52YWx1ZVswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiZm9udFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC52YWx1ZS5ib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUZVhib29rIGFsZ29yaXRobXMgb2Z0ZW4gcmVmZXJlbmNlIFwiY2hhcmFjdGVyIGJveGVzXCIsIHdoaWNoIGFyZSBzaW1wbHkgZ3JvdXBzXG4gKiB3aXRoIGEgc2luZ2xlIGNoYXJhY3RlciBpbiB0aGVtLiBUbyBkZWNpZGUgaWYgc29tZXRoaW5nIGlzIGEgY2hhcmFjdGVyIGJveCxcbiAqIHdlIGZpbmQgaXRzIGlubmVybW9zdCBncm91cCwgYW5kIHNlZSBpZiBpdCBpcyBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gKi9cbnZhciBpc0NoYXJhY3RlckJveCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIGJhc2VFbGVtID0gZ2V0QmFzZUVsZW0oZ3JvdXApO1xuXG4gICAgLy8gVGhlc2UgYXJlIGFsbCB0aGV5IHR5cGVzIG9mIGdyb3VwcyB3aGljaCBob2xkIHNpbmdsZSBjaGFyYWN0ZXJzXG4gICAgcmV0dXJuIGJhc2VFbGVtLnR5cGUgPT09IFwibWF0aG9yZFwiIHx8XG4gICAgICAgIGJhc2VFbGVtLnR5cGUgPT09IFwidGV4dG9yZFwiIHx8XG4gICAgICAgIGJhc2VFbGVtLnR5cGUgPT09IFwiYmluXCIgfHxcbiAgICAgICAgYmFzZUVsZW0udHlwZSA9PT0gXCJyZWxcIiB8fFxuICAgICAgICBiYXNlRWxlbS50eXBlID09PSBcImlubmVyXCIgfHxcbiAgICAgICAgYmFzZUVsZW0udHlwZSA9PT0gXCJvcGVuXCIgfHxcbiAgICAgICAgYmFzZUVsZW0udHlwZSA9PT0gXCJjbG9zZVwiIHx8XG4gICAgICAgIGJhc2VFbGVtLnR5cGUgPT09IFwicHVuY3RcIjtcbn07XG5cbnZhciBtYWtlTnVsbERlbGltaXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNsYXNzZXMpIHtcbiAgICByZXR1cm4gbWFrZVNwYW4oY2xhc3Nlcy5jb25jYXQoW1xuICAgICAgICBcInNpemluZ1wiLCBcInJlc2V0LVwiICsgb3B0aW9ucy5zaXplLCBcInNpemU1XCIsXG4gICAgICAgIG9wdGlvbnMuc3R5bGUucmVzZXQoKSwgU3R5bGUuVEVYVC5jbHMoKSxcbiAgICAgICAgXCJudWxsZGVsaW1pdGVyXCJdKSk7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSBtYXAgb2YgZ3JvdXAgdHlwZXMgdG8gdGhlIGZ1bmN0aW9uIHVzZWQgdG8gaGFuZGxlIHRoYXQgdHlwZS5cbiAqIFNpbXBsZXIgdHlwZXMgY29tZSBhdCB0aGUgYmVnaW5uaW5nLCB3aGlsZSBjb21wbGljYXRlZCB0eXBlcyBjb21lIGFmdGVyd2FyZHMuXG4gKi9cbnZhciBncm91cFR5cGVzID0ge307XG5cbmdyb3VwVHlwZXMubWF0aG9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwibWF0aG9yZFwiKTtcbn07XG5cbmdyb3VwVHlwZXMudGV4dG9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwidGV4dG9yZFwiKTtcbn07XG5cbmdyb3VwVHlwZXMuYmluID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWF0aHN5bShcbiAgICAgICAgZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUsIG9wdGlvbnMsIFtcIm1iaW5cIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5yZWwgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYXRoc3ltKFxuICAgICAgICBncm91cC52YWx1ZSwgZ3JvdXAubW9kZSwgb3B0aW9ucywgW1wibXJlbFwiXSk7XG59O1xuXG5ncm91cFR5cGVzLm9wZW4gPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYXRoc3ltKFxuICAgICAgICBncm91cC52YWx1ZSwgZ3JvdXAubW9kZSwgb3B0aW9ucywgW1wibW9wZW5cIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5jbG9zZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXG4gICAgICAgIGdyb3VwLnZhbHVlLCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtY2xvc2VcIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5pbm5lciA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXG4gICAgICAgIGdyb3VwLnZhbHVlLCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtaW5uZXJcIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5wdW5jdCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXG4gICAgICAgIGdyb3VwLnZhbHVlLCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtcHVuY3RcIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5vcmRncm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1ha2VTcGFuKFxuICAgICAgICBbXCJtb3JkXCIsIG9wdGlvbnMuc3R5bGUuY2xzKCldLFxuICAgICAgICBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUsIG9wdGlvbnMucmVzZXQoKSwgdHJ1ZSksXG4gICAgICAgIG9wdGlvbnNcbiAgICApO1xufTtcblxuZ3JvdXBUeXBlcy50ZXh0ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aEZvbnQoZ3JvdXAudmFsdWUuc3R5bGUpO1xuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC52YWx1ZS5ib2R5LCBuZXdPcHRpb25zLCB0cnVlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoaW5uZXJbaV0udHJ5Q29tYmluZShpbm5lcltpICsgMV0pKSB7XG4gICAgICAgICAgICBpbm5lci5zcGxpY2UoaSArIDEsIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwidGV4dFwiLCBuZXdPcHRpb25zLnN0eWxlLmNscygpXSxcbiAgICAgICAgaW5uZXIsIG5ld09wdGlvbnMpO1xufTtcblxuZ3JvdXBUeXBlcy5jb2xvciA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKFxuICAgICAgICBncm91cC52YWx1ZS52YWx1ZSxcbiAgICAgICAgb3B0aW9ucy53aXRoQ29sb3IoZ3JvdXAudmFsdWUuY29sb3IpLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICAvLyBcXGNvbG9yIGlzbid0IHN1cHBvc2VkIHRvIGFmZmVjdCB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudHMgaXQgY29udGFpbnMuXG4gICAgLy8gVG8gYWNjb21wbGlzaCB0aGlzLCB3ZSB3cmFwIHRoZSByZXN1bHRzIGluIGEgZnJhZ21lbnQsIHNvIHRoZSBpbm5lclxuICAgIC8vIGVsZW1lbnRzIHdpbGwgYmUgYWJsZSB0byBkaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZWlyIG5laWdoYm9ycy4gRm9yXG4gICAgLy8gZXhhbXBsZSwgYFxcY29sb3J7cmVkfXsyICt9IDNgIGhhcyB0aGUgc2FtZSBzcGFjaW5nIGFzIGAyICsgM2BcbiAgICByZXR1cm4gbmV3IGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG59O1xuXG5ncm91cFR5cGVzLnN1cHN1YiA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3VwZXJzY3JpcHQgYW5kIHN1YnNjcmlwdHMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGFnZVxuICAgIC8vIDQ0NS00NDYsIHJ1bGVzIDE4KGEtZikuXG5cbiAgICAvLyBIZXJlIGlzIHdoZXJlIHdlIGRlZmVyIHRvIHRoZSBpbm5lciBncm91cCBpZiBpdCBzaG91bGQgaGFuZGxlXG4gICAgLy8gc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGl0c2VsZi5cbiAgICBpZiAoc2hvdWxkSGFuZGxlU3VwU3ViKGdyb3VwLnZhbHVlLmJhc2UsIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBncm91cFR5cGVzW2dyb3VwLnZhbHVlLmJhc2UudHlwZV0oZ3JvdXAsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBiYXNlID0gYnVpbGRHcm91cChncm91cC52YWx1ZS5iYXNlLCBvcHRpb25zLnJlc2V0KCkpO1xuICAgIHZhciBzdXBtaWQ7XG4gICAgdmFyIHN1Ym1pZDtcbiAgICB2YXIgc3VwO1xuICAgIHZhciBzdWI7XG5cbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBuZXdPcHRpb25zO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnN1cCkge1xuICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuc3VwKCkpO1xuICAgICAgICBzdXAgPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLnN1cCwgbmV3T3B0aW9ucyk7XG4gICAgICAgIHN1cG1pZCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBzdHlsZS5zdXAoKS5jbHMoKV0sXG4gICAgICAgICAgICBbc3VwXSwgbmV3T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnN1Yikge1xuICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuc3ViKCkpO1xuICAgICAgICBzdWIgPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLnN1YiwgbmV3T3B0aW9ucyk7XG4gICAgICAgIHN1Ym1pZCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBzdHlsZS5zdWIoKS5jbHMoKV0sXG4gICAgICAgICAgICBbc3ViXSwgbmV3T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gUnVsZSAxOGFcbiAgICB2YXIgc3VwU2hpZnQ7XG4gICAgdmFyIHN1YlNoaWZ0O1xuICAgIGlmIChpc0NoYXJhY3RlckJveChncm91cC52YWx1ZS5iYXNlKSkge1xuICAgICAgICBzdXBTaGlmdCA9IDA7XG4gICAgICAgIHN1YlNoaWZ0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdXBTaGlmdCA9IGJhc2UuaGVpZ2h0IC0gc3R5bGUubWV0cmljcy5zdXBEcm9wO1xuICAgICAgICBzdWJTaGlmdCA9IGJhc2UuZGVwdGggKyBzdHlsZS5tZXRyaWNzLnN1YkRyb3A7XG4gICAgfVxuXG4gICAgLy8gUnVsZSAxOGNcbiAgICB2YXIgbWluU3VwU2hpZnQ7XG4gICAgaWYgKHN0eWxlID09PSBTdHlsZS5ESVNQTEFZKSB7XG4gICAgICAgIG1pblN1cFNoaWZ0ID0gc3R5bGUubWV0cmljcy5zdXAxO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuY3JhbXBlZCkge1xuICAgICAgICBtaW5TdXBTaGlmdCA9IHN0eWxlLm1ldHJpY3Muc3VwMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TdXBTaGlmdCA9IHN0eWxlLm1ldHJpY3Muc3VwMjtcbiAgICB9XG5cbiAgICAvLyBzY3JpcHRzcGFjZSBpcyBhIGZvbnQtc2l6ZS1pbmRlcGVuZGVudCBzaXplLCBzbyBzY2FsZSBpdFxuICAgIC8vIGFwcHJvcHJpYXRlbHlcbiAgICB2YXIgbXVsdGlwbGllciA9IFN0eWxlLlRFWFQuc2l6ZU11bHRpcGxpZXIgKlxuICAgICAgICAgICAgc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIHNjcmlwdHNwYWNlID1cbiAgICAgICAgKDAuNSAvIGZvbnRNZXRyaWNzLm1ldHJpY3MucHRQZXJFbSkgLyBtdWx0aXBsaWVyICsgXCJlbVwiO1xuXG4gICAgdmFyIHN1cHN1YjtcbiAgICBpZiAoIWdyb3VwLnZhbHVlLnN1cCkge1xuICAgICAgICAvLyBSdWxlIDE4YlxuICAgICAgICBzdWJTaGlmdCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgc3ViU2hpZnQsIHN0eWxlLm1ldHJpY3Muc3ViMSxcbiAgICAgICAgICAgIHN1Yi5oZWlnaHQgLSAwLjggKiBzdHlsZS5tZXRyaWNzLnhIZWlnaHQpO1xuXG4gICAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IHN1Ym1pZH1cbiAgICAgICAgXSwgXCJzaGlmdFwiLCBzdWJTaGlmdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgc3Vwc3ViLmNoaWxkcmVuWzBdLnN0eWxlLm1hcmdpblJpZ2h0ID0gc2NyaXB0c3BhY2U7XG5cbiAgICAgICAgLy8gU3Vic2NyaXB0cyBzaG91bGRuJ3QgYmUgc2hpZnRlZCBieSB0aGUgYmFzZSdzIGl0YWxpYyBjb3JyZWN0aW9uLlxuICAgICAgICAvLyBBY2NvdW50IGZvciB0aGF0IGJ5IHNoaWZ0aW5nIHRoZSBzdWJzY3JpcHQgYmFjayB0aGUgYXBwcm9wcmlhdGVcbiAgICAgICAgLy8gYW1vdW50LiBOb3RlIHdlIG9ubHkgZG8gdGhpcyB3aGVuIHRoZSBiYXNlIGlzIGEgc2luZ2xlIHN5bWJvbC5cbiAgICAgICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBkb21UcmVlLnN5bWJvbE5vZGUpIHtcbiAgICAgICAgICAgIHN1cHN1Yi5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5MZWZ0ID0gLWJhc2UuaXRhbGljICsgXCJlbVwiO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghZ3JvdXAudmFsdWUuc3ViKSB7XG4gICAgICAgIC8vIFJ1bGUgMThjLCBkXG4gICAgICAgIHN1cFNoaWZ0ID0gTWF0aC5tYXgoc3VwU2hpZnQsIG1pblN1cFNoaWZ0LFxuICAgICAgICAgICAgc3VwLmRlcHRoICsgMC4yNSAqIHN0eWxlLm1ldHJpY3MueEhlaWdodCk7XG5cbiAgICAgICAgc3Vwc3ViID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkfVxuICAgICAgICBdLCBcInNoaWZ0XCIsIC1zdXBTaGlmdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgc3Vwc3ViLmNoaWxkcmVuWzBdLnN0eWxlLm1hcmdpblJpZ2h0ID0gc2NyaXB0c3BhY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3VwU2hpZnQgPSBNYXRoLm1heChcbiAgICAgICAgICAgIHN1cFNoaWZ0LCBtaW5TdXBTaGlmdCwgc3VwLmRlcHRoICsgMC4yNSAqIHN0eWxlLm1ldHJpY3MueEhlaWdodCk7XG4gICAgICAgIHN1YlNoaWZ0ID0gTWF0aC5tYXgoc3ViU2hpZnQsIHN0eWxlLm1ldHJpY3Muc3ViMik7XG5cbiAgICAgICAgdmFyIHJ1bGVXaWR0aCA9IGZvbnRNZXRyaWNzLm1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3M7XG5cbiAgICAgICAgLy8gUnVsZSAxOGVcbiAgICAgICAgaWYgKChzdXBTaGlmdCAtIHN1cC5kZXB0aCkgLSAoc3ViLmhlaWdodCAtIHN1YlNoaWZ0KSA8XG4gICAgICAgICAgICAgICAgNCAqIHJ1bGVXaWR0aCkge1xuICAgICAgICAgICAgc3ViU2hpZnQgPSA0ICogcnVsZVdpZHRoIC0gKHN1cFNoaWZ0IC0gc3VwLmRlcHRoKSArIHN1Yi5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgcHNpID0gMC44ICogc3R5bGUubWV0cmljcy54SGVpZ2h0IC0gKHN1cFNoaWZ0IC0gc3VwLmRlcHRoKTtcbiAgICAgICAgICAgIGlmIChwc2kgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3VwU2hpZnQgKz0gcHNpO1xuICAgICAgICAgICAgICAgIHN1YlNoaWZ0IC09IHBzaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IHN1Ym1pZCwgc2hpZnQ6IHN1YlNoaWZ0fSxcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkLCBzaGlmdDogLXN1cFNoaWZ0fVxuICAgICAgICBdLCBcImluZGl2aWR1YWxTaGlmdFwiLCBudWxsLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBTZWUgY29tbWVudCBhYm92ZSBhYm91dCBzdWJzY3JpcHRzIG5vdCBiZWluZyBzaGlmdGVkXG4gICAgICAgIGlmIChiYXNlIGluc3RhbmNlb2YgZG9tVHJlZS5zeW1ib2xOb2RlKSB7XG4gICAgICAgICAgICBzdXBzdWIuY2hpbGRyZW5bMF0uc3R5bGUubWFyZ2luTGVmdCA9IC1iYXNlLml0YWxpYyArIFwiZW1cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cHN1Yi5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5SaWdodCA9IHNjcmlwdHNwYWNlO1xuICAgICAgICBzdXBzdWIuY2hpbGRyZW5bMV0uc3R5bGUubWFyZ2luUmlnaHQgPSBzY3JpcHRzcGFjZTtcbiAgICB9XG5cbiAgICAvLyBXZSBlbnN1cmUgdG8gd3JhcCB0aGUgc3Vwc3ViIHZsaXN0IGluIGEgc3Bhbi5tc3Vwc3ViIHRvIHJlc2V0IHRleHQtYWxpZ25cbiAgICB2YXIgbWNsYXNzID0gZ2V0VHlwZU9mRG9tVHJlZShiYXNlKSB8fCBcIm1vcmRcIjtcbiAgICByZXR1cm4gbWFrZVNwYW4oW21jbGFzc10sXG4gICAgICAgIFtiYXNlLCBtYWtlU3BhbihbXCJtc3Vwc3ViXCJdLCBbc3Vwc3ViXSldLFxuICAgICAgICBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMuZ2VuZnJhYyA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gRnJhY3Rpb25zIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIG9uIHBhZ2VzIDQ0NC00NDUsIHJ1bGVzIDE1KGEtZSkuXG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHRoaXMgZnJhY3Rpb24gc2hvdWxkIGJlIGluIGJhc2VkIG9uIHRoZVxuICAgIC8vIGZ1bmN0aW9uIHVzZWRcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGlmIChncm91cC52YWx1ZS5zaXplID09PSBcImRpc3BsYXlcIikge1xuICAgICAgICBzdHlsZSA9IFN0eWxlLkRJU1BMQVk7XG4gICAgfSBlbHNlIGlmIChncm91cC52YWx1ZS5zaXplID09PSBcInRleHRcIikge1xuICAgICAgICBzdHlsZSA9IFN0eWxlLlRFWFQ7XG4gICAgfVxuXG4gICAgdmFyIG5zdHlsZSA9IHN0eWxlLmZyYWNOdW0oKTtcbiAgICB2YXIgZHN0eWxlID0gc3R5bGUuZnJhY0RlbigpO1xuICAgIHZhciBuZXdPcHRpb25zO1xuXG4gICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aFN0eWxlKG5zdHlsZSk7XG4gICAgdmFyIG51bWVyID0gYnVpbGRHcm91cChncm91cC52YWx1ZS5udW1lciwgbmV3T3B0aW9ucyk7XG4gICAgdmFyIG51bWVycmVzZXQgPSBtYWtlU3Bhbihbc3R5bGUucmVzZXQoKSwgbnN0eWxlLmNscygpXSxcbiAgICAgICAgW251bWVyXSwgbmV3T3B0aW9ucyk7XG5cbiAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoZHN0eWxlKTtcbiAgICB2YXIgZGVub20gPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmRlbm9tLCBuZXdPcHRpb25zKTtcbiAgICB2YXIgZGVub21yZXNldCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBkc3R5bGUuY2xzKCldLFxuICAgICAgICBbZGVub21dLCBuZXdPcHRpb25zKTtcblxuICAgIHZhciBydWxlV2lkdGg7XG4gICAgaWYgKGdyb3VwLnZhbHVlLmhhc0JhckxpbmUpIHtcbiAgICAgICAgcnVsZVdpZHRoID0gZm9udE1ldHJpY3MubWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzcyAvXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlLnNpemVNdWx0aXBsaWVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJ1bGVXaWR0aCA9IDA7XG4gICAgfVxuXG4gICAgLy8gUnVsZSAxNWJcbiAgICB2YXIgbnVtU2hpZnQ7XG4gICAgdmFyIGNsZWFyYW5jZTtcbiAgICB2YXIgZGVub21TaGlmdDtcbiAgICBpZiAoc3R5bGUuc2l6ZSA9PT0gU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgICAgIG51bVNoaWZ0ID0gc3R5bGUubWV0cmljcy5udW0xO1xuICAgICAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgY2xlYXJhbmNlID0gMyAqIHJ1bGVXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyYW5jZSA9IDcgKiBmb250TWV0cmljcy5tZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGRlbm9tU2hpZnQgPSBzdHlsZS5tZXRyaWNzLmRlbm9tMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgbnVtU2hpZnQgPSBzdHlsZS5tZXRyaWNzLm51bTI7XG4gICAgICAgICAgICBjbGVhcmFuY2UgPSBydWxlV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1TaGlmdCA9IHN0eWxlLm1ldHJpY3MubnVtMztcbiAgICAgICAgICAgIGNsZWFyYW5jZSA9IDMgKiBmb250TWV0cmljcy5tZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGRlbm9tU2hpZnQgPSBzdHlsZS5tZXRyaWNzLmRlbm9tMjtcbiAgICB9XG5cbiAgICB2YXIgZnJhYztcbiAgICBpZiAocnVsZVdpZHRoID09PSAwKSB7XG4gICAgICAgIC8vIFJ1bGUgMTVjXG4gICAgICAgIHZhciBjYW5kaWRhdGVDbGVhcmFuY2UgPVxuICAgICAgICAgICAgKG51bVNoaWZ0IC0gbnVtZXIuZGVwdGgpIC0gKGRlbm9tLmhlaWdodCAtIGRlbm9tU2hpZnQpO1xuICAgICAgICBpZiAoY2FuZGlkYXRlQ2xlYXJhbmNlIDwgY2xlYXJhbmNlKSB7XG4gICAgICAgICAgICBudW1TaGlmdCArPSAwLjUgKiAoY2xlYXJhbmNlIC0gY2FuZGlkYXRlQ2xlYXJhbmNlKTtcbiAgICAgICAgICAgIGRlbm9tU2hpZnQgKz0gMC41ICogKGNsZWFyYW5jZSAtIGNhbmRpZGF0ZUNsZWFyYW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFjID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogZGVub21yZXNldCwgc2hpZnQ6IGRlbm9tU2hpZnR9LFxuICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBudW1lcnJlc2V0LCBzaGlmdDogLW51bVNoaWZ0fVxuICAgICAgICBdLCBcImluZGl2aWR1YWxTaGlmdFwiLCBudWxsLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSdWxlIDE1ZFxuICAgICAgICB2YXIgYXhpc0hlaWdodCA9IHN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodDtcblxuICAgICAgICBpZiAoKG51bVNoaWZ0IC0gbnVtZXIuZGVwdGgpIC0gKGF4aXNIZWlnaHQgKyAwLjUgKiBydWxlV2lkdGgpIDxcbiAgICAgICAgICAgICAgICBjbGVhcmFuY2UpIHtcbiAgICAgICAgICAgIG51bVNoaWZ0ICs9XG4gICAgICAgICAgICAgICAgY2xlYXJhbmNlIC0gKChudW1TaGlmdCAtIG51bWVyLmRlcHRoKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChheGlzSGVpZ2h0ICsgMC41ICogcnVsZVdpZHRoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGgpIC0gKGRlbm9tLmhlaWdodCAtIGRlbm9tU2hpZnQpIDxcbiAgICAgICAgICAgICAgICBjbGVhcmFuY2UpIHtcbiAgICAgICAgICAgIGRlbm9tU2hpZnQgKz1cbiAgICAgICAgICAgICAgICBjbGVhcmFuY2UgLSAoKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRlbm9tLmhlaWdodCAtIGRlbm9tU2hpZnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaWQgPSBtYWtlU3BhbihcbiAgICAgICAgICAgIFtvcHRpb25zLnN0eWxlLnJlc2V0KCksIFN0eWxlLlRFWFQuY2xzKCksIFwiZnJhYy1saW5lXCJdKTtcbiAgICAgICAgLy8gTWFudWFsbHkgc2V0IHRoZSBoZWlnaHQgb2YgdGhlIGxpbmUgYmVjYXVzZSBpdHMgaGVpZ2h0IGlzXG4gICAgICAgIC8vIGNyZWF0ZWQgaW4gQ1NTXG4gICAgICAgIG1pZC5oZWlnaHQgPSBydWxlV2lkdGg7XG5cbiAgICAgICAgdmFyIG1pZFNoaWZ0ID0gLShheGlzSGVpZ2h0IC0gMC41ICogcnVsZVdpZHRoKTtcblxuICAgICAgICBmcmFjID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogZGVub21yZXNldCwgc2hpZnQ6IGRlbm9tU2hpZnR9LFxuICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBtaWQsICAgICAgICBzaGlmdDogbWlkU2hpZnR9LFxuICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBudW1lcnJlc2V0LCBzaGlmdDogLW51bVNoaWZ0fVxuICAgICAgICBdLCBcImluZGl2aWR1YWxTaGlmdFwiLCBudWxsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBTaW5jZSB3ZSBtYW51YWxseSBjaGFuZ2UgdGhlIHN0eWxlIHNvbWV0aW1lcyAod2l0aCBcXGRmcmFjIG9yIFxcdGZyYWMpLFxuICAgIC8vIGFjY291bnQgZm9yIHRoZSBwb3NzaWJsZSBzaXplIGNoYW5nZSBoZXJlLlxuICAgIGZyYWMuaGVpZ2h0ICo9IHN0eWxlLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICBmcmFjLmRlcHRoICo9IHN0eWxlLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIC8vIFJ1bGUgMTVlXG4gICAgdmFyIGRlbGltU2l6ZTtcbiAgICBpZiAoc3R5bGUuc2l6ZSA9PT0gU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgICAgIGRlbGltU2l6ZSA9IHN0eWxlLm1ldHJpY3MuZGVsaW0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGltU2l6ZSA9IHN0eWxlLm1ldHJpY3MuZGVsaW0yO1xuICAgIH1cblxuICAgIHZhciBsZWZ0RGVsaW07XG4gICAgdmFyIHJpZ2h0RGVsaW07XG4gICAgaWYgKGdyb3VwLnZhbHVlLmxlZnREZWxpbSA9PSBudWxsKSB7XG4gICAgICAgIGxlZnREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1vcGVuXCJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0RGVsaW0gPSBkZWxpbWl0ZXIuY3VzdG9tU2l6ZWREZWxpbShcbiAgICAgICAgICAgIGdyb3VwLnZhbHVlLmxlZnREZWxpbSwgZGVsaW1TaXplLCB0cnVlLFxuICAgICAgICAgICAgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUpLCBncm91cC5tb2RlLCBbXCJtb3BlblwiXSk7XG4gICAgfVxuICAgIGlmIChncm91cC52YWx1ZS5yaWdodERlbGltID09IG51bGwpIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1jbG9zZVwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IGRlbGltaXRlci5jdXN0b21TaXplZERlbGltKFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUucmlnaHREZWxpbSwgZGVsaW1TaXplLCB0cnVlLFxuICAgICAgICAgICAgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUpLCBncm91cC5tb2RlLCBbXCJtY2xvc2VcIl0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlU3BhbihcbiAgICAgICAgW1wibW9yZFwiLCBvcHRpb25zLnN0eWxlLnJlc2V0KCksIHN0eWxlLmNscygpXSxcbiAgICAgICAgW2xlZnREZWxpbSwgbWFrZVNwYW4oW1wibWZyYWNcIl0sIFtmcmFjXSksIHJpZ2h0RGVsaW1dLFxuICAgICAgICBvcHRpb25zKTtcbn07XG5cbnZhciBjYWxjdWxhdGVTaXplID0gZnVuY3Rpb24oc2l6ZVZhbHVlLCBzdHlsZSkge1xuICAgIHZhciB4ID0gc2l6ZVZhbHVlLm51bWJlcjtcbiAgICBpZiAoc2l6ZVZhbHVlLnVuaXQgPT09IFwiZXhcIikge1xuICAgICAgICB4ICo9IHN0eWxlLm1ldHJpY3MuZW1QZXJFeDtcbiAgICB9IGVsc2UgaWYgKHNpemVWYWx1ZS51bml0ID09PSBcIm11XCIpIHtcbiAgICAgICAgeCAvPSAxODtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59O1xuXG5ncm91cFR5cGVzLmFycmF5ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgcjtcbiAgICB2YXIgYztcbiAgICB2YXIgbnIgPSBncm91cC52YWx1ZS5ib2R5Lmxlbmd0aDtcbiAgICB2YXIgbmMgPSAwO1xuICAgIHZhciBib2R5ID0gbmV3IEFycmF5KG5yKTtcblxuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgICAvLyBIb3Jpem9udGFsIHNwYWNpbmdcbiAgICB2YXIgcHQgPSAxIC8gZm9udE1ldHJpY3MubWV0cmljcy5wdFBlckVtO1xuICAgIHZhciBhcnJheWNvbHNlcCA9IDUgKiBwdDsgLy8gXFxhcnJheWNvbHNlcCBpbiBhcnRpY2xlLmNsc1xuXG4gICAgLy8gVmVydGljYWwgc3BhY2luZ1xuICAgIHZhciBiYXNlbGluZXNraXAgPSAxMiAqIHB0OyAvLyBzZWUgc2l6ZTEwLmNsb1xuICAgIC8vIERlZmF1bHQgXFxhcnJheXN0cmV0Y2ggZnJvbSBsdHRhYi5kdHhcbiAgICAvLyBUT0RPKGdhZ2Vybik6IG1heSBnZXQgcmVkZWZpbmVkIG9uY2Ugd2UgaGF2ZSB1c2VyLWRlZmluZWQgbWFjcm9zXG4gICAgdmFyIGFycmF5c3RyZXRjaCA9IHV0aWxzLmRlZmx0KGdyb3VwLnZhbHVlLmFycmF5c3RyZXRjaCwgMSk7XG4gICAgdmFyIGFycmF5c2tpcCA9IGFycmF5c3RyZXRjaCAqIGJhc2VsaW5lc2tpcDtcbiAgICB2YXIgYXJzdHJ1dEhlaWdodCA9IDAuNyAqIGFycmF5c2tpcDsgLy8gXFxzdHJ1dGJveCBpbiBsdGZzc3RyYy5kdHggYW5kXG4gICAgdmFyIGFyc3RydXREZXB0aCA9IDAuMyAqIGFycmF5c2tpcDsgIC8vIFxcQGFyc3RydXRib3ggaW4gbHR0YWIuZHR4XG5cbiAgICB2YXIgdG90YWxIZWlnaHQgPSAwO1xuICAgIGZvciAociA9IDA7IHIgPCBncm91cC52YWx1ZS5ib2R5Lmxlbmd0aDsgKytyKSB7XG4gICAgICAgIHZhciBpbnJvdyA9IGdyb3VwLnZhbHVlLmJvZHlbcl07XG4gICAgICAgIHZhciBoZWlnaHQgPSBhcnN0cnV0SGVpZ2h0OyAvLyBcXEBhcnJheSBhZGRzIGFuIFxcQGFyc3RydXRcbiAgICAgICAgdmFyIGRlcHRoID0gYXJzdHJ1dERlcHRoOyAgIC8vIHRvIGVhY2ggdG93ICh2aWEgdGhlIHRlbXBsYXRlKVxuXG4gICAgICAgIGlmIChuYyA8IGlucm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgbmMgPSBpbnJvdy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cm93ID0gbmV3IEFycmF5KGlucm93Lmxlbmd0aCk7XG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCBpbnJvdy5sZW5ndGg7ICsrYykge1xuICAgICAgICAgICAgdmFyIGVsdCA9IGJ1aWxkR3JvdXAoaW5yb3dbY10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGRlcHRoIDwgZWx0LmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgZGVwdGggPSBlbHQuZGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgZWx0LmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGVsdC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRyb3dbY10gPSBlbHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2FwID0gMDtcbiAgICAgICAgaWYgKGdyb3VwLnZhbHVlLnJvd0dhcHNbcl0pIHtcbiAgICAgICAgICAgIGdhcCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAudmFsdWUucm93R2Fwc1tyXS52YWx1ZSwgc3R5bGUpO1xuICAgICAgICAgICAgaWYgKGdhcCA+IDApIHsgLy8gXFxAYXJnYXJyYXljclxuICAgICAgICAgICAgICAgIGdhcCArPSBhcnN0cnV0RGVwdGg7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDwgZ2FwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZ2FwOyAvLyBcXEB4YXJnYXJyYXljclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnYXAgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cm93LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgb3V0cm93LmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGhlaWdodDtcbiAgICAgICAgb3V0cm93LnBvcyA9IHRvdGFsSGVpZ2h0O1xuICAgICAgICB0b3RhbEhlaWdodCArPSBkZXB0aCArIGdhcDsgLy8gXFxAeWFyZ2FycmF5Y3JcbiAgICAgICAgYm9keVtyXSA9IG91dHJvdztcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gdG90YWxIZWlnaHQgLyAyICsgc3R5bGUubWV0cmljcy5heGlzSGVpZ2h0O1xuICAgIHZhciBjb2xEZXNjcmlwdGlvbnMgPSBncm91cC52YWx1ZS5jb2xzIHx8IFtdO1xuICAgIHZhciBjb2xzID0gW107XG4gICAgdmFyIGNvbFNlcDtcbiAgICB2YXIgY29sRGVzY3JOdW07XG4gICAgZm9yIChjID0gMCwgY29sRGVzY3JOdW0gPSAwO1xuICAgICAgICAgLy8gQ29udGludWUgd2hpbGUgZWl0aGVyIHRoZXJlIGFyZSBtb3JlIGNvbHVtbnMgb3IgbW9yZSBjb2x1bW5cbiAgICAgICAgIC8vIGRlc2NyaXB0aW9ucywgc28gdHJhaWxpbmcgc2VwYXJhdG9ycyBkb24ndCBnZXQgbG9zdC5cbiAgICAgICAgIGMgPCBuYyB8fCBjb2xEZXNjck51bSA8IGNvbERlc2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgICArK2MsICsrY29sRGVzY3JOdW0pIHtcblxuICAgICAgICB2YXIgY29sRGVzY3IgPSBjb2xEZXNjcmlwdGlvbnNbY29sRGVzY3JOdW1dIHx8IHt9O1xuXG4gICAgICAgIHZhciBmaXJzdFNlcGFyYXRvciA9IHRydWU7XG4gICAgICAgIHdoaWxlIChjb2xEZXNjci50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHNlcGFyYXRvciBpbiBhIHJvdywgYWRkIGEgc3BhY2VcbiAgICAgICAgICAgIC8vIGJldHdlZW4gdGhlbS5cbiAgICAgICAgICAgIGlmICghZmlyc3RTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb2xTZXAgPSBtYWtlU3BhbihbXCJhcnJheWNvbHNlcFwiXSwgW10pO1xuICAgICAgICAgICAgICAgIGNvbFNlcC5zdHlsZS53aWR0aCA9XG4gICAgICAgICAgICAgICAgICAgIGZvbnRNZXRyaWNzLm1ldHJpY3MuZG91YmxlUnVsZVNlcCArIFwiZW1cIjtcbiAgICAgICAgICAgICAgICBjb2xzLnB1c2goY29sU2VwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbERlc2NyLnNlcGFyYXRvciA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gbWFrZVNwYW4oXG4gICAgICAgICAgICAgICAgICAgIFtcInZlcnRpY2FsLXNlcGFyYXRvclwiXSxcbiAgICAgICAgICAgICAgICAgICAgW10pO1xuICAgICAgICAgICAgICAgIHNlcGFyYXRvci5zdHlsZS5oZWlnaHQgPSB0b3RhbEhlaWdodCArIFwiZW1cIjtcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3Iuc3R5bGUudmVydGljYWxBbGlnbiA9XG4gICAgICAgICAgICAgICAgICAgIC0odG90YWxIZWlnaHQgLSBvZmZzZXQpICsgXCJlbVwiO1xuXG4gICAgICAgICAgICAgICAgY29scy5wdXNoKHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkludmFsaWQgc2VwYXJhdG9yIHR5cGU6IFwiICsgY29sRGVzY3Iuc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sRGVzY3JOdW0rKztcbiAgICAgICAgICAgIGNvbERlc2NyID0gY29sRGVzY3JpcHRpb25zW2NvbERlc2NyTnVtXSB8fCB7fTtcbiAgICAgICAgICAgIGZpcnN0U2VwYXJhdG9yID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA+PSBuYykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Vwd2lkdGg7XG4gICAgICAgIGlmIChjID4gMCB8fCBncm91cC52YWx1ZS5oc2tpcEJlZm9yZUFuZEFmdGVyKSB7XG4gICAgICAgICAgICBzZXB3aWR0aCA9IHV0aWxzLmRlZmx0KGNvbERlc2NyLnByZWdhcCwgYXJyYXljb2xzZXApO1xuICAgICAgICAgICAgaWYgKHNlcHdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29sU2VwID0gbWFrZVNwYW4oW1wiYXJyYXljb2xzZXBcIl0sIFtdKTtcbiAgICAgICAgICAgICAgICBjb2xTZXAuc3R5bGUud2lkdGggPSBzZXB3aWR0aCArIFwiZW1cIjtcbiAgICAgICAgICAgICAgICBjb2xzLnB1c2goY29sU2VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2wgPSBbXTtcbiAgICAgICAgZm9yIChyID0gMDsgciA8IG5yOyArK3IpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBib2R5W3JdO1xuICAgICAgICAgICAgdmFyIGVsZW0gPSByb3dbY107XG4gICAgICAgICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaGlmdCA9IHJvdy5wb3MgLSBvZmZzZXQ7XG4gICAgICAgICAgICBlbGVtLmRlcHRoID0gcm93LmRlcHRoO1xuICAgICAgICAgICAgZWxlbS5oZWlnaHQgPSByb3cuaGVpZ2h0O1xuICAgICAgICAgICAgY29sLnB1c2goe3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBlbGVtLCBzaGlmdDogc2hpZnR9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChjb2wsIFwiaW5kaXZpZHVhbFNoaWZ0XCIsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICBjb2wgPSBtYWtlU3BhbihcbiAgICAgICAgICAgIFtcImNvbC1hbGlnbi1cIiArIChjb2xEZXNjci5hbGlnbiB8fCBcImNcIildLFxuICAgICAgICAgICAgW2NvbF0pO1xuICAgICAgICBjb2xzLnB1c2goY29sKTtcblxuICAgICAgICBpZiAoYyA8IG5jIC0gMSB8fCBncm91cC52YWx1ZS5oc2tpcEJlZm9yZUFuZEFmdGVyKSB7XG4gICAgICAgICAgICBzZXB3aWR0aCA9IHV0aWxzLmRlZmx0KGNvbERlc2NyLnBvc3RnYXAsIGFycmF5Y29sc2VwKTtcbiAgICAgICAgICAgIGlmIChzZXB3aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbFNlcCA9IG1ha2VTcGFuKFtcImFycmF5Y29sc2VwXCJdLCBbXSk7XG4gICAgICAgICAgICAgICAgY29sU2VwLnN0eWxlLndpZHRoID0gc2Vwd2lkdGggKyBcImVtXCI7XG4gICAgICAgICAgICAgICAgY29scy5wdXNoKGNvbFNlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYm9keSA9IG1ha2VTcGFuKFtcIm10YWJsZVwiXSwgY29scyk7XG4gICAgcmV0dXJuIG1ha2VTcGFuKFtcIm1vcmRcIl0sIFtib2R5XSwgb3B0aW9ucyk7XG59O1xuXG5ncm91cFR5cGVzLnNwYWNpbmcgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIGlmIChncm91cC52YWx1ZSA9PT0gXCJcXFxcIFwiIHx8IGdyb3VwLnZhbHVlID09PSBcIlxcXFxzcGFjZVwiIHx8XG4gICAgICAgIGdyb3VwLnZhbHVlID09PSBcIiBcIiB8fCBncm91cC52YWx1ZSA9PT0gXCJ+XCIpIHtcbiAgICAgICAgLy8gU3BhY2VzIGFyZSBnZW5lcmF0ZWQgYnkgYWRkaW5nIGFuIGFjdHVhbCBzcGFjZS4gRWFjaCBvZiB0aGVzZVxuICAgICAgICAvLyB0aGluZ3MgaGFzIGFuIGVudHJ5IGluIHRoZSBzeW1ib2xzIHRhYmxlLCBzbyB0aGVzZSB3aWxsIGJlIHR1cm5lZFxuICAgICAgICAvLyBpbnRvIGFwcHJvcHJpYXRlIG91dHB1dHMuXG4gICAgICAgIGlmIChncm91cC5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwidGV4dG9yZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlU3BhbihbXCJtc3BhY2VcIl0sXG4gICAgICAgICAgICAgICAgW2J1aWxkQ29tbW9uLm1hdGhzeW0oZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUsIG9wdGlvbnMpXSxcbiAgICAgICAgICAgICAgICBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyIGtpbmRzIG9mIHNwYWNlcyBhcmUgb2YgYXJiaXRyYXJ5IHdpZHRoLiBXZSB1c2UgQ1NTIHRvXG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZXNlLlxuICAgICAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgICAgICBbXCJtc3BhY2VcIixcbiAgICAgICAgICAgICAgICBidWlsZENvbW1vbi5zcGFjaW5nRnVuY3Rpb25zW2dyb3VwLnZhbHVlXS5jbGFzc05hbWVdLFxuICAgICAgICAgICAgW10sIG9wdGlvbnMpO1xuICAgIH1cbn07XG5cbmdyb3VwVHlwZXMubGxhcCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImlubmVyXCJdLCBbYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zLnJlc2V0KCkpXSk7XG4gICAgdmFyIGZpeCA9IG1ha2VTcGFuKFtcImZpeFwiXSwgW10pO1xuICAgIHJldHVybiBtYWtlU3BhbihcbiAgICAgICAgW1wibW9yZFwiLCBcImxsYXBcIiwgb3B0aW9ucy5zdHlsZS5jbHMoKV0sIFtpbm5lciwgZml4XSwgb3B0aW9ucyk7XG59O1xuXG5ncm91cFR5cGVzLnJsYXAgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBpbm5lciA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJpbm5lclwiXSwgW2J1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy5yZXNldCgpKV0pO1xuICAgIHZhciBmaXggPSBtYWtlU3BhbihbXCJmaXhcIl0sIFtdKTtcbiAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgIFtcIm1vcmRcIiwgXCJybGFwXCIsIG9wdGlvbnMuc3R5bGUuY2xzKCldLCBbaW5uZXIsIGZpeF0sIG9wdGlvbnMpO1xufTtcblxuZ3JvdXBUeXBlcy5vcCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gT3BlcmF0b3JzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMtNDQ0LCBydWxlIDEzKGEpLlxuICAgIHZhciBzdXBHcm91cDtcbiAgICB2YXIgc3ViR3JvdXA7XG4gICAgdmFyIGhhc0xpbWl0cyA9IGZhbHNlO1xuICAgIGlmIChncm91cC50eXBlID09PSBcInN1cHN1YlwiKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbGltaXRzLCBzdXBzdWIgd2lsbCBwYXNzIHVzIGl0cyBncm91cCB0byBoYW5kbGUuIFB1bGxcbiAgICAgICAgLy8gb3V0IHRoZSBzdXBlcnNjcmlwdCBhbmQgc3Vic2NyaXB0IGFuZCBzZXQgdGhlIGdyb3VwIHRvIHRoZSBvcCBpblxuICAgICAgICAvLyBpdHMgYmFzZS5cbiAgICAgICAgc3VwR3JvdXAgPSBncm91cC52YWx1ZS5zdXA7XG4gICAgICAgIHN1Ykdyb3VwID0gZ3JvdXAudmFsdWUuc3ViO1xuICAgICAgICBncm91cCA9IGdyb3VwLnZhbHVlLmJhc2U7XG4gICAgICAgIGhhc0xpbWl0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIC8vIE1vc3Qgb3BlcmF0b3JzIGhhdmUgYSBsYXJnZSBzdWNjZXNzb3Igc3ltYm9sLCBidXQgdGhlc2UgZG9uJ3QuXG4gICAgdmFyIG5vU3VjY2Vzc29yID0gW1xuICAgICAgICBcIlxcXFxzbWFsbGludFwiXG4gICAgXTtcblxuICAgIHZhciBsYXJnZSA9IGZhbHNlO1xuICAgIGlmIChzdHlsZS5zaXplID09PSBTdHlsZS5ESVNQTEFZLnNpemUgJiZcbiAgICAgICAgZ3JvdXAudmFsdWUuc3ltYm9sICYmXG4gICAgICAgICF1dGlscy5jb250YWlucyhub1N1Y2Nlc3NvciwgZ3JvdXAudmFsdWUuYm9keSkpIHtcblxuICAgICAgICAvLyBNb3N0IHN5bWJvbCBvcGVyYXRvcnMgZ2V0IGxhcmdlciBpbiBkaXNwbGF5c3R5bGUgKHJ1bGUgMTMpXG4gICAgICAgIGxhcmdlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZTtcbiAgICB2YXIgYmFzZVNoaWZ0ID0gMDtcbiAgICB2YXIgc2xhbnQgPSAwO1xuICAgIGlmIChncm91cC52YWx1ZS5zeW1ib2wpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN5bWJvbCwgY3JlYXRlIHRoZSBzeW1ib2wuXG4gICAgICAgIHZhciBmb250TmFtZSA9IGxhcmdlID8gXCJTaXplMi1SZWd1bGFyXCIgOiBcIlNpemUxLVJlZ3VsYXJcIjtcbiAgICAgICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woXG4gICAgICAgICAgICBncm91cC52YWx1ZS5ib2R5LCBmb250TmFtZSwgXCJtYXRoXCIsIG9wdGlvbnMsXG4gICAgICAgICAgICBbXCJtb3BcIiwgXCJvcC1zeW1ib2xcIiwgbGFyZ2UgPyBcImxhcmdlLW9wXCIgOiBcInNtYWxsLW9wXCJdKTtcblxuICAgICAgICAvLyBTaGlmdCB0aGUgc3ltYm9sIHNvIGl0cyBjZW50ZXIgbGllcyBvbiB0aGUgYXhpcyAocnVsZSAxMykuIEl0XG4gICAgICAgIC8vIGFwcGVhcnMgdGhhdCBvdXIgZm9udHMgaGF2ZSB0aGUgY2VudGVycyBvZiB0aGUgc3ltYm9scyBhbHJlYWR5XG4gICAgICAgIC8vIGFsbW9zdCBvbiB0aGUgYXhpcywgc28gdGhlc2UgbnVtYmVycyBhcmUgdmVyeSBzbWFsbC4gTm90ZSB3ZVxuICAgICAgICAvLyBkb24ndCBhY3R1YWxseSBhcHBseSB0aGlzIGhlcmUsIGJ1dCBpbnN0ZWFkIGl0IGlzIHVzZWQgZWl0aGVyIGluXG4gICAgICAgIC8vIHRoZSB2bGlzdCBjcmVhdGlvbiBvciBzZXBhcmF0ZWx5IHdoZW4gdGhlcmUgYXJlIG5vIGxpbWl0cy5cbiAgICAgICAgYmFzZVNoaWZ0ID0gKGJhc2UuaGVpZ2h0IC0gYmFzZS5kZXB0aCkgLyAyIC1cbiAgICAgICAgICAgIHN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodCAqIHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgICAgIC8vIFRoZSBzbGFudCBvZiB0aGUgc3ltYm9sIGlzIGp1c3QgaXRzIGl0YWxpYyBjb3JyZWN0aW9uLlxuICAgICAgICBzbGFudCA9IGJhc2UuaXRhbGljO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudmFsdWUudmFsdWUpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGxpc3QsIGNvbXBvc2UgdGhhdCBsaXN0LlxuICAgICAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgIGJhc2UgPSBtYWtlU3BhbihbXCJtb3BcIl0sIGlubmVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgaXMgYSB0ZXh0IG9wZXJhdG9yLiBCdWlsZCB0aGUgdGV4dCBmcm9tIHRoZVxuICAgICAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgICAgIC8vIFRPRE8oZW1pbHkpOiBBZGQgYSBzcGFjZSBpbiB0aGUgbWlkZGxlIG9mIHNvbWUgb2YgdGhlc2VcbiAgICAgICAgLy8gb3BlcmF0b3JzLCBsaWtlIFxcbGltc3VwXG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBncm91cC52YWx1ZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChidWlsZENvbW1vbi5tYXRoc3ltKGdyb3VwLnZhbHVlLmJvZHlbaV0sIGdyb3VwLm1vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBiYXNlID0gbWFrZVNwYW4oW1wibW9wXCJdLCBvdXRwdXQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChoYXNMaW1pdHMpIHtcbiAgICAgICAgLy8gSUUgOCBjbGlwcyBcXGludCBpZiBpdCBpcyBpbiBhIGRpc3BsYXk6IGlubGluZS1ibG9jay4gV2Ugd3JhcCBpdFxuICAgICAgICAvLyBpbiBhIG5ldyBzcGFuIHNvIGl0IGlzIGFuIGlubGluZSwgYW5kIHdvcmtzLlxuICAgICAgICBiYXNlID0gbWFrZVNwYW4oW10sIFtiYXNlXSk7XG5cbiAgICAgICAgdmFyIHN1cG1pZDtcbiAgICAgICAgdmFyIHN1cEtlcm47XG4gICAgICAgIHZhciBzdWJtaWQ7XG4gICAgICAgIHZhciBzdWJLZXJuO1xuICAgICAgICB2YXIgbmV3T3B0aW9ucztcbiAgICAgICAgLy8gV2UgbWFudWFsbHkgaGF2ZSB0byBoYW5kbGUgdGhlIHN1cGVyc2NyaXB0cyBhbmQgc3Vic2NyaXB0cy4gVGhpcyxcbiAgICAgICAgLy8gYXNpZGUgZnJvbSB0aGUga2VybiBjYWxjdWxhdGlvbnMsIGlzIGNvcGllZCBmcm9tIHN1cHN1Yi5cbiAgICAgICAgaWYgKHN1cEdyb3VwKSB7XG4gICAgICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuc3VwKCkpO1xuICAgICAgICAgICAgdmFyIHN1cCA9IGJ1aWxkR3JvdXAoc3VwR3JvdXAsIG5ld09wdGlvbnMpO1xuICAgICAgICAgICAgc3VwbWlkID0gbWFrZVNwYW4oW3N0eWxlLnJlc2V0KCksIHN0eWxlLnN1cCgpLmNscygpXSxcbiAgICAgICAgICAgICAgICBbc3VwXSwgbmV3T3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHN1cEtlcm4gPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBmb250TWV0cmljcy5tZXRyaWNzLmJpZ09wU3BhY2luZzEsXG4gICAgICAgICAgICAgICAgZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmczIC0gc3VwLmRlcHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWJHcm91cCkge1xuICAgICAgICAgICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aFN0eWxlKHN0eWxlLnN1YigpKTtcbiAgICAgICAgICAgIHZhciBzdWIgPSBidWlsZEdyb3VwKHN1Ykdyb3VwLCBuZXdPcHRpb25zKTtcbiAgICAgICAgICAgIHN1Ym1pZCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBzdHlsZS5zdWIoKS5jbHMoKV0sXG4gICAgICAgICAgICAgICAgW3N1Yl0sIG5ld09wdGlvbnMpO1xuXG4gICAgICAgICAgICBzdWJLZXJuID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmcyLFxuICAgICAgICAgICAgICAgIGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNCAtIHN1Yi5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgdGhlIGZpbmFsIGdyb3VwIGFzIGEgdmxpc3Qgb2YgdGhlIHBvc3NpYmxlIHN1YnNjcmlwdCwgYmFzZSxcbiAgICAgICAgLy8gYW5kIHBvc3NpYmxlIHN1cGVyc2NyaXB0LlxuICAgICAgICB2YXIgZmluYWxHcm91cDtcbiAgICAgICAgdmFyIHRvcDtcbiAgICAgICAgdmFyIGJvdHRvbTtcbiAgICAgICAgaWYgKCFzdXBHcm91cCkge1xuICAgICAgICAgICAgdG9wID0gYmFzZS5oZWlnaHQgLSBiYXNlU2hpZnQ7XG5cbiAgICAgICAgICAgIGZpbmFsR3JvdXAgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoW1xuICAgICAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmc1fSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IHN1Ym1pZH0sXG4gICAgICAgICAgICAgICAge3R5cGU6IFwia2VyblwiLCBzaXplOiBzdWJLZXJufSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGJhc2V9XG4gICAgICAgICAgICBdLCBcInRvcFwiLCB0b3AsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBIZXJlLCB3ZSBzaGlmdCB0aGUgbGltaXRzIGJ5IHRoZSBzbGFudCBvZiB0aGUgc3ltYm9sLiBOb3RlXG4gICAgICAgICAgICAvLyB0aGF0IHdlIGFyZSBzdXBwb3NlZCB0byBzaGlmdCB0aGUgbGltaXRzIGJ5IDEvMiBvZiB0aGUgc2xhbnQsXG4gICAgICAgICAgICAvLyBidXQgc2luY2Ugd2UgYXJlIGNlbnRlcmluZyB0aGUgbGltaXRzIGFkZGluZyBhIGZ1bGwgc2xhbnQgb2ZcbiAgICAgICAgICAgIC8vIG1hcmdpbiB3aWxsIHNoaWZ0IGJ5IDEvMiB0aGF0LlxuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5MZWZ0ID0gLXNsYW50ICsgXCJlbVwiO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdWJHcm91cCkge1xuICAgICAgICAgICAgYm90dG9tID0gYmFzZS5kZXB0aCArIGJhc2VTaGlmdDtcblxuICAgICAgICAgICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBiYXNlfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IHN1cEtlcm59LFxuICAgICAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNX1cbiAgICAgICAgICAgIF0sIFwiYm90dG9tXCIsIGJvdHRvbSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIGFib3V0IHNsYW50c1xuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblsxXS5zdHlsZS5tYXJnaW5MZWZ0ID0gc2xhbnQgKyBcImVtXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN1cEdyb3VwICYmICFzdWJHcm91cCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYXNlIHByb2JhYmx5IHNob3VsZG4ndCBvY2N1ciAodGhpcyB3b3VsZCBtZWFuIHRoZVxuICAgICAgICAgICAgLy8gc3Vwc3ViIHdhcyBzZW5kaW5nIHVzIGEgZ3JvdXAgd2l0aCBubyBzdXBlcnNjcmlwdCBvclxuICAgICAgICAgICAgLy8gc3Vic2NyaXB0KSBidXQgYmUgc2FmZS5cbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm90dG9tID0gZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmc1ICtcbiAgICAgICAgICAgICAgICBzdWJtaWQuaGVpZ2h0ICsgc3VibWlkLmRlcHRoICtcbiAgICAgICAgICAgICAgICBzdWJLZXJuICtcbiAgICAgICAgICAgICAgICBiYXNlLmRlcHRoICsgYmFzZVNoaWZ0O1xuXG4gICAgICAgICAgICBmaW5hbEdyb3VwID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNX0sXG4gICAgICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBzdWJtaWR9LFxuICAgICAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogc3ViS2Vybn0sXG4gICAgICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBiYXNlfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IHN1cEtlcm59LFxuICAgICAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNX1cbiAgICAgICAgICAgIF0sIFwiYm90dG9tXCIsIGJvdHRvbSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIGFib3V0IHNsYW50c1xuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5MZWZ0ID0gLXNsYW50ICsgXCJlbVwiO1xuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblsyXS5zdHlsZS5tYXJnaW5MZWZ0ID0gc2xhbnQgKyBcImVtXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFrZVNwYW4oW1wibW9wXCIsIFwib3AtbGltaXRzXCJdLCBbZmluYWxHcm91cF0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChncm91cC52YWx1ZS5zeW1ib2wpIHtcbiAgICAgICAgICAgIGJhc2Uuc3R5bGUudG9wID0gYmFzZVNoaWZ0ICsgXCJlbVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufTtcblxuZ3JvdXBUeXBlcy5tb2QgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBpbm5lciA9IFtdO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwiYm1vZFwiKSB7XG4gICAgICAgIC8vIOKAnFxcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcFxcbWtlcm41bXXigJ1cbiAgICAgICAgaWYgKCFvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihcbiAgICAgICAgICAgICAgICBbXCJtc3BhY2VcIiwgXCJuZWdhdGl2ZW1lZGl1bXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oW1wibXNwYWNlXCIsIFwidGhpY2tzcGFjZVwiXSwgW10sIG9wdGlvbnMpKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3R5bGUuc2l6ZSA9PT0gU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oW1wibXNwYWNlXCIsIFwicXVhZFwiXSwgW10sIG9wdGlvbnMpKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwibW9kXCIpIHtcbiAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtc3BhY2VcIiwgXCJ0d2VsdmVtdXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oW1wibXNwYWNlXCIsIFwiZWlnaHRtdXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlID09PSBcInBvZFwiIHx8IGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwicG1vZFwiKSB7XG4gICAgICAgIGlubmVyLnB1c2goYnVpbGRDb21tb24ubWF0aHN5bShcIihcIiwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlICE9PSBcInBvZFwiKSB7XG4gICAgICAgIHZhciBtb2RJbm5lciA9IFtcbiAgICAgICAgICAgIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXCJtXCIsIGdyb3VwLm1vZGUpLFxuICAgICAgICAgICAgYnVpbGRDb21tb24ubWF0aHN5bShcIm9cIiwgZ3JvdXAubW9kZSksXG4gICAgICAgICAgICBidWlsZENvbW1vbi5tYXRoc3ltKFwiZFwiLCBncm91cC5tb2RlKV07XG4gICAgICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlID09PSBcImJtb2RcIikge1xuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtYmluXCJdLCBtb2RJbm5lciwgb3B0aW9ucykpO1xuICAgICAgICAgICAgLy8g4oCcXFxta2VybjVtdVxcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcOKAnVxuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtc3BhY2VcIiwgXCJ0aGlja3NwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgICAgICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oXG4gICAgICAgICAgICAgICAgICAgIFtcIm1zcGFjZVwiLCBcIm5lZ2F0aXZlbWVkaXVtc3BhY2VcIl0sIFtdLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpbm5lciwgbW9kSW5uZXIpO1xuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtc3BhY2VcIiwgXCJzaXhtdXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnZhbHVlKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGlubmVyLFxuICAgICAgICAgICAgYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLnZhbHVlLCBvcHRpb25zLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlID09PSBcInBvZFwiIHx8IGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwicG1vZFwiKSB7XG4gICAgICAgIGlubmVyLnB1c2goYnVpbGRDb21tb24ubWF0aHN5bShcIilcIiwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoaW5uZXIpO1xufTtcblxuZ3JvdXBUeXBlcy5rYXRleCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gVGhlIEthVGVYIGxvZ28uIFRoZSBvZmZzZXRzIGZvciB0aGUgSyBhbmQgYSB3ZXJlIGNob3NlbiB0byBsb29rXG4gICAgLy8gZ29vZCwgYnV0IHRoZSBvZmZzZXRzIGZvciB0aGUgVCwgRSwgYW5kIFggd2VyZSB0YWtlbiBmcm9tIHRoZVxuICAgIC8vIGRlZmluaXRpb24gb2YgXFxUZVggaW4gVGVYIChzZWUgVGVYYm9vayBwZy4gMzU2KVxuICAgIHZhciBrID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImtcIl0sIFtidWlsZENvbW1vbi5tYXRoc3ltKFwiS1wiLCBncm91cC5tb2RlKV0sIG9wdGlvbnMpO1xuICAgIHZhciBhID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImFcIl0sIFtidWlsZENvbW1vbi5tYXRoc3ltKFwiQVwiLCBncm91cC5tb2RlKV0sIG9wdGlvbnMpO1xuXG4gICAgYS5oZWlnaHQgPSAoYS5oZWlnaHQgKyAwLjIpICogMC43NTtcbiAgICBhLmRlcHRoID0gKGEuaGVpZ2h0IC0gMC4yKSAqIDAuNzU7XG5cbiAgICB2YXIgdCA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJ0XCJdLCBbYnVpbGRDb21tb24ubWF0aHN5bShcIlRcIiwgZ3JvdXAubW9kZSldLCBvcHRpb25zKTtcbiAgICB2YXIgZSA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJlXCJdLCBbYnVpbGRDb21tb24ubWF0aHN5bShcIkVcIiwgZ3JvdXAubW9kZSldLCBvcHRpb25zKTtcblxuICAgIGUuaGVpZ2h0ID0gKGUuaGVpZ2h0IC0gMC4yMTU1KTtcbiAgICBlLmRlcHRoID0gKGUuZGVwdGggKyAwLjIxNTUpO1xuXG4gICAgdmFyIHggPSBtYWtlU3BhbihcbiAgICAgICAgW1wieFwiXSwgW2J1aWxkQ29tbW9uLm1hdGhzeW0oXCJYXCIsIGdyb3VwLm1vZGUpXSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgIFtcIm1vcmRcIiwgXCJrYXRleC1sb2dvXCJdLCBbaywgYSwgdCwgZSwgeF0sIG9wdGlvbnMpO1xufTtcblxuZ3JvdXBUeXBlcy5vdmVybGluZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gT3ZlcmxpbmVzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnIDQ0MywgUnVsZSA5LlxuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgICAvLyBCdWlsZCB0aGUgaW5uZXIgZ3JvdXAgaW4gdGhlIGNyYW1wZWQgc3R5bGUuXG4gICAgdmFyIGlubmVyR3JvdXAgPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksXG4gICAgICAgICAgICBvcHRpb25zLndpdGhTdHlsZShzdHlsZS5jcmFtcCgpKSk7XG5cbiAgICB2YXIgcnVsZVdpZHRoID0gZm9udE1ldHJpY3MubWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzcyAvXG4gICAgICAgIHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBsaW5lIGFib3ZlIHRoZSBib2R5XG4gICAgdmFyIGxpbmUgPSBtYWtlU3BhbihcbiAgICAgICAgW3N0eWxlLnJlc2V0KCksIFN0eWxlLlRFWFQuY2xzKCksIFwib3ZlcmxpbmUtbGluZVwiXSk7XG4gICAgbGluZS5oZWlnaHQgPSBydWxlV2lkdGg7XG4gICAgbGluZS5tYXhGb250U2l6ZSA9IDEuMDtcblxuICAgIC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnNcbiAgICB2YXIgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoW1xuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGlubmVyR3JvdXB9LFxuICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IDMgKiBydWxlV2lkdGh9LFxuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGxpbmV9LFxuICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IHJ1bGVXaWR0aH1cbiAgICBdLCBcImZpcnN0QmFzZWxpbmVcIiwgbnVsbCwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oW1wibW9yZFwiLCBcIm92ZXJsaW5lXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMudW5kZXJsaW5lID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBVbmRlcmxpbmVzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnIDQ0MywgUnVsZSAxMC5cbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgLy8gQnVpbGQgdGhlIGlubmVyIGdyb3VwLlxuICAgIHZhciBpbm5lckdyb3VwID0gYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zKTtcblxuICAgIHZhciBydWxlV2lkdGggPSBmb250TWV0cmljcy5tZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzIC9cbiAgICAgICAgc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGxpbmUgYWJvdmUgdGhlIGJvZHlcbiAgICB2YXIgbGluZSA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBTdHlsZS5URVhULmNscygpLCBcInVuZGVybGluZS1saW5lXCJdKTtcbiAgICBsaW5lLmhlaWdodCA9IHJ1bGVXaWR0aDtcbiAgICBsaW5lLm1heEZvbnRTaXplID0gMS4wO1xuXG4gICAgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJuc1xuICAgIHZhciB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogcnVsZVdpZHRofSxcbiAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBsaW5lfSxcbiAgICAgICAge3R5cGU6IFwia2VyblwiLCBzaXplOiAzICogcnVsZVdpZHRofSxcbiAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBpbm5lckdyb3VwfVxuICAgIF0sIFwidG9wXCIsIGlubmVyR3JvdXAuaGVpZ2h0LCBvcHRpb25zKTtcblxuICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwidW5kZXJsaW5lXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMuc3FydCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3F1YXJlIHJvb3RzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMsIFJ1bGUgMTEuXG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIC8vIEZpcnN0LCB3ZSBkbyB0aGUgc2FtZSBzdGVwcyBhcyBpbiBvdmVybGluZSB0byBidWlsZCB0aGUgaW5uZXIgZ3JvdXBcbiAgICAvLyBhbmQgbGluZVxuICAgIHZhciBpbm5lciA9IGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuY3JhbXAoKSkpO1xuXG4gICAgdmFyIHJ1bGVXaWR0aCA9IGZvbnRNZXRyaWNzLm1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3MgL1xuICAgICAgICBzdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIHZhciBsaW5lID0gbWFrZVNwYW4oXG4gICAgICAgIFtzdHlsZS5yZXNldCgpLCBTdHlsZS5URVhULmNscygpLCBcInNxcnQtbGluZVwiXSwgW10sXG4gICAgICAgIG9wdGlvbnMpO1xuICAgIGxpbmUuaGVpZ2h0ID0gcnVsZVdpZHRoO1xuICAgIGxpbmUubWF4Rm9udFNpemUgPSAxLjA7XG5cbiAgICB2YXIgcGhpID0gcnVsZVdpZHRoO1xuICAgIGlmIChzdHlsZS5pZCA8IFN0eWxlLlRFWFQuaWQpIHtcbiAgICAgICAgcGhpID0gc3R5bGUubWV0cmljcy54SGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY2xlYXJhbmNlIGJldHdlZW4gdGhlIGJvZHkgYW5kIGxpbmVcbiAgICB2YXIgbGluZUNsZWFyYW5jZSA9IHJ1bGVXaWR0aCArIHBoaSAvIDQ7XG5cbiAgICB2YXIgaW5uZXJIZWlnaHQgPSAoaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGgpICogc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIG1pbkRlbGltaXRlckhlaWdodCA9IGlubmVySGVpZ2h0ICsgbGluZUNsZWFyYW5jZSArIHJ1bGVXaWR0aDtcblxuICAgIC8vIENyZWF0ZSBhIFxcc3VyZCBkZWxpbWl0ZXIgb2YgdGhlIHJlcXVpcmVkIG1pbmltdW0gc2l6ZVxuICAgIHZhciBkZWxpbSA9IG1ha2VTcGFuKFtcInNxcnQtc2lnblwiXSwgW1xuICAgICAgICBkZWxpbWl0ZXIuY3VzdG9tU2l6ZWREZWxpbShcIlxcXFxzdXJkXCIsIG1pbkRlbGltaXRlckhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIG9wdGlvbnMsIGdyb3VwLm1vZGUpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zKTtcblxuICAgIHZhciBkZWxpbURlcHRoID0gKGRlbGltLmhlaWdodCArIGRlbGltLmRlcHRoKSAtIHJ1bGVXaWR0aDtcblxuICAgIC8vIEFkanVzdCB0aGUgY2xlYXJhbmNlIGJhc2VkIG9uIHRoZSBkZWxpbWl0ZXIgc2l6ZVxuICAgIGlmIChkZWxpbURlcHRoID4gaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGggKyBsaW5lQ2xlYXJhbmNlKSB7XG4gICAgICAgIGxpbmVDbGVhcmFuY2UgPVxuICAgICAgICAgICAgKGxpbmVDbGVhcmFuY2UgKyBkZWxpbURlcHRoIC0gaW5uZXIuaGVpZ2h0IC0gaW5uZXIuZGVwdGgpIC8gMjtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCB0aGUgZGVsaW1pdGVyIHNvIHRoYXQgaXRzIHRvcCBsaW5lcyB1cCB3aXRoIHRoZSB0b3Agb2YgdGhlIGxpbmVcbiAgICB2YXIgZGVsaW1TaGlmdCA9IC0oaW5uZXIuaGVpZ2h0ICsgbGluZUNsZWFyYW5jZSArIHJ1bGVXaWR0aCkgKyBkZWxpbS5oZWlnaHQ7XG4gICAgZGVsaW0uc3R5bGUudG9wID0gZGVsaW1TaGlmdCArIFwiZW1cIjtcbiAgICBkZWxpbS5oZWlnaHQgLT0gZGVsaW1TaGlmdDtcbiAgICBkZWxpbS5kZXB0aCArPSBkZWxpbVNoaWZ0O1xuXG4gICAgLy8gV2UgYWRkIGEgc3BlY2lhbCBjYXNlIGhlcmUsIGJlY2F1c2UgZXZlbiB3aGVuIGBpbm5lcmAgaXMgZW1wdHksIHdlXG4gICAgLy8gc3RpbGwgZ2V0IGEgbGluZS4gU28sIHdlIHVzZSBhIHNpbXBsZSBoZXVyaXN0aWMgdG8gZGVjaWRlIGlmIHdlXG4gICAgLy8gc2hvdWxkIG9taXQgdGhlIGJvZHkgZW50aXJlbHkuIChub3RlIHRoaXMgZG9lc24ndCB3b3JrIGZvciBzb21ldGhpbmdcbiAgICAvLyBsaWtlIGBcXHNxcnR7XFxybGFwe3h9fWAsIGJ1dCBpZiBzb21lb25lIGlzIGRvaW5nIHRoYXQgdGhleSBkZXNlcnZlIGZvclxuICAgIC8vIGl0IG5vdCB0byB3b3JrLlxuICAgIHZhciBib2R5O1xuICAgIGlmIChpbm5lci5oZWlnaHQgPT09IDAgJiYgaW5uZXIuZGVwdGggPT09IDApIHtcbiAgICAgICAgYm9keSA9IG1ha2VTcGFuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGlubmVyfSxcbiAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogbGluZUNsZWFyYW5jZX0sXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGxpbmV9LFxuICAgICAgICAgICAge3R5cGU6IFwia2VyblwiLCBzaXplOiBydWxlV2lkdGh9XG4gICAgICAgIF0sIFwiZmlyc3RCYXNlbGluZVwiLCBudWxsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoIWdyb3VwLnZhbHVlLmluZGV4KSB7XG4gICAgICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwic3FydFwiXSwgW2RlbGltLCBib2R5XSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBvcHRpb25hbCByb290IGluZGV4XG5cbiAgICAgICAgLy8gVGhlIGluZGV4IGlzIGFsd2F5cyBpbiBzY3JpcHRzY3JpcHQgc3R5bGVcbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLndpdGhTdHlsZShTdHlsZS5TQ1JJUFRTQ1JJUFQpO1xuICAgICAgICB2YXIgcm9vdCA9IGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuaW5kZXgsIG5ld09wdGlvbnMpO1xuICAgICAgICB2YXIgcm9vdFdyYXAgPSBtYWtlU3BhbihcbiAgICAgICAgICAgIFtzdHlsZS5yZXNldCgpLCBTdHlsZS5TQ1JJUFRTQ1JJUFQuY2xzKCldLFxuICAgICAgICAgICAgW3Jvb3RdLFxuICAgICAgICAgICAgbmV3T3B0aW9ucyk7XG5cbiAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgaGVpZ2h0IGFuZCBkZXB0aCBvZiB0aGUgaW5uZXIgcGFydFxuICAgICAgICB2YXIgaW5uZXJSb290SGVpZ2h0ID0gTWF0aC5tYXgoZGVsaW0uaGVpZ2h0LCBib2R5LmhlaWdodCk7XG4gICAgICAgIHZhciBpbm5lclJvb3REZXB0aCA9IE1hdGgubWF4KGRlbGltLmRlcHRoLCBib2R5LmRlcHRoKTtcblxuICAgICAgICAvLyBUaGUgYW1vdW50IHRoZSBpbmRleCBpcyBzaGlmdGVkIGJ5LiBUaGlzIGlzIHRha2VuIGZyb20gdGhlIFRlWFxuICAgICAgICAvLyBzb3VyY2UsIGluIHRoZSBkZWZpbml0aW9uIG9mIGBcXHJAQHRgLlxuICAgICAgICB2YXIgdG9TaGlmdCA9IDAuNiAqIChpbm5lclJvb3RIZWlnaHQgLSBpbm5lclJvb3REZXB0aCk7XG5cbiAgICAgICAgLy8gQnVpbGQgYSBWTGlzdCB3aXRoIHRoZSBzdXBlcnNjcmlwdCBzaGlmdGVkIHVwIGNvcnJlY3RseVxuICAgICAgICB2YXIgcm9vdFZMaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFxuICAgICAgICAgICAgW3t0eXBlOiBcImVsZW1cIiwgZWxlbTogcm9vdFdyYXB9XSxcbiAgICAgICAgICAgIFwic2hpZnRcIiwgLXRvU2hpZnQsIG9wdGlvbnMpO1xuICAgICAgICAvLyBBZGQgYSBjbGFzcyBzdXJyb3VuZGluZyBpdCBzbyB3ZSBjYW4gYWRkIG9uIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgICAvLyBrZXJuaW5nXG4gICAgICAgIHZhciByb290Vkxpc3RXcmFwID0gbWFrZVNwYW4oW1wicm9vdFwiXSwgW3Jvb3RWTGlzdF0pO1xuXG4gICAgICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwic3FydFwiXSxcbiAgICAgICAgICAgIFtyb290Vkxpc3RXcmFwLCBkZWxpbSwgYm9keV0sIG9wdGlvbnMpO1xuICAgIH1cbn07XG5cbmdyb3VwVHlwZXMuc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBIYW5kbGUgc2l6aW5nIG9wZXJhdG9ycyBsaWtlIFxcSHVnZS4gUmVhbCBUZVggZG9lc24ndCBhY3R1YWxseSBhbGxvd1xuICAgIC8vIHRoZXNlIGZ1bmN0aW9ucyBpbnNpZGUgb2YgbWF0aCBleHByZXNzaW9ucywgc28gd2UgZG8gc29tZSBzcGVjaWFsXG4gICAgLy8gaGFuZGxpbmcuXG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgb3B0aW9ucy53aXRoU2l6ZShncm91cC52YWx1ZS5zaXplKSwgZmFsc2UpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgY29ycmVjdCBtYXhGb250U2l6ZS5cbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBmb250U2l6ZSA9IGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbZ3JvdXAudmFsdWUuc2l6ZV07XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAqIHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgLy8gQWRkIHNpemUtcmVzZXR0aW5nIGNsYXNzZXMgdG8gdGhlIGlubmVyIGxpc3QgYW5kIHNldCBtYXhGb250U2l6ZVxuICAgIC8vIG1hbnVhbGx5LiBIYW5kbGUgbmVzdGVkIHNpemUgY2hhbmdlcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwb3MgPSB1dGlscy5pbmRleE9mKGlubmVyW2ldLmNsYXNzZXMsIFwic2l6aW5nXCIpO1xuICAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgICAgaW5uZXJbaV0uY2xhc3Nlcy5wdXNoKFwic2l6aW5nXCIsIFwicmVzZXQtXCIgKyBvcHRpb25zLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAudmFsdWUuc2l6ZSwgc3R5bGUuY2xzKCkpO1xuICAgICAgICAgICAgaW5uZXJbaV0ubWF4Rm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbm5lcltpXS5jbGFzc2VzW3BvcyArIDFdID09PSBcInJlc2V0LVwiICsgZ3JvdXAudmFsdWUuc2l6ZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5lc3RlZCBzaXplIGNoYW5nZTogZS5nLiwgaW5uZXJbaV0gaXMgdGhlIFwiYlwiIGluXG4gICAgICAgICAgICAvLyBgXFxIdWdlIGEgXFxzbWFsbCBiYC4gT3ZlcnJpZGUgdGhlIG9sZCBzaXplICh0aGUgYHJlc2V0LWAgY2xhc3MpXG4gICAgICAgICAgICAvLyBidXQgbm90IHRoZSBuZXcgc2l6ZS5cbiAgICAgICAgICAgIGlubmVyW2ldLmNsYXNzZXNbcG9zICsgMV0gPSBcInJlc2V0LVwiICsgb3B0aW9ucy5zaXplO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChpbm5lcik7XG59O1xuXG5ncm91cFR5cGVzLnN0eWxpbmcgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFN0eWxlIGNoYW5nZXMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGcuIDQ0MiwgUnVsZSAzLlxuXG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHdlJ3JlIGNoYW5naW5nIHRvLlxuICAgIHZhciBzdHlsZU1hcCA9IHtcbiAgICAgICAgXCJkaXNwbGF5XCI6IFN0eWxlLkRJU1BMQVksXG4gICAgICAgIFwidGV4dFwiOiBTdHlsZS5URVhULFxuICAgICAgICBcInNjcmlwdFwiOiBTdHlsZS5TQ1JJUFQsXG4gICAgICAgIFwic2NyaXB0c2NyaXB0XCI6IFN0eWxlLlNDUklQVFNDUklQVFxuICAgIH07XG5cbiAgICB2YXIgbmV3U3R5bGUgPSBzdHlsZU1hcFtncm91cC52YWx1ZS5zdHlsZV07XG4gICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLndpdGhTdHlsZShuZXdTdHlsZSk7XG5cbiAgICAvLyBCdWlsZCB0aGUgaW5uZXIgZXhwcmVzc2lvbiBpbiB0aGUgbmV3IHN0eWxlLlxuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihcbiAgICAgICAgZ3JvdXAudmFsdWUudmFsdWUsIG5ld09wdGlvbnMsIGZhbHNlKTtcblxuICAgIC8vIEFkZCBzdHlsZS1yZXNldHRpbmcgY2xhc3NlcyB0byB0aGUgaW5uZXIgbGlzdC4gSGFuZGxlIG5lc3RlZCBjaGFuZ2VzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBvcyA9IHV0aWxzLmluZGV4T2YoaW5uZXJbaV0uY2xhc3NlcywgbmV3U3R5bGUucmVzZXQoKSk7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgICBpbm5lcltpXS5jbGFzc2VzLnB1c2gob3B0aW9ucy5zdHlsZS5yZXNldCgpLCBuZXdTdHlsZS5jbHMoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbmVzdGVkIHN0eWxlIGNoYW5nZSwgYXMgYFxcdGV4dHN0eWxlIGFcXHNjcmlwdHN0eWxlIGJgLlxuICAgICAgICAgICAgLy8gT25seSBvdmVycmlkZSB0aGUgb2xkIHN0eWxlICh0aGUgcmVzZXQgY2xhc3MpLlxuICAgICAgICAgICAgaW5uZXJbaV0uY2xhc3Nlc1twb3NdID0gb3B0aW9ucy5zdHlsZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoaW5uZXIpO1xufTtcblxuZ3JvdXBUeXBlcy5mb250ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9udCA9IGdyb3VwLnZhbHVlLmZvbnQ7XG4gICAgcmV0dXJuIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy53aXRoRm9udChmb250KSk7XG59O1xuXG5ncm91cFR5cGVzLmRlbGltc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGVsaW0gPSBncm91cC52YWx1ZS52YWx1ZTtcblxuICAgIGlmIChkZWxpbSA9PT0gXCIuXCIpIHtcbiAgICAgICAgLy8gRW1wdHkgZGVsaW1pdGVycyBzdGlsbCBjb3VudCBhcyBlbGVtZW50cywgZXZlbiB0aG91Z2ggdGhleSBkb24ndFxuICAgICAgICAvLyBzaG93IGFueXRoaW5nLlxuICAgICAgICByZXR1cm4gbWFrZVNwYW4oW2dyb3VwLnZhbHVlLm1jbGFzc10pO1xuICAgIH1cblxuICAgIC8vIFVzZSBkZWxpbWl0ZXIuc2l6ZWREZWxpbSB0byBnZW5lcmF0ZSB0aGUgZGVsaW1pdGVyLlxuICAgIHJldHVybiBkZWxpbWl0ZXIuc2l6ZWREZWxpbShcbiAgICAgICAgICAgIGRlbGltLCBncm91cC52YWx1ZS5zaXplLCBvcHRpb25zLCBncm91cC5tb2RlLFxuICAgICAgICAgICAgW2dyb3VwLnZhbHVlLm1jbGFzc10pO1xufTtcblxuZ3JvdXBUeXBlcy5sZWZ0cmlnaHQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIEJ1aWxkIHRoZSBpbm5lciBleHByZXNzaW9uXG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMucmVzZXQoKSwgdHJ1ZSk7XG5cbiAgICB2YXIgaW5uZXJIZWlnaHQgPSAwO1xuICAgIHZhciBpbm5lckRlcHRoID0gMDtcbiAgICB2YXIgaGFkTWlkZGxlID0gZmFsc2U7XG5cbiAgICAvLyBDYWxjdWxhdGUgaXRzIGhlaWdodCBhbmQgZGVwdGhcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbm5lcltpXS5pc01pZGRsZSkge1xuICAgICAgICAgICAgaGFkTWlkZGxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlubmVySGVpZ2h0ID0gTWF0aC5tYXgoaW5uZXJbaV0uaGVpZ2h0LCBpbm5lckhlaWdodCk7XG4gICAgICAgICAgICBpbm5lckRlcHRoID0gTWF0aC5tYXgoaW5uZXJbaV0uZGVwdGgsIGlubmVyRGVwdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIC8vIFRoZSBzaXplIG9mIGRlbGltaXRlcnMgaXMgdGhlIHNhbWUsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBzdHlsZSB3ZSBhcmVcbiAgICAvLyBpbi4gVGh1cywgdG8gY29ycmVjdGx5IGNhbGN1bGF0ZSB0aGUgc2l6ZSBvZiBkZWxpbWl0ZXIgd2UgbmVlZCBhcm91bmRcbiAgICAvLyBhIGdyb3VwLCB3ZSBzY2FsZSBkb3duIHRoZSBpbm5lciBzaXplIGJhc2VkIG9uIHRoZSBzaXplLlxuICAgIGlubmVySGVpZ2h0ICo9IHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuICAgIGlubmVyRGVwdGggKj0gc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICB2YXIgbGVmdERlbGltO1xuICAgIGlmIChncm91cC52YWx1ZS5sZWZ0ID09PSBcIi5cIikge1xuICAgICAgICAvLyBFbXB0eSBkZWxpbWl0ZXJzIGluIFxcbGVmdCBhbmQgXFxyaWdodCBtYWtlIG51bGwgZGVsaW1pdGVyIHNwYWNlcy5cbiAgICAgICAgbGVmdERlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW1wibW9wZW5cIl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIGxlZnRSaWdodERlbGltIHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IHNpemVkXG4gICAgICAgIC8vIGRlbGltaXRlci5cbiAgICAgICAgbGVmdERlbGltID0gZGVsaW1pdGVyLmxlZnRSaWdodERlbGltKFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUubGVmdCwgaW5uZXJIZWlnaHQsIGlubmVyRGVwdGgsIG9wdGlvbnMsXG4gICAgICAgICAgICBncm91cC5tb2RlLCBbXCJtb3BlblwiXSk7XG4gICAgfVxuICAgIC8vIEFkZCBpdCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBleHByZXNzaW9uXG4gICAgaW5uZXIudW5zaGlmdChsZWZ0RGVsaW0pO1xuXG4gICAgLy8gSGFuZGxlIG1pZGRsZSBkZWxpbWl0ZXJzXG4gICAgaWYgKGhhZE1pZGRsZSkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbm5lcltpXS5pc01pZGRsZSkge1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBvcHRpb25zIHRoYXQgd2VyZSBhY3RpdmUgd2hlbiBcXG1pZGRsZSB3YXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgaW5uZXJbaV0gPSBkZWxpbWl0ZXIubGVmdFJpZ2h0RGVsaW0oXG4gICAgICAgICAgICAgICAgICAgIGlubmVyW2ldLmlzTWlkZGxlLnZhbHVlLCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCxcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJbaV0uaXNNaWRkbGUub3B0aW9ucywgZ3JvdXAubW9kZSwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJpZ2h0RGVsaW07XG4gICAgLy8gU2FtZSBmb3IgdGhlIHJpZ2h0IGRlbGltaXRlclxuICAgIGlmIChncm91cC52YWx1ZS5yaWdodCA9PT0gXCIuXCIpIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1jbG9zZVwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IGRlbGltaXRlci5sZWZ0UmlnaHREZWxpbShcbiAgICAgICAgICAgIGdyb3VwLnZhbHVlLnJpZ2h0LCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCwgb3B0aW9ucyxcbiAgICAgICAgICAgIGdyb3VwLm1vZGUsIFtcIm1jbG9zZVwiXSk7XG4gICAgfVxuICAgIC8vIEFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uLlxuICAgIGlubmVyLnB1c2gocmlnaHREZWxpbSk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgIFtcIm1pbm5lclwiLCBzdHlsZS5jbHMoKV0sIGlubmVyLCBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMubWlkZGxlID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbWlkZGxlRGVsaW07XG4gICAgaWYgKGdyb3VwLnZhbHVlLnZhbHVlID09PSBcIi5cIikge1xuICAgICAgICBtaWRkbGVEZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtaWRkbGVEZWxpbSA9IGRlbGltaXRlci5zaXplZERlbGltKFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUudmFsdWUsIDEsIG9wdGlvbnMsXG4gICAgICAgICAgICBncm91cC5tb2RlLCBbXSk7XG4gICAgICAgIG1pZGRsZURlbGltLmlzTWlkZGxlID0ge3ZhbHVlOiBncm91cC52YWx1ZS52YWx1ZSwgb3B0aW9uczogb3B0aW9uc307XG4gICAgfVxuICAgIHJldHVybiBtaWRkbGVEZWxpbTtcbn07XG5cbmdyb3VwVHlwZXMucnVsZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gTWFrZSBhbiBlbXB0eSBzcGFuIGZvciB0aGUgcnVsZVxuICAgIHZhciBydWxlID0gbWFrZVNwYW4oW1wibW9yZFwiLCBcInJ1bGVcIl0sIFtdLCBvcHRpb25zKTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzaGlmdCwgd2lkdGgsIGFuZCBoZWlnaHQgb2YgdGhlIHJ1bGUsIGFuZCBhY2NvdW50IGZvciB1bml0c1xuICAgIHZhciBzaGlmdCA9IDA7XG4gICAgaWYgKGdyb3VwLnZhbHVlLnNoaWZ0KSB7XG4gICAgICAgIHNoaWZ0ID0gY2FsY3VsYXRlU2l6ZShncm91cC52YWx1ZS5zaGlmdCwgc3R5bGUpO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAudmFsdWUud2lkdGgsIHN0eWxlKTtcbiAgICB2YXIgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC52YWx1ZS5oZWlnaHQsIHN0eWxlKTtcblxuICAgIC8vIFRoZSBzaXplcyBvZiBydWxlcyBhcmUgYWJzb2x1dGUsIHNvIG1ha2UgaXQgbGFyZ2VyIGlmIHdlIGFyZSBpbiBhXG4gICAgLy8gc21hbGxlciBzdHlsZS5cbiAgICBzaGlmdCAvPSBzdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICB3aWR0aCAvPSBzdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICBoZWlnaHQgLz0gc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICAvLyBTdHlsZSB0aGUgcnVsZSB0byB0aGUgcmlnaHQgc2l6ZVxuICAgIHJ1bGUuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IHdpZHRoICsgXCJlbVwiO1xuICAgIHJ1bGUuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBoZWlnaHQgKyBcImVtXCI7XG4gICAgcnVsZS5zdHlsZS5ib3R0b20gPSBzaGlmdCArIFwiZW1cIjtcblxuICAgIC8vIFJlY29yZCB0aGUgaGVpZ2h0IGFuZCB3aWR0aFxuICAgIHJ1bGUud2lkdGggPSB3aWR0aDtcbiAgICBydWxlLmhlaWdodCA9IGhlaWdodCArIHNoaWZ0O1xuICAgIHJ1bGUuZGVwdGggPSAtc2hpZnQ7XG5cbiAgICByZXR1cm4gcnVsZTtcbn07XG5cbmdyb3VwVHlwZXMua2VybiA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gTWFrZSBhbiBlbXB0eSBzcGFuIGZvciB0aGUgcnVsZVxuICAgIHZhciBydWxlID0gbWFrZVNwYW4oW1wibW9yZFwiLCBcInJ1bGVcIl0sIFtdLCBvcHRpb25zKTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgdmFyIGRpbWVuc2lvbiA9IDA7XG4gICAgaWYgKGdyb3VwLnZhbHVlLmRpbWVuc2lvbikge1xuICAgICAgICBkaW1lbnNpb24gPSBjYWxjdWxhdGVTaXplKGdyb3VwLnZhbHVlLmRpbWVuc2lvbiwgc3R5bGUpO1xuICAgIH1cblxuICAgIGRpbWVuc2lvbiAvPSBzdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIHJ1bGUuc3R5bGUubWFyZ2luTGVmdCA9IGRpbWVuc2lvbiArIFwiZW1cIjtcblxuICAgIHJldHVybiBydWxlO1xufTtcblxuZ3JvdXBUeXBlcy5hY2NlbnQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIEFjY2VudHMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcuIDQ0MywgcnVsZSAxMi5cbiAgICB2YXIgYmFzZSA9IGdyb3VwLnZhbHVlLmJhc2U7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIHZhciBzdXBzdWJHcm91cDtcbiAgICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJzdXBzdWJcIikge1xuICAgICAgICAvLyBJZiBvdXIgYmFzZSBpcyBhIGNoYXJhY3RlciBib3gsIGFuZCB3ZSBoYXZlIHN1cGVyc2NyaXB0cyBhbmRcbiAgICAgICAgLy8gc3Vic2NyaXB0cywgdGhlIHN1cHN1YiB3aWxsIGRlZmVyIHRvIHVzLiBJbiBwYXJ0aWN1bGFyLCB3ZSB3YW50XG4gICAgICAgIC8vIHRvIGF0dGFjaCB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIHRvIHRoZSBpbm5lciBib2R5IChzb1xuICAgICAgICAvLyB0aGF0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIHdvbid0IGJlXG4gICAgICAgIC8vIGFmZmVjdGVkIGJ5IHRoZSBoZWlnaHQgb2YgdGhlIGFjY2VudCkuIFdlIGFjY29tcGxpc2ggdGhpcyBieVxuICAgICAgICAvLyBzdGlja2luZyB0aGUgYmFzZSBvZiB0aGUgYWNjZW50IGludG8gdGhlIGJhc2Ugb2YgdGhlIHN1cHN1YiwgYW5kXG4gICAgICAgIC8vIHJlbmRlcmluZyB0aGF0LCB3aGlsZSBrZWVwaW5nIHRyYWNrIG9mIHdoZXJlIHRoZSBhY2NlbnQgaXMuXG5cbiAgICAgICAgLy8gVGhlIHN1cHN1YiBncm91cCBpcyB0aGUgZ3JvdXAgdGhhdCB3YXMgcGFzc2VkIGluXG4gICAgICAgIHZhciBzdXBzdWIgPSBncm91cDtcbiAgICAgICAgLy8gVGhlIHJlYWwgYWNjZW50IGdyb3VwIGlzIHRoZSBiYXNlIG9mIHRoZSBzdXBzdWIgZ3JvdXBcbiAgICAgICAgZ3JvdXAgPSBzdXBzdWIudmFsdWUuYmFzZTtcbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciBib3ggaXMgdGhlIGJhc2Ugb2YgdGhlIGFjY2VudCBncm91cFxuICAgICAgICBiYXNlID0gZ3JvdXAudmFsdWUuYmFzZTtcbiAgICAgICAgLy8gU3RpY2sgdGhlIGNoYXJhY3RlciBib3ggaW50byB0aGUgYmFzZSBvZiB0aGUgc3Vwc3ViIGdyb3VwXG4gICAgICAgIHN1cHN1Yi52YWx1ZS5iYXNlID0gYmFzZTtcblxuICAgICAgICAvLyBSZXJlbmRlciB0aGUgc3Vwc3ViIGdyb3VwIHdpdGggaXRzIG5ldyBiYXNlLCBhbmQgc3RvcmUgdGhhdFxuICAgICAgICAvLyByZXN1bHQuXG4gICAgICAgIHN1cHN1Ykdyb3VwID0gYnVpbGRHcm91cChcbiAgICAgICAgICAgIHN1cHN1Yiwgb3B0aW9ucy5yZXNldCgpKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmFzZSBncm91cFxuICAgIHZhciBib2R5ID0gYnVpbGRHcm91cChcbiAgICAgICAgYmFzZSwgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuY3JhbXAoKSkpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBza2V3IG9mIHRoZSBhY2NlbnQuIFRoaXMgaXMgYmFzZWQgb24gdGhlIGxpbmUgXCJJZiB0aGVcbiAgICAvLyBudWNsZXVzIGlzIG5vdCBhIHNpbmdsZSBjaGFyYWN0ZXIsIGxldCBzID0gMDsgb3RoZXJ3aXNlIHNldCBzIHRvIHRoZVxuICAgIC8vIGtlcm4gYW1vdW50IGZvciB0aGUgbnVjbGV1cyBmb2xsb3dlZCBieSB0aGUgXFxza2V3Y2hhciBvZiBpdHMgZm9udC5cIlxuICAgIC8vIE5vdGUgdGhhdCBvdXIgc2tldyBtZXRyaWNzIGFyZSBqdXN0IHRoZSBrZXJuIGJldHdlZW4gZWFjaCBjaGFyYWN0ZXJcbiAgICAvLyBhbmQgdGhlIHNrZXdjaGFyLlxuICAgIHZhciBza2V3O1xuICAgIGlmIChpc0NoYXJhY3RlckJveChiYXNlKSkge1xuICAgICAgICAvLyBJZiB0aGUgYmFzZSBpcyBhIGNoYXJhY3RlciBib3gsIHRoZW4gd2Ugd2FudCB0aGUgc2tldyBvZiB0aGVcbiAgICAgICAgLy8gaW5uZXJtb3N0IGNoYXJhY3Rlci4gVG8gZG8gdGhhdCwgd2UgZmluZCB0aGUgaW5uZXJtb3N0IGNoYXJhY3RlcjpcbiAgICAgICAgdmFyIGJhc2VDaGFyID0gZ2V0QmFzZUVsZW0oYmFzZSk7XG4gICAgICAgIC8vIFRoZW4sIHdlIHJlbmRlciBpdHMgZ3JvdXAgdG8gZ2V0IHRoZSBzeW1ib2wgaW5zaWRlIGl0XG4gICAgICAgIHZhciBiYXNlR3JvdXAgPSBidWlsZEdyb3VwKFxuICAgICAgICAgICAgYmFzZUNoYXIsIG9wdGlvbnMud2l0aFN0eWxlKHN0eWxlLmNyYW1wKCkpKTtcbiAgICAgICAgLy8gRmluYWxseSwgd2UgcHVsbCB0aGUgc2tldyBvZmYgb2YgdGhlIHN5bWJvbC5cbiAgICAgICAgc2tldyA9IGJhc2VHcm91cC5za2V3O1xuICAgICAgICAvLyBOb3RlIHRoYXQgd2Ugbm93IHRocm93IGF3YXkgYmFzZUdyb3VwLCBiZWNhdXNlIHRoZSBsYXllcnMgd2VcbiAgICAgICAgLy8gcmVtb3ZlZCB3aXRoIGdldEJhc2VFbGVtIG1pZ2h0IGNvbnRhaW4gdGhpbmdzIGxpa2UgXFxjb2xvciB3aGljaFxuICAgICAgICAvLyB3ZSBjYW4ndCBnZXQgcmlkIG9mLlxuICAgICAgICAvLyBUT0RPKGVtaWx5KTogRmluZCBhIGJldHRlciB3YXkgdG8gZ2V0IHRoZSBza2V3XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2tldyA9IDA7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiB0aGUgYm9keSBhbmQgdGhlIGFjY2VudFxuICAgIHZhciBjbGVhcmFuY2UgPSBNYXRoLm1pbihcbiAgICAgICAgYm9keS5oZWlnaHQsXG4gICAgICAgIHN0eWxlLm1ldHJpY3MueEhlaWdodCk7XG5cbiAgICAvLyBCdWlsZCB0aGUgYWNjZW50XG4gICAgdmFyIGFjY2VudCA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woXG4gICAgICAgIGdyb3VwLnZhbHVlLmFjY2VudCwgXCJNYWluLVJlZ3VsYXJcIiwgXCJtYXRoXCIsIG9wdGlvbnMpO1xuICAgIC8vIFJlbW92ZSB0aGUgaXRhbGljIGNvcnJlY3Rpb24gb2YgdGhlIGFjY2VudCwgYmVjYXVzZSBpdCBvbmx5IHNlcnZlcyB0b1xuICAgIC8vIHNoaWZ0IHRoZSBhY2NlbnQgb3ZlciB0byBhIHBsYWNlIHdlIGRvbid0IHdhbnQuXG4gICAgYWNjZW50Lml0YWxpYyA9IDA7XG5cbiAgICAvLyBUaGUgXFx2ZWMgY2hhcmFjdGVyIHRoYXQgdGhlIGZvbnRzIHVzZSBpcyBhIGNvbWJpbmluZyBjaGFyYWN0ZXIsIGFuZFxuICAgIC8vIHRodXMgc2hvd3MgdXAgbXVjaCB0b28gZmFyIHRvIHRoZSBsZWZ0LiBUbyBhY2NvdW50IGZvciB0aGlzLCB3ZSBhZGQgYVxuICAgIC8vIHNwZWNpZmljIGNsYXNzIHdoaWNoIHNoaWZ0cyB0aGUgYWNjZW50IG92ZXIgdG8gd2hlcmUgd2Ugd2FudCBpdC5cbiAgICAvLyBUT0RPKGVtaWx5KTogRml4IHRoaXMgaW4gYSBiZXR0ZXIgd2F5LCBsaWtlIGJ5IGNoYW5naW5nIHRoZSBmb250XG4gICAgdmFyIHZlY0NsYXNzID0gZ3JvdXAudmFsdWUuYWNjZW50ID09PSBcIlxcXFx2ZWNcIiA/IFwiYWNjZW50LXZlY1wiIDogbnVsbDtcblxuICAgIHZhciBhY2NlbnRCb2R5ID0gbWFrZVNwYW4oW1wiYWNjZW50LWJvZHlcIiwgdmVjQ2xhc3NdLCBbXG4gICAgICAgIG1ha2VTcGFuKFtdLCBbYWNjZW50XSldKTtcblxuICAgIGFjY2VudEJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoW1xuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGJvZHl9LFxuICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IC1jbGVhcmFuY2V9LFxuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGFjY2VudEJvZHl9XG4gICAgXSwgXCJmaXJzdEJhc2VsaW5lXCIsIG51bGwsIG9wdGlvbnMpO1xuXG4gICAgLy8gU2hpZnQgdGhlIGFjY2VudCBvdmVyIGJ5IHRoZSBza2V3LiBOb3RlIHdlIHNoaWZ0IGJ5IHR3aWNlIHRoZSBza2V3XG4gICAgLy8gYmVjYXVzZSB3ZSBhcmUgY2VudGVyaW5nIHRoZSBhY2NlbnQsIHNvIGJ5IGFkZGluZyAyKnNrZXcgdG8gdGhlIGxlZnQsXG4gICAgLy8gd2Ugc2hpZnQgaXQgdG8gdGhlIHJpZ2h0IGJ5IDEqc2tldy5cbiAgICBhY2NlbnRCb2R5LmNoaWxkcmVuWzFdLnN0eWxlLm1hcmdpbkxlZnQgPSAyICogc2tldyArIFwiZW1cIjtcblxuICAgIHZhciBhY2NlbnRXcmFwID0gbWFrZVNwYW4oW1wibW9yZFwiLCBcImFjY2VudFwiXSwgW2FjY2VudEJvZHldLCBvcHRpb25zKTtcblxuICAgIGlmIChzdXBzdWJHcm91cCkge1xuICAgICAgICAvLyBIZXJlLCB3ZSByZXBsYWNlIHRoZSBcImJhc2VcIiBjaGlsZCBvZiB0aGUgc3Vwc3ViIHdpdGggb3VyIG5ld2x5XG4gICAgICAgIC8vIGdlbmVyYXRlZCBhY2NlbnQuXG4gICAgICAgIHN1cHN1Ykdyb3VwLmNoaWxkcmVuWzBdID0gYWNjZW50V3JhcDtcblxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCByZXJ1biB0aGUgaGVpZ2h0IGNhbGN1bGF0aW9uIGFmdGVyIHJlcGxhY2luZyB0aGVcbiAgICAgICAgLy8gYWNjZW50LCB3ZSBtYW51YWxseSByZWNhbGN1bGF0ZSBoZWlnaHQuXG4gICAgICAgIHN1cHN1Ykdyb3VwLmhlaWdodCA9IE1hdGgubWF4KGFjY2VudFdyYXAuaGVpZ2h0LCBzdXBzdWJHcm91cC5oZWlnaHQpO1xuXG4gICAgICAgIC8vIEFjY2VudHMgc2hvdWxkIGFsd2F5cyBiZSBvcmRzLCBldmVuIHdoZW4gdGhlaXIgaW5uYXJkcyBhcmUgbm90LlxuICAgICAgICBzdXBzdWJHcm91cC5jbGFzc2VzWzBdID0gXCJtb3JkXCI7XG5cbiAgICAgICAgcmV0dXJuIHN1cHN1Ykdyb3VwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhY2NlbnRXcmFwO1xuICAgIH1cbn07XG5cbmdyb3VwVHlwZXMucGhhbnRvbSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKFxuICAgICAgICBncm91cC52YWx1ZS52YWx1ZSxcbiAgICAgICAgb3B0aW9ucy53aXRoUGhhbnRvbSgpLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICAvLyBcXHBoYW50b20gaXNuJ3Qgc3VwcG9zZWQgdG8gYWZmZWN0IHRoZSBlbGVtZW50cyBpdCBjb250YWlucy5cbiAgICAvLyBTZWUgXCJjb2xvclwiIGZvciBtb3JlIGRldGFpbHMuXG4gICAgcmV0dXJuIG5ldyBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xufTtcblxuZ3JvdXBUeXBlcy5tY2xhc3MgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC52YWx1ZS52YWx1ZSwgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oW2dyb3VwLnZhbHVlLm1jbGFzc10sIGVsZW1lbnRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogYnVpbGRHcm91cCBpcyB0aGUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGdyb3VwIGFuZCBjYWxscyB0aGUgY29ycmVjdCBncm91cFR5cGVcbiAqIGZ1bmN0aW9uIGZvciBpdC4gSXQgYWxzbyBoYW5kbGVzIHRoZSBpbnRlcmFjdGlvbiBvZiBzaXplIGFuZCBzdHlsZSBjaGFuZ2VzXG4gKiBiZXR3ZWVuIHBhcmVudHMgYW5kIGNoaWxkcmVuLlxuICovXG52YXIgYnVpbGRHcm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgICByZXR1cm4gbWFrZVNwYW4oKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXBUeXBlc1tncm91cC50eXBlXSkge1xuICAgICAgICAvLyBDYWxsIHRoZSBncm91cFR5cGVzIGZ1bmN0aW9uXG4gICAgICAgIHZhciBncm91cE5vZGUgPSBncm91cFR5cGVzW2dyb3VwLnR5cGVdKGdyb3VwLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG11bHRpcGxpZXI7XG5cbiAgICAgICAgLy8gSWYgdGhlIHN0eWxlIGNoYW5nZWQgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY3VycmVudCBncm91cCxcbiAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHNpemUgZGlmZmVyZW5jZVxuICAgICAgICBpZiAob3B0aW9ucy5zdHlsZSAhPT0gb3B0aW9ucy5wYXJlbnRTdHlsZSkge1xuICAgICAgICAgICAgbXVsdGlwbGllciA9IG9wdGlvbnMuc3R5bGUuc2l6ZU11bHRpcGxpZXIgL1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudFN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgICAgICAgICBncm91cE5vZGUuaGVpZ2h0ICo9IG11bHRpcGxpZXI7XG4gICAgICAgICAgICBncm91cE5vZGUuZGVwdGggKj0gbXVsdGlwbGllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBzaXplIGNoYW5nZWQgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY3VycmVudCBncm91cCwgYWNjb3VudFxuICAgICAgICAvLyBmb3IgdGhhdCBzaXplIGRpZmZlcmVuY2UuXG4gICAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IG9wdGlvbnMucGFyZW50U2l6ZSkge1xuICAgICAgICAgICAgbXVsdGlwbGllciA9IGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbb3B0aW9ucy5zaXplXSAvXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbb3B0aW9ucy5wYXJlbnRTaXplXTtcblxuICAgICAgICAgICAgZ3JvdXBOb2RlLmhlaWdodCAqPSBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgZ3JvdXBOb2RlLmRlcHRoICo9IG11bHRpcGxpZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXBOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgXCJHb3QgZ3JvdXAgb2YgdW5rbm93biB0eXBlOiAnXCIgKyBncm91cC50eXBlICsgXCInXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGFrZSBhbiBlbnRpcmUgcGFyc2UgdHJlZSwgYW5kIGJ1aWxkIGl0IGludG8gYW4gYXBwcm9wcmlhdGUgc2V0IG9mIEhUTUxcbiAqIG5vZGVzLlxuICovXG52YXIgYnVpbGRIVE1MID0gZnVuY3Rpb24odHJlZSwgb3B0aW9ucykge1xuICAgIC8vIGJ1aWxkRXhwcmVzc2lvbiBpcyBkZXN0cnVjdGl2ZSwgc28gd2UgbmVlZCB0byBtYWtlIGEgY2xvbmVcbiAgICAvLyBvZiB0aGUgaW5jb21pbmcgdHJlZSBzbyB0aGF0IGl0IGlzbid0IGFjY2lkZW50YWxseSBjaGFuZ2VkXG4gICAgdHJlZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodHJlZSkpO1xuXG4gICAgLy8gQnVpbGQgdGhlIGV4cHJlc3Npb24gY29udGFpbmVkIGluIHRoZSB0cmVlXG4gICAgdmFyIGV4cHJlc3Npb24gPSBidWlsZEV4cHJlc3Npb24odHJlZSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgdmFyIGJvZHkgPSBtYWtlU3BhbihbXCJiYXNlXCIsIG9wdGlvbnMuc3R5bGUuY2xzKCldLCBleHByZXNzaW9uLCBvcHRpb25zKTtcblxuICAgIC8vIEFkZCBzdHJ1dHMsIHdoaWNoIGVuc3VyZSB0aGF0IHRoZSB0b3Agb2YgdGhlIEhUTUwgZWxlbWVudCBmYWxscyBhdCB0aGVcbiAgICAvLyBoZWlnaHQgb2YgdGhlIGV4cHJlc3Npb24sIGFuZCB0aGUgYm90dG9tIG9mIHRoZSBIVE1MIGVsZW1lbnQgZmFsbHMgYXQgdGhlXG4gICAgLy8gZGVwdGggb2YgdGhlIGV4cHJlc3Npb24uXG4gICAgdmFyIHRvcFN0cnV0ID0gbWFrZVNwYW4oW1wic3RydXRcIl0pO1xuICAgIHZhciBib3R0b21TdHJ1dCA9IG1ha2VTcGFuKFtcInN0cnV0XCIsIFwiYm90dG9tXCJdKTtcblxuICAgIHRvcFN0cnV0LnN0eWxlLmhlaWdodCA9IGJvZHkuaGVpZ2h0ICsgXCJlbVwiO1xuICAgIGJvdHRvbVN0cnV0LnN0eWxlLmhlaWdodCA9IChib2R5LmhlaWdodCArIGJvZHkuZGVwdGgpICsgXCJlbVwiO1xuICAgIC8vIFdlJ2QgbGlrZSB0byB1c2UgYHZlcnRpY2FsLWFsaWduOiB0b3BgIGJ1dCBpbiBJRSA5IHRoaXMgbG93ZXJzIHRoZVxuICAgIC8vIGJhc2VsaW5lIG9mIHRoZSBib3ggdG8gdGhlIGJvdHRvbSBvZiB0aGlzIHN0cnV0IChpbnN0ZWFkIHN0YXlpbmcgaW4gdGhlXG4gICAgLy8gbm9ybWFsIHBsYWNlKSBzbyB3ZSB1c2UgYW4gYWJzb2x1dGUgdmFsdWUgZm9yIHZlcnRpY2FsLWFsaWduIGluc3RlYWRcbiAgICBib3R0b21TdHJ1dC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gLWJvZHkuZGVwdGggKyBcImVtXCI7XG5cbiAgICAvLyBXcmFwIHRoZSBzdHJ1dHMgYW5kIGJvZHkgdG9nZXRoZXJcbiAgICB2YXIgaHRtbE5vZGUgPSBtYWtlU3BhbihbXCJrYXRleC1odG1sXCJdLCBbdG9wU3RydXQsIGJvdHRvbVN0cnV0LCBib2R5XSk7XG5cbiAgICBodG1sTm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG5cbiAgICByZXR1cm4gaHRtbE5vZGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkSFRNTDtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnZlcnRzIGEgcGFyc2UgdHJlZSBpbnRvIGEgY29vcmVzcG9uZGluZyBNYXRoTUwgdHJlZS4gVGhlIG1haW5cbiAqIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRNYXRoTUxgIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhIHBhcnNlIHRyZWUgZnJvbSB0aGVcbiAqIHBhcnNlci5cbiAqL1xuXG52YXIgYnVpbGRDb21tb24gPSByZXF1aXJlKFwiLi9idWlsZENvbW1vblwiKTtcbnZhciBmb250TWV0cmljcyA9IHJlcXVpcmUoXCIuL2ZvbnRNZXRyaWNzXCIpO1xudmFyIG1hdGhNTFRyZWUgPSByZXF1aXJlKFwiLi9tYXRoTUxUcmVlXCIpO1xudmFyIFBhcnNlRXJyb3IgPSByZXF1aXJlKFwiLi9QYXJzZUVycm9yXCIpO1xudmFyIHN5bWJvbHMgPSByZXF1aXJlKFwiLi9zeW1ib2xzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbnZhciBtYWtlU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuO1xudmFyIGZvbnRNYXAgPSBidWlsZENvbW1vbi5mb250TWFwO1xuXG4vKipcbiAqIFRha2VzIGEgc3ltYm9sIGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgTWF0aE1MIHRleHQgbm9kZSBhZnRlciBwZXJmb3JtaW5nXG4gKiBvcHRpb25hbCByZXBsYWNlbWVudCBmcm9tIHN5bWJvbHMuanMuXG4gKi9cbnZhciBtYWtlVGV4dCA9IGZ1bmN0aW9uKHRleHQsIG1vZGUpIHtcbiAgICBpZiAoc3ltYm9sc1ttb2RlXVt0ZXh0XSAmJiBzeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2UpIHtcbiAgICAgICAgdGV4dCA9IHN5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4dCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1hdGggdmFyaWFudCBhcyBhIHN0cmluZyBvciBudWxsIGlmIG5vbmUgaXMgcmVxdWlyZWQuXG4gKi9cbnZhciBnZXRWYXJpYW50ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgICBpZiAoIWZvbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSBncm91cC5tb2RlO1xuICAgIGlmIChmb250ID09PSBcIm1hdGhpdFwiKSB7XG4gICAgICAgIHJldHVybiBcIml0YWxpY1wiO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IGdyb3VwLnZhbHVlO1xuICAgIGlmICh1dGlscy5jb250YWlucyhbXCJcXFxcaW1hdGhcIiwgXCJcXFxcam1hdGhcIl0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoc3ltYm9sc1ttb2RlXVt2YWx1ZV0gJiYgc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZSkge1xuICAgICAgICB2YWx1ZSA9IHN5bWJvbHNbbW9kZV1bdmFsdWVdLnJlcGxhY2U7XG4gICAgfVxuXG4gICAgdmFyIGZvbnROYW1lID0gZm9udE1hcFtmb250XS5mb250TmFtZTtcbiAgICBpZiAoZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljcyh2YWx1ZSwgZm9udE5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmb250TWFwW29wdGlvbnMuZm9udF0udmFyaWFudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogRnVuY3Rpb25zIGZvciBoYW5kbGluZyB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIGdyb3VwcyBmb3VuZCBpbiB0aGUgcGFyc2VcbiAqIHRyZWUuIEVhY2ggZnVuY3Rpb24gc2hvdWxkIHRha2UgYSBwYXJzZSBncm91cCBhbmQgcmV0dXJuIGEgTWF0aE1MIG5vZGUuXG4gKi9cbnZhciBncm91cFR5cGVzID0ge307XG5cbmdyb3VwVHlwZXMubWF0aG9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtaVwiLFxuICAgICAgICBbbWFrZVRleHQoZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICB2YXIgdmFyaWFudCA9IGdldFZhcmlhbnQoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIGlmICh2YXJpYW50KSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgdmFyaWFudCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy50ZXh0b3JkID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGV4dCA9IG1ha2VUZXh0KGdyb3VwLnZhbHVlLCBncm91cC5tb2RlKTtcblxuICAgIHZhciB2YXJpYW50ID0gZ2V0VmFyaWFudChncm91cCwgb3B0aW9ucykgfHwgXCJub3JtYWxcIjtcblxuICAgIHZhciBub2RlO1xuICAgIGlmICgvWzAtOV0vLnRlc3QoZ3JvdXAudmFsdWUpKSB7XG4gICAgICAgIC8vIFRPRE8oa2V2aW5iKSBtZXJnZSBhZGphY2VudCA8bW4+IG5vZGVzXG4gICAgICAgIC8vIGRvIGl0IGFzIGEgcG9zdCBwcm9jZXNzaW5nIHN0ZXBcbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW5cIiwgW3RleHRdKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9udCkge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCB2YXJpYW50KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIFt0ZXh0XSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgdmFyaWFudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLmJpbiA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMucmVsID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5vcGVuID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5jbG9zZSA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuaW5uZXIgPSBmdW5jdGlvbihncm91cCkge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnZhbHVlLCBncm91cC5tb2RlKV0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLnB1bmN0ID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2VwYXJhdG9yXCIsIFwidHJ1ZVwiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5vcmRncm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLCBvcHRpb25zKTtcblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGlubmVyKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy50ZXh0ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgaW5uZXIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLmNvbG9yID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhjb2xvclwiLCBncm91cC52YWx1ZS5jb2xvcik7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuc3Vwc3ViID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbYnVpbGRHcm91cChncm91cC52YWx1ZS5iYXNlLCBvcHRpb25zKV07XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUuc3ViKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRHcm91cChncm91cC52YWx1ZS5zdWIsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUuc3VwKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRHcm91cChncm91cC52YWx1ZS5zdXAsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZVR5cGU7XG4gICAgaWYgKCFncm91cC52YWx1ZS5zdWIpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdXBcIjtcbiAgICB9IGVsc2UgaWYgKCFncm91cC52YWx1ZS5zdXApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdWJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlVHlwZSA9IFwibXN1YnN1cFwiO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUobm9kZVR5cGUsIGNoaWxkcmVuKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5nZW5mcmFjID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1mcmFjXCIsXG4gICAgICAgIFtidWlsZEdyb3VwKGdyb3VwLnZhbHVlLm51bWVyLCBvcHRpb25zKSxcbiAgICAgICAgICAgIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuZGVub20sIG9wdGlvbnMpXSk7XG5cbiAgICBpZiAoIWdyb3VwLnZhbHVlLmhhc0JhckxpbmUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5ldGhpY2tuZXNzXCIsIFwiMHB4XCIpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5sZWZ0RGVsaW0gIT0gbnVsbCB8fCBncm91cC52YWx1ZS5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHdpdGhEZWxpbXMgPSBbXTtcblxuICAgICAgICBpZiAoZ3JvdXAudmFsdWUubGVmdERlbGltICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0T3AgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgICAgICBcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC52YWx1ZS5sZWZ0RGVsaW0pXSk7XG5cbiAgICAgICAgICAgIGxlZnRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG5cbiAgICAgICAgICAgIHdpdGhEZWxpbXMucHVzaChsZWZ0T3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgd2l0aERlbGltcy5wdXNoKG5vZGUpO1xuXG4gICAgICAgIGlmIChncm91cC52YWx1ZS5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByaWdodE9wID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICAgICAgXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoZ3JvdXAudmFsdWUucmlnaHREZWxpbSldKTtcblxuICAgICAgICAgICAgcmlnaHRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG5cbiAgICAgICAgICAgIHdpdGhEZWxpbXMucHVzaChyaWdodE9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRlck5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgd2l0aERlbGltcyk7XG5cbiAgICAgICAgcmV0dXJuIG91dGVyTm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuYXJyYXkgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtdGFibGVcIiwgZ3JvdXAudmFsdWUuYm9keS5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICAgICAgXCJtdHJcIiwgcm93Lm1hcChmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibXRkXCIsIFtidWlsZEdyb3VwKGNlbGwsIG9wdGlvbnMpXSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG59O1xuXG5ncm91cFR5cGVzLnNxcnQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlO1xuICAgIGlmIChncm91cC52YWx1ZS5pbmRleCkge1xuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1yb290XCIsIFtcbiAgICAgICAgICAgICAgICBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuaW5kZXgsIG9wdGlvbnMpXG4gICAgICAgICAgICBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1zcXJ0XCIsIFtidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLmxlZnRyaWdodCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLmxlZnQgIT09IFwiLlwiKSB7XG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUubGVmdCwgZ3JvdXAubW9kZSldKTtcblxuICAgICAgICBsZWZ0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG5cbiAgICAgICAgaW5uZXIudW5zaGlmdChsZWZ0Tm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnJpZ2h0ICE9PSBcIi5cIikge1xuICAgICAgICB2YXIgcmlnaHROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZS5yaWdodCwgZ3JvdXAubW9kZSldKTtcblxuICAgICAgICByaWdodE5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuXG4gICAgICAgIGlubmVyLnB1c2gocmlnaHROb2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0ZXJOb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGlubmVyKTtcblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59O1xuXG5ncm91cFR5cGVzLm1pZGRsZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG1pZGRsZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUubWlkZGxlLCBncm91cC5tb2RlKV0pO1xuICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIHJldHVybiBtaWRkbGVOb2RlO1xufTtcblxuZ3JvdXBUeXBlcy5hY2NlbnQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBhY2NlbnROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnZhbHVlLmFjY2VudCwgZ3JvdXAubW9kZSldKTtcblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW92ZXJcIixcbiAgICAgICAgW2J1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYmFzZSwgb3B0aW9ucyksXG4gICAgICAgICAgICBhY2NlbnROb2RlXSk7XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudFwiLCBcInRydWVcIik7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuc3BhY2luZyA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUgPT09IFwiXFxcXCBcIiB8fCBncm91cC52YWx1ZSA9PT0gXCJcXFxcc3BhY2VcIiB8fFxuICAgICAgICBncm91cC52YWx1ZSA9PT0gXCIgXCIgfHwgZ3JvdXAudmFsdWUgPT09IFwiflwiKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgIFwibXRleHRcIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MDBhMFwiKV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcblxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgIFwid2lkdGhcIiwgYnVpbGRDb21tb24uc3BhY2luZ0Z1bmN0aW9uc1tncm91cC52YWx1ZV0uc2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLm9wID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZTtcblxuICAgIC8vIFRPRE8oZW1pbHkpOiBoYW5kbGUgYmlnIG9wZXJhdG9ycyB1c2luZyB0aGUgYGxhcmdlb3BgIGF0dHJpYnV0ZVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnN5bWJvbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3ltYm9sLiBKdXN0IGFkZCB0aGUgc3ltYm9sLlxuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZS5ib2R5LCBncm91cC5tb2RlKV0pO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudmFsdWUudmFsdWUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBvcGVyYXRvciB3aXRoIGNoaWxkcmVuLiBBZGQgdGhlbS5cbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICAgICAgXCJtb1wiLCBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgdGV4dCBvcGVyYXRvci4gQWRkIGFsbCBvZiB0aGUgY2hhcmFjdGVycyBmcm9tIHRoZVxuICAgICAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgICAgIC8vIFRPRE8oZW1pbHkpOiBBZGQgYSBzcGFjZSBpbiB0aGUgbWlkZGxlIG9mIHNvbWUgb2YgdGhlc2VcbiAgICAgICAgLy8gb3BlcmF0b3JzLCBsaWtlIFxcbGltc3VwLlxuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1pXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC52YWx1ZS5ib2R5LnNsaWNlKDEpKV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5tb2QgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBpbm5lciA9IFtdO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwicG9kXCIgfHwgZ3JvdXAudmFsdWUubW9kVHlwZSA9PT0gXCJwbW9kXCIpIHtcbiAgICAgICAgaW5uZXIucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgIFwibW9cIiwgW21ha2VUZXh0KFwiKFwiLCBncm91cC5tb2RlKV0pKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgIT09IFwicG9kXCIpIHtcbiAgICAgICAgaW5uZXIucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgIFwibW9cIiwgW21ha2VUZXh0KFwibW9kXCIsIGdyb3VwLm1vZGUpXSkpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudmFsdWUudmFsdWUpIHtcbiAgICAgICAgdmFyIHNwYWNlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgICAgIHNwYWNlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMC4zMzMzMzNlbVwiKTtcbiAgICAgICAgaW5uZXIucHVzaChzcGFjZSk7XG4gICAgICAgIGlubmVyID0gaW5uZXIuY29uY2F0KGJ1aWxkRXhwcmVzc2lvbihncm91cC52YWx1ZS52YWx1ZSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudmFsdWUubW9kVHlwZSA9PT0gXCJwb2RcIiB8fCBncm91cC52YWx1ZS5tb2RUeXBlID09PSBcInBtb2RcIikge1xuICAgICAgICBpbm5lci5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoXCIpXCIsIGdyb3VwLm1vZGUpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIGlubmVyKTtcbn07XG5cbmdyb3VwVHlwZXMua2F0ZXggPSBmdW5jdGlvbihncm91cCkge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXRleHRcIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiS2FUZVhcIildKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5mb250ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9udCA9IGdyb3VwLnZhbHVlLmZvbnQ7XG4gICAgcmV0dXJuIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy53aXRoRm9udChmb250KSk7XG59O1xuXG5ncm91cFR5cGVzLmRlbGltc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgIGlmIChncm91cC52YWx1ZS52YWx1ZSAhPT0gXCIuXCIpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChtYWtlVGV4dChncm91cC52YWx1ZS52YWx1ZSwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBjaGlsZHJlbik7XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUubWNsYXNzID09PSBcIm1vcGVuXCIgfHxcbiAgICAgICAgZ3JvdXAudmFsdWUubWNsYXNzID09PSBcIm1jbG9zZVwiKSB7XG4gICAgICAgIC8vIE9ubHkgc29tZSBvZiB0aGUgZGVsaW1zaXppbmcgZnVuY3Rpb25zIGFjdCBhcyBmZW5jZXMsIGFuZCB0aGV5XG4gICAgICAgIC8vIHJldHVybiBcIm1vcGVuXCIgb3IgXCJtY2xvc2VcIiBtY2xhc3MuXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgZGlzYWJsZSBmZW5jaW5nIGlmIGl0J3Mgbm90IGEgZmVuY2UsIHRvIG92ZXJyaWRlIHRoZVxuICAgICAgICAvLyBkZWZhdWx0cy5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcImZhbHNlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5zdHlsaW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG5cbiAgICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0ge1xuICAgICAgICBcImRpc3BsYXlcIjogW1wiMFwiLCBcInRydWVcIl0sXG4gICAgICAgIFwidGV4dFwiOiBbXCIwXCIsIFwiZmFsc2VcIl0sXG4gICAgICAgIFwic2NyaXB0XCI6IFtcIjFcIiwgXCJmYWxzZVwiXSxcbiAgICAgICAgXCJzY3JpcHRzY3JpcHRcIjogW1wiMlwiLCBcImZhbHNlXCJdXG4gICAgfTtcblxuICAgIHZhciBhdHRyID0gc3R5bGVBdHRyaWJ1dGVzW2dyb3VwLnZhbHVlLnN0eWxlXTtcblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgYXR0clswXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgYXR0clsxXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG5cbiAgICAvLyBUT0RPKGVtaWx5KTogVGhpcyBkb2Vzbid0IHByb2R1Y2UgdGhlIGNvcnJlY3Qgc2l6ZSBmb3IgbmVzdGVkIHNpemVcbiAgICAvLyBjaGFuZ2VzLCBiZWNhdXNlIHdlIGRvbid0IGtlZXAgc3RhdGUgb2Ygd2hhdCBzdHlsZSB3ZSdyZSBjdXJyZW50bHlcbiAgICAvLyBpbiwgc28gd2UgY2FuJ3QgcmVzZXQgdGhlIHNpemUgdG8gbm9ybWFsIGJlZm9yZSBjaGFuZ2luZyBpdC4gIE5vd1xuICAgIC8vIHRoYXQgd2UncmUgcGFzc2luZyBhbiBvcHRpb25zIHBhcmFtZXRlciB3ZSBzaG91bGQgYmUgYWJsZSB0byBmaXhcbiAgICAvLyB0aGlzLlxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFxuICAgICAgICBcIm1hdGhzaXplXCIsIGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbZ3JvdXAudmFsdWUuc2l6ZV0gKyBcImVtXCIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLm92ZXJsaW5lID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUyMDNlXCIpXSk7XG4gICAgb3BlcmF0b3Iuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb3ZlclwiLFxuICAgICAgICBbYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zKSxcbiAgICAgICAgICAgIG9wZXJhdG9yXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhY2NlbnRcIiwgXCJ0cnVlXCIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLnVuZGVybGluZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MjAzZVwiKV0pO1xuICAgIG9wZXJhdG9yLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXVuZGVyXCIsXG4gICAgICAgIFtidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpLFxuICAgICAgICAgICAgb3BlcmF0b3JdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudHVuZGVyXCIsIFwidHJ1ZVwiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5ydWxlID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAvLyBUT0RPKGVtaWx5KTogRmlndXJlIG91dCBpZiB0aGVyZSdzIGFuIGFjdHVhbCB3YXkgdG8gZHJhdyBibGFjayBib3hlc1xuICAgIC8vIGluIE1hdGhNTC5cbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5rZXJuID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAvLyBUT0RPKGtldmluKTogRmlndXJlIG91dCBpZiB0aGVyZSdzIGEgd2F5IHRvIGFkZCBzcGFjZSBpbiBNYXRoTUxcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5sbGFwID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1wYWRkZWRcIiwgW2J1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucyldKTtcblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiLTF3aWR0aFwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMHB4XCIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLnJsYXAgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXBhZGRlZFwiLCBbYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zKV0pO1xuXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBweFwiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5waGFudG9tID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIGlubmVyKTtcbn07XG5cbmdyb3VwVHlwZXMubWNsYXNzID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBub2RlcywgYnVpbGRzIHRoZW0sIGFuZCByZXR1cm5zIGEgbGlzdCBvZiB0aGUgZ2VuZXJhdGVkXG4gKiBNYXRoTUwgbm9kZXMuIEEgbGl0dGxlIHNpbXBsZXIgdGhhbiB0aGUgSFRNTCB2ZXJzaW9uIGJlY2F1c2Ugd2UgZG9uJ3QgZG8gYW55XG4gKiBwcmV2aW91cy1ub2RlIGhhbmRsaW5nLlxuICovXG52YXIgYnVpbGRFeHByZXNzaW9uID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBncm91cHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZXhwcmVzc2lvbltpXTtcbiAgICAgICAgZ3JvdXBzLnB1c2goYnVpbGRHcm91cChncm91cCwgb3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBzO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIGdyb3VwIGZyb20gdGhlIHBhcnNlciBhbmQgY2FsbHMgdGhlIGFwcHJvcHJpYXRlIGdyb3VwVHlwZXMgZnVuY3Rpb25cbiAqIG9uIGl0IHRvIHByb2R1Y2UgYSBNYXRoTUwgbm9kZS5cbiAqL1xudmFyIGJ1aWxkR3JvdXAgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXBUeXBlc1tncm91cC50eXBlXSkge1xuICAgICAgICAvLyBDYWxsIHRoZSBncm91cFR5cGVzIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiBncm91cFR5cGVzW2dyb3VwLnR5cGVdKGdyb3VwLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgIFwiR290IGdyb3VwIG9mIHVua25vd24gdHlwZTogJ1wiICsgZ3JvdXAudHlwZSArIFwiJ1wiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRha2VzIGEgZnVsbCBwYXJzZSB0cmVlIGFuZCBzZXR0aW5ncyBhbmQgYnVpbGRzIGEgTWF0aE1MIHJlcHJlc2VudGF0aW9uIG9mXG4gKiBpdC4gSW4gcGFydGljdWxhciwgd2UgcHV0IHRoZSBlbGVtZW50cyBmcm9tIGJ1aWxkaW5nIHRoZSBwYXJzZSB0cmVlIGludG8gYVxuICogPHNlbWFudGljcz4gdGFnIHNvIHdlIGNhbiBhbHNvIGluY2x1ZGUgdGhhdCBUZVggc291cmNlIGFzIGFuIGFubm90YXRpb24uXG4gKlxuICogTm90ZSB0aGF0IHdlIGFjdHVhbGx5IHJldHVybiBhIGRvbVRyZWUgZWxlbWVudCB3aXRoIGEgYDxtYXRoPmAgaW5zaWRlIGl0IHNvXG4gKiB3ZSBjYW4gZG8gYXBwcm9wcmlhdGUgc3R5bGluZy5cbiAqL1xudmFyIGJ1aWxkTWF0aE1MID0gZnVuY3Rpb24odHJlZSwgdGV4RXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBleHByZXNzaW9uID0gYnVpbGRFeHByZXNzaW9uKHRyZWUsIG9wdGlvbnMpO1xuXG4gICAgLy8gV3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBpbiBhbiBtcm93IHNvIGl0IGlzIHByZXNlbnRlZCBpbiB0aGUgc2VtYW50aWNzXG4gICAgLy8gdGFnIGNvcnJlY3RseS5cbiAgICB2YXIgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBleHByZXNzaW9uKTtcblxuICAgIC8vIEJ1aWxkIGEgVGVYIGFubm90YXRpb24gb2YgdGhlIHNvdXJjZVxuICAgIHZhciBhbm5vdGF0aW9uID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwiYW5ub3RhdGlvblwiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4RXhwcmVzc2lvbildKTtcblxuICAgIGFubm90YXRpb24uc2V0QXR0cmlidXRlKFwiZW5jb2RpbmdcIiwgXCJhcHBsaWNhdGlvbi94LXRleFwiKTtcblxuICAgIHZhciBzZW1hbnRpY3MgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJzZW1hbnRpY3NcIiwgW3dyYXBwZXIsIGFubm90YXRpb25dKTtcblxuICAgIHZhciBtYXRoID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtYXRoXCIsIFtzZW1hbnRpY3NdKTtcblxuICAgIC8vIFlvdSBjYW4ndCBzdHlsZSA8bWF0aD4gbm9kZXMsIHNvIHdlIHdyYXAgdGhlIG5vZGUgaW4gYSBzcGFuLlxuICAgIHJldHVybiBtYWtlU3BhbihbXCJrYXRleC1tYXRobWxcIl0sIFttYXRoXSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkTWF0aE1MO1xuIiwidmFyIGJ1aWxkSFRNTCA9IHJlcXVpcmUoXCIuL2J1aWxkSFRNTFwiKTtcbnZhciBidWlsZE1hdGhNTCA9IHJlcXVpcmUoXCIuL2J1aWxkTWF0aE1MXCIpO1xudmFyIGJ1aWxkQ29tbW9uID0gcmVxdWlyZShcIi4vYnVpbGRDb21tb25cIik7XG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoXCIuL09wdGlvbnNcIik7XG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKFwiLi9TZXR0aW5nc1wiKTtcbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL1N0eWxlXCIpO1xuXG52YXIgbWFrZVNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbjtcblxudmFyIGJ1aWxkVHJlZSA9IGZ1bmN0aW9uKHRyZWUsIGV4cHJlc3Npb24sIHNldHRpbmdzKSB7XG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCBuZXcgU2V0dGluZ3Moe30pO1xuXG4gICAgdmFyIHN0YXJ0U3R5bGUgPSBTdHlsZS5URVhUO1xuICAgIGlmIChzZXR0aW5ncy5kaXNwbGF5TW9kZSkge1xuICAgICAgICBzdGFydFN0eWxlID0gU3R5bGUuRElTUExBWTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucyh7XG4gICAgICAgIHN0eWxlOiBzdGFydFN0eWxlLFxuICAgICAgICBzaXplOiBcInNpemU1XCJcbiAgICB9KTtcblxuICAgIC8vIGBidWlsZEhUTUxgIHNvbWV0aW1lcyBtZXNzZXMgd2l0aCB0aGUgcGFyc2UgdHJlZSAobGlrZSB0dXJuaW5nIGJpbnMgLT5cbiAgICAvLyBvcmRzKSwgc28gd2UgYnVpbGQgdGhlIE1hdGhNTCB2ZXJzaW9uIGZpcnN0LlxuICAgIHZhciBtYXRoTUxOb2RlID0gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgb3B0aW9ucyk7XG4gICAgdmFyIGh0bWxOb2RlID0gYnVpbGRIVE1MKHRyZWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIGthdGV4Tm9kZSA9IG1ha2VTcGFuKFtcImthdGV4XCJdLCBbXG4gICAgICAgIG1hdGhNTE5vZGUsIGh0bWxOb2RlXG4gICAgXSk7XG5cbiAgICBpZiAoc2V0dGluZ3MuZGlzcGxheU1vZGUpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTcGFuKFtcImthdGV4LWRpc3BsYXlcIl0sIFtrYXRleE5vZGVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga2F0ZXhOb2RlO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRUcmVlO1xuIiwiLyoqXG4gKiBUaGlzIGZpbGUgZGVhbHMgd2l0aCBjcmVhdGluZyBkZWxpbWl0ZXJzIG9mIHZhcmlvdXMgc2l6ZXMuIFRoZSBUZVhib29rXG4gKiBkaXNjdXNzZXMgdGhlc2Ugcm91dGluZXMgb24gcGFnZSA0NDEtNDQyLCBpbiB0aGUgXCJBbm90aGVyIHN1YnJvdXRpbmUgc2V0cyBib3hcbiAqIHggdG8gYSBzcGVjaWZpZWQgdmFyaWFibGUgZGVsaW1pdGVyXCIgcGFyYWdyYXBoLlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBtYWluIHJvdXRpbmVzIGhlcmUuIGBtYWtlU21hbGxEZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgaW4gdGhlXG4gKiBub3JtYWwgZm9udCwgYnV0IGluIGVpdGhlciB0ZXh0LCBzY3JpcHQsIG9yIHNjcmlwdHNjcmlwdCBzdHlsZS5cbiAqIGBtYWtlTGFyZ2VEZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgaW4gdGV4dHN0eWxlLCBidXQgaW4gb25lIG9mIHRoZSBTaXplMSxcbiAqIFNpemUyLCBTaXplMywgb3IgU2l6ZTQgZm9udHMuIGBtYWtlU3RhY2tlZERlbGltYCBtYWtlcyBhIGRlbGltaXRlciBvdXQgb2ZcbiAqIHNtYWxsZXIgcGllY2VzIHRoYXQgYXJlIHN0YWNrZWQgb24gdG9wIG9mIG9uZSBhbm90aGVyLlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgdGFrZSBhIHBhcmFtZXRlciBgY2VudGVyYCwgd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgZGVsaW1pdGVyXG4gKiBzaG91bGQgYmUgY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzLlxuICpcbiAqIFRoZW4sIHRoZXJlIGFyZSB0aHJlZSBleHBvc2VkIGZ1bmN0aW9ucy4gYHNpemVkRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIGluXG4gKiBvbmUgb2YgdGhlIGdpdmVuIHNpemVzLiBUaGlzIGlzIHVzZWQgZm9yIHRoaW5ncyBsaWtlIGBcXGJpZ2xgLlxuICogYGN1c3RvbVNpemVkRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIHdpdGggYSBnaXZlbiB0b3RhbCBoZWlnaHQrZGVwdGguIEl0IGlzXG4gKiBjYWxsZWQgaW4gcGxhY2VzIGxpa2UgYFxcc3FydGAuIGBsZWZ0UmlnaHREZWxpbWAgbWFrZXMgYW4gYXBwcm9wcmlhdGVcbiAqIGRlbGltaXRlciB3aGljaCBzdXJyb3VuZHMgYW4gZXhwcmVzc2lvbiBvZiBhIGdpdmVuIGhlaWdodCBhbiBkZXB0aC4gSXQgaXNcbiAqIHVzZWQgaW4gYFxcbGVmdGAgYW5kIGBcXHJpZ2h0YC5cbiAqL1xuXG52YXIgUGFyc2VFcnJvciA9IHJlcXVpcmUoXCIuL1BhcnNlRXJyb3JcIik7XG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9TdHlsZVwiKTtcblxudmFyIGJ1aWxkQ29tbW9uID0gcmVxdWlyZShcIi4vYnVpbGRDb21tb25cIik7XG52YXIgZm9udE1ldHJpY3MgPSByZXF1aXJlKFwiLi9mb250TWV0cmljc1wiKTtcbnZhciBzeW1ib2xzID0gcmVxdWlyZShcIi4vc3ltYm9sc1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG52YXIgbWFrZVNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbjtcblxuLyoqXG4gKiBHZXQgdGhlIG1ldHJpY3MgZm9yIGEgZ2l2ZW4gc3ltYm9sIGFuZCBmb250LCBhZnRlciB0cmFuc2Zvcm1hdGlvbiAoaS5lLlxuICogYWZ0ZXIgZm9sbG93aW5nIHJlcGxhY2VtZW50IGZyb20gc3ltYm9scy5qcylcbiAqL1xudmFyIGdldE1ldHJpY3MgPSBmdW5jdGlvbihzeW1ib2wsIGZvbnQpIHtcbiAgICBpZiAoc3ltYm9scy5tYXRoW3N5bWJvbF0gJiYgc3ltYm9scy5tYXRoW3N5bWJvbF0ucmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljcyhcbiAgICAgICAgICAgIHN5bWJvbHMubWF0aFtzeW1ib2xdLnJlcGxhY2UsIGZvbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmb250TWV0cmljcy5nZXRDaGFyYWN0ZXJNZXRyaWNzKFxuICAgICAgICAgICAgc3ltYm9sLCBmb250KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHN5bWJvbCBpbiB0aGUgZ2l2ZW4gZm9udCBzaXplIChub3RlIHNpemUgaXMgYW4gaW50ZWdlcilcbiAqL1xudmFyIG1hdGhybVNpemUgPSBmdW5jdGlvbih2YWx1ZSwgc2l6ZSwgbW9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3ltYm9sKHZhbHVlLCBcIlNpemVcIiArIHNpemUgKyBcIi1SZWd1bGFyXCIsXG4gICAgICAgIG1vZGUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgZGVsaW1pdGVyIHNwYW4gaW4gYSBnaXZlbiBzdHlsZSwgYW5kIGFkZHMgYXBwcm9wcmlhdGUgaGVpZ2h0LCBkZXB0aCxcbiAqIGFuZCBtYXhGb250U2l6ZXMuXG4gKi9cbnZhciBzdHlsZVdyYXAgPSBmdW5jdGlvbihkZWxpbSwgdG9TdHlsZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICAgIGNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICAgIHZhciBzcGFuID0gbWFrZVNwYW4oXG4gICAgICAgIGNsYXNzZXMuY29uY2F0KFtcInN0eWxlLXdyYXBcIiwgb3B0aW9ucy5zdHlsZS5yZXNldCgpLCB0b1N0eWxlLmNscygpXSksXG4gICAgICAgIFtkZWxpbV0sIG9wdGlvbnMpO1xuXG4gICAgdmFyIG11bHRpcGxpZXIgPSB0b1N0eWxlLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIHNwYW4uaGVpZ2h0ICo9IG11bHRpcGxpZXI7XG4gICAgc3Bhbi5kZXB0aCAqPSBtdWx0aXBsaWVyO1xuICAgIHNwYW4ubWF4Rm9udFNpemUgPSB0b1N0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgcmV0dXJuIHNwYW47XG59O1xuXG4vKipcbiAqIE1ha2VzIGEgc21hbGwgZGVsaW1pdGVyLiBUaGlzIGlzIGEgZGVsaW1pdGVyIHRoYXQgY29tZXMgaW4gdGhlIE1haW4tUmVndWxhclxuICogZm9udCwgYnV0IGlzIHJlc3R5bGVkIHRvIGVpdGhlciBiZSBpbiB0ZXh0c3R5bGUsIHNjcmlwdHN0eWxlLCBvclxuICogc2NyaXB0c2NyaXB0c3R5bGUuXG4gKi9cbnZhciBtYWtlU21hbGxEZWxpbSA9IGZ1bmN0aW9uKGRlbGltLCBzdHlsZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gICAgdmFyIHRleHQgPSBidWlsZENvbW1vbi5tYWtlU3ltYm9sKGRlbGltLCBcIk1haW4tUmVndWxhclwiLCBtb2RlLCBvcHRpb25zKTtcblxuICAgIHZhciBzcGFuID0gc3R5bGVXcmFwKHRleHQsIHN0eWxlLCBvcHRpb25zLCBjbGFzc2VzKTtcblxuICAgIGlmIChjZW50ZXIpIHtcbiAgICAgICAgdmFyIHNoaWZ0ID1cbiAgICAgICAgICAgICgxIC0gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllciAvIHN0eWxlLnNpemVNdWx0aXBsaWVyKSAqXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodDtcblxuICAgICAgICBzcGFuLnN0eWxlLnRvcCA9IHNoaWZ0ICsgXCJlbVwiO1xuICAgICAgICBzcGFuLmhlaWdodCAtPSBzaGlmdDtcbiAgICAgICAgc3Bhbi5kZXB0aCArPSBzaGlmdDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Bhbjtcbn07XG5cbi8qKlxuICogTWFrZXMgYSBsYXJnZSBkZWxpbWl0ZXIuIFRoaXMgaXMgYSBkZWxpbWl0ZXIgdGhhdCBjb21lcyBpbiB0aGUgU2l6ZTEsIFNpemUyLFxuICogU2l6ZTMsIG9yIFNpemU0IGZvbnRzLiBJdCBpcyBhbHdheXMgcmVuZGVyZWQgaW4gdGV4dHN0eWxlLlxuICovXG52YXIgbWFrZUxhcmdlRGVsaW0gPSBmdW5jdGlvbihkZWxpbSwgc2l6ZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gICAgdmFyIGlubmVyID0gbWF0aHJtU2l6ZShkZWxpbSwgc2l6ZSwgbW9kZSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgc3BhbiA9IHN0eWxlV3JhcChcbiAgICAgICAgbWFrZVNwYW4oW1wiZGVsaW1zaXppbmdcIiwgXCJzaXplXCIgKyBzaXplXSwgW2lubmVyXSwgb3B0aW9ucyksXG4gICAgICAgIFN0eWxlLlRFWFQsIG9wdGlvbnMsIGNsYXNzZXMpO1xuXG4gICAgaWYgKGNlbnRlcikge1xuICAgICAgICB2YXIgc2hpZnQgPSAoMSAtIG9wdGlvbnMuc3R5bGUuc2l6ZU11bHRpcGxpZXIpICpcbiAgICAgICAgICAgIG9wdGlvbnMuc3R5bGUubWV0cmljcy5heGlzSGVpZ2h0O1xuXG4gICAgICAgIHNwYW4uc3R5bGUudG9wID0gc2hpZnQgKyBcImVtXCI7XG4gICAgICAgIHNwYW4uaGVpZ2h0IC09IHNoaWZ0O1xuICAgICAgICBzcGFuLmRlcHRoICs9IHNoaWZ0O1xuICAgIH1cblxuICAgIHJldHVybiBzcGFuO1xufTtcblxuLyoqXG4gKiBNYWtlIGFuIGlubmVyIHNwYW4gd2l0aCB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCBpbiB0aGUgZ2l2ZW4gZm9udC4gVGhpcyBpcyB1c2VkXG4gKiBpbiBgbWFrZVN0YWNrZWREZWxpbWAgdG8gbWFrZSB0aGUgc3RhY2tpbmcgcGllY2VzIGZvciB0aGUgZGVsaW1pdGVyLlxuICovXG52YXIgbWFrZUlubmVyID0gZnVuY3Rpb24oc3ltYm9sLCBmb250LCBtb2RlKSB7XG4gICAgdmFyIHNpemVDbGFzcztcbiAgICAvLyBBcHBseSB0aGUgY29ycmVjdCBDU1MgY2xhc3MgdG8gY2hvb3NlIHRoZSByaWdodCBmb250LlxuICAgIGlmIChmb250ID09PSBcIlNpemUxLVJlZ3VsYXJcIikge1xuICAgICAgICBzaXplQ2xhc3MgPSBcImRlbGltLXNpemUxXCI7XG4gICAgfSBlbHNlIGlmIChmb250ID09PSBcIlNpemU0LVJlZ3VsYXJcIikge1xuICAgICAgICBzaXplQ2xhc3MgPSBcImRlbGltLXNpemU0XCI7XG4gICAgfVxuXG4gICAgdmFyIGlubmVyID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImRlbGltc2l6aW5naW5uZXJcIiwgc2l6ZUNsYXNzXSxcbiAgICAgICAgW21ha2VTcGFuKFtdLCBbYnVpbGRDb21tb24ubWFrZVN5bWJvbChzeW1ib2wsIGZvbnQsIG1vZGUpXSldKTtcblxuICAgIC8vIFNpbmNlIHRoaXMgd2lsbCBiZSBwYXNzZWQgaW50byBgbWFrZVZMaXN0YCBpbiB0aGUgZW5kLCB3cmFwIHRoZSBlbGVtZW50XG4gICAgLy8gaW4gdGhlIGFwcHJvcHJpYXRlIHRhZyB0aGF0IFZMaXN0IHVzZXMuXG4gICAgcmV0dXJuIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogaW5uZXJ9O1xufTtcblxuLyoqXG4gKiBNYWtlIGEgc3RhY2tlZCBkZWxpbWl0ZXIgb3V0IG9mIGEgZ2l2ZW4gZGVsaW1pdGVyLCB3aXRoIHRoZSB0b3RhbCBoZWlnaHQgYXRcbiAqIGxlYXN0IGBoZWlnaHRUb3RhbGAuIFRoaXMgcm91dGluZSBpcyBtZW50aW9uZWQgb24gcGFnZSA0NDIgb2YgdGhlIFRlWGJvb2suXG4gKi9cbnZhciBtYWtlU3RhY2tlZERlbGltID0gZnVuY3Rpb24oZGVsaW0sIGhlaWdodFRvdGFsLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpIHtcbiAgICAvLyBUaGVyZSBhcmUgZm91ciBwYXJ0cywgdGhlIHRvcCwgYW4gb3B0aW9uYWwgbWlkZGxlLCBhIHJlcGVhdGVkIHBhcnQsIGFuZCBhXG4gICAgLy8gYm90dG9tLlxuICAgIHZhciB0b3A7XG4gICAgdmFyIG1pZGRsZTtcbiAgICB2YXIgcmVwZWF0O1xuICAgIHZhciBib3R0b207XG4gICAgdG9wID0gcmVwZWF0ID0gYm90dG9tID0gZGVsaW07XG4gICAgbWlkZGxlID0gbnVsbDtcbiAgICAvLyBBbHNvIGtlZXAgdHJhY2sgb2Ygd2hhdCBmb250IHRoZSBkZWxpbWl0ZXJzIGFyZSBpblxuICAgIHZhciBmb250ID0gXCJTaXplMS1SZWd1bGFyXCI7XG5cbiAgICAvLyBXZSBzZXQgdGhlIHBhcnRzIGFuZCBmb250IGJhc2VkIG9uIHRoZSBzeW1ib2wuIE5vdGUgdGhhdCB3ZSB1c2VcbiAgICAvLyAnXFx1MjNkMCcgaW5zdGVhZCBvZiAnfCcgYW5kICdcXHUyMDE2JyBpbnN0ZWFkIG9mICdcXFxcfCcgZm9yIHRoZVxuICAgIC8vIHJlcGVhdHMgb2YgdGhlIGFycm93c1xuICAgIGlmIChkZWxpbSA9PT0gXCJcXFxcdXBhcnJvd1wiKSB7XG4gICAgICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNkMFwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXFVwYXJyb3dcIikge1xuICAgICAgICByZXBlYXQgPSBib3R0b20gPSBcIlxcdTIwMTZcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxkb3duYXJyb3dcIikge1xuICAgICAgICB0b3AgPSByZXBlYXQgPSBcIlxcdTIzZDBcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxEb3duYXJyb3dcIikge1xuICAgICAgICB0b3AgPSByZXBlYXQgPSBcIlxcdTIwMTZcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFx1cGRvd25hcnJvd1wiKSB7XG4gICAgICAgIHRvcCA9IFwiXFxcXHVwYXJyb3dcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyM2QwXCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFxcXGRvd25hcnJvd1wiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXFVwZG93bmFycm93XCIpIHtcbiAgICAgICAgdG9wID0gXCJcXFxcVXBhcnJvd1wiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIwMTZcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXFxcRG93bmFycm93XCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJbXCIgfHwgZGVsaW0gPT09IFwiXFxcXGxicmFja1wiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1MjNhMVwiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIzYTJcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXHUyM2EzXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIl1cIiB8fCBkZWxpbSA9PT0gXCJcXFxccmJyYWNrXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E0XCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjNhNVwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTZcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxmbG9vclwiKSB7XG4gICAgICAgIHJlcGVhdCA9IHRvcCA9IFwiXFx1MjNhMlwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTNcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxjZWlsXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2ExXCI7XG4gICAgICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNhMlwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccmZsb29yXCIpIHtcbiAgICAgICAgcmVwZWF0ID0gdG9wID0gXCJcXHUyM2E1XCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjNhNlwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccmNlaWxcIikge1xuICAgICAgICB0b3AgPSBcIlxcdTIzYTRcIjtcbiAgICAgICAgcmVwZWF0ID0gYm90dG9tID0gXCJcXHUyM2E1XCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIihcIikge1xuICAgICAgICB0b3AgPSBcIlxcdTIzOWJcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyMzljXCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjM5ZFwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCIpXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyMzllXCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjM5ZlwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTBcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHtcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbGJyYWNlXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgICAgIG1pZGRsZSA9IFwiXFx1MjNhOFwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTlcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFx9XCIgfHwgZGVsaW0gPT09IFwiXFxcXHJicmFjZVwiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1MjNhYlwiO1xuICAgICAgICBtaWRkbGUgPSBcIlxcdTIzYWNcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXHUyM2FkXCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcbGdyb3VwXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjNhOVwiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJncm91cFwiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1MjNhYlwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYWRcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxsbW91c3RhY2hlXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjNhZFwiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJtb3VzdGFjaGVcIikge1xuICAgICAgICB0b3AgPSBcIlxcdTIzYWJcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXHUyM2E5XCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcc3VyZFwiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1ZTAwMVwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYjdcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHVlMDAwXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIG1ldHJpY3Mgb2YgdGhlIGZvdXIgc2VjdGlvbnNcbiAgICB2YXIgdG9wTWV0cmljcyA9IGdldE1ldHJpY3ModG9wLCBmb250KTtcbiAgICB2YXIgdG9wSGVpZ2h0VG90YWwgPSB0b3BNZXRyaWNzLmhlaWdodCArIHRvcE1ldHJpY3MuZGVwdGg7XG4gICAgdmFyIHJlcGVhdE1ldHJpY3MgPSBnZXRNZXRyaWNzKHJlcGVhdCwgZm9udCk7XG4gICAgdmFyIHJlcGVhdEhlaWdodFRvdGFsID0gcmVwZWF0TWV0cmljcy5oZWlnaHQgKyByZXBlYXRNZXRyaWNzLmRlcHRoO1xuICAgIHZhciBib3R0b21NZXRyaWNzID0gZ2V0TWV0cmljcyhib3R0b20sIGZvbnQpO1xuICAgIHZhciBib3R0b21IZWlnaHRUb3RhbCA9IGJvdHRvbU1ldHJpY3MuaGVpZ2h0ICsgYm90dG9tTWV0cmljcy5kZXB0aDtcbiAgICB2YXIgbWlkZGxlSGVpZ2h0VG90YWwgPSAwO1xuICAgIHZhciBtaWRkbGVGYWN0b3IgPSAxO1xuICAgIGlmIChtaWRkbGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG1pZGRsZU1ldHJpY3MgPSBnZXRNZXRyaWNzKG1pZGRsZSwgZm9udCk7XG4gICAgICAgIG1pZGRsZUhlaWdodFRvdGFsID0gbWlkZGxlTWV0cmljcy5oZWlnaHQgKyBtaWRkbGVNZXRyaWNzLmRlcHRoO1xuICAgICAgICBtaWRkbGVGYWN0b3IgPSAyOyAvLyByZXBlYXQgc3ltbWV0cmljYWxseSBhYm92ZSBhbmQgYmVsb3cgbWlkZGxlXG4gICAgfVxuXG4gICAgLy8gQ2FsY3VhdGUgdGhlIG1pbmltYWwgaGVpZ2h0IHRoYXQgdGhlIGRlbGltaXRlciBjYW4gaGF2ZS5cbiAgICAvLyBJdCBpcyBhdCBsZWFzdCB0aGUgc2l6ZSBvZiB0aGUgdG9wLCBib3R0b20sIGFuZCBvcHRpb25hbCBtaWRkbGUgY29tYmluZWQuXG4gICAgdmFyIG1pbkhlaWdodCA9IHRvcEhlaWdodFRvdGFsICsgYm90dG9tSGVpZ2h0VG90YWwgKyBtaWRkbGVIZWlnaHRUb3RhbDtcblxuICAgIC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiBjb3BpZXMgb2YgdGhlIHJlcGVhdCBzeW1ib2wgd2Ugd2lsbCBuZWVkXG4gICAgdmFyIHJlcGVhdENvdW50ID0gTWF0aC5jZWlsKFxuICAgICAgICAoaGVpZ2h0VG90YWwgLSBtaW5IZWlnaHQpIC8gKG1pZGRsZUZhY3RvciAqIHJlcGVhdEhlaWdodFRvdGFsKSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGRlbGltaXRlciBpbmNsdWRpbmcgYWxsIHRoZSBzeW1ib2xzXG4gICAgdmFyIHJlYWxIZWlnaHRUb3RhbCA9XG4gICAgICAgIG1pbkhlaWdodCArIHJlcGVhdENvdW50ICogbWlkZGxlRmFjdG9yICogcmVwZWF0SGVpZ2h0VG90YWw7XG5cbiAgICAvLyBUaGUgY2VudGVyIG9mIHRoZSBkZWxpbWl0ZXIgaXMgcGxhY2VkIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGF4aXMuIE5vdGVcbiAgICAvLyB0aGF0IGluIHRoaXMgY29udGV4dCwgXCJjZW50ZXJcIiBtZWFucyB0aGF0IHRoZSBkZWxpbWl0ZXIgc2hvdWxkIGJlXG4gICAgLy8gY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzIGluIHRoZSBjdXJyZW50IHN0eWxlLCB3aGlsZSBub3JtYWxseSBpdCBpc1xuICAgIC8vIGNlbnRlcmVkIGFyb3VuZCB0aGUgYXhpcyBpbiB0ZXh0c3R5bGUuXG4gICAgdmFyIGF4aXNIZWlnaHQgPSBvcHRpb25zLnN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodDtcbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgIGF4aXNIZWlnaHQgKj0gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXB0aFxuICAgIHZhciBkZXB0aCA9IHJlYWxIZWlnaHRUb3RhbCAvIDIgLSBheGlzSGVpZ2h0O1xuXG4gICAgLy8gTm93LCB3ZSBzdGFydCBidWlsZGluZyB0aGUgcGllY2VzIHRoYXQgd2lsbCBnbyBpbnRvIHRoZSB2bGlzdFxuXG4gICAgLy8gS2VlcCBhIGxpc3Qgb2YgdGhlIGlubmVyIHBpZWNlc1xuICAgIHZhciBpbm5lcnMgPSBbXTtcblxuICAgIC8vIEFkZCB0aGUgYm90dG9tIHN5bWJvbFxuICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcihib3R0b20sIGZvbnQsIG1vZGUpKTtcblxuICAgIHZhciBpO1xuICAgIGlmIChtaWRkbGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gQWRkIHRoYXQgbWFueSBzeW1ib2xzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXBlYXRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpbm5lcnMucHVzaChtYWtlSW5uZXIocmVwZWF0LCBmb250LCBtb2RlKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIGEgbWlkZGxlIGJpdCwgd2UgbmVlZCB0aGUgbWlkZGxlIHBhcnQgYW5kIHR3byByZXBlYXRlZFxuICAgICAgICAvLyBzZWN0aW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVwZWF0Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgaW5uZXJzLnB1c2gobWFrZUlubmVyKHJlcGVhdCwgZm9udCwgbW9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcihtaWRkbGUsIGZvbnQsIG1vZGUpKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlcGVhdENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcihyZXBlYXQsIGZvbnQsIG1vZGUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgdG9wIHN5bWJvbFxuICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcih0b3AsIGZvbnQsIG1vZGUpKTtcblxuICAgIC8vIEZpbmFsbHksIGJ1aWxkIHRoZSB2bGlzdFxuICAgIHZhciBpbm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChpbm5lcnMsIFwiYm90dG9tXCIsIGRlcHRoLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBzdHlsZVdyYXAoXG4gICAgICAgIG1ha2VTcGFuKFtcImRlbGltc2l6aW5nXCIsIFwibXVsdFwiXSwgW2lubmVyXSwgb3B0aW9ucyksXG4gICAgICAgIFN0eWxlLlRFWFQsIG9wdGlvbnMsIGNsYXNzZXMpO1xufTtcblxuLy8gVGhlcmUgYXJlIHRocmVlIGtpbmRzIG9mIGRlbGltaXRlcnMsIGRlbGltaXRlcnMgdGhhdCBzdGFjayB3aGVuIHRoZXkgYmVjb21lXG4vLyB0b28gbGFyZ2VcbnZhciBzdGFja0xhcmdlRGVsaW1pdGVycyA9IFtcbiAgICBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgXCJdXCIsIFwiXFxcXHJicmFja1wiLFxuICAgIFwiXFxcXHtcIiwgXCJcXFxcbGJyYWNlXCIsIFwiXFxcXH1cIiwgXCJcXFxccmJyYWNlXCIsXG4gICAgXCJcXFxcbGZsb29yXCIsIFwiXFxcXHJmbG9vclwiLCBcIlxcXFxsY2VpbFwiLCBcIlxcXFxyY2VpbFwiLFxuICAgIFwiXFxcXHN1cmRcIlxuXTtcblxuLy8gZGVsaW1pdGVycyB0aGF0IGFsd2F5cyBzdGFja1xudmFyIHN0YWNrQWx3YXlzRGVsaW1pdGVycyA9IFtcbiAgICBcIlxcXFx1cGFycm93XCIsIFwiXFxcXGRvd25hcnJvd1wiLCBcIlxcXFx1cGRvd25hcnJvd1wiLFxuICAgIFwiXFxcXFVwYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsIFwiXFxcXFVwZG93bmFycm93XCIsXG4gICAgXCJ8XCIsIFwiXFxcXHxcIiwgXCJcXFxcdmVydFwiLCBcIlxcXFxWZXJ0XCIsXG4gICAgXCJcXFxcbHZlcnRcIiwgXCJcXFxccnZlcnRcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIixcbiAgICBcIlxcXFxsZ3JvdXBcIiwgXCJcXFxccmdyb3VwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgXCJcXFxccm1vdXN0YWNoZVwiXG5dO1xuXG4vLyBhbmQgZGVsaW1pdGVycyB0aGF0IG5ldmVyIHN0YWNrXG52YXIgc3RhY2tOZXZlckRlbGltaXRlcnMgPSBbXG4gICAgXCI8XCIsIFwiPlwiLCBcIlxcXFxsYW5nbGVcIiwgXCJcXFxccmFuZ2xlXCIsIFwiL1wiLCBcIlxcXFxiYWNrc2xhc2hcIiwgXCJcXFxcbHRcIiwgXCJcXFxcZ3RcIlxuXTtcblxuLy8gTWV0cmljcyBvZiB0aGUgZGlmZmVyZW50IHNpemVzLiBGb3VuZCBieSBsb29raW5nIGF0IFRlWCdzIG91dHB1dCBvZlxuLy8gJFxcYmlnbHwgLy8gXFxCaWdsfCBcXGJpZ2dsfCBcXEJpZ2dsfCBcXHNob3dsaXN0cyRcbi8vIFVzZWQgdG8gY3JlYXRlIHN0YWNrZWQgZGVsaW1pdGVycyBvZiBhcHByb3ByaWF0ZSBzaXplcyBpbiBtYWtlU2l6ZWREZWxpbS5cbnZhciBzaXplVG9NYXhIZWlnaHQgPSBbMCwgMS4yLCAxLjgsIDIuNCwgMy4wXTtcblxuLyoqXG4gKiBVc2VkIHRvIGNyZWF0ZSBhIGRlbGltaXRlciBvZiBhIHNwZWNpZmljIHNpemUsIHdoZXJlIGBzaXplYCBpcyAxLCAyLCAzLCBvciA0LlxuICovXG52YXIgbWFrZVNpemVkRGVsaW0gPSBmdW5jdGlvbihkZWxpbSwgc2l6ZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICAgIC8vIDwgYW5kID4gdHVybiBpbnRvIFxcbGFuZ2xlIGFuZCBcXHJhbmdsZSBpbiBkZWxpbWl0ZXJzXG4gICAgaWYgKGRlbGltID09PSBcIjxcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbHRcIikge1xuICAgICAgICBkZWxpbSA9IFwiXFxcXGxhbmdsZVwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiPlwiIHx8IGRlbGltID09PSBcIlxcXFxndFwiKSB7XG4gICAgICAgIGRlbGltID0gXCJcXFxccmFuZ2xlXCI7XG4gICAgfVxuXG4gICAgLy8gU2l6ZWQgZGVsaW1pdGVycyBhcmUgbmV2ZXIgY2VudGVyZWQuXG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrTGFyZ2VEZWxpbWl0ZXJzLCBkZWxpbSkgfHxcbiAgICAgICAgdXRpbHMuY29udGFpbnMoc3RhY2tOZXZlckRlbGltaXRlcnMsIGRlbGltKSkge1xuICAgICAgICByZXR1cm4gbWFrZUxhcmdlRGVsaW0oZGVsaW0sIHNpemUsIGZhbHNlLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrQWx3YXlzRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgICAgIHJldHVybiBtYWtlU3RhY2tlZERlbGltKFxuICAgICAgICAgICAgZGVsaW0sIHNpemVUb01heEhlaWdodFtzaXplXSwgZmFsc2UsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSWxsZWdhbCBkZWxpbWl0ZXI6ICdcIiArIGRlbGltICsgXCInXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhlcmUgYXJlIHRocmVlIGRpZmZlcmVudCBzZXF1ZW5jZXMgb2YgZGVsaW1pdGVyIHNpemVzIHRoYXQgdGhlIGRlbGltaXRlcnNcbiAqIGZvbGxvdyBkZXBlbmRpbmcgb24gdGhlIGtpbmQgb2YgZGVsaW1pdGVyLiBUaGlzIGlzIHVzZWQgd2hlbiBjcmVhdGluZyBjdXN0b21cbiAqIHNpemVkIGRlbGltaXRlcnMgdG8gZGVjaWRlIHdoZXRoZXIgdG8gY3JlYXRlIGEgc21hbGwsIGxhcmdlLCBvciBzdGFja2VkXG4gKiBkZWxpbWl0ZXIuXG4gKlxuICogSW4gcmVhbCBUZVgsIHRoZXNlIHNlcXVlbmNlcyBhcmVuJ3QgZXhwbGljaXRseSBkZWZpbmVkLCBidXQgYXJlIGluc3RlYWRcbiAqIGRlZmluZWQgaW5zaWRlIHRoZSBmb250IG1ldHJpY3MuIFNpbmNlIHRoZXJlIGFyZSBvbmx5IHRocmVlIHNlcXVlbmNlcyB0aGF0XG4gKiBhcmUgcG9zc2libGUgZm9yIHRoZSBkZWxpbWl0ZXJzIHRoYXQgVGVYIGRlZmluZXMsIGl0IGlzIGVhc2llciB0byBqdXN0IGVuY29kZVxuICogdGhlbSBleHBsaWNpdGx5IGhlcmUuXG4gKi9cblxuLy8gRGVsaW1pdGVycyB0aGF0IG5ldmVyIHN0YWNrIHRyeSBzbWFsbCBkZWxpbWl0ZXJzIGFuZCBsYXJnZSBkZWxpbWl0ZXJzIG9ubHlcbnZhciBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2UgPSBbXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVFNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlRFWFR9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDF9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDJ9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDN9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDR9XG5dO1xuXG4vLyBEZWxpbWl0ZXJzIHRoYXQgYWx3YXlzIHN0YWNrIHRyeSB0aGUgc21hbGwgZGVsaW1pdGVycyBmaXJzdCwgdGhlbiBzdGFja1xudmFyIHN0YWNrQWx3YXlzRGVsaW1pdGVyU2VxdWVuY2UgPSBbXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVFNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlRFWFR9LFxuICAgIHt0eXBlOiBcInN0YWNrXCJ9XG5dO1xuXG4vLyBEZWxpbWl0ZXJzIHRoYXQgc3RhY2sgd2hlbiBsYXJnZSB0cnkgdGhlIHNtYWxsIGFuZCB0aGVuIGxhcmdlIGRlbGltaXRlcnMsIGFuZFxuLy8gc3RhY2sgYWZ0ZXJ3YXJkc1xudmFyIHN0YWNrTGFyZ2VEZWxpbWl0ZXJTZXF1ZW5jZSA9IFtcbiAgICB7dHlwZTogXCJzbWFsbFwiLCBzdHlsZTogU3R5bGUuU0NSSVBUU0NSSVBUfSxcbiAgICB7dHlwZTogXCJzbWFsbFwiLCBzdHlsZTogU3R5bGUuU0NSSVBUfSxcbiAgICB7dHlwZTogXCJzbWFsbFwiLCBzdHlsZTogU3R5bGUuVEVYVH0sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogMX0sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogMn0sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogM30sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogNH0sXG4gICAge3R5cGU6IFwic3RhY2tcIn1cbl07XG5cbi8qKlxuICogR2V0IHRoZSBmb250IHVzZWQgaW4gYSBkZWxpbWl0ZXIgYmFzZWQgb24gd2hhdCBraW5kIG9mIGRlbGltaXRlciBpdCBpcy5cbiAqL1xudmFyIGRlbGltVHlwZVRvRm9udCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiTWFpbi1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgICAgICByZXR1cm4gXCJTaXplXCIgKyB0eXBlLnNpemUgKyBcIi1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlLnR5cGUgPT09IFwic3RhY2tcIikge1xuICAgICAgICByZXR1cm4gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmF2ZXJzZSBhIHNlcXVlbmNlIG9mIHR5cGVzIG9mIGRlbGltaXRlcnMgdG8gZGVjaWRlIHdoYXQga2luZCBvZiBkZWxpbWl0ZXJcbiAqIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIGRlbGltaXRlciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0K2RlcHRoLlxuICovXG52YXIgdHJhdmVyc2VTZXF1ZW5jZSA9IGZ1bmN0aW9uKGRlbGltLCBoZWlnaHQsIHNlcXVlbmNlLCBvcHRpb25zKSB7XG4gICAgLy8gSGVyZSwgd2UgY2hvb3NlIHRoZSBpbmRleCB3ZSBzaG91bGQgc3RhcnQgYXQgaW4gdGhlIHNlcXVlbmNlcy4gSW4gc21hbGxlclxuICAgIC8vIHNpemVzICh3aGljaCBjb3JyZXNwb25kIHRvIGxhcmdlciBudW1iZXJzIGluIHN0eWxlLnNpemUpIHdlIHN0YXJ0IGVhcmxpZXJcbiAgICAvLyBpbiB0aGUgc2VxdWVuY2UuIFRodXMsIHNjcmlwdHNjcmlwdCBzdGFydHMgYXQgaW5kZXggMy0zPTAsIHNjcmlwdCBzdGFydHNcbiAgICAvLyBhdCBpbmRleCAzLTI9MSwgdGV4dCBzdGFydHMgYXQgMy0xPTIsIGFuZCBkaXNwbGF5IHN0YXJ0cyBhdCBtaW4oMiwzLTApPTJcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbigyLCAzIC0gb3B0aW9ucy5zdHlsZS5zaXplKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VxdWVuY2VbaV0udHlwZSA9PT0gXCJzdGFja1wiKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFsd2F5cyB0aGUgbGFzdCBkZWxpbWl0ZXIsIHNvIHdlIGp1c3QgYnJlYWsgdGhlIGxvb3Agbm93LlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWV0cmljcyA9IGdldE1ldHJpY3MoZGVsaW0sIGRlbGltVHlwZVRvRm9udChzZXF1ZW5jZVtpXSkpO1xuICAgICAgICB2YXIgaGVpZ2h0RGVwdGggPSBtZXRyaWNzLmhlaWdodCArIG1ldHJpY3MuZGVwdGg7XG5cbiAgICAgICAgLy8gU21hbGwgZGVsaW1pdGVycyBhcmUgc2NhbGVkIGRvd24gdmVyc2lvbnMgb2YgdGhlIHNhbWUgZm9udCwgc28gd2VcbiAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHN0eWxlIGNoYW5nZSBzaXplLlxuXG4gICAgICAgIGlmIChzZXF1ZW5jZVtpXS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgICAgICAgIGhlaWdodERlcHRoICo9IHNlcXVlbmNlW2ldLnN0eWxlLnNpemVNdWx0aXBsaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGRlbGltaXRlciBhdCB0aGlzIHNpemUgd29ya3MgZm9yIHRoZSBnaXZlbiBoZWlnaHQuXG4gICAgICAgIGlmIChoZWlnaHREZXB0aCA+IGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbmNlW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgcmV0dXJuIHRoZSBsYXN0IHNlcXVlbmNlIGVsZW1lbnQuXG4gICAgcmV0dXJuIHNlcXVlbmNlW3NlcXVlbmNlLmxlbmd0aCAtIDFdO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgZGVsaW1pdGVyIG9mIGEgZ2l2ZW4gaGVpZ2h0K2RlcHRoLCB3aXRoIG9wdGlvbmFsIGNlbnRlcmluZy4gSGVyZSwgd2VcbiAqIHRyYXZlcnNlIHRoZSBzZXF1ZW5jZXMsIGFuZCBjcmVhdGUgYSBkZWxpbWl0ZXIgdGhhdCB0aGUgc2VxdWVuY2UgdGVsbHMgdXMgdG8uXG4gKi9cbnZhciBtYWtlQ3VzdG9tU2l6ZWREZWxpbSA9IGZ1bmN0aW9uKGRlbGltLCBoZWlnaHQsIGNlbnRlciwgb3B0aW9ucywgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpIHtcbiAgICBpZiAoZGVsaW0gPT09IFwiPFwiIHx8IGRlbGltID09PSBcIlxcXFxsdFwiKSB7XG4gICAgICAgIGRlbGltID0gXCJcXFxcbGFuZ2xlXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCI+XCIgfHwgZGVsaW0gPT09IFwiXFxcXGd0XCIpIHtcbiAgICAgICAgZGVsaW0gPSBcIlxcXFxyYW5nbGVcIjtcbiAgICB9XG5cbiAgICAvLyBEZWNpZGUgd2hhdCBzZXF1ZW5jZSB0byB1c2VcbiAgICB2YXIgc2VxdWVuY2U7XG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrTmV2ZXJEZWxpbWl0ZXJzLCBkZWxpbSkpIHtcbiAgICAgICAgc2VxdWVuY2UgPSBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2U7XG4gICAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyhzdGFja0xhcmdlRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgICAgIHNlcXVlbmNlID0gc3RhY2tMYXJnZURlbGltaXRlclNlcXVlbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcXVlbmNlID0gc3RhY2tBbHdheXNEZWxpbWl0ZXJTZXF1ZW5jZTtcbiAgICB9XG5cbiAgICAvLyBMb29rIHRocm91Z2ggdGhlIHNlcXVlbmNlXG4gICAgdmFyIGRlbGltVHlwZSA9IHRyYXZlcnNlU2VxdWVuY2UoZGVsaW0sIGhlaWdodCwgc2VxdWVuY2UsIG9wdGlvbnMpO1xuXG4gICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBzZXF1ZW5jZSBlbGVtZW50IHdlIGRlY2lkZWQgb24sIGNhbGwgdGhlIGFwcHJvcHJpYXRlXG4gICAgLy8gZnVuY3Rpb24uXG4gICAgaWYgKGRlbGltVHlwZS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTbWFsbERlbGltKGRlbGltLCBkZWxpbVR5cGUuc3R5bGUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpO1xuICAgIH0gZWxzZSBpZiAoZGVsaW1UeXBlLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgICAgICByZXR1cm4gbWFrZUxhcmdlRGVsaW0oZGVsaW0sIGRlbGltVHlwZS5zaXplLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzKTtcbiAgICB9IGVsc2UgaWYgKGRlbGltVHlwZS50eXBlID09PSBcInN0YWNrXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTdGFja2VkRGVsaW0oZGVsaW0sIGhlaWdodCwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2UgYSBkZWxpbWl0ZXIgZm9yIHVzZSB3aXRoIGBcXGxlZnRgIGFuZCBgXFxyaWdodGAsIGdpdmVuIGEgaGVpZ2h0IGFuZCBkZXB0aFxuICogb2YgYW4gZXhwcmVzc2lvbiB0aGF0IHRoZSBkZWxpbWl0ZXJzIHN1cnJvdW5kLlxuICovXG52YXIgbWFrZUxlZnRSaWdodERlbGltID0gZnVuY3Rpb24oZGVsaW0sIGhlaWdodCwgZGVwdGgsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcykge1xuICAgIC8vIFdlIGFsd2F5cyBjZW50ZXIgXFxsZWZ0L1xccmlnaHQgZGVsaW1pdGVycywgc28gdGhlIGF4aXMgaXMgYWx3YXlzIHNoaWZ0ZWRcbiAgICB2YXIgYXhpc0hlaWdodCA9XG4gICAgICAgIG9wdGlvbnMuc3R5bGUubWV0cmljcy5heGlzSGVpZ2h0ICogb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIC8vIFRha2VuIGZyb20gVGVYIHNvdXJjZSwgdGV4LndlYiwgZnVuY3Rpb24gbWFrZV9sZWZ0X3JpZ2h0XG4gICAgdmFyIGRlbGltaXRlckZhY3RvciA9IDkwMTtcbiAgICB2YXIgZGVsaW1pdGVyRXh0ZW5kID0gNS4wIC8gZm9udE1ldHJpY3MubWV0cmljcy5wdFBlckVtO1xuXG4gICAgdmFyIG1heERpc3RGcm9tQXhpcyA9IE1hdGgubWF4KFxuICAgICAgICBoZWlnaHQgLSBheGlzSGVpZ2h0LCBkZXB0aCArIGF4aXNIZWlnaHQpO1xuXG4gICAgdmFyIHRvdGFsSGVpZ2h0ID0gTWF0aC5tYXgoXG4gICAgICAgIC8vIEluIHJlYWwgVGVYLCBjYWxjdWxhdGlvbnMgYXJlIGRvbmUgdXNpbmcgaW50ZWdyYWwgdmFsdWVzIHdoaWNoIGFyZVxuICAgICAgICAvLyA2NTUzNiBwZXIgcHQsIG9yIDY1NTM2MCBwZXIgZW0uIFNvLCB0aGUgZGl2aXNpb24gaGVyZSB0cnVuY2F0ZXMgaW5cbiAgICAgICAgLy8gVGVYIGJ1dCBkb2Vzbid0IGhlcmUsIHByb2R1Y2luZyBkaWZmZXJlbnQgcmVzdWx0cy4gSWYgd2Ugd2FudGVkIHRvXG4gICAgICAgIC8vIGV4YWN0bHkgbWF0Y2ggVGVYJ3MgY2FsY3VsYXRpb24sIHdlIGNvdWxkIGRvXG4gICAgICAgIC8vICAgTWF0aC5mbG9vcig2NTUzNjAgKiBtYXhEaXN0RnJvbUF4aXMgLyA1MDApICpcbiAgICAgICAgLy8gICAgZGVsaW1pdGVyRmFjdG9yIC8gNjU1MzYwXG4gICAgICAgIC8vIChUbyBzZWUgdGhlIGRpZmZlcmVuY2UsIGNvbXBhcmVcbiAgICAgICAgLy8gICAgeF57eF57XFxsZWZ0KFxccnVsZXswLjFlbX17MC42OGVtfVxccmlnaHQpfX1cbiAgICAgICAgLy8gaW4gVGVYIGFuZCBLYVRlWClcbiAgICAgICAgbWF4RGlzdEZyb21BeGlzIC8gNTAwICogZGVsaW1pdGVyRmFjdG9yLFxuICAgICAgICAyICogbWF4RGlzdEZyb21BeGlzIC0gZGVsaW1pdGVyRXh0ZW5kKTtcblxuICAgIC8vIEZpbmFsbHksIHdlIGRlZmVyIHRvIGBtYWtlQ3VzdG9tU2l6ZWREZWxpbWAgd2l0aCBvdXIgY2FsY3VsYXRlZCB0b3RhbFxuICAgIC8vIGhlaWdodFxuICAgIHJldHVybiBtYWtlQ3VzdG9tU2l6ZWREZWxpbShkZWxpbSwgdG90YWxIZWlnaHQsIHRydWUsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2l6ZWREZWxpbTogbWFrZVNpemVkRGVsaW0sXG4gICAgY3VzdG9tU2l6ZWREZWxpbTogbWFrZUN1c3RvbVNpemVkRGVsaW0sXG4gICAgbGVmdFJpZ2h0RGVsaW06IG1ha2VMZWZ0UmlnaHREZWxpbVxufTtcbiIsIi8qKlxuICogVGhlc2Ugb2JqZWN0cyBzdG9yZSB0aGUgZGF0YSBhYm91dCB0aGUgRE9NIG5vZGVzIHdlIGNyZWF0ZSwgYXMgd2VsbCBhcyBzb21lXG4gKiBleHRyYSBkYXRhLiBUaGV5IGNhbiB0aGVuIGJlIHRyYW5zZm9ybWVkIGludG8gcmVhbCBET00gbm9kZXMgd2l0aCB0aGVcbiAqIGB0b05vZGVgIGZ1bmN0aW9uIG9yIEhUTUwgbWFya3VwIHVzaW5nIGB0b01hcmt1cGAuIFRoZXkgYXJlIHVzZWZ1bCBmb3IgYm90aFxuICogc3RvcmluZyBleHRyYSBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlcywgYXMgd2VsbCBhcyBwcm92aWRpbmcgYSB3YXkgdG8gZWFzaWx5XG4gKiB3b3JrIHdpdGggdGhlIERPTS5cbiAqXG4gKiBTaW1pbGFyIGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIE1hdGhNTCBub2RlcyBleGlzdCBpbiBtYXRoTUxUcmVlLmpzLlxuICovXG52YXIgdW5pY29kZVJlZ2V4ZXMgPSByZXF1aXJlKFwiLi91bmljb2RlUmVnZXhlc1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBIVE1MIGNsYXNzTmFtZSBiYXNlZCBvbiBhIGxpc3Qgb2YgY2xhc3Nlcy4gSW4gYWRkaXRpb24gdG8gam9pbmluZ1xuICogd2l0aCBzcGFjZXMsIHdlIGFsc28gcmVtb3ZlIG51bGwgb3IgZW1wdHkgY2xhc3Nlcy5cbiAqL1xudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24oY2xhc3Nlcykge1xuICAgIGNsYXNzZXMgPSBjbGFzc2VzLnNsaWNlKCk7XG4gICAgZm9yICh2YXIgaSA9IGNsYXNzZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKCFjbGFzc2VzW2ldKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbGFzc2VzLmpvaW4oXCIgXCIpO1xufTtcblxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHNwYW4gbm9kZSwgd2l0aCBhIGNsYXNzTmFtZSwgYSBsaXN0IG9mIGNoaWxkcmVuLCBhbmRcbiAqIGFuIGlubGluZSBzdHlsZS4gSXQgYWxzbyBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBpdHMgaGVpZ2h0LCBkZXB0aCwgYW5kXG4gKiBtYXhGb250U2l6ZS5cbiAqL1xuZnVuY3Rpb24gc3BhbihjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmRlcHRoID0gMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gMDtcbiAgICB0aGlzLnN0eWxlID0ge307XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3R5bGUuaXNUaWdodCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMucHVzaChcIm10aWdodFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5nZXRDb2xvcigpKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLmNvbG9yID0gb3B0aW9ucy5nZXRDb2xvcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFNldHMgYW4gYXJiaXRyYXJ5IGF0dHJpYnV0ZSBvbiB0aGUgc3Bhbi4gV2FybmluZzogdXNlIHRoaXMgd2lzZWx5LiBOb3QgYWxsXG4gKiBicm93c2VycyBzdXBwb3J0IGF0dHJpYnV0ZXMgdGhlIHNhbWUsIGFuZCBoYXZpbmcgdG9vIG1hbnkgY3VzdG9tIGF0dHJpYnV0ZXNcbiAqIGlzIHByb2JhYmx5IGJhZC5cbiAqL1xuc3Bhbi5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWU7XG59O1xuXG5zcGFuLnByb3RvdHlwZS50cnlDb21iaW5lID0gZnVuY3Rpb24oc2libGluZykge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgc3BhbiBpbnRvIGFuIEhUTUwgbm9kZVxuICovXG5zcGFuLnByb3RvdHlwZS50b05vZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgLy8gQXBwbHkgdGhlIGNsYXNzXG4gICAgc3Bhbi5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpO1xuXG4gICAgLy8gQXBwbHkgaW5saW5lIHN0eWxlc1xuICAgIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0eWxlLCBzdHlsZSkpIHtcbiAgICAgICAgICAgIHNwYW4uc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBhdHRyaWJ1dGVzXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIHRoZSBjaGlsZHJlbiwgYWxzbyBhcyBIVE1MIG5vZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwYW47XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIHNwYW4gaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmdcbiAqL1xuc3Bhbi5wcm90b3R5cGUudG9NYXJrdXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWFya3VwID0gXCI8c3BhblwiO1xuXG4gICAgLy8gQWRkIHRoZSBjbGFzc1xuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIiBjbGFzcz1cXFwiXCI7XG4gICAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSk7XG4gICAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVzID0gXCJcIjtcblxuICAgIC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuICAgIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gdXRpbHMuaHlwaGVuYXRlKHN0eWxlKSArIFwiOlwiICsgdGhpcy5zdHlsZVtzdHlsZV0gKyBcIjtcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIHN0eWxlPVxcXCJcIiArIHV0aWxzLmVzY2FwZShzdHlsZXMpICsgXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBhdHRyaWJ1dGVzXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgICAgICBtYXJrdXAgKz0gXCIgXCIgKyBhdHRyICsgXCI9XFxcIlwiO1xuICAgICAgICAgICAgbWFya3VwICs9IHV0aWxzLmVzY2FwZSh0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICAgICAgbWFya3VwICs9IFwiXFxcIlwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPlwiO1xuXG4gICAgLy8gQWRkIHRoZSBtYXJrdXAgb2YgdGhlIGNoaWxkcmVuLCBhbHNvIGFzIG1hcmt1cFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIjwvc3Bhbj5cIjtcblxuICAgIHJldHVybiBtYXJrdXA7XG59O1xuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgZG9jdW1lbnQgZnJhZ21lbnQsIHdoaWNoIGNvbnRhaW5zIGVsZW1lbnRzLCBidXQgd2hlblxuICogcGxhY2VkIGludG8gdGhlIERPTSBkb2Vzbid0IGhhdmUgYW55IHJlcHJlc2VudGF0aW9uIGl0c2VsZi4gVGh1cywgaXQgb25seVxuICogY29udGFpbnMgY2hpbGRyZW4gYW5kIGRvZXNuJ3QgaGF2ZSBhbnkgSFRNTCBwcm9wZXJ0aWVzLiBJdCBhbHNvIGtlZXBzIHRyYWNrXG4gKiBvZiBhIGhlaWdodCwgZGVwdGgsIGFuZCBtYXhGb250U2l6ZS5cbiAqL1xuZnVuY3Rpb24gZG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbikge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgdGhpcy5tYXhGb250U2l6ZSA9IDA7XG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBhIG5vZGVcbiAqL1xuZG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUudG9Ob2RlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ3JlYXRlIGEgZnJhZ21lbnRcbiAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIC8vIEFwcGVuZCB0aGUgY2hpbGRyZW5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZnJhZy5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZztcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBIVE1MIG1hcmt1cFxuICovXG5kb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS50b01hcmt1cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIlwiO1xuXG4gICAgLy8gU2ltcGx5IGNvbmNhdGVuYXRlIHRoZSBtYXJrdXAgZm9yIHRoZSBjaGlsZHJlbiB0b2dldGhlclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG59O1xuXG52YXIgaUNvbWJpbmF0aW9ucyA9IHtcbiAgICAnw64nOiAnXFx1MDEzMVxcdTAzMDInLFxuICAgICfDryc6ICdcXHUwMTMxXFx1MDMwOCcsXG4gICAgJ8OtJzogJ1xcdTAxMzFcXHUwMzAxJyxcbiAgICAvLyAnxKsnOiAnXFx1MDEzMVxcdTAzMDQnLCAvLyBlbmFibGUgd2hlbiB3ZSBhZGQgRXh0ZW5kZWQgTGF0aW5cbiAgICAnw6wnOiAnXFx1MDEzMVxcdTAzMDAnXG59O1xuXG4vKipcbiAqIEEgc3ltYm9sIG5vZGUgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYSBzaW5nbGUgc3ltYm9sLiBJdCBlaXRoZXIgcmVuZGVyc1xuICogdG8gYSBzaW5nbGUgdGV4dCBub2RlLCBvciBhIHNwYW4gd2l0aCBhIHNpbmdsZSB0ZXh0IG5vZGUgaW4gaXQsIGRlcGVuZGluZyBvblxuICogd2hldGhlciBpdCBoYXMgQ1NTIGNsYXNzZXMsIHN0eWxlcywgb3IgbmVlZHMgaXRhbGljIGNvcnJlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHN5bWJvbE5vZGUodmFsdWUsIGhlaWdodCwgZGVwdGgsIGl0YWxpYywgc2tldywgY2xhc3Nlcywgc3R5bGUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUgfHwgXCJcIjtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aCB8fCAwO1xuICAgIHRoaXMuaXRhbGljID0gaXRhbGljIHx8IDA7XG4gICAgdGhpcy5za2V3ID0gc2tldyB8fCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSAwO1xuXG4gICAgLy8gTWFyayBDSksgY2hhcmFjdGVycyB3aXRoIHNwZWNpZmljIGNsYXNzZXMgc28gdGhhdCB3ZSBjYW4gc3BlY2lmeSB3aGljaFxuICAgIC8vIGZvbnRzIHRvIHVzZS4gIFRoaXMgYWxsb3dzIHVzIHRvIHJlbmRlciB0aGVzZSBjaGFyYWN0ZXJzIHdpdGggYSBzZXJpZlxuICAgIC8vIGZvbnQgaW4gc2l0dWF0aW9ucyB3aGVyZSB0aGUgYnJvd3NlciB3b3VsZCBlaXRoZXIgZGVmYXVsdCB0byBhIHNhbnMgc2VyaWZcbiAgICAvLyBvciByZW5kZXIgYSBwbGFjZWhvbGRlciBjaGFyYWN0ZXIuXG4gICAgaWYgKHVuaWNvZGVSZWdleGVzLmNqa1JlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIC8vIEkgY291bGRuJ3QgZmluZCBhbnkgZm9udHMgdGhhdCBjb250YWluZWQgSGFuZ3VsIGFzIHdlbGwgYXMgYWxsIG9mXG4gICAgICAgIC8vIHRoZSBvdGhlciBjaGFyYWN0ZXJzIHdlIHdhbnRlZCB0byB0ZXN0IHRoZXJlIGZvciBpdCBnZXRzIGl0cyBvd25cbiAgICAgICAgLy8gQ1NTIGNsYXNzLlxuICAgICAgICBpZiAodW5pY29kZVJlZ2V4ZXMuaGFuZ3VsUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKCdoYW5ndWxfZmFsbGJhY2snKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKCdjamtfZmFsbGJhY2snKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgvW8Ouw6/DrcOsXS8udGVzdCh0aGlzLnZhbHVlKSkgeyAgICAvLyBhZGQgxKsgd2hlbiB3ZSBhZGQgRXh0ZW5kZWQgTGF0aW5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGlDb21iaW5hdGlvbnNbdGhpcy52YWx1ZV07XG4gICAgfVxufVxuXG5zeW1ib2xOb2RlLnByb3RvdHlwZS50cnlDb21iaW5lID0gZnVuY3Rpb24oc2libGluZykge1xuICAgIGlmICghc2libGluZ1xuICAgICAgICB8fCAhKHNpYmxpbmcgaW5zdGFuY2VvZiBzeW1ib2xOb2RlKVxuICAgICAgICB8fCB0aGlzLml0YWxpYyA+IDBcbiAgICAgICAgfHwgY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSAhPT0gY3JlYXRlQ2xhc3Moc2libGluZy5jbGFzc2VzKVxuICAgICAgICB8fCB0aGlzLnNrZXcgIT09IHNpYmxpbmcuc2tld1xuICAgICAgICB8fCB0aGlzLm1heEZvbnRTaXplICE9PSBzaWJsaW5nLm1heEZvbnRTaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSlcbiAgICAgICAgICAgICYmIHRoaXMuc3R5bGVbc3R5bGVdICE9PSBzaWJsaW5nLnN0eWxlW3N0eWxlXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoc3R5bGUgaW4gc2libGluZy5zdHlsZSkge1xuICAgICAgICBpZiAoc2libGluZy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSlcbiAgICAgICAgICAgICYmIHRoaXMuc3R5bGVbc3R5bGVdICE9PSBzaWJsaW5nLnN0eWxlW3N0eWxlXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMudmFsdWUgKz0gc2libGluZy52YWx1ZTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KHRoaXMuaGVpZ2h0LCBzaWJsaW5nLmhlaWdodCk7XG4gICAgdGhpcy5kZXB0aCA9IE1hdGgubWF4KHRoaXMuZGVwdGgsIHNpYmxpbmcuZGVwdGgpO1xuICAgIHRoaXMuaXRhbGljID0gc2libGluZy5pdGFsaWM7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0ZXh0IG5vZGUgb3Igc3BhbiBmcm9tIGEgc3ltYm9sIG5vZGUuIE5vdGUgdGhhdCBhIHNwYW4gaXMgb25seVxuICogY3JlYXRlZCBpZiBpdCBpcyBuZWVkZWQuXG4gKi9cbnN5bWJvbE5vZGUucHJvdG90eXBlLnRvTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy52YWx1ZSk7XG4gICAgdmFyIHNwYW4gPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuaXRhbGljID4gMCkge1xuICAgICAgICBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4uc3R5bGUubWFyZ2luUmlnaHQgPSB0aGlzLml0YWxpYyArIFwiZW1cIjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBzcGFuLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNwYW4pIHtcbiAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBzeW1ib2wgbm9kZS5cbiAqL1xuc3ltYm9sTm9kZS5wcm90b3R5cGUudG9NYXJrdXAgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUT0RPKGFscGVydCk6IE1vcmUgZHVwbGljYXRpb24gdGhhbiBJJ2QgbGlrZSBmcm9tXG4gICAgLy8gc3Bhbi5wcm90b3R5cGUudG9NYXJrdXAgYW5kIHN5bWJvbE5vZGUucHJvdG90eXBlLnRvTm9kZS4uLlxuICAgIHZhciBuZWVkc1NwYW4gPSBmYWxzZTtcblxuICAgIHZhciBtYXJrdXAgPSBcIjxzcGFuXCI7XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICBuZWVkc1NwYW4gPSB0cnVlO1xuICAgICAgICBtYXJrdXAgKz0gXCIgY2xhc3M9XFxcIlwiO1xuICAgICAgICBtYXJrdXAgKz0gdXRpbHMuZXNjYXBlKGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3NlcykpO1xuICAgICAgICBtYXJrdXAgKz0gXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlcyA9IFwiXCI7XG5cbiAgICBpZiAodGhpcy5pdGFsaWMgPiAwKSB7XG4gICAgICAgIHN0eWxlcyArPSBcIm1hcmdpbi1yaWdodDpcIiArIHRoaXMuaXRhbGljICsgXCJlbTtcIjtcbiAgICB9XG4gICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSB1dGlscy5oeXBoZW5hdGUoc3R5bGUpICsgXCI6XCIgKyB0aGlzLnN0eWxlW3N0eWxlXSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgICBuZWVkc1NwYW4gPSB0cnVlO1xuICAgICAgICBtYXJrdXAgKz0gXCIgc3R5bGU9XFxcIlwiICsgdXRpbHMuZXNjYXBlKHN0eWxlcykgKyBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgZXNjYXBlZCA9IHV0aWxzLmVzY2FwZSh0aGlzLnZhbHVlKTtcbiAgICBpZiAobmVlZHNTcGFuKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIj5cIjtcbiAgICAgICAgbWFya3VwICs9IGVzY2FwZWQ7XG4gICAgICAgIG1hcmt1cCArPSBcIjwvc3Bhbj5cIjtcbiAgICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXNjYXBlZDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzcGFuOiBzcGFuLFxuICAgIGRvY3VtZW50RnJhZ21lbnQ6IGRvY3VtZW50RnJhZ21lbnQsXG4gICAgc3ltYm9sTm9kZTogc3ltYm9sTm9kZVxufTtcbiIsIi8qIGVzbGludCBuby1jb25zdGFudC1jb25kaXRpb246MCAqL1xudmFyIHBhcnNlRGF0YSA9IHJlcXVpcmUoXCIuL3BhcnNlRGF0YVwiKTtcbnZhciBQYXJzZUVycm9yID0gcmVxdWlyZShcIi4vUGFyc2VFcnJvclwiKTtcbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL1N0eWxlXCIpO1xuXG52YXIgUGFyc2VOb2RlID0gcGFyc2VEYXRhLlBhcnNlTm9kZTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgYm9keSBvZiB0aGUgZW52aXJvbm1lbnQsIHdpdGggcm93cyBkZWxpbWl0ZWQgYnkgXFxcXCBhbmRcbiAqIGNvbHVtbnMgZGVsaW1pdGVkIGJ5ICYsIGFuZCBjcmVhdGUgYSBuZXN0ZWQgbGlzdCBpbiByb3ctbWFqb3Igb3JkZXJcbiAqIHdpdGggb25lIGdyb3VwIHBlciBjZWxsLlxuICovXG5mdW5jdGlvbiBwYXJzZUFycmF5KHBhcnNlciwgcmVzdWx0KSB7XG4gICAgdmFyIHJvdyA9IFtdO1xuICAgIHZhciBib2R5ID0gW3Jvd107XG4gICAgdmFyIHJvd0dhcHMgPSBbXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgY2VsbCA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIG51bGwpO1xuICAgICAgICByb3cucHVzaChuZXcgUGFyc2VOb2RlKFwib3JkZ3JvdXBcIiwgY2VsbCwgcGFyc2VyLm1vZGUpKTtcbiAgICAgICAgdmFyIG5leHQgPSBwYXJzZXIubmV4dFRva2VuLnRleHQ7XG4gICAgICAgIGlmIChuZXh0ID09PSBcIiZcIikge1xuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxlbmRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gXCJcXFxcXFxcXFwiIHx8IG5leHQgPT09IFwiXFxcXGNyXCIpIHtcbiAgICAgICAgICAgIHZhciBjciA9IHBhcnNlci5wYXJzZUZ1bmN0aW9uKCk7XG4gICAgICAgICAgICByb3dHYXBzLnB1c2goY3IudmFsdWUuc2l6ZSk7XG4gICAgICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgICAgIGJvZHkucHVzaChyb3cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCAmIG9yIFxcXFxcXFxcIG9yIFxcXFxlbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5ib2R5ID0gYm9keTtcbiAgICByZXN1bHQucm93R2FwcyA9IHJvd0dhcHM7XG4gICAgcmV0dXJuIG5ldyBQYXJzZU5vZGUocmVzdWx0LnR5cGUsIHJlc3VsdCwgcGFyc2VyLm1vZGUpO1xufVxuXG4vKlxuICogQW4gZW52aXJvbm1lbnQgZGVmaW5pdGlvbiBpcyB2ZXJ5IHNpbWlsYXIgdG8gYSBmdW5jdGlvbiBkZWZpbml0aW9uOlxuICogaXQgaXMgZGVjbGFyZWQgd2l0aCBhIG5hbWUgb3IgYSBsaXN0IG9mIG5hbWVzLCBhIHNldCBvZiBwcm9wZXJ0aWVzXG4gKiBhbmQgYSBoYW5kbGVyIGNvbnRhaW5pbmcgdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGUgcHJvcGVydGllcyBpbmNsdWRlOlxuICogIC0gbnVtQXJnczogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgYWZ0ZXIgdGhlIFxcYmVnaW57bmFtZX0gZnVuY3Rpb24uXG4gKiAgLSBhcmdUeXBlczogKG9wdGlvbmFsKSBKdXN0IGxpa2UgZm9yIGEgZnVuY3Rpb25cbiAqICAtIGFsbG93ZWRJblRleHQ6IChvcHRpb25hbCkgV2hldGhlciBvciBub3QgdGhlIGVudmlyb25tZW50IGlzIGFsbG93ZWQgaW5zaWRlXG4gKiAgICAgICAgICAgICAgICAgICB0ZXh0IG1vZGUgKGRlZmF1bHQgZmFsc2UpIChub3QgZW5mb3JjZWQgeWV0KVxuICogIC0gbnVtT3B0aW9uYWxBcmdzOiAob3B0aW9uYWwpIEp1c3QgbGlrZSBmb3IgYSBmdW5jdGlvblxuICogQSBiYXJlIG51bWJlciBpbnN0ZWFkIG9mIHRoYXQgb2JqZWN0IGluZGljYXRlcyB0aGUgbnVtQXJncyB2YWx1ZS5cbiAqXG4gKiBUaGUgaGFuZGxlciBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdHdvIGFyZ3VtZW50c1xuICogIC0gY29udGV4dDogaW5mb3JtYXRpb24gYW5kIHJlZmVyZW5jZXMgcHJvdmlkZWQgYnkgdGhlIHBhcnNlclxuICogIC0gYXJnczogYW4gYXJyYXkgb2YgYXJndW1lbnRzIHBhc3NlZCB0byBcXGJlZ2lue25hbWV9XG4gKiBUaGUgY29udGV4dCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgLSBlbnZOYW1lOiB0aGUgbmFtZSBvZiB0aGUgZW52aXJvbm1lbnQsIG9uZSBvZiB0aGUgbGlzdGVkIG5hbWVzLlxuICogIC0gcGFyc2VyOiB0aGUgcGFyc2VyIG9iamVjdFxuICogIC0gbGV4ZXI6IHRoZSBsZXhlciBvYmplY3RcbiAqICAtIHBvc2l0aW9uczogdGhlIHBvc2l0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlc2UgYXJndW1lbnRzIGZyb20gYXJncy5cbiAqIFRoZSBoYW5kbGVyIG11c3QgcmV0dXJuIGEgUGFyc2VSZXN1bHQuXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lRW52aXJvbm1lbnQobmFtZXMsIHByb3BzLCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBuYW1lcyA9IFtuYW1lc107XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcHJvcHMgPSB7IG51bUFyZ3M6IHByb3BzIH07XG4gICAgfVxuICAgIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBvZiBlbnZpcm9ubWVudHNcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgbnVtQXJnczogcHJvcHMubnVtQXJncyB8fCAwLFxuICAgICAgICBhcmdUeXBlczogcHJvcHMuYXJnVHlwZXMsXG4gICAgICAgIGdyZWVkaW5lc3M6IDEsXG4gICAgICAgIGFsbG93ZWRJblRleHQ6ICEhcHJvcHMuYWxsb3dlZEluVGV4dCxcbiAgICAgICAgbnVtT3B0aW9uYWxBcmdzOiBwcm9wcy5udW1PcHRpb25hbEFyZ3MgfHwgMCxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0c1tuYW1lc1tpXV0gPSBkYXRhO1xuICAgIH1cbn1cblxuLy8gQXJyYXlzIGFyZSBwYXJ0IG9mIExhVGVYLCBkZWZpbmVkIGluIGx0dGFiLmR0eCBzbyBpdHMgZG9jdW1lbnRhdGlvblxuLy8gaXMgcGFydCBvZiB0aGUgc291cmNlMmUucGRmIGZpbGUgb2YgTGFUZVgyZSBzb3VyY2UgZG9jdW1lbnRhdGlvbi5cbmRlZmluZUVudmlyb25tZW50KFwiYXJyYXlcIiwge1xuICAgIG51bUFyZ3M6IDFcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgY29sYWxpZ24gPSBhcmdzWzBdO1xuICAgIGNvbGFsaWduID0gY29sYWxpZ24udmFsdWUubWFwID8gY29sYWxpZ24udmFsdWUgOiBbY29sYWxpZ25dO1xuICAgIHZhciBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGNhID0gbm9kZS52YWx1ZTtcbiAgICAgICAgaWYgKFwibGNyXCIuaW5kZXhPZihjYSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICAgICAgICBhbGlnbjogY2FcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY2EgPT09IFwifFwiKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic2VwYXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yOiBcInxcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgIFwiVW5rbm93biBjb2x1bW4gYWxpZ25tZW50OiBcIiArIG5vZGUudmFsdWUsXG4gICAgICAgICAgICBub2RlKTtcbiAgICB9KTtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGNvbHM6IGNvbHMsXG4gICAgICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXI6IHRydWUgLy8gXFxAcHJlYW1ibGUgaW4gbHR0YWIuZHR4XG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIHJldHVybiByZXM7XG59KTtcblxuLy8gVGhlIG1hdHJpeCBlbnZpcm9ubWVudHMgb2YgYW1zbWF0aCBidWlsZHMgb24gdGhlIGFycmF5IGVudmlyb25tZW50XG4vLyBvZiBMYVRlWCwgd2hpY2ggaXMgZGlzY3Vzc2VkIGFib3ZlLlxuZGVmaW5lRW52aXJvbm1lbnQoW1xuICAgIFwibWF0cml4XCIsXG4gICAgXCJwbWF0cml4XCIsXG4gICAgXCJibWF0cml4XCIsXG4gICAgXCJCbWF0cml4XCIsXG4gICAgXCJ2bWF0cml4XCIsXG4gICAgXCJWbWF0cml4XCJcbl0sIHtcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgZGVsaW1pdGVycyA9IHtcbiAgICAgICAgXCJtYXRyaXhcIjogbnVsbCxcbiAgICAgICAgXCJwbWF0cml4XCI6IFtcIihcIiwgXCIpXCJdLFxuICAgICAgICBcImJtYXRyaXhcIjogW1wiW1wiLCBcIl1cIl0sXG4gICAgICAgIFwiQm1hdHJpeFwiOiBbXCJcXFxce1wiLCBcIlxcXFx9XCJdLFxuICAgICAgICBcInZtYXRyaXhcIjogW1wifFwiLCBcInxcIl0sXG4gICAgICAgIFwiVm1hdHJpeFwiOiBbXCJcXFxcVmVydFwiLCBcIlxcXFxWZXJ0XCJdXG4gICAgfVtjb250ZXh0LmVudk5hbWVdO1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgaHNraXBCZWZvcmVBbmRBZnRlcjogZmFsc2UgLy8gXFxoc2tpcCAtXFxhcnJheWNvbHNlcCBpbiBhbXNtYXRoXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIGlmIChkZWxpbWl0ZXJzKSB7XG4gICAgICAgIHJlcyA9IG5ldyBQYXJzZU5vZGUoXCJsZWZ0cmlnaHRcIiwge1xuICAgICAgICAgICAgYm9keTogW3Jlc10sXG4gICAgICAgICAgICBsZWZ0OiBkZWxpbWl0ZXJzWzBdLFxuICAgICAgICAgICAgcmlnaHQ6IGRlbGltaXRlcnNbMV1cbiAgICAgICAgfSwgY29udGV4dC5tb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn0pO1xuXG4vLyBBIGNhc2VzIGVudmlyb25tZW50IChpbiBhbXNtYXRoLnN0eSkgaXMgYWxtb3N0IGVxdWl2YWxlbnQgdG9cbi8vIFxcZGVmXFxhcnJheXN0cmV0Y2h7MS4yfSVcbi8vIFxcbGVmdFxce1xcYmVnaW57YXJyYXl9e0B7fWxAe1xccXVhZH1sQHt9fSDigKYgXFxlbmR7YXJyYXl9XFxyaWdodC5cbmRlZmluZUVudmlyb25tZW50KFwiY2FzZXNcIiwge1xufSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgYXJyYXlzdHJldGNoOiAxLjIsXG4gICAgICAgIGNvbHM6IFt7XG4gICAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgICBhbGlnbjogXCJsXCIsXG4gICAgICAgICAgICBwcmVnYXA6IDAsXG4gICAgICAgICAgICAvLyBUT0RPKGtldmluYikgZ2V0IHRoZSBjdXJyZW50IHN0eWxlLlxuICAgICAgICAgICAgLy8gRm9yIG5vdyB3ZSB1c2UgdGhlIG1ldHJpY3MgZm9yIFRFWFQgc3R5bGUgd2hpY2ggaXMgd2hhdCB3ZSB3ZXJlXG4gICAgICAgICAgICAvLyBkb2luZyBiZWZvcmUuICBCZWZvcmUgYXR0ZW1wdGluZyB0byBnZXQgdGhlIGN1cnJlbnQgc3R5bGUgd2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBsb29rIGF0IFRlWCdzIGJlaGF2aW9yIGVzcGVjaWFsbHkgZm9yIFxcb3ZlciBhbmQgbWF0cmljZXMuXG4gICAgICAgICAgICBwb3N0Z2FwOiBTdHlsZS5URVhULm1ldHJpY3MucXVhZFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgICBhbGlnbjogXCJsXCIsXG4gICAgICAgICAgICBwcmVnYXA6IDAsXG4gICAgICAgICAgICBwb3N0Z2FwOiAwXG4gICAgICAgIH1dXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIHJlcyA9IG5ldyBQYXJzZU5vZGUoXCJsZWZ0cmlnaHRcIiwge1xuICAgICAgICBib2R5OiBbcmVzXSxcbiAgICAgICAgbGVmdDogXCJcXFxce1wiLFxuICAgICAgICByaWdodDogXCIuXCJcbiAgICB9LCBjb250ZXh0Lm1vZGUpO1xuICAgIHJldHVybiByZXM7XG59KTtcblxuLy8gQW4gYWxpZ25lZCBlbnZpcm9ubWVudCBpcyBsaWtlIHRoZSBhbGlnbiogZW52aXJvbm1lbnRcbi8vIGV4Y2VwdCBpdCBvcGVyYXRlcyB3aXRoaW4gbWF0aCBtb2RlLlxuLy8gTm90ZSB0aGF0IHdlIGFzc3VtZSBcXG5vbWFsbGluZXNraXBsaW1pdCB0byBiZSB6ZXJvLFxuLy8gc28gdGhhdCBcXHN0cnV0QCBpcyB0aGUgc2FtZSBhcyBcXHN0cnV0LlxuZGVmaW5lRW52aXJvbm1lbnQoXCJhbGlnbmVkXCIsIHtcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGNvbHM6IFtdXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIHZhciBlbXB0eUdyb3VwID0gbmV3IFBhcnNlTm9kZShcIm9yZGdyb3VwXCIsIFtdLCBjb250ZXh0Lm1vZGUpO1xuICAgIHZhciBudW1Db2xzID0gMDtcbiAgICByZXMudmFsdWUuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJvdy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgcm93W2ldLnZhbHVlLnVuc2hpZnQoZW1wdHlHcm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bUNvbHMgPCByb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBudW1Db2xzID0gcm93Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ29sczsgKytpKSB7XG4gICAgICAgIHZhciBhbGlnbiA9IFwiclwiO1xuICAgICAgICB2YXIgcHJlZ2FwID0gMDtcbiAgICAgICAgaWYgKGkgJSAyID09PSAxKSB7XG4gICAgICAgICAgICBhbGlnbiA9IFwibFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBwcmVnYXAgPSAyOyAvLyBvbmUgXFxxcXVhZCBiZXR3ZWVuIGNvbHVtbnNcbiAgICAgICAgfVxuICAgICAgICByZXMudmFsdWUuY29sc1tpXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgICAgIHByZWdhcDogcHJlZ2FwLFxuICAgICAgICAgICAgcG9zdGdhcDogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufSk7XG4iLCIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6MCAqL1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9TdHlsZVwiKTtcbnZhciBjamtSZWdleCA9IHJlcXVpcmUoXCIuL3VuaWNvZGVSZWdleGVzXCIpLmNqa1JlZ2V4O1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBtZXRyaWNzIHJlZ2FyZGluZyBmb250cyBhbmQgaW5kaXZpZHVhbCBzeW1ib2xzLiBUaGUgc2lnbWFcbiAqIGFuZCB4aSB2YXJpYWJsZXMsIGFzIHdlbGwgYXMgdGhlIG1ldHJpY01hcCBtYXAgY29udGFpbiBkYXRhIGV4dHJhY3RlZCBmcm9tXG4gKiBUZVgsIFRlWCBmb250IG1ldHJpY3MsIGFuZCB0aGUgVFRGIGZpbGVzLiBUaGVzZSBkYXRhIGFyZSB0aGVuIGV4cG9zZWQgdmlhIHRoZVxuICogYG1ldHJpY3NgIHZhcmlhYmxlIGFuZCB0aGUgZ2V0Q2hhcmFjdGVyTWV0cmljcyBmdW5jdGlvbi5cbiAqL1xuXG4vLyBJbiBUZVgsIHRoZXJlIGFyZSBhY3R1YWxseSB0aHJlZSBzZXRzIG9mIGRpbWVuc2lvbnMsIG9uZSBmb3IgZWFjaCBvZlxuLy8gdGV4dHN0eWxlLCBzY3JpcHRzdHlsZSwgYW5kIHNjcmlwdHNjcmlwdHN0eWxlLiAgVGhlc2UgYXJlIHByb3ZpZGVkIGluIHRoZVxuLy8gdGhlIGFycmF5cyBiZWxvdywgaW4gdGhhdCBvcmRlci5cbi8vXG4vLyBUaGUgZm9udCBtZXRyaWNzIGFyZSBzdG9yZWQgaW4gZm9udHMgY21zeTEwLCBjbXN5NywgYW5kIGNtc3k1IHJlc3BzZWN0aXZlbHkuXG4vLyBUaGlzIHdhcyBkZXRlcm1pbmVkIGJ5IHJ1bm5pbmcgdGhlIGZvbGxsb3dpbmcgc2NyaXB0OlxuLy9cbi8vICAgICBsYXRleCAtaW50ZXJhY3Rpb249bm9uc3RvcG1vZGUgXFxcbi8vICAgICAnXFxkb2N1bWVudGNsYXNze2FydGljbGV9XFx1c2VwYWNrYWdle2Ftc21hdGh9XFxiZWdpbntkb2N1bWVudH0nIFxcXG4vLyAgICAgJyRhJCBcXGV4cGFuZGFmdGVyXFxzaG93XFx0aGVcXHRleHRmb250MicgXFxcbi8vICAgICAnXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFxzY3JpcHRmb250MicgXFxcbi8vICAgICAnXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFxzY3JpcHRzY3JpcHRmb250MicgXFxcbi8vICAgICAnXFxzdG9wJ1xuLy9cbi8vIFRoZSBtZXRyaWNzIHRoZW1zZWx2ZXMgd2VyZSByZXRyZWl2ZWQgdXNpbmcgdGhlIGZvbGxvd2luZyBjb21tYW5kczpcbi8vXG4vLyAgICAgdGZ0b3BsIGNtc3kxMFxuLy8gICAgIHRmdG9wbCBjbXN5N1xuLy8gICAgIHRmdG9wbCBjbXN5NVxuLy9cbi8vIFRoZSBvdXRwdXQgb2YgZWFjaCBvZiB0aGVzZSBjb21tYW5kcyBpcyBxdWl0ZSBsZW5ndGh5LiAgVGhlIG9ubHkgcGFydCB3ZVxuLy8gY2FyZSBhYm91dCBpcyB0aGUgRk9OVERJTUVOIHNlY3Rpb24uIEVhY2ggdmFsdWUgaXMgbWVhc3VyZWQgaW4gRU1zLlxudmFyIHNpZ21hcyA9IHtcbiAgICBzbGFudDogWzAuMjUwLCAwLjI1MCwgMC4yNTBdLCAgICAgICAvLyBzaWdtYTFcbiAgICBzcGFjZTogWzAuMDAwLCAwLjAwMCwgMC4wMDBdLCAgICAgICAvLyBzaWdtYTJcbiAgICBzdHJldGNoOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sICAgICAvLyBzaWdtYTNcbiAgICBzaHJpbms6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSwgICAgICAvLyBzaWdtYTRcbiAgICB4SGVpZ2h0OiBbMC40MzEsIDAuNDMxLCAwLjQzMV0sICAgICAvLyBzaWdtYTVcbiAgICBxdWFkOiBbMS4wMDAsIDEuMTcxLCAxLjQ3Ml0sICAgICAgICAvLyBzaWdtYTZcbiAgICBleHRyYVNwYWNlOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sICAvLyBzaWdtYTdcbiAgICBudW0xOiBbMC42NzcsIDAuNzMyLCAwLjkyNV0sICAgICAgICAvLyBzaWdtYThcbiAgICBudW0yOiBbMC4zOTQsIDAuMzg0LCAwLjM4N10sICAgICAgICAvLyBzaWdtYTlcbiAgICBudW0zOiBbMC40NDQsIDAuNDcxLCAwLjUwNF0sICAgICAgICAvLyBzaWdtYTEwXG4gICAgZGVub20xOiBbMC42ODYsIDAuNzUyLCAxLjAyNV0sICAgICAgLy8gc2lnbWExMVxuICAgIGRlbm9tMjogWzAuMzQ1LCAwLjM0NCwgMC41MzJdLCAgICAgIC8vIHNpZ21hMTJcbiAgICBzdXAxOiBbMC40MTMsIDAuNTAzLCAwLjUwNF0sICAgICAgICAvLyBzaWdtYTEzXG4gICAgc3VwMjogWzAuMzYzLCAwLjQzMSwgMC40MDRdLCAgICAgICAgLy8gc2lnbWExNFxuICAgIHN1cDM6IFswLjI4OSwgMC4yODYsIDAuMjk0XSwgICAgICAgIC8vIHNpZ21hMTVcbiAgICBzdWIxOiBbMC4xNTAsIDAuMTQzLCAwLjIwMF0sICAgICAgICAvLyBzaWdtYTE2XG4gICAgc3ViMjogWzAuMjQ3LCAwLjI4NiwgMC40MDBdLCAgICAgICAgLy8gc2lnbWExN1xuICAgIHN1cERyb3A6IFswLjM4NiwgMC4zNTMsIDAuNDk0XSwgICAgIC8vIHNpZ21hMThcbiAgICBzdWJEcm9wOiBbMC4wNTAsIDAuMDcxLCAwLjEwMF0sICAgICAvLyBzaWdtYTE5XG4gICAgZGVsaW0xOiBbMi4zOTAsIDEuNzAwLCAxLjk4MF0sICAgICAgLy8gc2lnbWEyMFxuICAgIGRlbGltMjogWzEuMDEwLCAxLjE1NywgMS40MjBdLCAgICAgIC8vIHNpZ21hMjFcbiAgICBheGlzSGVpZ2h0OiBbMC4yNTAsIDAuMjUwLCAwLjI1MF0gIC8vIHNpZ21hMjJcbn07XG5cbi8vIFRoZXNlIGZvbnQgbWV0cmljcyBhcmUgZXh0cmFjdGVkIGZyb20gVGVYIGJ5IHVzaW5nXG4vLyBcXGZvbnRcXGE9Y21leDEwXG4vLyBcXHNob3d0aGVcXGZvbnRkaW1lblhcXGFcbi8vIHdoZXJlIFggaXMgdGhlIGNvcnJlc3BvbmRpbmcgdmFyaWFibGUgbnVtYmVyLiBUaGVzZSBjb3JyZXNwb25kIHRvIHRoZSBmb250XG4vLyBwYXJhbWV0ZXJzIG9mIHRoZSBleHRlbnNpb24gZm9udHMgKGZhbWlseSAzKS4gU2VlIHRoZSBUZVhib29rLCBwYWdlIDQ0MS5cbnZhciB4aTEgPSAwO1xudmFyIHhpMiA9IDA7XG52YXIgeGkzID0gMDtcbnZhciB4aTQgPSAwO1xudmFyIHhpNSA9IDAuNDMxO1xudmFyIHhpNiA9IDE7XG52YXIgeGk3ID0gMDtcbnZhciB4aTggPSAwLjA0O1xudmFyIHhpOSA9IDAuMTExO1xudmFyIHhpMTAgPSAwLjE2NjtcbnZhciB4aTExID0gMC4yO1xudmFyIHhpMTIgPSAwLjY7XG52YXIgeGkxMyA9IDAuMTtcblxuLy8gVGhpcyB2YWx1ZSBkZXRlcm1pbmVzIGhvdyBsYXJnZSBhIHB0IGlzLCBmb3IgbWV0cmljcyB3aGljaCBhcmUgZGVmaW5lZCBpblxuLy8gdGVybXMgb2YgcHRzLlxuLy8gVGhpcyB2YWx1ZSBpcyBhbHNvIHVzZWQgaW4ga2F0ZXgubGVzczsgaWYgeW91IGNoYW5nZSBpdCBtYWtlIHN1cmUgdGhlIHZhbHVlc1xuLy8gbWF0Y2guXG52YXIgcHRQZXJFbSA9IDEwLjA7XG5cbi8vIFRoZSBzcGFjZSBiZXR3ZWVuIGFkamFjZW50IGB8YCBjb2x1bW5zIGluIGFuIGFycmF5IGRlZmluaXRpb24uIEZyb21cbi8vIGBcXHNob3d0aGVcXGRvdWJsZXJ1bGVzZXBgIGluIExhVGVYLlxudmFyIGRvdWJsZVJ1bGVTZXAgPSAyLjAgLyBwdFBlckVtO1xuXG4vKipcbiAqIFRoaXMgaXMganVzdCBhIG1hcHBpbmcgZnJvbSBjb21tb24gbmFtZXMgdG8gcmVhbCBtZXRyaWNzXG4gKi9cbnZhciBtZXRyaWNzID0ge1xuICAgIGRlZmF1bHRSdWxlVGhpY2tuZXNzOiB4aTgsXG4gICAgYmlnT3BTcGFjaW5nMTogeGk5LFxuICAgIGJpZ09wU3BhY2luZzI6IHhpMTAsXG4gICAgYmlnT3BTcGFjaW5nMzogeGkxMSxcbiAgICBiaWdPcFNwYWNpbmc0OiB4aTEyLFxuICAgIGJpZ09wU3BhY2luZzU6IHhpMTMsXG4gICAgcHRQZXJFbTogcHRQZXJFbSxcbiAgICBkb3VibGVSdWxlU2VwOiBkb3VibGVSdWxlU2VwXG59O1xuXG4vLyBUaGlzIG1hcCBjb250YWlucyBhIG1hcHBpbmcgZnJvbSBmb250IG5hbWUgYW5kIGNoYXJhY3RlciBjb2RlIHRvIGNoYXJhY3RlclxuLy8gbWV0cmljcywgaW5jbHVkaW5nIGhlaWdodCwgZGVwdGgsIGl0YWxpYyBjb3JyZWN0aW9uLCBhbmQgc2tldyAoa2VybiBmcm9tIHRoZVxuLy8gY2hhcmFjdGVyIHRvIHRoZSBjb3JyZXNwb25kaW5nIFxcc2tld2NoYXIpXG4vLyBUaGlzIG1hcCBpcyBnZW5lcmF0ZWQgdmlhIGBtYWtlIG1ldHJpY3NgLiBJdCBzaG91bGQgbm90IGJlIGNoYW5nZWQgbWFudWFsbHkuXG52YXIgbWV0cmljTWFwID0gcmVxdWlyZShcIi4vZm9udE1ldHJpY3NEYXRhXCIpO1xuXG4vLyBUaGVzZSBhcmUgdmVyeSByb3VnaCBhcHByb3hpbWF0aW9ucy4gIFdlIGRlZmF1bHQgdG8gVGltZXMgTmV3IFJvbWFuIHdoaWNoXG4vLyBzaG91bGQgaGF2ZSBMYXRpbi0xIGFuZCBDeXJpbGxpYyBjaGFyYWN0ZXJzLCBidXQgbWF5IG5vdCBkZXBlbmRpbmcgb24gdGhlXG4vLyBvcGVyYXRpbmcgc3lzdGVtLiAgVGhlIG1ldHJpY3MgZG8gbm90IGFjY291bnQgZm9yIGV4dHJhIGhlaWdodCBmcm9tIHRoZVxuLy8gYWNjZW50cy4gIEluIHRoZSBjYXNlIG9mIEN5cmlsbGljIGNoYXJhY3RlcnMgd2hpY2ggaGF2ZSBib3RoIGFzY2VuZGVycyBhbmRcbi8vIGRlc2NlbmRlcnMgd2UgcHJlZmVyIGFwcHJveGltYXRpb25zIHdpdGggYXNjZW5kZXJzLCBwcmltYXJpbHkgdG8gcHJldmVudFxuLy8gdGhlIGZyYWN0aW9uIGJhciBvciByb290IGxpbmUgZnJvbSBpbnRlcnNlY3RpbmcgdGhlIGdseXBoLlxuLy8gVE9ETyhrZXZpbmIpIGFsbG93IHVuaW9uIG9mIG11bHRpcGxlIGdseXBoIG1ldHJpY3MgZm9yIGJldHRlciBhY2N1cmFjeS5cbnZhciBleHRyYUNoYXJhY3Rlck1hcCA9IHtcbiAgICAvLyBMYXRpbi0xXG4gICAgJ8OAJzogJ0EnLFxuICAgICfDgSc6ICdBJyxcbiAgICAnw4InOiAnQScsXG4gICAgJ8ODJzogJ0EnLFxuICAgICfDhCc6ICdBJyxcbiAgICAnw4UnOiAnQScsXG4gICAgJ8OGJzogJ0EnLFxuICAgICfDhyc6ICdDJyxcbiAgICAnw4gnOiAnRScsXG4gICAgJ8OJJzogJ0UnLFxuICAgICfDiic6ICdFJyxcbiAgICAnw4snOiAnRScsXG4gICAgJ8OMJzogJ0knLFxuICAgICfDjSc6ICdJJyxcbiAgICAnw44nOiAnSScsXG4gICAgJ8OPJzogJ0knLFxuICAgICfDkCc6ICdEJyxcbiAgICAnw5EnOiAnTicsXG4gICAgJ8OSJzogJ08nLFxuICAgICfDkyc6ICdPJyxcbiAgICAnw5QnOiAnTycsXG4gICAgJ8OVJzogJ08nLFxuICAgICfDlic6ICdPJyxcbiAgICAnw5gnOiAnTycsXG4gICAgJ8OZJzogJ1UnLFxuICAgICfDmic6ICdVJyxcbiAgICAnw5snOiAnVScsXG4gICAgJ8OcJzogJ1UnLFxuICAgICfDnSc6ICdZJyxcbiAgICAnw54nOiAnbycsXG4gICAgJ8OfJzogJ0InLFxuICAgICfDoCc6ICdhJyxcbiAgICAnw6EnOiAnYScsXG4gICAgJ8OiJzogJ2EnLFxuICAgICfDoyc6ICdhJyxcbiAgICAnw6QnOiAnYScsXG4gICAgJ8OlJzogJ2EnLFxuICAgICfDpic6ICdhJyxcbiAgICAnw6cnOiAnYycsXG4gICAgJ8OoJzogJ2UnLFxuICAgICfDqSc6ICdlJyxcbiAgICAnw6onOiAnZScsXG4gICAgJ8OrJzogJ2UnLFxuICAgICfDrCc6ICdpJyxcbiAgICAnw60nOiAnaScsXG4gICAgJ8OuJzogJ2knLFxuICAgICfDryc6ICdpJyxcbiAgICAnw7AnOiAnZCcsXG4gICAgJ8OxJzogJ24nLFxuICAgICfDsic6ICdvJyxcbiAgICAnw7MnOiAnbycsXG4gICAgJ8O0JzogJ28nLFxuICAgICfDtSc6ICdvJyxcbiAgICAnw7YnOiAnbycsXG4gICAgJ8O4JzogJ28nLFxuICAgICfDuSc6ICd1JyxcbiAgICAnw7onOiAndScsXG4gICAgJ8O7JzogJ3UnLFxuICAgICfDvCc6ICd1JyxcbiAgICAnw70nOiAneScsXG4gICAgJ8O+JzogJ28nLFxuICAgICfDvyc6ICd5JyxcblxuICAgIC8vIEN5cmlsbGljXG4gICAgJ9CQJzogJ0EnLFxuICAgICfQkSc6ICdCJyxcbiAgICAn0JInOiAnQicsXG4gICAgJ9CTJzogJ0YnLFxuICAgICfQlCc6ICdBJyxcbiAgICAn0JUnOiAnRScsXG4gICAgJ9CWJzogJ0snLFxuICAgICfQlyc6ICczJyxcbiAgICAn0JgnOiAnTicsXG4gICAgJ9CZJzogJ04nLFxuICAgICfQmic6ICdLJyxcbiAgICAn0JsnOiAnTicsXG4gICAgJ9CcJzogJ00nLFxuICAgICfQnSc6ICdIJyxcbiAgICAn0J4nOiAnTycsXG4gICAgJ9CfJzogJ04nLFxuICAgICfQoCc6ICdQJyxcbiAgICAn0KEnOiAnQycsXG4gICAgJ9CiJzogJ1QnLFxuICAgICfQoyc6ICd5JyxcbiAgICAn0KQnOiAnTycsXG4gICAgJ9ClJzogJ1gnLFxuICAgICfQpic6ICdVJyxcbiAgICAn0KcnOiAnaCcsXG4gICAgJ9CoJzogJ1cnLFxuICAgICfQqSc6ICdXJyxcbiAgICAn0KonOiAnQicsXG4gICAgJ9CrJzogJ1gnLFxuICAgICfQrCc6ICdCJyxcbiAgICAn0K0nOiAnMycsXG4gICAgJ9CuJzogJ1gnLFxuICAgICfQryc6ICdSJyxcbiAgICAn0LAnOiAnYScsXG4gICAgJ9CxJzogJ2InLFxuICAgICfQsic6ICdhJyxcbiAgICAn0LMnOiAncicsXG4gICAgJ9C0JzogJ3knLFxuICAgICfQtSc6ICdlJyxcbiAgICAn0LYnOiAnbScsXG4gICAgJ9C3JzogJ2UnLFxuICAgICfQuCc6ICduJyxcbiAgICAn0LknOiAnbicsXG4gICAgJ9C6JzogJ24nLFxuICAgICfQuyc6ICduJyxcbiAgICAn0LwnOiAnbScsXG4gICAgJ9C9JzogJ24nLFxuICAgICfQvic6ICdvJyxcbiAgICAn0L8nOiAnbicsXG4gICAgJ9GAJzogJ3AnLFxuICAgICfRgSc6ICdjJyxcbiAgICAn0YInOiAnbycsXG4gICAgJ9GDJzogJ3knLFxuICAgICfRhCc6ICdiJyxcbiAgICAn0YUnOiAneCcsXG4gICAgJ9GGJzogJ24nLFxuICAgICfRhyc6ICduJyxcbiAgICAn0YgnOiAndycsXG4gICAgJ9GJJzogJ3cnLFxuICAgICfRiic6ICdhJyxcbiAgICAn0YsnOiAnbScsXG4gICAgJ9GMJzogJ2EnLFxuICAgICfRjSc6ICdlJyxcbiAgICAn0Y4nOiAnbScsXG4gICAgJ9GPJzogJ3InXG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgbG9va2luZyB1cCBpbmZvcm1hdGlvbiBpbiB0aGVcbiAqIG1ldHJpY01hcCB0YWJsZS4gSXQgdGFrZXMgYSBjaGFyYWN0ZXIgYXMgYSBzdHJpbmcsIGFuZCBhIHN0eWxlLlxuICpcbiAqIE5vdGU6IHRoZSBgd2lkdGhgIHByb3BlcnR5IG1heSBiZSB1bmRlZmluZWQgaWYgZm9udE1ldHJpY3NEYXRhLmpzIHdhc24ndFxuICogYnVpbHQgdXNpbmcgYE1ha2UgZXh0ZW5kZWRfbWV0cmljc2AuXG4gKi9cbnZhciBnZXRDaGFyYWN0ZXJNZXRyaWNzID0gZnVuY3Rpb24oY2hhcmFjdGVyLCBzdHlsZSkge1xuICAgIHZhciBjaCA9IGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChjaGFyYWN0ZXJbMF0gaW4gZXh0cmFDaGFyYWN0ZXJNYXApIHtcbiAgICAgICAgY2ggPSBleHRyYUNoYXJhY3Rlck1hcFtjaGFyYWN0ZXJbMF1dLmNoYXJDb2RlQXQoMCk7XG4gICAgfSBlbHNlIGlmIChjamtSZWdleC50ZXN0KGNoYXJhY3RlclswXSkpIHtcbiAgICAgICAgY2ggPSAnTScuY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgdmFyIG1ldHJpY3MgPSBtZXRyaWNNYXBbc3R5bGVdW2NoXTtcbiAgICBpZiAobWV0cmljcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVwdGg6IG1ldHJpY3NbMF0sXG4gICAgICAgICAgICBoZWlnaHQ6IG1ldHJpY3NbMV0sXG4gICAgICAgICAgICBpdGFsaWM6IG1ldHJpY3NbMl0sXG4gICAgICAgICAgICBza2V3OiBtZXRyaWNzWzNdLFxuICAgICAgICAgICAgd2lkdGg6IG1ldHJpY3NbNF1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtZXRyaWNzOiBtZXRyaWNzLFxuICAgIHNpZ21hczogc2lnbWFzLFxuICAgIGdldENoYXJhY3Rlck1ldHJpY3M6IGdldENoYXJhY3Rlck1ldHJpY3Ncbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBcIkFNUy1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI2NVwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNjZcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjY3XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI2OFwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNjlcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI3MVwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzJcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjczXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI3NFwiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzVcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjc2XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI3N1wiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzhcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjc5XCI6IFswLjE2NjY3LCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4MFwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiODFcIjogWzAuMTY2NjcsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjgyXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4M1wiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiODRcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjg1XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NlwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiODdcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjg4XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4OVwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiOTBcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiMTY1XCI6IFswLCAwLjY3NSwgMC4wMjUsIDBdLFxuICAgICAgICBcIjE3NFwiOiBbMC4xNTU1OSwgMC42OTIyNCwgMCwgMF0sXG4gICAgICAgIFwiMjQwXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCIyOTVcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjcxMFwiOiBbMCwgMC44MjUsIDAsIDBdLFxuICAgICAgICBcIjczMlwiOiBbMCwgMC45LCAwLCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuOSwgMCwgMF0sXG4gICAgICAgIFwiOTg5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCIxMDA4XCI6IFswLCAwLjQzMDU2LCAwLjA0MDI4LCAwXSxcbiAgICAgICAgXCI4MjQ1XCI6IFswLCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4NDYzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NDg3XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NDk4XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTAyXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTAzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTA0XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTEzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTkyXCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMF0sXG4gICAgICAgIFwiODU5NFwiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDBdLFxuICAgICAgICBcIjg2MDJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjAzXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODYwNlwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYwOFwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYxMFwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYxMVwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYxOVwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODYyMFwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODYyMVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDBdLFxuICAgICAgICBcIjg2MjJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjI0XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjI1XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjMwXCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NjMxXCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NjM0XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwXSxcbiAgICAgICAgXCI4NjM1XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwXSxcbiAgICAgICAgXCI4NjM4XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjM5XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQyXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQzXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ0XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ2XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ3XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ4XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ5XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjUwXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjUxXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwXSxcbiAgICAgICAgXCI4NjUyXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwXSxcbiAgICAgICAgXCI4NjUzXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODY1NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg2NTVcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjY2XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4NjY3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4NjY5XCI6IFstMC4xMzMxMywgMC4zNzc4OCwgMCwgMF0sXG4gICAgICAgIFwiODY3MlwiOiBbLTAuMDY0LCAwLjQzNywgMCwgMF0sXG4gICAgICAgIFwiODY3NFwiOiBbLTAuMDY0LCAwLjQzNywgMCwgMF0sXG4gICAgICAgIFwiODcwNVwiOiBbMCwgMC44MjUsIDAsIDBdLFxuICAgICAgICBcIjg3MDhcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjg3MDlcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDBdLFxuICAgICAgICBcIjg3MTdcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjg3MjJcIjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwXSxcbiAgICAgICAgXCI4NzI0XCI6IFswLjA4MTk4LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzI2XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4NzMzXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM3XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM4XCI6IFswLjAzNTE3LCAwLjUyMjM5LCAwLCAwXSxcbiAgICAgICAgXCI4NzM5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4NzQwXCI6IFswLjI1MTQyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NzQxXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4NzQyXCI6IFswLjI1MTQyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NzU2XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzU3XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzY0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODc2NVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDBdLFxuICAgICAgICBcIjg3NjlcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NzcwXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMF0sXG4gICAgICAgIFwiODc3NFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMF0sXG4gICAgICAgIFwiODc3NlwiOiBbLTAuMDE2ODgsIDAuNDgzMTIsIDAsIDBdLFxuICAgICAgICBcIjg3NzhcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDBdLFxuICAgICAgICBcIjg3ODJcIjogWzAuMDYwNjIsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg3ODNcIjogWzAuMDYwNjIsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg3ODVcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg3ODZcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg3ODdcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg3OTBcIjogWzAsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjg3OTFcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg3OTZcIjogWzAuMDgxOTgsIDAuOTE2NjcsIDAsIDBdLFxuICAgICAgICBcIjg4MDZcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjg4MDdcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjg4MDhcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjg4MDlcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjg4MTJcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjg4MTRcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4MTVcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4MTZcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4MTdcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4MThcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MTlcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MjJcIjogWzAuMTgwOCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjg4MjNcIjogWzAuMTgwOCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjg4MjhcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjg4MjlcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjg4MzBcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MzFcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MzJcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4MzNcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4NDBcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4NDFcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4NDJcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdLFxuICAgICAgICBcIjg4NDNcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdLFxuICAgICAgICBcIjg4NDdcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg4NDhcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg4NThcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg4NTlcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg4NjFcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg4NjJcIjogWzAsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODYzXCI6IFswLCAwLjY3NSwgMCwgMF0sXG4gICAgICAgIFwiODg2NFwiOiBbMCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjg4NjVcIjogWzAsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODcyXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODczXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODc0XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODc2XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODc3XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODc4XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODc5XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODgyXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4ODgzXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4ODg0XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODg1XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODg4XCI6IFswLCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4ODkwXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODkxXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODkyXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTAxXCI6IFswLCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4OTAzXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTA1XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTA2XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTA3XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTA4XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTA5XCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMF0sXG4gICAgICAgIFwiODkxMFwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxMVwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxMlwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxM1wiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxNFwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxNVwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxNlwiOiBbMCwgMC42OTIyNCwgMCwgMF0sXG4gICAgICAgIFwiODkxOFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg5MTlcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwXSxcbiAgICAgICAgXCI4OTIwXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4OTIxXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4OTIyXCI6IFswLjM4NTY5LCAwLjg4NTY5LCAwLCAwXSxcbiAgICAgICAgXCI4OTIzXCI6IFswLjM4NTY5LCAwLjg4NTY5LCAwLCAwXSxcbiAgICAgICAgXCI4OTI2XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTI3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTI4XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTI5XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTM0XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM1XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM2XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM3XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM4XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwXSxcbiAgICAgICAgXCI4OTM5XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwXSxcbiAgICAgICAgXCI4OTQwXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTQxXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTk0XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTk1XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDE2XCI6IFswLjE1NTU5LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDg0XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDg4XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDkyXCI6IFswLCAwLjM3Nzg4LCAwLCAwXSxcbiAgICAgICAgXCI5NDk2XCI6IFswLCAwLjM3Nzg4LCAwLCAwXSxcbiAgICAgICAgXCI5NTg1XCI6IFswLjE5NDQ0LCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI5NTg2XCI6IFswLjE5NDQ0LCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI5NjMyXCI6IFswLCAwLjY3NSwgMCwgMF0sXG4gICAgICAgIFwiOTYzM1wiOiBbMCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjk2NTBcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NTFcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NTRcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NjBcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NjFcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NjRcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NzRcIjogWzAuMTExMTEsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjk3MzNcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjEwMDAzXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCIxMDAxNlwiOiBbMCwgMC42OTIyNCwgMCwgMF0sXG4gICAgICAgIFwiMTA3MzFcIjogWzAuMTExMTEsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjEwODQ2XCI6IFswLjE5NDQ0LCAwLjc1NTgzLCAwLCAwXSxcbiAgICAgICAgXCIxMDg3N1wiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMF0sXG4gICAgICAgIFwiMTA4NzhcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjEwODg1XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwXSxcbiAgICAgICAgXCIxMDg4NlwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMF0sXG4gICAgICAgIFwiMTA4ODdcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdLFxuICAgICAgICBcIjEwODg4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCIxMDg4OVwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiMTA4OTBcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjEwODkxXCI6IFswLjQ4MjU2LCAwLjk4MjU2LCAwLCAwXSxcbiAgICAgICAgXCIxMDg5MlwiOiBbMC40ODI1NiwgMC45ODI1NiwgMCwgMF0sXG4gICAgICAgIFwiMTA5MDFcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjEwOTAyXCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCIxMDkzM1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiMTA5MzRcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjEwOTM1XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCIxMDkzNlwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiMTA5MzdcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjEwOTM4XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCIxMDk0OVwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMF0sXG4gICAgICAgIFwiMTA5NTBcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjEwOTU1XCI6IFswLjI4NDgxLCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCIxMDk1NlwiOiBbMC4yODQ4MSwgMC43OTM4MywgMCwgMF0sXG4gICAgICAgIFwiNTczNTBcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDBdLFxuICAgICAgICBcIjU3MzUxXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI1NzM1MlwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMF0sXG4gICAgICAgIFwiNTczNTNcIjogWzAsIDAuNDMwNTYsIDAuMDQwMjgsIDBdLFxuICAgICAgICBcIjU3MzU2XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCI1NzM1N1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiNTczNThcIjogWzAuNDE5NTEsIDAuOTE5NTEsIDAsIDBdLFxuICAgICAgICBcIjU3MzU5XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI1NzM2MFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMF0sXG4gICAgICAgIFwiNTczNjFcIjogWzAuNDE5NTEsIDAuOTE5NTEsIDAsIDBdLFxuICAgICAgICBcIjU3MzY2XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCI1NzM2N1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiNTczNjhcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjU3MzY5XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCI1NzM3MFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMF0sXG4gICAgICAgIFwiNTczNzFcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdXG4gICAgfSxcbiAgICBcIkNhbGlncmFwaGljLVJlZ3VsYXJcIjoge1xuICAgICAgICBcIjQ4XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI0OVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTBcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI1MlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1NVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI2NVwiOiBbMCwgMC42ODMzMywgMCwgMC4xOTQ0NV0sXG4gICAgICAgIFwiNjZcIjogWzAsIDAuNjgzMzMsIDAuMDMwNDEsIDAuMTM4ODldLFxuICAgICAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLjA1ODM0LCAwLjEzODg5XSxcbiAgICAgICAgXCI2OFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiNjlcIjogWzAsIDAuNjgzMzMsIDAuMDg5NDQsIDAuMTExMTFdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjY4MzMzLCAwLjA5OTMxLCAwLjExMTExXSxcbiAgICAgICAgXCI3MVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4wNTkzLCAwLjExMTExXSxcbiAgICAgICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMC4wMDk2NSwgMC4xMTExMV0sXG4gICAgICAgIFwiNzNcIjogWzAsIDAuNjgzMzMsIDAuMDczODIsIDBdLFxuICAgICAgICBcIjc0XCI6IFswLjA5NzIyLCAwLjY4MzMzLCAwLjE4NDcyLCAwLjE2NjY3XSxcbiAgICAgICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMC4wMTQ0NSwgMC4wNTU1Nl0sXG4gICAgICAgIFwiNzZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODldLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjY4MzMzLCAwLCAwLjEzODg5XSxcbiAgICAgICAgXCI3OFwiOiBbMCwgMC42ODMzMywgMC4xNDczNiwgMC4wODMzNF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMTExMTFdLFxuICAgICAgICBcIjgwXCI6IFswLCAwLjY4MzMzLCAwLjA4MjIyLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4MVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMCwgMC4xMTExMV0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjgzXCI6IFswLCAwLjY4MzMzLCAwLjA3NSwgMC4xMzg4OV0sXG4gICAgICAgIFwiODRcIjogWzAsIDAuNjgzMzMsIDAuMjU0MTcsIDBdLFxuICAgICAgICBcIjg1XCI6IFswLCAwLjY4MzMzLCAwLjA5OTMxLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NlwiOiBbMCwgMC42ODMzMywgMC4wODIyMiwgMF0sXG4gICAgICAgIFwiODdcIjogWzAsIDAuNjgzMzMsIDAuMDgyMjIsIDAuMDgzMzRdLFxuICAgICAgICBcIjg4XCI6IFswLCAwLjY4MzMzLCAwLjE0NjQzLCAwLjEzODg5XSxcbiAgICAgICAgXCI4OVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4wODIyMiwgMC4wODMzNF0sXG4gICAgICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAuMDc5NDQsIDAuMTM4ODldXG4gICAgfSxcbiAgICBcIkZyYWt0dXItUmVndWxhclwiOiB7XG4gICAgICAgIFwiMzNcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjM0XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIzOFwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiMzlcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjQwXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwXSxcbiAgICAgICAgXCI0MVwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMF0sXG4gICAgICAgIFwiNDJcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjQzXCI6IFswLjA4MzE5LCAwLjU4MjgzLCAwLCAwXSxcbiAgICAgICAgXCI0NFwiOiBbMCwgMC4xMDgwMywgMCwgMF0sXG4gICAgICAgIFwiNDVcIjogWzAuMDgzMTksIDAuNTgyODMsIDAsIDBdLFxuICAgICAgICBcIjQ2XCI6IFswLCAwLjEwODAzLCAwLCAwXSxcbiAgICAgICAgXCI0N1wiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMF0sXG4gICAgICAgIFwiNDhcIjogWzAsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjQ5XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1MFwiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiNTFcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjUyXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1M1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiNTRcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjU1XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1NlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTdcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjU4XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1OVwiOiBbMC4xMjYwNCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiNjFcIjogWy0wLjEzMDk5LCAwLjM2ODY2LCAwLCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMC4xMjYwNCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLjA2MzAyLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAuMTI2MDQsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjAzNzgxLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLjEyNjA0LCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMF0sXG4gICAgICAgIFwiOTNcIjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDBdLFxuICAgICAgICBcIjk0XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjEwNFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiMTA4XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIxMDlcIjogWzAsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjExMFwiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiMTExXCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMTJcIjogWzAuMTg5MDYsIDAuNTIzOTYsIDAsIDBdLFxuICAgICAgICBcIjExM1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiMTE0XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMTVcIjogWzAsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjExNlwiOiBbMCwgMC42MjExOSwgMCwgMF0sXG4gICAgICAgIFwiMTE3XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMThcIjogWzAsIDAuNTIzOTYsIDAsIDBdLFxuICAgICAgICBcIjExOVwiOiBbMCwgMC41MjM5NiwgMCwgMF0sXG4gICAgICAgIFwiMTIwXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMjFcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjEyMlwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiODIxNlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODIxN1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTgxMTJcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjU4MTEzXCI6IFswLCAwLjYyMTE5LCAwLCAwXSxcbiAgICAgICAgXCI1ODExNFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTgxMTVcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjU4MTE2XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1ODExN1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTgxMThcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjU4MTE5XCI6IFswLCAwLjQ3NTM0LCAwLCAwXVxuICAgIH0sXG4gICAgXCJNYWluLUJvbGRcIjoge1xuICAgICAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0M1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMF0sXG4gICAgICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0NlwiOiBbMCwgMC4xNTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1MlwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1NVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1OFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjYwXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI2MVwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjYyXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjY1XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI2NlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNjdcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjY4XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI2OVwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzBcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjcxXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI3MlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzNcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjc0XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI3NVwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzZcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI3OFwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjgwXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjgzXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI4NFwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiODVcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjg2XCI6IFswLCAwLjY4NjExLCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCI4N1wiOiBbMCwgMC42ODYxMSwgMC4wMTU5NywgMF0sXG4gICAgICAgIFwiODhcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjg5XCI6IFswLCAwLjY4NjExLCAwLjAyODc1LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjkyXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjMxLCAwLjEzNDQ0LCAwLjAzMTk0LCAwXSxcbiAgICAgICAgXCI5NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5OVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4xMDkwMywgMF0sXG4gICAgICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwNVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDE1OTcsIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTI0XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEyNlwiOiBbMC4zNSwgMC4zNDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxNzJcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjE3NVwiOiBbMCwgMC41OTYxMSwgMCwgMF0sXG4gICAgICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxNzdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjE4MFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMjE1XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCIyNDdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcxMVwiOiBbMCwgMC42MzE5NCwgMCwgMF0sXG4gICAgICAgIFwiNzEzXCI6IFswLCAwLjU5NjExLCAwLCAwXSxcbiAgICAgICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MjlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzMyXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NjhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3MlwiOiBbMCwgMC41OTYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzc0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzc4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc4MFwiOiBbMCwgMC42MzE5NCwgMCwgMF0sXG4gICAgICAgIFwiODI0XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MTVcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkxNlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTIwXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MjNcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkyNlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTI4XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MzFcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkzM1wiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTM0XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MzZcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkzN1wiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiODIxMVwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiODIxMlwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyNFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODI0MlwiOiBbMCwgMC41NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiODQwN1wiOiBbMCwgMC43MjQ0NCwgMC4xNTQ4NiwgMF0sXG4gICAgICAgIFwiODQ2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ3MlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODUwMVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODU5MlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg1OTNcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg1OTRcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NTk1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTk2XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMF0sXG4gICAgICAgIFwiODU5N1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiODU5OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODU5OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODYwMFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODYwMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODYzNlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg2MzdcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NjQwXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMF0sXG4gICAgICAgIFwiODY0MVwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg2NTZcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NjU3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjU4XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMF0sXG4gICAgICAgIFwiODY1OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODY2MFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg2NjFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MDRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MDZcIjogWzAsIDAuNjk0NDQsIDAuMDYzODksIDBdLFxuICAgICAgICBcIjg3MDdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MDlcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MTFcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjg3MTJcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3MTVcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3MjJcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjNcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjZcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjdcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwXSxcbiAgICAgICAgXCI4NzI4XCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMF0sXG4gICAgICAgIFwiODcyOVwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDBdLFxuICAgICAgICBcIjg3MzBcIjogWzAuMTgsIDAuODIsIDAsIDBdLFxuICAgICAgICBcIjg3MzNcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MzRcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MzZcIjogWzAsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjg3MzlcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3NDFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3NDNcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDRcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDVcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDZcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDdcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMTI3NzgsIDBdLFxuICAgICAgICBcIjg3NjRcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NzY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzcxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4Nzc2XCI6IFswLjAyNDQ0LCAwLjUyNDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzgxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4ODAxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4ODA0XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODA1XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODEwXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODExXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODI2XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODI3XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODM0XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODM1XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODM4XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODM5XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ5XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUwXCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUxXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUyXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUzXCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU0XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU1XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU2XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU3XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4OTAwXCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMF0sXG4gICAgICAgIFwiODkwMVwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDBdLFxuICAgICAgICBcIjg5MDJcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTk0XCI6IFstMC4xMzg4OSwgMC4zNjExMSwgMCwgMF0sXG4gICAgICAgIFwiODk5NVwiOiBbLTAuMTM4ODksIDAuMzYxMTEsIDAsIDBdLFxuICAgICAgICBcIjk2NTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk2NTdcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwXSxcbiAgICAgICAgXCI5NjYxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjY3XCI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMF0sXG4gICAgICAgIFwiOTcxMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyNFwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyNVwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyNlwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyN1wiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgzN1wiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiOTgzOFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgzOVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyMTZcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEwMjE3XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMDgxNVwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiMTA5MjdcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDBdLFxuICAgICAgICBcIjEwOTI4XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXVxuICAgIH0sXG4gICAgXCJNYWluLUl0YWxpY1wiOiB7XG4gICAgICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDBdLFxuICAgICAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLjA2OTYxLCAwXSxcbiAgICAgICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNjYxNiwgMF0sXG4gICAgICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAuMTM2MzksIDBdLFxuICAgICAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwXSxcbiAgICAgICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMC4xMjQxNywgMF0sXG4gICAgICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAuMTYxOTQsIDBdLFxuICAgICAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLjAzNjk0LCAwXSxcbiAgICAgICAgXCI0MlwiOiBbMCwgMC43NSwgMC4xNDkxNywgMF0sXG4gICAgICAgIFwiNDNcIjogWzAuMDU2NjcsIDAuNTYxNjcsIDAuMDM2OTQsIDBdLFxuICAgICAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjEwNTU2LCAwLCAwXSxcbiAgICAgICAgXCI0NVwiOiBbMCwgMC40MzA1NiwgMC4wMjgyNiwgMF0sXG4gICAgICAgIFwiNDZcIjogWzAsIDAuMTA1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLjE2MTk0LCAwXSxcbiAgICAgICAgXCI0OFwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNDlcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDBdLFxuICAgICAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwXSxcbiAgICAgICAgXCI1MVwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNTJcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDBdLFxuICAgICAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwXSxcbiAgICAgICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNTVcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDBdLFxuICAgICAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwXSxcbiAgICAgICAgXCI1N1wiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAuMDU4MiwgMF0sXG4gICAgICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDU4MiwgMF0sXG4gICAgICAgIFwiNjFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLjA2NjE2LCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMC4xMjI1LCAwXSxcbiAgICAgICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMC4wOTU5NywgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4xNDUyOCwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjEyMDI4LCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAuMDg3MjIsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4xNTgwNiwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMTQwMjgsIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wOTQwMywgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTAyNTcsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLjA5NDAzLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMzg2OCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMTE5NzIsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzMzA1LCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xNjM4OSwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMTgzNjEsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjE4MzYxLCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4xNTgwNiwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMTkzODMsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMC4xODc1LCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMC4xMDUyOCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAuMDY2NDYsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjMxLCAwLjEyMDU2LCAwLjA5MjA4LCAwXSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAuMDYzMTIsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLjA1NjUzLCAwXSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDBdLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMC4wNzUxNCwgMF0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjIxMTk0LCAwXSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDg4NDcsIDBdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMC4wNzY3MSwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY1NTM2LCAwLjEwMTksIDBdLFxuICAgICAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NTUzNiwgMC4xNDQ2NywgMF0sXG4gICAgICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjEwNzY0LCAwXSxcbiAgICAgICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDBdLFxuICAgICAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMF0sXG4gICAgICAgIFwiMTEwXCI6IFswLCAwLjQzMDU2LCAwLjA3NjcxLCAwXSxcbiAgICAgICAgXCIxMTFcIjogWzAsIDAuNDMwNTYsIDAuMDYzMTIsIDBdLFxuICAgICAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNjMxMiwgMF0sXG4gICAgICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA4ODQ3LCAwXSxcbiAgICAgICAgXCIxMTRcIjogWzAsIDAuNDMwNTYsIDAuMTA3NjQsIDBdLFxuICAgICAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMC4wODIwOCwgMF0sXG4gICAgICAgIFwiMTE2XCI6IFswLCAwLjYxNTA4LCAwLjA5NDg2LCAwXSxcbiAgICAgICAgXCIxMTdcIjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDBdLFxuICAgICAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMC4xMDc2NCwgMF0sXG4gICAgICAgIFwiMTE5XCI6IFswLCAwLjQzMDU2LCAwLjEwNzY0LCAwXSxcbiAgICAgICAgXCIxMjBcIjogWzAsIDAuNDMwNTYsIDAuMTIwNDIsIDBdLFxuICAgICAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wODg0NywgMF0sXG4gICAgICAgIFwiMTIyXCI6IFswLCAwLjQzMDU2LCAwLjEyMjkyLCAwXSxcbiAgICAgICAgXCIxMjZcIjogWzAuMzUsIDAuMzE3ODYsIDAuMTE1ODUsIDBdLFxuICAgICAgICBcIjE2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzA1XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjc2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzY5XCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuNjk0NDQsIDAuMDY2NDYsIDBdLFxuICAgICAgICBcIjc3MVwiOiBbMCwgMC42Njc4NiwgMC4xMTU4NSwgMF0sXG4gICAgICAgIFwiNzcyXCI6IFswLCAwLjU2MTY3LCAwLjEwMzMzLCAwXSxcbiAgICAgICAgXCI3NzRcIjogWzAsIDAuNjk0NDQsIDAuMTA4MDYsIDBdLFxuICAgICAgICBcIjc3NVwiOiBbMCwgMC42Njc4NiwgMC4xMTc1MiwgMF0sXG4gICAgICAgIFwiNzc2XCI6IFswLCAwLjY2Nzg2LCAwLjEwNDc0LCAwXSxcbiAgICAgICAgXCI3NzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3OVwiOiBbMCwgMC42OTQ0NCwgMC4xMjI1LCAwXSxcbiAgICAgICAgXCI3ODBcIjogWzAsIDAuNjI4NDcsIDAuMDgyOTUsIDBdLFxuICAgICAgICBcIjkxNVwiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMF0sXG4gICAgICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDBdLFxuICAgICAgICBcIjkyM1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLjE1Mjk0LCAwXSxcbiAgICAgICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDBdLFxuICAgICAgICBcIjkzMVwiOiBbMCwgMC42ODMzMywgMC4xMjAyOCwgMF0sXG4gICAgICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLjExMTExLCAwXSxcbiAgICAgICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAuMDU5ODYsIDBdLFxuICAgICAgICBcIjkzNlwiOiBbMCwgMC42ODMzMywgMC4xMTExMSwgMF0sXG4gICAgICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwXSxcbiAgICAgICAgXCI4MjExXCI6IFswLCAwLjQzMDU2LCAwLjA5MjA4LCAwXSxcbiAgICAgICAgXCI4MjEyXCI6IFswLCAwLjQzMDU2LCAwLjA5MjA4LCAwXSxcbiAgICAgICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwXSxcbiAgICAgICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwXSxcbiAgICAgICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLjE2ODUsIDBdLFxuICAgICAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAuMDY5NjEsIDBdLFxuICAgICAgICBcIjg0NjNcIjogWzAsIDAuNjg4ODksIDAsIDBdXG4gICAgfSxcbiAgICBcIk1haW4tUmVndWxhclwiOiB7XG4gICAgICAgIFwiMzJcIjogWzAsIDAsIDAsIDBdLFxuICAgICAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0M1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTA1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI0NlwiOiBbMCwgMC4xMDU1NiwgMCwgMF0sXG4gICAgICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1MlwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1NVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1OFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjYwXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiNjFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI2MlwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMDI1LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjkyXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjMxLCAwLjEyMDU2LCAwLjAyNzc4LCAwXSxcbiAgICAgICAgXCI5NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4wNzc3OCwgMF0sXG4gICAgICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwNVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY2Nzg2LCAwLCAwXSxcbiAgICAgICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNjE1MDgsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTI0XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEyNlwiOiBbMC4zNSwgMC4zMTc4NiwgMCwgMF0sXG4gICAgICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwXSxcbiAgICAgICAgXCIxNjhcIjogWzAsIDAuNjY3ODYsIDAsIDBdLFxuICAgICAgICBcIjE3MlwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTc1XCI6IFswLCAwLjU2Nzc4LCAwLCAwXSxcbiAgICAgICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjE3N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMF0sXG4gICAgICAgIFwiMTgwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIyMTVcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjI0N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMF0sXG4gICAgICAgIFwiMzA1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzExXCI6IFswLCAwLjYyODQ3LCAwLCAwXSxcbiAgICAgICAgXCI3MTNcIjogWzAsIDAuNTY3NzgsIDAsIDBdLFxuICAgICAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcyOVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNjY3ODYsIDAsIDBdLFxuICAgICAgICBcIjc2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3MVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiNzcyXCI6IFswLCAwLjU2Nzc4LCAwLCAwXSxcbiAgICAgICAgXCI3NzRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3NVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiNzc2XCI6IFswLCAwLjY2Nzg2LCAwLCAwXSxcbiAgICAgICAgXCI3NzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3OVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzgwXCI6IFswLCAwLjYyODQ3LCAwLCAwXSxcbiAgICAgICAgXCI4MjRcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkxNVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjkyM1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjkzMVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjkzNlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4MjExXCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwXSxcbiAgICAgICAgXCI4MjEyXCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwXSxcbiAgICAgICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjI0XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjI1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjMwXCI6IFswLCAwLjEyLCAwLCAwXSxcbiAgICAgICAgXCI4MjQyXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NDA3XCI6IFswLCAwLjcxNDQ0LCAwLjE1MzgyLCAwXSxcbiAgICAgICAgXCI4NDYzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NDY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NDY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLjExMTExXSxcbiAgICAgICAgXCI4NDcyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjExMTExXSxcbiAgICAgICAgXCI4NDc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTAxXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTkyXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODU5M1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODU5NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg1OTVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg1OTZcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NTk3XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NTk4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTk5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjAwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjAxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjE0XCI6IFswLjAxMSwgMC41MTEsIDAsIDBdLFxuICAgICAgICBcIjg2MTdcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiODYxOFwiOiBbMC4wMTEsIDAuNTExLCAwLCAwXSxcbiAgICAgICAgXCI4NjM2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODYzN1wiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg2NDBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjQxXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODY1MlwiOiBbMC4wMTEsIDAuNjcxLCAwLCAwXSxcbiAgICAgICAgXCI4NjU2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODY1N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODY1OFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg2NTlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg2NjBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjYxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzA2XCI6IFswLCAwLjY5NDQ0LCAwLjA1NTU2LCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NzA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzA5XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzExXCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4NzEyXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiODcxNVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg3MjJcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjZcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjdcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwXSxcbiAgICAgICAgXCI4NzI4XCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMF0sXG4gICAgICAgIFwiODcyOVwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDBdLFxuICAgICAgICBcIjg3MzBcIjogWzAuMiwgMC44LCAwLCAwXSxcbiAgICAgICAgXCI4NzMzXCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzM0XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM5XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzQxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzQzXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ0XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ1XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMTExLCAwXSxcbiAgICAgICAgXCI4NzY0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODc2OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODc3MVwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDBdLFxuICAgICAgICBcIjg3NzNcIjogWy0wLjAyMiwgMC41ODksIDAsIDBdLFxuICAgICAgICBcIjg3NzZcIjogWy0wLjAxNjg4LCAwLjQ4MzEyLCAwLCAwXSxcbiAgICAgICAgXCI4NzgxXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMF0sXG4gICAgICAgIFwiODc4NFwiOiBbLTAuMTMzLCAwLjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODAwXCI6IFswLjIxNSwgMC43MTYsIDAsIDBdLFxuICAgICAgICBcIjg4MDFcIjogWy0wLjAzNjI1LCAwLjQ2Mzc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODA0XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODA1XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODEwXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiODgxMVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg4MjZcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwXSxcbiAgICAgICAgXCI4ODI3XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiODgzNFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg4MzVcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwXSxcbiAgICAgICAgXCI4ODM4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODM5XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ5XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUwXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUxXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUyXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU0XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU1XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU2XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU3XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODcyXCI6IFswLjI0OSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiODkwMFwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDBdLFxuICAgICAgICBcIjg5MDFcIjogWy0wLjA1NTU1LCAwLjQ0NDQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTAyXCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMF0sXG4gICAgICAgIFwiODkwNFwiOiBbMC4wMDUsIDAuNTA1LCAwLCAwXSxcbiAgICAgICAgXCI4OTQyXCI6IFswLjAzLCAwLjksIDAsIDBdLFxuICAgICAgICBcIjg5NDNcIjogWy0wLjE5LCAwLjMxLCAwLCAwXSxcbiAgICAgICAgXCI4OTQ1XCI6IFstMC4xLCAwLjgyLCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTk0XCI6IFstMC4xNDIzNiwgMC4zNTc2NCwgMCwgMF0sXG4gICAgICAgIFwiODk5NVwiOiBbLTAuMTQyMzYsIDAuMzU3NjQsIDAsIDBdLFxuICAgICAgICBcIjkxMzZcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMF0sXG4gICAgICAgIFwiOTEzN1wiOiBbMC4yNDQsIDAuNzQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjUxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjU3XCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMF0sXG4gICAgICAgIFwiOTY2MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTY2N1wiOiBbLTAuMDM0NzIsIDAuNDY1MjgsIDAsIDBdLFxuICAgICAgICBcIjk3MTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjRcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjVcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjZcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjdcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MzdcIjogWzAsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjk4MzhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MzlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMjE2XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxN1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMjJcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyMjNcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyMjlcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzBcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzFcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzJcIjogWzAuMDI0LCAwLjUyNSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzNcIjogWzAuMDI0LCAwLjUyNSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzRcIjogWzAuMDI0LCAwLjUyNSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzZcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTA4MTVcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjEwOTI3XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCIxMDkyOFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMF1cbiAgICB9LFxuICAgIFwiTWF0aC1Cb2xkSXRhbGljXCI6IHtcbiAgICAgICAgXCI0N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4NjExLCAwLjA0ODM1LCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODYxMSwgMC4wNjk3OSwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjg2MTEsIDAuMDMxOTQsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4NjExLCAwLjA1NDUxLCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4NjExLCAwLjA4MjI5LCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODYxMSwgMC4wNzc3OCwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjg2MTEsIDAuMTAwNjksIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjg2MTEsIDAuMTE0MjQsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4NjExLCAwLjExNDI0LCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODYxMSwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODYxMSwgMC4wMDQyMSwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjg2MTEsIDAuMDUzODIsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODYxMSwgMC4xMTQyNCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjg2MTEsIDAuMjU1NTUsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODYxMSwgMC4wNzc3OCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjg2MTEsIDAuMjU1NTUsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwXSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMDQyLCAwXSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY5MzI2LCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjkzMjYsIDAuMDYyMiwgMF0sXG4gICAgICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjAxODUyLCAwXSxcbiAgICAgICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMDA4OCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAuMDQyMTMsIDBdLFxuICAgICAgICBcIjkxNVwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMF0sXG4gICAgICAgIFwiOTE2XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MjBcIjogWzAsIDAuNjg2MTEsIDAuMDMxOTQsIDBdLFxuICAgICAgICBcIjkyM1wiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTI2XCI6IFswLCAwLjY4NjExLCAwLjA3NDU4LCAwXSxcbiAgICAgICAgXCI5MjhcIjogWzAsIDAuNjg2MTEsIDAuMDgyMjksIDBdLFxuICAgICAgICBcIjkzMVwiOiBbMCwgMC42ODYxMSwgMC4wNTQ1MSwgMF0sXG4gICAgICAgIFwiOTMzXCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwXSxcbiAgICAgICAgXCI5MzRcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkzNlwiOiBbMCwgMC42ODYxMSwgMC4xMTY1MywgMF0sXG4gICAgICAgIFwiOTM3XCI6IFswLCAwLjY4NjExLCAwLjA0ODM1LCAwXSxcbiAgICAgICAgXCI5NDVcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk0NlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzQwMywgMF0sXG4gICAgICAgIFwiOTQ3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA2Mzg5LCAwXSxcbiAgICAgICAgXCI5NDhcIjogWzAsIDAuNjk0NDQsIDAuMDM4MTksIDBdLFxuICAgICAgICBcIjk0OVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTUwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA2MjE1LCAwXSxcbiAgICAgICAgXCI5NTFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk1MlwiOiBbMCwgMC42OTQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiOTUzXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NTRcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTU2XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NTdcIjogWzAsIDAuNDQ0NDQsIDAuMDY4OTgsIDBdLFxuICAgICAgICBcIjk1OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzAyMSwgMF0sXG4gICAgICAgIFwiOTU5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjBcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk2MVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTYyXCI6IFswLjA5NzIyLCAwLjQ0NDQ0LCAwLjA3OTE3LCAwXSxcbiAgICAgICAgXCI5NjNcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk2NFwiOiBbMCwgMC40NDQ0NCwgMC4xMzQ3MiwgMF0sXG4gICAgICAgIFwiOTY1XCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCI5NjlcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5ODJcIjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDBdLFxuICAgICAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMTNcIjogWzAsIDAuNDQ0NDQsIDAsIDBdXG4gICAgfSxcbiAgICBcIk1hdGgtSXRhbGljXCI6IHtcbiAgICAgICAgXCI0N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODldLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0XSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDU1NTZdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjA4MTI1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4xMTExMV0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMDk2MTgsIDAuMTY2NjddLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA1NTU2XSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzRdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzRdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMDc3MywgMC4wODMzNF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzRdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wMjc3OF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4wODMzNF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEwNzY0LCAwLjE2NjY3XSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY1OTUyLCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjU5NTIsIDAuMDU3MjQsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wMzE0OCwgMF0sXG4gICAgICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjAxOTY4LCAwLjA4MzM0XSxcbiAgICAgICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdLFxuICAgICAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4wMjY5MSwgMC4wODMzNF0sXG4gICAgICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDU1NTZdLFxuICAgICAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMC4wNDM5OCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3XSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjgzMzMsIDAuMDc1NjksIDAuMDgzMzRdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDU1NTZdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExLCAwLjA1NTU2XSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjgzMzMsIDAuMDUwMTcsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0NVwiOiBbMCwgMC40MzA1NiwgMC4wMDM3LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUyNzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTU1NiwgMF0sXG4gICAgICAgIFwiOTQ4XCI6IFswLCAwLjY5NDQ0LCAwLjAzNzg1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NDlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNzM3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDI3NzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1M1wiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTU0XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI5NTVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1NlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTU3XCI6IFswLCAwLjQzMDU2LCAwLjA2MzY2LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDQ2MDEsIDAuMTExMTFdLFxuICAgICAgICBcIjk1OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTYwXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40MzA1NiwgMC4wNzk4NiwgMC4wODMzNF0sXG4gICAgICAgIFwiOTYzXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjRcIjogWzAsIDAuNDMwNTYsIDAuMTEzMiwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTY1XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNTg4LCAwLjExMTExXSxcbiAgICAgICAgXCI5NjlcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDBdLFxuICAgICAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5ODJcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjEwMTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdXG4gICAgfSxcbiAgICBcIk1hdGgtUmVndWxhclwiOiB7XG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODldLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0XSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDU1NTZdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjA4MTI1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4xMTExMV0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMDk2MTgsIDAuMTY2NjddLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA1NTU2XSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzRdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzRdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMDc3MywgMC4wODMzNF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzRdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wMjc3OF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4wODMzNF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEwNzY0LCAwLjE2NjY3XSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY1OTUyLCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjU5NTIsIDAuMDU3MjQsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wMzE0OCwgMF0sXG4gICAgICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjAxOTY4LCAwLjA4MzM0XSxcbiAgICAgICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdLFxuICAgICAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4wMjY5MSwgMC4wODMzNF0sXG4gICAgICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDU1NTZdLFxuICAgICAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMC4wNDM5OCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3XSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjgzMzMsIDAuMDc1NjksIDAuMDgzMzRdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDU1NTZdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExLCAwLjA1NTU2XSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjgzMzMsIDAuMDUwMTcsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0NVwiOiBbMCwgMC40MzA1NiwgMC4wMDM3LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUyNzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTU1NiwgMF0sXG4gICAgICAgIFwiOTQ4XCI6IFswLCAwLjY5NDQ0LCAwLjAzNzg1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NDlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNzM3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDI3NzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1M1wiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTU0XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI5NTVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1NlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTU3XCI6IFswLCAwLjQzMDU2LCAwLjA2MzY2LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDQ2MDEsIDAuMTExMTFdLFxuICAgICAgICBcIjk1OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTYwXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40MzA1NiwgMC4wNzk4NiwgMC4wODMzNF0sXG4gICAgICAgIFwiOTYzXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjRcIjogWzAsIDAuNDMwNTYsIDAuMTEzMiwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTY1XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNTg4LCAwLjExMTExXSxcbiAgICAgICAgXCI5NjlcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDBdLFxuICAgICAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5ODJcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjEwMTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdXG4gICAgfSxcbiAgICBcIlNhbnNTZXJpZi1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjQ0XCI6IFswLjEyNSwgMC4wODMzMywgMCwgMF0sXG4gICAgICAgIFwiNDVcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjQ2XCI6IFswLCAwLjA4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDhcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ5XCI6IFswLCAwLjY1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI1MFwiOiBbMCwgMC42NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNTFcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjUyXCI6IFswLCAwLjY1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI1M1wiOiBbMCwgMC42NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNTRcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjU1XCI6IFswLCAwLjY1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI1NlwiOiBbMCwgMC42NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNTdcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjU4XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1OVwiOiBbMC4xMjUsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjYxXCI6IFstMC4xMywgMC4zNywgMCwgMF0sXG4gICAgICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzJcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjczXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODFcIjogWzAuMTI1LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjk0NDQsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY5NDQ0LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjk0NDQsIDAuMDI1LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTVcIjogWzAuMzUsIDAuMDk0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAxXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMDY5NDQsIDBdLFxuICAgICAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTM4OSwgMF0sXG4gICAgICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDVcIjogWzAsIDAuNjc5MzcsIDAsIDBdLFxuICAgICAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NzkzNywgMCwgMF0sXG4gICAgICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwOVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTRcIjogWzAsIDAuNDQ0NDQsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE2XCI6IFswLCAwLjU3MTQzLCAwLCAwXSxcbiAgICAgICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExOFwiOiBbMCwgMC40NDQ0NCwgMC4wMTM4OSwgMF0sXG4gICAgICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTM4OSwgMF0sXG4gICAgICAgIFwiMTIyXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMjZcIjogWzAuMzUsIDAuMzI2NTksIDAsIDBdLFxuICAgICAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NjhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuNjc2NTksIDAsIDBdLFxuICAgICAgICBcIjc3MlwiOiBbMCwgMC42MDg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzc0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzVcIjogWzAsIDAuNjc5MzcsIDAsIDBdLFxuICAgICAgICBcIjc3NlwiOiBbMCwgMC42NzkzNywgMCwgMF0sXG4gICAgICAgIFwiNzc4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc4MFwiOiBbMCwgMC42MzE5NCwgMCwgMF0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjgyMTJcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAsIDBdXG4gICAgfSxcbiAgICBcIlNjcmlwdC1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI2NVwiOiBbMCwgMC43LCAwLjIyOTI1LCAwXSxcbiAgICAgICAgXCI2NlwiOiBbMCwgMC43LCAwLjA0MDg3LCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC43LCAwLjE2ODksIDBdLFxuICAgICAgICBcIjY4XCI6IFswLCAwLjcsIDAuMDkzNzEsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjcsIDAuMTg1ODMsIDBdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjcsIDAuMTM2MzQsIDBdLFxuICAgICAgICBcIjcxXCI6IFswLCAwLjcsIDAuMTczMjIsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjcsIDAuMjk2OTQsIDBdLFxuICAgICAgICBcIjczXCI6IFswLCAwLjcsIDAuMTkxODksIDBdLFxuICAgICAgICBcIjc0XCI6IFswLjI3Nzc4LCAwLjcsIDAuMTkxODksIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjcsIDAuMzEyNTksIDBdLFxuICAgICAgICBcIjc2XCI6IFswLCAwLjcsIDAuMTkxODksIDBdLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjcsIDAuMTU5ODEsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjcsIDAuMzUyNSwgMF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNywgMC4wODA3OCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNywgMC4wODA3OCwgMF0sXG4gICAgICAgIFwiODFcIjogWzAsIDAuNywgMC4wMzMwNSwgMF0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNywgMC4wNjI1OSwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNywgMC4xOTE4OSwgMF0sXG4gICAgICAgIFwiODRcIjogWzAsIDAuNywgMC4yOTA4NywgMF0sXG4gICAgICAgIFwiODVcIjogWzAsIDAuNywgMC4yNTgxNSwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNywgMC4yNzUyMywgMF0sXG4gICAgICAgIFwiODdcIjogWzAsIDAuNywgMC4yNzUyMywgMF0sXG4gICAgICAgIFwiODhcIjogWzAsIDAuNywgMC4yNjAwNiwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNywgMC4yOTM5LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC43LCAwLjI0MDM3LCAwXVxuICAgIH0sXG4gICAgXCJTaXplMS1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI0MFwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiOTJcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCIxMjNcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjEyNVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiNzEwXCI6IFswLCAwLjcyMjIyLCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNzIyMjIsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC43MjIyMiwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjcyMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4MjE0XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDBdLFxuICAgICAgICBcIjg1OTNcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg1OTVcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg2NTdcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg2NTlcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg3MTlcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjBcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjFcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MzBcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjg3MzlcIjogWy0wLjAwNTk5LCAwLjYwNiwgMCwgMF0sXG4gICAgICAgIFwiODc0MVwiOiBbLTAuMDA1OTksIDAuNjA2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ3XCI6IFswLjMwNjEyLCAwLjgwNSwgMC4xOTQ0NSwgMF0sXG4gICAgICAgIFwiODc0OFwiOiBbMC4zMDYsIDAuODA1LCAwLjE5NDQ1LCAwXSxcbiAgICAgICAgXCI4NzQ5XCI6IFswLjMwNiwgMC44MDUsIDAuMTk0NDUsIDBdLFxuICAgICAgICBcIjg3NTBcIjogWzAuMzA2MTIsIDAuODA1LCAwLjE5NDQ1LCAwXSxcbiAgICAgICAgXCI4ODk2XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODk3XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODk4XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODk5XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI5MTY4XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDBdLFxuICAgICAgICBcIjEwMjE2XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxN1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTJcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEwNzUzXCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMDc1NFwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTZcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEwNzU4XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXVxuICAgIH0sXG4gICAgXCJTaXplMi1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI0MFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiOTJcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCIxMjNcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjEyNVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiNzEwXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzE5XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCI4NzIwXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCI4NzIxXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCI4NzMwXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ3XCI6IFswLjg2MjI1LCAxLjM2LCAwLjQ0NDQ1LCAwXSxcbiAgICAgICAgXCI4NzQ4XCI6IFswLjg2MiwgMS4zNiwgMC40NDQ0NSwgMF0sXG4gICAgICAgIFwiODc0OVwiOiBbMC44NjIsIDEuMzYsIDAuNDQ0NDUsIDBdLFxuICAgICAgICBcIjg3NTBcIjogWzAuODYyMjUsIDEuMzYsIDAuNDQ0NDUsIDBdLFxuICAgICAgICBcIjg4OTZcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg4OTdcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg4OThcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg4OTlcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg5NjhcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjg5NjlcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjg5NzBcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjg5NzFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjEwMjE2XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxN1wiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTJcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjEwNzUzXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCIxMDc1NFwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTZcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjEwNzU4XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXVxuICAgIH0sXG4gICAgXCJTaXplMy1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI0MFwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiOTJcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCIxMjNcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdLFxuICAgICAgICBcIjEyNVwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiNzEwXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzMwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxNlwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMTdcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdXG4gICAgfSxcbiAgICBcIlNpemU0LVJlZ3VsYXJcIjoge1xuICAgICAgICBcIjQwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0MVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiNDdcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDBdLFxuICAgICAgICBcIjkxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5MlwiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiOTNcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiMTI1XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI3MTBcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI4NzMwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5MTE1XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMF0sXG4gICAgICAgIFwiOTExNlwiOiBbMWUtMDUsIDAuNiwgMCwgMF0sXG4gICAgICAgIFwiOTExN1wiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDBdLFxuICAgICAgICBcIjkxMThcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwXSxcbiAgICAgICAgXCI5MTE5XCI6IFsxZS0wNSwgMC42LCAwLCAwXSxcbiAgICAgICAgXCI5MTIwXCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMF0sXG4gICAgICAgIFwiOTEyMVwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDBdLFxuICAgICAgICBcIjkxMjJcIjogWy0wLjAwMDk5LCAwLjYwMSwgMCwgMF0sXG4gICAgICAgIFwiOTEyM1wiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDBdLFxuICAgICAgICBcIjkxMjRcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwXSxcbiAgICAgICAgXCI5MTI1XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDBdLFxuICAgICAgICBcIjkxMjZcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwXSxcbiAgICAgICAgXCI5MTI3XCI6IFsxZS0wNSwgMC45LCAwLCAwXSxcbiAgICAgICAgXCI5MTI4XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCI5MTI5XCI6IFswLjkwMDAxLCAwLCAwLCAwXSxcbiAgICAgICAgXCI5MTMwXCI6IFswLCAwLjMsIDAsIDBdLFxuICAgICAgICBcIjkxMzFcIjogWzFlLTA1LCAwLjksIDAsIDBdLFxuICAgICAgICBcIjkxMzJcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjkxMzNcIjogWzAuOTAwMDEsIDAsIDAsIDBdLFxuICAgICAgICBcIjkxNDNcIjogWzAuODg1MDIsIDAuOTE1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxNlwiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMTdcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDBdLFxuICAgICAgICBcIjU3MzQ0XCI6IFstMC4wMDQ5OSwgMC42MDUsIDAsIDBdLFxuICAgICAgICBcIjU3MzQ1XCI6IFstMC4wMDQ5OSwgMC42MDUsIDAsIDBdLFxuICAgICAgICBcIjU3NjgwXCI6IFswLCAwLjEyLCAwLCAwXSxcbiAgICAgICAgXCI1NzY4MVwiOiBbMCwgMC4xMiwgMCwgMF0sXG4gICAgICAgIFwiNTc2ODJcIjogWzAsIDAuMTIsIDAsIDBdLFxuICAgICAgICBcIjU3NjgzXCI6IFswLCAwLjEyLCAwLCAwXVxuICAgIH0sXG4gICAgXCJUeXBld3JpdGVyLVJlZ3VsYXJcIjoge1xuICAgICAgICBcIjMzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIzNFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMzVcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjM2XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzN1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzhcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjM5XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI0MFwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjQyXCI6IFswLCAwLjUyMDgzLCAwLCAwXSxcbiAgICAgICAgXCI0M1wiOiBbLTAuMDgwNTYsIDAuNTMwNTUsIDAsIDBdLFxuICAgICAgICBcIjQ0XCI6IFswLjEzODg5LCAwLjEyNSwgMCwgMF0sXG4gICAgICAgIFwiNDVcIjogWy0wLjA4MDU2LCAwLjUzMDU1LCAwLCAwXSxcbiAgICAgICAgXCI0NlwiOiBbMCwgMC4xMjUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0OFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNDlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjUwXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI1MVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNTJcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjUzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI1NFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNTVcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjU2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI1N1wiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjU5XCI6IFswLjEzODg5LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI2MFwiOiBbLTAuMDU1NTYsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjYxXCI6IFstMC4xOTU0OSwgMC40MTU2MiwgMCwgMF0sXG4gICAgICAgIFwiNjJcIjogWy0wLjA1NTU2LCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNjRcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjY1XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI2NlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNjdcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjY4XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI2OVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzBcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjcxXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3MlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzNcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc0XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzZcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3OFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjgwXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI4MVwiOiBbMC4xMzg4OSwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjgzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI4NFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiODVcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjg2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI4N1wiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiODhcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjg5XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkyXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjA5NTE0LCAwLCAwLCAwXSxcbiAgICAgICAgXCI5NlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjk4XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTAwXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEwMlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTAzXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMDRcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjEwNVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTA2XCI6IFswLjIyMjIyLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIxMDdcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjEwOFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNTUzNTgsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTI0XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMjVcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEyNlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTI3XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIzMDVcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjU2N1wiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNzY4XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NjlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NzJcIjogWzAsIDAuNTY1NTUsIDAsIDBdLFxuICAgICAgICBcIjc3NFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzc2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NzhcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc4MFwiOiBbMCwgMC41NjU5NywgMCwgMF0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjIwMThcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjIwMTlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjgyNDJcIjogWzAsIDAuNjExMTEsIDAsIDBdXG4gICAgfVxufTtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIFBhcnNlRXJyb3IgPSByZXF1aXJlKFwiLi9QYXJzZUVycm9yXCIpO1xudmFyIHBhcnNlRGF0YSA9IHJlcXVpcmUoXCIuL3BhcnNlRGF0YVwiKTtcbnZhciBQYXJzZU5vZGUgPSBwYXJzZURhdGEuUGFyc2VOb2RlO1xuXG4vKiBUaGlzIGZpbGUgY29udGFpbnMgYSBsaXN0IG9mIGZ1bmN0aW9ucyB0aGF0IHdlIHBhcnNlLCBpZGVudGlmaWVkIGJ5XG4gKiB0aGUgY2FsbHMgdG8gZGVmaW5lRnVuY3Rpb24uXG4gKlxuICogVGhlIGZpcnN0IGFyZ3VtZW50IHRvIGRlZmluZUZ1bmN0aW9uIGlzIGEgc2luZ2xlIG5hbWUgb3IgYSBsaXN0IG9mIG5hbWVzLlxuICogQWxsIGZ1bmN0aW9ucyBuYW1lZCBpbiBzdWNoIGEgbGlzdCB3aWxsIHNoYXJlIGEgc2luZ2xlIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEVhY2ggZGVjbGFyZWQgZnVuY3Rpb24gY2FuIGhhdmUgYXNzb2NpYXRlZCBwcm9wZXJ0aWVzLCB3aGljaFxuICogaW5jbHVkZSB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIG51bUFyZ3M6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoZSBmdW5jdGlvbiB0YWtlcy5cbiAqICAgICAgICAgICAgIElmIHRoaXMgaXMgdGhlIG9ubHkgcHJvcGVydHksIGl0IGNhbiBiZSBwYXNzZWQgYXMgYSBudW1iZXJcbiAqICAgICAgICAgICAgIGluc3RlYWQgb2YgYW4gZWxlbWVudCBvZiBhIHByb3BlcnRpZXMgb2JqZWN0LlxuICogIC0gYXJnVHlwZXM6IChvcHRpb25hbCkgQW4gYXJyYXkgY29ycmVzcG9uZGluZyB0byBlYWNoIGFyZ3VtZW50IG9mIHRoZVxuICogICAgICAgICAgICAgIGZ1bmN0aW9uLCBnaXZpbmcgdGhlIHR5cGUgb2YgYXJndW1lbnQgdGhhdCBzaG91bGQgYmUgcGFyc2VkLiBJdHNcbiAqICAgICAgICAgICAgICBsZW5ndGggc2hvdWxkIGJlIGVxdWFsIHRvIGBudW1BcmdzICsgbnVtT3B0aW9uYWxBcmdzYC4gVmFsaWRcbiAqICAgICAgICAgICAgICB0eXBlczpcbiAqICAgICAgICAgICAgICAgLSBcInNpemVcIjogQSBzaXplLWxpa2UgdGhpbmcsIHN1Y2ggYXMgXCIxZW1cIiBvciBcIjVleFwiXG4gKiAgICAgICAgICAgICAgIC0gXCJjb2xvclwiOiBBbiBodG1sIGNvbG9yLCBsaWtlIFwiI2FiY1wiIG9yIFwiYmx1ZVwiXG4gKiAgICAgICAgICAgICAgIC0gXCJvcmlnaW5hbFwiOiBUaGUgc2FtZSB0eXBlIGFzIHRoZSBlbnZpcm9ubWVudCB0aGF0IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJlaW5nIHBhcnNlZCBpcyBpbiAoZS5nLiB1c2VkIGZvciB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2RpZXMgb2YgZnVuY3Rpb25zIGxpa2UgXFxjb2xvciB3aGVyZSB0aGUgZmlyc3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudCBpcyBzcGVjaWFsIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkIG5vcm1hbGx5KVxuICogICAgICAgICAgICAgIE90aGVyIHBvc3NpYmxlIHR5cGVzIChwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZClcbiAqICAgICAgICAgICAgICAgLSBcInRleHRcIjogVGV4dC1saWtlIChlLmcuIFxcdGV4dClcbiAqICAgICAgICAgICAgICAgLSBcIm1hdGhcIjogTm9ybWFsIG1hdGhcbiAqICAgICAgICAgICAgICBJZiB1bmRlZmluZWQsIHRoaXMgd2lsbCBiZSB0cmVhdGVkIGFzIGFuIGFwcHJvcHJpYXRlIGxlbmd0aFxuICogICAgICAgICAgICAgIGFycmF5IG9mIFwib3JpZ2luYWxcIiBzdHJpbmdzXG4gKiAgLSBncmVlZGluZXNzOiAob3B0aW9uYWwpIFRoZSBncmVlZGluZXNzIG9mIHRoZSBmdW5jdGlvbiB0byB1c2UgdW5ncm91cGVkXG4gKiAgICAgICAgICAgICAgICBhcmd1bWVudHMuXG4gKlxuICogICAgICAgICAgICAgICAgRS5nLiBpZiB5b3UgaGF2ZSBhbiBleHByZXNzaW9uXG4gKiAgICAgICAgICAgICAgICAgIFxcc3FydCBcXGZyYWMgMSAyXG4gKiAgICAgICAgICAgICAgICBzaW5jZSBcXGZyYWMgaGFzIGdyZWVkaW5lc3M9MiB2cyBcXHNxcnQncyBncmVlZGluZXNzPTEsIFxcZnJhY1xuICogICAgICAgICAgICAgICAgd2lsbCB1c2UgdGhlIHR3byBhcmd1bWVudHMgJzEnIGFuZCAnMicgYXMgaXRzIHR3byBhcmd1bWVudHMsXG4gKiAgICAgICAgICAgICAgICB0aGVuIHRoYXQgd2hvbGUgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGFzIHRoZSBhcmd1bWVudCB0b1xuICogICAgICAgICAgICAgICAgXFxzcXJ0LiBPbiB0aGUgb3RoZXIgaGFuZCwgdGhlIGV4cHJlc3Npb25zXG4gKiAgICAgICAgICAgICAgICAgIFxcZnJhYyBcXGZyYWMgMSAyIDNcbiAqICAgICAgICAgICAgICAgIGFuZFxuICogICAgICAgICAgICAgICAgICBcXGZyYWMgXFxzcXJ0IDEgMlxuICogICAgICAgICAgICAgICAgd2lsbCBmYWlsIGJlY2F1c2UgXFxmcmFjIGFuZCBcXGZyYWMgaGF2ZSBlcXVhbCBncmVlZGluZXNzXG4gKiAgICAgICAgICAgICAgICBhbmQgXFxzcXJ0IGhhcyBhIGxvd2VyIGdyZWVkaW5lc3MgdGhhbiBcXGZyYWMgcmVzcGVjdGl2ZWx5LiBUb1xuICogICAgICAgICAgICAgICAgbWFrZSB0aGVzZSBwYXJzZSwgd2Ugd291bGQgaGF2ZSB0byBjaGFuZ2UgdGhlbSB0bzpcbiAqICAgICAgICAgICAgICAgICAgXFxmcmFjIHtcXGZyYWMgMSAyfSAzXG4gKiAgICAgICAgICAgICAgICBhbmRcbiAqICAgICAgICAgICAgICAgICAgXFxmcmFjIHtcXHNxcnQgMX0gMlxuICpcbiAqICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAxYFxuICogIC0gYWxsb3dlZEluVGV4dDogKG9wdGlvbmFsKSBXaGV0aGVyIG9yIG5vdCB0aGUgZnVuY3Rpb24gaXMgYWxsb3dlZCBpbnNpZGVcbiAqICAgICAgICAgICAgICAgICAgIHRleHQgbW9kZSAoZGVmYXVsdCBmYWxzZSlcbiAqICAtIG51bU9wdGlvbmFsQXJnczogKG9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIG9wdGlvbmFsIGFyZ3VtZW50cyB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIHBhcnNlLiBJZiB0aGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZW4ndCBmb3VuZCxcbiAqICAgICAgICAgICAgICAgICAgICAgYG51bGxgIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBoYW5kbGVyIGluIHRoZWlyIHBsYWNlLlxuICogICAgICAgICAgICAgICAgICAgICAoZGVmYXVsdCAwKVxuICogIC0gaW5maXg6IChvcHRpb25hbCkgTXVzdCBiZSB0cnVlIGlmIHRoZSBmdW5jdGlvbiBpcyBhbiBpbmZpeCBvcGVyYXRvci5cbiAqXG4gKiBUaGUgbGFzdCBhcmd1bWVudCBpcyB0aGF0IGltcGxlbWVudGF0aW9uLCB0aGUgaGFuZGxlciBmb3IgdGhlIGZ1bmN0aW9uKHMpLlxuICogSXQgaXMgY2FsbGVkIHRvIGhhbmRsZSB0aGVzZSBmdW5jdGlvbnMgYW5kIHRoZWlyIGFyZ3VtZW50cy5cbiAqIEl0IHJlY2VpdmVzIHR3byBhcmd1bWVudHM6XG4gKiAgLSBjb250ZXh0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFuZCByZWZlcmVuY2VzIHByb3ZpZGVkIGJ5IHRoZSBwYXJzZXJcbiAqICAtIGFyZ3MgaXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG9idGFpbmVkIGZyb20gVGVYIGlucHV0XG4gKiBUaGUgY29udGV4dCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgLSBmdW5jTmFtZTogdGhlIHRleHQgKGkuZS4gbmFtZSkgb2YgdGhlIGZ1bmN0aW9uLCBpbmNsdWRpbmcgXFxcbiAqICAtIHBhcnNlcjogdGhlIHBhcnNlciBvYmplY3RcbiAqICAtIGxleGVyOiB0aGUgbGV4ZXIgb2JqZWN0XG4gKiAgLSBwb3NpdGlvbnM6IHRoZSBwb3NpdGlvbnMgaW4gdGhlIG92ZXJhbGwgc3RyaW5nIG9mIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICBhbmQgdGhlIGFyZ3VtZW50cy5cbiAqIFRoZSBsYXR0ZXIgdGhyZWUgc2hvdWxkIG9ubHkgYmUgdXNlZCB0byBwcm9kdWNlIGVycm9yIG1lc3NhZ2VzLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcga2V5czpcbiAqICAtIHR5cGU6IFRoZSB0eXBlIG9mIGVsZW1lbnQgdGhhdCB0aGlzIGlzLiBUaGlzIGlzIHRoZW4gdXNlZCBpblxuICogICAgICAgICAgYnVpbGRIVE1ML2J1aWxkTWF0aE1MIHRvIGRldGVybWluZSB3aGljaCBmdW5jdGlvblxuICogICAgICAgICAgc2hvdWxkIGJlIGNhbGxlZCB0byBidWlsZCB0aGlzIG5vZGUgaW50byBhIERPTSBub2RlXG4gKiBBbnkgb3RoZXIgZGF0YSBjYW4gYmUgYWRkZWQgdG8gdGhlIG9iamVjdCwgd2hpY2ggd2lsbCBiZSBwYXNzZWRcbiAqIGluIHRvIHRoZSBmdW5jdGlvbiBpbiBidWlsZEhUTUwvYnVpbGRNYXRoTUwgYXMgYGdyb3VwLnZhbHVlYC5cbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVGdW5jdGlvbihuYW1lcywgcHJvcHMsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5hbWVzID0gW25hbWVzXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBwcm9wcyA9IHsgbnVtQXJnczogcHJvcHMgfTtcbiAgICB9XG4gICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIG9mIGZ1bmN0aW9uc1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICBudW1BcmdzOiBwcm9wcy5udW1BcmdzLFxuICAgICAgICBhcmdUeXBlczogcHJvcHMuYXJnVHlwZXMsXG4gICAgICAgIGdyZWVkaW5lc3M6IChwcm9wcy5ncmVlZGluZXNzID09PSB1bmRlZmluZWQpID8gMSA6IHByb3BzLmdyZWVkaW5lc3MsXG4gICAgICAgIGFsbG93ZWRJblRleHQ6ICEhcHJvcHMuYWxsb3dlZEluVGV4dCxcbiAgICAgICAgbnVtT3B0aW9uYWxBcmdzOiBwcm9wcy5udW1PcHRpb25hbEFyZ3MgfHwgMCxcbiAgICAgICAgaW5maXg6ICEhcHJvcHMuaW5maXgsXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHNbbmFtZXNbaV1dID0gZGF0YTtcbiAgICB9XG59XG5cbi8vIFNpbmNlIHRoZSBjb3JyZXNwb25kaW5nIGJ1aWxkSFRNTC9idWlsZE1hdGhNTCBmdW5jdGlvbiBleHBlY3RzIGFcbi8vIGxpc3Qgb2YgZWxlbWVudHMsIHdlIG5vcm1hbGl6ZSBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIGFyZ3VtZW50c1xudmFyIG9yZGFyZ3VtZW50ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgcmV0dXJuIGFyZy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2FyZ107XG4gICAgfVxufTtcblxuLy8gQSBub3JtYWwgc3F1YXJlIHJvb3RcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXHNxcnRcIiwge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGluZGV4ID0gYXJnc1swXTtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzcXJ0XCIsXG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgIH07XG59KTtcblxuLy8gTm9uLW1hdGh5IHRleHQsIHBvc3NpYmx5IGluIGEgZm9udFxudmFyIHRleHRGdW5jdGlvblN0eWxlcyA9IHtcbiAgICBcIlxcXFx0ZXh0XCI6IHVuZGVmaW5lZCwgXCJcXFxcdGV4dHJtXCI6IFwibWF0aHJtXCIsIFwiXFxcXHRleHRzZlwiOiBcIm1hdGhzZlwiLFxuICAgIFwiXFxcXHRleHR0dFwiOiBcIm1hdGh0dFwiLCBcIlxcXFx0ZXh0bm9ybWFsXCI6IFwibWF0aHJtXCIsIFwiXFxcXHRleHRiZlwiOiBcIm1hdGhiZlwiLFxuICAgIFwiXFxcXHRleHRpdFwiOiBcInRleHRpdFwiXG59O1xuXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcdGV4dFwiLCBcIlxcXFx0ZXh0cm1cIiwgXCJcXFxcdGV4dHNmXCIsIFwiXFxcXHRleHR0dFwiLCBcIlxcXFx0ZXh0bm9ybWFsXCIsXG4gICAgXCJcXFxcdGV4dGJmXCIsIFwiXFxcXHRleHRpdFwiXG5dLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXSxcbiAgICBncmVlZGluZXNzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgICBzdHlsZTogdGV4dEZ1bmN0aW9uU3R5bGVzW2NvbnRleHQuZnVuY05hbWVdXG4gICAgfTtcbn0pO1xuXG4vLyBBIHR3by1hcmd1bWVudCBjdXN0b20gY29sb3JcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXGNvbG9yXCIsIHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgZ3JlZWRpbmVzczogMyxcbiAgICBhcmdUeXBlczogW1wiY29sb3JcIiwgXCJvcmlnaW5hbFwiXVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBjb2xvciA9IGFyZ3NbMF07XG4gICAgdmFyIGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgY29sb3I6IGNvbG9yLnZhbHVlLFxuICAgICAgICB2YWx1ZTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xufSk7XG5cbi8vIEFuIG92ZXJsaW5lXG5kZWZpbmVGdW5jdGlvbihcIlxcXFxvdmVybGluZVwiLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm92ZXJsaW5lXCIsXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xufSk7XG5cbi8vIEFuIHVuZGVybGluZVxuZGVmaW5lRnVuY3Rpb24oXCJcXFxcdW5kZXJsaW5lXCIsIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidW5kZXJsaW5lXCIsXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xufSk7XG5cbi8vIEEgYm94IG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0XG5kZWZpbmVGdW5jdGlvbihcIlxcXFxydWxlXCIsIHtcbiAgICBudW1BcmdzOiAyLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiLCBcInNpemVcIiwgXCJzaXplXCJdXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIHNoaWZ0ID0gYXJnc1swXTtcbiAgICB2YXIgd2lkdGggPSBhcmdzWzFdO1xuICAgIHZhciBoZWlnaHQgPSBhcmdzWzJdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwicnVsZVwiLFxuICAgICAgICBzaGlmdDogc2hpZnQgJiYgc2hpZnQudmFsdWUsXG4gICAgICAgIHdpZHRoOiB3aWR0aC52YWx1ZSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQudmFsdWVcbiAgICB9O1xufSk7XG5cbi8vIFRPRE86IEluIFRlWCwgXFxta2VybiBvbmx5IGFjY2VwdHMgbXUtdW5pdHMsIGFuZCBcXGtlcm4gZG9lcyBub3QgYWNjZXB0XG4vLyBtdS11bml0cy4gSW4gY3VycmVudCBLYVRlWCB3ZSByZWxheCB0aGlzOyBib3RoIGNvbW1hbmRzIGFjY2VwdCBhbnkgdW5pdC5cbmRlZmluZUZ1bmN0aW9uKFtcIlxcXFxrZXJuXCIsIFwiXFxcXG1rZXJuXCJdLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBkaW1lbnNpb246IGFyZ3NbMF0udmFsdWVcbiAgICB9O1xufSk7XG5cbi8vIEEgS2FUZVggbG9nb1xuZGVmaW5lRnVuY3Rpb24oXCJcXFxcS2FUZVhcIiwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImthdGV4XCJcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFwiXFxcXHBoYW50b21cIiwge1xuICAgIG51bUFyZ3M6IDFcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJwaGFudG9tXCIsXG4gICAgICAgIHZhbHVlOiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG59KTtcblxuLy8gTWF0aCBjbGFzcyBjb21tYW5kcyBleGNlcHQgXFxtYXRob3BcbmRlZmluZUZ1bmN0aW9uKFtcbiAgICBcIlxcXFxtYXRob3JkXCIsIFwiXFxcXG1hdGhiaW5cIiwgXCJcXFxcbWF0aHJlbFwiLCBcIlxcXFxtYXRob3BlblwiLFxuICAgIFwiXFxcXG1hdGhjbG9zZVwiLCBcIlxcXFxtYXRocHVuY3RcIiwgXCJcXFxcbWF0aGlubmVyXCJcbl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICAgIG1jbGFzczogXCJtXCIgKyBjb250ZXh0LmZ1bmNOYW1lLnN1YnN0cig1KSxcbiAgICAgICAgdmFsdWU6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbn0pO1xuXG4vLyBCdWlsZCBhIHJlbGF0aW9uIGJ5IHBsYWNpbmcgb25lIHN5bWJvbCBvbiB0b3Agb2YgYW5vdGhlclxuZGVmaW5lRnVuY3Rpb24oXCJcXFxcc3RhY2tyZWxcIiwge1xuICAgIG51bUFyZ3M6IDJcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgdG9wID0gYXJnc1swXTtcbiAgICB2YXIgYm90dG9tID0gYXJnc1sxXTtcblxuICAgIHZhciBib3R0b21vcCA9IG5ldyBQYXJzZU5vZGUoXCJvcFwiLCB7XG4gICAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgICBhbHdheXNIYW5kbGVTdXBTdWI6IHRydWUsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvcmRhcmd1bWVudChib3R0b20pXG4gICAgfSwgYm90dG9tLm1vZGUpO1xuXG4gICAgdmFyIHN1cHN1YiA9IG5ldyBQYXJzZU5vZGUoXCJzdXBzdWJcIiwge1xuICAgICAgICBiYXNlOiBib3R0b21vcCxcbiAgICAgICAgc3VwOiB0b3AsXG4gICAgICAgIHN1YjogbnVsbFxuICAgIH0sIHRvcC5tb2RlKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICAgIG1jbGFzczogXCJtcmVsXCIsXG4gICAgICAgIHZhbHVlOiBbc3Vwc3ViXVxuICAgIH07XG59KTtcblxuLy8gXFxtb2QtdHlwZSBmdW5jdGlvbnNcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXGJtb2RcIiwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm1vZFwiLFxuICAgICAgICBtb2RUeXBlOiBcImJtb2RcIixcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFtcIlxcXFxwb2RcIiwgXCJcXFxccG1vZFwiLCBcIlxcXFxtb2RcIl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibW9kXCIsXG4gICAgICAgIG1vZFR5cGU6IGNvbnRleHQuZnVuY05hbWUuc3Vic3RyKDEpLFxuICAgICAgICB2YWx1ZTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xufSk7XG5cbi8vIEV4dHJhIGRhdGEgbmVlZGVkIGZvciB0aGUgZGVsaW1pdGVyIGhhbmRsZXIgZG93biBiZWxvd1xudmFyIGRlbGltaXRlclNpemVzID0ge1xuICAgIFwiXFxcXGJpZ2xcIiA6IHttY2xhc3M6IFwibW9wZW5cIiwgICAgc2l6ZTogMX0sXG4gICAgXCJcXFxcQmlnbFwiIDoge21jbGFzczogXCJtb3BlblwiLCAgICBzaXplOiAyfSxcbiAgICBcIlxcXFxiaWdnbFwiOiB7bWNsYXNzOiBcIm1vcGVuXCIsICAgIHNpemU6IDN9LFxuICAgIFwiXFxcXEJpZ2dsXCI6IHttY2xhc3M6IFwibW9wZW5cIiwgICAgc2l6ZTogNH0sXG4gICAgXCJcXFxcYmlnclwiIDoge21jbGFzczogXCJtY2xvc2VcIiwgICBzaXplOiAxfSxcbiAgICBcIlxcXFxCaWdyXCIgOiB7bWNsYXNzOiBcIm1jbG9zZVwiLCAgIHNpemU6IDJ9LFxuICAgIFwiXFxcXGJpZ2dyXCI6IHttY2xhc3M6IFwibWNsb3NlXCIsICAgc2l6ZTogM30sXG4gICAgXCJcXFxcQmlnZ3JcIjoge21jbGFzczogXCJtY2xvc2VcIiwgICBzaXplOiA0fSxcbiAgICBcIlxcXFxiaWdtXCIgOiB7bWNsYXNzOiBcIm1yZWxcIiwgICAgIHNpemU6IDF9LFxuICAgIFwiXFxcXEJpZ21cIiA6IHttY2xhc3M6IFwibXJlbFwiLCAgICAgc2l6ZTogMn0sXG4gICAgXCJcXFxcYmlnZ21cIjoge21jbGFzczogXCJtcmVsXCIsICAgICBzaXplOiAzfSxcbiAgICBcIlxcXFxCaWdnbVwiOiB7bWNsYXNzOiBcIm1yZWxcIiwgICAgIHNpemU6IDR9LFxuICAgIFwiXFxcXGJpZ1wiICA6IHttY2xhc3M6IFwibW9yZFwiLCAgICAgc2l6ZTogMX0sXG4gICAgXCJcXFxcQmlnXCIgIDoge21jbGFzczogXCJtb3JkXCIsICAgICBzaXplOiAyfSxcbiAgICBcIlxcXFxiaWdnXCIgOiB7bWNsYXNzOiBcIm1vcmRcIiwgICAgIHNpemU6IDN9LFxuICAgIFwiXFxcXEJpZ2dcIiA6IHttY2xhc3M6IFwibW9yZFwiLCAgICAgc2l6ZTogNH1cbn07XG5cbnZhciBkZWxpbWl0ZXJzID0gW1xuICAgIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXFxcXGxicmFja1wiLCBcIl1cIiwgXCJcXFxccmJyYWNrXCIsXG4gICAgXCJcXFxce1wiLCBcIlxcXFxsYnJhY2VcIiwgXCJcXFxcfVwiLCBcIlxcXFxyYnJhY2VcIixcbiAgICBcIlxcXFxsZmxvb3JcIiwgXCJcXFxccmZsb29yXCIsIFwiXFxcXGxjZWlsXCIsIFwiXFxcXHJjZWlsXCIsXG4gICAgXCI8XCIsIFwiPlwiLCBcIlxcXFxsYW5nbGVcIiwgXCJcXFxccmFuZ2xlXCIsIFwiXFxcXGx0XCIsIFwiXFxcXGd0XCIsXG4gICAgXCJcXFxcbHZlcnRcIiwgXCJcXFxccnZlcnRcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIixcbiAgICBcIlxcXFxsZ3JvdXBcIiwgXCJcXFxccmdyb3VwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgXCJcXFxccm1vdXN0YWNoZVwiLFxuICAgIFwiL1wiLCBcIlxcXFxiYWNrc2xhc2hcIixcbiAgICBcInxcIiwgXCJcXFxcdmVydFwiLCBcIlxcXFx8XCIsIFwiXFxcXFZlcnRcIixcbiAgICBcIlxcXFx1cGFycm93XCIsIFwiXFxcXFVwYXJyb3dcIixcbiAgICBcIlxcXFxkb3duYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsXG4gICAgXCJcXFxcdXBkb3duYXJyb3dcIiwgXCJcXFxcVXBkb3duYXJyb3dcIixcbiAgICBcIi5cIlxuXTtcblxudmFyIGZvbnRBbGlhc2VzID0ge1xuICAgIFwiXFxcXEJiYlwiOiBcIlxcXFxtYXRoYmJcIixcbiAgICBcIlxcXFxib2xkXCI6IFwiXFxcXG1hdGhiZlwiLFxuICAgIFwiXFxcXGZyYWtcIjogXCJcXFxcbWF0aGZyYWtcIlxufTtcblxuLy8gU2luZ2xlLWFyZ3VtZW50IGNvbG9yIGZ1bmN0aW9uc1xuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGJsdWVcIiwgXCJcXFxcb3JhbmdlXCIsIFwiXFxcXHBpbmtcIiwgXCJcXFxccmVkXCIsXG4gICAgXCJcXFxcZ3JlZW5cIiwgXCJcXFxcZ3JheVwiLCBcIlxcXFxwdXJwbGVcIixcbiAgICBcIlxcXFxibHVlQVwiLCBcIlxcXFxibHVlQlwiLCBcIlxcXFxibHVlQ1wiLCBcIlxcXFxibHVlRFwiLCBcIlxcXFxibHVlRVwiLFxuICAgIFwiXFxcXHRlYWxBXCIsIFwiXFxcXHRlYWxCXCIsIFwiXFxcXHRlYWxDXCIsIFwiXFxcXHRlYWxEXCIsIFwiXFxcXHRlYWxFXCIsXG4gICAgXCJcXFxcZ3JlZW5BXCIsIFwiXFxcXGdyZWVuQlwiLCBcIlxcXFxncmVlbkNcIiwgXCJcXFxcZ3JlZW5EXCIsIFwiXFxcXGdyZWVuRVwiLFxuICAgIFwiXFxcXGdvbGRBXCIsIFwiXFxcXGdvbGRCXCIsIFwiXFxcXGdvbGRDXCIsIFwiXFxcXGdvbGREXCIsIFwiXFxcXGdvbGRFXCIsXG4gICAgXCJcXFxccmVkQVwiLCBcIlxcXFxyZWRCXCIsIFwiXFxcXHJlZENcIiwgXCJcXFxccmVkRFwiLCBcIlxcXFxyZWRFXCIsXG4gICAgXCJcXFxcbWFyb29uQVwiLCBcIlxcXFxtYXJvb25CXCIsIFwiXFxcXG1hcm9vbkNcIiwgXCJcXFxcbWFyb29uRFwiLCBcIlxcXFxtYXJvb25FXCIsXG4gICAgXCJcXFxccHVycGxlQVwiLCBcIlxcXFxwdXJwbGVCXCIsIFwiXFxcXHB1cnBsZUNcIiwgXCJcXFxccHVycGxlRFwiLCBcIlxcXFxwdXJwbGVFXCIsXG4gICAgXCJcXFxcbWludEFcIiwgXCJcXFxcbWludEJcIiwgXCJcXFxcbWludENcIixcbiAgICBcIlxcXFxncmF5QVwiLCBcIlxcXFxncmF5QlwiLCBcIlxcXFxncmF5Q1wiLCBcIlxcXFxncmF5RFwiLCBcIlxcXFxncmF5RVwiLFxuICAgIFwiXFxcXGdyYXlGXCIsIFwiXFxcXGdyYXlHXCIsIFwiXFxcXGdyYXlIXCIsIFwiXFxcXGdyYXlJXCIsXG4gICAgXCJcXFxca2FCbHVlXCIsIFwiXFxcXGthR3JlZW5cIlxuXSwge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBncmVlZGluZXNzOiAzXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgY29sb3I6IFwia2F0ZXgtXCIgKyBjb250ZXh0LmZ1bmNOYW1lLnNsaWNlKDEpLFxuICAgICAgICB2YWx1ZTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xufSk7XG5cbi8vIFRoZXJlIGFyZSAyIGZsYWdzIGZvciBvcGVyYXRvcnM7IHdoZXRoZXIgdGhleSBwcm9kdWNlIGxpbWl0cyBpblxuLy8gZGlzcGxheXN0eWxlLCBhbmQgd2hldGhlciB0aGV5IGFyZSBzeW1ib2xzIGFuZCBzaG91bGQgZ3JvdyBpblxuLy8gZGlzcGxheXN0eWxlLiBUaGVzZSBmb3VyIGdyb3VwcyBjb3ZlciB0aGUgZm91ciBwb3NzaWJsZSBjaG9pY2VzLlxuXG4vLyBObyBsaW1pdHMsIG5vdCBzeW1ib2xzXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcYXJjc2luXCIsIFwiXFxcXGFyY2Nvc1wiLCBcIlxcXFxhcmN0YW5cIiwgXCJcXFxcYXJnXCIsIFwiXFxcXGNvc1wiLCBcIlxcXFxjb3NoXCIsXG4gICAgXCJcXFxcY290XCIsIFwiXFxcXGNvdGhcIiwgXCJcXFxcY3NjXCIsIFwiXFxcXGRlZ1wiLCBcIlxcXFxkaW1cIiwgXCJcXFxcZXhwXCIsIFwiXFxcXGhvbVwiLFxuICAgIFwiXFxcXGtlclwiLCBcIlxcXFxsZ1wiLCBcIlxcXFxsblwiLCBcIlxcXFxsb2dcIiwgXCJcXFxcc2VjXCIsIFwiXFxcXHNpblwiLCBcIlxcXFxzaW5oXCIsXG4gICAgXCJcXFxcdGFuXCIsIFwiXFxcXHRhbmhcIlxuXSwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIGJvZHk6IGNvbnRleHQuZnVuY05hbWVcbiAgICB9O1xufSk7XG5cbi8vIExpbWl0cywgbm90IHN5bWJvbHNcbmRlZmluZUZ1bmN0aW9uKFtcbiAgICBcIlxcXFxkZXRcIiwgXCJcXFxcZ2NkXCIsIFwiXFxcXGluZlwiLCBcIlxcXFxsaW1cIiwgXCJcXFxcbGltaW5mXCIsIFwiXFxcXGxpbXN1cFwiLCBcIlxcXFxtYXhcIixcbiAgICBcIlxcXFxtaW5cIiwgXCJcXFxcUHJcIiwgXCJcXFxcc3VwXCJcbl0sIHtcbiAgICBudW1BcmdzOiAwXG59LCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgICBsaW1pdHM6IHRydWUsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIGJvZHk6IGNvbnRleHQuZnVuY05hbWVcbiAgICB9O1xufSk7XG5cbi8vIE5vIGxpbWl0cywgc3ltYm9sc1xuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGludFwiLCBcIlxcXFxpaW50XCIsIFwiXFxcXGlpaW50XCIsIFwiXFxcXG9pbnRcIlxuXSwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICAgIHN5bWJvbDogdHJ1ZSxcbiAgICAgICAgYm9keTogY29udGV4dC5mdW5jTmFtZVxuICAgIH07XG59KTtcblxuLy8gTGltaXRzLCBzeW1ib2xzXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcY29wcm9kXCIsIFwiXFxcXGJpZ3ZlZVwiLCBcIlxcXFxiaWd3ZWRnZVwiLCBcIlxcXFxiaWd1cGx1c1wiLCBcIlxcXFxiaWdjYXBcIixcbiAgICBcIlxcXFxiaWdjdXBcIiwgXCJcXFxcaW50b3BcIiwgXCJcXFxccHJvZFwiLCBcIlxcXFxzdW1cIiwgXCJcXFxcYmlnb3RpbWVzXCIsXG4gICAgXCJcXFxcYmlnb3BsdXNcIiwgXCJcXFxcYmlnb2RvdFwiLCBcIlxcXFxiaWdzcWN1cFwiLCBcIlxcXFxzbWFsbGludFwiXG5dLCB7XG4gICAgbnVtQXJnczogMFxufSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgICBzeW1ib2w6IHRydWUsXG4gICAgICAgIGJvZHk6IGNvbnRleHQuZnVuY05hbWVcbiAgICB9O1xufSk7XG5cbi8vIFxcbWF0aG9wIGNsYXNzIGNvbW1hbmRcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXG1hdGhvcFwiLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG59KTtcblxuLy8gRnJhY3Rpb25zXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcZGZyYWNcIiwgXCJcXFxcZnJhY1wiLCBcIlxcXFx0ZnJhY1wiLFxuICAgIFwiXFxcXGRiaW5vbVwiLCBcIlxcXFxiaW5vbVwiLCBcIlxcXFx0Ymlub21cIixcbiAgICBcIlxcXFxcXFxcYXRvcGZyYWNcIiAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbl0sIHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGdyZWVkaW5lc3M6IDJcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgbnVtZXIgPSBhcmdzWzBdO1xuICAgIHZhciBkZW5vbSA9IGFyZ3NbMV07XG4gICAgdmFyIGhhc0JhckxpbmU7XG4gICAgdmFyIGxlZnREZWxpbSA9IG51bGw7XG4gICAgdmFyIHJpZ2h0RGVsaW0gPSBudWxsO1xuICAgIHZhciBzaXplID0gXCJhdXRvXCI7XG5cbiAgICBzd2l0Y2ggKGNvbnRleHQuZnVuY05hbWUpIHtcbiAgICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgICBjYXNlIFwiXFxcXGZyYWNcIjpcbiAgICAgICAgY2FzZSBcIlxcXFx0ZnJhY1wiOlxuICAgICAgICAgICAgaGFzQmFyTGluZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlxcXFxcXFxcYXRvcGZyYWNcIjpcbiAgICAgICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgICBjYXNlIFwiXFxcXGJpbm9tXCI6XG4gICAgICAgIGNhc2UgXCJcXFxcdGJpbm9tXCI6XG4gICAgICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBsZWZ0RGVsaW0gPSBcIihcIjtcbiAgICAgICAgICAgIHJpZ2h0RGVsaW0gPSBcIilcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGdlbmZyYWMgY29tbWFuZFwiKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNvbnRleHQuZnVuY05hbWUpIHtcbiAgICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgICAgICAgc2l6ZSA9IFwiZGlzcGxheVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJcXFxcdGZyYWNcIjpcbiAgICAgICAgY2FzZSBcIlxcXFx0Ymlub21cIjpcbiAgICAgICAgICAgIHNpemUgPSBcInRleHRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgICBudW1lcjogbnVtZXIsXG4gICAgICAgIGRlbm9tOiBkZW5vbSxcbiAgICAgICAgaGFzQmFyTGluZTogaGFzQmFyTGluZSxcbiAgICAgICAgbGVmdERlbGltOiBsZWZ0RGVsaW0sXG4gICAgICAgIHJpZ2h0RGVsaW06IHJpZ2h0RGVsaW0sXG4gICAgICAgIHNpemU6IHNpemVcbiAgICB9O1xufSk7XG5cbi8vIExlZnQgYW5kIHJpZ2h0IG92ZXJsYXAgZnVuY3Rpb25zXG5kZWZpbmVGdW5jdGlvbihbXCJcXFxcbGxhcFwiLCBcIlxcXFxybGFwXCJdLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGNvbnRleHQuZnVuY05hbWUuc2xpY2UoMSksXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xufSk7XG5cbi8vIERlbGltaXRlciBmdW5jdGlvbnNcbnZhciBjaGVja0RlbGltaXRlciA9IGZ1bmN0aW9uKGRlbGltLCBjb250ZXh0KSB7XG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKGRlbGltaXRlcnMsIGRlbGltLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZGVsaW07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgZGVsaW1pdGVyOiAnXCIgKyBkZWxpbS52YWx1ZSArIFwiJyBhZnRlciAnXCIgK1xuICAgICAgICAgICAgY29udGV4dC5mdW5jTmFtZSArIFwiJ1wiLCBkZWxpbSk7XG4gICAgfVxufTtcblxuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGJpZ2xcIiwgXCJcXFxcQmlnbFwiLCBcIlxcXFxiaWdnbFwiLCBcIlxcXFxCaWdnbFwiLFxuICAgIFwiXFxcXGJpZ3JcIiwgXCJcXFxcQmlnclwiLCBcIlxcXFxiaWdnclwiLCBcIlxcXFxCaWdnclwiLFxuICAgIFwiXFxcXGJpZ21cIiwgXCJcXFxcQmlnbVwiLCBcIlxcXFxiaWdnbVwiLCBcIlxcXFxCaWdnbVwiLFxuICAgIFwiXFxcXGJpZ1wiLCAgXCJcXFxcQmlnXCIsICBcIlxcXFxiaWdnXCIsICBcIlxcXFxCaWdnXCJcbl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImRlbGltc2l6aW5nXCIsXG4gICAgICAgIHNpemU6IGRlbGltaXRlclNpemVzW2NvbnRleHQuZnVuY05hbWVdLnNpemUsXG4gICAgICAgIG1jbGFzczogZGVsaW1pdGVyU2l6ZXNbY29udGV4dC5mdW5jTmFtZV0ubWNsYXNzLFxuICAgICAgICB2YWx1ZTogZGVsaW0udmFsdWVcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFtcbiAgICBcIlxcXFxsZWZ0XCIsIFwiXFxcXHJpZ2h0XCJcbl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICAvLyBcXGxlZnQgYW5kIFxccmlnaHQgYXJlIGNhdWdodCBzb21ld2hlcmUgaW4gUGFyc2VyLmpzLCB3aGljaCBpc1xuICAgIC8vIHdoeSB0aGlzIGRhdGEgZG9lc24ndCBtYXRjaCB3aGF0IGlzIGluIGJ1aWxkSFRNTC5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgICB2YWx1ZTogZGVsaW0udmFsdWVcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFwiXFxcXG1pZGRsZVwiLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuICAgIGlmICghY29udGV4dC5wYXJzZXIubGVmdHJpZ2h0RGVwdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcbWlkZGxlIHdpdGhvdXQgcHJlY2VkaW5nIFxcXFxsZWZ0XCIsIGRlbGltKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm1pZGRsZVwiLFxuICAgICAgICB2YWx1ZTogZGVsaW0udmFsdWVcbiAgICB9O1xufSk7XG5cbi8vIFNpemluZyBmdW5jdGlvbnMgKGhhbmRsZWQgaW4gUGFyc2VyLmpzIGV4cGxpY2l0bHksIGhlbmNlIG5vIGhhbmRsZXIpXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcdGlueVwiLCBcIlxcXFxzY3JpcHRzaXplXCIsIFwiXFxcXGZvb3Rub3Rlc2l6ZVwiLCBcIlxcXFxzbWFsbFwiLFxuICAgIFwiXFxcXG5vcm1hbHNpemVcIiwgXCJcXFxcbGFyZ2VcIiwgXCJcXFxcTGFyZ2VcIiwgXCJcXFxcTEFSR0VcIiwgXCJcXFxcaHVnZVwiLCBcIlxcXFxIdWdlXCJcbl0sIDAsIG51bGwpO1xuXG4vLyBTdHlsZSBjaGFuZ2luZyBmdW5jdGlvbnMgKGhhbmRsZWQgaW4gUGFyc2VyLmpzIGV4cGxpY2l0bHksIGhlbmNlIG5vXG4vLyBoYW5kbGVyKVxuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGRpc3BsYXlzdHlsZVwiLCBcIlxcXFx0ZXh0c3R5bGVcIiwgXCJcXFxcc2NyaXB0c3R5bGVcIixcbiAgICBcIlxcXFxzY3JpcHRzY3JpcHRzdHlsZVwiXG5dLCAwLCBudWxsKTtcblxuZGVmaW5lRnVuY3Rpb24oW1xuICAgIC8vIHN0eWxlc1xuICAgIFwiXFxcXG1hdGhybVwiLCBcIlxcXFxtYXRoaXRcIiwgXCJcXFxcbWF0aGJmXCIsXG5cbiAgICAvLyBmYW1pbGllc1xuICAgIFwiXFxcXG1hdGhiYlwiLCBcIlxcXFxtYXRoY2FsXCIsIFwiXFxcXG1hdGhmcmFrXCIsIFwiXFxcXG1hdGhzY3JcIiwgXCJcXFxcbWF0aHNmXCIsXG4gICAgXCJcXFxcbWF0aHR0XCIsXG5cbiAgICAvLyBhbGlhc2VzXG4gICAgXCJcXFxcQmJiXCIsIFwiXFxcXGJvbGRcIiwgXCJcXFxcZnJha1wiXG5dLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBncmVlZGluZXNzOiAyXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHZhciBmdW5jID0gY29udGV4dC5mdW5jTmFtZTtcbiAgICBpZiAoZnVuYyBpbiBmb250QWxpYXNlcykge1xuICAgICAgICBmdW5jID0gZm9udEFsaWFzZXNbZnVuY107XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgICBmb250OiBmdW5jLnNsaWNlKDEpLFxuICAgICAgICBib2R5OiBib2R5XG4gICAgfTtcbn0pO1xuXG4vLyBBY2NlbnRzXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcYWN1dGVcIiwgXCJcXFxcZ3JhdmVcIiwgXCJcXFxcZGRvdFwiLCBcIlxcXFx0aWxkZVwiLCBcIlxcXFxiYXJcIiwgXCJcXFxcYnJldmVcIixcbiAgICBcIlxcXFxjaGVja1wiLCBcIlxcXFxoYXRcIiwgXCJcXFxcdmVjXCIsIFwiXFxcXGRvdFwiXG4gICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBleHBhbmRpbmcgYWNjZW50cyB5ZXRcbiAgICAvLyBcIlxcXFx3aWRldGlsZGVcIiwgXCJcXFxcd2lkZWhhdFwiXG5dLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBiYXNlID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImFjY2VudFwiLFxuICAgICAgICBhY2NlbnQ6IGNvbnRleHQuZnVuY05hbWUsXG4gICAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xufSk7XG5cbi8vIEluZml4IGdlbmVyYWxpemVkIGZyYWN0aW9uc1xuZGVmaW5lRnVuY3Rpb24oW1wiXFxcXG92ZXJcIiwgXCJcXFxcY2hvb3NlXCIsIFwiXFxcXGF0b3BcIl0sIHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGluZml4OiB0cnVlXG59LCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIHJlcGxhY2VXaXRoO1xuICAgIHN3aXRjaCAoY29udGV4dC5mdW5jTmFtZSkge1xuICAgICAgICBjYXNlIFwiXFxcXG92ZXJcIjpcbiAgICAgICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcZnJhY1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJcXFxcY2hvb3NlXCI6XG4gICAgICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGJpbm9tXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlxcXFxhdG9wXCI6XG4gICAgICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxhdG9wZnJhY1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgaW5maXggZ2VuZnJhYyBjb21tYW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImluZml4XCIsXG4gICAgICAgIHJlcGxhY2VXaXRoOiByZXBsYWNlV2l0aCxcbiAgICAgICAgdG9rZW46IGNvbnRleHQudG9rZW5cbiAgICB9O1xufSk7XG5cbi8vIFJvdyBicmVha3MgZm9yIGFsaWduZWQgZGF0YVxuZGVmaW5lRnVuY3Rpb24oW1wiXFxcXFxcXFxcIiwgXCJcXFxcY3JcIl0sIHtcbiAgICBudW1BcmdzOiAwLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBzaXplID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImNyXCIsXG4gICAgICAgIHNpemU6IHNpemVcbiAgICB9O1xufSk7XG5cbi8vIEVudmlyb25tZW50IGRlbGltaXRlcnNcbmRlZmluZUZ1bmN0aW9uKFtcIlxcXFxiZWdpblwiLCBcIlxcXFxlbmRcIl0sIHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ0ZXh0XCJdXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIG5hbWVHcm91cCA9IGFyZ3NbMF07XG4gICAgaWYgKG5hbWVHcm91cC50eXBlICE9PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGVudmlyb25tZW50IG5hbWVcIiwgbmFtZUdyb3VwKTtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZUdyb3VwLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG5hbWUgKz0gbmFtZUdyb3VwLnZhbHVlW2ldLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImVudmlyb25tZW50XCIsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIG5hbWVHcm91cDogbmFtZUdyb3VwXG4gICAgfTtcbn0pO1xuIiwiLyoqXG4gKiBUaGVzZSBvYmplY3RzIHN0b3JlIGRhdGEgYWJvdXQgTWF0aE1MIG5vZGVzLiBUaGlzIGlzIHRoZSBNYXRoTUwgZXF1aXZhbGVudFxuICogb2YgdGhlIHR5cGVzIGluIGRvbVRyZWUuanMuIFNpbmNlIE1hdGhNTCBoYW5kbGVzIGl0cyBvd24gcmVuZGVyaW5nLCBhbmRcbiAqIHNpbmNlIHdlJ3JlIG1haW5seSB1c2luZyBNYXRoTUwgdG8gaW1wcm92ZSBhY2Nlc3NpYmlsaXR5LCB3ZSBkb24ndCBtYW5hZ2VcbiAqIGFueSBvZiB0aGUgc3R5bGluZyBzdGF0ZSB0aGF0IHRoZSBwbGFpbiBET00gbm9kZXMgZG8uXG4gKlxuICogVGhlIGB0b05vZGVgIGFuZCBgdG9NYXJrdXBgIGZ1bmN0aW9ucyB3b3JrIHNpbWxhcmx5IHRvIGhvdyB0aGV5IGRvIGluXG4gKiBkb21UcmVlLmpzLCBjcmVhdGluZyBuYW1lc3BhY2VkIERPTSBub2RlcyBhbmQgSFRNTCB0ZXh0IG1hcmt1cCByZXNwZWN0aXZlbHkuXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBnZW5lcmFsIHB1cnBvc2UgTWF0aE1MIG5vZGUgb2YgYW55IHR5cGUuIFRoZVxuICogY29uc3RydWN0b3IgcmVxdWlyZXMgdGhlIHR5cGUgb2Ygbm9kZSB0byBjcmVhdGUgKGZvciBleGFtcGxlLCBgXCJtb1wiYCBvclxuICogYFwibXNwYWNlXCJgLCBjb3JyZXNwb25kaW5nIHRvIGA8bW8+YCBhbmQgYDxtc3BhY2U+YCB0YWdzKS5cbiAqL1xuZnVuY3Rpb24gTWF0aE5vZGUodHlwZSwgY2hpbGRyZW4pIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbn1cblxuLyoqXG4gKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiBhIE1hdGhNTCBub2RlLiBNYXRoTUwgZGVwZW5kcyBvbiBhdHRyaWJ1dGVzIHRvIGNvbnZleSBhXG4gKiBzZW1hbnRpYyBjb250ZW50LCBzbyB0aGlzIGlzIHVzZWQgaGVhdmlseS5cbiAqL1xuTWF0aE5vZGUucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIE1hdGhNTC1uYW1lc3BhY2VkIERPTSBlbGVtZW50LlxuICovXG5NYXRoTm9kZS5wcm90b3R5cGUudG9Ob2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCB0aGlzLnR5cGUpO1xuXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuXG4gKi9cbk1hdGhOb2RlLnByb3RvdHlwZS50b01hcmt1cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIjxcIiArIHRoaXMudHlwZTtcblxuICAgIC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArIFwiPVxcXCJcIjtcbiAgICAgICAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgICAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIj5cIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIjwvXCIgKyB0aGlzLnR5cGUgKyBcIj5cIjtcblxuICAgIHJldHVybiBtYXJrdXA7XG59O1xuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgcGllY2Ugb2YgdGV4dC5cbiAqL1xuZnVuY3Rpb24gVGV4dE5vZGUodGV4dCkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHRleHQgbm9kZSBpbnRvIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuVGV4dE5vZGUucHJvdG90eXBlLnRvTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gSFRNTCBtYXJrdXAgKHdoaWNoIGlzIGp1c3QgdGhlIHRleHQgaXRzZWxmKS5cbiAqL1xuVGV4dE5vZGUucHJvdG90eXBlLnRvTWFya3VwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVzY2FwZSh0aGlzLnRleHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWF0aE5vZGU6IE1hdGhOb2RlLFxuICAgIFRleHROb2RlOiBUZXh0Tm9kZVxufTtcbiIsIi8qKlxuICogVGhlIHJlc3VsdGluZyBwYXJzZSB0cmVlIG5vZGVzIG9mIHRoZSBwYXJzZSB0cmVlLlxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHByb3ZpZGUgcG9zaXRpb24gaW5mb3JtYXRpb24sIHNvIHRoYXQgYSBQYXJzZU5vZGUgY2FuXG4gKiBmdWxmaWwgYSByb2xlIHNpbWlsYXIgdG8gYSBUb2tlbiBpbiBlcnJvciByZXBvcnRpbmcuXG4gKiBGb3IgZGV0YWlscyBvbiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIHNlZSBUb2tlbiBjb25zdHJ1Y3Rvci5cbiAqIFByb3ZpZGluZyBzdWNoIGluZm9ybWF0aW9uIGNhbiBsZWFkIHRvIGJldHRlciBlcnJvciByZXBvcnRpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICB0eXBlICAgICAgIHR5cGUgb2Ygbm9kZSwgbGlrZSBlLmcuIFwib3JkZ3JvdXBcIlxuICogQHBhcmFtIHs/b2JqZWN0fSB2YWx1ZSAgICAgIHR5cGUtc3BlY2lmaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSAgbW9kZSAgICAgICBwYXJzZSBtb2RlIGluIGFjdGlvbiBmb3IgdGhpcyBub2RlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF0aFwiIG9yIFwidGV4dFwiXG4gKiBAcGFyYW0ge1Rva2VuPX0gZmlyc3RUb2tlbiAgZmlyc3QgdG9rZW4gb2YgdGhlIGlucHV0IGZvciB0aGlzIG5vZGUsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBvbWl0IHBvc2l0aW9uIGluZm9ybWF0aW9uIGlmIHVuc2V0XG4gKiBAcGFyYW0ge1Rva2VuPX0gbGFzdFRva2VuICAgbGFzdCB0b2tlbiBvZiB0aGUgaW5wdXQgZm9yIHRoaXMgbm9kZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGRlZmF1bHQgdG8gZmlyc3RUb2tlbiBpZiB1bnNldFxuICovXG5mdW5jdGlvbiBQYXJzZU5vZGUodHlwZSwgdmFsdWUsIG1vZGUsIGZpcnN0VG9rZW4sIGxhc3RUb2tlbikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgaWYgKGZpcnN0VG9rZW4gJiYgKCFsYXN0VG9rZW4gfHwgbGFzdFRva2VuLmxleGVyID09PSBmaXJzdFRva2VuLmxleGVyKSkge1xuICAgICAgICB0aGlzLmxleGVyID0gZmlyc3RUb2tlbi5sZXhlcjtcbiAgICAgICAgdGhpcy5zdGFydCA9IGZpcnN0VG9rZW4uc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gKGxhc3RUb2tlbiB8fCBmaXJzdFRva2VuKS5lbmQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQYXJzZU5vZGU6IFBhcnNlTm9kZVxufTtcblxuIiwiLyoqXG4gKiBQcm92aWRlcyBhIHNpbmdsZSBmdW5jdGlvbiBmb3IgcGFyc2luZyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyXG4gKiBUT0RPKGVtaWx5KTogUmVtb3ZlIHRoaXNcbiAqL1xuXG52YXIgUGFyc2VyID0gcmVxdWlyZShcIi4vUGFyc2VyXCIpO1xuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyLCB0aGVuIHJldHVybnMgdGhlIHBhcnNlZCByZXN1bHQuXG4gKi9cbnZhciBwYXJzZVRyZWUgPSBmdW5jdGlvbih0b1BhcnNlLCBzZXR0aW5ncykge1xuICAgIGlmICghKHR5cGVvZiB0b1BhcnNlID09PSAnc3RyaW5nJyB8fCB0b1BhcnNlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdLYVRlWCBjYW4gb25seSBwYXJzZSBzdHJpbmcgdHlwZWQgZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcih0b1BhcnNlLCBzZXR0aW5ncyk7XG5cbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlVHJlZTtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGhvbGRzIGEgbGlzdCBvZiBhbGwgbm8tYXJndW1lbnQgZnVuY3Rpb25zIGFuZCBzaW5nbGUtY2hhcmFjdGVyXG4gKiBzeW1ib2xzIChsaWtlICdhJyBvciAnOycpLlxuICpcbiAqIEZvciBlYWNoIG9mIHRoZSBzeW1ib2xzLCB0aGVyZSBhcmUgdGhyZWUgcHJvcGVydGllcyB0aGV5IGNhbiBoYXZlOlxuICogLSBmb250IChyZXF1aXJlZCk6IHRoZSBmb250IHRvIGJlIHVzZWQgZm9yIHRoaXMgc3ltYm9sLiBFaXRoZXIgXCJtYWluXCIgKHRoZVxuICAgICBub3JtYWwgZm9udCksIG9yIFwiYW1zXCIgKHRoZSBhbXMgZm9udHMpLlxuICogLSBncm91cCAocmVxdWlyZWQpOiB0aGUgUGFyc2VOb2RlIGdyb3VwIHR5cGUgdGhlIHN5bWJvbCBzaG91bGQgaGF2ZSAoaS5lLlxuICAgICBcInRleHRvcmRcIiwgXCJtYXRob3JkXCIsIGV0YykuXG4gICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vS2hhbi9LYVRlWC93aWtpL0V4YW1pbmluZy1UZVgjZ3JvdXAtdHlwZXNcbiAqIC0gcmVwbGFjZTogdGhlIGNoYXJhY3RlciB0aGF0IHRoaXMgc3ltYm9sIG9yIGZ1bmN0aW9uIHNob3VsZCBiZVxuICogICByZXBsYWNlZCB3aXRoIChpLmUuIFwiXFxwaGlcIiBoYXMgYSByZXBsYWNlIHZhbHVlIG9mIFwiXFx1MDNkNVwiLCB0aGUgcGhpXG4gKiAgIGNoYXJhY3RlciBpbiB0aGUgbWFpbiBmb250KS5cbiAqXG4gKiBUaGUgb3V0ZXJtb3N0IG1hcCBpbiB0aGUgdGFibGUgaW5kaWNhdGVzIHdoYXQgbW9kZSB0aGUgc3ltYm9scyBzaG91bGQgYmVcbiAqIGFjY2VwdGVkIGluIChlLmcuIFwibWF0aFwiIG9yIFwidGV4dFwiKS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYXRoOiB7fSxcbiAgICB0ZXh0OiB7fVxufTtcblxuZnVuY3Rpb24gZGVmaW5lU3ltYm9sKG1vZGUsIGZvbnQsIGdyb3VwLCByZXBsYWNlLCBuYW1lKSB7XG4gICAgbW9kdWxlLmV4cG9ydHNbbW9kZV1bbmFtZV0gPSB7XG4gICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgIGdyb3VwOiBncm91cCxcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZVxuICAgIH07XG59XG5cbi8vIFNvbWUgYWJicmV2aWF0aW9ucyBmb3IgY29tbW9ubHkgdXNlZCBzdHJpbmdzLlxuLy8gVGhpcyBoZWxwcyBtaW5pZnkgdGhlIGNvZGUsIGFuZCBhbHNvIHNwb3R0aW5nIHR5cG9zIHVzaW5nIGpzaGludC5cblxuLy8gbW9kZXM6XG52YXIgbWF0aCA9IFwibWF0aFwiO1xudmFyIHRleHQgPSBcInRleHRcIjtcblxuLy8gZm9udHM6XG52YXIgbWFpbiA9IFwibWFpblwiO1xudmFyIGFtcyA9IFwiYW1zXCI7XG5cbi8vIGdyb3VwczpcbnZhciBhY2NlbnQgPSBcImFjY2VudFwiO1xudmFyIGJpbiA9IFwiYmluXCI7XG52YXIgY2xvc2UgPSBcImNsb3NlXCI7XG52YXIgaW5uZXIgPSBcImlubmVyXCI7XG52YXIgbWF0aG9yZCA9IFwibWF0aG9yZFwiO1xudmFyIG9wID0gXCJvcFwiO1xudmFyIG9wZW4gPSBcIm9wZW5cIjtcbnZhciBwdW5jdCA9IFwicHVuY3RcIjtcbnZhciByZWwgPSBcInJlbFwiO1xudmFyIHNwYWNpbmcgPSBcInNwYWNpbmdcIjtcbnZhciB0ZXh0b3JkID0gXCJ0ZXh0b3JkXCI7XG5cbi8vIE5vdyBjb21lcyB0aGUgc3ltYm9sIHRhYmxlXG5cbi8vIFJlbGF0aW9uIFN5bWJvbHNcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2MVwiLCBcIlxcXFxlcXVpdlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI3YVwiLCBcIlxcXFxwcmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjdiXCIsIFwiXFxcXHN1Y2NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyM2NcIiwgXCJcXFxcc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmE1XCIsIFwiXFxcXHBlcnBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTJhYWZcIiwgXCJcXFxccHJlY2VxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyYWIwXCIsIFwiXFxcXHN1Y2NlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0M1wiLCBcIlxcXFxzaW1lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNmFcIiwgXCJcXFxcbGxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNmJcIiwgXCJcXFxcZ2dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNGRcIiwgXCJcXFxcYXN5bXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMjVcIiwgXCJcXFxccGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYzhcIiwgXCJcXFxcYm93dGllXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMzIzXCIsIFwiXFxcXHNtaWxlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjkxXCIsIFwiXFxcXHNxc3Vic2V0ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyOTJcIiwgXCJcXFxcc3FzdXBzZXRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI1MFwiLCBcIlxcXFxkb3RlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjMyMlwiLCBcIlxcXFxmcm93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwYlwiLCBcIlxcXFxuaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIxZFwiLCBcIlxcXFxwcm9wdG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYTJcIiwgXCJcXFxcdmRhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYTNcIiwgXCJcXFxcZGFzaHZcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMGJcIiwgXCJcXFxcb3duc1wiKTtcblxuLy8gUHVuY3R1YXRpb25cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBwdW5jdCwgXCJcXHUwMDJlXCIsIFwiXFxcXGxkb3RwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHB1bmN0LCBcIlxcdTIyYzVcIiwgXCJcXFxcY2RvdHBcIik7XG5cbi8vIE1pc2MgU3ltYm9sc1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyM1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyM1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEzNVwiLCBcIlxcXFxhbGVwaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMDBcIiwgXCJcXFxcZm9yYWxsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEwZlwiLCBcIlxcXFxoYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwM1wiLCBcIlxcXFxleGlzdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjA3XCIsIFwiXFxcXG5hYmxhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjY2ZFwiLCBcIlxcXFxmbGF0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExM1wiLCBcIlxcXFxlbGxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjZlXCIsIFwiXFxcXG5hdHVyYWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYzXCIsIFwiXFxcXGNsdWJzdWl0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExOFwiLCBcIlxcXFx3cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NmZcIiwgXCJcXFxcc2hhcnBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYyXCIsIFwiXFxcXGRpYW1vbmRzdWl0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExY1wiLCBcIlxcXFxSZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjFcIiwgXCJcXFxcaGVhcnRzdWl0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExMVwiLCBcIlxcXFxJbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjBcIiwgXCJcXFxcc3BhZGVzdWl0XCIpO1xuXG4vLyBNYXRoIGFuZCBUZXh0XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMjFcIiwgXCJcXFxcZGRhZ1wiKTtcblxuLy8gTGFyZ2UgRGVsaW1pdGVyc1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTIzYjFcIiwgXCJcXFxccm1vdXN0YWNoZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIzYjBcIiwgXCJcXFxcbG1vdXN0YWNoZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyN2VmXCIsIFwiXFxcXHJncm91cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTI3ZWVcIiwgXCJcXFxcbGdyb3VwXCIpO1xuXG4vLyBCaW5hcnkgT3BlcmF0b3JzXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTNcIiwgXCJcXFxcbXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTZcIiwgXCJcXFxcb21pbnVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjhlXCIsIFwiXFxcXHVwbHVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjkzXCIsIFwiXFxcXHNxY2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE3XCIsIFwiXFxcXGFzdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5NFwiLCBcIlxcXFxzcWN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjVlZlwiLCBcIlxcXFxiaWdjaXJjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE5XCIsIFwiXFxcXGJ1bGxldFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnZ2VyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjQwXCIsIFwiXFxcXHdyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyYTNmXCIsIFwiXFxcXGFtYWxnXCIpO1xuXG4vLyBBcnJvdyBTeW1ib2xzXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjVcIiwgXCJcXFxcbG9uZ2xlZnRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMFwiLCBcIlxcXFxMZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjhcIiwgXCJcXFxcTG9uZ2xlZnRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmNlwiLCBcIlxcXFxsb25ncmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMlwiLCBcIlxcXFxSaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y5XCIsIFwiXFxcXExvbmdyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk0XCIsIFwiXFxcXGxlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y3XCIsIFwiXFxcXGxvbmdsZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkNFwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmYVwiLCBcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYTZcIiwgXCJcXFxcbWFwc3RvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2ZjXCIsIFwiXFxcXGxvbmdtYXBzdG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTdcIiwgXCJcXFxcbmVhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFhOVwiLCBcIlxcXFxob29rbGVmdGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWFhXCIsIFwiXFxcXGhvb2tyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk4XCIsIFwiXFxcXHNlYXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYmNcIiwgXCJcXFxcbGVmdGhhcnBvb251cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFjMFwiLCBcIlxcXFxyaWdodGhhcnBvb251cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5OVwiLCBcIlxcXFxzd2Fycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWJkXCIsIFwiXFxcXGxlZnRoYXJwb29uZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFjMVwiLCBcIlxcXFxyaWdodGhhcnBvb25kb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk2XCIsIFwiXFxcXG53YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxY2NcIiwgXCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIik7XG5cbi8vIEFNUyBOZWdhdGVkIEJpbmFyeSBSZWxhdGlvbnNcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZlXCIsIFwiXFxcXG5sZXNzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTBcIiwgXCJcXFxcbmxlcXNsYW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTFcIiwgXCJcXFxcbmxlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4N1wiLCBcIlxcXFxsbmVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNjhcIiwgXCJcXFxcbG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAwY1wiLCBcIlxcXFxsdmVydG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlNlwiLCBcIlxcXFxsbnNpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTg5XCIsIFwiXFxcXGxuYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODBcIiwgXCJcXFxcbnByZWNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlMFwiLCBcIlxcXFxucHJlY2VxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZThcIiwgXCJcXFxccHJlY25zaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiOVwiLCBcIlxcXFxwcmVjbmFwcHJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQxXCIsIFwiXFxcXG5zaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAwNlwiLCBcIlxcXFxuc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyNFwiLCBcIlxcXFxubWlkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWNcIiwgXCJcXFxcbnZkYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWRcIiwgXCJcXFxcbnZEYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWFcIiwgXCJcXFxcbnRyaWFuZ2xlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmVjXCIsIFwiXFxcXG50cmlhbmdsZWxlZnRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhhXCIsIFwiXFxcXHN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDFhXCIsIFwiXFxcXHZhcnN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNiXCIsIFwiXFxcXHN1YnNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxN1wiLCBcIlxcXFx2YXJzdWJzZXRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNmZcIiwgXCJcXFxcbmd0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDBmXCIsIFwiXFxcXG5nZXFzbGFudFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDBlXCIsIFwiXFxcXG5nZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODhcIiwgXCJcXFxcZ25lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjY5XCIsIFwiXFxcXGduZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGRcIiwgXCJcXFxcZ3ZlcnRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTdcIiwgXCJcXFxcZ25zaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4YVwiLCBcIlxcXFxnbmFwcHJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjgxXCIsIFwiXFxcXG5zdWNjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTFcIiwgXCJcXFxcbnN1Y2NlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU5XCIsIFwiXFxcXHN1Y2Nuc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYmFcIiwgXCJcXFxcc3VjY25hcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0NlwiLCBcIlxcXFxuY29uZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDA3XCIsIFwiXFxcXG5zaG9ydHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMjZcIiwgXCJcXFxcbnBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWZcIiwgXCJcXFxcblZEYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWJcIiwgXCJcXFxcbnRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlZFwiLCBcIlxcXFxudHJpYW5nbGVyaWdodGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMThcIiwgXCJcXFxcbnN1cHNldGVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhiXCIsIFwiXFxcXHN1cHNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDFiXCIsIFwiXFxcXHZhcnN1cHNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNjXCIsIFwiXFxcXHN1cHNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxOVwiLCBcIlxcXFx2YXJzdXBzZXRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWVcIiwgXCJcXFxcblZkYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYjVcIiwgXCJcXFxccHJlY25lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiNlwiLCBcIlxcXFxzdWNjbmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDE2XCIsIFwiXFxcXG5zdWJzZXRlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiNFwiLCBcIlxcXFx1bmxoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmI1XCIsIFwiXFxcXHVucmhkXCIpO1xuXG4vLyBBTVMgTmVnYXRlZCBBcnJvd3NcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMTlhXCIsIFwiXFxcXG5sZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5YlwiLCBcIlxcXFxucmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWNkXCIsIFwiXFxcXG5MZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjZlwiLCBcIlxcXFxuUmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFlXCIsIFwiXFxcXG5sZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWNlXCIsIFwiXFxcXG5MZWZ0cmlnaHRhcnJvd1wiKTtcblxuLy8gQU1TIE1pc2NcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWIzXCIsIFwiXFxcXHZhcnRyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTBmXCIsIFwiXFxcXGhzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViZFwiLCBcIlxcXFx0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1Y2FcIiwgXCJcXFxcbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjRjOFwiLCBcIlxcXFxjaXJjbGVkU1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhZVwiLCBcIlxcXFxjaXJjbGVkUlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjIyMVwiLCBcIlxcXFxtZWFzdXJlZGFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjA0XCIsIFwiXFxcXG5leGlzdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMjdcIiwgXCJcXFxcbWhvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTMyXCIsIFwiXFxcXEZpbnZcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxNDFcIiwgXCJcXFxcR2FtZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDA2YlwiLCBcIlxcXFxCYmJrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMDM1XCIsIFwiXFxcXGJhY2twcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViMlwiLCBcIlxcXFxibGFja3RyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWJjXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWEwXCIsIFwiXFxcXGJsYWNrc3F1YXJlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyOWViXCIsIFwiXFxcXGJsYWNrbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjYwNVwiLCBcIlxcXFxiaWdzdGFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjIyXCIsIFwiXFxcXHNwaGVyaWNhbGFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjAxXCIsIFwiXFxcXGNvbXBsZW1lbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAwZjBcIiwgXCJcXFxcZXRoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNTcxXCIsIFwiXFxcXGRpYWd1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjU3MlwiLCBcIlxcXFxkaWFnZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjVhMVwiLCBcIlxcXFxzcXVhcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1YTFcIiwgXCJcXFxcQm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWNhXCIsIFwiXFxcXERpYW1vbmRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAwYTVcIiwgXCJcXFxceWVuXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNzEzXCIsIFwiXFxcXGNoZWNrbWFya1wiKTtcblxuLy8gQU1TIEhlYnJld1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTM2XCIsIFwiXFxcXGJldGhcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMzhcIiwgXCJcXFxcZGFsZXRoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTM3XCIsIFwiXFxcXGdpbWVsXCIpO1xuXG4vLyBBTVMgR3JlZWtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDNkZFwiLCBcIlxcXFxkaWdhbW1hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUwM2YwXCIsIFwiXFxcXHZhcmthcHBhXCIpO1xuXG4vLyBBTVMgRGVsaW1pdGVyc1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgb3BlbiwgXCJcXHUyNTBjXCIsIFwiXFxcXHVsY29ybmVyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgY2xvc2UsIFwiXFx1MjUxMFwiLCBcIlxcXFx1cmNvcm5lclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIG9wZW4sIFwiXFx1MjUxNFwiLCBcIlxcXFxsbGNvcm5lclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGNsb3NlLCBcIlxcdTI1MThcIiwgXCJcXFxcbHJjb3JuZXJcIik7XG5cbi8vIEFNUyBCaW5hcnkgUmVsYXRpb25zXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2NlwiLCBcIlxcXFxsZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhN2RcIiwgXCJcXFxcbGVxc2xhbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE5NVwiLCBcIlxcXFxlcXNsYW50bGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcyXCIsIFwiXFxcXGxlc3NzaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4NVwiLCBcIlxcXFxsZXNzYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNGFcIiwgXCJcXFxcYXBwcm94ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJkNlwiLCBcIlxcXFxsZXNzZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDhcIiwgXCJcXFxcbGxsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzZcIiwgXCJcXFxcbGVzc2d0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRhXCIsIFwiXFxcXGxlc3NlcWd0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYThiXCIsIFwiXFxcXGxlc3NlcXFndHJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1MVwiLCBcIlxcXFxkb3RlcWRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUzXCIsIFwiXFxcXHJpc2luZ2RvdHNlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUyXCIsIFwiXFxcXGZhbGxpbmdkb3RzZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzZFwiLCBcIlxcXFxiYWNrc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyY2RcIiwgXCJcXFxcYmFja3NpbWVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYzVcIiwgXCJcXFxcc3Vic2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDBcIiwgXCJcXFxcU3Vic2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOGZcIiwgXCJcXFxcc3FzdWJzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3Y1wiLCBcIlxcXFxwcmVjY3VybHllcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRlXCIsIFwiXFxcXGN1cmx5ZXFwcmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2VcIiwgXCJcXFxccHJlY3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI3XCIsIFwiXFxcXHByZWNhcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiMlwiLCBcIlxcXFx2YXJ0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiNFwiLCBcIlxcXFx0cmlhbmdsZWxlZnRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmE4XCIsIFwiXFxcXHZEYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWFcIiwgXCJcXFxcVnZkYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIzMjNcIiwgXCJcXFxcc21hbGxzbWlsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMzIyXCIsIFwiXFxcXHNtYWxsZnJvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0ZlwiLCBcIlxcXFxidW1wZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0ZVwiLCBcIlxcXFxCdW1wZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2N1wiLCBcIlxcXFxnZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhN2VcIiwgXCJcXFxcZ2Vxc2xhbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE5NlwiLCBcIlxcXFxlcXNsYW50Z3RyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzNcIiwgXCJcXFxcZ3Ryc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODZcIiwgXCJcXFxcZ3RyYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDdcIiwgXCJcXFxcZ3RyZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDlcIiwgXCJcXFxcZ2dnXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzdcIiwgXCJcXFxcZ3RybGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRiXCIsIFwiXFxcXGd0cmVxbGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYThjXCIsIFwiXFxcXGd0cmVxcWxlc3NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1NlwiLCBcIlxcXFxlcWNpcmNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1N1wiLCBcIlxcXFxjaXJjZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1Y1wiLCBcIlxcXFx0cmlhbmdsZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzY1wiLCBcIlxcXFx0aGlja3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQ4XCIsIFwiXFxcXHRoaWNrYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYzZcIiwgXCJcXFxcc3Vwc2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDFcIiwgXCJcXFxcU3Vwc2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOTBcIiwgXCJcXFxcc3FzdXBzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3ZFwiLCBcIlxcXFxzdWNjY3VybHllcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRmXCIsIFwiXFxcXGN1cmx5ZXFzdWNjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2ZcIiwgXCJcXFxcc3VjY3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI4XCIsIFwiXFxcXHN1Y2NhcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiM1wiLCBcIlxcXFx2YXJ0cmlhbmdsZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjVcIiwgXCJcXFxcdHJpYW5nbGVyaWdodGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYTlcIiwgXCJcXFxcVmRhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxzaG9ydG1pZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI1XCIsIFwiXFxcXHNob3J0cGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2Y1wiLCBcIlxcXFxiZXR3ZWVuXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDRcIiwgXCJcXFxccGl0Y2hmb3JrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMWRcIiwgXCJcXFxcdmFycHJvcHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTI1YzBcIiwgXCJcXFxcYmxhY2t0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzNFwiLCBcIlxcXFx0aGVyZWZvcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIwZFwiLCBcIlxcXFxiYWNrZXBzaWxvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWI2XCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjM1XCIsIFwiXFxcXGJlY2F1c2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkOFwiLCBcIlxcXFxsbGxlc3NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkOVwiLCBcIlxcXFxnZ2d0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmIyXCIsIFwiXFxcXGxoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmIzXCIsIFwiXFxcXHJoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQyXCIsIFwiXFxcXGVxc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmM4XCIsIFwiXFxcXEpvaW5cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1MVwiLCBcIlxcXFxEb3RlcVwiKTtcblxuLy8gQU1TIEJpbmFyeSBPcGVyYXRvcnNcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjE0XCIsIFwiXFxcXGRvdHBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjIxNlwiLCBcIlxcXFxzbWFsbHNldG1pbnVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDJcIiwgXCJcXFxcQ2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDNcIiwgXCJcXFxcQ3VwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTJhNWVcIiwgXCJcXFxcZG91YmxlYmFyd2VkZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5ZlwiLCBcIlxcXFxib3htaW51c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjllXCIsIFwiXFxcXGJveHBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjN1wiLCBcIlxcXFxkaXZpZGVvbnRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYzlcIiwgXCJcXFxcbHRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2FcIiwgXCJcXFxccnRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2JcIiwgXCJcXFxcbGVmdHRocmVldGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjY1wiLCBcIlxcXFxyaWdodHRocmVldGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjZlwiLCBcIlxcXFxjdXJseXdlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2VcIiwgXCJcXFxcY3VybHl2ZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5ZFwiLCBcIlxcXFxjaXJjbGVkZGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjliXCIsIFwiXFxcXGNpcmNsZWRhc3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjNVwiLCBcIlxcXFxjZW50ZXJkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiYVwiLCBcIlxcXFxpbnRlcmNhbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQyXCIsIFwiXFxcXGRvdWJsZWNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQzXCIsIFwiXFxcXGRvdWJsZWN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmEwXCIsIFwiXFxcXGJveHRpbWVzXCIpO1xuXG4vLyBBTVMgQXJyb3dzXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFlMlwiLCBcIlxcXFxkYXNocmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWUwXCIsIFwiXFxcXGRhc2hsZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjN1wiLCBcIlxcXFxsZWZ0bGVmdGFycm93c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWM2XCIsIFwiXFxcXGxlZnRyaWdodGFycm93c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWRhXCIsIFwiXFxcXExsZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5ZVwiLCBcIlxcXFx0d29oZWFkbGVmdGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYTJcIiwgXCJcXFxcbGVmdGFycm93dGFpbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFiXCIsIFwiXFxcXGxvb3BhcnJvd2xlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjYlwiLCBcIlxcXFxsZWZ0cmlnaHRoYXJwb29uc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWI2XCIsIFwiXFxcXGN1cnZlYXJyb3dsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmFcIiwgXCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjBcIiwgXCJcXFxcTHNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzhcIiwgXCJcXFxcdXB1cGFycm93c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWJmXCIsIFwiXFxcXHVwaGFycG9vbmxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjM1wiLCBcIlxcXFxkb3duaGFycG9vbmxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiOFwiLCBcIlxcXFxtdWx0aW1hcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFkXCIsIFwiXFxcXGxlZnRyaWdodHNxdWlnYXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjOVwiLCBcIlxcXFxyaWdodHJpZ2h0YXJyb3dzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzRcIiwgXCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYTBcIiwgXCJcXFxcdHdvaGVhZHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhM1wiLCBcIlxcXFxyaWdodGFycm93dGFpbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFjXCIsIFwiXFxcXGxvb3BhcnJvd3JpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjdcIiwgXCJcXFxcY3VydmVhcnJvd3JpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmJcIiwgXCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWIxXCIsIFwiXFxcXFJzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWNhXCIsIFwiXFxcXGRvd25kb3duYXJyb3dzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmVcIiwgXCJcXFxcdXBoYXJwb29ucmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjMlwiLCBcIlxcXFxkb3duaGFycG9vbnJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZGRcIiwgXCJcXFxccmlnaHRzcXVpZ2Fycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZGRcIiwgXCJcXFxcbGVhZHN0b1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWRiXCIsIFwiXFxcXFJyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmVcIiwgXCJcXFxccmVzdHJpY3Rpb25cIik7XG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJgXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIyMFwiLCBcIlxcXFxhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMWVcIiwgXCJcXFxcaW5mdHlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDMyXCIsIFwiXFxcXHByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjViM1wiLCBcIlxcXFx0cmlhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOTNcIiwgXCJcXFxcR2FtbWFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMzk0XCIsIFwiXFxcXERlbHRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5OFwiLCBcIlxcXFxUaGV0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOWJcIiwgXCJcXFxcTGFtYmRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5ZVwiLCBcIlxcXFxYaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTBcIiwgXCJcXFxcUGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2EzXCIsIFwiXFxcXFNpZ21hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhNVwiLCBcIlxcXFxVcHNpbG9uXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhNlwiLCBcIlxcXFxQaGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2E4XCIsIFwiXFxcXFBzaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTlcIiwgXCJcXFxcT21lZ2FcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGFjXCIsIFwiXFxcXG5lZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYWNcIiwgXCJcXFxcbG5vdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyYTRcIiwgXCJcXFxcdG9wXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjJhNVwiLCBcIlxcXFxib3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjA1XCIsIFwiXFxcXGVtcHR5c2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjA1XCIsIFwiXFxcXHZhcm5vdGhpbmdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2IxXCIsIFwiXFxcXGFscGhhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiMlwiLCBcIlxcXFxiZXRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiM1wiLCBcIlxcXFxnYW1tYVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjRcIiwgXCJcXFxcZGVsdGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2Y1XCIsIFwiXFxcXGVwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I2XCIsIFwiXFxcXHpldGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I3XCIsIFwiXFxcXGV0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjhcIiwgXCJcXFxcdGhldGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I5XCIsIFwiXFxcXGlvdGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JhXCIsIFwiXFxcXGthcHBhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiYlwiLCBcIlxcXFxsYW1iZGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JjXCIsIFwiXFxcXG11XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiZFwiLCBcIlxcXFxudVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYmVcIiwgXCJcXFxceGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJvXCIsIFwiXFxcXG9taWNyb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2MwXCIsIFwiXFxcXHBpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjMVwiLCBcIlxcXFxyaG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2MzXCIsIFwiXFxcXHNpZ21hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjNFwiLCBcIlxcXFx0YXVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M1XCIsIFwiXFxcXHVwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2Q1XCIsIFwiXFxcXHBoaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzdcIiwgXCJcXFxcY2hpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjOFwiLCBcIlxcXFxwc2lcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M5XCIsIFwiXFxcXG9tZWdhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiNVwiLCBcIlxcXFx2YXJlcHNpbG9uXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNkMVwiLCBcIlxcXFx2YXJ0aGV0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzZDZcIiwgXCJcXFxcdmFycGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2YxXCIsIFwiXFxcXHZhcnJob1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzJcIiwgXCJcXFxcdmFyc2lnbWFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M2XCIsIFwiXFxcXHZhcnBoaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxN1wiLCBcIipcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIitcIiwgXCIrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjEyXCIsIFwiLVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjJjNVwiLCBcIlxcXFxjZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE4XCIsIFwiXFxcXGNpcmNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTAwZjdcIiwgXCJcXFxcZGl2XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUwMGIxXCIsIFwiXFxcXHBtXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUwMGQ3XCIsIFwiXFxcXHRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjI5XCIsIFwiXFxcXGNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyYVwiLCBcIlxcXFxjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc2V0bWludXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcbGFuZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyOFwiLCBcIlxcXFxsb3JcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcd2VkZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjhcIiwgXCJcXFxcdmVlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIxYVwiLCBcIlxcXFxzdXJkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiKFwiLCBcIihcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJbXCIsIFwiW1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTI3ZThcIiwgXCJcXFxcbGFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiXFx1MjIyM1wiLCBcIlxcXFxsdmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIyMjVcIiwgXCJcXFxcbFZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiKVwiLCBcIilcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXVwiLCBcIl1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiP1wiLCBcIj9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiIVwiLCBcIiFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXFx1MjdlOVwiLCBcIlxcXFxyYW5nbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXFx1MjIyM1wiLCBcIlxcXFxydmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyMjI1XCIsIFwiXFxcXHJWZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI9XCIsIFwiPVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPFwiLCBcIjxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIj5cIiwgXCI+XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI6XCIsIFwiOlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0OFwiLCBcIlxcXFxhcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNDVcIiwgXCJcXFxcY29uZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTBcIiwgXCJcXFxcZ2V0c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPlwiLCBcIlxcXFxndFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwOFwiLCBcIlxcXFxpblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwOVwiLCBcIlxcXFxub3RpblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI4MlwiLCBcIlxcXFxzdWJzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODNcIiwgXCJcXFxcc3Vwc2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjg2XCIsIFwiXFxcXHN1YnNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjg3XCIsIFwiXFxcXHN1cHNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODhcIiwgXCJcXFxcbnN1YnNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODlcIiwgXCJcXFxcbnN1cHNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmE4XCIsIFwiXFxcXG1vZGVsc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MFwiLCBcIlxcXFxsZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNjRcIiwgXCJcXFxcbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNjRcIiwgXCJcXFxcbGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI8XCIsIFwiXFxcXGx0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjYwXCIsIFwiXFxcXG5lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjYwXCIsIFwiXFxcXG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MlwiLCBcIlxcXFxyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTkyXCIsIFwiXFxcXHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzFcIiwgXCJcXFxcbmdlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcwXCIsIFwiXFxcXG5sZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxcIVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJ+XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHNwYWNpbmcsIG51bGwsIFwiXFxcXCxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxcOlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBudWxsLCBcIlxcXFw7XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHNwYWNpbmcsIG51bGwsIFwiXFxcXGVuc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxccXF1YWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxccXVhZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiLFwiLCBcIixcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiO1wiLCBcIjtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiOlwiLCBcIlxcXFxjb2xvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmJjXCIsIFwiXFxcXGJhcndlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYmJcIiwgXCJcXFxcdmVlYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk5XCIsIFwiXFxcXG9kb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTVcIiwgXCJcXFxcb3BsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTdcIiwgXCJcXFxcb3RpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwMlwiLCBcIlxcXFxwYXJ0aWFsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk4XCIsIFwiXFxcXG9zbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjlhXCIsIFwiXFxcXGNpcmNsZWRjaXJjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYTFcIiwgXCJcXFxcYm94ZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyNWIzXCIsIFwiXFxcXGJpZ3RyaWFuZ2xldXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YmRcIiwgXCJcXFxcYmlndHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjJjNFwiLCBcIlxcXFxkaWFtb25kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMmM2XCIsIFwiXFxcXHN0YXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YzNcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyNWI5XCIsIFwiXFxcXHRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwie1wiLCBcIlxcXFxsYnJhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwifVwiLCBcIlxcXFxyYnJhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJbXCIsIFwiXFxcXGxicmFja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJdXCIsIFwiXFxcXHJicmFja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIzMGFcIiwgXCJcXFxcbGZsb29yXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTIzMGJcIiwgXCJcXFxccmZsb29yXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiXFx1MjMwOFwiLCBcIlxcXFxsY2VpbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyMzA5XCIsIFwiXFxcXHJjZWlsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFxcXFwiLCBcIlxcXFxiYWNrc2xhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjIzXCIsIFwifFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjNcIiwgXCJcXFxcdmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjVcIiwgXCJcXFxcfFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjVcIiwgXCJcXFxcVmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MVwiLCBcIlxcXFx1cGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWQxXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTNcIiwgXCJcXFxcZG93bmFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWQzXCIsIFwiXFxcXERvd25hcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5NVwiLCBcIlxcXFx1cGRvd25hcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkNVwiLCBcIlxcXFxVcGRvd25hcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMjEwXCIsIFwiXFxcXGNvcHJvZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMmMxXCIsIFwiXFxcXGJpZ3ZlZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMmMwXCIsIFwiXFxcXGJpZ3dlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGgsIG9wLCBcIlxcdTJhMDRcIiwgXCJcXFxcYmlndXBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjJjMlwiLCBcIlxcXFxiaWdjYXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjJjM1wiLCBcIlxcXFxiaWdjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxpbnRvcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMjJjXCIsIFwiXFxcXGlpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyZFwiLCBcIlxcXFxpaWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMjBmXCIsIFwiXFxcXHByb2RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIxMVwiLCBcIlxcXFxzdW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MmEwMlwiLCBcIlxcXFxiaWdvdGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MmEwMVwiLCBcIlxcXFxiaWdvcGx1c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyYTAwXCIsIFwiXFxcXGJpZ29kb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyZVwiLCBcIlxcXFxvaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGgsIG9wLCBcIlxcdTJhMDZcIiwgXCJcXFxcYmlnc3FjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxzbWFsbGludFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXHRleHRlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXG1hdGhlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXGxkb3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbGRvdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgaW5uZXIsIFwiXFx1MjJlZlwiLCBcIlxcXFxjZG90c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgXCJcXHUyMmYxXCIsIFwiXFxcXGRkb3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjJlZVwiLCBcIlxcXFx2ZG90c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDBiNFwiLCBcIlxcXFxhY3V0ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDA2MFwiLCBcIlxcXFxncmF2ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDBhOFwiLCBcIlxcXFxkZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMDdlXCIsIFwiXFxcXHRpbGRlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMGFmXCIsIFwiXFxcXGJhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkOFwiLCBcIlxcXFxicmV2ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjN1wiLCBcIlxcXFxjaGVja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDA1ZVwiLCBcIlxcXFxoYXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTIwZDdcIiwgXCJcXFxcdmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmQ5XCIsIFwiXFxcXGRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAxMzFcIiwgXCJcXFxcaW1hdGhcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwMjM3XCIsIFwiXFxcXGptYXRoXCIpO1xuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiLS1cIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiLS0tXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxOFwiLCBcImBcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwiJ1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWNcIiwgXCJgYFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWRcIiwgXCInJ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYjBcIiwgXCJcXFxcZGVncmVlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFxkZWdyZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwMGEzXCIsIFwiXFxcXHBvdW5kc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjcyMFwiLCBcIlxcXFxtYWx0ZXNlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIGFtcywgdGV4dG9yZCwgXCJcXHUyNzIwXCIsIFwiXFxcXG1hbHRlc2VcIik7XG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCIgXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIn5cIik7XG5cbi8vIFRoZXJlIGFyZSBsb3RzIG9mIHN5bWJvbHMgd2hpY2ggYXJlIHRoZSBzYW1lLCBzbyB3ZSBhZGQgdGhlbSBpbiBhZnRlcndhcmRzLlxudmFyIGk7XG52YXIgY2g7XG5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gbWF0aCBtb2RlXG52YXIgbWF0aFRleHRTeW1ib2xzID0gXCIwMTIzNDU2Nzg5L0AuXFxcIlwiO1xuZm9yIChpID0gMDsgaSA8IG1hdGhUZXh0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gbWF0aFRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGVcbnZhciB0ZXh0U3ltYm9scyA9IFwiMDEyMzQ1Njc4OSFAKigpLT0rW11cXFwiOzo/Ly4sXCI7XG5mb3IgKGkgPSAwOyBpIDwgdGV4dFN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICBjaCA9IHRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGUsIGFuZCBtYXRob3JkcyBpbiBtYXRoIG1vZGVcbnZhciBsZXR0ZXJzID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XG5mb3IgKGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gbGV0dGVycy5jaGFyQXQoaSk7XG4gICAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCBjaCk7XG4gICAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbi8vIExhdGluLTEgbGV0dGVyc1xuZm9yIChpID0gMHgwMEMwOyBpIDw9IDB4MDBENjsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgY2gpO1xufVxuXG5mb3IgKGkgPSAweDAwRDg7IGkgPD0gMHgwMEY2OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbmZvciAoaSA9IDB4MDBGODsgaSA8PSAweDAwRkY7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQ3lyaWxsaWNcbmZvciAoaSA9IDB4MDQxMDsgaSA8PSAweDA0NEY7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gVW5pY29kZSB2ZXJzaW9ucyBvZiBleGlzdGluZyBjaGFyYWN0ZXJzXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwi4oCTXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxNFwiLCBcIuKAlFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCLigJhcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwi4oCZXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxY1wiLCBcIuKAnFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWRcIiwgXCLigJ1cIik7XG4iLCJ2YXIgaGFuZ3VsUmVnZXggPSAvW1xcdUFDMDAtXFx1RDdBRl0vO1xuXG4vLyBUaGlzIHJlZ2V4IGNvbWJpbmVzXG4vLyAtIEhpcmFnYW5hOiBbXFx1MzA0MC1cXHUzMDlGXVxuLy8gLSBLYXRha2FuYTogW1xcdTMwQTAtXFx1MzBGRl1cbi8vIC0gQ0pLIGlkZW9ncmFtczogW1xcdTRFMDAtXFx1OUZBRl1cbi8vIC0gSGFuZ3VsIHN5bGxhYmxlczogW1xcdUFDMDAtXFx1RDdBRl1cbi8vIE5vdGFibHkgbWlzc2luZyBhcmUgaGFsZndpZHRoIEthdGFrYW5hIGFuZCBSb21hbmppIGdseXBocy5cbnZhciBjamtSZWdleCA9XG4gICAgL1tcXHUzMDQwLVxcdTMwOUZdfFtcXHUzMEEwLVxcdTMwRkZdfFtcXHU0RTAwLVxcdTlGQUZdfFtcXHVBQzAwLVxcdUQ3QUZdLztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY2prUmVnZXg6IGNqa1JlZ2V4LFxuICAgIGhhbmd1bFJlZ2V4OiBoYW5ndWxSZWdleFxufTtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGEgbGlzdCBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB3aGljaCBhcmUgdXNlZnVsIGluIG90aGVyXG4gKiBmaWxlcy5cbiAqL1xuXG4vKipcbiAqIFByb3ZpZGUgYW4gYGluZGV4T2ZgIGZ1bmN0aW9uIHdoaWNoIHdvcmtzIGluIElFOCwgYnV0IGRlZmVycyB0byBuYXRpdmUgaWZcbiAqIHBvc3NpYmxlLlxuICovXG52YXIgbmF0aXZlSW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xudmFyIGluZGV4T2YgPSBmdW5jdGlvbihsaXN0LCBlbGVtKSB7XG4gICAgaWYgKGxpc3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGxpc3QuaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikge1xuICAgICAgICByZXR1cm4gbGlzdC5pbmRleE9mKGVsZW0pO1xuICAgIH1cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGwgPSBsaXN0Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAobGlzdFtpXSA9PT0gZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhbiBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbiBhIGxpc3RcbiAqL1xudmFyIGNvbnRhaW5zID0gZnVuY3Rpb24obGlzdCwgZWxlbSkge1xuICAgIHJldHVybiBpbmRleE9mKGxpc3QsIGVsZW0pICE9PSAtMTtcbn07XG5cbi8qKlxuICogUHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUgaWYgYSBzZXR0aW5nIGlzIHVuZGVmaW5lZFxuICovXG52YXIgZGVmbHQgPSBmdW5jdGlvbihzZXR0aW5nLCBkZWZhdWx0SWZVbmRlZmluZWQpIHtcbiAgICByZXR1cm4gc2V0dGluZyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdElmVW5kZWZpbmVkIDogc2V0dGluZztcbn07XG5cbi8vIGh5cGhlbmF0ZSBhbmQgZXNjYXBlIGFkYXB0ZWQgZnJvbSBGYWNlYm9vaydzIFJlYWN0IHVuZGVyIEFwYWNoZSAyIGxpY2Vuc2VcblxudmFyIHVwcGVyY2FzZSA9IC8oW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHVwcGVyY2FzZSwgXCItJDFcIikudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBFU0NBUEVfTE9PS1VQID0ge1xuICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgXCI+XCI6IFwiJmd0O1wiLFxuICAgIFwiPFwiOiBcIiZsdDtcIixcbiAgICBcIlxcXCJcIjogXCImcXVvdDtcIixcbiAgICBcIidcIjogXCImI3gyNztcIlxufTtcblxudmFyIEVTQ0FQRV9SRUdFWCA9IC9bJj48XCInXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVyKG1hdGNoKSB7XG4gICAgcmV0dXJuIEVTQ0FQRV9MT09LVVBbbWF0Y2hdO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZSh0ZXh0KSB7XG4gICAgcmV0dXJuIChcIlwiICsgdGV4dCkucmVwbGFjZShFU0NBUEVfUkVHRVgsIGVzY2FwZXIpO1xufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgYSBET00gZWxlbWVudCBpbiBhbGwgc3VwcG9ydGVkXG4gKiBicm93c2Vycy4gTm90ZSB0aGF0IHdlIGRvbid0IGRlZmluZSB0aGlzIGlmIHRoZXJlIGlzIG5vIGRvY3VtZW50LlxuICovXG52YXIgc2V0VGV4dENvbnRlbnQ7XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHRlc3ROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgaWYgKFwidGV4dENvbnRlbnRcIiBpbiB0ZXN0Tm9kZSkge1xuICAgICAgICBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uKG5vZGUsIHRleHQpIHtcbiAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24obm9kZSwgdGV4dCkge1xuICAgICAgICAgICAgbm9kZS5pbm5lclRleHQgPSB0ZXh0O1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNsZWFyIGEgbm9kZS5cbiAqL1xuZnVuY3Rpb24gY2xlYXJOb2RlKG5vZGUpIHtcbiAgICBzZXRUZXh0Q29udGVudChub2RlLCBcIlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29udGFpbnM6IGNvbnRhaW5zLFxuICAgIGRlZmx0OiBkZWZsdCxcbiAgICBlc2NhcGU6IGVzY2FwZSxcbiAgICBoeXBoZW5hdGU6IGh5cGhlbmF0ZSxcbiAgICBpbmRleE9mOiBpbmRleE9mLFxuICAgIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgICBjbGVhck5vZGU6IGNsZWFyTm9kZVxufTtcbiIsIi8qKiBAZmxvdyAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0UmVsb2NhdGFibGUocmUpIHtcbiAgLy8gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb3VsZCB1c2UgYSBXZWFrTWFwIGluc3RlYWQgb2YgYW4gZXhwYW5kby5cbiAgaWYgKCFyZS5fX21hdGNoQXRSZWxvY2F0YWJsZSkge1xuICAgIC8vIERpc2p1bmN0aW9ucyBhcmUgdGhlIGxvd2VzdC1wcmVjZWRlbmNlIG9wZXJhdG9yLCBzbyB3ZSBjYW4gbWFrZSBhbnlcbiAgICAvLyBwYXR0ZXJuIG1hdGNoIHRoZSBlbXB0eSBzdHJpbmcgYnkgYXBwZW5kaW5nIGB8KClgIHRvIGl0OlxuICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1wYXR0ZXJuc1xuICAgIHZhciBzb3VyY2UgPSByZS5zb3VyY2UgKyBcInwoKVwiO1xuXG4gICAgLy8gV2UgYWx3YXlzIG1ha2UgdGhlIG5ldyByZWdleCBnbG9iYWwuXG4gICAgdmFyIGZsYWdzID0gXCJnXCIgKyAocmUuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAocmUubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiKSArIChyZS51bmljb2RlID8gXCJ1XCIgOiBcIlwiKVxuICAgIC8vIHN0aWNreSAoLy4uLi95KSBkb2Vzbid0IG1ha2Ugc2Vuc2UgaW4gY29uanVuY3Rpb24gd2l0aCBvdXIgcmVsb2NhdGlvblxuICAgIC8vIGxvZ2ljLCBzbyB3ZSBpZ25vcmUgaXQgaGVyZS5cbiAgICA7XG5cbiAgICByZS5fX21hdGNoQXRSZWxvY2F0YWJsZSA9IG5ldyBSZWdFeHAoc291cmNlLCBmbGFncyk7XG4gIH1cbiAgcmV0dXJuIHJlLl9fbWF0Y2hBdFJlbG9jYXRhYmxlO1xufVxuXG5mdW5jdGlvbiBtYXRjaEF0KHJlLCBzdHIsIHBvcykge1xuICBpZiAocmUuZ2xvYmFsIHx8IHJlLnN0aWNreSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1hdGNoQXQoLi4uKTogT25seSBub24tZ2xvYmFsIHJlZ2V4ZXMgYXJlIHN1cHBvcnRlZFwiKTtcbiAgfVxuICB2YXIgcmVsb2MgPSBnZXRSZWxvY2F0YWJsZShyZSk7XG4gIHJlbG9jLmxhc3RJbmRleCA9IHBvcztcbiAgdmFyIG1hdGNoID0gcmVsb2MuZXhlYyhzdHIpO1xuICAvLyBMYXN0IGNhcHR1cmluZyBncm91cCBpcyBvdXIgc2VudGluZWwgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVnZXhcbiAgLy8gbWF0Y2hlZCBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uXG4gIGlmIChtYXRjaFttYXRjaC5sZW5ndGggLSAxXSA9PSBudWxsKSB7XG4gICAgLy8gT3JpZ2luYWwgcmVnZXggbWF0Y2hlZC5cbiAgICBtYXRjaC5sZW5ndGggPSBtYXRjaC5sZW5ndGggLSAxO1xuICAgIHJldHVybiBtYXRjaDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoQXQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBwdXNoLWJhc2VkIGV2ZW50IG9yIHZhbHVlIHRoYXQgYW4ge0BsaW5rIE9ic2VydmFibGV9IGNhbiBlbWl0LlxuICogVGhpcyBjbGFzcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBvcGVyYXRvcnMgdGhhdCBtYW5hZ2Ugbm90aWZpY2F0aW9ucyxcbiAqIGxpa2Uge0BsaW5rIG1hdGVyaWFsaXplfSwge0BsaW5rIGRlbWF0ZXJpYWxpemV9LCB7QGxpbmsgb2JzZXJ2ZU9ufSwgYW5kXG4gKiBvdGhlcnMuIEJlc2lkZXMgd3JhcHBpbmcgdGhlIGFjdHVhbCBkZWxpdmVyZWQgdmFsdWUsIGl0IGFsc28gYW5ub3RhdGVzIGl0XG4gKiB3aXRoIG1ldGFkYXRhIG9mLCBmb3IgaW5zdGFuY2UsIHdoYXQgdHlwZSBvZiBwdXNoIG1lc3NhZ2UgaXQgaXMgKGBuZXh0YCxcbiAqIGBlcnJvcmAsIG9yIGBjb21wbGV0ZWApLlxuICpcbiAqIEBzZWUge0BsaW5rIG1hdGVyaWFsaXplfVxuICogQHNlZSB7QGxpbmsgZGVtYXRlcmlhbGl6ZX1cbiAqIEBzZWUge0BsaW5rIG9ic2VydmVPbn1cbiAqXG4gKiBAY2xhc3MgTm90aWZpY2F0aW9uPFQ+XG4gKi9cbnZhciBOb3RpZmljYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vdGlmaWNhdGlvbihraW5kLCB2YWx1ZSwgZXJyb3IpIHtcbiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBraW5kID09PSAnTic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGl2ZXJzIHRvIHRoZSBnaXZlbiBgb2JzZXJ2ZXJgIHRoZSB2YWx1ZSB3cmFwcGVkIGJ5IHRoaXMgTm90aWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ9IG9ic2VydmVyXG4gICAgICogQHJldHVyblxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUub2JzZXJ2ZSA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5lcnJvciAmJiBvYnNlcnZlci5lcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYnNlcnZlci5jb21wbGV0ZSAmJiBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBzb21lIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2tzLCBkZWxpdmVyIHRoZSB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGVcbiAgICAgKiBjdXJyZW50IE5vdGlmaWNhdGlvbiB0byB0aGUgY29ycmVjdGx5IGNvcnJlc3BvbmRpbmcgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IHZvaWR9IG5leHQgQW4gT2JzZXJ2ZXIgYG5leHRgIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBhbnkpOiB2b2lkfSBbZXJyb3JdIEFuIE9ic2VydmVyIGBlcnJvcmAgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIEFuIE9ic2VydmVyIGBjb21wbGV0ZWAgY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUuZG8gPSBmdW5jdGlvbiAobmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBraW5kID0gdGhpcy5raW5kO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ04nOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0ICYmIG5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IgJiYgZXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGxldGUgJiYgY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGFrZXMgYW4gT2JzZXJ2ZXIgb3IgaXRzIGluZGl2aWR1YWwgY2FsbGJhY2sgZnVuY3Rpb25zLCBhbmQgY2FsbHMgYG9ic2VydmVgXG4gICAgICogb3IgYGRvYCBtZXRob2RzIGFjY29yZGluZ2x5LlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBuZXh0T3JPYnNlcnZlciBBbiBPYnNlcnZlciBvclxuICAgICAqIHRoZSBgbmV4dGAgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IGFueSk6IHZvaWR9IFtlcnJvcl0gQW4gT2JzZXJ2ZXIgYGVycm9yYCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gQW4gT2JzZXJ2ZXIgYGNvbXBsZXRlYCBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5hY2NlcHQgPSBmdW5jdGlvbiAobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgJiYgdHlwZW9mIG5leHRPck9ic2VydmVyLm5leHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9ic2VydmUobmV4dE9yT2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG8obmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IGp1c3QgZGVsaXZlcnMgdGhlIG5vdGlmaWNhdGlvbiByZXByZXNlbnRlZFxuICAgICAqIGJ5IHRoaXMgTm90aWZpY2F0aW9uIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLnRvT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGtpbmQgPSB0aGlzLmtpbmQ7XG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLm9mKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnRocm93KHRoaXMuZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmVtcHR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmV4cGVjdGVkIG5vdGlmaWNhdGlvbiBraW5kIHZhbHVlJyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHNob3J0Y3V0IHRvIGNyZWF0ZSBhIE5vdGlmaWNhdGlvbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBgbmV4dGAgZnJvbSBhXG4gICAgICogZ2l2ZW4gdmFsdWUuXG4gICAgICogQHBhcmFtIHtUfSB2YWx1ZSBUaGUgYG5leHRgIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge05vdGlmaWNhdGlvbjxUPn0gVGhlIFwibmV4dFwiIE5vdGlmaWNhdGlvbiByZXByZXNlbnRpbmcgdGhlXG4gICAgICogYXJndW1lbnQuXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm90aWZpY2F0aW9uKCdOJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnVuZGVmaW5lZFZhbHVlTm90aWZpY2F0aW9uO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBzaG9ydGN1dCB0byBjcmVhdGUgYSBOb3RpZmljYXRpb24gaW5zdGFuY2Ugb2YgdGhlIHR5cGUgYGVycm9yYCBmcm9tIGFcbiAgICAgKiBnaXZlbiBlcnJvci5cbiAgICAgKiBAcGFyYW0ge2FueX0gW2Vycl0gVGhlIGBlcnJvcmAgZXJyb3IuXG4gICAgICogQHJldHVybiB7Tm90aWZpY2F0aW9uPFQ+fSBUaGUgXCJlcnJvclwiIE5vdGlmaWNhdGlvbiByZXByZXNlbnRpbmcgdGhlXG4gICAgICogYXJndW1lbnQuXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLmNyZWF0ZUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbignRScsIHVuZGVmaW5lZCwgZXJyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgc2hvcnRjdXQgdG8gY3JlYXRlIGEgTm90aWZpY2F0aW9uIGluc3RhbmNlIG9mIHRoZSB0eXBlIGBjb21wbGV0ZWAuXG4gICAgICogQHJldHVybiB7Tm90aWZpY2F0aW9uPGFueT59IFRoZSB2YWx1ZWxlc3MgXCJjb21wbGV0ZVwiIE5vdGlmaWNhdGlvbi5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24uY3JlYXRlQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlTm90aWZpY2F0aW9uO1xuICAgIH07XG4gICAgTm90aWZpY2F0aW9uLmNvbXBsZXRlTm90aWZpY2F0aW9uID0gbmV3IE5vdGlmaWNhdGlvbignQycpO1xuICAgIE5vdGlmaWNhdGlvbi51bmRlZmluZWRWYWx1ZU5vdGlmaWNhdGlvbiA9IG5ldyBOb3RpZmljYXRpb24oJ04nLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiBOb3RpZmljYXRpb247XG59KCkpO1xuZXhwb3J0cy5Ob3RpZmljYXRpb24gPSBOb3RpZmljYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob3RpZmljYXRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi91dGlsL3Jvb3QnKTtcbnZhciB0b1N1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vdXRpbC90b1N1YnNjcmliZXInKTtcbnZhciBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYW55IHNldCBvZiB2YWx1ZXMgb3ZlciBhbnkgYW1vdW50IG9mIHRpbWUuIFRoaXMgdGhlIG1vc3QgYmFzaWMgYnVpbGRpbmcgYmxvY2tcbiAqIG9mIFJ4SlMuXG4gKlxuICogQGNsYXNzIE9ic2VydmFibGU8VD5cbiAqL1xudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZSB0aGUgZnVuY3Rpb24gdGhhdCBpcyAgY2FsbGVkIHdoZW4gdGhlIE9ic2VydmFibGUgaXNcbiAgICAgKiBpbml0aWFsbHkgc3Vic2NyaWJlZCB0by4gVGhpcyBmdW5jdGlvbiBpcyBnaXZlbiBhIFN1YnNjcmliZXIsIHRvIHdoaWNoIG5ldyB2YWx1ZXNcbiAgICAgKiBjYW4gYmUgYG5leHRgZWQsIG9yIGFuIGBlcnJvcmAgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gcmFpc2UgYW4gZXJyb3IsIG9yXG4gICAgICogYGNvbXBsZXRlYCBjYW4gYmUgY2FsbGVkIHRvIG5vdGlmeSBvZiBhIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlLCB3aXRoIHRoaXMgT2JzZXJ2YWJsZSBhcyB0aGUgc291cmNlLCBhbmQgdGhlIHBhc3NlZFxuICAgICAqIG9wZXJhdG9yIGRlZmluZWQgYXMgdGhlIG5ldyBvYnNlcnZhYmxlJ3Mgb3BlcmF0b3IuXG4gICAgICogQG1ldGhvZCBsaWZ0XG4gICAgICogQHBhcmFtIHtPcGVyYXRvcn0gb3BlcmF0b3IgdGhlIG9wZXJhdG9yIGRlZmluaW5nIHRoZSBvcGVyYXRpb24gdG8gdGFrZSBvbiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IG9ic2VydmFibGUgd2l0aCB0aGUgT3BlcmF0b3IgYXBwbGllZFxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm9wZXJhdG9yO1xuICAgICAgICB2YXIgc2luayA9IHRvU3Vic2NyaWJlcl8xLnRvU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBvcGVyYXRvci5jYWxsKHNpbmssIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpbmsuYWRkKHRoaXMuX3RyeVN1YnNjcmliZShzaW5rKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc2luay5zeW5jRXJyb3JWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2luaztcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShzaW5rKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgc2luay5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGZvckVhY2hcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0IGEgaGFuZGxlciBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBvYnNlcnZhYmxlXG4gICAgICogQHBhcmFtIHtQcm9taXNlQ29uc3RydWN0b3J9IFtQcm9taXNlQ3Rvcl0gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBQcm9taXNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgZWl0aGVyIHJlc29sdmVzIG9uIG9ic2VydmFibGUgY29tcGxldGlvbiBvclxuICAgICAqICByZWplY3RzIHdpdGggdGhlIGhhbmRsZWQgZXJyb3JcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKG5leHQsIFByb21pc2VDdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgICAgIGlmIChyb290XzEucm9vdC5SeCAmJiByb290XzEucm9vdC5SeC5jb25maWcgJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocm9vdF8xLnJvb3QuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFByb21pc2UgaW1wbCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc3Vic2NyaXB0aW9uLCB0aGVuIHdlIGNhbiBzdXJtaXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXh0IGhhbmRsaW5nIGlzIGFzeW5jaHJvbm91cy4gQW55IGVycm9ycyB0aHJvd25cbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBiZSByZWplY3RlZCBleHBsaWNpdGx5IGFuZCB1bnN1YnNjcmliZSBtdXN0IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxlZCBtYW51YWxseVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgTk8gc3Vic2NyaXB0aW9uLCB0aGVuIHdlJ3JlIGdldHRpbmcgYSBuZXh0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgc3luY2hyb25vdXNseSBkdXJpbmcgc3Vic2NyaXB0aW9uLiBXZSBjYW4ganVzdCBjYWxsIGl0LlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBlcnJvcnMsIE9ic2VydmFibGUncyBgc3Vic2NyaWJlYCB3aWxsIGVuc3VyZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5zdWJzY3JpcHRpb24gbG9naWMgaXMgY2FsbGVkLCB0aGVuIHN5bmNocm9ub3VzbHkgcmV0aHJvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIHRoYXQsIFByb21pc2Ugd2lsbCB0cmFwIHRoZSBlcnJvciBhbmQgc2VuZCBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBkb3duIHRoZSByZWplY3Rpb24gcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVqZWN0LCByZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFuIGludGVyb3AgcG9pbnQgZGVmaW5lZCBieSB0aGUgZXM3LW9ic2VydmFibGUgc3BlYyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG4gICAgICogQG1ldGhvZCBTeW1ib2wub2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IHRoaXMgaW5zdGFuY2Ugb2YgdGhlIG9ic2VydmFibGVcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZVtvYnNlcnZhYmxlXzEuJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBIQUNLOiBTaW5jZSBUeXBlU2NyaXB0IGluaGVyaXRzIHN0YXRpYyBwcm9wZXJ0aWVzIHRvbywgd2UgaGF2ZSB0b1xuICAgIC8vIGZpZ2h0IGFnYWluc3QgVHlwZVNjcmlwdCBoZXJlIHNvIFN1YmplY3QgY2FuIGhhdmUgYSBkaWZmZXJlbnQgc3RhdGljIGNyZWF0ZSBzaWduYXR1cmVcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbGQgT2JzZXJ2YWJsZSBieSBjYWxsaW5nIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZT8gdGhlIHN1YnNjcmliZXIgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYSBuZXcgY29sZCBvYnNlcnZhYmxlXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmUpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KCkpO1xuZXhwb3J0cy5PYnNlcnZhYmxlID0gT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVtcHR5ID0ge1xuICAgIGNsb3NlZDogdHJ1ZSxcbiAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24gKGVycikgeyB0aHJvdyBlcnI7IH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBbiBleGVjdXRpb24gY29udGV4dCBhbmQgYSBkYXRhIHN0cnVjdHVyZSB0byBvcmRlciB0YXNrcyBhbmQgc2NoZWR1bGUgdGhlaXJcbiAqIGV4ZWN1dGlvbi4gUHJvdmlkZXMgYSBub3Rpb24gb2YgKHBvdGVudGlhbGx5IHZpcnR1YWwpIHRpbWUsIHRocm91Z2ggdGhlXG4gKiBgbm93KClgIGdldHRlciBtZXRob2QuXG4gKlxuICogRWFjaCB1bml0IG9mIHdvcmsgaW4gYSBTY2hlZHVsZXIgaXMgY2FsbGVkIGFuIHtAbGluayBBY3Rpb259LlxuICpcbiAqIGBgYHRzXG4gKiBjbGFzcyBTY2hlZHVsZXIge1xuICogICBub3coKTogbnVtYmVyO1xuICogICBzY2hlZHVsZSh3b3JrLCBkZWxheT8sIHN0YXRlPyk6IFN1YnNjcmlwdGlvbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBjbGFzcyBTY2hlZHVsZXJcbiAqL1xudmFyIFNjaGVkdWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2NoZWR1bGVyKFNjaGVkdWxlckFjdGlvbiwgbm93KSB7XG4gICAgICAgIGlmIChub3cgPT09IHZvaWQgMCkgeyBub3cgPSBTY2hlZHVsZXIubm93OyB9XG4gICAgICAgIHRoaXMuU2NoZWR1bGVyQWN0aW9uID0gU2NoZWR1bGVyQWN0aW9uO1xuICAgICAgICB0aGlzLm5vdyA9IG5vdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGEgZnVuY3Rpb24sIGB3b3JrYCwgZm9yIGV4ZWN1dGlvbi4gTWF5IGhhcHBlbiBhdCBzb21lIHBvaW50IGluXG4gICAgICogdGhlIGZ1dHVyZSwgYWNjb3JkaW5nIHRvIHRoZSBgZGVsYXlgIHBhcmFtZXRlciwgaWYgc3BlY2lmaWVkLiBNYXkgYmUgcGFzc2VkXG4gICAgICogc29tZSBjb250ZXh0IG9iamVjdCwgYHN0YXRlYCwgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGB3b3JrYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBnaXZlbiBhcmd1bWVudHMgd2lsbCBiZSBwcm9jZXNzZWQgYW4gc3RvcmVkIGFzIGFuIEFjdGlvbiBvYmplY3QgaW4gYVxuICAgICAqIHF1ZXVlIG9mIGFjdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0YXRlOiA/VCk6ID9TdWJzY3JpcHRpb259IHdvcmsgQSBmdW5jdGlvbiByZXByZXNlbnRpbmcgYVxuICAgICAqIHRhc2ssIG9yIHNvbWUgdW5pdCBvZiB3b3JrIHRvIGJlIGV4ZWN1dGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gVGltZSB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHdvcmssIHdoZXJlIHRoZVxuICAgICAqIHRpbWUgdW5pdCBpcyBpbXBsaWNpdCBhbmQgZGVmaW5lZCBieSB0aGUgU2NoZWR1bGVyIGl0c2VsZi5cbiAgICAgKiBAcGFyYW0ge1R9IFtzdGF0ZV0gU29tZSBjb250ZXh0dWFsIGRhdGEgdGhhdCB0aGUgYHdvcmtgIGZ1bmN0aW9uIHVzZXMgd2hlblxuICAgICAqIGNhbGxlZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn0gQSBzdWJzY3JpcHRpb24gaW4gb3JkZXIgdG8gYmUgYWJsZSB0byB1bnN1YnNjcmliZVxuICAgICAqIHRoZSBzY2hlZHVsZWQgd29yay5cbiAgICAgKi9cbiAgICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHdvcmssIGRlbGF5LCBzdGF0ZSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLlNjaGVkdWxlckFjdGlvbih0aGlzLCB3b3JrKS5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xuICAgIH07XG4gICAgU2NoZWR1bGVyLm5vdyA9IERhdGUubm93ID8gRGF0ZS5ub3cgOiBmdW5jdGlvbiAoKSB7IHJldHVybiArbmV3IERhdGUoKTsgfTtcbiAgICByZXR1cm4gU2NoZWR1bGVyO1xufSgpKTtcbmV4cG9ydHMuU2NoZWR1bGVyID0gU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG52YXIgT2JzZXJ2ZXJfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2ZXInKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGludGVyZmFjZSBhbmQgZXh0ZW5kcyB0aGVcbiAqIHtAbGluayBTdWJzY3JpcHRpb259IGNsYXNzLiBXaGlsZSB0aGUge0BsaW5rIE9ic2VydmVyfSBpcyB0aGUgcHVibGljIEFQSSBmb3JcbiAqIGNvbnN1bWluZyB0aGUgdmFsdWVzIG9mIGFuIHtAbGluayBPYnNlcnZhYmxlfSwgYWxsIE9ic2VydmVycyBnZXQgY29udmVydGVkIHRvXG4gKiBhIFN1YnNjcmliZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgU3Vic2NyaXB0aW9uLWxpa2UgY2FwYWJpbGl0aWVzIHN1Y2ggYXNcbiAqIGB1bnN1YnNjcmliZWAuIFN1YnNjcmliZXIgaXMgYSBjb21tb24gdHlwZSBpbiBSeEpTLCBhbmQgY3J1Y2lhbCBmb3JcbiAqIGltcGxlbWVudGluZyBvcGVyYXRvcnMsIGJ1dCBpdCBpcyByYXJlbHkgdXNlZCBhcyBhIHB1YmxpYyBBUEkuXG4gKlxuICogQGNsYXNzIFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBbZGVzdGluYXRpb25Pck5leHRdIEEgcGFydGlhbGx5XG4gICAgICogZGVmaW5lZCBPYnNlcnZlciBvciBhIGBuZXh0YCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlcihkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IE9ic2VydmVyXzEuZW1wdHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbk9yTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25Pck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbk9yTmV4dCBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbk9yTmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uYWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIGZhY3RvcnkgZm9yIGEgU3Vic2NyaWJlciwgZ2l2ZW4gYSAocG90ZW50aWFsbHkgcGFydGlhbCkgZGVmaW5pdGlvblxuICAgICAqIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oeDogP1QpOiB2b2lkfSBbbmV4dF0gVGhlIGBuZXh0YCBjYWxsYmFjayBvZiBhbiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHJldHVybiB7U3Vic2NyaWJlcjxUPn0gQSBTdWJzY3JpYmVyIHdyYXBwaW5nIHRoZSAocGFydGlhbGx5IGRlZmluZWQpXG4gICAgICogT2JzZXJ2ZXIgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcihuZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBuZXh0YCBmcm9tXG4gICAgICogdGhlIE9ic2VydmFibGUsIHdpdGggYSB2YWx1ZS4gVGhlIE9ic2VydmFibGUgbWF5IGNhbGwgdGhpcyBtZXRob2QgMCBvciBtb3JlXG4gICAgICogdGltZXMuXG4gICAgICogQHBhcmFtIHtUfSBbdmFsdWVdIFRoZSBgbmV4dGAgdmFsdWUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2YgdHlwZSBgZXJyb3JgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhbiBhdHRhY2hlZCB7QGxpbmsgRXJyb3J9LiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdFxuICAgICAqIHRoZSBPYnNlcnZhYmxlIGhhcyBleHBlcmllbmNlZCBhbiBlcnJvciBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHthbnl9IFtlcnJdIFRoZSBgZXJyb3JgIGV4Y2VwdGlvbi5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIGEgdmFsdWVsZXNzIG5vdGlmaWNhdGlvbiBvZiB0eXBlXG4gICAgICogYGNvbXBsZXRlYCBmcm9tIHRoZSBPYnNlcnZhYmxlLiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdCB0aGUgT2JzZXJ2YWJsZVxuICAgICAqIGhhcyBmaW5pc2hlZCBzZW5kaW5nIHB1c2gtYmFzZWQgbm90aWZpY2F0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cztcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IF9wYXJlbnRzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVyO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3Vic2NyaWJlciA9IFN1YnNjcmliZXI7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhZmVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIoX3BhcmVudFN1YnNjcmliZXIsIG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBfcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9ic2VydmVyT3JOZXh0KSkge1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ic2VydmVyT3JOZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQubmV4dDtcbiAgICAgICAgICAgIGVycm9yID0gb2JzZXJ2ZXJPck5leHQuZXJyb3I7XG4gICAgICAgICAgICBjb21wbGV0ZSA9IG9ic2VydmVyT3JOZXh0LmNvbXBsZXRlO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKGNvbnRleHQudW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoY29udGV4dC51bnN1YnNjcmliZS5iaW5kKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSB0aGlzLnVuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIH1cbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMuX25leHQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX25leHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9uZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgdGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yVW5zdWIgPSBmdW5jdGlvbiAoZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yU2V0RXJyb3IgPSBmdW5jdGlvbiAocGFyZW50LCBmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICBfcGFyZW50U3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0FycmF5Jyk7XG52YXIgaXNPYmplY3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc09iamVjdCcpO1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0Z1bmN0aW9uJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvcicpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGlzcG9zYWJsZSByZXNvdXJjZSwgc3VjaCBhcyB0aGUgZXhlY3V0aW9uIG9mIGFuIE9ic2VydmFibGUuIEFcbiAqIFN1YnNjcmlwdGlvbiBoYXMgb25lIGltcG9ydGFudCBtZXRob2QsIGB1bnN1YnNjcmliZWAsIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRcbiAqIGFuZCBqdXN0IGRpc3Bvc2VzIHRoZSByZXNvdXJjZSBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uXG4gKlxuICogQWRkaXRpb25hbGx5LCBzdWJzY3JpcHRpb25zIG1heSBiZSBncm91cGVkIHRvZ2V0aGVyIHRocm91Z2ggdGhlIGBhZGQoKWBcbiAqIG1ldGhvZCwgd2hpY2ggd2lsbCBhdHRhY2ggYSBjaGlsZCBTdWJzY3JpcHRpb24gdG8gdGhlIGN1cnJlbnQgU3Vic2NyaXB0aW9uLlxuICogV2hlbiBhIFN1YnNjcmlwdGlvbiBpcyB1bnN1YnNjcmliZWQsIGFsbCBpdHMgY2hpbGRyZW4gKGFuZCBpdHMgZ3JhbmRjaGlsZHJlbilcbiAqIHdpbGwgYmUgdW5zdWJzY3JpYmVkIGFzIHdlbGwuXG4gKlxuICogQGNsYXNzIFN1YnNjcmlwdGlvblxuICovXG52YXIgU3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFt1bnN1YnNjcmliZV0gQSBmdW5jdGlvbiBkZXNjcmliaW5nIGhvdyB0b1xuICAgICAqIHBlcmZvcm0gdGhlIGRpc3Bvc2FsIG9mIHJlc291cmNlcyB3aGVuIHRoZSBgdW5zdWJzY3JpYmVgIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIFN1YnNjcmlwdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHVuc3Vic2NyaWJlZC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi4gTWF5LCBmb3IgaW5zdGFuY2UsIGNhbmNlbFxuICAgICAqIGFuIG9uZ29pbmcgT2JzZXJ2YWJsZSBleGVjdXRpb24gb3IgY2FuY2VsIGFueSBvdGhlciB0eXBlIG9mIHdvcmsgdGhhdFxuICAgICAqIHN0YXJ0ZWQgd2hlbiB0aGUgU3Vic2NyaXB0aW9uIHdhcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3JzO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cywgX3Vuc3Vic2NyaWJlID0gX2EuX3Vuc3Vic2NyaWJlLCBfc3Vic2NyaXB0aW9ucyA9IF9hLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBudWxsO1xuICAgICAgICAvLyBudWxsIG91dCBfc3Vic2NyaXB0aW9ucyBmaXJzdCBzbyBhbnkgY2hpbGQgc3Vic2NyaXB0aW9ucyB0aGF0IGF0dGVtcHRcbiAgICAgICAgLy8gdG8gcmVtb3ZlIHRoZW1zZWx2ZXMgZnJvbSB0aGlzIHN1YnNjcmlwdGlvbiB3aWxsIG5vb3BcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgbGVuID0gX3BhcmVudHMgPyBfcGFyZW50cy5sZW5ndGggOiAwO1xuICAgICAgICAvLyBpZiB0aGlzLl9wYXJlbnQgaXMgbnVsbCwgdGhlbiBzbyBpcyB0aGlzLl9wYXJlbnRzLCBhbmQgd2VcbiAgICAgICAgLy8gZG9uJ3QgaGF2ZSB0byByZW1vdmUgb3Vyc2VsdmVzIGZyb20gYW55IHBhcmVudCBzdWJzY3JpcHRpb25zLlxuICAgICAgICB3aGlsZSAoX3BhcmVudCkge1xuICAgICAgICAgICAgX3BhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAvLyBpZiB0aGlzLl9wYXJlbnRzIGlzIG51bGwgb3IgaW5kZXggPj0gbGVuLFxuICAgICAgICAgICAgLy8gdGhlbiBfcGFyZW50IGlzIHNldCB0byBudWxsLCBhbmQgdGhlIGxvb3AgZXhpdHNcbiAgICAgICAgICAgIF9wYXJlbnQgPSArK2luZGV4IDwgbGVuICYmIF9wYXJlbnRzW2luZGV4XSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihfdW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKF91bnN1YnNjcmliZSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IChlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvciA/XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUuZXJyb3JzKSA6IFtlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkoX3N1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgbGVuID0gX3N1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gX3N1YnNjcmlwdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdF8xLmlzT2JqZWN0KHN1YikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWFsID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChzdWIudW5zdWJzY3JpYmUpLmNhbGwoc3ViKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWFsID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVyci5lcnJvcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Vycm9ycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0ZWFyIGRvd24gdG8gYmUgY2FsbGVkIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUoKSBvZiB0aGlzXG4gICAgICogU3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRlYXIgZG93biBiZWluZyBhZGRlZCBpcyBhIHN1YnNjcmlwdGlvbiB0aGF0IGlzIGFscmVhZHlcbiAgICAgKiB1bnN1YnNjcmliZWQsIGlzIHRoZSBzYW1lIHJlZmVyZW5jZSBgYWRkYCBpcyBiZWluZyBjYWxsZWQgb24sIG9yIGlzXG4gICAgICogYFN1YnNjcmlwdGlvbi5FTVBUWWAsIGl0IHdpbGwgbm90IGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBzdWJzY3JpcHRpb24gaXMgYWxyZWFkeSBpbiBhbiBgY2xvc2VkYCBzdGF0ZSwgdGhlIHBhc3NlZFxuICAgICAqIHRlYXIgZG93biBsb2dpYyB3aWxsIGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUZWFyZG93bkxvZ2ljfSB0ZWFyZG93biBUaGUgYWRkaXRpb25hbCBsb2dpYyB0byBleGVjdXRlIG9uXG4gICAgICogdGVhcmRvd24uXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufSBSZXR1cm5zIHRoZSBTdWJzY3JpcHRpb24gdXNlZCBvciBjcmVhdGVkIHRvIGJlXG4gICAgICogYWRkZWQgdG8gdGhlIGlubmVyIHN1YnNjcmlwdGlvbnMgbGlzdC4gVGhpcyBTdWJzY3JpcHRpb24gY2FuIGJlIHVzZWQgd2l0aFxuICAgICAqIGByZW1vdmUoKWAgdG8gcmVtb3ZlIHRoZSBwYXNzZWQgdGVhcmRvd24gbG9naWMgZnJvbSB0aGUgaW5uZXIgc3Vic2NyaXB0aW9uc1xuICAgICAqIGxpc3QuXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGVhcmRvd24pIHtcbiAgICAgICAgaWYgKCF0ZWFyZG93biB8fCAodGVhcmRvd24gPT09IFN1YnNjcmlwdGlvbi5FTVBUWSkpIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlYXJkb3duID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGVhcmRvd247XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHRlYXJkb3duKSB7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0ZWFyZG93bik7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2xvc2VkIHx8IHR5cGVvZiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb24uX2FkZFBhcmVudCAhPT0gJ2Z1bmN0aW9uJyAvKiBxdWFjayBxdWFjayAqLykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5fc3Vic2NyaXB0aW9ucyA9IFt0bXBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgdGVhcmRvd24gJyArIHRlYXJkb3duICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zIHx8ICh0aGlzLl9zdWJzY3JpcHRpb25zID0gW10pO1xuICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLl9hZGRQYXJlbnQodGhpcyk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgU3Vic2NyaXB0aW9uIGZyb20gdGhlIGludGVybmFsIGxpc3Qgb2Ygc3Vic2NyaXB0aW9ucyB0aGF0IHdpbGxcbiAgICAgKiB1bnN1YnNjcmliZSBkdXJpbmcgdGhlIHVuc3Vic2NyaWJlIHByb2Nlc3Mgb2YgdGhpcyBTdWJzY3JpcHRpb24uXG4gICAgICogQHBhcmFtIHtTdWJzY3JpcHRpb259IHN1YnNjcmlwdGlvbiBUaGUgc3Vic2NyaXB0aW9uIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX2FkZFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgX3BhcmVudCA9IF9hLl9wYXJlbnQsIF9wYXJlbnRzID0gX2EuX3BhcmVudHM7XG4gICAgICAgIGlmICghX3BhcmVudCB8fCBfcGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwYXJlbnQsIG9yIHRoZSBuZXcgcGFyZW50IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBwYXJlbnQsIHRoZW4gc2V0IHRoaXMuX3BhcmVudCB0byB0aGUgbmV3IHBhcmVudC5cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghX3BhcmVudHMpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBvbmUgcGFyZW50LCBidXQgbm90IG11bHRpcGxlLCBhbGxvY2F0ZSBhbiBBcnJheSB0b1xuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHJlc3Qgb2YgdGhlIHBhcmVudCBTdWJzY3JpcHRpb25zLlxuICAgICAgICAgICAgdGhpcy5fcGFyZW50cyA9IFtwYXJlbnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9wYXJlbnRzLmluZGV4T2YocGFyZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoZSBuZXcgcGFyZW50IHRvIHRoZSBfcGFyZW50cyBsaXN0IGlmIGl0J3Mgbm90IGFscmVhZHkgdGhlcmUuXG4gICAgICAgICAgICBfcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5FTVBUWSA9IChmdW5jdGlvbiAoZW1wdHkpIHtcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0obmV3IFN1YnNjcmlwdGlvbigpKSk7XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbjtcbmZ1bmN0aW9uIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvcnMpIHtcbiAgICByZXR1cm4gZXJyb3JzLnJlZHVjZShmdW5jdGlvbiAoZXJycywgZXJyKSB7IHJldHVybiBlcnJzLmNvbmNhdCgoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpID8gZXJyLmVycm9ycyA6IGVycik7IH0sIFtdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmlwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZnJvbUV2ZW50XzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2Zyb21FdmVudCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZnJvbUV2ZW50ID0gZnJvbUV2ZW50XzEuZnJvbUV2ZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkZWJvdW5jZVRpbWVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RlYm91bmNlVGltZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRlYm91bmNlVGltZSA9IGRlYm91bmNlVGltZV8xLmRlYm91bmNlVGltZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlVGltZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZG9fMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RvJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZG8gPSBkb18xLl9kbztcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5fZG8gPSBkb18xLl9kbztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBtYXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21hcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm1hcCA9IG1hcF8xLm1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgb2JzZXJ2ZU9uXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9vYnNlcnZlT24nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5vYnNlcnZlT24gPSBvYnNlcnZlT25fMS5vYnNlcnZlT247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZlT24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmouYWRkTGlzdGVuZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzSlF1ZXJ5U3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmoub24gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5vZmYgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc05vZGVMaXN0KHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0b1N0cmluZy5jYWxsKHNvdXJjZU9iaikgPT09ICdbb2JqZWN0IE5vZGVMaXN0XSc7XG59XG5mdW5jdGlvbiBpc0hUTUxDb2xsZWN0aW9uKHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0b1N0cmluZy5jYWxsKHNvdXJjZU9iaikgPT09ICdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXSc7XG59XG5mdW5jdGlvbiBpc0V2ZW50VGFyZ2V0KHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0eXBlb2Ygc291cmNlT2JqLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5yZW1vdmVFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBGcm9tRXZlbnRPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnJvbUV2ZW50T2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGcm9tRXZlbnRPYnNlcnZhYmxlKHNvdXJjZU9iaiwgZXZlbnROYW1lLCBzZWxlY3Rvciwgb3B0aW9ucykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zb3VyY2VPYmogPSBzb3VyY2VPYmo7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgZXZlbnRzIG9mIGEgc3BlY2lmaWMgdHlwZSBjb21pbmcgZnJvbSB0aGVcbiAgICAgKiBnaXZlbiBldmVudCB0YXJnZXQuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q3JlYXRlcyBhbiBPYnNlcnZhYmxlIGZyb20gRE9NIGV2ZW50cywgb3IgTm9kZVxuICAgICAqIEV2ZW50RW1pdHRlciBldmVudHMgb3Igb3RoZXJzLjwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvZnJvbUV2ZW50LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIGJ5IGF0dGFjaGluZyBhbiBldmVudCBsaXN0ZW5lciB0byBhbiBcImV2ZW50IHRhcmdldFwiLFxuICAgICAqIHdoaWNoIG1heSBiZSBhbiBvYmplY3Qgd2l0aCBgYWRkRXZlbnRMaXN0ZW5lcmAgYW5kIGByZW1vdmVFdmVudExpc3RlbmVyYCxcbiAgICAgKiBhIE5vZGUuanMgRXZlbnRFbWl0dGVyLCBhIGpRdWVyeSBzdHlsZSBFdmVudEVtaXR0ZXIsIGEgTm9kZUxpc3QgZnJvbSB0aGVcbiAgICAgKiBET00sIG9yIGFuIEhUTUxDb2xsZWN0aW9uIGZyb20gdGhlIERPTS4gVGhlIGV2ZW50IGhhbmRsZXIgaXMgYXR0YWNoZWQgd2hlblxuICAgICAqIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkLCBhbmQgcmVtb3ZlZCB3aGVuIHRoZSBTdWJzY3JpcHRpb24gaXNcbiAgICAgKiB1bnN1YnNjcmliZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyBjbGlja3MgaGFwcGVuaW5nIG9uIHRoZSBET00gZG9jdW1lbnQ8L2NhcHRpb24+XG4gICAgICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAgICAgKiBjbGlja3Muc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogLy8gUmVzdWx0cyBpbjpcbiAgICAgKiAvLyBNb3VzZUV2ZW50IG9iamVjdCBsb2dnZWQgdG8gY29uc29sZSBldmVyeXRpbWUgYSBjbGlja1xuICAgICAqIC8vIG9jY3VycyBvbiB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBmcm9tfVxuICAgICAqIEBzZWUge0BsaW5rIGZyb21FdmVudFBhdHRlcm59XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0TGlrZX0gdGFyZ2V0IFRoZSBET01FbGVtZW50LCBldmVudCB0YXJnZXQsIE5vZGUuanNcbiAgICAgKiBFdmVudEVtaXR0ZXIsIE5vZGVMaXN0IG9yIEhUTUxDb2xsZWN0aW9uIHRvIGF0dGFjaCB0aGUgZXZlbnQgaGFuZGxlciB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBldmVudCBuYW1lIG9mIGludGVyZXN0LCBiZWluZyBlbWl0dGVkIGJ5IHRoZVxuICAgICAqIGB0YXJnZXRgLlxuICAgICAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdGhyb3VnaCB0byBhZGRFdmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtIHtTZWxlY3Rvck1ldGhvZFNpZ25hdHVyZTxUPn0gW3NlbGVjdG9yXSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0b1xuICAgICAqIHBvc3QtcHJvY2VzcyByZXN1bHRzLiBJdCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGV2ZW50IGhhbmRsZXIgYW5kXG4gICAgICogc2hvdWxkIHJldHVybiBhIHNpbmdsZSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fVxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGZyb21FdmVudFxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUsIG9wdGlvbnMsIHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgICAgICAgc2VsZWN0b3IgPSBvcHRpb25zO1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyb21FdmVudE9ic2VydmFibGUodGFyZ2V0LCBldmVudE5hbWUsIHNlbGVjdG9yLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIEZyb21FdmVudE9ic2VydmFibGUuc2V0dXBTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiAoc291cmNlT2JqLCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlO1xuICAgICAgICBpZiAoaXNOb2RlTGlzdChzb3VyY2VPYmopIHx8IGlzSFRNTENvbGxlY3Rpb24oc291cmNlT2JqKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNvdXJjZU9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIEZyb21FdmVudE9ic2VydmFibGUuc2V0dXBTdWJzY3JpcHRpb24oc291cmNlT2JqW2ldLCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRXZlbnRUYXJnZXQoc291cmNlT2JqKSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZV8xID0gc291cmNlT2JqO1xuICAgICAgICAgICAgc291cmNlT2JqLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlXzEucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzSlF1ZXJ5U3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZV8yID0gc291cmNlT2JqO1xuICAgICAgICAgICAgc291cmNlT2JqLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZV8yLm9mZihldmVudE5hbWUsIGhhbmRsZXIpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTm9kZVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iaikpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VfMyA9IHNvdXJjZU9iajtcbiAgICAgICAgICAgIHNvdXJjZU9iai5hZGRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2VfMy5yZW1vdmVMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBldmVudCB0YXJnZXQnKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLmFkZChuZXcgU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSk7XG4gICAgfTtcbiAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNvdXJjZU9iaiA9IHRoaXMuc291cmNlT2JqO1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gdGhpcy5ldmVudE5hbWU7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICB2YXIgaGFuZGxlciA9IHNlbGVjdG9yID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHNlbGVjdG9yKS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IDogZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHN1YnNjcmliZXIubmV4dChlKTsgfTtcbiAgICAgICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5zZXR1cFN1YnNjcmlwdGlvbihzb3VyY2VPYmosIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICByZXR1cm4gRnJvbUV2ZW50T2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRnJvbUV2ZW50T2JzZXJ2YWJsZSA9IEZyb21FdmVudE9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gcm9tRXZlbnRPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEZyb21FdmVudE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRnJvbUV2ZW50T2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5mcm9tRXZlbnQgPSBGcm9tRXZlbnRPYnNlcnZhYmxlXzEuRnJvbUV2ZW50T2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mcm9tRXZlbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG9ubHkgYWZ0ZXIgYSBwYXJ0aWN1bGFyIHRpbWUgc3BhblxuICogaGFzIHBhc3NlZCB3aXRob3V0IGFub3RoZXIgc291cmNlIGVtaXNzaW9uLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGRlbGF5fSwgYnV0IHBhc3NlcyBvbmx5IHRoZSBtb3N0XG4gKiByZWNlbnQgdmFsdWUgZnJvbSBlYWNoIGJ1cnN0IG9mIGVtaXNzaW9ucy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZWJvdW5jZVRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGRlYm91bmNlVGltZWAgZGVsYXlzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IGRyb3BzXG4gKiBwcmV2aW91cyBwZW5kaW5nIGRlbGF5ZWQgZW1pc3Npb25zIGlmIGEgbmV3IHZhbHVlIGFycml2ZXMgb24gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gVGhpcyBvcGVyYXRvciBrZWVwcyB0cmFjayBvZiB0aGUgbW9zdCByZWNlbnQgdmFsdWUgZnJvbSB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLCBhbmQgZW1pdHMgdGhhdCBvbmx5IHdoZW4gYGR1ZVRpbWVgIGVub3VnaCB0aW1lIGhhcyBwYXNzZWRcbiAqIHdpdGhvdXQgYW55IG90aGVyIHZhbHVlIGFwcGVhcmluZyBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGEgbmV3IHZhbHVlXG4gKiBhcHBlYXJzIGJlZm9yZSBgZHVlVGltZWAgc2lsZW5jZSBvY2N1cnMsIHRoZSBwcmV2aW91cyB2YWx1ZSB3aWxsIGJlIGRyb3BwZWRcbiAqIGFuZCB3aWxsIG5vdCBiZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBUaGlzIGlzIGEgcmF0ZS1saW1pdGluZyBvcGVyYXRvciwgYmVjYXVzZSBpdCBpcyBpbXBvc3NpYmxlIGZvciBtb3JlIHRoYW4gb25lXG4gKiB2YWx1ZSB0byBiZSBlbWl0dGVkIGluIGFueSB0aW1lIHdpbmRvdyBvZiBkdXJhdGlvbiBgZHVlVGltZWAsIGJ1dCBpdCBpcyBhbHNvXG4gKiBhIGRlbGF5LWxpa2Ugb3BlcmF0b3Igc2luY2Ugb3V0cHV0IGVtaXNzaW9ucyBkbyBub3Qgb2NjdXIgYXQgdGhlIHNhbWUgdGltZSBhc1xuICogdGhleSBkaWQgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBPcHRpb25hbGx5IHRha2VzIGEge0BsaW5rIElTY2hlZHVsZXJ9IGZvclxuICogbWFuYWdpbmcgdGltZXJzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG1vc3QgcmVjZW50IGNsaWNrIGFmdGVyIGEgYnVyc3Qgb2YgY2xpY2tzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZGVib3VuY2VUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICogQHNlZSB7QGxpbmsgc2FtcGxlVGltZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlVGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVlVGltZSBUaGUgdGltZW91dCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgKG9yIHRoZSB0aW1lXG4gKiB1bml0IGRldGVybWluZWQgaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmApIGZvciB0aGUgd2luZG93IG9mXG4gKiB0aW1lIHJlcXVpcmVkIHRvIHdhaXQgZm9yIGVtaXNzaW9uIHNpbGVuY2UgYmVmb3JlIGVtaXR0aW5nIHRoZSBtb3N0IHJlY2VudFxuICogc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgdGltZW91dCBmb3IgZWFjaCB2YWx1ZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBkZWxheXMgdGhlIGVtaXNzaW9ucyBvZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGJ5IHRoZSBzcGVjaWZpZWQgYGR1ZVRpbWVgLCBhbmQgbWF5IGRyb3Agc29tZSB2YWx1ZXMgaWYgdGhleSBvY2N1clxuICogdG9vIGZyZXF1ZW50bHkuXG4gKiBAbWV0aG9kIGRlYm91bmNlVGltZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2VUaW1lKGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGVib3VuY2VUaW1lT3BlcmF0b3IoZHVlVGltZSwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLmRlYm91bmNlVGltZSA9IGRlYm91bmNlVGltZTtcbnZhciBEZWJvdW5jZVRpbWVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VUaW1lT3BlcmF0b3IoZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGR1ZVRpbWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBEZWJvdW5jZVRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlYm91bmNlVGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kdWVUaW1lLCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIERlYm91bmNlVGltZU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGVib3VuY2VUaW1lU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlYm91bmNlVGltZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVib3VuY2VUaW1lU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kdWVUaW1lID0gZHVlVGltZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJEZWJvdW5jZSgpO1xuICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQodGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb24gPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIHRoaXMuZHVlVGltZSwgdGhpcykpO1xuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlYm91bmNlZE5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuZGVib3VuY2VkTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhckRlYm91bmNlKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5sYXN0VmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5jbGVhckRlYm91bmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gdGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChkZWJvdW5jZWRTdWJzY3JpcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGRlYm91bmNlZFN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICBkZWJvdW5jZWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlYm91bmNlVGltZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5mdW5jdGlvbiBkaXNwYXRjaE5leHQoc3Vic2NyaWJlcikge1xuICAgIHN1YnNjcmliZXIuZGVib3VuY2VkTmV4dCgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2VUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUGVyZm9ybSBhIHNpZGUgZWZmZWN0IGZvciBldmVyeSBlbWlzc2lvbiBvbiB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCByZXR1cm5cbiAqIGFuIE9ic2VydmFibGUgdGhhdCBpcyBpZGVudGljYWwgdG8gdGhlIHNvdXJjZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SW50ZXJjZXB0cyBlYWNoIGVtaXNzaW9uIG9uIHRoZSBzb3VyY2UgYW5kIHJ1bnMgYVxuICogZnVuY3Rpb24sIGJ1dCByZXR1cm5zIGFuIG91dHB1dCB3aGljaCBpcyBpZGVudGljYWwgdG8gdGhlIHNvdXJjZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kby5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGEgbWlycm9yZWQgT2JzZXJ2YWJsZSBvZiB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBtb2RpZmllZCBzbyB0aGF0XG4gKiB0aGUgcHJvdmlkZWQgT2JzZXJ2ZXIgaXMgY2FsbGVkIHRvIHBlcmZvcm0gYSBzaWRlIGVmZmVjdCBmb3IgZXZlcnkgdmFsdWUsXG4gKiBlcnJvciwgYW5kIGNvbXBsZXRpb24gZW1pdHRlZCBieSB0aGUgc291cmNlLiBBbnkgZXJyb3JzIHRoYXQgYXJlIHRocm93biBpblxuICogdGhlIGFmb3JlbWVudGlvbmVkIE9ic2VydmVyIG9yIGhhbmRsZXJzIGFyZSBzYWZlbHkgc2VudCBkb3duIHRoZSBlcnJvciBwYXRoXG4gKiBvZiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogVGhpcyBvcGVyYXRvciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZyB5b3VyIE9ic2VydmFibGVzIGZvciB0aGUgY29ycmVjdCB2YWx1ZXNcbiAqIG9yIHBlcmZvcm1pbmcgb3RoZXIgc2lkZSBlZmZlY3RzLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgZGlmZmVyZW50IHRvIGEgYHN1YnNjcmliZWAgb24gdGhlIE9ic2VydmFibGUuIElmIHRoZSBPYnNlcnZhYmxlXG4gKiByZXR1cm5lZCBieSBgZG9gIGlzIG5vdCBzdWJzY3JpYmVkLCB0aGUgc2lkZSBlZmZlY3RzIHNwZWNpZmllZCBieSB0aGVcbiAqIE9ic2VydmVyIHdpbGwgbmV2ZXIgaGFwcGVuLiBgZG9gIHRoZXJlZm9yZSBzaW1wbHkgc3BpZXMgb24gZXhpc3RpbmdcbiAqIGV4ZWN1dGlvbiwgaXQgZG9lcyBub3QgdHJpZ2dlciBhbiBleGVjdXRpb24gdG8gaGFwcGVuIGxpa2UgYHN1YnNjcmliZWAgZG9lcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgZXZlcnkgZXZlcnkgY2xpY2sgdG8gdGhlIGNsaWVudFggcG9zaXRpb24gb2YgdGhhdCBjbGljaywgd2hpbGUgYWxzbyBsb2dnaW5nIHRoZSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcG9zaXRpb25zID0gY2xpY2tzXG4gKiAgIC5kbyhldiA9PiBjb25zb2xlLmxvZyhldikpXG4gKiAgIC5tYXAoZXYgPT4gZXYuY2xpZW50WCk7XG4gKiBwb3NpdGlvbnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1hcH1cbiAqIEBzZWUge0BsaW5rIHN1YnNjcmliZX1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmVyfGZ1bmN0aW9ufSBbbmV4dE9yT2JzZXJ2ZXJdIEEgbm9ybWFsIE9ic2VydmVyIG9iamVjdCBvciBhXG4gKiBjYWxsYmFjayBmb3IgYG5leHRgLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayBmb3IgZXJyb3JzIGluIHRoZSBzb3VyY2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY29tcGxldGVdIENhbGxiYWNrIGZvciB0aGUgY29tcGxldGlvbiBvZiB0aGUgc291cmNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBpZGVudGljYWwgdG8gdGhlIHNvdXJjZSwgYnV0IHJ1bnMgdGhlXG4gKiBzcGVjaWZpZWQgT2JzZXJ2ZXIgb3IgY2FsbGJhY2socykgZm9yIGVhY2ggaXRlbS5cbiAqIEBtZXRob2QgZG9cbiAqIEBuYW1lIGRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBfZG8obmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERvT3BlcmF0b3IobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkpO1xufVxuZXhwb3J0cy5fZG8gPSBfZG87XG52YXIgRG9PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRG9PcGVyYXRvcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHRoaXMubmV4dE9yT2JzZXJ2ZXIgPSBuZXh0T3JPYnNlcnZlcjtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLmNvbXBsZXRlID0gY29tcGxldGU7XG4gICAgfVxuICAgIERvT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEb1N1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5uZXh0T3JPYnNlcnZlciwgdGhpcy5lcnJvciwgdGhpcy5jb21wbGV0ZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERvT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEb1N1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEb1N1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZChzYWZlU3Vic2NyaWJlcik7XG4gICAgICAgIHRoaXMuc2FmZVN1YnNjcmliZXIgPSBzYWZlU3Vic2NyaWJlcjtcbiAgICB9XG4gICAgRG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb1N1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gdGhpcy5zYWZlU3Vic2NyaWJlcjtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERvU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBBcHBsaWVzIGEgZ2l2ZW4gYHByb2plY3RgIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLCBhbmQgZW1pdHMgdGhlIHJlc3VsdGluZyB2YWx1ZXMgYXMgYW4gT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGlrZSBbQXJyYXkucHJvdG90eXBlLm1hcCgpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9tYXApLFxuICogaXQgcGFzc2VzIGVhY2ggc291cmNlIHZhbHVlIHRocm91Z2ggYSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiB0byBnZXRcbiAqIGNvcnJlc3BvbmRpbmcgb3V0cHV0IHZhbHVlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogU2ltaWxhciB0byB0aGUgd2VsbCBrbm93biBgQXJyYXkucHJvdG90eXBlLm1hcGAgZnVuY3Rpb24sIHRoaXMgb3BlcmF0b3JcbiAqIGFwcGxpZXMgYSBwcm9qZWN0aW9uIHRvIGVhY2ggdmFsdWUgYW5kIGVtaXRzIHRoYXQgcHJvamVjdGlvbiBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBldmVyeSBldmVyeSBjbGljayB0byB0aGUgY2xpZW50WCBwb3NpdGlvbiBvZiB0aGF0IGNsaWNrPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwb3NpdGlvbnMgPSBjbGlja3MubWFwKGV2ID0+IGV2LmNsaWVudFgpO1xuICogcG9zaXRpb25zLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtYXBUb31cbiAqIEBzZWUge0BsaW5rIHBsdWNrfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBSfSBwcm9qZWN0IFRoZSBmdW5jdGlvbiB0byBhcHBseVxuICogdG8gZWFjaCBgdmFsdWVgIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBUaGUgYGluZGV4YCBwYXJhbWV0ZXIgaXNcbiAqIHRoZSBudW1iZXIgYGlgIGZvciB0aGUgaS10aCBlbWlzc2lvbiB0aGF0IGhhcyBoYXBwZW5lZCBzaW5jZSB0aGVcbiAqIHN1YnNjcmlwdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgbnVtYmVyIGAwYC5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gZGVmaW5lIHdoYXQgYHRoaXNgIGlzIGluIHRoZVxuICogYHByb2plY3RgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIHRyYW5zZm9ybWVkIGJ5IHRoZSBnaXZlbiBgcHJvamVjdGAgZnVuY3Rpb24uXG4gKiBAbWV0aG9kIG1hcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWFwKHByb2plY3QsIHRoaXNBcmcpIHtcbiAgICBpZiAodHlwZW9mIHByb2plY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgaXMgbm90IGEgZnVuY3Rpb24uIEFyZSB5b3UgbG9va2luZyBmb3IgYG1hcFRvKClgPycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNYXBPcGVyYXRvcihwcm9qZWN0LCB0aGlzQXJnKSk7XG59XG5leHBvcnRzLm1hcCA9IG1hcDtcbnZhciBNYXBPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwT3BlcmF0b3IocHJvamVjdCwgdGhpc0FyZykge1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgIH1cbiAgICBNYXBPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1hcFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcm9qZWN0LCB0aGlzLnRoaXNBcmcpKTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk1hcE9wZXJhdG9yID0gTWFwT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHRoaXNBcmcpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZyB8fCB0aGlzO1xuICAgIH1cbiAgICAvLyBOT1RFOiBUaGlzIGxvb2tzIHVub3B0aW1pemVkLCBidXQgaXQncyBhY3R1YWxseSBwdXJwb3NlZnVsbHkgTk9UXG4gICAgLy8gdXNpbmcgdHJ5L2NhdGNoIG9wdGltaXphdGlvbnMuXG4gICAgTWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5jYWxsKHRoaXMudGhpc0FyZywgdmFsdWUsIHRoaXMuY291bnQrKyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgTm90aWZpY2F0aW9uXzEgPSByZXF1aXJlKCcuLi9Ob3RpZmljYXRpb24nKTtcbi8qKlxuICogQHNlZSB7QGxpbmsgTm90aWZpY2F0aW9ufVxuICpcbiAqIEBwYXJhbSBzY2hlZHVsZXJcbiAqIEBwYXJhbSBkZWxheVxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPnxXZWJTb2NrZXRTdWJqZWN0PFQ+fE9ic2VydmFibGU8VD59XG4gKiBAbWV0aG9kIG9ic2VydmVPblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZU9uKHNjaGVkdWxlciwgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBPYnNlcnZlT25PcGVyYXRvcihzY2hlZHVsZXIsIGRlbGF5KSk7XG59XG5leHBvcnRzLm9ic2VydmVPbiA9IG9ic2VydmVPbjtcbnZhciBPYnNlcnZlT25PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT2JzZXJ2ZU9uT3BlcmF0b3Ioc2NoZWR1bGVyLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB9XG4gICAgT2JzZXJ2ZU9uT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBPYnNlcnZlT25TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuc2NoZWR1bGVyLCB0aGlzLmRlbGF5KSk7XG4gICAgfTtcbiAgICByZXR1cm4gT2JzZXJ2ZU9uT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5PYnNlcnZlT25PcGVyYXRvciA9IE9ic2VydmVPbk9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBPYnNlcnZlT25TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT2JzZXJ2ZU9uU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPYnNlcnZlT25TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBzY2hlZHVsZXIsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgfVxuICAgIE9ic2VydmVPblN1YnNjcmliZXIuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBub3RpZmljYXRpb24gPSBhcmcubm90aWZpY2F0aW9uLCBkZXN0aW5hdGlvbiA9IGFyZy5kZXN0aW5hdGlvbjtcbiAgICAgICAgbm90aWZpY2F0aW9uLm9ic2VydmUoZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBPYnNlcnZlT25TdWJzY3JpYmVyLnByb3RvdHlwZS5zY2hlZHVsZU1lc3NhZ2UgPSBmdW5jdGlvbiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKE9ic2VydmVPblN1YnNjcmliZXIuZGlzcGF0Y2gsIHRoaXMuZGVsYXksIG5ldyBPYnNlcnZlT25NZXNzYWdlKG5vdGlmaWNhdGlvbiwgdGhpcy5kZXN0aW5hdGlvbikpKTtcbiAgICB9O1xuICAgIE9ic2VydmVPblN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVNZXNzYWdlKE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0KHZhbHVlKSk7XG4gICAgfTtcbiAgICBPYnNlcnZlT25TdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVNZXNzYWdlKE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVFcnJvcihlcnIpKTtcbiAgICB9O1xuICAgIE9ic2VydmVPblN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU1lc3NhZ2UoTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUNvbXBsZXRlKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmVPblN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLk9ic2VydmVPblN1YnNjcmliZXIgPSBPYnNlcnZlT25TdWJzY3JpYmVyO1xudmFyIE9ic2VydmVPbk1lc3NhZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmVPbk1lc3NhZ2Uobm90aWZpY2F0aW9uLCBkZXN0aW5hdGlvbikge1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbiA9IG5vdGlmaWNhdGlvbjtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gT2JzZXJ2ZU9uTWVzc2FnZTtcbn0oKSk7XG5leHBvcnRzLk9ic2VydmVPbk1lc3NhZ2UgPSBPYnNlcnZlT25NZXNzYWdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2ZU9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogQSB1bml0IG9mIHdvcmsgdG8gYmUgZXhlY3V0ZWQgaW4gYSB7QGxpbmsgU2NoZWR1bGVyfS4gQW4gYWN0aW9uIGlzIHR5cGljYWxseVxuICogY3JlYXRlZCBmcm9tIHdpdGhpbiBhIFNjaGVkdWxlciBhbmQgYW4gUnhKUyB1c2VyIGRvZXMgbm90IG5lZWQgdG8gY29uY2VyblxuICogdGhlbXNlbHZlcyBhYm91dCBjcmVhdGluZyBhbmQgbWFuaXB1bGF0aW5nIGFuIEFjdGlvbi5cbiAqXG4gKiBgYGB0c1xuICogY2xhc3MgQWN0aW9uPFQ+IGV4dGVuZHMgU3Vic2NyaXB0aW9uIHtcbiAqICAgbmV3IChzY2hlZHVsZXI6IFNjaGVkdWxlciwgd29yazogKHN0YXRlPzogVCkgPT4gdm9pZCk7XG4gKiAgIHNjaGVkdWxlKHN0YXRlPzogVCwgZGVsYXk6IG51bWJlciA9IDApOiBTdWJzY3JpcHRpb247XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAY2xhc3MgQWN0aW9uPFQ+XG4gKi9cbnZhciBBY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIHRoaXMgYWN0aW9uIG9uIGl0cyBwYXJlbnQgU2NoZWR1bGVyIGZvciBleGVjdXRpb24uIE1heSBiZSBwYXNzZWRcbiAgICAgKiBzb21lIGNvbnRleHQgb2JqZWN0LCBgc3RhdGVgLiBNYXkgaGFwcGVuIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZSxcbiAgICAgKiBhY2NvcmRpbmcgdG8gdGhlIGBkZWxheWAgcGFyYW1ldGVyLCBpZiBzcGVjaWZpZWQuXG4gICAgICogQHBhcmFtIHtUfSBbc3RhdGVdIFNvbWUgY29udGV4dHVhbCBkYXRhIHRoYXQgdGhlIGB3b3JrYCBmdW5jdGlvbiB1c2VzIHdoZW5cbiAgICAgKiBjYWxsZWQgYnkgdGhlIFNjaGVkdWxlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5XSBUaW1lIHRvIHdhaXQgYmVmb3JlIGV4ZWN1dGluZyB0aGUgd29yaywgd2hlcmUgdGhlXG4gICAgICogdGltZSB1bml0IGlzIGltcGxpY2l0IGFuZCBkZWZpbmVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gQWN0aW9uO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuQWN0aW9uID0gQWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQXN5bmNBY3Rpb25fMSA9IHJlcXVpcmUoJy4vQXN5bmNBY3Rpb24nKTtcbnZhciBBbmltYXRpb25GcmFtZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9BbmltYXRpb25GcmFtZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBBbmltYXRpb25GcmFtZUFjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFuaW1hdGlvbkZyYW1lQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkZyYW1lQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy53b3JrID0gd29yaztcbiAgICB9XG4gICAgQW5pbWF0aW9uRnJhbWVBY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICAvLyBJZiBkZWxheSBpcyBncmVhdGVyIHRoYW4gMCwgcmVxdWVzdCBhcyBhbiBhc3luYyBhY3Rpb24uXG4gICAgICAgIGlmIChkZWxheSAhPT0gbnVsbCAmJiBkZWxheSA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkLmNhbGwodGhpcywgc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFB1c2ggdGhlIGFjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBzY2hlZHVsZXIgcXVldWUuXG4gICAgICAgIHNjaGVkdWxlci5hY3Rpb25zLnB1c2godGhpcyk7XG4gICAgICAgIC8vIElmIGFuIGFuaW1hdGlvbiBmcmFtZSBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZCwgZG9uJ3QgcmVxdWVzdCBhbm90aGVyXG4gICAgICAgIC8vIG9uZS4gSWYgYW4gYW5pbWF0aW9uIGZyYW1lIGhhc24ndCBiZWVuIHJlcXVlc3RlZCB5ZXQsIHJlcXVlc3Qgb25lLiBSZXR1cm5cbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lIHJlcXVlc3QgaWQuXG4gICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGVkIHx8IChzY2hlZHVsZXIuc2NoZWR1bGVkID0gQW5pbWF0aW9uRnJhbWVfMS5BbmltYXRpb25GcmFtZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc2NoZWR1bGVyLmZsdXNoLmJpbmQoc2NoZWR1bGVyLCBudWxsKSkpO1xuICAgIH07XG4gICAgQW5pbWF0aW9uRnJhbWVBY3Rpb24ucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICAvLyBJZiBkZWxheSBleGlzdHMgYW5kIGlzIGdyZWF0ZXIgdGhhbiAwLCBvciBpZiB0aGUgZGVsYXkgaXMgbnVsbCAodGhlXG4gICAgICAgIC8vIGFjdGlvbiB3YXNuJ3QgcmVzY2hlZHVsZWQpIGJ1dCB3YXMgb3JpZ2luYWxseSBzY2hlZHVsZWQgYXMgYW4gYXN5bmNcbiAgICAgICAgLy8gYWN0aW9uLCB0aGVuIHJlY3ljbGUgYXMgYW4gYXN5bmMgYWN0aW9uLlxuICAgICAgICBpZiAoKGRlbGF5ICE9PSBudWxsICYmIGRlbGF5ID4gMCkgfHwgKGRlbGF5ID09PSBudWxsICYmIHRoaXMuZGVsYXkgPiAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHNjaGVkdWxlciBxdWV1ZSBpcyBlbXB0eSwgY2FuY2VsIHRoZSByZXF1ZXN0ZWQgYW5pbWF0aW9uIGZyYW1lIGFuZFxuICAgICAgICAvLyBzZXQgdGhlIHNjaGVkdWxlZCBmbGFnIHRvIHVuZGVmaW5lZCBzbyB0aGUgbmV4dCBBbmltYXRpb25GcmFtZUFjdGlvbiB3aWxsXG4gICAgICAgIC8vIHJlcXVlc3QgaXRzIG93bi5cbiAgICAgICAgaWYgKHNjaGVkdWxlci5hY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgQW5pbWF0aW9uRnJhbWVfMS5BbmltYXRpb25GcmFtZS5jYW5jZWxBbmltYXRpb25GcmFtZShpZCk7XG4gICAgICAgICAgICBzY2hlZHVsZXIuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB1bmRlZmluZWQgc28gdGhlIGFjdGlvbiBrbm93cyB0byByZXF1ZXN0IGEgbmV3IGFzeW5jIGlkIGlmIGl0J3MgcmVzY2hlZHVsZWQuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uRnJhbWVBY3Rpb247XG59KEFzeW5jQWN0aW9uXzEuQXN5bmNBY3Rpb24pKTtcbmV4cG9ydHMuQW5pbWF0aW9uRnJhbWVBY3Rpb24gPSBBbmltYXRpb25GcmFtZUFjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFuaW1hdGlvbkZyYW1lQWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQXN5bmNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4vQXN5bmNTY2hlZHVsZXInKTtcbnZhciBBbmltYXRpb25GcmFtZVNjaGVkdWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGNvdW50ID0gYWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIGFjdGlvbiA9IGFjdGlvbiB8fCBhY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9IGFjdGlvbi5leGVjdXRlKGFjdGlvbi5zdGF0ZSwgYWN0aW9uLmRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgrK2luZGV4IDwgY291bnQgJiYgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgY291bnQgJiYgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXI7XG59KEFzeW5jU2NoZWR1bGVyXzEuQXN5bmNTY2hlZHVsZXIpKTtcbmV4cG9ydHMuQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgPSBBbmltYXRpb25GcmFtZVNjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG52YXIgQWN0aW9uXzEgPSByZXF1aXJlKCcuL0FjdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBBc3luY0FjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzeW5jQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFzeW5jQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy53b3JrID0gd29yaztcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWx3YXlzIHJlcGxhY2UgdGhlIGN1cnJlbnQgc3RhdGUgd2l0aCB0aGUgbmV3IHN0YXRlLlxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIC8vIFNldCB0aGUgcGVuZGluZyBmbGFnIGluZGljYXRpbmcgdGhhdCB0aGlzIGFjdGlvbiBoYXMgYmVlbiBzY2hlZHVsZWQsIG9yXG4gICAgICAgIC8vIGhhcyByZWN1cnNpdmVseSByZXNjaGVkdWxlZCBpdHNlbGYuXG4gICAgICAgIHRoaXMucGVuZGluZyA9IHRydWU7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW1wb3J0YW50IGltcGxlbWVudGF0aW9uIG5vdGU6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEFjdGlvbnMgb25seSBleGVjdXRlIG9uY2UgYnkgZGVmYXVsdCwgdW5sZXNzIHJlc2NoZWR1bGVkIGZyb20gd2l0aGluIHRoZVxuICAgICAgICAvLyBzY2hlZHVsZWQgY2FsbGJhY2suIFRoaXMgYWxsb3dzIHVzIHRvIGltcGxlbWVudCBzaW5nbGUgYW5kIHJlcGVhdFxuICAgICAgICAvLyBhY3Rpb25zIHZpYSB0aGUgc2FtZSBjb2RlIHBhdGgsIHdpdGhvdXQgYWRkaW5nIEFQSSBzdXJmYWNlIGFyZWEsIGFzIHdlbGxcbiAgICAgICAgLy8gYXMgbWltaWMgdHJhZGl0aW9uYWwgcmVjdXJzaW9uIGJ1dCBhY3Jvc3MgYXN5bmNocm9ub3VzIGJvdW5kYXJpZXMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEhvd2V2ZXIsIEpTIHJ1bnRpbWVzIGFuZCB0aW1lcnMgZGlzdGluZ3Vpc2ggYmV0d2VlbiBpbnRlcnZhbHMgYWNoaWV2ZWQgYnlcbiAgICAgICAgLy8gc2VyaWFsIGBzZXRUaW1lb3V0YCBjYWxscyB2cy4gYSBzaW5nbGUgYHNldEludGVydmFsYCBjYWxsLiBBbiBpbnRlcnZhbCBvZlxuICAgICAgICAvLyBzZXJpYWwgYHNldFRpbWVvdXRgIGNhbGxzIGNhbiBiZSBpbmRpdmlkdWFsbHkgZGVsYXllZCwgd2hpY2ggZGVsYXlzXG4gICAgICAgIC8vIHNjaGVkdWxpbmcgdGhlIG5leHQgYHNldFRpbWVvdXRgLCBhbmQgc28gb24uIGBzZXRJbnRlcnZhbGAgYXR0ZW1wdHMgdG9cbiAgICAgICAgLy8gZ3VhcmFudGVlIHRoZSBpbnRlcnZhbCBjYWxsYmFjayB3aWxsIGJlIGludm9rZWQgbW9yZSBwcmVjaXNlbHkgdG8gdGhlXG4gICAgICAgIC8vIGludGVydmFsIHBlcmlvZCwgcmVnYXJkbGVzcyBvZiBsb2FkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGVyZWZvcmUsIHdlIHVzZSBgc2V0SW50ZXJ2YWxgIHRvIHNjaGVkdWxlIHNpbmdsZSBhbmQgcmVwZWF0IGFjdGlvbnMuXG4gICAgICAgIC8vIElmIHRoZSBhY3Rpb24gcmVzY2hlZHVsZXMgaXRzZWxmIHdpdGggdGhlIHNhbWUgZGVsYXksIHRoZSBpbnRlcnZhbCBpcyBub3RcbiAgICAgICAgLy8gY2FuY2VsZWQuIElmIHRoZSBhY3Rpb24gZG9lc24ndCByZXNjaGVkdWxlLCBvciByZXNjaGVkdWxlcyB3aXRoIGFcbiAgICAgICAgLy8gZGlmZmVyZW50IGRlbGF5LCB0aGUgaW50ZXJ2YWwgd2lsbCBiZSBjYW5jZWxlZCBhZnRlciBzY2hlZHVsZWQgY2FsbGJhY2tcbiAgICAgICAgLy8gZXhlY3V0aW9uLlxuICAgICAgICAvL1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQoc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgLy8gSWYgdGhpcyBhY3Rpb24gaGFzIGFscmVhZHkgYW4gYXN5bmMgSWQsIGRvbid0IHJlcXVlc3QgYSBuZXcgb25lLlxuICAgICAgICB0aGlzLmlkID0gdGhpcy5pZCB8fCB0aGlzLnJlcXVlc3RBc3luY0lkKHNjaGVkdWxlciwgdGhpcy5pZCwgZGVsYXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIHJvb3RfMS5yb290LnNldEludGVydmFsKHNjaGVkdWxlci5mbHVzaC5iaW5kKHNjaGVkdWxlciwgdGhpcyksIGRlbGF5KTtcbiAgICB9O1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5yZWN5Y2xlQXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgLy8gSWYgdGhpcyBhY3Rpb24gaXMgcmVzY2hlZHVsZWQgd2l0aCB0aGUgc2FtZSBkZWxheSB0aW1lLCBkb24ndCBjbGVhciB0aGUgaW50ZXJ2YWwgaWQuXG4gICAgICAgIGlmIChkZWxheSAhPT0gbnVsbCAmJiB0aGlzLmRlbGF5ID09PSBkZWxheSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIGFjdGlvbidzIGRlbGF5IHRpbWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgZGVsYXksXG4gICAgICAgIC8vIGNsZWFyIHRoZSBpbnRlcnZhbCBpZFxuICAgICAgICByZXR1cm4gcm9vdF8xLnJvb3QuY2xlYXJJbnRlcnZhbChpZCkgJiYgdW5kZWZpbmVkIHx8IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGV4ZWN1dGVzIHRoaXMgYWN0aW9uIGFuZCB0aGUgYHdvcmtgIGl0IGNvbnRhaW5zLlxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdleGVjdXRpbmcgYSBjYW5jZWxsZWQgYWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMuX2V4ZWN1dGUoc3RhdGUsIGRlbGF5KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wZW5kaW5nID09PSBmYWxzZSAmJiB0aGlzLmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERlcXVldWUgaWYgdGhlIGFjdGlvbiBkaWRuJ3QgcmVzY2hlZHVsZSBpdHNlbGYuIERvbid0IGNhbGxcbiAgICAgICAgICAgIC8vIHVuc3Vic2NyaWJlKCksIGJlY2F1c2UgdGhlIGFjdGlvbiBjb3VsZCByZXNjaGVkdWxlIGxhdGVyLlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgICAgICAvLyBgYGBcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiBkb1dvcmsoY291bnRlcikge1xuICAgICAgICAgICAgLy8gICAvKiAuLi4gSSdtIGEgYnVzeSB3b3JrZXIgYmVlIC4uLiAqL1xuICAgICAgICAgICAgLy8gICB2YXIgb3JpZ2luYWxBY3Rpb24gPSB0aGlzO1xuICAgICAgICAgICAgLy8gICAvKiB3YWl0IDEwMG1zIGJlZm9yZSByZXNjaGVkdWxpbmcgdGhlIGFjdGlvbiAqL1xuICAgICAgICAgICAgLy8gICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vICAgICBvcmlnaW5hbEFjdGlvbi5zY2hlZHVsZShjb3VudGVyICsgMSk7XG4gICAgICAgICAgICAvLyAgIH0sIDEwMCk7XG4gICAgICAgICAgICAvLyB9LCAxMDAwKTtcbiAgICAgICAgICAgIC8vIGBgYFxuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQodGhpcy5zY2hlZHVsZXIsIHRoaXMuaWQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuX2V4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIHZhciBlcnJvcmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvclZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53b3JrKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICAgICAgICBlcnJvclZhbHVlID0gISFlICYmIGUgfHwgbmV3IEVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JWYWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHNjaGVkdWxlci5hY3Rpb25zO1xuICAgICAgICB2YXIgaW5kZXggPSBhY3Rpb25zLmluZGV4T2YodGhpcyk7XG4gICAgICAgIHRoaXMud29yayA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gbnVsbDtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXIsIGlkLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jQWN0aW9uO1xufShBY3Rpb25fMS5BY3Rpb24pKTtcbmV4cG9ydHMuQXN5bmNBY3Rpb24gPSBBc3luY0FjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzeW5jQWN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi9TY2hlZHVsZXInKTtcbnZhciBBc3luY1NjaGVkdWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzeW5jU2NoZWR1bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFzeW5jU2NoZWR1bGVyKCkge1xuICAgICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGUgU2NoZWR1bGVyIGlzIGN1cnJlbnRseSBleGVjdXRpbmcgYSBiYXRjaCBvZlxuICAgICAgICAgKiBxdWV1ZWQgYWN0aW9ucy5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZXJuYWwgSUQgdXNlZCB0byB0cmFjayB0aGUgbGF0ZXN0IGFzeW5jaHJvbm91cyB0YXNrIHN1Y2ggYXMgdGhvc2VcbiAgICAgICAgICogY29taW5nIGZyb20gYHNldFRpbWVvdXRgLCBgc2V0SW50ZXJ2YWxgLCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCwgYW5kXG4gICAgICAgICAqIG90aGVycy5cbiAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBBc3luY1NjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPSBhY3Rpb24uZXhlY3V0ZShhY3Rpb24uc3RhdGUsIGFjdGlvbi5kZWxheSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKTsgLy8gZXhoYXVzdCB0aGUgc2NoZWR1bGVyIHF1ZXVlXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgd2hpbGUgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBc3luY1NjaGVkdWxlcjtcbn0oU2NoZWR1bGVyXzEuU2NoZWR1bGVyKSk7XG5leHBvcnRzLkFzeW5jU2NoZWR1bGVyID0gQXN5bmNTY2hlZHVsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY1NjaGVkdWxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBBbmltYXRpb25GcmFtZUFjdGlvbl8xID0gcmVxdWlyZSgnLi9BbmltYXRpb25GcmFtZUFjdGlvbicpO1xudmFyIEFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuL0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVyJyk7XG4vKipcbiAqXG4gKiBBbmltYXRpb24gRnJhbWUgU2NoZWR1bGVyXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlBlcmZvcm0gdGFzayB3aGVuIGB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYCB3b3VsZCBmaXJlPC9zcGFuPlxuICpcbiAqIFdoZW4gYGFuaW1hdGlvbkZyYW1lYCBzY2hlZHVsZXIgaXMgdXNlZCB3aXRoIGRlbGF5LCBpdCB3aWxsIGZhbGwgYmFjayB0byB7QGxpbmsgYXN5bmN9IHNjaGVkdWxlclxuICogYmVoYXZpb3VyLlxuICpcbiAqIFdpdGhvdXQgZGVsYXksIGBhbmltYXRpb25GcmFtZWAgc2NoZWR1bGVyIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBzbW9vdGggYnJvd3NlciBhbmltYXRpb25zLlxuICogSXQgbWFrZXMgc3VyZSBzY2hlZHVsZWQgdGFzayB3aWxsIGhhcHBlbiBqdXN0IGJlZm9yZSBuZXh0IGJyb3dzZXIgY29udGVudCByZXBhaW50LFxuICogdGh1cyBwZXJmb3JtaW5nIGFuaW1hdGlvbnMgYXMgZWZmaWNpZW50bHkgYXMgcG9zc2libGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+U2NoZWR1bGUgZGl2IGhlaWdodCBhbmltYXRpb248L2NhcHRpb24+XG4gKiBjb25zdCBkaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc29tZS1kaXYnKTtcbiAqXG4gKiBSeC5TY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24oaGVpZ2h0KSB7XG4gKiAgIGRpdi5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gKlxuICogICB0aGlzLnNjaGVkdWxlKGhlaWdodCArIDEpOyAgLy8gYHRoaXNgIHJlZmVyZW5jZXMgY3VycmVudGx5IGV4ZWN1dGluZyBBY3Rpb24sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3ZSByZXNjaGVkdWxlIHdpdGggbmV3IHN0YXRlXG4gKiB9LCAwLCAwKTtcbiAqXG4gKiAvLyBZb3Ugd2lsbCBzZWUgLnNvbWUtZGl2IGVsZW1lbnQgZ3Jvd2luZyBpbiBoZWlnaHRcbiAqXG4gKlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBhbmltYXRpb25GcmFtZVxuICogQG93bmVyIFNjaGVkdWxlclxuICovXG5leHBvcnRzLmFuaW1hdGlvbkZyYW1lID0gbmV3IEFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyXzEuQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIoQW5pbWF0aW9uRnJhbWVBY3Rpb25fMS5BbmltYXRpb25GcmFtZUFjdGlvbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbmltYXRpb25GcmFtZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBBc3luY0FjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc3luY0FjdGlvbicpO1xudmFyIEFzeW5jU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuL0FzeW5jU2NoZWR1bGVyJyk7XG4vKipcbiAqXG4gKiBBc3luYyBTY2hlZHVsZXJcbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+U2NoZWR1bGUgdGFzayBhcyBpZiB5b3UgdXNlZCBzZXRUaW1lb3V0KHRhc2ssIGR1cmF0aW9uKTwvc3Bhbj5cbiAqXG4gKiBgYXN5bmNgIHNjaGVkdWxlciBzY2hlZHVsZXMgdGFza3MgYXN5bmNocm9ub3VzbHksIGJ5IHB1dHRpbmcgdGhlbSBvbiB0aGUgSmF2YVNjcmlwdFxuICogZXZlbnQgbG9vcCBxdWV1ZS4gSXQgaXMgYmVzdCB1c2VkIHRvIGRlbGF5IHRhc2tzIGluIHRpbWUgb3IgdG8gc2NoZWR1bGUgdGFza3MgcmVwZWF0aW5nXG4gKiBpbiBpbnRlcnZhbHMuXG4gKlxuICogSWYgeW91IGp1c3Qgd2FudCB0byBcImRlZmVyXCIgdGFzaywgdGhhdCBpcyB0byBwZXJmb3JtIGl0IHJpZ2h0IGFmdGVyIGN1cnJlbnRseVxuICogZXhlY3V0aW5nIHN5bmNocm9ub3VzIGNvZGUgZW5kcyAoY29tbW9ubHkgYWNoaWV2ZWQgYnkgYHNldFRpbWVvdXQoZGVmZXJyZWRUYXNrLCAwKWApLFxuICogYmV0dGVyIGNob2ljZSB3aWxsIGJlIHRoZSB7QGxpbmsgYXNhcH0gc2NoZWR1bGVyLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSBhc3luYyBzY2hlZHVsZXIgdG8gZGVsYXkgdGFzazwvY2FwdGlvbj5cbiAqIGNvbnN0IHRhc2sgPSAoKSA9PiBjb25zb2xlLmxvZygnaXQgd29ya3MhJyk7XG4gKlxuICogUnguU2NoZWR1bGVyLmFzeW5jLnNjaGVkdWxlKHRhc2ssIDIwMDApO1xuICpcbiAqIC8vIEFmdGVyIDIgc2Vjb25kcyBsb2dzOlxuICogLy8gXCJpdCB3b3JrcyFcIlxuICpcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2UgYXN5bmMgc2NoZWR1bGVyIHRvIHJlcGVhdCB0YXNrIGluIGludGVydmFsczwvY2FwdGlvbj5cbiAqIGZ1bmN0aW9uIHRhc2soc3RhdGUpIHtcbiAqICAgY29uc29sZS5sb2coc3RhdGUpO1xuICogICB0aGlzLnNjaGVkdWxlKHN0YXRlICsgMSwgMTAwMCk7IC8vIGB0aGlzYCByZWZlcmVuY2VzIGN1cnJlbnRseSBleGVjdXRpbmcgQWN0aW9uLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdlIHJlc2NoZWR1bGUgd2l0aCBuZXcgc3RhdGUgYW5kIGRlbGF5XG4gKiB9XG4gKlxuICogUnguU2NoZWR1bGVyLmFzeW5jLnNjaGVkdWxlKHRhc2ssIDMwMDAsIDApO1xuICpcbiAqIC8vIExvZ3M6XG4gKiAvLyAwIGFmdGVyIDNzXG4gKiAvLyAxIGFmdGVyIDRzXG4gKiAvLyAyIGFmdGVyIDVzXG4gKiAvLyAzIGFmdGVyIDZzXG4gKlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBhc3luY1xuICogQG93bmVyIFNjaGVkdWxlclxuICovXG5leHBvcnRzLmFzeW5jID0gbmV3IEFzeW5jU2NoZWR1bGVyXzEuQXN5bmNTY2hlZHVsZXIoQXN5bmNBY3Rpb25fMS5Bc3luY0FjdGlvbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3luYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbmZ1bmN0aW9uIGdldFN5bWJvbE9ic2VydmFibGUoY29udGV4dCkge1xuICAgIHZhciAkJG9ic2VydmFibGU7XG4gICAgdmFyIFN5bWJvbCA9IGNvbnRleHQuU3ltYm9sO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgJCRvYnNlcnZhYmxlID0gU3ltYm9sLm9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAkJG9ic2VydmFibGUgPSBTeW1ib2woJ29ic2VydmFibGUnKTtcbiAgICAgICAgICAgIFN5bWJvbC5vYnNlcnZhYmxlID0gJCRvYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAkJG9ic2VydmFibGUgPSAnQEBvYnNlcnZhYmxlJztcbiAgICB9XG4gICAgcmV0dXJuICQkb2JzZXJ2YWJsZTtcbn1cbmV4cG9ydHMuZ2V0U3ltYm9sT2JzZXJ2YWJsZSA9IGdldFN5bWJvbE9ic2VydmFibGU7XG5leHBvcnRzLiQkb2JzZXJ2YWJsZSA9IGdldFN5bWJvbE9ic2VydmFibGUocm9vdF8xLnJvb3QpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBTeW1ib2wgPSByb290XzEucm9vdC5TeW1ib2w7XG5leHBvcnRzLiQkcnhTdWJzY3JpYmVyID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpID9cbiAgICBTeW1ib2wuZm9yKCdyeFN1YnNjcmliZXInKSA6ICdAQHJ4U3Vic2NyaWJlcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yeFN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi9yb290Jyk7XG52YXIgUmVxdWVzdEFuaW1hdGlvbkZyYW1lRGVmaW5pdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVxdWVzdEFuaW1hdGlvbkZyYW1lRGVmaW5pdGlvbihyb290KSB7XG4gICAgICAgIGlmIChyb290LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHJvb3QuY2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHJvb3QubW96Q2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHJvb3Qud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gcm9vdC5tc0NhbmNlbEFuaW1hdGlvbkZyYW1lLmJpbmQocm9vdCk7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJvb3QubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb290Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSByb290Lm9DYW5jZWxBbmltYXRpb25GcmFtZS5iaW5kKHJvb3QpO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290Lm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSByb290LmNsZWFyVGltZW91dC5iaW5kKHJvb3QpO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIHJvb3Quc2V0VGltZW91dChjYiwgMTAwMCAvIDYwKTsgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUmVxdWVzdEFuaW1hdGlvbkZyYW1lRGVmaW5pdGlvbjtcbn0oKSk7XG5leHBvcnRzLlJlcXVlc3RBbmltYXRpb25GcmFtZURlZmluaXRpb24gPSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVEZWZpbml0aW9uO1xuZXhwb3J0cy5BbmltYXRpb25GcmFtZSA9IG5ldyBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVEZWZpbml0aW9uKHJvb3RfMS5yb290KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFuaW1hdGlvbkZyYW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIG9uZSBvciBtb3JlIGVycm9ycyBoYXZlIG9jY3VycmVkIGR1cmluZyB0aGVcbiAqIGB1bnN1YnNjcmliZWAgb2YgYSB7QGxpbmsgU3Vic2NyaXB0aW9ufS5cbiAqL1xudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVbnN1YnNjcmlwdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdmFyIGVyciA9IEVycm9yLmNhbGwodGhpcywgZXJyb3JzID9cbiAgICAgICAgICAgIGVycm9ycy5sZW5ndGggKyBcIiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxcbiAgXCIgKyBlcnJvcnMubWFwKGZ1bmN0aW9uIChlcnIsIGkpIHsgcmV0dXJuICgoaSArIDEpICsgXCIpIFwiICsgZXJyLnRvU3RyaW5nKCkpOyB9KS5qb2luKCdcXG4gICcpIDogJycpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdVbnN1YnNjcmlwdGlvbkVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IGVyci5zdGFjaztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiBVbnN1YnNjcmlwdGlvbkVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5VbnN1YnNjcmlwdGlvbkVycm9yID0gVW5zdWJzY3JpcHRpb25FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuc3Vic2NyaXB0aW9uRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyB0eXBlb2YgYW55IHNvIHRoYXQgaXQgd2UgZG9uJ3QgaGF2ZSB0byBjYXN0IHdoZW4gY29tcGFyaW5nIGEgcmVzdWx0IHRvIHRoZSBlcnJvciBvYmplY3RcbmV4cG9ydHMuZXJyb3JPYmplY3QgPSB7IGU6IHt9IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvck9iamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcic7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0Z1bmN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNPYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIHdpbmRvdzogYnJvd3NlciBpbiBET00gbWFpbiB0aHJlYWRcbiAqIHNlbGY6IGJyb3dzZXIgaW4gV2ViV29ya2VyXG4gKiBnbG9iYWw6IE5vZGUuanMvb3RoZXJcbiAqL1xuZXhwb3J0cy5yb290ID0gKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93LndpbmRvdyA9PT0gd2luZG93ICYmIHdpbmRvd1xuICAgIHx8IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmXG4gICAgfHwgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsKTtcbmlmICghZXhwb3J0cy5yb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSeEpTIGNvdWxkIG5vdCBmaW5kIGFueSBnbG9iYWwgY29udGV4dCAod2luZG93LCBzZWxmLCBnbG9iYWwpJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb290LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9yeFN1YnNjcmliZXInKTtcbnZhciBPYnNlcnZlcl8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2ZXInKTtcbmZ1bmN0aW9uIHRvU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgaWYgKG5leHRPck9ic2VydmVyKSB7XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciBpbnN0YW5jZW9mIFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dE9yT2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbmV4dE9yT2JzZXJ2ZXIgJiYgIWVycm9yICYmICFjb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKE9ic2VydmVyXzEuZW1wdHkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xufVxuZXhwb3J0cy50b1N1YnNjcmliZXIgPSB0b1N1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b1N1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4vZXJyb3JPYmplY3QnKTtcbnZhciB0cnlDYXRjaFRhcmdldDtcbmZ1bmN0aW9uIHRyeUNhdGNoZXIoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRyeUNhdGNoVGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSA9IGU7XG4gICAgICAgIHJldHVybiBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyeUNhdGNoKGZuKSB7XG4gICAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgICByZXR1cm4gdHJ5Q2F0Y2hlcjtcbn1cbmV4cG9ydHMudHJ5Q2F0Y2ggPSB0cnlDYXRjaDtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyeUNhdGNoLmpzLm1hcCIsIi8vIENvcHlyaWdodCAyMDE0IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vICAgICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vICAgICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cblxuIWZ1bmN0aW9uKGEsYil7dmFyIGM9e30sZD17fSxlPXt9LGY9bnVsbDshZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhKXJldHVybiBhO3ZhciBiPXt9O2Zvcih2YXIgYyBpbiBhKWJbY109YVtjXTtyZXR1cm4gYn1mdW5jdGlvbiBkKCl7dGhpcy5fZGVsYXk9MCx0aGlzLl9lbmREZWxheT0wLHRoaXMuX2ZpbGw9XCJub25lXCIsdGhpcy5faXRlcmF0aW9uU3RhcnQ9MCx0aGlzLl9pdGVyYXRpb25zPTEsdGhpcy5fZHVyYXRpb249MCx0aGlzLl9wbGF5YmFja1JhdGU9MSx0aGlzLl9kaXJlY3Rpb249XCJub3JtYWxcIix0aGlzLl9lYXNpbmc9XCJsaW5lYXJcIix0aGlzLl9lYXNpbmdGdW5jdGlvbj14fWZ1bmN0aW9uIGUoKXtyZXR1cm4gYS5pc0RlcHJlY2F0ZWQoXCJJbnZhbGlkIHRpbWluZyBpbnB1dHNcIixcIjIwMTYtMDMtMDJcIixcIlR5cGVFcnJvciBleGNlcHRpb25zIHdpbGwgYmUgdGhyb3duIGluc3RlYWQuXCIsITApfWZ1bmN0aW9uIGYoYixjLGUpe3ZhciBmPW5ldyBkO3JldHVybiBjJiYoZi5maWxsPVwiYm90aFwiLGYuZHVyYXRpb249XCJhdXRvXCIpLFwibnVtYmVyXCIhPXR5cGVvZiBifHxpc05hTihiKT92b2lkIDAhPT1iJiZPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiKS5mb3JFYWNoKGZ1bmN0aW9uKGMpe2lmKFwiYXV0b1wiIT1iW2NdKXtpZigoXCJudW1iZXJcIj09dHlwZW9mIGZbY118fFwiZHVyYXRpb25cIj09YykmJihcIm51bWJlclwiIT10eXBlb2YgYltjXXx8aXNOYU4oYltjXSkpKXJldHVybjtpZihcImZpbGxcIj09YyYmdi5pbmRleE9mKGJbY10pPT0tMSlyZXR1cm47aWYoXCJkaXJlY3Rpb25cIj09YyYmdy5pbmRleE9mKGJbY10pPT0tMSlyZXR1cm47aWYoXCJwbGF5YmFja1JhdGVcIj09YyYmMSE9PWJbY10mJmEuaXNEZXByZWNhdGVkKFwiQW5pbWF0aW9uRWZmZWN0VGltaW5nLnBsYXliYWNrUmF0ZVwiLFwiMjAxNC0xMS0yOFwiLFwiVXNlIEFuaW1hdGlvbi5wbGF5YmFja1JhdGUgaW5zdGVhZC5cIikpcmV0dXJuO2ZbY109YltjXX19KTpmLmR1cmF0aW9uPWIsZn1mdW5jdGlvbiBnKGEpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBhJiYoYT1pc05hTihhKT97ZHVyYXRpb246MH06e2R1cmF0aW9uOmF9KSxhfWZ1bmN0aW9uIGgoYixjKXtyZXR1cm4gYj1hLm51bWVyaWNUaW1pbmdUb09iamVjdChiKSxmKGIsYyl9ZnVuY3Rpb24gaShhLGIsYyxkKXtyZXR1cm4gYTwwfHxhPjF8fGM8MHx8Yz4xP3g6ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gZihhLGIsYyl7cmV0dXJuIDMqYSooMS1jKSooMS1jKSpjKzMqYiooMS1jKSpjKmMrYypjKmN9aWYoZTw9MCl7dmFyIGc9MDtyZXR1cm4gYT4wP2c9Yi9hOiFiJiZjPjAmJihnPWQvYyksZyplfWlmKGU+PTEpe3ZhciBoPTA7cmV0dXJuIGM8MT9oPShkLTEpLyhjLTEpOjE9PWMmJmE8MSYmKGg9KGItMSkvKGEtMSkpLDEraCooZS0xKX1mb3IodmFyIGk9MCxqPTE7aTxqOyl7dmFyIGs9KGkraikvMixsPWYoYSxjLGspO2lmKE1hdGguYWJzKGUtbCk8MWUtNSlyZXR1cm4gZihiLGQsayk7bDxlP2k9azpqPWt9cmV0dXJuIGYoYixkLGspfX1mdW5jdGlvbiBqKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGMpe2lmKGM+PTEpcmV0dXJuIDE7dmFyIGQ9MS9hO3JldHVybiBjKz1iKmQsYy1jJWR9fWZ1bmN0aW9uIGsoYSl7Q3x8KEM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZSksQy5hbmltYXRpb25UaW1pbmdGdW5jdGlvbj1cIlwiLEMuYW5pbWF0aW9uVGltaW5nRnVuY3Rpb249YTt2YXIgYj1DLmFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uO2lmKFwiXCI9PWImJmUoKSl0aHJvdyBuZXcgVHlwZUVycm9yKGErXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIGVhc2luZ1wiKTtyZXR1cm4gYn1mdW5jdGlvbiBsKGEpe2lmKFwibGluZWFyXCI9PWEpcmV0dXJuIHg7dmFyIGI9RS5leGVjKGEpO2lmKGIpcmV0dXJuIGkuYXBwbHkodGhpcyxiLnNsaWNlKDEpLm1hcChOdW1iZXIpKTt2YXIgYz1GLmV4ZWMoYSk7aWYoYylyZXR1cm4gaihOdW1iZXIoY1sxXSkse3N0YXJ0OnksbWlkZGxlOnosZW5kOkF9W2NbMl1dKTt2YXIgZD1CW2FdO3JldHVybiBkP2Q6eH1mdW5jdGlvbiBtKGEpe3JldHVybiBNYXRoLmFicyhuKGEpL2EucGxheWJhY2tSYXRlKX1mdW5jdGlvbiBuKGEpe3JldHVybiAwPT09YS5kdXJhdGlvbnx8MD09PWEuaXRlcmF0aW9ucz8wOmEuZHVyYXRpb24qYS5pdGVyYXRpb25zfWZ1bmN0aW9uIG8oYSxiLGMpe2lmKG51bGw9PWIpcmV0dXJuIEc7dmFyIGQ9Yy5kZWxheSthK2MuZW5kRGVsYXk7cmV0dXJuIGI8TWF0aC5taW4oYy5kZWxheSxkKT9IOmI+PU1hdGgubWluKGMuZGVsYXkrYSxkKT9JOkp9ZnVuY3Rpb24gcChhLGIsYyxkLGUpe3N3aXRjaChkKXtjYXNlIEg6cmV0dXJuXCJiYWNrd2FyZHNcIj09Ynx8XCJib3RoXCI9PWI/MDpudWxsO2Nhc2UgSjpyZXR1cm4gYy1lO2Nhc2UgSTpyZXR1cm5cImZvcndhcmRzXCI9PWJ8fFwiYm90aFwiPT1iP2E6bnVsbDtjYXNlIEc6cmV0dXJuIG51bGx9fWZ1bmN0aW9uIHEoYSxiLGMsZCxlKXt2YXIgZj1lO3JldHVybiAwPT09YT9iIT09SCYmKGYrPWMpOmYrPWQvYSxmfWZ1bmN0aW9uIHIoYSxiLGMsZCxlLGYpe3ZhciBnPWE9PT0xLzA/YiUxOmElMTtyZXR1cm4gMCE9PWd8fGMhPT1JfHwwPT09ZHx8MD09PWUmJjAhPT1mfHwoZz0xKSxnfWZ1bmN0aW9uIHMoYSxiLGMsZCl7cmV0dXJuIGE9PT1JJiZiPT09MS8wPzEvMDoxPT09Yz9NYXRoLmZsb29yKGQpLTE6TWF0aC5mbG9vcihkKX1mdW5jdGlvbiB0KGEsYixjKXt2YXIgZD1hO2lmKFwibm9ybWFsXCIhPT1hJiZcInJldmVyc2VcIiE9PWEpe3ZhciBlPWI7XCJhbHRlcm5hdGUtcmV2ZXJzZVwiPT09YSYmKGUrPTEpLGQ9XCJub3JtYWxcIixlIT09MS8wJiZlJTIhPT0wJiYoZD1cInJldmVyc2VcIil9cmV0dXJuXCJub3JtYWxcIj09PWQ/YzoxLWN9ZnVuY3Rpb24gdShhLGIsYyl7dmFyIGQ9byhhLGIsYyksZT1wKGEsYy5maWxsLGIsZCxjLmRlbGF5KTtpZihudWxsPT09ZSlyZXR1cm4gbnVsbDt2YXIgZj1xKGMuZHVyYXRpb24sZCxjLml0ZXJhdGlvbnMsZSxjLml0ZXJhdGlvblN0YXJ0KSxnPXIoZixjLml0ZXJhdGlvblN0YXJ0LGQsYy5pdGVyYXRpb25zLGUsYy5kdXJhdGlvbiksaD1zKGQsYy5pdGVyYXRpb25zLGcsZiksaT10KGMuZGlyZWN0aW9uLGgsZyk7cmV0dXJuIGMuX2Vhc2luZ0Z1bmN0aW9uKGkpfXZhciB2PVwiYmFja3dhcmRzfGZvcndhcmRzfGJvdGh8bm9uZVwiLnNwbGl0KFwifFwiKSx3PVwicmV2ZXJzZXxhbHRlcm5hdGV8YWx0ZXJuYXRlLXJldmVyc2VcIi5zcGxpdChcInxcIikseD1mdW5jdGlvbihhKXtyZXR1cm4gYX07ZC5wcm90b3R5cGU9e19zZXRNZW1iZXI6ZnVuY3Rpb24oYixjKXt0aGlzW1wiX1wiK2JdPWMsdGhpcy5fZWZmZWN0JiYodGhpcy5fZWZmZWN0Ll90aW1pbmdJbnB1dFtiXT1jLHRoaXMuX2VmZmVjdC5fdGltaW5nPWEubm9ybWFsaXplVGltaW5nSW5wdXQodGhpcy5fZWZmZWN0Ll90aW1pbmdJbnB1dCksdGhpcy5fZWZmZWN0LmFjdGl2ZUR1cmF0aW9uPWEuY2FsY3VsYXRlQWN0aXZlRHVyYXRpb24odGhpcy5fZWZmZWN0Ll90aW1pbmcpLHRoaXMuX2VmZmVjdC5fYW5pbWF0aW9uJiZ0aGlzLl9lZmZlY3QuX2FuaW1hdGlvbi5fcmVidWlsZFVuZGVybHlpbmdBbmltYXRpb24oKSl9LGdldCBwbGF5YmFja1JhdGUoKXtyZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlfSxzZXQgZGVsYXkoYSl7dGhpcy5fc2V0TWVtYmVyKFwiZGVsYXlcIixhKX0sZ2V0IGRlbGF5KCl7cmV0dXJuIHRoaXMuX2RlbGF5fSxzZXQgZW5kRGVsYXkoYSl7dGhpcy5fc2V0TWVtYmVyKFwiZW5kRGVsYXlcIixhKX0sZ2V0IGVuZERlbGF5KCl7cmV0dXJuIHRoaXMuX2VuZERlbGF5fSxzZXQgZmlsbChhKXt0aGlzLl9zZXRNZW1iZXIoXCJmaWxsXCIsYSl9LGdldCBmaWxsKCl7cmV0dXJuIHRoaXMuX2ZpbGx9LHNldCBpdGVyYXRpb25TdGFydChhKXtpZigoaXNOYU4oYSl8fGE8MCkmJmUoKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0aW9uU3RhcnQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIsIHJlY2VpdmVkOiBcIit0aW1pbmcuaXRlcmF0aW9uU3RhcnQpO3RoaXMuX3NldE1lbWJlcihcIml0ZXJhdGlvblN0YXJ0XCIsYSl9LGdldCBpdGVyYXRpb25TdGFydCgpe3JldHVybiB0aGlzLl9pdGVyYXRpb25TdGFydH0sc2V0IGR1cmF0aW9uKGEpe2lmKFwiYXV0b1wiIT1hJiYoaXNOYU4oYSl8fGE8MCkmJmUoKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiZHVyYXRpb24gbXVzdCBiZSBub24tbmVnYXRpdmUgb3IgYXV0bywgcmVjZWl2ZWQ6IFwiK2EpO3RoaXMuX3NldE1lbWJlcihcImR1cmF0aW9uXCIsYSl9LGdldCBkdXJhdGlvbigpe3JldHVybiB0aGlzLl9kdXJhdGlvbn0sc2V0IGRpcmVjdGlvbihhKXt0aGlzLl9zZXRNZW1iZXIoXCJkaXJlY3Rpb25cIixhKX0sZ2V0IGRpcmVjdGlvbigpe3JldHVybiB0aGlzLl9kaXJlY3Rpb259LHNldCBlYXNpbmcoYSl7dGhpcy5fZWFzaW5nRnVuY3Rpb249bChrKGEpKSx0aGlzLl9zZXRNZW1iZXIoXCJlYXNpbmdcIixhKX0sZ2V0IGVhc2luZygpe3JldHVybiB0aGlzLl9lYXNpbmd9LHNldCBpdGVyYXRpb25zKGEpe2lmKChpc05hTihhKXx8YTwwKSYmZSgpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRpb25zIG11c3QgYmUgbm9uLW5lZ2F0aXZlLCByZWNlaXZlZDogXCIrYSk7dGhpcy5fc2V0TWVtYmVyKFwiaXRlcmF0aW9uc1wiLGEpfSxnZXQgaXRlcmF0aW9ucygpe3JldHVybiB0aGlzLl9pdGVyYXRpb25zfX07dmFyIHk9MSx6PS41LEE9MCxCPXtlYXNlOmkoLjI1LC4xLC4yNSwxKSxcImVhc2UtaW5cIjppKC40MiwwLDEsMSksXCJlYXNlLW91dFwiOmkoMCwwLC41OCwxKSxcImVhc2UtaW4tb3V0XCI6aSguNDIsMCwuNTgsMSksXCJzdGVwLXN0YXJ0XCI6aigxLHkpLFwic3RlcC1taWRkbGVcIjpqKDEseiksXCJzdGVwLWVuZFwiOmooMSxBKX0sQz1udWxsLEQ9XCJcXFxccyooLT9cXFxcZCtcXFxcLj9cXFxcZCp8LT9cXFxcLlxcXFxkKylcXFxccypcIixFPW5ldyBSZWdFeHAoXCJjdWJpYy1iZXppZXJcXFxcKFwiK0QrXCIsXCIrRCtcIixcIitEK1wiLFwiK0QrXCJcXFxcKVwiKSxGPS9zdGVwc1xcKFxccyooXFxkKylcXHMqLFxccyooc3RhcnR8bWlkZGxlfGVuZClcXHMqXFwpLyxHPTAsSD0xLEk9MixKPTM7YS5jbG9uZVRpbWluZ0lucHV0PWMsYS5tYWtlVGltaW5nPWYsYS5udW1lcmljVGltaW5nVG9PYmplY3Q9ZyxhLm5vcm1hbGl6ZVRpbWluZ0lucHV0PWgsYS5jYWxjdWxhdGVBY3RpdmVEdXJhdGlvbj1tLGEuY2FsY3VsYXRlSXRlcmF0aW9uUHJvZ3Jlc3M9dSxhLmNhbGN1bGF0ZVBoYXNlPW8sYS5ub3JtYWxpemVFYXNpbmc9ayxhLnBhcnNlRWFzaW5nRnVuY3Rpb249bH0oYyxmKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiKXtyZXR1cm4gYSBpbiBrP2tbYV1bYl18fGI6Yn1mdW5jdGlvbiBkKGEpe3JldHVyblwiZGlzcGxheVwiPT09YXx8MD09PWEubGFzdEluZGV4T2YoXCJhbmltYXRpb25cIiwwKXx8MD09PWEubGFzdEluZGV4T2YoXCJ0cmFuc2l0aW9uXCIsMCl9ZnVuY3Rpb24gZShhLGIsZSl7aWYoIWQoYSkpe3ZhciBmPWhbYV07aWYoZil7aS5zdHlsZVthXT1iO2Zvcih2YXIgZyBpbiBmKXt2YXIgaj1mW2ddLGs9aS5zdHlsZVtqXTtlW2pdPWMoaixrKX19ZWxzZSBlW2FdPWMoYSxiKX19ZnVuY3Rpb24gZihhKXt2YXIgYj1bXTtmb3IodmFyIGMgaW4gYSlpZighKGMgaW5bXCJlYXNpbmdcIixcIm9mZnNldFwiLFwiY29tcG9zaXRlXCJdKSl7dmFyIGQ9YVtjXTtBcnJheS5pc0FycmF5KGQpfHwoZD1bZF0pO2Zvcih2YXIgZSxmPWQubGVuZ3RoLGc9MDtnPGY7ZysrKWU9e30sXCJvZmZzZXRcImluIGE/ZS5vZmZzZXQ9YS5vZmZzZXQ6MT09Zj9lLm9mZnNldD0xOmUub2Zmc2V0PWcvKGYtMSksXCJlYXNpbmdcImluIGEmJihlLmVhc2luZz1hLmVhc2luZyksXCJjb21wb3NpdGVcImluIGEmJihlLmNvbXBvc2l0ZT1hLmNvbXBvc2l0ZSksZVtjXT1kW2ddLGIucHVzaChlKX1yZXR1cm4gYi5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEub2Zmc2V0LWIub2Zmc2V0fSksYn1mdW5jdGlvbiBnKGIpe2Z1bmN0aW9uIGMoKXt2YXIgYT1kLmxlbmd0aDtudWxsPT1kW2EtMV0ub2Zmc2V0JiYoZFthLTFdLm9mZnNldD0xKSxhPjEmJm51bGw9PWRbMF0ub2Zmc2V0JiYoZFswXS5vZmZzZXQ9MCk7Zm9yKHZhciBiPTAsYz1kWzBdLm9mZnNldCxlPTE7ZTxhO2UrKyl7dmFyIGY9ZFtlXS5vZmZzZXQ7aWYobnVsbCE9Zil7Zm9yKHZhciBnPTE7ZzxlLWI7ZysrKWRbYitnXS5vZmZzZXQ9YysoZi1jKSpnLyhlLWIpO2I9ZSxjPWZ9fX1pZihudWxsPT1iKXJldHVybltdO3dpbmRvdy5TeW1ib2wmJlN5bWJvbC5pdGVyYXRvciYmQXJyYXkucHJvdG90eXBlLmZyb20mJmJbU3ltYm9sLml0ZXJhdG9yXSYmKGI9QXJyYXkuZnJvbShiKSksQXJyYXkuaXNBcnJheShiKXx8KGI9ZihiKSk7Zm9yKHZhciBkPWIubWFwKGZ1bmN0aW9uKGIpe3ZhciBjPXt9O2Zvcih2YXIgZCBpbiBiKXt2YXIgZj1iW2RdO2lmKFwib2Zmc2V0XCI9PWQpe2lmKG51bGwhPWYpe2lmKGY9TnVtYmVyKGYpLCFpc0Zpbml0ZShmKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiS2V5ZnJhbWUgb2Zmc2V0cyBtdXN0IGJlIG51bWJlcnMuXCIpO2lmKGY8MHx8Zj4xKXRocm93IG5ldyBUeXBlRXJyb3IoXCJLZXlmcmFtZSBvZmZzZXRzIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLlwiKX19ZWxzZSBpZihcImNvbXBvc2l0ZVwiPT1kKXtpZihcImFkZFwiPT1mfHxcImFjY3VtdWxhdGVcIj09Zil0aHJvd3t0eXBlOkRPTUV4Y2VwdGlvbi5OT1RfU1VQUE9SVEVEX0VSUixuYW1lOlwiTm90U3VwcG9ydGVkRXJyb3JcIixtZXNzYWdlOlwiYWRkIGNvbXBvc2l0aW5nIGlzIG5vdCBzdXBwb3J0ZWRcIn07aWYoXCJyZXBsYWNlXCIhPWYpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgY29tcG9zaXRlIG1vZGUgXCIrZitcIi5cIil9ZWxzZSBmPVwiZWFzaW5nXCI9PWQ/YS5ub3JtYWxpemVFYXNpbmcoZik6XCJcIitmO2UoZCxmLGMpfXJldHVybiB2b2lkIDA9PWMub2Zmc2V0JiYoYy5vZmZzZXQ9bnVsbCksdm9pZCAwPT1jLmVhc2luZyYmKGMuZWFzaW5nPVwibGluZWFyXCIpLGN9KSxnPSEwLGg9LSgxLzApLGk9MDtpPGQubGVuZ3RoO2krKyl7dmFyIGo9ZFtpXS5vZmZzZXQ7aWYobnVsbCE9ail7aWYoajxoKXRocm93IG5ldyBUeXBlRXJyb3IoXCJLZXlmcmFtZXMgYXJlIG5vdCBsb29zZWx5IHNvcnRlZCBieSBvZmZzZXQuIFNvcnQgb3Igc3BlY2lmeSBvZmZzZXRzLlwiKTtoPWp9ZWxzZSBnPSExfXJldHVybiBkPWQuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBhLm9mZnNldD49MCYmYS5vZmZzZXQ8PTF9KSxnfHxjKCksZH12YXIgaD17YmFja2dyb3VuZDpbXCJiYWNrZ3JvdW5kSW1hZ2VcIixcImJhY2tncm91bmRQb3NpdGlvblwiLFwiYmFja2dyb3VuZFNpemVcIixcImJhY2tncm91bmRSZXBlYXRcIixcImJhY2tncm91bmRBdHRhY2htZW50XCIsXCJiYWNrZ3JvdW5kT3JpZ2luXCIsXCJiYWNrZ3JvdW5kQ2xpcFwiLFwiYmFja2dyb3VuZENvbG9yXCJdLGJvcmRlcjpbXCJib3JkZXJUb3BDb2xvclwiLFwiYm9yZGVyVG9wU3R5bGVcIixcImJvcmRlclRvcFdpZHRoXCIsXCJib3JkZXJSaWdodENvbG9yXCIsXCJib3JkZXJSaWdodFN0eWxlXCIsXCJib3JkZXJSaWdodFdpZHRoXCIsXCJib3JkZXJCb3R0b21Db2xvclwiLFwiYm9yZGVyQm90dG9tU3R5bGVcIixcImJvcmRlckJvdHRvbVdpZHRoXCIsXCJib3JkZXJMZWZ0Q29sb3JcIixcImJvcmRlckxlZnRTdHlsZVwiLFwiYm9yZGVyTGVmdFdpZHRoXCJdLGJvcmRlckJvdHRvbTpbXCJib3JkZXJCb3R0b21XaWR0aFwiLFwiYm9yZGVyQm90dG9tU3R5bGVcIixcImJvcmRlckJvdHRvbUNvbG9yXCJdLGJvcmRlckNvbG9yOltcImJvcmRlclRvcENvbG9yXCIsXCJib3JkZXJSaWdodENvbG9yXCIsXCJib3JkZXJCb3R0b21Db2xvclwiLFwiYm9yZGVyTGVmdENvbG9yXCJdLGJvcmRlckxlZnQ6W1wiYm9yZGVyTGVmdFdpZHRoXCIsXCJib3JkZXJMZWZ0U3R5bGVcIixcImJvcmRlckxlZnRDb2xvclwiXSxib3JkZXJSYWRpdXM6W1wiYm9yZGVyVG9wTGVmdFJhZGl1c1wiLFwiYm9yZGVyVG9wUmlnaHRSYWRpdXNcIixcImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzXCJdLGJvcmRlclJpZ2h0OltcImJvcmRlclJpZ2h0V2lkdGhcIixcImJvcmRlclJpZ2h0U3R5bGVcIixcImJvcmRlclJpZ2h0Q29sb3JcIl0sYm9yZGVyVG9wOltcImJvcmRlclRvcFdpZHRoXCIsXCJib3JkZXJUb3BTdHlsZVwiLFwiYm9yZGVyVG9wQ29sb3JcIl0sYm9yZGVyV2lkdGg6W1wiYm9yZGVyVG9wV2lkdGhcIixcImJvcmRlclJpZ2h0V2lkdGhcIixcImJvcmRlckJvdHRvbVdpZHRoXCIsXCJib3JkZXJMZWZ0V2lkdGhcIl0sZmxleDpbXCJmbGV4R3Jvd1wiLFwiZmxleFNocmlua1wiLFwiZmxleEJhc2lzXCJdLGZvbnQ6W1wiZm9udEZhbWlseVwiLFwiZm9udFNpemVcIixcImZvbnRTdHlsZVwiLFwiZm9udFZhcmlhbnRcIixcImZvbnRXZWlnaHRcIixcImxpbmVIZWlnaHRcIl0sbWFyZ2luOltcIm1hcmdpblRvcFwiLFwibWFyZ2luUmlnaHRcIixcIm1hcmdpbkJvdHRvbVwiLFwibWFyZ2luTGVmdFwiXSxvdXRsaW5lOltcIm91dGxpbmVDb2xvclwiLFwib3V0bGluZVN0eWxlXCIsXCJvdXRsaW5lV2lkdGhcIl0scGFkZGluZzpbXCJwYWRkaW5nVG9wXCIsXCJwYWRkaW5nUmlnaHRcIixcInBhZGRpbmdCb3R0b21cIixcInBhZGRpbmdMZWZ0XCJdfSxpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcImRpdlwiKSxqPXt0aGluOlwiMXB4XCIsbWVkaXVtOlwiM3B4XCIsdGhpY2s6XCI1cHhcIn0saz17Ym9yZGVyQm90dG9tV2lkdGg6aixib3JkZXJMZWZ0V2lkdGg6aixib3JkZXJSaWdodFdpZHRoOmosYm9yZGVyVG9wV2lkdGg6aixmb250U2l6ZTp7XCJ4eC1zbWFsbFwiOlwiNjAlXCIsXCJ4LXNtYWxsXCI6XCI3NSVcIixzbWFsbDpcIjg5JVwiLG1lZGl1bTpcIjEwMCVcIixsYXJnZTpcIjEyMCVcIixcIngtbGFyZ2VcIjpcIjE1MCVcIixcInh4LWxhcmdlXCI6XCIyMDAlXCJ9LGZvbnRXZWlnaHQ6e25vcm1hbDpcIjQwMFwiLGJvbGQ6XCI3MDBcIn0sb3V0bGluZVdpZHRoOmosdGV4dFNoYWRvdzp7bm9uZTpcIjBweCAwcHggMHB4IHRyYW5zcGFyZW50XCJ9LGJveFNoYWRvdzp7bm9uZTpcIjBweCAwcHggMHB4IDBweCB0cmFuc3BhcmVudFwifX07YS5jb252ZXJ0VG9BcnJheUZvcm09ZixhLm5vcm1hbGl6ZUtleWZyYW1lcz1nfShjLGYpLGZ1bmN0aW9uKGEpe3ZhciBiPXt9O2EuaXNEZXByZWNhdGVkPWZ1bmN0aW9uKGEsYyxkLGUpe3ZhciBmPWU/XCJhcmVcIjpcImlzXCIsZz1uZXcgRGF0ZSxoPW5ldyBEYXRlKGMpO3JldHVybiBoLnNldE1vbnRoKGguZ2V0TW9udGgoKSszKSwhKGc8aCYmKGEgaW4gYnx8Y29uc29sZS53YXJuKFwiV2ViIEFuaW1hdGlvbnM6IFwiK2ErXCIgXCIrZitcIiBkZXByZWNhdGVkIGFuZCB3aWxsIHN0b3Agd29ya2luZyBvbiBcIitoLnRvRGF0ZVN0cmluZygpK1wiLiBcIitkKSxiW2FdPSEwLDEpKX0sYS5kZXByZWNhdGVkPWZ1bmN0aW9uKGIsYyxkLGUpe3ZhciBmPWU/XCJhcmVcIjpcImlzXCI7aWYoYS5pc0RlcHJlY2F0ZWQoYixjLGQsZSkpdGhyb3cgbmV3IEVycm9yKGIrXCIgXCIrZitcIiBubyBsb25nZXIgc3VwcG9ydGVkLiBcIitkKX19KGMpLGZ1bmN0aW9uKCl7aWYoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFuaW1hdGUpe3ZhciBhPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hbmltYXRlKFtdLDApLGI9ITA7aWYoYSYmKGI9ITEsXCJwbGF5fGN1cnJlbnRUaW1lfHBhdXNlfHJldmVyc2V8cGxheWJhY2tSYXRlfGNhbmNlbHxmaW5pc2h8c3RhcnRUaW1lfHBsYXlTdGF0ZVwiLnNwbGl0KFwifFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGMpe3ZvaWQgMD09PWFbY10mJihiPSEwKX0pKSwhYilyZXR1cm59IWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGEpe2Zvcih2YXIgYj17fSxjPTA7YzxhLmxlbmd0aDtjKyspZm9yKHZhciBkIGluIGFbY10paWYoXCJvZmZzZXRcIiE9ZCYmXCJlYXNpbmdcIiE9ZCYmXCJjb21wb3NpdGVcIiE9ZCl7dmFyIGU9e29mZnNldDphW2NdLm9mZnNldCxlYXNpbmc6YVtjXS5lYXNpbmcsdmFsdWU6YVtjXVtkXX07YltkXT1iW2RdfHxbXSxiW2RdLnB1c2goZSl9Zm9yKHZhciBmIGluIGIpe3ZhciBnPWJbZl07aWYoMCE9Z1swXS5vZmZzZXR8fDEhPWdbZy5sZW5ndGgtMV0ub2Zmc2V0KXRocm93e3R5cGU6RE9NRXhjZXB0aW9uLk5PVF9TVVBQT1JURURfRVJSLG5hbWU6XCJOb3RTdXBwb3J0ZWRFcnJvclwiLG1lc3NhZ2U6XCJQYXJ0aWFsIGtleWZyYW1lcyBhcmUgbm90IHN1cHBvcnRlZFwifX1yZXR1cm4gYn1mdW5jdGlvbiBlKGMpe3ZhciBkPVtdO2Zvcih2YXIgZSBpbiBjKWZvcih2YXIgZj1jW2VdLGc9MDtnPGYubGVuZ3RoLTE7ZysrKXt2YXIgaD1nLGk9ZysxLGo9ZltoXS5vZmZzZXQsaz1mW2ldLm9mZnNldCxsPWosbT1rOzA9PWcmJihsPS0oMS8wKSwwPT1rJiYoaT1oKSksZz09Zi5sZW5ndGgtMiYmKG09MS8wLDE9PWomJihoPWkpKSxkLnB1c2goe2FwcGx5RnJvbTpsLGFwcGx5VG86bSxzdGFydE9mZnNldDpmW2hdLm9mZnNldCxlbmRPZmZzZXQ6ZltpXS5vZmZzZXQsZWFzaW5nRnVuY3Rpb246YS5wYXJzZUVhc2luZ0Z1bmN0aW9uKGZbaF0uZWFzaW5nKSxwcm9wZXJ0eTplLGludGVycG9sYXRpb246Yi5wcm9wZXJ0eUludGVycG9sYXRpb24oZSxmW2hdLnZhbHVlLGZbaV0udmFsdWUpfSl9cmV0dXJuIGQuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLnN0YXJ0T2Zmc2V0LWIuc3RhcnRPZmZzZXR9KSxkfWIuY29udmVydEVmZmVjdElucHV0PWZ1bmN0aW9uKGMpe3ZhciBmPWEubm9ybWFsaXplS2V5ZnJhbWVzKGMpLGc9ZChmKSxoPWUoZyk7cmV0dXJuIGZ1bmN0aW9uKGEsYyl7aWYobnVsbCE9YyloLmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gYz49YS5hcHBseUZyb20mJmM8YS5hcHBseVRvfSkuZm9yRWFjaChmdW5jdGlvbihkKXt2YXIgZT1jLWQuc3RhcnRPZmZzZXQsZj1kLmVuZE9mZnNldC1kLnN0YXJ0T2Zmc2V0LGc9MD09Zj8wOmQuZWFzaW5nRnVuY3Rpb24oZS9mKTtiLmFwcGx5KGEsZC5wcm9wZXJ0eSxkLmludGVycG9sYXRpb24oZykpfSk7ZWxzZSBmb3IodmFyIGQgaW4gZylcIm9mZnNldFwiIT1kJiZcImVhc2luZ1wiIT1kJiZcImNvbXBvc2l0ZVwiIT1kJiZiLmNsZWFyKGEsZCl9fX0oYyxkLGYpLGZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGEpe3JldHVybiBhLnJlcGxhY2UoLy0oLikvZyxmdW5jdGlvbihhLGIpe3JldHVybiBiLnRvVXBwZXJDYXNlKCl9KX1mdW5jdGlvbiBlKGEsYixjKXtoW2NdPWhbY118fFtdLGhbY10ucHVzaChbYSxiXSl9ZnVuY3Rpb24gZihhLGIsYyl7Zm9yKHZhciBmPTA7ZjxjLmxlbmd0aDtmKyspe3ZhciBnPWNbZl07ZShhLGIsZChnKSl9fWZ1bmN0aW9uIGcoYyxlLGYpe3ZhciBnPWM7Ly0vLnRlc3QoYykmJiFhLmlzRGVwcmVjYXRlZChcIkh5cGhlbmF0ZWQgcHJvcGVydHkgbmFtZXNcIixcIjIwMTYtMDMtMjJcIixcIlVzZSBjYW1lbENhc2UgaW5zdGVhZC5cIiwhMCkmJihnPWQoYykpLFwiaW5pdGlhbFwiIT1lJiZcImluaXRpYWxcIiE9Znx8KFwiaW5pdGlhbFwiPT1lJiYoZT1pW2ddKSxcImluaXRpYWxcIj09ZiYmKGY9aVtnXSkpO2Zvcih2YXIgaj1lPT1mP1tdOmhbZ10saz0wO2omJms8ai5sZW5ndGg7aysrKXt2YXIgbD1qW2tdWzBdKGUpLG09altrXVswXShmKTtpZih2b2lkIDAhPT1sJiZ2b2lkIDAhPT1tKXt2YXIgbj1qW2tdWzFdKGwsbSk7aWYobil7dmFyIG89Yi5JbnRlcnBvbGF0aW9uLmFwcGx5KG51bGwsbik7cmV0dXJuIGZ1bmN0aW9uKGEpe3JldHVybiAwPT1hP2U6MT09YT9mOm8oYSl9fX19cmV0dXJuIGIuSW50ZXJwb2xhdGlvbighMSwhMCxmdW5jdGlvbihhKXtyZXR1cm4gYT9mOmV9KX12YXIgaD17fTtiLmFkZFByb3BlcnRpZXNIYW5kbGVyPWY7dmFyIGk9e2JhY2tncm91bmRDb2xvcjpcInRyYW5zcGFyZW50XCIsYmFja2dyb3VuZFBvc2l0aW9uOlwiMCUgMCVcIixib3JkZXJCb3R0b21Db2xvcjpcImN1cnJlbnRDb2xvclwiLGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6XCIwcHhcIixib3JkZXJCb3R0b21SaWdodFJhZGl1czpcIjBweFwiLGJvcmRlckJvdHRvbVdpZHRoOlwiM3B4XCIsYm9yZGVyTGVmdENvbG9yOlwiY3VycmVudENvbG9yXCIsYm9yZGVyTGVmdFdpZHRoOlwiM3B4XCIsYm9yZGVyUmlnaHRDb2xvcjpcImN1cnJlbnRDb2xvclwiLGJvcmRlclJpZ2h0V2lkdGg6XCIzcHhcIixib3JkZXJTcGFjaW5nOlwiMnB4XCIsYm9yZGVyVG9wQ29sb3I6XCJjdXJyZW50Q29sb3JcIixib3JkZXJUb3BMZWZ0UmFkaXVzOlwiMHB4XCIsYm9yZGVyVG9wUmlnaHRSYWRpdXM6XCIwcHhcIixib3JkZXJUb3BXaWR0aDpcIjNweFwiLGJvdHRvbTpcImF1dG9cIixjbGlwOlwicmVjdCgwcHgsIDBweCwgMHB4LCAwcHgpXCIsY29sb3I6XCJibGFja1wiLGZvbnRTaXplOlwiMTAwJVwiLGZvbnRXZWlnaHQ6XCI0MDBcIixoZWlnaHQ6XCJhdXRvXCIsbGVmdDpcImF1dG9cIixsZXR0ZXJTcGFjaW5nOlwibm9ybWFsXCIsbGluZUhlaWdodDpcIjEyMCVcIixtYXJnaW5Cb3R0b206XCIwcHhcIixtYXJnaW5MZWZ0OlwiMHB4XCIsbWFyZ2luUmlnaHQ6XCIwcHhcIixtYXJnaW5Ub3A6XCIwcHhcIixtYXhIZWlnaHQ6XCJub25lXCIsbWF4V2lkdGg6XCJub25lXCIsbWluSGVpZ2h0OlwiMHB4XCIsbWluV2lkdGg6XCIwcHhcIixvcGFjaXR5OlwiMS4wXCIsb3V0bGluZUNvbG9yOlwiaW52ZXJ0XCIsb3V0bGluZU9mZnNldDpcIjBweFwiLG91dGxpbmVXaWR0aDpcIjNweFwiLHBhZGRpbmdCb3R0b206XCIwcHhcIixwYWRkaW5nTGVmdDpcIjBweFwiLHBhZGRpbmdSaWdodDpcIjBweFwiLHBhZGRpbmdUb3A6XCIwcHhcIixyaWdodDpcImF1dG9cIix0ZXh0SW5kZW50OlwiMHB4XCIsdGV4dFNoYWRvdzpcIjBweCAwcHggMHB4IHRyYW5zcGFyZW50XCIsdG9wOlwiYXV0b1wiLHRyYW5zZm9ybTpcIlwiLHZlcnRpY2FsQWxpZ246XCIwcHhcIix2aXNpYmlsaXR5OlwidmlzaWJsZVwiLHdpZHRoOlwiYXV0b1wiLHdvcmRTcGFjaW5nOlwibm9ybWFsXCIsekluZGV4OlwiYXV0b1wifTtiLnByb3BlcnR5SW50ZXJwb2xhdGlvbj1nfShjLGQsZiksZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYil7dmFyIGM9YS5jYWxjdWxhdGVBY3RpdmVEdXJhdGlvbihiKSxkPWZ1bmN0aW9uKGQpe3JldHVybiBhLmNhbGN1bGF0ZUl0ZXJhdGlvblByb2dyZXNzKGMsZCxiKX07cmV0dXJuIGQuX3RvdGFsRHVyYXRpb249Yi5kZWxheStjK2IuZW5kRGVsYXksZH1iLktleWZyYW1lRWZmZWN0PWZ1bmN0aW9uKGMsZSxmLGcpe3ZhciBoLGk9ZChhLm5vcm1hbGl6ZVRpbWluZ0lucHV0KGYpKSxqPWIuY29udmVydEVmZmVjdElucHV0KGUpLGs9ZnVuY3Rpb24oKXtqKGMsaCl9O3JldHVybiBrLl91cGRhdGU9ZnVuY3Rpb24oYSl7cmV0dXJuIGg9aShhKSxudWxsIT09aH0say5fY2xlYXI9ZnVuY3Rpb24oKXtqKGMsbnVsbCl9LGsuX2hhc1NhbWVUYXJnZXQ9ZnVuY3Rpb24oYSl7cmV0dXJuIGM9PT1hfSxrLl90YXJnZXQ9YyxrLl90b3RhbER1cmF0aW9uPWkuX3RvdGFsRHVyYXRpb24say5faWQ9ZyxrfSxiLk51bGxFZmZlY3Q9ZnVuY3Rpb24oYSl7dmFyIGI9ZnVuY3Rpb24oKXthJiYoYSgpLGE9bnVsbCl9O3JldHVybiBiLl91cGRhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH0sYi5fdG90YWxEdXJhdGlvbj0wLGIuX2hhc1NhbWVUYXJnZXQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sYn19KGMsZCxmKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiLGMpe2MuZW51bWVyYWJsZT0hMCxjLmNvbmZpZ3VyYWJsZT0hMCxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLGMpfWZ1bmN0aW9uIGQoYSl7dGhpcy5fc3Vycm9nYXRlU3R5bGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFwiZGl2XCIpLnN0eWxlLHRoaXMuX3N0eWxlPWEuc3R5bGUsdGhpcy5fbGVuZ3RoPTAsdGhpcy5faXNBbmltYXRlZFByb3BlcnR5PXt9O2Zvcih2YXIgYj0wO2I8dGhpcy5fc3R5bGUubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5fc3R5bGVbYl07dGhpcy5fc3Vycm9nYXRlU3R5bGVbY109dGhpcy5fc3R5bGVbY119dGhpcy5fdXBkYXRlSW5kaWNlcygpfWZ1bmN0aW9uIGUoYSl7aWYoIWEuX3dlYkFuaW1hdGlvbnNQYXRjaGVkU3R5bGUpe3ZhciBiPW5ldyBkKGEpO3RyeXtjKGEsXCJzdHlsZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYn19KX1jYXRjaChiKXthLnN0eWxlLl9zZXQ9ZnVuY3Rpb24oYixjKXthLnN0eWxlW2JdPWN9LGEuc3R5bGUuX2NsZWFyPWZ1bmN0aW9uKGIpe2Euc3R5bGVbYl09XCJcIn19YS5fd2ViQW5pbWF0aW9uc1BhdGNoZWRTdHlsZT1hLnN0eWxlfX12YXIgZj17Y3NzVGV4dDoxLGxlbmd0aDoxLHBhcmVudFJ1bGU6MX0sZz17Z2V0UHJvcGVydHlDU1NWYWx1ZToxLGdldFByb3BlcnR5UHJpb3JpdHk6MSxnZXRQcm9wZXJ0eVZhbHVlOjEsaXRlbToxLHJlbW92ZVByb3BlcnR5OjEsc2V0UHJvcGVydHk6MX0saD17cmVtb3ZlUHJvcGVydHk6MSxzZXRQcm9wZXJ0eToxfTtkLnByb3RvdHlwZT17Z2V0IGNzc1RleHQoKXtyZXR1cm4gdGhpcy5fc3Vycm9nYXRlU3R5bGUuY3NzVGV4dH0sc2V0IGNzc1RleHQoYSl7Zm9yKHZhciBiPXt9LGM9MDtjPHRoaXMuX3N1cnJvZ2F0ZVN0eWxlLmxlbmd0aDtjKyspYlt0aGlzLl9zdXJyb2dhdGVTdHlsZVtjXV09ITA7dGhpcy5fc3Vycm9nYXRlU3R5bGUuY3NzVGV4dD1hLHRoaXMuX3VwZGF0ZUluZGljZXMoKTtmb3IodmFyIGM9MDtjPHRoaXMuX3N1cnJvZ2F0ZVN0eWxlLmxlbmd0aDtjKyspYlt0aGlzLl9zdXJyb2dhdGVTdHlsZVtjXV09ITA7Zm9yKHZhciBkIGluIGIpdGhpcy5faXNBbmltYXRlZFByb3BlcnR5W2RdfHx0aGlzLl9zdHlsZS5zZXRQcm9wZXJ0eShkLHRoaXMuX3N1cnJvZ2F0ZVN0eWxlLmdldFByb3BlcnR5VmFsdWUoZCkpfSxnZXQgbGVuZ3RoKCl7cmV0dXJuIHRoaXMuX3N1cnJvZ2F0ZVN0eWxlLmxlbmd0aH0sZ2V0IHBhcmVudFJ1bGUoKXtyZXR1cm4gdGhpcy5fc3R5bGUucGFyZW50UnVsZX0sX3VwZGF0ZUluZGljZXM6ZnVuY3Rpb24oKXtmb3IoO3RoaXMuX2xlbmd0aDx0aGlzLl9zdXJyb2dhdGVTdHlsZS5sZW5ndGg7KU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLHRoaXMuX2xlbmd0aCx7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdXJyb2dhdGVTdHlsZVthXX19KHRoaXMuX2xlbmd0aCl9KSx0aGlzLl9sZW5ndGgrKztmb3IoO3RoaXMuX2xlbmd0aD50aGlzLl9zdXJyb2dhdGVTdHlsZS5sZW5ndGg7KXRoaXMuX2xlbmd0aC0tLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLHRoaXMuX2xlbmd0aCx7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITEsdmFsdWU6dm9pZCAwfSl9LF9zZXQ6ZnVuY3Rpb24oYSxiKXt0aGlzLl9zdHlsZVthXT1iLHRoaXMuX2lzQW5pbWF0ZWRQcm9wZXJ0eVthXT0hMH0sX2NsZWFyOmZ1bmN0aW9uKGEpe3RoaXMuX3N0eWxlW2FdPXRoaXMuX3N1cnJvZ2F0ZVN0eWxlW2FdLGRlbGV0ZSB0aGlzLl9pc0FuaW1hdGVkUHJvcGVydHlbYV19fTtmb3IodmFyIGkgaW4gZylkLnByb3RvdHlwZVtpXT1mdW5jdGlvbihhLGIpe3JldHVybiBmdW5jdGlvbigpe3ZhciBjPXRoaXMuX3N1cnJvZ2F0ZVN0eWxlW2FdLmFwcGx5KHRoaXMuX3N1cnJvZ2F0ZVN0eWxlLGFyZ3VtZW50cyk7cmV0dXJuIGImJih0aGlzLl9pc0FuaW1hdGVkUHJvcGVydHlbYXJndW1lbnRzWzBdXXx8dGhpcy5fc3R5bGVbYV0uYXBwbHkodGhpcy5fc3R5bGUsYXJndW1lbnRzKSx0aGlzLl91cGRhdGVJbmRpY2VzKCkpLGN9fShpLGkgaW4gaCk7Zm9yKHZhciBqIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSlqIGluIGZ8fGogaW4gZ3x8IWZ1bmN0aW9uKGEpe2MoZC5wcm90b3R5cGUsYSx7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N1cnJvZ2F0ZVN0eWxlW2FdfSxzZXQ6ZnVuY3Rpb24oYil7dGhpcy5fc3Vycm9nYXRlU3R5bGVbYV09Yix0aGlzLl91cGRhdGVJbmRpY2VzKCksdGhpcy5faXNBbmltYXRlZFByb3BlcnR5W2FdfHwodGhpcy5fc3R5bGVbYV09Yil9fSl9KGopO2EuYXBwbHk9ZnVuY3Rpb24oYixjLGQpe2UoYiksYi5zdHlsZS5fc2V0KGEucHJvcGVydHlOYW1lKGMpLGQpfSxhLmNsZWFyPWZ1bmN0aW9uKGIsYyl7Yi5fd2ViQW5pbWF0aW9uc1BhdGNoZWRTdHlsZSYmYi5zdHlsZS5fY2xlYXIoYS5wcm9wZXJ0eU5hbWUoYykpfX0oZCxmKSxmdW5jdGlvbihhKXt3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYW5pbWF0ZT1mdW5jdGlvbihiLGMpe3ZhciBkPVwiXCI7cmV0dXJuIGMmJmMuaWQmJihkPWMuaWQpLGEudGltZWxpbmUuX3BsYXkoYS5LZXlmcmFtZUVmZmVjdCh0aGlzLGIsYyxkKSl9fShkKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiLGQpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhJiZcIm51bWJlclwiPT10eXBlb2YgYilyZXR1cm4gYSooMS1kKStiKmQ7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhJiZcImJvb2xlYW5cIj09dHlwZW9mIGIpcmV0dXJuIGQ8LjU/YTpiO2lmKGEubGVuZ3RoPT1iLmxlbmd0aCl7Zm9yKHZhciBlPVtdLGY9MDtmPGEubGVuZ3RoO2YrKyllLnB1c2goYyhhW2ZdLGJbZl0sZCkpO3JldHVybiBlfXRocm93XCJNaXNtYXRjaGVkIGludGVycG9sYXRpb24gYXJndW1lbnRzIFwiK2ErXCI6XCIrYn1hLkludGVycG9sYXRpb249ZnVuY3Rpb24oYSxiLGQpe3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gZChjKGEsYixlKSl9fX0oZCxmKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiLGMpe3JldHVybiBNYXRoLm1heChNYXRoLm1pbihhLGMpLGIpfWZ1bmN0aW9uIGQoYixkLGUpe3ZhciBmPWEuZG90KGIsZCk7Zj1jKGYsLTEsMSk7dmFyIGc9W107aWYoMT09PWYpZz1iO2Vsc2UgZm9yKHZhciBoPU1hdGguYWNvcyhmKSxpPTEqTWF0aC5zaW4oZSpoKS9NYXRoLnNxcnQoMS1mKmYpLGo9MDtqPDQ7aisrKWcucHVzaChiW2pdKihNYXRoLmNvcyhlKmgpLWYqaSkrZFtqXSppKTtyZXR1cm4gZ312YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxiKXtmb3IodmFyIGM9W1swLDAsMCwwXSxbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXV0sZD0wO2Q8NDtkKyspZm9yKHZhciBlPTA7ZTw0O2UrKylmb3IodmFyIGY9MDtmPDQ7ZisrKWNbZF1bZV0rPWJbZF1bZl0qYVtmXVtlXTtyZXR1cm4gY31mdW5jdGlvbiBiKGEpe3JldHVybiAwPT1hWzBdWzJdJiYwPT1hWzBdWzNdJiYwPT1hWzFdWzJdJiYwPT1hWzFdWzNdJiYwPT1hWzJdWzBdJiYwPT1hWzJdWzFdJiYxPT1hWzJdWzJdJiYwPT1hWzJdWzNdJiYwPT1hWzNdWzJdJiYxPT1hWzNdWzNdfWZ1bmN0aW9uIGMoYyxkLGUsZixnKXtmb3IodmFyIGg9W1sxLDAsMCwwXSxbMCwxLDAsMF0sWzAsMCwxLDBdLFswLDAsMCwxXV0saT0wO2k8NDtpKyspaFtpXVszXT1nW2ldO2Zvcih2YXIgaT0wO2k8MztpKyspZm9yKHZhciBqPTA7ajwzO2orKyloWzNdW2ldKz1jW2pdKmhbal1baV07dmFyIGs9ZlswXSxsPWZbMV0sbT1mWzJdLG49ZlszXSxvPVtbMSwwLDAsMF0sWzAsMSwwLDBdLFswLDAsMSwwXSxbMCwwLDAsMV1dO29bMF1bMF09MS0yKihsKmwrbSptKSxvWzBdWzFdPTIqKGsqbC1tKm4pLG9bMF1bMl09MiooayptK2wqbiksb1sxXVswXT0yKihrKmwrbSpuKSxvWzFdWzFdPTEtMiooayprK20qbSksb1sxXVsyXT0yKihsKm0taypuKSxvWzJdWzBdPTIqKGsqbS1sKm4pLG9bMl1bMV09MioobCptK2sqbiksb1syXVsyXT0xLTIqKGsqaytsKmwpLGg9YShoLG8pO3ZhciBwPVtbMSwwLDAsMF0sWzAsMSwwLDBdLFswLDAsMSwwXSxbMCwwLDAsMV1dO2VbMl0mJihwWzJdWzFdPWVbMl0saD1hKGgscCkpLGVbMV0mJihwWzJdWzFdPTAscFsyXVswXT1lWzBdLGg9YShoLHApKSxlWzBdJiYocFsyXVswXT0wLHBbMV1bMF09ZVswXSxoPWEoaCxwKSk7Zm9yKHZhciBpPTA7aTwzO2krKylmb3IodmFyIGo9MDtqPDM7aisrKWhbaV1bal0qPWRbaV07cmV0dXJuIGIoaCk/W2hbMF1bMF0saFswXVsxXSxoWzFdWzBdLGhbMV1bMV0saFszXVswXSxoWzNdWzFdXTpoWzBdLmNvbmNhdChoWzFdLGhbMl0saFszXSl9cmV0dXJuIGN9KCk7YS5jb21wb3NlTWF0cml4PWUsYS5xdWF0PWR9KGQsZiksZnVuY3Rpb24oYSxiLGMpe2Euc2VxdWVuY2VOdW1iZXI9MDt2YXIgZD1mdW5jdGlvbihhLGIsYyl7dGhpcy50YXJnZXQ9YSx0aGlzLmN1cnJlbnRUaW1lPWIsdGhpcy50aW1lbGluZVRpbWU9Yyx0aGlzLnR5cGU9XCJmaW5pc2hcIix0aGlzLmJ1YmJsZXM9ITEsdGhpcy5jYW5jZWxhYmxlPSExLHRoaXMuY3VycmVudFRhcmdldD1hLHRoaXMuZGVmYXVsdFByZXZlbnRlZD0hMSx0aGlzLmV2ZW50UGhhc2U9RXZlbnQuQVRfVEFSR0VULHRoaXMudGltZVN0YW1wPURhdGUubm93KCl9O2IuQW5pbWF0aW9uPWZ1bmN0aW9uKGIpe3RoaXMuaWQ9XCJcIixiJiZiLl9pZCYmKHRoaXMuaWQ9Yi5faWQpLHRoaXMuX3NlcXVlbmNlTnVtYmVyPWEuc2VxdWVuY2VOdW1iZXIrKyx0aGlzLl9jdXJyZW50VGltZT0wLHRoaXMuX3N0YXJ0VGltZT1udWxsLHRoaXMuX3BhdXNlZD0hMSx0aGlzLl9wbGF5YmFja1JhdGU9MSx0aGlzLl9pblRpbWVsaW5lPSEwLHRoaXMuX2ZpbmlzaGVkRmxhZz0hMCx0aGlzLm9uZmluaXNoPW51bGwsdGhpcy5fZmluaXNoSGFuZGxlcnM9W10sdGhpcy5fZWZmZWN0PWIsdGhpcy5faW5FZmZlY3Q9dGhpcy5fZWZmZWN0Ll91cGRhdGUoMCksdGhpcy5faWRsZT0hMCx0aGlzLl9jdXJyZW50VGltZVBlbmRpbmc9ITF9LGIuQW5pbWF0aW9uLnByb3RvdHlwZT17X2Vuc3VyZUFsaXZlOmZ1bmN0aW9uKCl7dGhpcy5wbGF5YmFja1JhdGU8MCYmMD09PXRoaXMuY3VycmVudFRpbWU/dGhpcy5faW5FZmZlY3Q9dGhpcy5fZWZmZWN0Ll91cGRhdGUoLTEpOnRoaXMuX2luRWZmZWN0PXRoaXMuX2VmZmVjdC5fdXBkYXRlKHRoaXMuY3VycmVudFRpbWUpLHRoaXMuX2luVGltZWxpbmV8fCF0aGlzLl9pbkVmZmVjdCYmdGhpcy5fZmluaXNoZWRGbGFnfHwodGhpcy5faW5UaW1lbGluZT0hMCxiLnRpbWVsaW5lLl9hbmltYXRpb25zLnB1c2godGhpcykpfSxfdGlja0N1cnJlbnRUaW1lOmZ1bmN0aW9uKGEsYil7YSE9dGhpcy5fY3VycmVudFRpbWUmJih0aGlzLl9jdXJyZW50VGltZT1hLHRoaXMuX2lzRmluaXNoZWQmJiFiJiYodGhpcy5fY3VycmVudFRpbWU9dGhpcy5fcGxheWJhY2tSYXRlPjA/dGhpcy5fdG90YWxEdXJhdGlvbjowKSx0aGlzLl9lbnN1cmVBbGl2ZSgpKX0sZ2V0IGN1cnJlbnRUaW1lKCl7cmV0dXJuIHRoaXMuX2lkbGV8fHRoaXMuX2N1cnJlbnRUaW1lUGVuZGluZz9udWxsOnRoaXMuX2N1cnJlbnRUaW1lfSxzZXQgY3VycmVudFRpbWUoYSl7YT0rYSxpc05hTihhKXx8KGIucmVzdGFydCgpLHRoaXMuX3BhdXNlZHx8bnVsbD09dGhpcy5fc3RhcnRUaW1lfHwodGhpcy5fc3RhcnRUaW1lPXRoaXMuX3RpbWVsaW5lLmN1cnJlbnRUaW1lLWEvdGhpcy5fcGxheWJhY2tSYXRlKSx0aGlzLl9jdXJyZW50VGltZVBlbmRpbmc9ITEsdGhpcy5fY3VycmVudFRpbWUhPWEmJih0aGlzLl9pZGxlJiYodGhpcy5faWRsZT0hMSx0aGlzLl9wYXVzZWQ9ITApLHRoaXMuX3RpY2tDdXJyZW50VGltZShhLCEwKSxiLmFwcGx5RGlydGllZEFuaW1hdGlvbih0aGlzKSkpfSxnZXQgc3RhcnRUaW1lKCl7cmV0dXJuIHRoaXMuX3N0YXJ0VGltZX0sc2V0IHN0YXJ0VGltZShhKXthPSthLGlzTmFOKGEpfHx0aGlzLl9wYXVzZWR8fHRoaXMuX2lkbGV8fCh0aGlzLl9zdGFydFRpbWU9YSx0aGlzLl90aWNrQ3VycmVudFRpbWUoKHRoaXMuX3RpbWVsaW5lLmN1cnJlbnRUaW1lLXRoaXMuX3N0YXJ0VGltZSkqdGhpcy5wbGF5YmFja1JhdGUpLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpKX0sZ2V0IHBsYXliYWNrUmF0ZSgpe3JldHVybiB0aGlzLl9wbGF5YmFja1JhdGV9LHNldCBwbGF5YmFja1JhdGUoYSl7aWYoYSE9dGhpcy5fcGxheWJhY2tSYXRlKXt2YXIgYz10aGlzLmN1cnJlbnRUaW1lO3RoaXMuX3BsYXliYWNrUmF0ZT1hLHRoaXMuX3N0YXJ0VGltZT1udWxsLFwicGF1c2VkXCIhPXRoaXMucGxheVN0YXRlJiZcImlkbGVcIiE9dGhpcy5wbGF5U3RhdGUmJih0aGlzLl9maW5pc2hlZEZsYWc9ITEsdGhpcy5faWRsZT0hMSx0aGlzLl9lbnN1cmVBbGl2ZSgpLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpKSxudWxsIT1jJiYodGhpcy5jdXJyZW50VGltZT1jKX19LGdldCBfaXNGaW5pc2hlZCgpe3JldHVybiF0aGlzLl9pZGxlJiYodGhpcy5fcGxheWJhY2tSYXRlPjAmJnRoaXMuX2N1cnJlbnRUaW1lPj10aGlzLl90b3RhbER1cmF0aW9ufHx0aGlzLl9wbGF5YmFja1JhdGU8MCYmdGhpcy5fY3VycmVudFRpbWU8PTApfSxnZXQgX3RvdGFsRHVyYXRpb24oKXtyZXR1cm4gdGhpcy5fZWZmZWN0Ll90b3RhbER1cmF0aW9ufSxnZXQgcGxheVN0YXRlKCl7cmV0dXJuIHRoaXMuX2lkbGU/XCJpZGxlXCI6bnVsbD09dGhpcy5fc3RhcnRUaW1lJiYhdGhpcy5fcGF1c2VkJiYwIT10aGlzLnBsYXliYWNrUmF0ZXx8dGhpcy5fY3VycmVudFRpbWVQZW5kaW5nP1wicGVuZGluZ1wiOnRoaXMuX3BhdXNlZD9cInBhdXNlZFwiOnRoaXMuX2lzRmluaXNoZWQ/XCJmaW5pc2hlZFwiOlwicnVubmluZ1wifSxfcmV3aW5kOmZ1bmN0aW9uKCl7aWYodGhpcy5fcGxheWJhY2tSYXRlPj0wKXRoaXMuX2N1cnJlbnRUaW1lPTA7ZWxzZXtpZighKHRoaXMuX3RvdGFsRHVyYXRpb248MS8wKSl0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiVW5hYmxlIHRvIHJld2luZCBuZWdhdGl2ZSBwbGF5YmFjayByYXRlIGFuaW1hdGlvbiB3aXRoIGluZmluaXRlIGR1cmF0aW9uXCIsXCJJbnZhbGlkU3RhdGVFcnJvclwiKTt0aGlzLl9jdXJyZW50VGltZT10aGlzLl90b3RhbER1cmF0aW9ufX0scGxheTpmdW5jdGlvbigpe3RoaXMuX3BhdXNlZD0hMSwodGhpcy5faXNGaW5pc2hlZHx8dGhpcy5faWRsZSkmJih0aGlzLl9yZXdpbmQoKSx0aGlzLl9zdGFydFRpbWU9bnVsbCksdGhpcy5fZmluaXNoZWRGbGFnPSExLHRoaXMuX2lkbGU9ITEsdGhpcy5fZW5zdXJlQWxpdmUoKSxiLmFwcGx5RGlydGllZEFuaW1hdGlvbih0aGlzKX0scGF1c2U6ZnVuY3Rpb24oKXt0aGlzLl9pc0ZpbmlzaGVkfHx0aGlzLl9wYXVzZWR8fHRoaXMuX2lkbGU/dGhpcy5faWRsZSYmKHRoaXMuX3Jld2luZCgpLHRoaXMuX2lkbGU9ITEpOnRoaXMuX2N1cnJlbnRUaW1lUGVuZGluZz0hMCx0aGlzLl9zdGFydFRpbWU9bnVsbCx0aGlzLl9wYXVzZWQ9ITB9LGZpbmlzaDpmdW5jdGlvbigpe3RoaXMuX2lkbGV8fCh0aGlzLmN1cnJlbnRUaW1lPXRoaXMuX3BsYXliYWNrUmF0ZT4wP3RoaXMuX3RvdGFsRHVyYXRpb246MCx0aGlzLl9zdGFydFRpbWU9dGhpcy5fdG90YWxEdXJhdGlvbi10aGlzLmN1cnJlbnRUaW1lLHRoaXMuX2N1cnJlbnRUaW1lUGVuZGluZz0hMSxiLmFwcGx5RGlydGllZEFuaW1hdGlvbih0aGlzKSl9LGNhbmNlbDpmdW5jdGlvbigpe3RoaXMuX2luRWZmZWN0JiYodGhpcy5faW5FZmZlY3Q9ITEsdGhpcy5faWRsZT0hMCx0aGlzLl9wYXVzZWQ9ITEsdGhpcy5faXNGaW5pc2hlZD0hMCx0aGlzLl9maW5pc2hlZEZsYWc9ITAsdGhpcy5fY3VycmVudFRpbWU9MCx0aGlzLl9zdGFydFRpbWU9bnVsbCx0aGlzLl9lZmZlY3QuX3VwZGF0ZShudWxsKSxiLmFwcGx5RGlydGllZEFuaW1hdGlvbih0aGlzKSl9LHJldmVyc2U6ZnVuY3Rpb24oKXt0aGlzLnBsYXliYWNrUmF0ZSo9LTEsdGhpcy5wbGF5KCl9LGFkZEV2ZW50TGlzdGVuZXI6ZnVuY3Rpb24oYSxiKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBiJiZcImZpbmlzaFwiPT1hJiZ0aGlzLl9maW5pc2hIYW5kbGVycy5wdXNoKGIpfSxyZW1vdmVFdmVudExpc3RlbmVyOmZ1bmN0aW9uKGEsYil7aWYoXCJmaW5pc2hcIj09YSl7dmFyIGM9dGhpcy5fZmluaXNoSGFuZGxlcnMuaW5kZXhPZihiKTtjPj0wJiZ0aGlzLl9maW5pc2hIYW5kbGVycy5zcGxpY2UoYywxKX19LF9maXJlRXZlbnRzOmZ1bmN0aW9uKGEpe2lmKHRoaXMuX2lzRmluaXNoZWQpe2lmKCF0aGlzLl9maW5pc2hlZEZsYWcpe3ZhciBiPW5ldyBkKHRoaXMsdGhpcy5fY3VycmVudFRpbWUsYSksYz10aGlzLl9maW5pc2hIYW5kbGVycy5jb25jYXQodGhpcy5vbmZpbmlzaD9bdGhpcy5vbmZpbmlzaF06W10pO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtjLmZvckVhY2goZnVuY3Rpb24oYSl7YS5jYWxsKGIudGFyZ2V0LGIpfSl9LDApLHRoaXMuX2ZpbmlzaGVkRmxhZz0hMH19ZWxzZSB0aGlzLl9maW5pc2hlZEZsYWc9ITF9LF90aWNrOmZ1bmN0aW9uKGEsYil7dGhpcy5faWRsZXx8dGhpcy5fcGF1c2VkfHwobnVsbD09dGhpcy5fc3RhcnRUaW1lP2ImJih0aGlzLnN0YXJ0VGltZT1hLXRoaXMuX2N1cnJlbnRUaW1lL3RoaXMucGxheWJhY2tSYXRlKTp0aGlzLl9pc0ZpbmlzaGVkfHx0aGlzLl90aWNrQ3VycmVudFRpbWUoKGEtdGhpcy5fc3RhcnRUaW1lKSp0aGlzLnBsYXliYWNrUmF0ZSkpLGImJih0aGlzLl9jdXJyZW50VGltZVBlbmRpbmc9ITEsdGhpcy5fZmlyZUV2ZW50cyhhKSl9LGdldCBfbmVlZHNUaWNrKCl7cmV0dXJuIHRoaXMucGxheVN0YXRlIGlue3BlbmRpbmc6MSxydW5uaW5nOjF9fHwhdGhpcy5fZmluaXNoZWRGbGFnfSxfdGFyZ2V0QW5pbWF0aW9uczpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX2VmZmVjdC5fdGFyZ2V0O3JldHVybiBhLl9hY3RpdmVBbmltYXRpb25zfHwoYS5fYWN0aXZlQW5pbWF0aW9ucz1bXSksYS5fYWN0aXZlQW5pbWF0aW9uc30sX21hcmtUYXJnZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl90YXJnZXRBbmltYXRpb25zKCk7YS5pbmRleE9mKHRoaXMpPT09LTEmJmEucHVzaCh0aGlzKX0sX3VubWFya1RhcmdldDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX3RhcmdldEFuaW1hdGlvbnMoKSxiPWEuaW5kZXhPZih0aGlzKTtiIT09LTEmJmEuc3BsaWNlKGIsMSl9fX0oYyxkLGYpLGZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGEpe3ZhciBiPWo7aj1bXSxhPHEuY3VycmVudFRpbWUmJihhPXEuY3VycmVudFRpbWUpLHEuX2FuaW1hdGlvbnMuc29ydChlKSxxLl9hbmltYXRpb25zPWgoYSwhMCxxLl9hbmltYXRpb25zKVswXSxiLmZvckVhY2goZnVuY3Rpb24oYil7YlsxXShhKX0pLGcoKSxsPXZvaWQgMH1mdW5jdGlvbiBlKGEsYil7cmV0dXJuIGEuX3NlcXVlbmNlTnVtYmVyLWIuX3NlcXVlbmNlTnVtYmVyfWZ1bmN0aW9uIGYoKXt0aGlzLl9hbmltYXRpb25zPVtdLHRoaXMuY3VycmVudFRpbWU9d2luZG93LnBlcmZvcm1hbmNlJiZwZXJmb3JtYW5jZS5ub3c/cGVyZm9ybWFuY2Uubm93KCk6MH1mdW5jdGlvbiBnKCl7by5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EoKX0pLG8ubGVuZ3RoPTB9ZnVuY3Rpb24gaChhLGMsZCl7cD0hMCxuPSExO3ZhciBlPWIudGltZWxpbmU7ZS5jdXJyZW50VGltZT1hLG09ITE7dmFyIGY9W10sZz1bXSxoPVtdLGk9W107cmV0dXJuIGQuZm9yRWFjaChmdW5jdGlvbihiKXtiLl90aWNrKGEsYyksYi5faW5FZmZlY3Q/KGcucHVzaChiLl9lZmZlY3QpLGIuX21hcmtUYXJnZXQoKSk6KGYucHVzaChiLl9lZmZlY3QpLGIuX3VubWFya1RhcmdldCgpKSxiLl9uZWVkc1RpY2smJihtPSEwKTt2YXIgZD1iLl9pbkVmZmVjdHx8Yi5fbmVlZHNUaWNrO2IuX2luVGltZWxpbmU9ZCxkP2gucHVzaChiKTppLnB1c2goYil9KSxvLnB1c2guYXBwbHkobyxmKSxvLnB1c2guYXBwbHkobyxnKSxtJiZyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXt9KSxwPSExLFtoLGldfXZhciBpPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsaj1bXSxrPTA7d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT1mdW5jdGlvbihhKXt2YXIgYj1rKys7cmV0dXJuIDA9PWoubGVuZ3RoJiZpKGQpLGoucHVzaChbYixhXSksYn0sd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lPWZ1bmN0aW9uKGEpe2ouZm9yRWFjaChmdW5jdGlvbihiKXtiWzBdPT1hJiYoYlsxXT1mdW5jdGlvbigpe30pfSl9LGYucHJvdG90eXBlPXtfcGxheTpmdW5jdGlvbihjKXtjLl90aW1pbmc9YS5ub3JtYWxpemVUaW1pbmdJbnB1dChjLnRpbWluZyk7dmFyIGQ9bmV3IGIuQW5pbWF0aW9uKGMpO3JldHVybiBkLl9pZGxlPSExLGQuX3RpbWVsaW5lPXRoaXMsdGhpcy5fYW5pbWF0aW9ucy5wdXNoKGQpLGIucmVzdGFydCgpLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKGQpLGR9fTt2YXIgbD12b2lkIDAsbT0hMSxuPSExO2IucmVzdGFydD1mdW5jdGlvbigpe3JldHVybiBtfHwobT0hMCxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXt9KSxuPSEwKSxufSxiLmFwcGx5RGlydGllZEFuaW1hdGlvbj1mdW5jdGlvbihhKXtpZighcCl7YS5fbWFya1RhcmdldCgpO3ZhciBjPWEuX3RhcmdldEFuaW1hdGlvbnMoKTtjLnNvcnQoZSk7dmFyIGQ9aChiLnRpbWVsaW5lLmN1cnJlbnRUaW1lLCExLGMuc2xpY2UoKSlbMV07ZC5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPXEuX2FuaW1hdGlvbnMuaW5kZXhPZihhKTtiIT09LTEmJnEuX2FuaW1hdGlvbnMuc3BsaWNlKGIsMSl9KSxnKCl9fTt2YXIgbz1bXSxwPSExLHE9bmV3IGY7Yi50aW1lbGluZT1xfShjLGQsZiksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYil7Zm9yKHZhciBjPTAsZD0wO2Q8YS5sZW5ndGg7ZCsrKWMrPWFbZF0qYltkXTtyZXR1cm4gY31mdW5jdGlvbiBkKGEsYil7cmV0dXJuW2FbMF0qYlswXSthWzRdKmJbMV0rYVs4XSpiWzJdK2FbMTJdKmJbM10sYVsxXSpiWzBdK2FbNV0qYlsxXSthWzldKmJbMl0rYVsxM10qYlszXSxhWzJdKmJbMF0rYVs2XSpiWzFdK2FbMTBdKmJbMl0rYVsxNF0qYlszXSxhWzNdKmJbMF0rYVs3XSpiWzFdK2FbMTFdKmJbMl0rYVsxNV0qYlszXSxhWzBdKmJbNF0rYVs0XSpiWzVdK2FbOF0qYls2XSthWzEyXSpiWzddLGFbMV0qYls0XSthWzVdKmJbNV0rYVs5XSpiWzZdK2FbMTNdKmJbN10sYVsyXSpiWzRdK2FbNl0qYls1XSthWzEwXSpiWzZdK2FbMTRdKmJbN10sYVszXSpiWzRdK2FbN10qYls1XSthWzExXSpiWzZdK2FbMTVdKmJbN10sYVswXSpiWzhdK2FbNF0qYls5XSthWzhdKmJbMTBdK2FbMTJdKmJbMTFdLGFbMV0qYls4XSthWzVdKmJbOV0rYVs5XSpiWzEwXSthWzEzXSpiWzExXSxhWzJdKmJbOF0rYVs2XSpiWzldK2FbMTBdKmJbMTBdK2FbMTRdKmJbMTFdLGFbM10qYls4XSthWzddKmJbOV0rYVsxMV0qYlsxMF0rYVsxNV0qYlsxMV0sYVswXSpiWzEyXSthWzRdKmJbMTNdK2FbOF0qYlsxNF0rYVsxMl0qYlsxNV0sYVsxXSpiWzEyXSthWzVdKmJbMTNdK2FbOV0qYlsxNF0rYVsxM10qYlsxNV0sYVsyXSpiWzEyXSthWzZdKmJbMTNdK2FbMTBdKmJbMTRdK2FbMTRdKmJbMTVdLGFbM10qYlsxMl0rYVs3XSpiWzEzXSthWzExXSpiWzE0XSthWzE1XSpiWzE1XV19ZnVuY3Rpb24gZShhKXt2YXIgYj1hLnJhZHx8MCxjPWEuZGVnfHwwLGQ9YS5ncmFkfHwwLGU9YS50dXJufHwwLGY9KGMvMzYwK2QvNDAwK2UpKigyKk1hdGguUEkpK2I7cmV0dXJuIGZ9ZnVuY3Rpb24gZihhKXtzd2l0Y2goYS50KXtjYXNlXCJyb3RhdGV4XCI6dmFyIGI9ZShhLmRbMF0pO3JldHVyblsxLDAsMCwwLDAsTWF0aC5jb3MoYiksTWF0aC5zaW4oYiksMCwwLC1NYXRoLnNpbihiKSxNYXRoLmNvcyhiKSwwLDAsMCwwLDFdO2Nhc2VcInJvdGF0ZXlcIjp2YXIgYj1lKGEuZFswXSk7cmV0dXJuW01hdGguY29zKGIpLDAsLU1hdGguc2luKGIpLDAsMCwxLDAsMCxNYXRoLnNpbihiKSwwLE1hdGguY29zKGIpLDAsMCwwLDAsMV07Y2FzZVwicm90YXRlXCI6Y2FzZVwicm90YXRlelwiOnZhciBiPWUoYS5kWzBdKTtyZXR1cm5bTWF0aC5jb3MoYiksTWF0aC5zaW4oYiksMCwwLC1NYXRoLnNpbihiKSxNYXRoLmNvcyhiKSwwLDAsMCwwLDEsMCwwLDAsMCwxXTtjYXNlXCJyb3RhdGUzZFwiOnZhciBjPWEuZFswXSxkPWEuZFsxXSxmPWEuZFsyXSxiPWUoYS5kWzNdKSxnPWMqYytkKmQrZipmO2lmKDA9PT1nKWM9MSxkPTAsZj0wO2Vsc2UgaWYoMSE9PWcpe3ZhciBoPU1hdGguc3FydChnKTtjLz1oLGQvPWgsZi89aH12YXIgaT1NYXRoLnNpbihiLzIpLGo9aSpNYXRoLmNvcyhiLzIpLGs9aSppO3JldHVyblsxLTIqKGQqZCtmKmYpKmssMiooYypkKmsrZipqKSwyKihjKmYqay1kKmopLDAsMiooYypkKmstZipqKSwxLTIqKGMqYytmKmYpKmssMiooZCpmKmsrYypqKSwwLDIqKGMqZiprK2QqaiksMiooZCpmKmstYypqKSwxLTIqKGMqYytkKmQpKmssMCwwLDAsMCwxXTtjYXNlXCJzY2FsZVwiOnJldHVyblthLmRbMF0sMCwwLDAsMCxhLmRbMV0sMCwwLDAsMCwxLDAsMCwwLDAsMV07Y2FzZVwic2NhbGV4XCI6cmV0dXJuW2EuZFswXSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMV07Y2FzZVwic2NhbGV5XCI6cmV0dXJuWzEsMCwwLDAsMCxhLmRbMF0sMCwwLDAsMCwxLDAsMCwwLDAsMV07Y2FzZVwic2NhbGV6XCI6cmV0dXJuWzEsMCwwLDAsMCwxLDAsMCwwLDAsYS5kWzBdLDAsMCwwLDAsMV07Y2FzZVwic2NhbGUzZFwiOnJldHVyblthLmRbMF0sMCwwLDAsMCxhLmRbMV0sMCwwLDAsMCxhLmRbMl0sMCwwLDAsMCwxXTtjYXNlXCJza2V3XCI6dmFyIGw9ZShhLmRbMF0pLG09ZShhLmRbMV0pO3JldHVyblsxLE1hdGgudGFuKG0pLDAsMCxNYXRoLnRhbihsKSwxLDAsMCwwLDAsMSwwLDAsMCwwLDFdO2Nhc2VcInNrZXd4XCI6dmFyIGI9ZShhLmRbMF0pO3JldHVyblsxLDAsMCwwLE1hdGgudGFuKGIpLDEsMCwwLDAsMCwxLDAsMCwwLDAsMV07Y2FzZVwic2tld3lcIjp2YXIgYj1lKGEuZFswXSk7cmV0dXJuWzEsTWF0aC50YW4oYiksMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXTtjYXNlXCJ0cmFuc2xhdGVcIjp2YXIgYz1hLmRbMF0ucHh8fDAsZD1hLmRbMV0ucHh8fDA7cmV0dXJuWzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLGMsZCwwLDFdO2Nhc2VcInRyYW5zbGF0ZXhcIjp2YXIgYz1hLmRbMF0ucHh8fDA7cmV0dXJuWzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLGMsMCwwLDFdO2Nhc2VcInRyYW5zbGF0ZXlcIjp2YXIgZD1hLmRbMF0ucHh8fDA7cmV0dXJuWzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsZCwwLDFdO2Nhc2VcInRyYW5zbGF0ZXpcIjp2YXIgZj1hLmRbMF0ucHh8fDA7cmV0dXJuWzEsMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCxmLDFdO2Nhc2VcInRyYW5zbGF0ZTNkXCI6dmFyIGM9YS5kWzBdLnB4fHwwLGQ9YS5kWzFdLnB4fHwwLGY9YS5kWzJdLnB4fHwwO3JldHVyblsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCxjLGQsZiwxXTtjYXNlXCJwZXJzcGVjdGl2ZVwiOnZhciBuPWEuZFswXS5weD8tMS9hLmRbMF0ucHg6MDtyZXR1cm5bMSwwLDAsMCwwLDEsMCwwLDAsMCwxLG4sMCwwLDAsMV07Y2FzZVwibWF0cml4XCI6cmV0dXJuW2EuZFswXSxhLmRbMV0sMCwwLGEuZFsyXSxhLmRbM10sMCwwLDAsMCwxLDAsYS5kWzRdLGEuZFs1XSwwLDFdO2Nhc2VcIm1hdHJpeDNkXCI6cmV0dXJuIGEuZH19ZnVuY3Rpb24gZyhhKXtyZXR1cm4gMD09PWEubGVuZ3RoP1sxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXTphLm1hcChmKS5yZWR1Y2UoZCl9ZnVuY3Rpb24gaChhKXtyZXR1cm5baShnKGEpKV19dmFyIGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEpe3JldHVybiBhWzBdWzBdKmFbMV1bMV0qYVsyXVsyXSthWzFdWzBdKmFbMl1bMV0qYVswXVsyXSthWzJdWzBdKmFbMF1bMV0qYVsxXVsyXS1hWzBdWzJdKmFbMV1bMV0qYVsyXVswXS1hWzFdWzJdKmFbMl1bMV0qYVswXVswXS1hWzJdWzJdKmFbMF1bMV0qYVsxXVswXX1mdW5jdGlvbiBiKGIpe2Zvcih2YXIgYz0xL2EoYiksZD1iWzBdWzBdLGU9YlswXVsxXSxmPWJbMF1bMl0sZz1iWzFdWzBdLGg9YlsxXVsxXSxpPWJbMV1bMl0saj1iWzJdWzBdLGs9YlsyXVsxXSxsPWJbMl1bMl0sbT1bWyhoKmwtaSprKSpjLChmKmstZSpsKSpjLChlKmktZipoKSpjLDBdLFsoaSpqLWcqbCkqYywoZCpsLWYqaikqYywoZipnLWQqaSkqYywwXSxbKGcqay1oKmopKmMsKGoqZS1kKmspKmMsKGQqaC1lKmcpKmMsMF1dLG49W10sbz0wO288MztvKyspe2Zvcih2YXIgcD0wLHE9MDtxPDM7cSsrKXArPWJbM11bcV0qbVtxXVtvXTtuLnB1c2gocCl9cmV0dXJuIG4ucHVzaCgxKSxtLnB1c2gobiksbX1mdW5jdGlvbiBkKGEpe3JldHVybltbYVswXVswXSxhWzFdWzBdLGFbMl1bMF0sYVszXVswXV0sW2FbMF1bMV0sYVsxXVsxXSxhWzJdWzFdLGFbM11bMV1dLFthWzBdWzJdLGFbMV1bMl0sYVsyXVsyXSxhWzNdWzJdXSxbYVswXVszXSxhWzFdWzNdLGFbMl1bM10sYVszXVszXV1dfWZ1bmN0aW9uIGUoYSxiKXtmb3IodmFyIGM9W10sZD0wO2Q8NDtkKyspe2Zvcih2YXIgZT0wLGY9MDtmPDQ7ZisrKWUrPWFbZl0qYltmXVtkXTtjLnB1c2goZSl9cmV0dXJuIGN9ZnVuY3Rpb24gZihhKXt2YXIgYj1nKGEpO3JldHVyblthWzBdL2IsYVsxXS9iLGFbMl0vYl19ZnVuY3Rpb24gZyhhKXtyZXR1cm4gTWF0aC5zcXJ0KGFbMF0qYVswXSthWzFdKmFbMV0rYVsyXSphWzJdKX1mdW5jdGlvbiBoKGEsYixjLGQpe3JldHVybltjKmFbMF0rZCpiWzBdLGMqYVsxXStkKmJbMV0sYyphWzJdK2QqYlsyXV19ZnVuY3Rpb24gaShhLGIpe3JldHVyblthWzFdKmJbMl0tYVsyXSpiWzFdLGFbMl0qYlswXS1hWzBdKmJbMl0sYVswXSpiWzFdLWFbMV0qYlswXV19ZnVuY3Rpb24gaihqKXt2YXIgaz1bai5zbGljZSgwLDQpLGouc2xpY2UoNCw4KSxqLnNsaWNlKDgsMTIpLGouc2xpY2UoMTIsMTYpXTtpZigxIT09a1szXVszXSlyZXR1cm4gbnVsbDtmb3IodmFyIGw9W10sbT0wO208NDttKyspbC5wdXNoKGtbbV0uc2xpY2UoKSk7Zm9yKHZhciBtPTA7bTwzO20rKylsW21dWzNdPTA7aWYoMD09PWEobCkpcmV0dXJuITE7dmFyIG4sbz1bXTtpZihrWzBdWzNdfHxrWzFdWzNdfHxrWzJdWzNdKXtvLnB1c2goa1swXVszXSksby5wdXNoKGtbMV1bM10pLG8ucHVzaChrWzJdWzNdKSxvLnB1c2goa1szXVszXSk7dmFyIHA9YihsKSxxPWQocCk7bj1lKG8scSl9ZWxzZSBuPVswLDAsMCwxXTt2YXIgcj1rWzNdLnNsaWNlKDAsMykscz1bXTtzLnB1c2goa1swXS5zbGljZSgwLDMpKTt2YXIgdD1bXTt0LnB1c2goZyhzWzBdKSksc1swXT1mKHNbMF0pO3ZhciB1PVtdO3MucHVzaChrWzFdLnNsaWNlKDAsMykpLHUucHVzaChjKHNbMF0sc1sxXSkpLHNbMV09aChzWzFdLHNbMF0sMSwtdVswXSksdC5wdXNoKGcoc1sxXSkpLHNbMV09ZihzWzFdKSx1WzBdLz10WzFdLHMucHVzaChrWzJdLnNsaWNlKDAsMykpLHUucHVzaChjKHNbMF0sc1syXSkpLHNbMl09aChzWzJdLHNbMF0sMSwtdVsxXSksdS5wdXNoKGMoc1sxXSxzWzJdKSksc1syXT1oKHNbMl0sc1sxXSwxLC11WzJdKSx0LnB1c2goZyhzWzJdKSksc1syXT1mKHNbMl0pLHVbMV0vPXRbMl0sdVsyXS89dFsyXTt2YXIgdj1pKHNbMV0sc1syXSk7aWYoYyhzWzBdLHYpPDApZm9yKHZhciBtPTA7bTwzO20rKyl0W21dKj0tMSxzW21dWzBdKj0tMSxzW21dWzFdKj0tMSxzW21dWzJdKj0tMTt2YXIgdyx4LHk9c1swXVswXStzWzFdWzFdK3NbMl1bMl0rMTtyZXR1cm4geT4xZS00Pyh3PS41L01hdGguc3FydCh5KSx4PVsoc1syXVsxXS1zWzFdWzJdKSp3LChzWzBdWzJdLXNbMl1bMF0pKncsKHNbMV1bMF0tc1swXVsxXSkqdywuMjUvd10pOnNbMF1bMF0+c1sxXVsxXSYmc1swXVswXT5zWzJdWzJdPyh3PTIqTWF0aC5zcXJ0KDErc1swXVswXS1zWzFdWzFdLXNbMl1bMl0pLHg9Wy4yNSp3LChzWzBdWzFdK3NbMV1bMF0pL3csKHNbMF1bMl0rc1syXVswXSkvdywoc1syXVsxXS1zWzFdWzJdKS93XSk6c1sxXVsxXT5zWzJdWzJdPyh3PTIqTWF0aC5zcXJ0KDErc1sxXVsxXS1zWzBdWzBdLXNbMl1bMl0pLHg9WyhzWzBdWzFdK3NbMV1bMF0pL3csLjI1KncsKHNbMV1bMl0rc1syXVsxXSkvdywoc1swXVsyXS1zWzJdWzBdKS93XSk6KHc9MipNYXRoLnNxcnQoMStzWzJdWzJdLXNbMF1bMF0tc1sxXVsxXSkseD1bKHNbMF1bMl0rc1syXVswXSkvdywoc1sxXVsyXStzWzJdWzFdKS93LC4yNSp3LChzWzFdWzBdLXNbMF1bMV0pL3ddKSxbcix0LHUseCxuXX1yZXR1cm4gan0oKTthLmRvdD1jLGEubWFrZU1hdHJpeERlY29tcG9zaXRpb249aH0oZCxmKSxmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEsYil7dmFyIGM9YS5leGVjKGIpO2lmKGMpcmV0dXJuIGM9YS5pZ25vcmVDYXNlP2NbMF0udG9Mb3dlckNhc2UoKTpjWzBdLFtjLGIuc3Vic3RyKGMubGVuZ3RoKV19ZnVuY3Rpb24gYyhhLGIpe2I9Yi5yZXBsYWNlKC9eXFxzKi8sXCJcIik7dmFyIGM9YShiKTtpZihjKXJldHVybltjWzBdLGNbMV0ucmVwbGFjZSgvXlxccyovLFwiXCIpXX1mdW5jdGlvbiBkKGEsZCxlKXthPWMuYmluZChudWxsLGEpO2Zvcih2YXIgZj1bXTs7KXt2YXIgZz1hKGUpO2lmKCFnKXJldHVybltmLGVdO2lmKGYucHVzaChnWzBdKSxlPWdbMV0sZz1iKGQsZSksIWd8fFwiXCI9PWdbMV0pcmV0dXJuW2YsZV07ZT1nWzFdfX1mdW5jdGlvbiBlKGEsYil7Zm9yKHZhciBjPTAsZD0wO2Q8Yi5sZW5ndGgmJighL1xcc3wsLy50ZXN0KGJbZF0pfHwwIT1jKTtkKyspaWYoXCIoXCI9PWJbZF0pYysrO2Vsc2UgaWYoXCIpXCI9PWJbZF0mJihjLS0sMD09YyYmZCsrLGM8PTApKWJyZWFrO3ZhciBlPWEoYi5zdWJzdHIoMCxkKSk7cmV0dXJuIHZvaWQgMD09ZT92b2lkIDA6W2UsYi5zdWJzdHIoZCldfWZ1bmN0aW9uIGYoYSxiKXtmb3IodmFyIGM9YSxkPWI7YyYmZDspYz5kP2MlPWQ6ZCU9YztyZXR1cm4gYz1hKmIvKGMrZCl9ZnVuY3Rpb24gZyhhKXtyZXR1cm4gZnVuY3Rpb24oYil7dmFyIGM9YShiKTtyZXR1cm4gYyYmKGNbMF09dm9pZCAwKSxjfX1mdW5jdGlvbiBoKGEsYil7cmV0dXJuIGZ1bmN0aW9uKGMpe3ZhciBkPWEoYyk7cmV0dXJuIGQ/ZDpbYixjXX19ZnVuY3Rpb24gaShiLGMpe2Zvcih2YXIgZD1bXSxlPTA7ZTxiLmxlbmd0aDtlKyspe3ZhciBmPWEuY29uc3VtZVRyaW1tZWQoYltlXSxjKTtpZighZnx8XCJcIj09ZlswXSlyZXR1cm47dm9pZCAwIT09ZlswXSYmZC5wdXNoKGZbMF0pLGM9ZlsxXX1pZihcIlwiPT1jKXJldHVybiBkfWZ1bmN0aW9uIGooYSxiLGMsZCxlKXtmb3IodmFyIGc9W10saD1bXSxpPVtdLGo9ZihkLmxlbmd0aCxlLmxlbmd0aCksaz0wO2s8ajtrKyspe3ZhciBsPWIoZFtrJWQubGVuZ3RoXSxlW2slZS5sZW5ndGhdKTtpZighbClyZXR1cm47Zy5wdXNoKGxbMF0pLGgucHVzaChsWzFdKSxpLnB1c2gobFsyXSl9cmV0dXJuW2csaCxmdW5jdGlvbihiKXt2YXIgZD1iLm1hcChmdW5jdGlvbihhLGIpe3JldHVybiBpW2JdKGEpfSkuam9pbihjKTtyZXR1cm4gYT9hKGQpOmR9XX1mdW5jdGlvbiBrKGEsYixjKXtmb3IodmFyIGQ9W10sZT1bXSxmPVtdLGc9MCxoPTA7aDxjLmxlbmd0aDtoKyspaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgY1toXSl7dmFyIGk9Y1toXShhW2ddLGJbZysrXSk7ZC5wdXNoKGlbMF0pLGUucHVzaChpWzFdKSxmLnB1c2goaVsyXSl9ZWxzZSFmdW5jdGlvbihhKXtkLnB1c2goITEpLGUucHVzaCghMSksZi5wdXNoKGZ1bmN0aW9uKCl7cmV0dXJuIGNbYV19KX0oaCk7cmV0dXJuW2QsZSxmdW5jdGlvbihhKXtmb3IodmFyIGI9XCJcIixjPTA7YzxhLmxlbmd0aDtjKyspYis9ZltjXShhW2NdKTtyZXR1cm4gYn1dfWEuY29uc3VtZVRva2VuPWIsYS5jb25zdW1lVHJpbW1lZD1jLGEuY29uc3VtZVJlcGVhdGVkPWQsYS5jb25zdW1lUGFyZW50aGVzaXNlZD1lLGEuaWdub3JlPWcsYS5vcHRpb25hbD1oLGEuY29uc3VtZUxpc3Q9aSxhLm1lcmdlTmVzdGVkUmVwZWF0ZWQ9ai5iaW5kKG51bGwsbnVsbCksYS5tZXJnZVdyYXBwZWROZXN0ZWRSZXBlYXRlZD1qLGEubWVyZ2VMaXN0PWt9KGQpLGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYil7ZnVuY3Rpb24gYyhiKXt2YXIgYz1hLmNvbnN1bWVUb2tlbigvXmluc2V0L2ksYik7aWYoYylyZXR1cm4gZC5pbnNldD0hMCxjO3ZhciBjPWEuY29uc3VtZUxlbmd0aE9yUGVyY2VudChiKTtpZihjKXJldHVybiBkLmxlbmd0aHMucHVzaChjWzBdKSxjO3ZhciBjPWEuY29uc3VtZUNvbG9yKGIpO3JldHVybiBjPyhkLmNvbG9yPWNbMF0sYyk6dm9pZCAwfXZhciBkPXtpbnNldDohMSxsZW5ndGhzOltdLGNvbG9yOm51bGx9LGU9YS5jb25zdW1lUmVwZWF0ZWQoYywvXi8sYik7aWYoZSYmZVswXS5sZW5ndGgpcmV0dXJuW2QsZVsxXV19ZnVuY3Rpb24gYyhjKXt2YXIgZD1hLmNvbnN1bWVSZXBlYXRlZChiLC9eLC8sYyk7aWYoZCYmXCJcIj09ZFsxXSlyZXR1cm4gZFswXX1mdW5jdGlvbiBkKGIsYyl7Zm9yKDtiLmxlbmd0aHMubGVuZ3RoPE1hdGgubWF4KGIubGVuZ3Rocy5sZW5ndGgsYy5sZW5ndGhzLmxlbmd0aCk7KWIubGVuZ3Rocy5wdXNoKHtweDowfSk7Zm9yKDtjLmxlbmd0aHMubGVuZ3RoPE1hdGgubWF4KGIubGVuZ3Rocy5sZW5ndGgsYy5sZW5ndGhzLmxlbmd0aCk7KWMubGVuZ3Rocy5wdXNoKHtweDowfSk7aWYoYi5pbnNldD09Yy5pbnNldCYmISFiLmNvbG9yPT0hIWMuY29sb3Ipe2Zvcih2YXIgZCxlPVtdLGY9W1tdLDBdLGc9W1tdLDBdLGg9MDtoPGIubGVuZ3Rocy5sZW5ndGg7aCsrKXt2YXIgaT1hLm1lcmdlRGltZW5zaW9ucyhiLmxlbmd0aHNbaF0sYy5sZW5ndGhzW2hdLDI9PWgpO2ZbMF0ucHVzaChpWzBdKSxnWzBdLnB1c2goaVsxXSksZS5wdXNoKGlbMl0pfWlmKGIuY29sb3ImJmMuY29sb3Ipe3ZhciBqPWEubWVyZ2VDb2xvcnMoYi5jb2xvcixjLmNvbG9yKTtmWzFdPWpbMF0sZ1sxXT1qWzFdLGQ9alsyXTtcbn1yZXR1cm5bZixnLGZ1bmN0aW9uKGEpe2Zvcih2YXIgYz1iLmluc2V0P1wiaW5zZXQgXCI6XCIgXCIsZj0wO2Y8ZS5sZW5ndGg7ZisrKWMrPWVbZl0oYVswXVtmXSkrXCIgXCI7cmV0dXJuIGQmJihjKz1kKGFbMV0pKSxjfV19fWZ1bmN0aW9uIGUoYixjLGQsZSl7ZnVuY3Rpb24gZihhKXtyZXR1cm57aW5zZXQ6YSxjb2xvcjpbMCwwLDAsMF0sbGVuZ3Roczpbe3B4OjB9LHtweDowfSx7cHg6MH0se3B4OjB9XX19Zm9yKHZhciBnPVtdLGg9W10saT0wO2k8ZC5sZW5ndGh8fGk8ZS5sZW5ndGg7aSsrKXt2YXIgaj1kW2ldfHxmKGVbaV0uaW5zZXQpLGs9ZVtpXXx8ZihkW2ldLmluc2V0KTtnLnB1c2goaiksaC5wdXNoKGspfXJldHVybiBhLm1lcmdlTmVzdGVkUmVwZWF0ZWQoYixjLGcsaCl9dmFyIGY9ZS5iaW5kKG51bGwsZCxcIiwgXCIpO2EuYWRkUHJvcGVydGllc0hhbmRsZXIoYyxmLFtcImJveC1zaGFkb3dcIixcInRleHQtc2hhZG93XCJdKX0oZCksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe3JldHVybiBhLnRvRml4ZWQoMykucmVwbGFjZShcIi4wMDBcIixcIlwiKX1mdW5jdGlvbiBkKGEsYixjKXtyZXR1cm4gTWF0aC5taW4oYixNYXRoLm1heChhLGMpKX1mdW5jdGlvbiBlKGEpe2lmKC9eXFxzKlstK10/KFxcZCpcXC4pP1xcZCtcXHMqJC8udGVzdChhKSlyZXR1cm4gTnVtYmVyKGEpfWZ1bmN0aW9uIGYoYSxiKXtyZXR1cm5bYSxiLGNdfWZ1bmN0aW9uIGcoYSxiKXtpZigwIT1hKXJldHVybiBpKDAsMS8wKShhLGIpfWZ1bmN0aW9uIGgoYSxiKXtyZXR1cm5bYSxiLGZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLnJvdW5kKGQoMSwxLzAsYSkpfV19ZnVuY3Rpb24gaShhLGIpe3JldHVybiBmdW5jdGlvbihlLGYpe3JldHVybltlLGYsZnVuY3Rpb24oZSl7cmV0dXJuIGMoZChhLGIsZSkpfV19fWZ1bmN0aW9uIGooYSxiKXtyZXR1cm5bYSxiLE1hdGgucm91bmRdfWEuY2xhbXA9ZCxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGUsaSgwLDEvMCksW1wiYm9yZGVyLWltYWdlLXdpZHRoXCIsXCJsaW5lLWhlaWdodFwiXSksYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihlLGkoMCwxKSxbXCJvcGFjaXR5XCIsXCJzaGFwZS1pbWFnZS10aHJlc2hvbGRcIl0pLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoZSxnLFtcImZsZXgtZ3Jvd1wiLFwiZmxleC1zaHJpbmtcIl0pLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoZSxoLFtcIm9ycGhhbnNcIixcIndpZG93c1wiXSksYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihlLGosW1wiei1pbmRleFwiXSksYS5wYXJzZU51bWJlcj1lLGEubWVyZ2VOdW1iZXJzPWYsYS5udW1iZXJUb1N0cmluZz1jfShkLGYpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIpe2lmKFwidmlzaWJsZVwiPT1hfHxcInZpc2libGVcIj09YilyZXR1cm5bMCwxLGZ1bmN0aW9uKGMpe3JldHVybiBjPD0wP2E6Yz49MT9iOlwidmlzaWJsZVwifV19YS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihTdHJpbmcsYyxbXCJ2aXNpYmlsaXR5XCJdKX0oZCksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe2E9YS50cmltKCksZi5maWxsU3R5bGU9XCIjMDAwXCIsZi5maWxsU3R5bGU9YTt2YXIgYj1mLmZpbGxTdHlsZTtpZihmLmZpbGxTdHlsZT1cIiNmZmZcIixmLmZpbGxTdHlsZT1hLGI9PWYuZmlsbFN0eWxlKXtmLmZpbGxSZWN0KDAsMCwxLDEpO3ZhciBjPWYuZ2V0SW1hZ2VEYXRhKDAsMCwxLDEpLmRhdGE7Zi5jbGVhclJlY3QoMCwwLDEsMSk7dmFyIGQ9Y1szXS8yNTU7cmV0dXJuW2NbMF0qZCxjWzFdKmQsY1syXSpkLGRdfX1mdW5jdGlvbiBkKGIsYyl7cmV0dXJuW2IsYyxmdW5jdGlvbihiKXtmdW5jdGlvbiBjKGEpe3JldHVybiBNYXRoLm1heCgwLE1hdGgubWluKDI1NSxhKSl9aWYoYlszXSlmb3IodmFyIGQ9MDtkPDM7ZCsrKWJbZF09TWF0aC5yb3VuZChjKGJbZF0vYlszXSkpO3JldHVybiBiWzNdPWEubnVtYmVyVG9TdHJpbmcoYS5jbGFtcCgwLDEsYlszXSkpLFwicmdiYShcIitiLmpvaW4oXCIsXCIpK1wiKVwifV19dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFwiY2FudmFzXCIpO2Uud2lkdGg9ZS5oZWlnaHQ9MTt2YXIgZj1lLmdldENvbnRleHQoXCIyZFwiKTthLmFkZFByb3BlcnRpZXNIYW5kbGVyKGMsZCxbXCJiYWNrZ3JvdW5kLWNvbG9yXCIsXCJib3JkZXItYm90dG9tLWNvbG9yXCIsXCJib3JkZXItbGVmdC1jb2xvclwiLFwiYm9yZGVyLXJpZ2h0LWNvbG9yXCIsXCJib3JkZXItdG9wLWNvbG9yXCIsXCJjb2xvclwiLFwib3V0bGluZS1jb2xvclwiLFwidGV4dC1kZWNvcmF0aW9uLWNvbG9yXCJdKSxhLmNvbnN1bWVDb2xvcj1hLmNvbnN1bWVQYXJlbnRoZXNpc2VkLmJpbmQobnVsbCxjKSxhLm1lcmdlQ29sb3JzPWR9KGQsZiksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYil7aWYoYj1iLnRyaW0oKS50b0xvd2VyQ2FzZSgpLFwiMFwiPT1iJiZcInB4XCIuc2VhcmNoKGEpPj0wKXJldHVybntweDowfTtpZigvXlteKF0qJHxeY2FsYy8udGVzdChiKSl7Yj1iLnJlcGxhY2UoL2NhbGNcXCgvZyxcIihcIik7dmFyIGM9e307Yj1iLnJlcGxhY2UoYSxmdW5jdGlvbihhKXtyZXR1cm4gY1thXT1udWxsLFwiVVwiK2F9KTtmb3IodmFyIGQ9XCJVKFwiK2Euc291cmNlK1wiKVwiLGU9Yi5yZXBsYWNlKC9bLStdPyhcXGQqXFwuKT9cXGQrL2csXCJOXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChcIk5cIitkLFwiZ1wiKSxcIkRcIikucmVwbGFjZSgvXFxzWystXVxccy9nLFwiT1wiKS5yZXBsYWNlKC9cXHMvZyxcIlwiKSxmPVsvTlxcKihEKS9nLC8oTnxEKVsqXFwvXU4vZywvKE58RClPXFwxL2csL1xcKChOfEQpXFwpL2ddLGc9MDtnPGYubGVuZ3RoOylmW2ddLnRlc3QoZSk/KGU9ZS5yZXBsYWNlKGZbZ10sXCIkMVwiKSxnPTApOmcrKztpZihcIkRcIj09ZSl7Zm9yKHZhciBoIGluIGMpe3ZhciBpPWV2YWwoYi5yZXBsYWNlKG5ldyBSZWdFeHAoXCJVXCIraCxcImdcIiksXCJcIikucmVwbGFjZShuZXcgUmVnRXhwKGQsXCJnXCIpLFwiKjBcIikpO2lmKCFpc0Zpbml0ZShpKSlyZXR1cm47Y1toXT1pfXJldHVybiBjfX19ZnVuY3Rpb24gZChhLGIpe3JldHVybiBlKGEsYiwhMCl9ZnVuY3Rpb24gZShiLGMsZCl7dmFyIGUsZj1bXTtmb3IoZSBpbiBiKWYucHVzaChlKTtmb3IoZSBpbiBjKWYuaW5kZXhPZihlKTwwJiZmLnB1c2goZSk7cmV0dXJuIGI9Zi5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGJbYV18fDB9KSxjPWYubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBjW2FdfHwwfSksW2IsYyxmdW5jdGlvbihiKXt2YXIgYz1iLm1hcChmdW5jdGlvbihjLGUpe3JldHVybiAxPT1iLmxlbmd0aCYmZCYmKGM9TWF0aC5tYXgoYywwKSksYS5udW1iZXJUb1N0cmluZyhjKStmW2VdfSkuam9pbihcIiArIFwiKTtyZXR1cm4gYi5sZW5ndGg+MT9cImNhbGMoXCIrYytcIilcIjpjfV19dmFyIGY9XCJweHxlbXxleHxjaHxyZW18dnd8dmh8dm1pbnx2bWF4fGNtfG1tfGlufHB0fHBjXCIsZz1jLmJpbmQobnVsbCxuZXcgUmVnRXhwKGYsXCJnXCIpKSxoPWMuYmluZChudWxsLG5ldyBSZWdFeHAoZitcInwlXCIsXCJnXCIpKSxpPWMuYmluZChudWxsLC9kZWd8cmFkfGdyYWR8dHVybi9nKTthLnBhcnNlTGVuZ3RoPWcsYS5wYXJzZUxlbmd0aE9yUGVyY2VudD1oLGEuY29uc3VtZUxlbmd0aE9yUGVyY2VudD1hLmNvbnN1bWVQYXJlbnRoZXNpc2VkLmJpbmQobnVsbCxoKSxhLnBhcnNlQW5nbGU9aSxhLm1lcmdlRGltZW5zaW9ucz1lO3ZhciBqPWEuY29uc3VtZVBhcmVudGhlc2lzZWQuYmluZChudWxsLGcpLGs9YS5jb25zdW1lUmVwZWF0ZWQuYmluZCh2b2lkIDAsaiwvXi8pLGw9YS5jb25zdW1lUmVwZWF0ZWQuYmluZCh2b2lkIDAsaywvXiwvKTthLmNvbnN1bWVTaXplUGFpckxpc3Q9bDt2YXIgbT1mdW5jdGlvbihhKXt2YXIgYj1sKGEpO2lmKGImJlwiXCI9PWJbMV0pcmV0dXJuIGJbMF19LG49YS5tZXJnZU5lc3RlZFJlcGVhdGVkLmJpbmQodm9pZCAwLGQsXCIgXCIpLG89YS5tZXJnZU5lc3RlZFJlcGVhdGVkLmJpbmQodm9pZCAwLG4sXCIsXCIpO2EubWVyZ2VOb25OZWdhdGl2ZVNpemVQYWlyPW4sYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihtLG8sW1wiYmFja2dyb3VuZC1zaXplXCJdKSxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGgsZCxbXCJib3JkZXItYm90dG9tLXdpZHRoXCIsXCJib3JkZXItaW1hZ2Utd2lkdGhcIixcImJvcmRlci1sZWZ0LXdpZHRoXCIsXCJib3JkZXItcmlnaHQtd2lkdGhcIixcImJvcmRlci10b3Atd2lkdGhcIixcImZsZXgtYmFzaXNcIixcImZvbnQtc2l6ZVwiLFwiaGVpZ2h0XCIsXCJsaW5lLWhlaWdodFwiLFwibWF4LWhlaWdodFwiLFwibWF4LXdpZHRoXCIsXCJvdXRsaW5lLXdpZHRoXCIsXCJ3aWR0aFwiXSksYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihoLGUsW1wiYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1c1wiLFwiYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXNcIixcImJvcmRlci10b3AtbGVmdC1yYWRpdXNcIixcImJvcmRlci10b3AtcmlnaHQtcmFkaXVzXCIsXCJib3R0b21cIixcImxlZnRcIixcImxldHRlci1zcGFjaW5nXCIsXCJtYXJnaW4tYm90dG9tXCIsXCJtYXJnaW4tbGVmdFwiLFwibWFyZ2luLXJpZ2h0XCIsXCJtYXJnaW4tdG9wXCIsXCJtaW4taGVpZ2h0XCIsXCJtaW4td2lkdGhcIixcIm91dGxpbmUtb2Zmc2V0XCIsXCJwYWRkaW5nLWJvdHRvbVwiLFwicGFkZGluZy1sZWZ0XCIsXCJwYWRkaW5nLXJpZ2h0XCIsXCJwYWRkaW5nLXRvcFwiLFwicGVyc3BlY3RpdmVcIixcInJpZ2h0XCIsXCJzaGFwZS1tYXJnaW5cIixcInRleHQtaW5kZW50XCIsXCJ0b3BcIixcInZlcnRpY2FsLWFsaWduXCIsXCJ3b3JkLXNwYWNpbmdcIl0pfShkLGYpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhiKXtyZXR1cm4gYS5jb25zdW1lTGVuZ3RoT3JQZXJjZW50KGIpfHxhLmNvbnN1bWVUb2tlbigvXmF1dG8vLGIpfWZ1bmN0aW9uIGQoYil7dmFyIGQ9YS5jb25zdW1lTGlzdChbYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZChudWxsLC9ecmVjdC8pKSxhLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKG51bGwsL15cXCgvKSksYS5jb25zdW1lUmVwZWF0ZWQuYmluZChudWxsLGMsL14sLyksYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZChudWxsLC9eXFwpLykpXSxiKTtpZihkJiY0PT1kWzBdLmxlbmd0aClyZXR1cm4gZFswXX1mdW5jdGlvbiBlKGIsYyl7cmV0dXJuXCJhdXRvXCI9PWJ8fFwiYXV0b1wiPT1jP1shMCwhMSxmdW5jdGlvbihkKXt2YXIgZT1kP2I6YztpZihcImF1dG9cIj09ZSlyZXR1cm5cImF1dG9cIjt2YXIgZj1hLm1lcmdlRGltZW5zaW9ucyhlLGUpO3JldHVybiBmWzJdKGZbMF0pfV06YS5tZXJnZURpbWVuc2lvbnMoYixjKX1mdW5jdGlvbiBmKGEpe3JldHVyblwicmVjdChcIithK1wiKVwifXZhciBnPWEubWVyZ2VXcmFwcGVkTmVzdGVkUmVwZWF0ZWQuYmluZChudWxsLGYsZSxcIiwgXCIpO2EucGFyc2VCb3g9ZCxhLm1lcmdlQm94ZXM9ZyxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGQsZyxbXCJjbGlwXCJdKX0oZCxmKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBjPTA7cmV0dXJuIGEubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBhPT09az9iW2MrK106YX0pfX1mdW5jdGlvbiBkKGEpe3JldHVybiBhfWZ1bmN0aW9uIGUoYil7aWYoYj1iLnRvTG93ZXJDYXNlKCkudHJpbSgpLFwibm9uZVwiPT1iKXJldHVybltdO2Zvcih2YXIgYyxkPS9cXHMqKFxcdyspXFwoKFteKV0qKVxcKS9nLGU9W10sZj0wO2M9ZC5leGVjKGIpOyl7aWYoYy5pbmRleCE9ZilyZXR1cm47Zj1jLmluZGV4K2NbMF0ubGVuZ3RoO3ZhciBnPWNbMV0saD1uW2ddO2lmKCFoKXJldHVybjt2YXIgaT1jWzJdLnNwbGl0KFwiLFwiKSxqPWhbMF07aWYoai5sZW5ndGg8aS5sZW5ndGgpcmV0dXJuO2Zvcih2YXIgaz1bXSxvPTA7bzxqLmxlbmd0aDtvKyspe3ZhciBwLHE9aVtvXSxyPWpbb107aWYocD1xP3tBOmZ1bmN0aW9uKGIpe3JldHVyblwiMFwiPT1iLnRyaW0oKT9tOmEucGFyc2VBbmdsZShiKX0sTjphLnBhcnNlTnVtYmVyLFQ6YS5wYXJzZUxlbmd0aE9yUGVyY2VudCxMOmEucGFyc2VMZW5ndGh9W3IudG9VcHBlckNhc2UoKV0ocSk6e2E6bSxuOmtbMF0sdDpsfVtyXSx2b2lkIDA9PT1wKXJldHVybjtrLnB1c2gocCl9aWYoZS5wdXNoKHt0OmcsZDprfSksZC5sYXN0SW5kZXg9PWIubGVuZ3RoKXJldHVybiBlfX1mdW5jdGlvbiBmKGEpe3JldHVybiBhLnRvRml4ZWQoNikucmVwbGFjZShcIi4wMDAwMDBcIixcIlwiKX1mdW5jdGlvbiBnKGIsYyl7aWYoYi5kZWNvbXBvc2l0aW9uUGFpciE9PWMpe2IuZGVjb21wb3NpdGlvblBhaXI9Yzt2YXIgZD1hLm1ha2VNYXRyaXhEZWNvbXBvc2l0aW9uKGIpfWlmKGMuZGVjb21wb3NpdGlvblBhaXIhPT1iKXtjLmRlY29tcG9zaXRpb25QYWlyPWI7dmFyIGU9YS5tYWtlTWF0cml4RGVjb21wb3NpdGlvbihjKX1yZXR1cm4gbnVsbD09ZFswXXx8bnVsbD09ZVswXT9bWyExXSxbITBdLGZ1bmN0aW9uKGEpe3JldHVybiBhP2NbMF0uZDpiWzBdLmR9XTooZFswXS5wdXNoKDApLGVbMF0ucHVzaCgxKSxbZCxlLGZ1bmN0aW9uKGIpe3ZhciBjPWEucXVhdChkWzBdWzNdLGVbMF1bM10sYls1XSksZz1hLmNvbXBvc2VNYXRyaXgoYlswXSxiWzFdLGJbMl0sYyxiWzRdKSxoPWcubWFwKGYpLmpvaW4oXCIsXCIpO3JldHVybiBofV0pfWZ1bmN0aW9uIGgoYSl7cmV0dXJuIGEucmVwbGFjZSgvW3h5XS8sXCJcIil9ZnVuY3Rpb24gaShhKXtyZXR1cm4gYS5yZXBsYWNlKC8oeHx5fHp8M2QpPyQvLFwiM2RcIil9ZnVuY3Rpb24gaihiLGMpe3ZhciBkPWEubWFrZU1hdHJpeERlY29tcG9zaXRpb24mJiEwLGU9ITE7aWYoIWIubGVuZ3RofHwhYy5sZW5ndGgpe2IubGVuZ3RofHwoZT0hMCxiPWMsYz1bXSk7Zm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKyspe3ZhciBqPWJbZl0udCxrPWJbZl0uZCxsPVwic2NhbGVcIj09ai5zdWJzdHIoMCw1KT8xOjA7Yy5wdXNoKHt0OmosZDprLm1hcChmdW5jdGlvbihhKXtpZihcIm51bWJlclwiPT10eXBlb2YgYSlyZXR1cm4gbDt2YXIgYj17fTtmb3IodmFyIGMgaW4gYSliW2NdPWw7cmV0dXJuIGJ9KX0pfX12YXIgbT1mdW5jdGlvbihhLGIpe3JldHVyblwicGVyc3BlY3RpdmVcIj09YSYmXCJwZXJzcGVjdGl2ZVwiPT1ifHwoXCJtYXRyaXhcIj09YXx8XCJtYXRyaXgzZFwiPT1hKSYmKFwibWF0cml4XCI9PWJ8fFwibWF0cml4M2RcIj09Yil9LG89W10scD1bXSxxPVtdO2lmKGIubGVuZ3RoIT1jLmxlbmd0aCl7aWYoIWQpcmV0dXJuO3ZhciByPWcoYixjKTtvPVtyWzBdXSxwPVtyWzFdXSxxPVtbXCJtYXRyaXhcIixbclsyXV1dXX1lbHNlIGZvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7ZisrKXt2YXIgaixzPWJbZl0udCx0PWNbZl0udCx1PWJbZl0uZCx2PWNbZl0uZCx3PW5bc10seD1uW3RdO2lmKG0ocyx0KSl7aWYoIWQpcmV0dXJuO3ZhciByPWcoW2JbZl1dLFtjW2ZdXSk7by5wdXNoKHJbMF0pLHAucHVzaChyWzFdKSxxLnB1c2goW1wibWF0cml4XCIsW3JbMl1dXSl9ZWxzZXtpZihzPT10KWo9cztlbHNlIGlmKHdbMl0mJnhbMl0mJmgocyk9PWgodCkpaj1oKHMpLHU9d1syXSh1KSx2PXhbMl0odik7ZWxzZXtpZighd1sxXXx8IXhbMV18fGkocykhPWkodCkpe2lmKCFkKXJldHVybjt2YXIgcj1nKGIsYyk7bz1bclswXV0scD1bclsxXV0scT1bW1wibWF0cml4XCIsW3JbMl1dXV07YnJlYWt9aj1pKHMpLHU9d1sxXSh1KSx2PXhbMV0odil9Zm9yKHZhciB5PVtdLHo9W10sQT1bXSxCPTA7Qjx1Lmxlbmd0aDtCKyspe3ZhciBDPVwibnVtYmVyXCI9PXR5cGVvZiB1W0JdP2EubWVyZ2VOdW1iZXJzOmEubWVyZ2VEaW1lbnNpb25zLHI9Qyh1W0JdLHZbQl0pO3lbQl09clswXSx6W0JdPXJbMV0sQS5wdXNoKHJbMl0pfW8ucHVzaCh5KSxwLnB1c2goeikscS5wdXNoKFtqLEFdKX19aWYoZSl7dmFyIEQ9bztvPXAscD1EfXJldHVybltvLHAsZnVuY3Rpb24oYSl7cmV0dXJuIGEubWFwKGZ1bmN0aW9uKGEsYil7dmFyIGM9YS5tYXAoZnVuY3Rpb24oYSxjKXtyZXR1cm4gcVtiXVsxXVtjXShhKX0pLmpvaW4oXCIsXCIpO3JldHVyblwibWF0cml4XCI9PXFbYl1bMF0mJjE2PT1jLnNwbGl0KFwiLFwiKS5sZW5ndGgmJihxW2JdWzBdPVwibWF0cml4M2RcIikscVtiXVswXStcIihcIitjK1wiKVwifSkuam9pbihcIiBcIil9XX12YXIgaz1udWxsLGw9e3B4OjB9LG09e2RlZzowfSxuPXttYXRyaXg6W1wiTk5OTk5OXCIsW2ssaywwLDAsayxrLDAsMCwwLDAsMSwwLGssaywwLDFdLGRdLG1hdHJpeDNkOltcIk5OTk5OTk5OTk5OTk5OTk5cIixkXSxyb3RhdGU6W1wiQVwiXSxyb3RhdGV4OltcIkFcIl0scm90YXRleTpbXCJBXCJdLHJvdGF0ZXo6W1wiQVwiXSxyb3RhdGUzZDpbXCJOTk5BXCJdLHBlcnNwZWN0aXZlOltcIkxcIl0sc2NhbGU6W1wiTm5cIixjKFtrLGssMV0pLGRdLHNjYWxleDpbXCJOXCIsYyhbaywxLDFdKSxjKFtrLDFdKV0sc2NhbGV5OltcIk5cIixjKFsxLGssMV0pLGMoWzEsa10pXSxzY2FsZXo6W1wiTlwiLGMoWzEsMSxrXSldLHNjYWxlM2Q6W1wiTk5OXCIsZF0sc2tldzpbXCJBYVwiLG51bGwsZF0sc2tld3g6W1wiQVwiLG51bGwsYyhbayxtXSldLHNrZXd5OltcIkFcIixudWxsLGMoW20sa10pXSx0cmFuc2xhdGU6W1wiVHRcIixjKFtrLGssbF0pLGRdLHRyYW5zbGF0ZXg6W1wiVFwiLGMoW2ssbCxsXSksYyhbayxsXSldLHRyYW5zbGF0ZXk6W1wiVFwiLGMoW2wsayxsXSksYyhbbCxrXSldLHRyYW5zbGF0ZXo6W1wiTFwiLGMoW2wsbCxrXSldLHRyYW5zbGF0ZTNkOltcIlRUTFwiLGRdfTthLmFkZFByb3BlcnRpZXNIYW5kbGVyKGUsaixbXCJ0cmFuc2Zvcm1cIl0pfShkLGYpLGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSl7dmFyIGI9TnVtYmVyKGEpO2lmKCEoaXNOYU4oYil8fGI8MTAwfHxiPjkwMHx8YiUxMDAhPT0wKSlyZXR1cm4gYn1mdW5jdGlvbiBjKGIpe3JldHVybiBiPTEwMCpNYXRoLnJvdW5kKGIvMTAwKSxiPWEuY2xhbXAoMTAwLDkwMCxiKSw0MDA9PT1iP1wibm9ybWFsXCI6NzAwPT09Yj9cImJvbGRcIjpTdHJpbmcoYil9ZnVuY3Rpb24gZChhLGIpe3JldHVyblthLGIsY119YS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihiLGQsW1wiZm9udC13ZWlnaHRcIl0pfShkKSxmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe3ZhciBiPXt9O2Zvcih2YXIgYyBpbiBhKWJbY109LWFbY107cmV0dXJuIGJ9ZnVuY3Rpb24gYyhiKXtyZXR1cm4gYS5jb25zdW1lVG9rZW4oL14obGVmdHxjZW50ZXJ8cmlnaHR8dG9wfGJvdHRvbSlcXGIvaSxiKXx8YS5jb25zdW1lTGVuZ3RoT3JQZXJjZW50KGIpfWZ1bmN0aW9uIGQoYixkKXt2YXIgZT1hLmNvbnN1bWVSZXBlYXRlZChjLC9eLyxkKTtpZihlJiZcIlwiPT1lWzFdKXt2YXIgZj1lWzBdO2lmKGZbMF09ZlswXXx8XCJjZW50ZXJcIixmWzFdPWZbMV18fFwiY2VudGVyXCIsMz09YiYmKGZbMl09ZlsyXXx8e3B4OjB9KSxmLmxlbmd0aD09Yil7aWYoL3RvcHxib3R0b20vLnRlc3QoZlswXSl8fC9sZWZ0fHJpZ2h0Ly50ZXN0KGZbMV0pKXt2YXIgaD1mWzBdO2ZbMF09ZlsxXSxmWzFdPWh9aWYoL2xlZnR8cmlnaHR8Y2VudGVyfE9iamVjdC8udGVzdChmWzBdKSYmL3RvcHxib3R0b218Y2VudGVyfE9iamVjdC8udGVzdChmWzFdKSlyZXR1cm4gZi5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGE/YTpnW2FdfSl9fX1mdW5jdGlvbiBlKGQpe3ZhciBlPWEuY29uc3VtZVJlcGVhdGVkKGMsL14vLGQpO2lmKGUpe2Zvcih2YXIgZj1lWzBdLGg9W3tcIiVcIjo1MH0se1wiJVwiOjUwfV0saT0wLGo9ITEsaz0wO2s8Zi5sZW5ndGg7aysrKXt2YXIgbD1mW2tdO1wic3RyaW5nXCI9PXR5cGVvZiBsPyhqPS9ib3R0b218cmlnaHQvLnRlc3QobCksaT17bGVmdDowLHJpZ2h0OjAsY2VudGVyOmksdG9wOjEsYm90dG9tOjF9W2xdLGhbaV09Z1tsXSxcImNlbnRlclwiPT1sJiZpKyspOihqJiYobD1iKGwpLGxbXCIlXCJdPShsW1wiJVwiXXx8MCkrMTAwKSxoW2ldPWwsaSsrLGo9ITEpfXJldHVybltoLGVbMV1dfX1mdW5jdGlvbiBmKGIpe3ZhciBjPWEuY29uc3VtZVJlcGVhdGVkKGUsL14sLyxiKTtpZihjJiZcIlwiPT1jWzFdKXJldHVybiBjWzBdfXZhciBnPXtsZWZ0OntcIiVcIjowfSxjZW50ZXI6e1wiJVwiOjUwfSxyaWdodDp7XCIlXCI6MTAwfSx0b3A6e1wiJVwiOjB9LGJvdHRvbTp7XCIlXCI6MTAwfX0saD1hLm1lcmdlTmVzdGVkUmVwZWF0ZWQuYmluZChudWxsLGEubWVyZ2VEaW1lbnNpb25zLFwiIFwiKTthLmFkZFByb3BlcnRpZXNIYW5kbGVyKGQuYmluZChudWxsLDMpLGgsW1widHJhbnNmb3JtLW9yaWdpblwiXSksYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihkLmJpbmQobnVsbCwyKSxoLFtcInBlcnNwZWN0aXZlLW9yaWdpblwiXSksYS5jb25zdW1lUG9zaXRpb249ZSxhLm1lcmdlT2Zmc2V0TGlzdD1oO3ZhciBpPWEubWVyZ2VOZXN0ZWRSZXBlYXRlZC5iaW5kKG51bGwsaCxcIiwgXCIpO2EuYWRkUHJvcGVydGllc0hhbmRsZXIoZixpLFtcImJhY2tncm91bmQtcG9zaXRpb25cIixcIm9iamVjdC1wb3NpdGlvblwiXSl9KGQpLGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYil7dmFyIGM9YS5jb25zdW1lVG9rZW4oL15jaXJjbGUvLGIpO2lmKGMmJmNbMF0pcmV0dXJuW1wiY2lyY2xlXCJdLmNvbmNhdChhLmNvbnN1bWVMaXN0KFthLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKHZvaWQgMCwvXlxcKC8pKSxkLGEuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQodm9pZCAwLC9eYXQvKSksYS5jb25zdW1lUG9zaXRpb24sYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZCh2b2lkIDAsL15cXCkvKSldLGNbMV0pKTt2YXIgZj1hLmNvbnN1bWVUb2tlbigvXmVsbGlwc2UvLGIpO2lmKGYmJmZbMF0pcmV0dXJuW1wiZWxsaXBzZVwiXS5jb25jYXQoYS5jb25zdW1lTGlzdChbYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZCh2b2lkIDAsL15cXCgvKSksZSxhLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKHZvaWQgMCwvXmF0LykpLGEuY29uc3VtZVBvc2l0aW9uLGEuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQodm9pZCAwLC9eXFwpLykpXSxmWzFdKSk7dmFyIGc9YS5jb25zdW1lVG9rZW4oL15wb2x5Z29uLyxiKTtyZXR1cm4gZyYmZ1swXT9bXCJwb2x5Z29uXCJdLmNvbmNhdChhLmNvbnN1bWVMaXN0KFthLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKHZvaWQgMCwvXlxcKC8pKSxhLm9wdGlvbmFsKGEuY29uc3VtZVRva2VuLmJpbmQodm9pZCAwLC9ebm9uemVyb1xccyosfF5ldmVub2RkXFxzKiwvKSxcIm5vbnplcm8sXCIpLGEuY29uc3VtZVNpemVQYWlyTGlzdCxhLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKHZvaWQgMCwvXlxcKS8pKV0sZ1sxXSkpOnZvaWQgMH1mdW5jdGlvbiBjKGIsYyl7aWYoYlswXT09PWNbMF0pcmV0dXJuXCJjaXJjbGVcIj09YlswXT9hLm1lcmdlTGlzdChiLnNsaWNlKDEpLGMuc2xpY2UoMSksW1wiY2lyY2xlKFwiLGEubWVyZ2VEaW1lbnNpb25zLFwiIGF0IFwiLGEubWVyZ2VPZmZzZXRMaXN0LFwiKVwiXSk6XCJlbGxpcHNlXCI9PWJbMF0/YS5tZXJnZUxpc3QoYi5zbGljZSgxKSxjLnNsaWNlKDEpLFtcImVsbGlwc2UoXCIsYS5tZXJnZU5vbk5lZ2F0aXZlU2l6ZVBhaXIsXCIgYXQgXCIsYS5tZXJnZU9mZnNldExpc3QsXCIpXCJdKTpcInBvbHlnb25cIj09YlswXSYmYlsxXT09Y1sxXT9hLm1lcmdlTGlzdChiLnNsaWNlKDIpLGMuc2xpY2UoMiksW1wicG9seWdvbihcIixiWzFdLGcsXCIpXCJdKTp2b2lkIDB9dmFyIGQ9YS5jb25zdW1lUGFyZW50aGVzaXNlZC5iaW5kKG51bGwsYS5wYXJzZUxlbmd0aE9yUGVyY2VudCksZT1hLmNvbnN1bWVSZXBlYXRlZC5iaW5kKHZvaWQgMCxkLC9eLyksZj1hLm1lcmdlTmVzdGVkUmVwZWF0ZWQuYmluZCh2b2lkIDAsYS5tZXJnZURpbWVuc2lvbnMsXCIgXCIpLGc9YS5tZXJnZU5lc3RlZFJlcGVhdGVkLmJpbmQodm9pZCAwLGYsXCIsXCIpO2EuYWRkUHJvcGVydGllc0hhbmRsZXIoYixjLFtcInNoYXBlLW91dHNpZGVcIl0pfShkKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiKXtiLmNvbmNhdChbYV0pLmZvckVhY2goZnVuY3Rpb24oYil7YiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUmJihkW2FdPWIpfSl9dmFyIGQ9e307YyhcInRyYW5zZm9ybVwiLFtcIndlYmtpdFRyYW5zZm9ybVwiLFwibXNUcmFuc2Zvcm1cIl0pLGMoXCJ0cmFuc2Zvcm1PcmlnaW5cIixbXCJ3ZWJraXRUcmFuc2Zvcm1PcmlnaW5cIl0pLGMoXCJwZXJzcGVjdGl2ZVwiLFtcIndlYmtpdFBlcnNwZWN0aXZlXCJdKSxjKFwicGVyc3BlY3RpdmVPcmlnaW5cIixbXCJ3ZWJraXRQZXJzcGVjdGl2ZU9yaWdpblwiXSksYS5wcm9wZXJ0eU5hbWU9ZnVuY3Rpb24oYSl7cmV0dXJuIGRbYV18fGF9fShkLGYpfSgpLCFmdW5jdGlvbigpe2lmKHZvaWQgMD09PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuYW5pbWF0ZShbXSkub25jYW5jZWwpe3ZhciBhO2lmKHdpbmRvdy5wZXJmb3JtYW5jZSYmcGVyZm9ybWFuY2Uubm93KXZhciBhPWZ1bmN0aW9uKCl7cmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpfTtlbHNlIHZhciBhPWZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9O3ZhciBiPWZ1bmN0aW9uKGEsYixjKXt0aGlzLnRhcmdldD1hLHRoaXMuY3VycmVudFRpbWU9Yix0aGlzLnRpbWVsaW5lVGltZT1jLHRoaXMudHlwZT1cImNhbmNlbFwiLHRoaXMuYnViYmxlcz0hMSx0aGlzLmNhbmNlbGFibGU9ITEsdGhpcy5jdXJyZW50VGFyZ2V0PWEsdGhpcy5kZWZhdWx0UHJldmVudGVkPSExLHRoaXMuZXZlbnRQaGFzZT1FdmVudC5BVF9UQVJHRVQsdGhpcy50aW1lU3RhbXA9RGF0ZS5ub3coKX0sYz13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYW5pbWF0ZTt3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYW5pbWF0ZT1mdW5jdGlvbihkLGUpe3ZhciBmPWMuY2FsbCh0aGlzLGQsZSk7Zi5fY2FuY2VsSGFuZGxlcnM9W10sZi5vbmNhbmNlbD1udWxsO3ZhciBnPWYuY2FuY2VsO2YuY2FuY2VsPWZ1bmN0aW9uKCl7Zy5jYWxsKHRoaXMpO3ZhciBjPW5ldyBiKHRoaXMsbnVsbCxhKCkpLGQ9dGhpcy5fY2FuY2VsSGFuZGxlcnMuY29uY2F0KHRoaXMub25jYW5jZWw/W3RoaXMub25jYW5jZWxdOltdKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZC5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuY2FsbChjLnRhcmdldCxjKX0pfSwwKX07dmFyIGg9Zi5hZGRFdmVudExpc3RlbmVyO2YuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihhLGIpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGImJlwiY2FuY2VsXCI9PWE/dGhpcy5fY2FuY2VsSGFuZGxlcnMucHVzaChiKTpoLmNhbGwodGhpcyxhLGIpfTt2YXIgaT1mLnJlbW92ZUV2ZW50TGlzdGVuZXI7cmV0dXJuIGYucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihhLGIpe2lmKFwiY2FuY2VsXCI9PWEpe3ZhciBjPXRoaXMuX2NhbmNlbEhhbmRsZXJzLmluZGV4T2YoYik7Yz49MCYmdGhpcy5fY2FuY2VsSGFuZGxlcnMuc3BsaWNlKGMsMSl9ZWxzZSBpLmNhbGwodGhpcyxhLGIpfSxmfX19KCksZnVuY3Rpb24oYSl7dmFyIGI9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGM9bnVsbCxkPSExO3RyeXt2YXIgZT1nZXRDb21wdXRlZFN0eWxlKGIpLmdldFByb3BlcnR5VmFsdWUoXCJvcGFjaXR5XCIpLGY9XCIwXCI9PWU/XCIxXCI6XCIwXCI7Yz1iLmFuaW1hdGUoe29wYWNpdHk6W2YsZl19LHtkdXJhdGlvbjoxfSksYy5jdXJyZW50VGltZT0wLGQ9Z2V0Q29tcHV0ZWRTdHlsZShiKS5nZXRQcm9wZXJ0eVZhbHVlKFwib3BhY2l0eVwiKT09Zn1jYXRjaChhKXt9ZmluYWxseXtjJiZjLmNhbmNlbCgpfWlmKCFkKXt2YXIgZz13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYW5pbWF0ZTt3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYW5pbWF0ZT1mdW5jdGlvbihiLGMpe3JldHVybiB3aW5kb3cuU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3ImJkFycmF5LnByb3RvdHlwZS5mcm9tJiZiW1N5bWJvbC5pdGVyYXRvcl0mJihiPUFycmF5LmZyb20oYikpLEFycmF5LmlzQXJyYXkoYil8fG51bGw9PT1ifHwoYj1hLmNvbnZlcnRUb0FycmF5Rm9ybShiKSksZy5jYWxsKHRoaXMsYixjKX19fShjKSxiLnRydWU9YX0oe30sZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWItYW5pbWF0aW9ucy5taW4uanMubWFwIiwiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGbG9yaWFuIEtsYW1wZmVyXG4gKiBMaWNlbnNlZCB1bmRlciBNSVRcbiAqL1xuXG4vLyBjb25zdCBKU19GRUFUVVJFUyA9IFtcbi8vICAgJ2ZuL2FycmF5L2Zvci1lYWNoJyxcbi8vICAgJ2ZuL2Z1bmN0aW9uL2JpbmQnLFxuLy8gICAnZm4vbnVtYmVyL2NvbnN0cnVjdG9yJyxcbi8vICAgJ2ZuL29iamVjdC9hc3NpZ24nLFxuLy8gICAnZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eScsXG4vLyAgICdmbi9vYmplY3Qva2V5cycsXG4vLyBdO1xuXG4vLyBjb25zdCBNT0RFUk5JWlJfVEVTVFMgPSBbXG4vLyAgICdjdXN0b21ldmVudCcsXG4vLyBdO1xuXG5jbGFzcyBNaXgge31cblxuY29uc3QgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbCB8fCAoeCA9PiBgXyR7eH1gKTtcblxuY29uc3QgZGVmID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LmJpbmQoT2JqZWN0KTtcblxuY29uc3QgUk9PVCA9IFN5bWJvbCgncm9vdCcpO1xuY29uc3QgU1RBVEUgPSBTeW1ib2woJ3N0YXRlJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGV2ZW50TmFtZSwgZGF0YSA9IHt9KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIGRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc3QgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlLCBkYXRhLmRldGFpbCk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldHVwUHJvcGVydHkoa2V5LCBzaWRlRWZmZWN0KSB7XG4gIGRlZih0aGlzLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogKCkgPT4gdGhpc1tTVEFURV1ba2V5XSxcbiAgICBzZXQ6ICh2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHNpZGVFZmZlY3QgIT0gbnVsbCkge1xuICAgICAgICBzaWRlRWZmZWN0KHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgfSk7XG59XG5cbi8vIFRPRE86IHN0dWR5IGhvdyBuYXRpdmUgZWxlbWVudHMgZGVhbCB3aXRoIGF0dHJpYnV0ZXMvcHJvcGVyaXRlc1xuZnVuY3Rpb24gc2V0dXBQcm9wZXJ0aWVzKCkge1xuICBjb25zdCBzaWRlRWZmZWN0cyA9IHRoaXMuc2lkZUVmZmVjdHMoKTtcblxuICBPYmplY3Qua2V5cyh0aGlzW1NUQVRFXSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB0aGlzW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBzaWRlRWZmZWN0ID0gc2lkZUVmZmVjdHNba2V5XTtcbiAgICAgIHNldHVwUHJvcGVydHkuY2FsbCh0aGlzLCBrZXksIHNpZGVFZmZlY3QpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IChDID0gTWl4KSA9PiBjbGFzcyBleHRlbmRzIEMge1xuICBnZXQgY29tcG9uZW50TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnROYW1lKCk7XG4gIH1cblxuICBnZXRDb21wb25lbnROYW1lKCkge1xuICAgIHRocm93IEVycm9yKCdDb21wb25lbnQgbmVlZHMgdG8gaGF2ZSBhIG5hbWUsIGUuZy4gYG15LXRhZ2AuIE92ZXJyaWRlIGBnZXRDb21wb25lbnROYW1lYCcpO1xuICB9XG5cbiAgc2V0dXBDb21wb25lbnQoZWwsIHN0YXRlKSB7XG4gICAgZGVmKHRoaXMsIFNUQVRFLCB7IHZhbHVlOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRzKCksIHN0YXRlKSB9KTtcbiAgICBzZXR1cFByb3BlcnRpZXMuY2FsbCh0aGlzKTtcbiAgICBkZWYodGhpcywgUk9PVCwgeyB2YWx1ZTogdGhpcy5zZXR1cERPTShlbCkgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXR1cERPTShlbCkge1xuICAgIHJldHVybiBlbDtcbiAgfVxuXG4gIGdldCByb290KCkge1xuICAgIHJldHVybiB0aGlzLmdldFJvb3QoKTtcbiAgfVxuXG4gIGdldCBlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbCgpO1xuICB9XG5cbiAgZ2V0Um9vdCgpIHtcbiAgICByZXR1cm4gdGhpc1tST09UXTtcbiAgfVxuXG4gIGdldEVsKCkge1xuICAgIHJldHVybiB0aGlzW1JPT1RdO1xuICB9XG5cbiAgZmlyZUV2ZW50KGV2ZW50TmFtZSwgZGF0YSkge1xuICAgIGNvbnN0IGV2ZW50TmFtZU5TID0gYCR7dGhpcy5jb21wb25lbnROYW1lfS0ke2V2ZW50TmFtZX1gO1xuICAgIHRoaXMuZWwuZGlzcGF0Y2hFdmVudChjcmVhdGVFdmVudChldmVudE5hbWVOUywgZGF0YSkpO1xuICB9XG5cbiAgZGVmYXVsdHMoKSB7XG4gICAgLy8gVE9ETzogcHJvZHVjdGlvbiBidWlsZHMgd2l0aCBwcmVwcm9jZXNzP1xuICAgIGNvbnNvbGUud2FybignZGVmYXVsdHMgbm90IHByb3ZpZGVkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHNpZGVFZmZlY3RzKCkge1xuICAgIC8vIFRPRE86IHByb2R1Y3Rpb24gYnVpbGRzIHdpdGggcHJlcHJvY2Vzcz9cbiAgICBjb25zb2xlLndhcm4oJ3NpZGVFZmZlY3RzIG5vdCBwcm92aWRlZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBzZXRTdGF0ZShrZXlPck1hcCwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGtleU9yTWFwID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5zZXRTdGF0ZUtWKGtleU9yTWFwLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yga2V5T3JNYXAgPT09ICdvYmplY3QnKSB7XG4gICAgICB0aGlzLnNldFN0YXRlTWFwKGtleU9yTWFwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoJ3NldFN0YXRlIG5lZWRzIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgc2V0U3RhdGVLVihrZXksIHZhbHVlKSB7XG4gICAgdGhpc1tTVEFURV1ba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgc2V0U3RhdGVNYXAobWFwKSB7XG4gICAgT2JqZWN0LmtleXModGhpc1tTVEFURV0pLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgdGhpcy5zZXRTdGF0ZUtWKGtleSwgbWFwW2tleV0pO1xuICAgIH0pO1xuICB9XG59O1xuIiwiLyoqXG4gICogQHBhcmFtIHQgY3VycmVudCB0aW1lXG4gICogQHBhcmFtIGIgc3RhcnQgdmFsdWVcbiAgKiBAcGFyYW0gYyBjaGFuZ2UgaW4gdmFsdWVcbiAgKiBAcGFyYW0gZCBkdXJhdGlvblxuICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICovXG5mdW5jdGlvbiBsaW5lYXJUd2Vlbih0LCBiLCBjLCBkKSB7XG4gIHJldHVybiAoKGMgKiB0KSAvIGQpICsgYjtcbn1cblxuZnVuY3Rpb24gcGFnZURpc3QocDEsIHAyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoKChwMS5wYWdlWCAtIHAyLnBhZ2VYKSAqKiAyKSArICgocDEucGFnZVkgLSBwMi5wYWdlWSkgKiogMikpO1xufVxuXG5mdW5jdGlvbiBjb250YWlucyh0YXJnZXQsIGNsYXNzTmFtZSkge1xuICBsZXQgdCA9IHRhcmdldDtcbiAgd2hpbGUgKHQgIT0gbnVsbCkge1xuICAgIGlmICh0LmNsYXNzTGlzdCAmJiB0LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdCA9IHQucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB7IGxpbmVhclR3ZWVuLCBwYWdlRGlzdCwgY29udGFpbnMgfTtcbiIsIi8qXG4gKiBBZGFwdGVkIGZyb20gUmF0Y2hldCdzIHNsaWRlcnMuanNcbiAqIGh0dHA6Ly9nb3JhdGNoZXQuY29tL2NvbXBvbmVudHMjc2xpZGVyc1xuICpcbiAqIEFkYXB0ZWQgZnJvbSBCcmFkIEJpcmRzYWxsJ3MgU3dpcGVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS90aGViaXJkL1N3aXBlXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZsb3JpYW4gS2xhbXBmZXJcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXMsIGltcG9ydC9uby11bnJlc29sdmVkLCBpbXBvcnQvZXh0ZW5zaW9ucyAqL1xuXG5pbXBvcnQgY29tcG9uZW50Q29yZSBmcm9tICd5LWNvbXBvbmVudC9zcmMvY29tcG9uZW50LWNvcmUnO1xuXG5pbXBvcnQgeyBsaW5lYXJUd2VlbiwgcGFnZURpc3QgfSBmcm9tICcuLi9jb21tb24nO1xuXG4vLyBjb25zdCBKU19GRUFUVVJFUyA9IFtcbi8vICAgJ2ZuL2FycmF5L2Zvci1lYWNoJyxcbi8vICAgJ2ZuL2Z1bmN0aW9uL2JpbmQnLFxuLy8gICAnZm4vbnVtYmVyL2NvbnN0cnVjdG9yJyxcbi8vICAgJ2ZuL29iamVjdC9hc3NpZ24nLFxuLy8gICAnZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eScsXG4vLyAgICdmbi9vYmplY3Qva2V5cycsXG4vLyAgICdmbi9hcnJheS9yZWR1Y2UnLFxuLy8gXTtcbi8vXG4vLyBjb25zdCBNT0RFUk5JWlJfVEVTVFMgPSBbXG4vLyAgICdjdXN0b21ldmVudCcsXG4vLyAgICdldmVudGxpc3RlbmVyJyxcbi8vICAgJ3F1ZXJ5c2VsZWN0b3InLFxuLy8gICAncmVxdWVzdGFuaW1hdGlvbmZyYW1lJyxcbi8vICAgJ2NsYXNzbGlzdCcsXG4vLyAgICdvcGFjaXR5Jyxcbi8vICAgJ2Nzc3RyYW5zZm9ybXMnLFxuLy8gICAnY3NzcG9pbnRlcmV2ZW50cycsXG4vLyBdO1xuXG5jb25zdCBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sIHx8ICh4ID0+IGBfJHt4fWApO1xuXG5jb25zdCBJRExFID0gU3ltYm9sKCdpZGxlJyk7XG5jb25zdCBUT1VDSElORyA9IFN5bWJvbCgndG91Y2hpbmcnKTtcbmNvbnN0IFNUQVJUX0FOSU1BVElORyA9IFN5bWJvbCgnc3RhcnRBbmltYXRpbmcnKTtcbmNvbnN0IEFOSU1BVElORyA9IFN5bWJvbCgnYW5pbWF0aW5nJyk7XG5cbmNvbnN0IFZFTE9DSVRZX1RIUkVTSE9MRCA9IDAuMjtcbmNvbnN0IFZFTE9DSVRZX0xJTkVBUl9DT01CSU5BVElPTiA9IDAuODtcblxuY29uc3QgZGVmID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LmJpbmQoT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgQyA9PiBjbGFzcyBleHRlbmRzIGNvbXBvbmVudENvcmUoQykge1xuXG4gIC8vIEBvdmVycmlkZVxuICBnZXRDb21wb25lbnROYW1lKCkge1xuICAgIHJldHVybiAneS1kcmF3ZXInO1xuICB9XG5cbiAgLy8gQG92ZXJyaWRlXG4gIHNldHVwQ29tcG9uZW50KGVsLCBwcm9wcykge1xuICAgIHN1cGVyLnNldHVwQ29tcG9uZW50KGVsLCBwcm9wcyk7XG5cbiAgICB0aGlzLmNhY2hlRE9NRWxlbWVudHMoKTtcbiAgICB0aGlzLmRlZlByb3BlcnRpZXMoKTtcbiAgICB0aGlzLmJpbmRDYWxsYmFja3MoKTtcblxuICAgIHRoaXMuanVtcFRvKHRoaXMub3BlbmVkKTtcbiAgICBpZiAoIXRoaXMucGVyc2lzdGVudCkgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIGlmICh0aGlzLnBlcnNpc3RlbnQpIHRoaXMuc2NyaW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0dXBET00oZWwpIHtcbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICBjYWNoZURPTUVsZW1lbnRzKCkge1xuICAgIGRlZih0aGlzLCAnc2NyaW0nLCB7IHZhbHVlOiB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcignLnktZHJhd2VyLXNjcmltJykgfSk7XG4gICAgZGVmKHRoaXMsICdjb250ZW50JywgeyB2YWx1ZTogdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3IoJy55LWRyYXdlci1jb250ZW50JykgfSk7XG4gIH1cblxuICBkZWZQcm9wZXJ0aWVzKCkge1xuICAgIGRlZih0aGlzLCAnc3RhcnRYJywgeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdzdGFydFknLCB7IHZhbHVlOiAwLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ3BhZ2VYJywgeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdwYWdlWScsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnbGFzdFBhZ2VYJywgeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdsYXN0UGFnZVknLCB7IHZhbHVlOiAwLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ2lzU2Nyb2xsaW5nJywgeyB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ3N0YXJ0ZWRNb3ZpbmcnLCB7IHZhbHVlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdsb29wU3RhdGUnLCB7IHZhbHVlOiBJRExFLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ3ZlbG9jaXR5JywgeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdzdGFydFRyYW5zbGF0ZVgnLCB7IHZhbHVlOiAwLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ3RyYW5zbGF0ZVgnLCB7IHZhbHVlOiAwLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ2FuaW1hdGlvbkZyYW1lUmVxdWVzdGVkJywgeyB2YWx1ZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAndG91Y2hpbmcnLCB7IHZhbHVlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdsYXN0VGltZScsIHsgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdzbGlkZXJXaWR0aCcsIHsgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdhbmltYXRpb24nLCB7IHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG4gIH1cblxuICBiaW5kQ2FsbGJhY2tzKCkge1xuICAgIGRlZih0aGlzLCAndG91Y2hTdGFydENhbGxiYWNrJywgeyB2YWx1ZTogdGhpcy50b3VjaFN0YXJ0Q2FsbGJhY2suYmluZCh0aGlzKSB9KTtcbiAgICBkZWYodGhpcywgJ3RvdWNoTW92ZUNhbGxiYWNrJywgeyB2YWx1ZTogdGhpcy50b3VjaE1vdmVDYWxsYmFjay5iaW5kKHRoaXMpIH0pO1xuICAgIGRlZih0aGlzLCAndG91Y2hFbmRDYWxsYmFjaycsIHsgdmFsdWU6IHRoaXMudG91Y2hFbmRDYWxsYmFjay5iaW5kKHRoaXMpIH0pO1xuICAgIGRlZih0aGlzLCAnc2NyaW1DbGlja0NhbGxiYWNrJywgeyB2YWx1ZTogdGhpcy5zY3JpbUNsaWNrQ2FsbGJhY2suYmluZCh0aGlzKSB9KTtcbiAgICBkZWYodGhpcywgJ2FuaW1hdGlvbkZyYW1lQ2FsbGJhY2snLCB7IHZhbHVlOiB0aGlzLmFuaW1hdGlvbkZyYW1lQ2FsbGJhY2suYmluZCh0aGlzKSB9KTtcbiAgfVxuXG4gIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLnRvdWNoU3RhcnRDYWxsYmFjaywgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLnRvdWNoTW92ZUNhbGxiYWNrLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy50b3VjaEVuZENhbGxiYWNrLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuXG4gICAgdGhpcy5zY3JpbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuc2NyaW1DbGlja0NhbGxiYWNrKTtcbiAgfVxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLnRvdWNoU3RhcnRDYWxsYmFjaywgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLnRvdWNoTW92ZUNhbGxiYWNrLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy50b3VjaEVuZENhbGxiYWNrLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuXG4gICAgdGhpcy5zY3JpbS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuc2NyaW1DbGlja0NhbGxiYWNrKTtcbiAgfVxuXG4gIHJlcXVlc3RBbmltYXRpb25Mb29wKCkge1xuICAgIGlmICghdGhpcy5hbmltYXRpb25GcmFtZVJlcXVlc3RlZCkge1xuICAgICAgdGhpcy5hbmltYXRpb25GcmFtZVJlcXVlc3RlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZUNhbGxiYWNrKTtcbiAgICB9XG4gIH1cblxuICBnZXROZWFyZXN0VG91Y2godG91Y2hlcykge1xuICAgIGlmICh0b3VjaGVzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRvdWNoZXNbMF07XG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UuY2FsbCh0b3VjaGVzLCAoYWNjLCB0b3VjaCkgPT4ge1xuICAgICAgY29uc3QgZGlzdCA9IHBhZ2VEaXN0KHRoaXMsIHRvdWNoKTtcbiAgICAgIHJldHVybiAoZGlzdCA8IGFjYy5kaXN0KSA/IHtcbiAgICAgICAgZGlzdCxcbiAgICAgICAgdG91Y2gsXG4gICAgICB9IDogYWNjO1xuICAgIH0sIHtcbiAgICAgIGRpc3Q6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgIHRvdWNoOiBudWxsLFxuICAgIH0pLnRvdWNoO1xuICB9XG5cbiAgdG91Y2hTdGFydENhbGxiYWNrKGUpIHtcbiAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IHVuZGVmaW5lZDtcblxuICAgICAgY29uc3QgdG91Y2ggPSBlLnRvdWNoZXNbMF07XG4gICAgICB0aGlzLnN0YXJ0WCA9IHRvdWNoLnBhZ2VYO1xuICAgICAgdGhpcy5zdGFydFkgPSB0b3VjaC5wYWdlWTtcbiAgICAgIHRoaXMucGFnZVggPSB0b3VjaC5wYWdlWDtcbiAgICAgIHRoaXMucGFnZVkgPSB0b3VjaC5wYWdlWTtcbiAgICAgIHRoaXMubGFzdFBhZ2VYID0gdG91Y2gucGFnZVg7XG4gICAgICB0aGlzLmxhc3RQYWdlWSA9IHRvdWNoLnBhZ2VZO1xuXG4gICAgICBpZiAodGhpcy5vcGVuZWQgfHwgKHRoaXMucGFnZVggPCB3aW5kb3cuaW5uZXJXaWR0aCAvIDMpKSB7XG4gICAgICAgIHRoaXMucHJlcEludGVyYWN0aW9uKCk7XG4gICAgICAgIHRoaXMudG91Y2hpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmxvb3BTdGF0ZSA9IFRPVUNISU5HO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRvdWNoTW92ZUNhbGxiYWNrKGUpIHtcbiAgICBpZiAodGhpcy50b3VjaGluZykge1xuICAgICAgY29uc3QgdG91Y2ggPSB0aGlzLmdldE5lYXJlc3RUb3VjaChlLnRvdWNoZXMpO1xuICAgICAgdGhpcy5wYWdlWCA9IHRvdWNoLnBhZ2VYO1xuICAgICAgdGhpcy5wYWdlWSA9IHRvdWNoLnBhZ2VZO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuaXNTY3JvbGxpbmcgPT09ICd1bmRlZmluZWQnICYmIHRoaXMuc3RhcnRlZE1vdmluZykge1xuICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gTWF0aC5hYnModGhpcy5zdGFydFkgLSB0aGlzLnBhZ2VZKSA+IE1hdGguYWJzKHRoaXMuc3RhcnRYIC0gdGhpcy5wYWdlWCk7XG4gICAgICAgIGlmICghdGhpcy5pc1Njcm9sbGluZykge1xuICAgICAgICAgIHRoaXMubG9vcFN0YXRlID0gVE9VQ0hJTkc7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uTG9vcCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLnN0YXJ0ZWRNb3ZpbmcgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZU1lbnVPcGVuKCkge1xuICAgIGlmICh0aGlzLnZlbG9jaXR5ID4gVkVMT0NJVFlfVEhSRVNIT0xEKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKCdvcGVuZWQnLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudmVsb2NpdHkgPCAtVkVMT0NJVFlfVEhSRVNIT0xEKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKCdvcGVuZWQnLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zbGF0ZVggPj0gdGhpcy5zbGlkZXJXaWR0aCAvIDIpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoJ29wZW5lZCcsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFN0YXRlKCdvcGVuZWQnLCBmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgdG91Y2hFbmRDYWxsYmFjayhlKSB7XG4gICAgaWYgKHRoaXMudG91Y2hpbmcpIHtcbiAgICAgIGlmICh0aGlzLmlzU2Nyb2xsaW5nIHx8IGUudG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhcnRlZE1vdmluZykge1xuICAgICAgICB0aGlzLnVwZGF0ZU1lbnVPcGVuKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgICB0aGlzLnNjcmltLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYWxsJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2NyaW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvb3BTdGF0ZSA9IFNUQVJUX0FOSU1BVElORztcbiAgICAgIHRoaXMuc3RhcnRlZE1vdmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy50b3VjaGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHNjcmltQ2xpY2tDYWxsYmFjaygpIHtcbiAgICB0aGlzLmNsb3NlKCk7XG4gIH1cblxuICBwcmVwSW50ZXJhY3Rpb24oKSB7XG4gICAgdGhpcy5jb250ZW50LnN0eWxlLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgICB0aGlzLnNjcmltLnN0eWxlLndpbGxDaGFuZ2UgPSAnb3BhY2l0eSc7XG4gICAgdGhpcy5jb250ZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3ktZHJhd2VyLW9wZW5lZCcpO1xuICAgIHRoaXMuc2xpZGVyV2lkdGggPSB0aGlzLmdldE1vdmFibGVTbGlkZXJXaWR0aCgpO1xuICB9XG5cbiAgZ2V0TW92YWJsZVNsaWRlcldpZHRoKCkge1xuICAgIC8vIFNpbmNlIHBhcnQgb2YgdGhlIHNsaWRlciBjb3VsZCBiZSB2aXNpYmxlLFxuICAgIC8vIHRoZSB3aWR0aCB0aGF0IGlzIFwibW92YWJsZVwiIGlzIGxlc3MgdGhhbiB0aGUgY29tcGxldGUgc2xpZGVyIHdpZHRoXG4gICAgLy8gYW5kIGdpdmVuIGJ5XG4gICAgcmV0dXJuIC10aGlzLmNvbnRlbnQub2Zmc2V0TGVmdDtcbiAgfVxuXG4gIGFuaW1hdGVUbyhvcGVuZWQpIHtcbiAgICB0aGlzLnByZXBJbnRlcmFjdGlvbigpO1xuICAgIHRoaXMuc2V0U3RhdGUoJ29wZW5lZCcsIG9wZW5lZCk7XG4gICAgdGhpcy5sb29wU3RhdGUgPSBTVEFSVF9BTklNQVRJTkc7XG4gICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uTG9vcCgpO1xuICB9XG5cbiAganVtcFRvKG9wZW5lZCkge1xuICAgIHRoaXMucHJlcEludGVyYWN0aW9uKCk7XG4gICAgdGhpcy5zZXRTdGF0ZSgnb3BlbmVkJywgb3BlbmVkKTtcbiAgICB0aGlzLmxvb3BTdGF0ZSA9IElETEU7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuc3RhcnRUcmFuc2xhdGVYID0gb3BlbmVkICogdGhpcy5zbGlkZXJXaWR0aDtcbiAgICAgIHRoaXMuZW5kQW5pbWF0aW5nKCk7XG4gICAgICB0aGlzLnVwZGF0ZURPTSh0aGlzLnN0YXJ0VHJhbnNsYXRlWCwgdGhpcy5zbGlkZXJXaWR0aCk7XG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVUcmFuc2xhdGVYKCkge1xuICAgIGNvbnN0IGRlbHRhWCA9IHRoaXMucGFnZVggLSB0aGlzLnN0YXJ0WDtcbiAgICB0aGlzLnRyYW5zbGF0ZVggPSB0aGlzLnN0YXJ0VHJhbnNsYXRlWCArIGRlbHRhWDtcbiAgICB0aGlzLnRyYW5zbGF0ZVggPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0aGlzLnNsaWRlcldpZHRoLCB0aGlzLnRyYW5zbGF0ZVgpKTtcbiAgICByZXR1cm4gZGVsdGFYO1xuICB9XG5cbiAgYW5pbWF0aW9uRnJhbWVDYWxsYmFjayh0aW1lKSB7XG4gICAgc3dpdGNoICh0aGlzLmxvb3BTdGF0ZSkge1xuICAgICAgY2FzZSBUT1VDSElORzoge1xuICAgICAgICB0aGlzLnRvdWNoaW5nRnJhbWUodGltZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIFNUQVJUX0FOSU1BVElORzoge1xuICAgICAgICB0aGlzLnN0YXJ0QW5pbWF0aW5nRnJhbWUodGltZSk7XG4gICAgICAgIHRoaXMubG9vcFN0YXRlID0gQU5JTUFUSU5HO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sodGltZSk7IC8vIGp1bXAgdG8gbmV4dCBjYXNlIGJsb2NrXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlIEFOSU1BVElORzoge1xuICAgICAgICB0aGlzLmFuaW1hdGluZ0ZyYW1lKHRpbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b3VjaGluZ0ZyYW1lKHRpbWUpIHtcbiAgICBjb25zdCB0aW1lRGlmZiA9IHRpbWUgLSB0aGlzLmxhc3RUaW1lO1xuXG4gICAgaWYgKHRpbWVEaWZmID4gMCkge1xuICAgICAgY29uc3QgcGFnZVhEaWZmID0gdGhpcy5wYWdlWCAtIHRoaXMubGFzdFBhZ2VYO1xuICAgICAgdGhpcy52ZWxvY2l0eSA9IChWRUxPQ0lUWV9MSU5FQVJfQ09NQklOQVRJT04gKiAocGFnZVhEaWZmIC8gdGltZURpZmYpKSArXG4gICAgICAgICAgICAgICAgICAgICAgKCgxIC0gVkVMT0NJVFlfTElORUFSX0NPTUJJTkFUSU9OKSAqIHRoaXMudmVsb2NpdHkpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlVHJhbnNsYXRlWCgpO1xuICAgIHRoaXMudXBkYXRlRE9NKHRoaXMudHJhbnNsYXRlWCwgdGhpcy5zbGlkZXJXaWR0aCk7XG5cbiAgICB0aGlzLmxhc3RUaW1lID0gdGltZTtcbiAgICB0aGlzLmxhc3RQYWdlWCA9IHRoaXMucGFnZVg7XG4gICAgdGhpcy5sYXN0UGFnZVkgPSB0aGlzLnBhZ2VZO1xuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVDYWxsYmFjayk7XG4gIH1cblxuICBzdGFydEFuaW1hdGluZ0ZyYW1lKHRpbWUpIHtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zbGF0ZVgoKTtcblxuICAgIC8vIHN0b3JlIGFsbCBhbmltYXRpb24gcmVsYXRlZCBkYXRhIGluIHRoaXMgb2JqZWN0LFxuICAgIC8vIGRlbGV0ZSBhZnRlciBhbmltYXRpb24gaXMgY29tcGxldGVkXG4gICAgY29uc3QgYW5pbWF0aW9uID0ge307XG4gICAgYW5pbWF0aW9uLnN0YXJ0WCA9IHRoaXMudHJhbnNsYXRlWDtcbiAgICBhbmltYXRpb24uZW5kWCA9ICh0aGlzLm9wZW5lZCA/IDEgOiAwKSAqIHRoaXMuc2xpZGVyV2lkdGg7XG4gICAgYW5pbWF0aW9uLmNoYW5nZUluVmFsdWUgPSBhbmltYXRpb24uZW5kWCAtIGFuaW1hdGlvbi5zdGFydFg7XG4gICAgYW5pbWF0aW9uLnN0YXJ0VGltZSA9IHRpbWU7XG4gICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XG4gIH1cblxuICBhbmltYXRpbmdGcmFtZSh0aW1lKSB7XG4gICAgY29uc3QgdGltZUluQW5pbWF0aW9uID0gdGltZSAtIHRoaXMuYW5pbWF0aW9uLnN0YXJ0VGltZTtcblxuICAgIGlmICh0aW1lSW5BbmltYXRpb24gPCB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbikge1xuICAgICAgdGhpcy5hbmltYXRpbmdDb250KHRpbWVJbkFuaW1hdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYW5pbWF0aW5nRW5kKCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVET00odGhpcy5zdGFydFRyYW5zbGF0ZVgsIHRoaXMuc2xpZGVyV2lkdGgpO1xuICB9XG5cbiAgYW5pbWF0aW5nQ29udCh0aW1lSW5BbmltYXRpb24pIHtcbiAgICBjb25zdCBzdGFydFZhbHVlID0gdGhpcy5hbmltYXRpb24uc3RhcnRYO1xuICAgIGNvbnN0IGNoYW5nZUluVmFsdWUgPSB0aGlzLmFuaW1hdGlvbi5jaGFuZ2VJblZhbHVlO1xuICAgIHRoaXMuc3RhcnRUcmFuc2xhdGVYID0gbGluZWFyVHdlZW4odGltZUluQW5pbWF0aW9uLCBzdGFydFZhbHVlLCBjaGFuZ2VJblZhbHVlLFxuICAgICAgdGhpcy50cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lQ2FsbGJhY2spO1xuICB9XG5cbiAgYW5pbWF0aW5nRW5kKCkge1xuICAgIC8vIGVuZCBhbmltYXRpb25cbiAgICB0aGlzLnN0YXJ0VHJhbnNsYXRlWCA9IHRoaXMuYW5pbWF0aW9uLmVuZFg7XG4gICAgZGVsZXRlIHRoaXMuYW5pbWF0aW9uO1xuICAgIHRoaXMuZW5kQW5pbWF0aW5nKCk7XG4gIH1cblxuICBlbmRBbmltYXRpbmcoKSB7XG4gICAgdGhpcy5hbmltYXRpb25GcmFtZVJlcXVlc3RlZCA9IGZhbHNlO1xuICAgIHRoaXMubG9vcFN0YXRlID0gSURMRTtcbiAgICB0aGlzLnZlbG9jaXR5ID0gMDtcblxuICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgLy8gZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcbiAgICAgIHRoaXMuc2NyaW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhbGwnO1xuICAgICAgdGhpcy5jb250ZW50LmNsYXNzTGlzdC5hZGQoJ3ktZHJhd2VyLW9wZW5lZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93WSA9ICcnO1xuICAgICAgdGhpcy5zY3JpbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG5cbiAgICAgIC8vIG9ubHkgcmVtb3ZlIHRoZSBzdHlsZXMgd2hlbiBjbG9zaW5nIHRoZSBkcmF3ZXIsXG4gICAgICAvLyBzaW5jZSB3ZSBlaXRlaHIgZXhwZWN0IGEgbmF2aWdhdGlvbiAocGFnZSByZWxvYWQpXG4gICAgICAvLyBvciBjbG9zaW5nIHRoZSBkcmF3ZXIgYWdhaW4sIGllIG1vcmUgY2hhbmdlc1xuICAgICAgdGhpcy5jb250ZW50LnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgICAgIHRoaXMuc2NyaW0uc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIH1cblxuICAgIHRoaXMuZmlyZUV2ZW50KCd0cmFuc2l0aW9uZWQnKTtcbiAgfVxuXG4gIHVwZGF0ZURPTSh0cmFuc2xhdGVYLCBzbGlkZXJXaWR0aCkge1xuICAgIHRoaXMuY29udGVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgke3RyYW5zbGF0ZVh9cHgpYDtcbiAgICB0aGlzLnNjcmltLnN0eWxlLm9wYWNpdHkgPSB0cmFuc2xhdGVYIC8gc2xpZGVyV2lkdGg7XG4gIH1cblxuICAvLyBAb3ZlcnJpZGVcbiAgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW5lZDogZmFsc2UsXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IDIwMCxcbiAgICAgIHBlcnNpc3RlbnQ6IGZhbHNlLFxuICAgIH07XG4gIH1cblxuICAvLyBAb3ZlcnJpZGVcbiAgc2lkZUVmZmVjdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZW5lZDogKG8pID0+IHtcbiAgICAgICAgaWYgKG8gPT09IHRydWUpIHRoaXMub3BlbigpO1xuICAgICAgICBlbHNlIHRoaXMuY2xvc2UoKTtcbiAgICAgIH0sXG4gICAgICBwZXJzaXN0ZW50OiAoZCkgPT4ge1xuICAgICAgICBpZiAoZCA9PT0gdHJ1ZSkgdGhpcy5wZXJzaXN0KCk7XG4gICAgICAgIGVsc2UgdGhpcy51bnBlcnNpc3QoKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuYW5pbWF0ZVRvKGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5hbmltYXRlVG8odHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHBlcnNpc3QoKSB7XG4gICAgdGhpcy5zY3JpbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnNldFN0YXRlKCdwZXJzaXN0ZW50JywgdHJ1ZSk7XG4gIH1cblxuICB1bnBlcnNpc3QoKSB7XG4gICAgdGhpcy5zY3JpbS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuc2V0U3RhdGUoJ3BlcnNpc3RlbnQnLCBmYWxzZSk7XG4gIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZsb3JpYW4gS2xhbXBmZXJcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcywgaW1wb3J0L25vLXVucmVzb2x2ZWQsIGltcG9ydC9leHRlbnNpb25zICovXG5pbXBvcnQgZHJhd2VyQ29yZSBmcm9tICcuLi9jb3JlJztcblxuY29uc3Qgc3R5bGUgPSBgXG48c3R5bGU+XG4ueS1kcmF3ZXItc2NyaW0ge1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGZpeGVkO1xuICB0b3A6IDA7XG4gIHJpZ2h0OiAwO1xuICBib3R0b206IDA7XG4gIGxlZnQ6IDA7XG4gIG9wYWNpdHk6IDA7XG4gIHotaW5kZXg6IDA7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsMCwwKTtcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgY29udGFpbjogY29udGVudDtcblxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNjcpO1xufVxuXG4ueS1kcmF3ZXItY29udGVudCB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgbGVmdDogMDtcbiAgYm90dG9tOiAwO1xuICB0b3A6IDA7XG4gIHotaW5kZXg6IDE7XG4gIG92ZXJmbG93LXg6IGhpZGRlbjtcbiAgb3ZlcmZsb3cteTogYXV0bztcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLDAsMCk7XG4gIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcbiAgY29udGFpbjogY29udGVudDtcblxuICBsZWZ0OiAtMThyZW07XG4gIHdpZHRoOiAxOHJlbTtcbiAgYmFja2dyb3VuZDogI2U4ZThlODtcbn1cblxuLnktZHJhd2VyLWNvbnRlbnQueS1kcmF3ZXItb3BlbmVkIHtcbiAgbGVmdDogMCFpbXBvcnRhbnQ7XG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwwLDApIWltcG9ydGFudDtcbn1cblxuPC9zdHlsZT5gO1xuXG5cbmZ1bmN0aW9uIGZyYWdtZW50RnJvbVN0cmluZyhzdHJIVE1MKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHJIVE1MKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHJhd2VyIGV4dGVuZHMgZHJhd2VyQ29yZSgpIHtcbiAgY29uc3RydWN0b3IoZWwsIHByb3BzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNldHVwQ29tcG9uZW50KGVsLCBwcm9wcyk7XG4gIH1cblxuICAvLyBAb3ZlcnJpZGVcbiAgc2V0dXBET00oZWwpIHtcbiAgICBpZiAoIWVsKSB0aHJvdyBFcnJvcignTm8gZWxlbWVudCBwcm92aWRlZCcpO1xuXG4gICAgY29uc3Qgc2NyaW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzY3JpbS5jbGFzc0xpc3QuYWRkKCd5LWRyYXdlci1zY3JpbScpO1xuXG4gICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgneS1kcmF3ZXItY29udGVudCcpO1xuICAgIHdoaWxlIChlbC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBjb250ZW50LmFwcGVuZENoaWxkKGVsLmNoaWxkcmVuWzBdKTtcbiAgICB9XG5cbiAgICBlbC5hcHBlbmRDaGlsZChzY3JpbSk7XG4gICAgZWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICBjb25zdCByZWYgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3R5bGUnKVswXTtcbiAgICByZWYucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZnJhZ21lbnRGcm9tU3RyaW5nKHN0eWxlKSwgcmVmKTtcblxuICAgIHJldHVybiBlbDtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgSW5uZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5uZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyU3Vic2NyaWJlcihwYXJlbnQsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLm91dGVyVmFsdWUgPSBvdXRlclZhbHVlO1xuICAgICAgICB0aGlzLm91dGVySW5kZXggPSBvdXRlckluZGV4O1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhcmVudC5ub3RpZnlOZXh0KHRoaXMub3V0ZXJWYWx1ZSwgdmFsdWUsIHRoaXMub3V0ZXJJbmRleCwgdGhpcy5pbmRleCsrLCB0aGlzKTtcbiAgICB9O1xuICAgIElubmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeUVycm9yKGVycm9yLCB0aGlzKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeUNvbXBsZXRlKHRoaXMpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5uZXJTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5Jbm5lclN1YnNjcmliZXIgPSBJbm5lclN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5lclN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgT3V0ZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3V0ZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE91dGVyU3Vic2NyaWJlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIE91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE91dGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuT3V0ZXJTdWJzY3JpYmVyID0gT3V0ZXJTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3V0ZXJTdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InKTtcbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YmplY3RTdWJzY3JpcHRpb24nKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBAY2xhc3MgU3ViamVjdFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YmplY3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgfVxuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmliZXIgPSBTdWJqZWN0U3Vic2NyaWJlcjtcbi8qKlxuICogQGNsYXNzIFN1YmplY3Q8VD5cbiAqL1xudmFyIFN1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3QoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBTdWJqZWN0LnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ViamVjdFN1YnNjcmliZXIodGhpcyk7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gbmV3IEFub255bW91c1N1YmplY3QodGhpcywgdGhpcyk7XG4gICAgICAgIHN1YmplY3Qub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29weVtpXS5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50aHJvd25FcnJvciA9IGVycjtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBudWxsO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl90cnlTdWJzY3JpYmUuY2FsbCh0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHRoaXMudGhyb3duRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpcHRpb25fMS5TdWJqZWN0U3Vic2NyaXB0aW9uKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5hc09ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKCk7XG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBTdWJqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJqZWN0O1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5TdWJqZWN0ID0gU3ViamVjdDtcbi8qKlxuICogQGNsYXNzIEFub255bW91c1N1YmplY3Q8VD5cbiAqL1xudmFyIEFub255bW91c1N1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbm9ueW1vdXNTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24ubmV4dCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFub255bW91c1N1YmplY3Q7XG59KFN1YmplY3QpKTtcbmV4cG9ydHMuQW5vbnltb3VzU3ViamVjdCA9IEFub255bW91c1N1YmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0U3Vic2NyaXB0aW9uKHN1YmplY3QsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IHN1YnNjcmliZXI7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgfVxuICAgIFN1YmplY3RTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0O1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gc3ViamVjdC5vYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IG51bGw7XG4gICAgICAgIGlmICghb2JzZXJ2ZXJzIHx8IG9ic2VydmVycy5sZW5ndGggPT09IDAgfHwgc3ViamVjdC5pc1N0b3BwZWQgfHwgc3ViamVjdC5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaWJlckluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2YodGhpcy5zdWJzY3JpYmVyKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2Uoc3Vic2NyaWJlckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5TdWJqZWN0U3Vic2NyaXB0aW9uID0gU3ViamVjdFN1YnNjcmlwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3RTdWJzY3JpcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGRlZmVyXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL2RlZmVyJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5kZWZlciA9IGRlZmVyXzEuZGVmZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgYWpheF8xID0gcmVxdWlyZSgnLi4vLi4vLi4vb2JzZXJ2YWJsZS9kb20vYWpheCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuYWpheCA9IGFqYXhfMS5hamF4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWpheC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZW1wdHlfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvZW1wdHknKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmVtcHR5ID0gZW1wdHlfMS5lbXB0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtcHR5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBtZXJnZV8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9tZXJnZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUubWVyZ2UgPSBtZXJnZV8xLm1lcmdlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIG9mXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL29mJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5vZiA9IG9mXzEub2Y7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGhyb3dfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvdGhyb3cnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnRocm93ID0gdGhyb3dfMS5fdGhyb3c7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY2F0Y2hfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2NhdGNoJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY2F0Y2ggPSBjYXRjaF8xLl9jYXRjaDtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5fY2F0Y2ggPSBjYXRjaF8xLl9jYXRjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkZWxheV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZGVsYXknKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kZWxheSA9IGRlbGF5XzEuZGVsYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWxheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGlzdGluY3RVbnRpbEtleUNoYW5nZWRfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQgPSBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZF8xLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGluY3RVbnRpbEtleUNoYW5nZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZpbHRlcl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZmlsdGVyJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmlsdGVyID0gZmlsdGVyXzEuZmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBtZXJnZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvbWVyZ2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5tZXJnZSA9IG1lcmdlXzEubWVyZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VBbGxfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21lcmdlQWxsJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2VBbGwgPSBtZXJnZUFsbF8xLm1lcmdlQWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VBbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHNoYXJlXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zaGFyZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnNoYXJlID0gc2hhcmVfMS5zaGFyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzdGFydFdpdGhfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3N0YXJ0V2l0aCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnN0YXJ0V2l0aCA9IHN0YXJ0V2l0aF8xLnN0YXJ0V2l0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXJ0V2l0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc3dpdGNoXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zd2l0Y2gnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zd2l0Y2ggPSBzd2l0Y2hfMS5fc3dpdGNoO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLl9zd2l0Y2ggPSBzd2l0Y2hfMS5fc3dpdGNoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzd2l0Y2hNYXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3N3aXRjaE1hcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnN3aXRjaE1hcCA9IHN3aXRjaE1hcF8xLnN3aXRjaE1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaE1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGFrZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvdGFrZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnRha2UgPSB0YWtlXzEudGFrZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHdpdGhMYXRlc3RGcm9tXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci93aXRoTGF0ZXN0RnJvbScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLndpdGhMYXRlc3RGcm9tID0gd2l0aExhdGVzdEZyb21fMS53aXRoTGF0ZXN0RnJvbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpdGhMYXRlc3RGcm9tLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB6aXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3ppcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnppcCA9IHppcF8xLnppcFByb3RvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emlwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIFNjYWxhck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vU2NhbGFyT2JzZXJ2YWJsZScpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9FbXB0eU9ic2VydmFibGUnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBBcnJheU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIGlmICghc2NoZWR1bGVyICYmIGFycmF5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5faXNTY2FsYXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGFycmF5WzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFycmF5T2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoYXJyYXksIHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHNvbWUgdmFsdWVzIHlvdSBzcGVjaWZ5IGFzIGFyZ3VtZW50cyxcbiAgICAgKiBpbW1lZGlhdGVseSBvbmUgYWZ0ZXIgdGhlIG90aGVyLCBhbmQgdGhlbiBlbWl0cyBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5FbWl0cyB0aGUgYXJndW1lbnRzIHlvdSBwcm92aWRlLCB0aGVuIGNvbXBsZXRlcy5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL29mLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogVGhpcyBzdGF0aWMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQgb25seVxuICAgICAqIGVtaXRzIHRoZSBhcmd1bWVudHMgZ2l2ZW4sIGFuZCB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uIHRoZXJlYWZ0ZXIuIEl0IGNhblxuICAgICAqIGJlIHVzZWQgZm9yIGNvbXBvc2luZyB3aXRoIG90aGVyIE9ic2VydmFibGVzLCBzdWNoIGFzIHdpdGgge0BsaW5rIGNvbmNhdH0uXG4gICAgICogQnkgZGVmYXVsdCwgaXQgdXNlcyBhIGBudWxsYCBJU2NoZWR1bGVyLCB3aGljaCBtZWFucyB0aGUgYG5leHRgXG4gICAgICogbm90aWZpY2F0aW9ucyBhcmUgc2VudCBzeW5jaHJvbm91c2x5LCBhbHRob3VnaCB3aXRoIGEgZGlmZmVyZW50IElTY2hlZHVsZXJcbiAgICAgKiBpdCBpcyBwb3NzaWJsZSB0byBkZXRlcm1pbmUgd2hlbiB0aG9zZSBub3RpZmljYXRpb25zIHdpbGwgYmUgZGVsaXZlcmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCAxMCwgMjAsIDMwLCB0aGVuICdhJywgJ2InLCAnYycsIHRoZW4gc3RhcnQgdGlja2luZyBldmVyeSBzZWNvbmQuPC9jYXB0aW9uPlxuICAgICAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS5vZigxMCwgMjAsIDMwKTtcbiAgICAgKiB2YXIgbGV0dGVycyA9IFJ4Lk9ic2VydmFibGUub2YoJ2EnLCAnYicsICdjJyk7XG4gICAgICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gbnVtYmVycy5jb25jYXQobGV0dGVycykuY29uY2F0KGludGVydmFsKTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIGVtcHR5fVxuICAgICAqIEBzZWUge0BsaW5rIG5ldmVyfVxuICAgICAqIEBzZWUge0BsaW5rIHRocm93fVxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi5UfSB2YWx1ZXMgQXJndW1lbnRzIHRoYXQgcmVwcmVzZW50IGBuZXh0YCB2YWx1ZXMgdG8gYmUgZW1pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9ucyBvZiB0aGUgYG5leHRgIG5vdGlmaWNhdGlvbnMuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGVhY2ggZ2l2ZW4gaW5wdXQgdmFsdWUuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgb2ZcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEFycmF5T2JzZXJ2YWJsZS5vZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NoZWR1bGVyID0gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcbiAgICAgICAgICAgIGFycmF5LnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NoZWR1bGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjYWxhck9ic2VydmFibGVfMS5TY2FsYXJPYnNlcnZhYmxlKGFycmF5WzBdLCBzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXJyYXlPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBhcnJheSA9IHN0YXRlLmFycmF5LCBpbmRleCA9IHN0YXRlLmluZGV4LCBjb3VudCA9IHN0YXRlLmNvdW50LCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKGluZGV4ID49IGNvdW50KSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KGFycmF5W2luZGV4XSk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbiAgICB9O1xuICAgIEFycmF5T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICAgIHZhciBjb3VudCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEFycmF5T2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGFycmF5OiBhcnJheSwgaW5kZXg6IGluZGV4LCBjb3VudDogY291bnQsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCAmJiAhc3Vic2NyaWJlci5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBcnJheU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkFycmF5T2JzZXJ2YWJsZSA9IEFycmF5T2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFycmF5T2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIEBjbGFzcyBDb25uZWN0YWJsZU9ic2VydmFibGU8VD5cbiAqL1xudmFyIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbm5lY3RhYmxlT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25uZWN0YWJsZU9ic2VydmFibGUoc291cmNlLCBzdWJqZWN0RmFjdG9yeSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc3ViamVjdEZhY3RvcnkgPSBzdWJqZWN0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5fcmVmQ291bnQgPSAwO1xuICAgIH1cbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdWJqZWN0KCkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5nZXRTdWJqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuX3N1YmplY3Q7XG4gICAgICAgIGlmICghc3ViamVjdCB8fCBzdWJqZWN0LmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5fc3ViamVjdCA9IHRoaXMuc3ViamVjdEZhY3RvcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3ViamVjdDtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLl9jb25uZWN0aW9uO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24gPSB0aGlzLl9jb25uZWN0aW9uID0gbmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5hZGQodGhpcy5zb3VyY2VcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKG5ldyBDb25uZWN0YWJsZVN1YnNjcmliZXIodGhpcy5nZXRTdWJqZWN0KCksIHRoaXMpKSk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLnJlZkNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZWZDb3VudE9wZXJhdG9yKHRoaXMpKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25uZWN0YWJsZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkNvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IENvbm5lY3RhYmxlT2JzZXJ2YWJsZTtcbmV4cG9ydHMuY29ubmVjdGFibGVPYnNlcnZhYmxlRGVzY3JpcHRvciA9IHtcbiAgICBvcGVyYXRvcjogeyB2YWx1ZTogbnVsbCB9LFxuICAgIF9yZWZDb3VudDogeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBfc3Vic2NyaWJlOiB7IHZhbHVlOiBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgfSxcbiAgICBnZXRTdWJqZWN0OiB7IHZhbHVlOiBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLmdldFN1YmplY3QgfSxcbiAgICBjb25uZWN0OiB7IHZhbHVlOiBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLmNvbm5lY3QgfSxcbiAgICByZWZDb3VudDogeyB2YWx1ZTogQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5yZWZDb3VudCB9XG59O1xudmFyIENvbm5lY3RhYmxlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbm5lY3RhYmxlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25uZWN0YWJsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgIH1cbiAgICBDb25uZWN0YWJsZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fZXJyb3IuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gdGhpcy5jb25uZWN0YWJsZTtcbiAgICAgICAgaWYgKGNvbm5lY3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0gY29ubmVjdGFibGUuX2Nvbm5lY3Rpb247XG4gICAgICAgICAgICBjb25uZWN0YWJsZS5fcmVmQ291bnQgPSAwO1xuICAgICAgICAgICAgY29ubmVjdGFibGUuX3N1YmplY3QgPSBudWxsO1xuICAgICAgICAgICAgY29ubmVjdGFibGUuX2Nvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb25uZWN0YWJsZVN1YnNjcmliZXI7XG59KFN1YmplY3RfMS5TdWJqZWN0U3Vic2NyaWJlcikpO1xudmFyIFJlZkNvdW50T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZkNvdW50T3BlcmF0b3IoY29ubmVjdGFibGUpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgIH1cbiAgICBSZWZDb3VudE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICB2YXIgY29ubmVjdGFibGUgPSB0aGlzLmNvbm5lY3RhYmxlO1xuICAgICAgICBjb25uZWN0YWJsZS5fcmVmQ291bnQrKztcbiAgICAgICAgdmFyIHJlZkNvdW50ZXIgPSBuZXcgUmVmQ291bnRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGNvbm5lY3RhYmxlKTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUocmVmQ291bnRlcik7XG4gICAgICAgIGlmICghcmVmQ291bnRlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJlZkNvdW50ZXIuY29ubmVjdGlvbiA9IGNvbm5lY3RhYmxlLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZkNvdW50T3BlcmF0b3I7XG59KCkpO1xudmFyIFJlZkNvdW50U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZkNvdW50U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZDb3VudFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgIH1cbiAgICBSZWZDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gdGhpcy5jb25uZWN0YWJsZTtcbiAgICAgICAgaWYgKCFjb25uZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gbnVsbDtcbiAgICAgICAgdmFyIHJlZkNvdW50ID0gY29ubmVjdGFibGUuX3JlZkNvdW50O1xuICAgICAgICBpZiAocmVmQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0YWJsZS5fcmVmQ291bnQgPSByZWZDb3VudCAtIDE7XG4gICAgICAgIGlmIChyZWZDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8vXG4gICAgICAgIC8vIENvbXBhcmUgdGhlIGxvY2FsIFJlZkNvdW50U3Vic2NyaWJlcidzIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIHRvIHRoZVxuICAgICAgICAvLyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiBvbiB0aGUgc2hhcmVkIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS4gSW4gY2FzZXNcbiAgICAgICAgLy8gd2hlcmUgdGhlIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSBzb3VyY2Ugc3luY2hyb25vdXNseSBlbWl0cyB2YWx1ZXMsIGFuZFxuICAgICAgICAvLyB0aGUgUmVmQ291bnRTdWJzY3JpYmVyJ3MgZG93bnN0cmVhbSBPYnNlcnZlcnMgc3luY2hyb25vdXNseSB1bnN1YnNjcmliZSxcbiAgICAgICAgLy8gZXhlY3V0aW9uIGNvbnRpbnVlcyB0byBoZXJlIGJlZm9yZSB0aGUgUmVmQ291bnRPcGVyYXRvciBoYXMgYSBjaGFuY2UgdG9cbiAgICAgICAgLy8gc3VwcGx5IHRoZSBSZWZDb3VudFN1YnNjcmliZXIgd2l0aCB0aGUgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uLlxuICAgICAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vIE9ic2VydmFibGUucmFuZ2UoMCwgMTApXG4gICAgICAgIC8vICAgLnB1Ymxpc2goKVxuICAgICAgICAvLyAgIC5yZWZDb3VudCgpXG4gICAgICAgIC8vICAgLnRha2UoNSlcbiAgICAgICAgLy8gICAuc3Vic2NyaWJlKCk7XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyBJbiBvcmRlciB0byBhY2NvdW50IGZvciB0aGlzIGNhc2UsIFJlZkNvdW50U3Vic2NyaWJlciBzaG91bGQgb25seSBkaXNwb3NlXG4gICAgICAgIC8vIHRoZSBDb25uZWN0YWJsZU9ic2VydmFibGUncyBzaGFyZWQgY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gaWYgdGhlXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIGV4aXN0cywgKmFuZCogZWl0aGVyOlxuICAgICAgICAvLyAgIGEuIFJlZkNvdW50U3Vic2NyaWJlciBkb2Vzbid0IGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIHNoYXJlZCBjb25uZWN0aW9uXG4gICAgICAgIC8vICAgICAgU3Vic2NyaXB0aW9uIHlldCwgb3IsXG4gICAgICAgIC8vICAgYi4gUmVmQ291bnRTdWJzY3JpYmVyJ3MgY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gcmVmZXJlbmNlIGlzIGlkZW50aWNhbFxuICAgICAgICAvLyAgICAgIHRvIHRoZSBzaGFyZWQgY29ubmVjdGlvbiBTdWJzY3JpcHRpb25cbiAgICAgICAgLy8vXG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uO1xuICAgICAgICB2YXIgc2hhcmVkQ29ubmVjdGlvbiA9IGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICBpZiAoc2hhcmVkQ29ubmVjdGlvbiAmJiAoIWNvbm5lY3Rpb24gfHwgc2hhcmVkQ29ubmVjdGlvbiA9PT0gY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgIHNoYXJlZENvbm5lY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlZkNvdW50U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbm5lY3RhYmxlT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIERlZmVyT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmVyT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZlck9ic2VydmFibGUob2JzZXJ2YWJsZUZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZUZhY3RvcnkgPSBvYnNlcnZhYmxlRmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQsIG9uIHN1YnNjcmliZSwgY2FsbHMgYW4gT2JzZXJ2YWJsZSBmYWN0b3J5IHRvXG4gICAgICogbWFrZSBhbiBPYnNlcnZhYmxlIGZvciBlYWNoIG5ldyBPYnNlcnZlci5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5DcmVhdGVzIHRoZSBPYnNlcnZhYmxlIGxhemlseSwgdGhhdCBpcywgb25seSB3aGVuIGl0XG4gICAgICogaXMgc3Vic2NyaWJlZC5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2RlZmVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogYGRlZmVyYCBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0aGUgT2JzZXJ2YWJsZSBvbmx5IHdoZW4gdGhlIE9ic2VydmVyXG4gICAgICogc3Vic2NyaWJlcywgYW5kIGNyZWF0ZSBhIGZyZXNoIE9ic2VydmFibGUgZm9yIGVhY2ggT2JzZXJ2ZXIuIEl0IHdhaXRzIHVudGlsXG4gICAgICogYW4gT2JzZXJ2ZXIgc3Vic2NyaWJlcyB0byBpdCwgYW5kIHRoZW4gaXQgZ2VuZXJhdGVzIGFuIE9ic2VydmFibGUsXG4gICAgICogdHlwaWNhbGx5IHdpdGggYW4gT2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uLiBJdCBkb2VzIHRoaXMgYWZyZXNoIGZvciBlYWNoXG4gICAgICogc3Vic2NyaWJlciwgc28gYWx0aG91Z2ggZWFjaCBzdWJzY3JpYmVyIG1heSB0aGluayBpdCBpcyBzdWJzY3JpYmluZyB0byB0aGVcbiAgICAgKiBzYW1lIE9ic2VydmFibGUsIGluIGZhY3QgZWFjaCBzdWJzY3JpYmVyIGdldHMgaXRzIG93biBpbmRpdmlkdWFsXG4gICAgICogT2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN1YnNjcmliZSB0byBlaXRoZXIgYW4gT2JzZXJ2YWJsZSBvZiBjbGlja3Mgb3IgYW4gT2JzZXJ2YWJsZSBvZiBpbnRlcnZhbCwgYXQgcmFuZG9tPC9jYXB0aW9uPlxuICAgICAqIHZhciBjbGlja3NPckludGVydmFsID0gUnguT2JzZXJ2YWJsZS5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICogICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAqICAgICByZXR1cm4gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgcmV0dXJuIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogY2xpY2tzT3JJbnRlcnZhbC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmcgYmVoYXZpb3I6XG4gICAgICogLy8gSWYgdGhlIHJlc3VsdCBvZiBNYXRoLnJhbmRvbSgpIGlzIGdyZWF0ZXIgdGhhbiAwLjUgaXQgd2lsbCBsaXN0ZW5cbiAgICAgKiAvLyBmb3IgY2xpY2tzIGFueXdoZXJlIG9uIHRoZSBcImRvY3VtZW50XCI7IHdoZW4gZG9jdW1lbnQgaXMgY2xpY2tlZCBpdFxuICAgICAqIC8vIHdpbGwgbG9nIGEgTW91c2VFdmVudCBvYmplY3QgdG8gdGhlIGNvbnNvbGUuIElmIHRoZSByZXN1bHQgaXMgbGVzc1xuICAgICAqIC8vIHRoYW4gMC41IGl0IHdpbGwgZW1pdCBhc2NlbmRpbmcgbnVtYmVycywgb25lIGV2ZXJ5IHNlY29uZCgxMDAwbXMpLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiBTdWJzY3JpYmFibGVPclByb21pc2V9IG9ic2VydmFibGVGYWN0b3J5IFRoZSBPYnNlcnZhYmxlXG4gICAgICogZmFjdG9yeSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggT2JzZXJ2ZXIgdGhhdCBzdWJzY3JpYmVzIHRvIHRoZSBvdXRwdXRcbiAgICAgKiBPYnNlcnZhYmxlLiBNYXkgYWxzbyByZXR1cm4gYSBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGNvbnZlcnRlZCBvbiB0aGUgZmx5XG4gICAgICogdG8gYW4gT2JzZXJ2YWJsZS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHdob3NlIE9ic2VydmVycycgc3Vic2NyaXB0aW9ucyB0cmlnZ2VyXG4gICAgICogYW4gaW52b2NhdGlvbiBvZiB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGRlZmVyXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBEZWZlck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKG9ic2VydmFibGVGYWN0b3J5KSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJPYnNlcnZhYmxlKG9ic2VydmFibGVGYWN0b3J5KTtcbiAgICB9O1xuICAgIERlZmVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMub2JzZXJ2YWJsZUZhY3RvcnkpO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmVyT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRGVmZXJPYnNlcnZhYmxlID0gRGVmZXJPYnNlcnZhYmxlO1xudmFyIERlZmVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZlclN1YnNjcmliZXIoZGVzdGluYXRpb24sIGZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLnRyeURlZmVyKCk7XG4gICAgfVxuICAgIERlZmVyU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5RGVmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsRmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2NhbGxGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5mYWN0b3J5KCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWZlclN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmZXJPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBFbXB0eU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbXB0eU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG5vIGl0ZW1zIHRvIHRoZSBPYnNlcnZlciBhbmQgaW1tZWRpYXRlbHlcbiAgICAgKiBlbWl0cyBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5KdXN0IGVtaXRzICdjb21wbGV0ZScsIGFuZCBub3RoaW5nIGVsc2UuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9lbXB0eS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uLiBJdCBjYW4gYmUgdXNlZCBmb3IgY29tcG9zaW5nIHdpdGggb3RoZXJcbiAgICAgKiBPYnNlcnZhYmxlcywgc3VjaCBhcyBpbiBhIHtAbGluayBtZXJnZU1hcH0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBudW1iZXIgNywgdGhlbiBjb21wbGV0ZS48L2NhcHRpb24+XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZW1wdHkoKS5zdGFydFdpdGgoNyk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBhbmQgZmxhdHRlbiBvbmx5IG9kZCBudW1iZXJzIHRvIHRoZSBzZXF1ZW5jZSAnYScsICdiJywgJ2MnPC9jYXB0aW9uPlxuICAgICAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogdmFyIHJlc3VsdCA9IGludGVydmFsLm1lcmdlTWFwKHggPT5cbiAgICAgKiAgIHggJSAyID09PSAxID8gUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKSA6IFJ4Lk9ic2VydmFibGUuZW1wdHkoKVxuICAgICAqICk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZyB0byB0aGUgY29uc29sZTpcbiAgICAgKiAvLyB4IGlzIGVxdWFsIHRvIHRoZSBjb3VudCBvbiB0aGUgaW50ZXJ2YWwgZWcoMCwxLDIsMywuLi4pXG4gICAgICogLy8geCB3aWxsIG9jY3VyIGV2ZXJ5IDEwMDBtc1xuICAgICAqIC8vIGlmIHggJSAyIGlzIGVxdWFsIHRvIDEgcHJpbnQgYWJjXG4gICAgICogLy8gaWYgeCAlIDIgaXMgbm90IGVxdWFsIHRvIDEgbm90aGluZyB3aWxsIGJlIG91dHB1dFxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIG5ldmVyfVxuICAgICAqIEBzZWUge0BsaW5rIG9mfVxuICAgICAqIEBzZWUge0BsaW5rIHRocm93fVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEEge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbiBvZiB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIFwiZW1wdHlcIiBPYnNlcnZhYmxlOiBlbWl0cyBvbmx5IHRoZSBjb21wbGV0ZVxuICAgICAqIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBlbXB0eVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRW1wdHlPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIEVtcHR5T2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlcjtcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRW1wdHlPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEVtcHR5T2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwgeyBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRW1wdHlPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5FbXB0eU9ic2VydmFibGUgPSBFbXB0eU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbXB0eU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEVycm9yT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVycm9yT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFcnJvck9ic2VydmFibGUoZXJyb3IsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbm8gaXRlbXMgdG8gdGhlIE9ic2VydmVyIGFuZCBpbW1lZGlhdGVseVxuICAgICAqIGVtaXRzIGFuIGVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5KdXN0IGVtaXRzICdlcnJvcicsIGFuZCBub3RoaW5nIGVsc2UuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy90aHJvdy5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgZXJyb3Igbm90aWZpY2F0aW9uLiBJdCBjYW4gYmUgdXNlZCBmb3IgY29tcG9zaW5nIHdpdGggb3RoZXJcbiAgICAgKiBPYnNlcnZhYmxlcywgc3VjaCBhcyBpbiBhIHtAbGluayBtZXJnZU1hcH0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBudW1iZXIgNywgdGhlbiBlbWl0IGFuIGVycm9yLjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS50aHJvdyhuZXcgRXJyb3IoJ29vcHMhJykpLnN0YXJ0V2l0aCg3KTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGUgPT4gY29uc29sZS5lcnJvcihlKSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgYW5kIGZsYXR0ZW4gbnVtYmVycyB0byB0aGUgc2VxdWVuY2UgJ2EnLCAnYicsICdjJywgYnV0IHRocm93IGFuIGVycm9yIGZvciAxMzwvY2FwdGlvbj5cbiAgICAgKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgICAqIHZhciByZXN1bHQgPSBpbnRlcnZhbC5tZXJnZU1hcCh4ID0+XG4gICAgICogICB4ID09PSAxMyA/XG4gICAgICogICAgIFJ4Lk9ic2VydmFibGUudGhyb3coJ1RoaXJ0ZWVucyBhcmUgYmFkJykgOlxuICAgICAqICAgICBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpXG4gICAgICogKTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGUgPT4gY29uc29sZS5lcnJvcihlKSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGV9XG4gICAgICogQHNlZSB7QGxpbmsgZW1wdHl9XG4gICAgICogQHNlZSB7QGxpbmsgbmV2ZXJ9XG4gICAgICogQHNlZSB7QGxpbmsgb2Z9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gZXJyb3IgVGhlIHBhcnRpY3VsYXIgRXJyb3IgdG8gcGFzcyB0byB0aGUgZXJyb3Igbm90aWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZW1pc3Npb24gb2YgdGhlIGVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBlcnJvciBPYnNlcnZhYmxlOiBlbWl0cyBvbmx5IHRoZSBlcnJvciBub3RpZmljYXRpb25cbiAgICAgKiB1c2luZyB0aGUgZ2l2ZW4gZXJyb3IgYXJndW1lbnQuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgdGhyb3dcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEVycm9yT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoZXJyb3IsIHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yT2JzZXJ2YWJsZShlcnJvciwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIEVycm9yT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIGVycm9yID0gYXJnLmVycm9yLCBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXI7XG4gICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgRXJyb3JPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy5lcnJvcjtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEVycm9yT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEVycm9yT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRXJyb3JPYnNlcnZhYmxlID0gRXJyb3JPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXJyb3JPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBTY2FsYXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2NhbGFyT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY2FsYXJPYnNlcnZhYmxlKHZhbHVlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgdGhpcy5faXNTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBTY2FsYXJPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NhbGFyT2JzZXJ2YWJsZSh2YWx1ZSwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFNjYWxhck9ic2VydmFibGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGRvbmUgPSBzdGF0ZS5kb25lLCB2YWx1ZSA9IHN0YXRlLnZhbHVlLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBTY2FsYXJPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKFNjYWxhck9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBkb25lOiBmYWxzZSwgdmFsdWU6IHZhbHVlLCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2NhbGFyT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuU2NhbGFyT2JzZXJ2YWJsZSA9IFNjYWxhck9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY2FsYXJPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIERlZmVyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9EZWZlck9ic2VydmFibGUnKTtcbmV4cG9ydHMuZGVmZXIgPSBEZWZlck9ic2VydmFibGVfMS5EZWZlck9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi8uLi91dGlsL3Jvb3QnKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi8uLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uLy4uL1N1YnNjcmliZXInKTtcbnZhciBtYXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21hcCcpO1xuZnVuY3Rpb24gZ2V0Q09SU1JlcXVlc3QoKSB7XG4gICAgaWYgKHJvb3RfMS5yb290LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgcm9vdF8xLnJvb3QuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoISFyb290XzEucm9vdC5YRG9tYWluUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IHJvb3RfMS5yb290LlhEb21haW5SZXF1ZXN0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NPUlMgaXMgbm90IHN1cHBvcnRlZCBieSB5b3VyIGJyb3dzZXInKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRYTUxIdHRwUmVxdWVzdCgpIHtcbiAgICBpZiAocm9vdF8xLnJvb3QuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByb290XzEucm9vdC5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHByb2dJZCA9IHZvaWQgMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBwcm9nSWRzID0gWydNc3htbDIuWE1MSFRUUCcsICdNaWNyb3NvZnQuWE1MSFRUUCcsICdNc3htbDIuWE1MSFRUUC40LjAnXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ0lkID0gcHJvZ0lkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ldyByb290XzEucm9vdC5BY3RpdmVYT2JqZWN0KHByb2dJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyByb290XzEucm9vdC5BY3RpdmVYT2JqZWN0KHByb2dJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE1MSHR0cFJlcXVlc3QgaXMgbm90IHN1cHBvcnRlZCBieSB5b3VyIGJyb3dzZXInKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFqYXhHZXQodXJsLCBoZWFkZXJzKSB7XG4gICAgaWYgKGhlYWRlcnMgPT09IHZvaWQgMCkgeyBoZWFkZXJzID0gbnVsbDsgfVxuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdHRVQnLCB1cmw6IHVybCwgaGVhZGVyczogaGVhZGVycyB9KTtcbn1cbmV4cG9ydHMuYWpheEdldCA9IGFqYXhHZXQ7XG47XG5mdW5jdGlvbiBhamF4UG9zdCh1cmwsIGJvZHksIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEFqYXhPYnNlcnZhYmxlKHsgbWV0aG9kOiAnUE9TVCcsIHVybDogdXJsLCBib2R5OiBib2R5LCBoZWFkZXJzOiBoZWFkZXJzIH0pO1xufVxuZXhwb3J0cy5hamF4UG9zdCA9IGFqYXhQb3N0O1xuO1xuZnVuY3Rpb24gYWpheERlbGV0ZSh1cmwsIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEFqYXhPYnNlcnZhYmxlKHsgbWV0aG9kOiAnREVMRVRFJywgdXJsOiB1cmwsIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG59XG5leHBvcnRzLmFqYXhEZWxldGUgPSBhamF4RGVsZXRlO1xuO1xuZnVuY3Rpb24gYWpheFB1dCh1cmwsIGJvZHksIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEFqYXhPYnNlcnZhYmxlKHsgbWV0aG9kOiAnUFVUJywgdXJsOiB1cmwsIGJvZHk6IGJvZHksIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG59XG5leHBvcnRzLmFqYXhQdXQgPSBhamF4UHV0O1xuO1xuZnVuY3Rpb24gYWpheFBhdGNoKHVybCwgYm9keSwgaGVhZGVycykge1xuICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUoeyBtZXRob2Q6ICdQQVRDSCcsIHVybDogdXJsLCBib2R5OiBib2R5LCBoZWFkZXJzOiBoZWFkZXJzIH0pO1xufVxuZXhwb3J0cy5hamF4UGF0Y2ggPSBhamF4UGF0Y2g7XG47XG5mdW5jdGlvbiBhamF4R2V0SlNPTih1cmwsIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEFqYXhPYnNlcnZhYmxlKHsgbWV0aG9kOiAnR0VUJywgdXJsOiB1cmwsIHJlc3BvbnNlVHlwZTogJ2pzb24nLCBoZWFkZXJzOiBoZWFkZXJzIH0pXG4gICAgICAgIC5saWZ0KG5ldyBtYXBfMS5NYXBPcGVyYXRvcihmdW5jdGlvbiAoeCwgaW5kZXgpIHsgcmV0dXJuIHgucmVzcG9uc2U7IH0sIG51bGwpKTtcbn1cbmV4cG9ydHMuYWpheEdldEpTT04gPSBhamF4R2V0SlNPTjtcbjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgQWpheE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBamF4T2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBamF4T2JzZXJ2YWJsZSh1cmxPclJlcXVlc3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICBjcmVhdGVYSFI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcm9zc0RvbWFpbiA/IGdldENPUlNSZXF1ZXN0LmNhbGwodGhpcykgOiBnZXRYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNyb3NzRG9tYWluOiBmYWxzZSxcbiAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogZmFsc2UsXG4gICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICByZXNwb25zZVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIHRpbWVvdXQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmxPclJlcXVlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXF1ZXN0LnVybCA9IHVybE9yUmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdXJsT3JSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHVybE9yUmVxdWVzdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0W3Byb3BdID0gdXJsT3JSZXF1ZXN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIH1cbiAgICBBamF4T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWpheFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5yZXF1ZXN0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JzZXJ2YWJsZSBmb3IgYW4gQWpheCByZXF1ZXN0IHdpdGggZWl0aGVyIGEgcmVxdWVzdCBvYmplY3Qgd2l0aFxuICAgICAqIHVybCwgaGVhZGVycywgZXRjIG9yIGEgc3RyaW5nIGZvciBhIFVSTC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc291cmNlID0gUnguT2JzZXJ2YWJsZS5hamF4KCcvcHJvZHVjdHMnKTtcbiAgICAgKiBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlLmFqYXgoeyB1cmw6ICdwcm9kdWN0cycsIG1ldGhvZDogJ0dFVCcgfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IHJlcXVlc3QgQ2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgICAqICAgQSBzdHJpbmcgb2YgdGhlIFVSTCB0byBtYWtlIHRoZSBBamF4IGNhbGwuXG4gICAgICogICBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXNcbiAgICAgKiAgIC0gdXJsOiBVUkwgb2YgdGhlIHJlcXVlc3RcbiAgICAgKiAgIC0gYm9keTogVGhlIGJvZHkgb2YgdGhlIHJlcXVlc3RcbiAgICAgKiAgIC0gbWV0aG9kOiBNZXRob2Qgb2YgdGhlIHJlcXVlc3QsIHN1Y2ggYXMgR0VULCBQT1NULCBQVVQsIFBBVENILCBERUxFVEVcbiAgICAgKiAgIC0gYXN5bmM6IFdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgYXN5bmNcbiAgICAgKiAgIC0gaGVhZGVyczogT3B0aW9uYWwgaGVhZGVyc1xuICAgICAqICAgLSBjcm9zc0RvbWFpbjogdHJ1ZSBpZiBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0LCBlbHNlIGZhbHNlXG4gICAgICogICAtIGNyZWF0ZVhIUjogYSBmdW5jdGlvbiB0byBvdmVycmlkZSBpZiB5b3UgbmVlZCB0byB1c2UgYW4gYWx0ZXJuYXRlXG4gICAgICogICBYTUxIdHRwUmVxdWVzdCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiAgIC0gcmVzdWx0U2VsZWN0b3I6IGEgZnVuY3Rpb24gdG8gdXNlIHRvIGFsdGVyIHRoZSBvdXRwdXQgdmFsdWUgdHlwZSBvZlxuICAgICAqICAgdGhlIE9ic2VydmFibGUuIEdldHMge0BsaW5rIEFqYXhSZXNwb25zZX0gYXMgYW4gYXJndW1lbnQuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBjb250YWluaW5nIHRoZSBYTUxIdHRwUmVxdWVzdC5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBhamF4XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAqL1xuICAgIEFqYXhPYnNlcnZhYmxlLmNyZWF0ZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjcmVhdGUgPSBmdW5jdGlvbiAodXJsT3JSZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFqYXhPYnNlcnZhYmxlKHVybE9yUmVxdWVzdCk7XG4gICAgICAgIH07XG4gICAgICAgIGNyZWF0ZS5nZXQgPSBhamF4R2V0O1xuICAgICAgICBjcmVhdGUucG9zdCA9IGFqYXhQb3N0O1xuICAgICAgICBjcmVhdGUuZGVsZXRlID0gYWpheERlbGV0ZTtcbiAgICAgICAgY3JlYXRlLnB1dCA9IGFqYXhQdXQ7XG4gICAgICAgIGNyZWF0ZS5wYXRjaCA9IGFqYXhQYXRjaDtcbiAgICAgICAgY3JlYXRlLmdldEpTT04gPSBhamF4R2V0SlNPTjtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBBamF4T2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuQWpheE9ic2VydmFibGUgPSBBamF4T2JzZXJ2YWJsZTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQWpheFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBamF4U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBamF4U3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcmVxdWVzdCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB2YXIgaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycyB8fCB7fTtcbiAgICAgICAgLy8gZm9yY2UgQ09SUyBpZiByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKCFyZXF1ZXN0LmNyb3NzRG9tYWluICYmICFoZWFkZXJzWydYLVJlcXVlc3RlZC1XaXRoJ10pIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ1gtUmVxdWVzdGVkLVdpdGgnXSA9ICdYTUxIdHRwUmVxdWVzdCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5zdXJlIGNvbnRlbnQgdHlwZSBpcyBzZXRcbiAgICAgICAgaWYgKCEoJ0NvbnRlbnQtVHlwZScgaW4gaGVhZGVycykgJiYgIShyb290XzEucm9vdC5Gb3JtRGF0YSAmJiByZXF1ZXN0LmJvZHkgaW5zdGFuY2VvZiByb290XzEucm9vdC5Gb3JtRGF0YSkgJiYgdHlwZW9mIHJlcXVlc3QuYm9keSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcHJvcGVybHkgc2VyaWFsaXplIGJvZHlcbiAgICAgICAgcmVxdWVzdC5ib2R5ID0gdGhpcy5zZXJpYWxpemVCb2R5KHJlcXVlc3QuYm9keSwgcmVxdWVzdC5oZWFkZXJzWydDb250ZW50LVR5cGUnXSk7XG4gICAgICAgIHRoaXMuc2VuZCgpO1xuICAgIH1cbiAgICBBamF4U3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHhociA9IF9hLnhociwgcmVxdWVzdCA9IF9hLnJlcXVlc3QsIGRlc3RpbmF0aW9uID0gX2EuZGVzdGluYXRpb247XG4gICAgICAgIHZhciByZXNwb25zZSA9IG5ldyBBamF4UmVzcG9uc2UoZSwgeGhyLCByZXF1ZXN0KTtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXNwb25zZSk7XG4gICAgfTtcbiAgICBBamF4U3Vic2NyaWJlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcmVxdWVzdCA9IF9hLnJlcXVlc3QsIF9iID0gX2EucmVxdWVzdCwgdXNlciA9IF9iLnVzZXIsIG1ldGhvZCA9IF9iLm1ldGhvZCwgdXJsID0gX2IudXJsLCBhc3luYyA9IF9iLmFzeW5jLCBwYXNzd29yZCA9IF9iLnBhc3N3b3JkLCBoZWFkZXJzID0gX2IuaGVhZGVycywgYm9keSA9IF9iLmJvZHk7XG4gICAgICAgIHZhciBjcmVhdGVYSFIgPSByZXF1ZXN0LmNyZWF0ZVhIUjtcbiAgICAgICAgdmFyIHhociA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goY3JlYXRlWEhSKS5jYWxsKHJlcXVlc3QpO1xuICAgICAgICBpZiAoeGhyID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnhociA9IHhocjtcbiAgICAgICAgICAgIC8vIHNldCB1cCB0aGUgZXZlbnRzIGJlZm9yZSBvcGVuIFhIUlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L1VzaW5nX1hNTEh0dHBSZXF1ZXN0XG4gICAgICAgICAgICAvLyBZb3UgbmVlZCB0byBhZGQgdGhlIGV2ZW50IGxpc3RlbmVycyBiZWZvcmUgY2FsbGluZyBvcGVuKCkgb24gdGhlIHJlcXVlc3QuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgdGhlIHByb2dyZXNzIGV2ZW50cyB3aWxsIG5vdCBmaXJlLlxuICAgICAgICAgICAgdGhpcy5zZXR1cEV2ZW50cyh4aHIsIHJlcXVlc3QpO1xuICAgICAgICAgICAgLy8gb3BlbiBYSFJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goeGhyLm9wZW4pLmNhbGwoeGhyLCBtZXRob2QsIHVybCwgYXN5bmMsIHVzZXIsIHBhc3N3b3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goeGhyLm9wZW4pLmNhbGwoeGhyLCBtZXRob2QsIHVybCwgYXN5bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRpbWVvdXQsIHJlc3BvbnNlVHlwZSBhbmQgd2l0aENyZWRlbnRpYWxzIGNhbiBiZSBzZXQgb25jZSB0aGUgWEhSIGlzIG9wZW5cbiAgICAgICAgICAgIHhoci50aW1lb3V0ID0gcmVxdWVzdC50aW1lb3V0O1xuICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHJlcXVlc3QucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIXJlcXVlc3Qud2l0aENyZWRlbnRpYWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2V0IGhlYWRlcnNcbiAgICAgICAgICAgIHRoaXMuc2V0SGVhZGVycyh4aHIsIGhlYWRlcnMpO1xuICAgICAgICAgICAgLy8gZmluYWxseSBzZW5kIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICByZXN1bHQgPSBib2R5ID8gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIuc2VuZCkuY2FsbCh4aHIsIGJvZHkpIDogdHJ5Q2F0Y2hfMS50cnlDYXRjaCh4aHIuc2VuZCkuY2FsbCh4aHIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geGhyO1xuICAgIH07XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLnNlcmlhbGl6ZUJvZHkgPSBmdW5jdGlvbiAoYm9keSwgY29udGVudFR5cGUpIHtcbiAgICAgICAgaWYgKCFib2R5IHx8IHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm9vdF8xLnJvb3QuRm9ybURhdGEgJiYgYm9keSBpbnN0YW5jZW9mIHJvb3RfMS5yb290LkZvcm1EYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBzcGxpdEluZGV4ID0gY29udGVudFR5cGUuaW5kZXhPZignOycpO1xuICAgICAgICAgICAgaWYgKHNwbGl0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSBjb250ZW50VHlwZS5zdWJzdHJpbmcoMCwgc3BsaXRJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYm9keSkubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIChlbmNvZGVVUkkoa2V5KSArIFwiPVwiICsgZW5jb2RlVVJJKGJvZHlba2V5XSkpOyB9KS5qb2luKCcmJyk7XG4gICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbi9qc29uJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBamF4U3Vic2NyaWJlci5wcm90b3R5cGUuc2V0SGVhZGVycyA9IGZ1bmN0aW9uICh4aHIsIGhlYWRlcnMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmIChoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5zZXR1cEV2ZW50cyA9IGZ1bmN0aW9uICh4aHIsIHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIHByb2dyZXNzU3Vic2NyaWJlciA9IHJlcXVlc3QucHJvZ3Jlc3NTdWJzY3JpYmVyO1xuICAgICAgICBmdW5jdGlvbiB4aHJUaW1lb3V0KGUpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHhoclRpbWVvdXQsIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyLCBwcm9ncmVzc1N1YnNjcmliZXIgPSBfYS5wcm9ncmVzc1N1YnNjcmliZXIsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0O1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgIHByb2dyZXNzU3Vic2NyaWJlci5lcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IobmV3IEFqYXhUaW1lb3V0RXJyb3IodGhpcywgcmVxdWVzdCkpOyAvL1RPRE86IE1ha2UgYmV0dGVyZXIuXG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICB4aHIub250aW1lb3V0ID0geGhyVGltZW91dDtcbiAgICAgICAgeGhyVGltZW91dC5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgeGhyVGltZW91dC5zdWJzY3JpYmVyID0gdGhpcztcbiAgICAgICAgeGhyVGltZW91dC5wcm9ncmVzc1N1YnNjcmliZXIgPSBwcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgIGlmICh4aHIudXBsb2FkICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgICAgICAgaWYgKHByb2dyZXNzU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgIHZhciB4aHJQcm9ncmVzc18xO1xuICAgICAgICAgICAgICAgIHhoclByb2dyZXNzXzEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3NTdWJzY3JpYmVyID0geGhyUHJvZ3Jlc3NfMS5wcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzU3Vic2NyaWJlci5uZXh0KGUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHJvb3RfMS5yb290LlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5vbnByb2dyZXNzID0geGhyUHJvZ3Jlc3NfMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IHhoclByb2dyZXNzXzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHhoclByb2dyZXNzXzEucHJvZ3Jlc3NTdWJzY3JpYmVyID0gcHJvZ3Jlc3NTdWJzY3JpYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHhockVycm9yXzE7XG4gICAgICAgICAgICB4aHJFcnJvcl8xID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSB4aHJFcnJvcl8xLCBwcm9ncmVzc1N1YnNjcmliZXIgPSBfYS5wcm9ncmVzc1N1YnNjcmliZXIsIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyLCByZXF1ZXN0ID0gX2EucmVxdWVzdDtcbiAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzU3Vic2NyaWJlci5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihuZXcgQWpheEVycm9yKCdhamF4IGVycm9yJywgdGhpcywgcmVxdWVzdCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5vbmVycm9yID0geGhyRXJyb3JfMTtcbiAgICAgICAgICAgIHhockVycm9yXzEucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICB4aHJFcnJvcl8xLnN1YnNjcmliZXIgPSB0aGlzO1xuICAgICAgICAgICAgeGhyRXJyb3JfMS5wcm9ncmVzc1N1YnNjcmliZXIgPSBwcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24geGhyUmVhZHlTdGF0ZUNoYW5nZShlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB4aHJSZWFkeVN0YXRlQ2hhbmdlLCBzdWJzY3JpYmVyID0gX2Euc3Vic2NyaWJlciwgcHJvZ3Jlc3NTdWJzY3JpYmVyID0gX2EucHJvZ3Jlc3NTdWJzY3JpYmVyLCByZXF1ZXN0ID0gX2EucmVxdWVzdDtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgSUU5IGJ1ZyAoaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MClcbiAgICAgICAgICAgICAgICB2YXIgc3RhdHVzXzEgPSB0aGlzLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHRoaXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIHZhciByZXNwb25zZSA9ICh0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gKHRoaXMucmVzcG9uc2UgfHwgdGhpcy5yZXNwb25zZVRleHQpIDogdGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgLy8gZml4IHN0YXR1cyBjb2RlIHdoZW4gaXQgaXMgMCAoMCBzdGF0dXMgaXMgdW5kb2N1bWVudGVkKS5cbiAgICAgICAgICAgICAgICAvLyBPY2N1cnMgd2hlbiBhY2Nlc3NpbmcgZmlsZSByZXNvdXJjZXMgb3Igb24gQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vIHdoaWxlIHJldHJpZXZpbmcgZmlsZXMgZnJvbSBhcHBsaWNhdGlvbiBjYWNoZS5cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzXzEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzXzEgPSByZXNwb25zZSA/IDIwMCA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgyMDAgPD0gc3RhdHVzXzEgJiYgc3RhdHVzXzEgPCAzMDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGUpO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc1N1YnNjcmliZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihuZXcgQWpheEVycm9yKCdhamF4IGVycm9yICcgKyBzdGF0dXNfMSwgdGhpcywgcmVxdWVzdCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB4aHJSZWFkeVN0YXRlQ2hhbmdlO1xuICAgICAgICB4aHJSZWFkeVN0YXRlQ2hhbmdlLnN1YnNjcmliZXIgPSB0aGlzO1xuICAgICAgICB4aHJSZWFkeVN0YXRlQ2hhbmdlLnByb2dyZXNzU3Vic2NyaWJlciA9IHByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgeGhyUmVhZHlTdGF0ZUNoYW5nZS5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICB9O1xuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZG9uZSA9IF9hLmRvbmUsIHhociA9IF9hLnhocjtcbiAgICAgICAgaWYgKCFkb25lICYmIHhociAmJiB4aHIucmVhZHlTdGF0ZSAhPT0gNCAmJiB0eXBlb2YgeGhyLmFib3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQWpheFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLkFqYXhTdWJzY3JpYmVyID0gQWpheFN1YnNjcmliZXI7XG4vKipcbiAqIEEgbm9ybWFsaXplZCBBSkFYIHJlc3BvbnNlLlxuICpcbiAqIEBzZWUge0BsaW5rIGFqYXh9XG4gKlxuICogQGNsYXNzIEFqYXhSZXNwb25zZVxuICovXG52YXIgQWpheFJlc3BvbnNlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBamF4UmVzcG9uc2Uob3JpZ2luYWxFdmVudCwgeGhyLCByZXF1ZXN0KSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIHRoaXMueGhyID0geGhyO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0geGhyLnJlc3BvbnNlVHlwZSB8fCByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICAgICAgaWYgKCdyZXNwb25zZScgaW4geGhyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vSUUgZG9lcyBub3Qgc3VwcG9ydCBqc29uIGFzIHJlc3BvbnNlVHlwZSwgcGFyc2UgaXQgaW50ZXJuYWxseVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0geGhyLnJlc3BvbnNlVHlwZSA/IHhoci5yZXNwb25zZSA6IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlIHx8IHhoci5yZXNwb25zZVRleHQgfHwgJ251bGwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQgfHwgJ251bGwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd4bWwnOlxuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSB4aHIucmVzcG9uc2VYTUw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9ICgncmVzcG9uc2UnIGluIHhocikgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBBamF4UmVzcG9uc2U7XG59KCkpO1xuZXhwb3J0cy5BamF4UmVzcG9uc2UgPSBBamF4UmVzcG9uc2U7XG4vKipcbiAqIEEgbm9ybWFsaXplZCBBSkFYIGVycm9yLlxuICpcbiAqIEBzZWUge0BsaW5rIGFqYXh9XG4gKlxuICogQGNsYXNzIEFqYXhFcnJvclxuICovXG52YXIgQWpheEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWpheEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFqYXhFcnJvcihtZXNzYWdlLCB4aHIsIHJlcXVlc3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMueGhyID0geGhyO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgfVxuICAgIHJldHVybiBBamF4RXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkFqYXhFcnJvciA9IEFqYXhFcnJvcjtcbi8qKlxuICogQHNlZSB7QGxpbmsgYWpheH1cbiAqXG4gKiBAY2xhc3MgQWpheFRpbWVvdXRFcnJvclxuICovXG52YXIgQWpheFRpbWVvdXRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFqYXhUaW1lb3V0RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWpheFRpbWVvdXRFcnJvcih4aHIsIHJlcXVlc3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgJ2FqYXggdGltZW91dCcsIHhociwgcmVxdWVzdCk7XG4gICAgfVxuICAgIHJldHVybiBBamF4VGltZW91dEVycm9yO1xufShBamF4RXJyb3IpKTtcbmV4cG9ydHMuQWpheFRpbWVvdXRFcnJvciA9IEFqYXhUaW1lb3V0RXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BamF4T2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBBamF4T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9BamF4T2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5hamF4ID0gQWpheE9ic2VydmFibGVfMS5BamF4T2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hamF4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9FbXB0eU9ic2VydmFibGUnKTtcbmV4cG9ydHMuZW1wdHkgPSBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW1wdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgbWVyZ2VfMSA9IHJlcXVpcmUoJy4uL29wZXJhdG9yL21lcmdlJyk7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2VfMS5tZXJnZVN0YXRpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9BcnJheU9ic2VydmFibGUnKTtcbmV4cG9ydHMub2YgPSBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUub2Y7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBFcnJvck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRXJyb3JPYnNlcnZhYmxlJyk7XG5leHBvcnRzLl90aHJvdyA9IEVycm9yT2JzZXJ2YWJsZV8xLkVycm9yT2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQ2F0Y2hlcyBlcnJvcnMgb24gdGhlIG9ic2VydmFibGUgdG8gYmUgaGFuZGxlZCBieSByZXR1cm5pbmcgYSBuZXcgb2JzZXJ2YWJsZSBvciB0aHJvd2luZyBhbiBlcnJvci5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2NhdGNoLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbnRpbnVlcyB3aXRoIGEgZGlmZmVyZW50IE9ic2VydmFibGUgd2hlbiB0aGVyZSdzIGFuIGVycm9yPC9jYXB0aW9uPlxuICpcbiAqIE9ic2VydmFibGUub2YoMSwgMiwgMywgNCwgNSlcbiAqICAgLm1hcChuID0+IHtcbiAqIFx0ICAgaWYgKG4gPT0gNCkge1xuICogXHQgICAgIHRocm93ICdmb3VyISc7XG4gKiAgICAgfVxuICpcdCAgIHJldHVybiBuO1xuICogICB9KVxuICogICAuY2F0Y2goZXJyID0+IE9ic2VydmFibGUub2YoJ0knLCAnSUknLCAnSUlJJywgJ0lWJywgJ1YnKSlcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqICAgLy8gMSwgMiwgMywgSSwgSUksIElJSSwgSVYsIFZcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZXRyaWVzIHRoZSBjYXVnaHQgc291cmNlIE9ic2VydmFibGUgYWdhaW4gaW4gY2FzZSBvZiBlcnJvciwgc2ltaWxhciB0byByZXRyeSgpIG9wZXJhdG9yPC9jYXB0aW9uPlxuICpcbiAqIE9ic2VydmFibGUub2YoMSwgMiwgMywgNCwgNSlcbiAqICAgLm1hcChuID0+IHtcbiAqIFx0ICAgaWYgKG4gPT09IDQpIHtcbiAqIFx0ICAgICB0aHJvdyAnZm91ciEnO1xuICogICAgIH1cbiAqIFx0ICAgcmV0dXJuIG47XG4gKiAgIH0pXG4gKiAgIC5jYXRjaCgoZXJyLCBjYXVnaHQpID0+IGNhdWdodClcbiAqICAgLnRha2UoMzApXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiAgIC8vIDEsIDIsIDMsIDEsIDIsIDMsIC4uLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRocm93cyBhIG5ldyBlcnJvciB3aGVuIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aHJvd3MgYW4gZXJyb3I8L2NhcHRpb24+XG4gKlxuICogT2JzZXJ2YWJsZS5vZigxLCAyLCAzLCA0LCA1KVxuICogICAubWFwKG4gPT4ge1xuICogICAgIGlmIChuID09IDQpIHtcbiAqICAgICAgIHRocm93ICdmb3VyISc7XG4gKiAgICAgfVxuICogICAgIHJldHVybiBuO1xuICogICB9KVxuICogICAuY2F0Y2goZXJyID0+IHtcbiAqICAgICB0aHJvdyAnZXJyb3IgaW4gc291cmNlLiBEZXRhaWxzOiAnICsgZXJyO1xuICogICB9KVxuICogICAuc3Vic2NyaWJlKFxuICogICAgIHggPT4gY29uc29sZS5sb2coeCksXG4gKiAgICAgZXJyID0+IGNvbnNvbGUubG9nKGVycilcbiAqICAgKTtcbiAqICAgLy8gMSwgMiwgMywgZXJyb3IgaW4gc291cmNlLiBEZXRhaWxzOiBmb3VyIVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHNlbGVjdG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhcyBhcmd1bWVudHMgYGVycmAsIHdoaWNoIGlzIHRoZSBlcnJvciwgYW5kIGBjYXVnaHRgLCB3aGljaFxuICogIGlzIHRoZSBzb3VyY2Ugb2JzZXJ2YWJsZSwgaW4gY2FzZSB5b3UnZCBsaWtlIHRvIFwicmV0cnlcIiB0aGF0IG9ic2VydmFibGUgYnkgcmV0dXJuaW5nIGl0IGFnYWluLiBXaGF0ZXZlciBvYnNlcnZhYmxlXG4gKiAgaXMgcmV0dXJuZWQgYnkgdGhlIGBzZWxlY3RvcmAgd2lsbCBiZSB1c2VkIHRvIGNvbnRpbnVlIHRoZSBvYnNlcnZhYmxlIGNoYWluLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSB0aGF0IG9yaWdpbmF0ZXMgZnJvbSBlaXRoZXIgdGhlIHNvdXJjZSBvciB0aGUgb2JzZXJ2YWJsZSByZXR1cm5lZCBieSB0aGVcbiAqICBjYXRjaCBgc2VsZWN0b3JgIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBjYXRjaFxuICogQG5hbWUgY2F0Y2hcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9jYXRjaChzZWxlY3Rvcikge1xuICAgIHZhciBvcGVyYXRvciA9IG5ldyBDYXRjaE9wZXJhdG9yKHNlbGVjdG9yKTtcbiAgICB2YXIgY2F1Z2h0ID0gdGhpcy5saWZ0KG9wZXJhdG9yKTtcbiAgICByZXR1cm4gKG9wZXJhdG9yLmNhdWdodCA9IGNhdWdodCk7XG59XG5leHBvcnRzLl9jYXRjaCA9IF9jYXRjaDtcbnZhciBDYXRjaE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXRjaE9wZXJhdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB9XG4gICAgQ2F0Y2hPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IENhdGNoU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnNlbGVjdG9yLCB0aGlzLmNhdWdodCkpO1xuICAgIH07XG4gICAgcmV0dXJuIENhdGNoT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBDYXRjaFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYXRjaFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2F0Y2hTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBzZWxlY3RvciwgY2F1Z2h0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNhdWdodCA9IGNhdWdodDtcbiAgICB9XG4gICAgLy8gTk9URTogb3ZlcnJpZGluZyBgZXJyb3JgIGluc3RlYWQgb2YgYF9lcnJvcmAgYmVjYXVzZSB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaGF2ZSB0aGlzIGZsYWcgdGhpcyBzdWJzY3JpYmVyIGFzIGBpc1N0b3BwZWRgLiBXZSBjYW4gbWltaWMgdGhlXG4gICAgLy8gYmVoYXZpb3Igb2YgdGhlIFJldHJ5U3Vic2NyaWJlciAoZnJvbSB0aGUgYHJldHJ5YCBvcGVyYXRvciksIHdoZXJlXG4gICAgLy8gd2UgdW5zdWJzY3JpYmUgZnJvbSBvdXIgc291cmNlIGNoYWluLCByZXNldCBvdXIgU3Vic2NyaWJlciBmbGFncyxcbiAgICAvLyB0aGVuIHN1YnNjcmliZSB0byB0aGUgc2VsZWN0b3IgcmVzdWx0LlxuICAgIENhdGNoU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuc2VsZWN0b3IoZXJyLCB0aGlzLmNhdWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyMikge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlcnIyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDYXRjaFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2F0Y2guanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlQWxsXzEgPSByZXF1aXJlKCcuL21lcmdlQWxsJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDcmVhdGVzIGFuIG91dHB1dCBPYnNlcnZhYmxlIHdoaWNoIHNlcXVlbnRpYWxseSBlbWl0cyBhbGwgdmFsdWVzIGZyb20gZXZlcnlcbiAqIGdpdmVuIGlucHV0IE9ic2VydmFibGUgYWZ0ZXIgdGhlIGN1cnJlbnQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29uY2F0ZW5hdGVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5XG4gKiBzZXF1ZW50aWFsbHkgZW1pdHRpbmcgdGhlaXIgdmFsdWVzLCBvbmUgT2JzZXJ2YWJsZSBhZnRlciB0aGUgb3RoZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEpvaW5zIHRoaXMgT2JzZXJ2YWJsZSB3aXRoIG11bHRpcGxlIG90aGVyIE9ic2VydmFibGVzIGJ5IHN1YnNjcmliaW5nIHRvIHRoZW1cbiAqIG9uZSBhdCBhIHRpbWUsIHN0YXJ0aW5nIHdpdGggdGhlIHNvdXJjZSwgYW5kIG1lcmdpbmcgdGhlaXIgcmVzdWx0cyBpbnRvIHRoZVxuICogb3V0cHV0IE9ic2VydmFibGUuIFdpbGwgd2FpdCBmb3IgZWFjaCBPYnNlcnZhYmxlIHRvIGNvbXBsZXRlIGJlZm9yZSBtb3ZpbmdcbiAqIG9uIHRvIHRoZSBuZXh0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIGEgdGltZXIgY291bnRpbmcgZnJvbSAwIHRvIDMgd2l0aCBhIHN5bmNocm9ub3VzIHNlcXVlbmNlIGZyb20gMSB0byAxMDwvY2FwdGlvbj5cbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KTtcbiAqIHZhciBzZXF1ZW5jZSA9IFJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgMTApO1xuICogdmFyIHJlc3VsdCA9IHRpbWVyLmNvbmNhdChzZXF1ZW5jZSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIHJlc3VsdHMgaW46XG4gKiAvLyAxMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAyIC0xMDAwbXMtPiAzIC1pbW1lZGlhdGUtPiAxIC4uLiAxMFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIDMgT2JzZXJ2YWJsZXM8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIHJlc3VsdCA9IHRpbWVyMS5jb25jYXQodGltZXIyLCB0aW1lcjMpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyByZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAoUHJpbnRzIHRvIGNvbnNvbGUgc2VxdWVudGlhbGx5KVxuICogLy8gLTEwMDBtcy0+IDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IC4uLiA5XG4gKiAvLyAtMjAwMG1zLT4gMCAtMjAwMG1zLT4gMSAtMjAwMG1zLT4gLi4uIDVcbiAqIC8vIC01MDBtcy0+IDAgLTUwMG1zLT4gMSAtNTAwbXMtPiAuLi4gOVxuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIGFmdGVyIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gQW4gb3B0aW9uYWwgSVNjaGVkdWxlciB0byBzY2hlZHVsZSBlYWNoXG4gKiBPYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFsbCB2YWx1ZXMgb2YgZWFjaCBwYXNzZWQgT2JzZXJ2YWJsZSBtZXJnZWQgaW50byBhXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgaW4gb3JkZXIsIGluIHNlcmlhbCBmYXNoaW9uLlxuICogQG1ldGhvZCBjb25jYXRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKGNvbmNhdFN0YXRpYy5hcHBseSh2b2lkIDAsIFt0aGlzXS5jb25jYXQob2JzZXJ2YWJsZXMpKSk7XG59XG5leHBvcnRzLmNvbmNhdCA9IGNvbmNhdDtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENyZWF0ZXMgYW4gb3V0cHV0IE9ic2VydmFibGUgd2hpY2ggc2VxdWVudGlhbGx5IGVtaXRzIGFsbCB2YWx1ZXMgZnJvbSBnaXZlblxuICogT2JzZXJ2YWJsZSBhbmQgdGhlbiBtb3ZlcyBvbiB0byB0aGUgbmV4dC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29uY2F0ZW5hdGVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5XG4gKiBzZXF1ZW50aWFsbHkgZW1pdHRpbmcgdGhlaXIgdmFsdWVzLCBvbmUgT2JzZXJ2YWJsZSBhZnRlciB0aGUgb3RoZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBjb25jYXRgIGpvaW5zIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyLCBieSBzdWJzY3JpYmluZyB0byB0aGVtIG9uZSBhdCBhIHRpbWUgYW5kXG4gKiBtZXJnaW5nIHRoZWlyIHJlc3VsdHMgaW50byB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFlvdSBjYW4gcGFzcyBlaXRoZXIgYW4gYXJyYXkgb2ZcbiAqIE9ic2VydmFibGVzLCBvciBwdXQgdGhlbSBkaXJlY3RseSBhcyBhcmd1bWVudHMuIFBhc3NpbmcgYW4gZW1wdHkgYXJyYXkgd2lsbCByZXN1bHRcbiAqIGluIE9ic2VydmFibGUgdGhhdCBjb21wbGV0ZXMgaW1tZWRpYXRlbHkuXG4gKlxuICogYGNvbmNhdGAgd2lsbCBzdWJzY3JpYmUgdG8gZmlyc3QgaW5wdXQgT2JzZXJ2YWJsZSBhbmQgZW1pdCBhbGwgaXRzIHZhbHVlcywgd2l0aG91dFxuICogY2hhbmdpbmcgb3IgYWZmZWN0aW5nIHRoZW0gaW4gYW55IHdheS4gV2hlbiB0aGF0IE9ic2VydmFibGUgY29tcGxldGVzLCBpdCB3aWxsXG4gKiBzdWJzY3JpYmUgdG8gdGhlbiBuZXh0IE9ic2VydmFibGUgcGFzc2VkIGFuZCwgYWdhaW4sIGVtaXQgaXRzIHZhbHVlcy4gVGhpcyB3aWxsIGJlXG4gKiByZXBlYXRlZCwgdW50aWwgdGhlIG9wZXJhdG9yIHJ1bnMgb3V0IG9mIE9ic2VydmFibGVzLiBXaGVuIGxhc3QgaW5wdXQgT2JzZXJ2YWJsZSBjb21wbGV0ZXMsXG4gKiBgY29uY2F0YCB3aWxsIGNvbXBsZXRlIGFzIHdlbGwuIEF0IGFueSBnaXZlbiBtb21lbnQgb25seSBvbmUgT2JzZXJ2YWJsZSBwYXNzZWQgdG8gb3BlcmF0b3JcbiAqIGVtaXRzIHZhbHVlcy4gSWYgeW91IHdvdWxkIGxpa2UgdG8gZW1pdCB2YWx1ZXMgZnJvbSBwYXNzZWQgT2JzZXJ2YWJsZXMgY29uY3VycmVudGx5LCBjaGVjayBvdXRcbiAqIHtAbGluayBtZXJnZX0gaW5zdGVhZCwgZXNwZWNpYWxseSB3aXRoIG9wdGlvbmFsIGBjb25jdXJyZW50YCBwYXJhbWV0ZXIuIEFzIGEgbWF0dGVyIG9mIGZhY3QsXG4gKiBgY29uY2F0YCBpcyBhbiBlcXVpdmFsZW50IG9mIGBtZXJnZWAgb3BlcmF0b3Igd2l0aCBgY29uY3VycmVudGAgcGFyYW1ldGVyIHNldCB0byBgMWAuXG4gKlxuICogTm90ZSB0aGF0IGlmIHNvbWUgaW5wdXQgT2JzZXJ2YWJsZSBuZXZlciBjb21wbGV0ZXMsIGBjb25jYXRgIHdpbGwgYWxzbyBuZXZlciBjb21wbGV0ZVxuICogYW5kIE9ic2VydmFibGVzIGZvbGxvd2luZyB0aGUgb25lIHRoYXQgZGlkIG5vdCBjb21wbGV0ZSB3aWxsIG5ldmVyIGJlIHN1YnNjcmliZWQuIE9uIHRoZSBvdGhlclxuICogaGFuZCwgaWYgc29tZSBPYnNlcnZhYmxlIHNpbXBseSBjb21wbGV0ZXMgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgc3Vic2NyaWJlZCwgaXQgd2lsbCBiZVxuICogaW52aXNpYmxlIGZvciBgY29uY2F0YCwgd2hpY2ggd2lsbCBqdXN0IG1vdmUgb24gdG8gdGhlIG5leHQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBJZiBhbnkgT2JzZXJ2YWJsZSBpbiBjaGFpbiBlcnJvcnMsIGluc3RlYWQgb2YgcGFzc2luZyBjb250cm9sIHRvIHRoZSBuZXh0IE9ic2VydmFibGUsXG4gKiBgY29uY2F0YCB3aWxsIGVycm9yIGltbWVkaWF0ZWx5IGFzIHdlbGwuIE9ic2VydmFibGVzIHRoYXQgd291bGQgYmUgc3Vic2NyaWJlZCBhZnRlclxuICogdGhlIG9uZSB0aGF0IGVtaXR0ZWQgZXJyb3IsIG5ldmVyIHdpbGwuXG4gKlxuICogSWYgeW91IHBhc3MgdG8gYGNvbmNhdGAgdGhlIHNhbWUgT2JzZXJ2YWJsZSBtYW55IHRpbWVzLCBpdHMgc3RyZWFtIG9mIHZhbHVlc1xuICogd2lsbCBiZSBcInJlcGxheWVkXCIgb24gZXZlcnkgc3Vic2NyaXB0aW9uLCB3aGljaCBtZWFucyB5b3UgY2FuIHJlcGVhdCBnaXZlbiBPYnNlcnZhYmxlXG4gKiBhcyBtYW55IHRpbWVzIGFzIHlvdSBsaWtlLiBJZiBwYXNzaW5nIHRoZSBzYW1lIE9ic2VydmFibGUgdG8gYGNvbmNhdGAgMTAwMCB0aW1lcyBiZWNvbWVzIHRlZGlvdXMsXG4gKiB5b3UgY2FuIGFsd2F5cyB1c2Uge0BsaW5rIHJlcGVhdH0uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgYSB0aW1lciBjb3VudGluZyBmcm9tIDAgdG8gMyB3aXRoIGEgc3luY2hyb25vdXMgc2VxdWVuY2UgZnJvbSAxIHRvIDEwPC9jYXB0aW9uPlxuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpO1xuICogdmFyIHNlcXVlbmNlID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMCk7XG4gKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5jb25jYXQodGltZXIsIHNlcXVlbmNlKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gcmVzdWx0cyBpbjpcbiAqIC8vIDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IDIgLTEwMDBtcy0+IDMgLWltbWVkaWF0ZS0+IDEgLi4uIDEwXG4gKlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIGFuIGFycmF5IG9mIDMgT2JzZXJ2YWJsZXM8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuY29uY2F0KFt0aW1lcjEsIHRpbWVyMiwgdGltZXIzXSk7IC8vIG5vdGUgdGhhdCBhcnJheSBpcyBwYXNzZWRcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gcmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gKFByaW50cyB0byBjb25zb2xlIHNlcXVlbnRpYWxseSlcbiAqIC8vIC0xMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAuLi4gOVxuICogLy8gLTIwMDBtcy0+IDAgLTIwMDBtcy0+IDEgLTIwMDBtcy0+IC4uLiA1XG4gKiAvLyAtNTAwbXMtPiAwIC01MDBtcy0+IDEgLTUwMG1zLT4gLi4uIDlcbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgdGhlIHNhbWUgT2JzZXJ2YWJsZSB0byByZXBlYXQgaXQ8L2NhcHRpb24+XG4gKiBjb25zdCB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgyKTtcbiAqXG4gKiBSeC5PYnNlcnZhYmxlLmNvbmNhdCh0aW1lciwgdGltZXIpIC8vIGNvbmNhdGluZyB0aGUgc2FtZSBPYnNlcnZhYmxlIVxuICogLnN1YnNjcmliZShcbiAqICAgdmFsdWUgPT4gY29uc29sZS5sb2codmFsdWUpLFxuICogICBlcnIgPT4ge30sXG4gKiAgICgpID0+IGNvbnNvbGUubG9nKCcuLi5hbmQgaXQgaXMgZG9uZSEnKVxuICogKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gMCBhZnRlciAxc1xuICogLy8gMSBhZnRlciAyc1xuICogLy8gMCBhZnRlciAzc1xuICogLy8gMSBhZnRlciA0c1xuICogLy8gXCIuLi5hbmQgaXQgaXMgZG9uZSFcIiBhbHNvIGFmdGVyIDRzXG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IGlucHV0MSBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIHdpdGggb3RoZXJzLlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IGlucHV0MiBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIHdpdGggb3RoZXJzLlxuICogTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBBbiBvcHRpb25hbCBJU2NoZWR1bGVyIHRvIHNjaGVkdWxlIGVhY2hcbiAqIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQWxsIHZhbHVlcyBvZiBlYWNoIHBhc3NlZCBPYnNlcnZhYmxlIG1lcmdlZCBpbnRvIGFcbiAqIHNpbmdsZSBPYnNlcnZhYmxlLCBpbiBvcmRlciwgaW4gc2VyaWFsIGZhc2hpb24uXG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIGNvbmNhdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY29uY2F0U3RhdGljKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgc2NoZWR1bGVyID0gbnVsbDtcbiAgICB2YXIgYXJncyA9IG9ic2VydmFibGVzO1xuICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKGFyZ3Nbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IGFyZ3MucG9wKCk7XG4gICAgfVxuICAgIGlmIChzY2hlZHVsZXIgPT09IG51bGwgJiYgb2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxICYmIG9ic2VydmFibGVzWzBdIGluc3RhbmNlb2YgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShvYnNlcnZhYmxlcywgc2NoZWR1bGVyKS5saWZ0KG5ldyBtZXJnZUFsbF8xLk1lcmdlQWxsT3BlcmF0b3IoMSkpO1xufVxuZXhwb3J0cy5jb25jYXRTdGF0aWMgPSBjb25jYXRTdGF0aWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG52YXIgaXNEYXRlXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzRGF0ZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBOb3RpZmljYXRpb25fMSA9IHJlcXVpcmUoJy4uL05vdGlmaWNhdGlvbicpO1xuLyoqXG4gKiBEZWxheXMgdGhlIGVtaXNzaW9uIG9mIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IGEgZ2l2ZW4gdGltZW91dCBvclxuICogdW50aWwgYSBnaXZlbiBEYXRlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5UaW1lIHNoaWZ0cyBlYWNoIGl0ZW0gYnkgc29tZSBzcGVjaWZpZWQgYW1vdW50IG9mXG4gKiBtaWxsaXNlY29uZHMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZGVsYXkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogSWYgdGhlIGRlbGF5IGFyZ3VtZW50IGlzIGEgTnVtYmVyLCB0aGlzIG9wZXJhdG9yIHRpbWUgc2hpZnRzIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhhdCBhbW91bnQgb2YgdGltZSBleHByZXNzZWQgaW4gbWlsbGlzZWNvbmRzLiBUaGUgcmVsYXRpdmVcbiAqIHRpbWUgaW50ZXJ2YWxzIGJldHdlZW4gdGhlIHZhbHVlcyBhcmUgcHJlc2VydmVkLlxuICpcbiAqIElmIHRoZSBkZWxheSBhcmd1bWVudCBpcyBhIERhdGUsIHRoaXMgb3BlcmF0b3IgdGltZSBzaGlmdHMgdGhlIHN0YXJ0IG9mIHRoZVxuICogT2JzZXJ2YWJsZSBleGVjdXRpb24gdW50aWwgdGhlIGdpdmVuIGRhdGUgb2NjdXJzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkRlbGF5IGVhY2ggY2xpY2sgYnkgb25lIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgZGVsYXllZENsaWNrcyA9IGNsaWNrcy5kZWxheSgxMDAwKTsgLy8gZWFjaCBjbGljayBlbWl0dGVkIGFmdGVyIDEgc2Vjb25kXG4gKiBkZWxheWVkQ2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5EZWxheSBhbGwgY2xpY2tzIHVudGlsIGEgZnV0dXJlIGRhdGUgaGFwcGVuczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgZGF0ZSA9IG5ldyBEYXRlKCdNYXJjaCAxNSwgMjA1MCAxMjowMDowMCcpOyAvLyBpbiB0aGUgZnV0dXJlXG4gKiB2YXIgZGVsYXllZENsaWNrcyA9IGNsaWNrcy5kZWxheShkYXRlKTsgLy8gY2xpY2sgZW1pdHRlZCBvbmx5IGFmdGVyIHRoYXQgZGF0ZVxuICogZGVsYXllZENsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZGVib3VuY2VUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVsYXlXaGVufVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGRlbGF5IFRoZSBkZWxheSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgKGEgYG51bWJlcmApIG9yXG4gKiBhIGBEYXRlYCB1bnRpbCB3aGljaCB0aGUgZW1pc3Npb24gb2YgdGhlIHNvdXJjZSBpdGVtcyBpcyBkZWxheWVkLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3JcbiAqIG1hbmFnaW5nIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGhlIHRpbWUtc2hpZnQgZm9yIGVhY2ggaXRlbS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBkZWxheXMgdGhlIGVtaXNzaW9ucyBvZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGJ5IHRoZSBzcGVjaWZpZWQgdGltZW91dCBvciBEYXRlLlxuICogQG1ldGhvZCBkZWxheVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZGVsYXkoZGVsYXksIHNjaGVkdWxlcikge1xuICAgIGlmIChzY2hlZHVsZXIgPT09IHZvaWQgMCkgeyBzY2hlZHVsZXIgPSBhc3luY18xLmFzeW5jOyB9XG4gICAgdmFyIGFic29sdXRlRGVsYXkgPSBpc0RhdGVfMS5pc0RhdGUoZGVsYXkpO1xuICAgIHZhciBkZWxheUZvciA9IGFic29sdXRlRGVsYXkgPyAoK2RlbGF5IC0gc2NoZWR1bGVyLm5vdygpKSA6IE1hdGguYWJzKGRlbGF5KTtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEZWxheU9wZXJhdG9yKGRlbGF5Rm9yLCBzY2hlZHVsZXIpKTtcbn1cbmV4cG9ydHMuZGVsYXkgPSBkZWxheTtcbnZhciBEZWxheU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWxheU9wZXJhdG9yKGRlbGF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgRGVsYXlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlbGF5U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmRlbGF5LCB0aGlzLnNjaGVkdWxlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIERlbGF5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEZWxheVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWxheVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVsYXlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkZWxheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVycm9yZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgRGVsYXlTdWJzY3JpYmVyLmRpc3BhdGNoID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBzdGF0ZS5zb3VyY2U7XG4gICAgICAgIHZhciBxdWV1ZSA9IHNvdXJjZS5xdWV1ZTtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHN0YXRlLnNjaGVkdWxlcjtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gc3RhdGUuZGVzdGluYXRpb247XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwICYmIChxdWV1ZVswXS50aW1lIC0gc2NoZWR1bGVyLm5vdygpKSA8PSAwKSB7XG4gICAgICAgICAgICBxdWV1ZS5zaGlmdCgpLm5vdGlmaWNhdGlvbi5vYnNlcnZlKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGRlbGF5XzEgPSBNYXRoLm1heCgwLCBxdWV1ZVswXS50aW1lIC0gc2NoZWR1bGVyLm5vdygpKTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUsIGRlbGF5XzEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc291cmNlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9zY2hlZHVsZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoRGVsYXlTdWJzY3JpYmVyLmRpc3BhdGNoLCB0aGlzLmRlbGF5LCB7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMsIGRlc3RpbmF0aW9uOiB0aGlzLmRlc3RpbmF0aW9uLCBzY2hlZHVsZXI6IHNjaGVkdWxlclxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBEZWxheVN1YnNjcmliZXIucHJvdG90eXBlLnNjaGVkdWxlTm90aWZpY2F0aW9uID0gZnVuY3Rpb24gKG5vdGlmaWNhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5lcnJvcmVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgbWVzc2FnZSA9IG5ldyBEZWxheU1lc3NhZ2Uoc2NoZWR1bGVyLm5vdygpICsgdGhpcy5kZWxheSwgbm90aWZpY2F0aW9uKTtcbiAgICAgICAgdGhpcy5xdWV1ZS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZShzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWxheVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQodmFsdWUpKTtcbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmVycm9yZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbl8xLk5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSgpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWxheVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG52YXIgRGVsYXlNZXNzYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWxheU1lc3NhZ2UodGltZSwgbm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9uID0gbm90aWZpY2F0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gRGVsYXlNZXNzYWdlO1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbGF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFsbCBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IGFyZSBkaXN0aW5jdCBieSBjb21wYXJpc29uIGZyb20gdGhlIHByZXZpb3VzIGl0ZW0uXG4gKlxuICogSWYgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGl0ZW0gdG8gdGVzdCBmb3Igd2hldGhlciBvciBub3QgdGhhdCB2YWx1ZSBzaG91bGQgYmUgZW1pdHRlZC5cbiAqXG4gKiBJZiBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLCBhbiBlcXVhbGl0eSBjaGVjayBpcyB1c2VkIGJ5IGRlZmF1bHQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QSBzaW1wbGUgZXhhbXBsZSB3aXRoIG51bWJlcnM8L2NhcHRpb24+XG4gKiBPYnNlcnZhYmxlLm9mKDEsIDEsIDIsIDIsIDIsIDEsIDEsIDIsIDMsIDMsIDQpXG4gKiAgIC5kaXN0aW5jdFVudGlsQ2hhbmdlZCgpXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7IC8vIDEsIDIsIDEsIDIsIDMsIDRcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BbiBleGFtcGxlIHVzaW5nIGEgY29tcGFyZSBmdW5jdGlvbjwvY2FwdGlvbj5cbiAqIGludGVyZmFjZSBQZXJzb24ge1xuICogICAgYWdlOiBudW1iZXIsXG4gKiAgICBuYW1lOiBzdHJpbmdcbiAqIH1cbiAqXG4gKiBPYnNlcnZhYmxlLm9mPFBlcnNvbj4oXG4gKiAgICAgeyBhZ2U6IDQsIG5hbWU6ICdGb28nfSxcbiAqICAgICB7IGFnZTogNywgbmFtZTogJ0Jhcid9LFxuICogICAgIHsgYWdlOiA1LCBuYW1lOiAnRm9vJ30pXG4gKiAgICAgeyBhZ2U6IDYsIG5hbWU6ICdGb28nfSlcbiAqICAgICAuZGlzdGluY3RVbnRpbENoYW5nZWQoKHA6IFBlcnNvbiwgcTogUGVyc29uKSA9PiBwLm5hbWUgPT09IHEubmFtZSlcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIGRpc3BsYXlzOlxuICogLy8geyBhZ2U6IDQsIG5hbWU6ICdGb28nIH1cbiAqIC8vIHsgYWdlOiA3LCBuYW1lOiAnQmFyJyB9XG4gKiAvLyB7IGFnZTogNSwgbmFtZTogJ0ZvbycgfVxuICpcbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0fVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbEtleUNoYW5nZWR9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NvbXBhcmVdIE9wdGlvbmFsIGNvbXBhcmlzb24gZnVuY3Rpb24gY2FsbGVkIHRvIHRlc3QgaWYgYW4gaXRlbSBpcyBkaXN0aW5jdCBmcm9tIHRoZSBwcmV2aW91cyBpdGVtIGluIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCBkaXN0aW5jdCB2YWx1ZXMuXG4gKiBAbWV0aG9kIGRpc3RpbmN0VW50aWxDaGFuZ2VkXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkaXN0aW5jdFVudGlsQ2hhbmdlZChjb21wYXJlLCBrZXlTZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERpc3RpbmN0VW50aWxDaGFuZ2VkT3BlcmF0b3IoY29tcGFyZSwga2V5U2VsZWN0b3IpKTtcbn1cbmV4cG9ydHMuZGlzdGluY3RVbnRpbENoYW5nZWQgPSBkaXN0aW5jdFVudGlsQ2hhbmdlZDtcbnZhciBEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yKGNvbXBhcmUsIGtleVNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY29tcGFyZSA9IGNvbXBhcmU7XG4gICAgICAgIHRoaXMua2V5U2VsZWN0b3IgPSBrZXlTZWxlY3RvcjtcbiAgICB9XG4gICAgRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNvbXBhcmUsIHRoaXMua2V5U2VsZWN0b3IpKTtcbiAgICB9O1xuICAgIHJldHVybiBEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgY29tcGFyZSwga2V5U2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmtleVNlbGVjdG9yID0ga2V5U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaGFzS2V5ID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5jb21wYXJlID0gY29tcGFyZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICByZXR1cm4geCA9PT0geTtcbiAgICB9O1xuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGtleVNlbGVjdG9yID0gdGhpcy5rZXlTZWxlY3RvcjtcbiAgICAgICAgdmFyIGtleSA9IHZhbHVlO1xuICAgICAgICBpZiAoa2V5U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGtleSA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godGhpcy5rZXlTZWxlY3RvcikodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5oYXNLZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2godGhpcy5jb21wYXJlKSh0aGlzLmtleSwga2V5KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNLZXkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChCb29sZWFuKHJlc3VsdCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmtleSA9IGtleTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXN0aW5jdFVudGlsQ2hhbmdlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBkaXN0aW5jdFVudGlsQ2hhbmdlZF8xID0gcmVxdWlyZSgnLi9kaXN0aW5jdFVudGlsQ2hhbmdlZCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYWxsIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgYXJlIGRpc3RpbmN0IGJ5IGNvbXBhcmlzb24gZnJvbSB0aGUgcHJldmlvdXMgaXRlbSxcbiAqIHVzaW5nIGEgcHJvcGVydHkgYWNjZXNzZWQgYnkgdXNpbmcgdGhlIGtleSBwcm92aWRlZCB0byBjaGVjayBpZiB0aGUgdHdvIGl0ZW1zIGFyZSBkaXN0aW5jdC5cbiAqXG4gKiBJZiBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHRoZW4gaXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggaXRlbSB0byB0ZXN0IGZvciB3aGV0aGVyIG9yIG5vdCB0aGF0IHZhbHVlIHNob3VsZCBiZSBlbWl0dGVkLlxuICpcbiAqIElmIGEgY29tcGFyYXRvciBmdW5jdGlvbiBpcyBub3QgcHJvdmlkZWQsIGFuIGVxdWFsaXR5IGNoZWNrIGlzIHVzZWQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BbiBleGFtcGxlIGNvbXBhcmluZyB0aGUgbmFtZSBvZiBwZXJzb25zPC9jYXB0aW9uPlxuICpcbiAqICBpbnRlcmZhY2UgUGVyc29uIHtcbiAqICAgICBhZ2U6IG51bWJlcixcbiAqICAgICBuYW1lOiBzdHJpbmdcbiAqICB9XG4gKlxuICogT2JzZXJ2YWJsZS5vZjxQZXJzb24+KFxuICogICAgIHsgYWdlOiA0LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgeyBhZ2U6IDcsIG5hbWU6ICdCYXInfSxcbiAqICAgICB7IGFnZTogNSwgbmFtZTogJ0Zvbyd9LFxuICogICAgIHsgYWdlOiA2LCBuYW1lOiAnRm9vJ30pXG4gKiAgICAgLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKCduYW1lJylcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIGRpc3BsYXlzOlxuICogLy8geyBhZ2U6IDQsIG5hbWU6ICdGb28nIH1cbiAqIC8vIHsgYWdlOiA3LCBuYW1lOiAnQmFyJyB9XG4gKiAvLyB7IGFnZTogNSwgbmFtZTogJ0ZvbycgfVxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkFuIGV4YW1wbGUgY29tcGFyaW5nIHRoZSBmaXJzdCBsZXR0ZXJzIG9mIHRoZSBuYW1lPC9jYXB0aW9uPlxuICpcbiAqIGludGVyZmFjZSBQZXJzb24ge1xuICogICAgIGFnZTogbnVtYmVyLFxuICogICAgIG5hbWU6IHN0cmluZ1xuICogIH1cbiAqXG4gKiBPYnNlcnZhYmxlLm9mPFBlcnNvbj4oXG4gKiAgICAgeyBhZ2U6IDQsIG5hbWU6ICdGb28xJ30sXG4gKiAgICAgeyBhZ2U6IDcsIG5hbWU6ICdCYXInfSxcbiAqICAgICB7IGFnZTogNSwgbmFtZTogJ0ZvbzInfSxcbiAqICAgICB7IGFnZTogNiwgbmFtZTogJ0ZvbzMnfSlcbiAqICAgICAuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQoJ25hbWUnLCAoeDogc3RyaW5nLCB5OiBzdHJpbmcpID0+IHguc3Vic3RyaW5nKDAsIDMpID09PSB5LnN1YnN0cmluZygwLCAzKSlcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIGRpc3BsYXlzOlxuICogLy8geyBhZ2U6IDQsIG5hbWU6ICdGb28xJyB9XG4gKiAvLyB7IGFnZTogNywgbmFtZTogJ0JhcicgfVxuICogLy8geyBhZ2U6IDUsIG5hbWU6ICdGb28yJyB9XG4gKlxuICogQHNlZSB7QGxpbmsgZGlzdGluY3R9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsQ2hhbmdlZH1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFN0cmluZyBrZXkgZm9yIG9iamVjdCBwcm9wZXJ0eSBsb29rdXAgb24gZWFjaCBpdGVtLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NvbXBhcmVdIE9wdGlvbmFsIGNvbXBhcmlzb24gZnVuY3Rpb24gY2FsbGVkIHRvIHRlc3QgaWYgYW4gaXRlbSBpcyBkaXN0aW5jdCBmcm9tIHRoZSBwcmV2aW91cyBpdGVtIGluIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCBkaXN0aW5jdCB2YWx1ZXMgYmFzZWQgb24gdGhlIGtleSBzcGVjaWZpZWQuXG4gKiBAbWV0aG9kIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZChrZXksIGNvbXBhcmUpIHtcbiAgICByZXR1cm4gZGlzdGluY3RVbnRpbENoYW5nZWRfMS5kaXN0aW5jdFVudGlsQ2hhbmdlZC5jYWxsKHRoaXMsIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIGlmIChjb21wYXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZSh4W2tleV0sIHlba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhba2V5XSA9PT0geVtrZXldO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCA9IGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzdGluY3RVbnRpbEtleUNoYW5nZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBGaWx0ZXIgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgb25seSBlbWl0dGluZyB0aG9zZSB0aGF0XG4gKiBzYXRpc2Z5IGEgc3BlY2lmaWVkIHByZWRpY2F0ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGlrZVxuICogW0FycmF5LnByb3RvdHlwZS5maWx0ZXIoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmlsdGVyKSxcbiAqIGl0IG9ubHkgZW1pdHMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgaWYgaXQgcGFzc2VzIGEgY3JpdGVyaW9uIGZ1bmN0aW9uLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2ZpbHRlci5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBTaW1pbGFyIHRvIHRoZSB3ZWxsLWtub3duIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2QsIHRoaXMgb3BlcmF0b3JcbiAqIHRha2VzIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcGFzc2VzIHRoZW0gdGhyb3VnaCBhIGBwcmVkaWNhdGVgXG4gKiBmdW5jdGlvbiBhbmQgb25seSBlbWl0cyB0aG9zZSB2YWx1ZXMgdGhhdCB5aWVsZGVkIGB0cnVlYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IG9ubHkgY2xpY2sgZXZlbnRzIHdob3NlIHRhcmdldCB3YXMgYSBESVYgZWxlbWVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgY2xpY2tzT25EaXZzID0gY2xpY2tzLmZpbHRlcihldiA9PiBldi50YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpO1xuICogY2xpY2tzT25EaXZzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxDaGFuZ2VkfVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbEtleUNoYW5nZWR9XG4gKiBAc2VlIHtAbGluayBpZ25vcmVFbGVtZW50c31cbiAqIEBzZWUge0BsaW5rIHBhcnRpdGlvbn1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW59IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRoYXRcbiAqIGV2YWx1YXRlcyBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBpdCByZXR1cm5zIGB0cnVlYCxcbiAqIHRoZSB2YWx1ZSBpcyBlbWl0dGVkLCBpZiBgZmFsc2VgIHRoZSB2YWx1ZSBpcyBub3QgcGFzc2VkIHRvIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuIFRoZSBgaW5kZXhgIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggc291cmNlXG4gKiBlbWlzc2lvbiB0aGF0IGhhcyBoYXBwZW5lZCBzaW5jZSB0aGUgc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXJcbiAqIGAwYC5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiBgdGhpc2BcbiAqIGluIHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSB0aGF0IHdlcmVcbiAqIGFsbG93ZWQgYnkgdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBmaWx0ZXJcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBGaWx0ZXJPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcpKTtcbn1cbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xudmFyIEZpbHRlck9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBGaWx0ZXJPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgfVxuICAgIEZpbHRlck9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmlsdGVyU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy50aGlzQXJnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBGaWx0ZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmlsdGVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaWx0ZXJTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcmVkaWNhdGUsIHRoaXNBcmcpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgIH1cbiAgICAvLyB0aGUgdHJ5IGNhdGNoIGJsb2NrIGJlbG93IGlzIGxlZnQgc3BlY2lmaWNhbGx5IGZvclxuICAgIC8vIG9wdGltaXphdGlvbiBhbmQgcGVyZiByZWFzb25zLiBhIHRyeUNhdGNoZXIgaXMgbm90IG5lY2Vzc2FyeSBoZXJlLlxuICAgIEZpbHRlclN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZS5jYWxsKHRoaXMudGhpc0FyZywgdmFsdWUsIHRoaXMuY291bnQrKyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXJTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VBbGxfMSA9IHJlcXVpcmUoJy4vbWVyZ2VBbGwnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBjb25jdXJyZW50bHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGV2ZXJ5XG4gKiBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieSBibGVuZGluZ1xuICogdGhlaXIgdmFsdWVzIGludG8gb25lIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1lcmdlYCBzdWJzY3JpYmVzIHRvIGVhY2ggZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZSAoZWl0aGVyIHRoZSBzb3VyY2Ugb3IgYW5cbiAqIE9ic2VydmFibGUgZ2l2ZW4gYXMgYXJndW1lbnQpLCBhbmQgc2ltcGx5IGZvcndhcmRzICh3aXRob3V0IGRvaW5nIGFueVxuICogdHJhbnNmb3JtYXRpb24pIGFsbCB0aGUgdmFsdWVzIGZyb20gYWxsIHRoZSBpbnB1dCBPYnNlcnZhYmxlcyB0byB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgb25seSBjb21wbGV0ZXMgb25jZSBhbGwgaW5wdXQgT2JzZXJ2YWJsZXNcbiAqIGhhdmUgY29tcGxldGVkLiBBbnkgZXJyb3IgZGVsaXZlcmVkIGJ5IGFuIGlucHV0IE9ic2VydmFibGUgd2lsbCBiZSBpbW1lZGlhdGVseVxuICogZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWVyZ2UgdG9nZXRoZXIgdHdvIE9ic2VydmFibGVzOiAxcyBpbnRlcnZhbCBhbmQgY2xpY2tzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgY2xpY2tzT3JUaW1lciA9IGNsaWNrcy5tZXJnZSh0aW1lcik7XG4gKiBjbGlja3NPclRpbWVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NZXJnZSB0b2dldGhlciAzIE9ic2VydmFibGVzLCBidXQgb25seSAyIHJ1biBjb25jdXJyZW50bHk8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIGNvbmN1cnJlbnQgPSAyOyAvLyB0aGUgYXJndW1lbnRcbiAqIHZhciBtZXJnZWQgPSB0aW1lcjEubWVyZ2UodGltZXIyLCB0aW1lcjMsIGNvbmN1cnJlbnQpO1xuICogbWVyZ2VkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gb3RoZXIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBtZXJnZSB3aXRoIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvciBtYW5hZ2luZ1xuICogY29uY3VycmVuY3kgb2YgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgdGhhdCBhcmUgdGhlIHJlc3VsdCBvZlxuICogZXZlcnkgaW5wdXQgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgbWVyZ2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0LmNhbGwobWVyZ2VTdGF0aWMuYXBwbHkodm9pZCAwLCBbdGhpc10uY29uY2F0KG9ic2VydmFibGVzKSkpO1xufVxuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBjb25jdXJyZW50bHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGV2ZXJ5XG4gKiBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieSBibGVuZGluZ1xuICogdGhlaXIgdmFsdWVzIGludG8gb25lIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1lcmdlYCBzdWJzY3JpYmVzIHRvIGVhY2ggZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZSAoYXMgYXJndW1lbnRzKSwgYW5kIHNpbXBseVxuICogZm9yd2FyZHMgKHdpdGhvdXQgZG9pbmcgYW55IHRyYW5zZm9ybWF0aW9uKSBhbGwgdGhlIHZhbHVlcyBmcm9tIGFsbCB0aGUgaW5wdXRcbiAqIE9ic2VydmFibGVzIHRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIG9ubHkgY29tcGxldGVzXG4gKiBvbmNlIGFsbCBpbnB1dCBPYnNlcnZhYmxlcyBoYXZlIGNvbXBsZXRlZC4gQW55IGVycm9yIGRlbGl2ZXJlZCBieSBhbiBpbnB1dFxuICogT2JzZXJ2YWJsZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1lcmdlIHRvZ2V0aGVyIHR3byBPYnNlcnZhYmxlczogMXMgaW50ZXJ2YWwgYW5kIGNsaWNrczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrc09yVGltZXIgPSBSeC5PYnNlcnZhYmxlLm1lcmdlKGNsaWNrcywgdGltZXIpO1xuICogY2xpY2tzT3JUaW1lci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gdGltZXIgd2lsbCBlbWl0IGFzY2VuZGluZyB2YWx1ZXMsIG9uZSBldmVyeSBzZWNvbmQoMTAwMG1zKSB0byBjb25zb2xlXG4gKiAvLyBjbGlja3MgbG9ncyBNb3VzZUV2ZW50cyB0byBjb25zb2xlIGV2ZXJ5dGltZSB0aGUgXCJkb2N1bWVudFwiIGlzIGNsaWNrZWRcbiAqIC8vIFNpbmNlIHRoZSB0d28gc3RyZWFtcyBhcmUgbWVyZ2VkIHlvdSBzZWUgdGhlc2UgaGFwcGVuaW5nXG4gKiAvLyBhcyB0aGV5IG9jY3VyLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1lcmdlIHRvZ2V0aGVyIDMgT2JzZXJ2YWJsZXMsIGJ1dCBvbmx5IDIgcnVuIGNvbmN1cnJlbnRseTwvY2FwdGlvbj5cbiAqIHZhciB0aW1lcjEgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApO1xuICogdmFyIHRpbWVyMiA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkudGFrZSg2KTtcbiAqIHZhciB0aW1lcjMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkudGFrZSgxMCk7XG4gKiB2YXIgY29uY3VycmVudCA9IDI7IC8vIHRoZSBhcmd1bWVudFxuICogdmFyIG1lcmdlZCA9IFJ4Lk9ic2VydmFibGUubWVyZ2UodGltZXIxLCB0aW1lcjIsIHRpbWVyMywgY29uY3VycmVudCk7XG4gKiBtZXJnZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIC0gRmlyc3QgdGltZXIxIGFuZCB0aW1lcjIgd2lsbCBydW4gY29uY3VycmVudGx5XG4gKiAvLyAtIHRpbWVyMSB3aWxsIGVtaXQgYSB2YWx1ZSBldmVyeSAxMDAwbXMgZm9yIDEwIGl0ZXJhdGlvbnNcbiAqIC8vIC0gdGltZXIyIHdpbGwgZW1pdCBhIHZhbHVlIGV2ZXJ5IDIwMDBtcyBmb3IgNiBpdGVyYXRpb25zXG4gKiAvLyAtIGFmdGVyIHRpbWVyMSBoaXRzIGl0J3MgbWF4IGl0ZXJhdGlvbiwgdGltZXIyIHdpbGxcbiAqIC8vICAgY29udGludWUsIGFuZCB0aW1lcjMgd2lsbCBzdGFydCB0byBydW4gY29uY3VycmVudGx5IHdpdGggdGltZXIyXG4gKiAvLyAtIHdoZW4gdGltZXIyIGhpdHMgaXQncyBtYXggaXRlcmF0aW9uIGl0IHRlcm1pbmF0ZXMsIGFuZFxuICogLy8gICB0aW1lcjMgd2lsbCBjb250aW51ZSB0byBlbWl0IGEgdmFsdWUgZXZlcnkgNTAwbXMgdW50aWwgaXQgaXMgY29tcGxldGVcbiAqXG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqXG4gKiBAcGFyYW0gey4uLk9ic2VydmFibGVJbnB1dH0gb2JzZXJ2YWJsZXMgSW5wdXQgT2JzZXJ2YWJsZXMgdG8gbWVyZ2UgdG9nZXRoZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbnB1dFxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBUaGUgSVNjaGVkdWxlciB0byB1c2UgZm9yIG1hbmFnaW5nXG4gKiBjb25jdXJyZW5jeSBvZiBpbnB1dCBPYnNlcnZhYmxlcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyB0aGF0IGFyZSB0aGUgcmVzdWx0IG9mXG4gKiBldmVyeSBpbnB1dCBPYnNlcnZhYmxlLlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBtZXJnZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VTdGF0aWMoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIHZhciBzY2hlZHVsZXIgPSBudWxsO1xuICAgIHZhciBsYXN0ID0gb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIobGFzdCkpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgICAgIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPiAxICYmIHR5cGVvZiBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbmN1cnJlbnQgPSBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgbGFzdCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uY3VycmVudCA9IG9ic2VydmFibGVzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoc2NoZWR1bGVyID09PSBudWxsICYmIG9ic2VydmFibGVzLmxlbmd0aCA9PT0gMSAmJiBvYnNlcnZhYmxlc1swXSBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSB7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMsIHNjaGVkdWxlcikubGlmdChuZXcgbWVyZ2VBbGxfMS5NZXJnZUFsbE9wZXJhdG9yKGNvbmN1cnJlbnQpKTtcbn1cbmV4cG9ydHMubWVyZ2VTdGF0aWMgPSBtZXJnZVN0YXRpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlIGludG8gYSBmaXJzdC1vcmRlciBPYnNlcnZhYmxlIHdoaWNoXG4gKiBjb25jdXJyZW50bHkgZGVsaXZlcnMgYWxsIHZhbHVlcyB0aGF0IGFyZSBlbWl0dGVkIG9uIHRoZSBpbm5lciBPYnNlcnZhYmxlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgYW4gT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tZXJnZUFsbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgbWVyZ2VBbGxgIHN1YnNjcmliZXMgdG8gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIE9ic2VydmFibGVzLCBhbHNvIGtub3duIGFzXG4gKiBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlLiBFYWNoIHRpbWUgaXQgb2JzZXJ2ZXMgb25lIG9mIHRoZXNlIGVtaXR0ZWQgaW5uZXJcbiAqIE9ic2VydmFibGVzLCBpdCBzdWJzY3JpYmVzIHRvIHRoYXQgYW5kIGRlbGl2ZXJzIGFsbCB0aGUgdmFsdWVzIGZyb20gdGhlXG4gKiBpbm5lciBPYnNlcnZhYmxlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIG9ubHlcbiAqIGNvbXBsZXRlcyBvbmNlIGFsbCBpbm5lciBPYnNlcnZhYmxlcyBoYXZlIGNvbXBsZXRlZC4gQW55IGVycm9yIGRlbGl2ZXJlZCBieVxuICogYSBpbm5lciBPYnNlcnZhYmxlIHdpbGwgYmUgaW1tZWRpYXRlbHkgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+U3Bhd24gYSBuZXcgaW50ZXJ2YWwgT2JzZXJ2YWJsZSBmb3IgZWFjaCBjbGljayBldmVudCwgYW5kIGJsZW5kIHRoZWlyIG91dHB1dHMgYXMgb25lIE9ic2VydmFibGU8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGhpZ2hlck9yZGVyID0gY2xpY2tzLm1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogdmFyIGZpcnN0T3JkZXIgPSBoaWdoZXJPcmRlci5tZXJnZUFsbCgpO1xuICogZmlyc3RPcmRlci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q291bnQgZnJvbSAwIHRvIDkgZXZlcnkgc2Vjb25kIGZvciBlYWNoIGNsaWNrLCBidXQgb25seSBhbGxvdyAyIGNvbmN1cnJlbnQgdGltZXJzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApKTtcbiAqIHZhciBmaXJzdE9yZGVyID0gaGlnaGVyT3JkZXIubWVyZ2VBbGwoMik7XG4gKiBmaXJzdE9yZGVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lQWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICogQHNlZSB7QGxpbmsgc3dpdGNofVxuICogQHNlZSB7QGxpbmsgemlwQWxsfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlubmVyXG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB2YWx1ZXMgY29taW5nIGZyb20gYWxsIHRoZVxuICogaW5uZXIgT2JzZXJ2YWJsZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIG1lcmdlQWxsXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtZXJnZUFsbChjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgTWVyZ2VBbGxPcGVyYXRvcihjb25jdXJyZW50KSk7XG59XG5leHBvcnRzLm1lcmdlQWxsID0gbWVyZ2VBbGw7XG52YXIgTWVyZ2VBbGxPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVyZ2VBbGxPcGVyYXRvcihjb25jdXJyZW50KSB7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgfVxuICAgIE1lcmdlQWxsT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VBbGxTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLmNvbmN1cnJlbnQpKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXJnZUFsbE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWVyZ2VBbGxPcGVyYXRvciA9IE1lcmdlQWxsT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE1lcmdlQWxsU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lcmdlQWxsU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXJnZUFsbFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbmN1cnJlbnQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgfVxuICAgIE1lcmdlQWxsU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPCB0aGlzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG9ic2VydmFibGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2gob2JzZXJ2YWJsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlQWxsU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VBbGxTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VBbGxTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuTWVyZ2VBbGxTdWJzY3JpYmVyID0gTWVyZ2VBbGxTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VBbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQ29ubmVjdGFibGVPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZScpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdHMgb2YgaW52b2tpbmcgYSBzcGVjaWZpZWQgc2VsZWN0b3Igb24gaXRlbXNcbiAqIGVtaXR0ZWQgYnkgYSBDb25uZWN0YWJsZU9ic2VydmFibGUgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHN0cmVhbS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL211bHRpY2FzdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN1YmplY3R9IHN1YmplY3RPclN1YmplY3RGYWN0b3J5IC0gRmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgYW4gaW50ZXJtZWRpYXRlIHN1YmplY3QgdGhyb3VnaFxuICogd2hpY2ggdGhlIHNvdXJjZSBzZXF1ZW5jZSdzIGVsZW1lbnRzIHdpbGwgYmUgbXVsdGljYXN0IHRvIHRoZSBzZWxlY3RvciBmdW5jdGlvblxuICogb3IgU3ViamVjdCB0byBwdXNoIHNvdXJjZSBlbGVtZW50cyBpbnRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSAtIE9wdGlvbmFsIHNlbGVjdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIHVzZSB0aGUgbXVsdGljYXN0ZWQgc291cmNlIHN0cmVhbVxuICogYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsIHdpdGhvdXQgY2F1c2luZyBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc3RyZWFtLlxuICogU3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIHNvdXJjZSB3aWxsIHJlY2VpdmUgYWxsIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBmcm9tIHRoZVxuICogdGltZSBvZiB0aGUgc3Vic2NyaXB0aW9uIGZvcndhcmQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdHMgb2YgaW52b2tpbmcgdGhlIHNlbGVjdG9yXG4gKiBvbiB0aGUgaXRlbXMgZW1pdHRlZCBieSBhIGBDb25uZWN0YWJsZU9ic2VydmFibGVgIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0b1xuICogdGhlIHVuZGVybHlpbmcgc3RyZWFtLlxuICogQG1ldGhvZCBtdWx0aWNhc3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG11bHRpY2FzdChzdWJqZWN0T3JTdWJqZWN0RmFjdG9yeSwgc2VsZWN0b3IpIHtcbiAgICB2YXIgc3ViamVjdEZhY3Rvcnk7XG4gICAgaWYgKHR5cGVvZiBzdWJqZWN0T3JTdWJqZWN0RmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdWJqZWN0RmFjdG9yeSA9IHN1YmplY3RPclN1YmplY3RGYWN0b3J5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3ViamVjdEZhY3RvcnkgPSBmdW5jdGlvbiBzdWJqZWN0RmFjdG9yeSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJqZWN0T3JTdWJqZWN0RmFjdG9yeTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNdWx0aWNhc3RPcGVyYXRvcihzdWJqZWN0RmFjdG9yeSwgc2VsZWN0b3IpKTtcbiAgICB9XG4gICAgdmFyIGNvbm5lY3RhYmxlID0gT2JqZWN0LmNyZWF0ZSh0aGlzLCBDb25uZWN0YWJsZU9ic2VydmFibGVfMS5jb25uZWN0YWJsZU9ic2VydmFibGVEZXNjcmlwdG9yKTtcbiAgICBjb25uZWN0YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgIGNvbm5lY3RhYmxlLnN1YmplY3RGYWN0b3J5ID0gc3ViamVjdEZhY3Rvcnk7XG4gICAgcmV0dXJuIGNvbm5lY3RhYmxlO1xufVxuZXhwb3J0cy5tdWx0aWNhc3QgPSBtdWx0aWNhc3Q7XG52YXIgTXVsdGljYXN0T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE11bHRpY2FzdE9wZXJhdG9yKHN1YmplY3RGYWN0b3J5LCBzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnN1YmplY3RGYWN0b3J5ID0gc3ViamVjdEZhY3Rvcnk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICB9XG4gICAgTXVsdGljYXN0T3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0RmFjdG9yeSgpO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gc2VsZWN0b3Ioc3ViamVjdCkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICBzdWJzY3JpcHRpb24uYWRkKHNvdXJjZS5zdWJzY3JpYmUoc3ViamVjdCkpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpY2FzdE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTXVsdGljYXN0T3BlcmF0b3IgPSBNdWx0aWNhc3RPcGVyYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11bHRpY2FzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtdWx0aWNhc3RfMSA9IHJlcXVpcmUoJy4vbXVsdGljYXN0Jyk7XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xuZnVuY3Rpb24gc2hhcmVTdWJqZWN0RmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IFN1YmplY3RfMS5TdWJqZWN0KCk7XG59XG4vKipcbiAqIFJldHVybnMgYSBuZXcgT2JzZXJ2YWJsZSB0aGF0IG11bHRpY2FzdHMgKHNoYXJlcykgdGhlIG9yaWdpbmFsIE9ic2VydmFibGUuIEFzIGxvbmcgYXMgdGhlcmUgaXMgYXQgbGVhc3Qgb25lXG4gKiBTdWJzY3JpYmVyIHRoaXMgT2JzZXJ2YWJsZSB3aWxsIGJlIHN1YnNjcmliZWQgYW5kIGVtaXR0aW5nIGRhdGEuIFdoZW4gYWxsIHN1YnNjcmliZXJzIGhhdmUgdW5zdWJzY3JpYmVkIGl0IHdpbGxcbiAqIHVuc3Vic2NyaWJlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBCZWNhdXNlIHRoZSBPYnNlcnZhYmxlIGlzIG11bHRpY2FzdGluZyBpdCBtYWtlcyB0aGUgc3RyZWFtIGBob3RgLlxuICogVGhpcyBpcyBhbiBhbGlhcyBmb3IgLnB1Ymxpc2goKS5yZWZDb3VudCgpLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2hhcmUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHVwb24gY29ubmVjdGlvbiBjYXVzZXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRvIGVtaXQgaXRlbXMgdG8gaXRzIE9ic2VydmVycy5cbiAqIEBtZXRob2Qgc2hhcmVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHNoYXJlKCkge1xuICAgIHJldHVybiBtdWx0aWNhc3RfMS5tdWx0aWNhc3QuY2FsbCh0aGlzLCBzaGFyZVN1YmplY3RGYWN0b3J5KS5yZWZDb3VudCgpO1xufVxuZXhwb3J0cy5zaGFyZSA9IHNoYXJlO1xuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIFNjYWxhck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvU2NhbGFyT2JzZXJ2YWJsZScpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnKTtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoJy4vY29uY2F0Jyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyB5b3Ugc3BlY2lmeSBhcyBhcmd1bWVudHMgYmVmb3JlIGl0IGJlZ2lucyB0byBlbWl0XG4gKiBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N0YXJ0V2l0aC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0gey4uLlR9IHZhbHVlcyAtIEl0ZW1zIHlvdSB3YW50IHRoZSBtb2RpZmllZCBPYnNlcnZhYmxlIHRvIGVtaXQgZmlyc3QuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gLSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyBpbiB0aGUgc3BlY2lmaWVkIEl0ZXJhYmxlIGFuZCB0aGVuIGVtaXRzIHRoZSBpdGVtc1xuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN0YXJ0V2l0aFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc3RhcnRXaXRoKCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFycmF5W19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgc2NoZWR1bGVyID0gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSkge1xuICAgICAgICBhcnJheS5wb3AoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgfVxuICAgIHZhciBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gY29uY2F0XzEuY29uY2F0U3RhdGljKG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKSwgdGhpcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdF8xLmNvbmNhdFN0YXRpYyhuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjb25jYXRfMS5jb25jYXRTdGF0aWMobmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpLCB0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLnN0YXJ0V2l0aCA9IHN0YXJ0V2l0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXJ0V2l0aC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSBieVxuICogc3Vic2NyaWJpbmcgdG8gb25seSB0aGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIG9mIHRob3NlIGlubmVyIE9ic2VydmFibGVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzIGJ5IGRyb3BwaW5nIHRoZVxuICogcHJldmlvdXMgaW5uZXIgT2JzZXJ2YWJsZSBvbmNlIGEgbmV3IG9uZSBhcHBlYXJzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N3aXRjaC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgc3dpdGNoYCBzdWJzY3JpYmVzIHRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcywgYWxzbyBrbm93biBhcyBhXG4gKiBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZSBlbWl0dGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlcywgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHN1YnNjcmliZXMgdG8gdGhlIGlubmVyIE9ic2VydmFibGUgYW5kXG4gKiBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnkgdGhhdC4gU28gZmFyLCBpdCBiZWhhdmVzXG4gKiBsaWtlIHtAbGluayBtZXJnZUFsbH0uIEhvd2V2ZXIsIHdoZW4gYSBuZXcgaW5uZXIgT2JzZXJ2YWJsZSBpcyBlbWl0dGVkLFxuICogYHN3aXRjaGAgdW5zdWJzY3JpYmVzIGZyb20gdGhlIGVhcmxpZXItZW1pdHRlZCBpbm5lciBPYnNlcnZhYmxlIGFuZFxuICogc3Vic2NyaWJlcyB0byB0aGUgbmV3IGlubmVyIE9ic2VydmFibGUgYW5kIGJlZ2lucyBlbWl0dGluZyBpdGVtcyBmcm9tIGl0LiBJdFxuICogY29udGludWVzIHRvIGJlaGF2ZSBsaWtlIHRoaXMgZm9yIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiAvLyBFYWNoIGNsaWNrIGV2ZW50IGlzIG1hcHBlZCB0byBhbiBPYnNlcnZhYmxlIHRoYXQgdGlja3MgZXZlcnkgc2Vjb25kXG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiB2YXIgc3dpdGNoZWQgPSBoaWdoZXJPcmRlci5zd2l0Y2goKTtcbiAqIC8vIFRoZSBvdXRjb21lIGlzIHRoYXQgYHN3aXRjaGVkYCBpcyBlc3NlbnRpYWxseSBhIHRpbWVyIHRoYXQgcmVzdGFydHNcbiAqIC8vIG9uIGV2ZXJ5IGNsaWNrLiBUaGUgaW50ZXJ2YWwgT2JzZXJ2YWJsZXMgZnJvbSBvbGRlciBjbGlja3MgZG8gbm90IG1lcmdlXG4gKiAvLyB3aXRoIHRoZSBjdXJyZW50IGludGVydmFsIE9ic2VydmFibGUuXG4gKiBzd2l0Y2hlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcFRvfVxuICogQHNlZSB7QGxpbmsgemlwQWxsfVxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbXMgZW1pdHRlZCBieSB0aGVcbiAqIE9ic2VydmFibGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoXG4gKiBAbmFtZSBzd2l0Y2hcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9zd2l0Y2goKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoT3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLl9zd2l0Y2ggPSBfc3dpdGNoO1xudmFyIFN3aXRjaE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgU3dpdGNoT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN3aXRjaFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgfVxuICAgIFN3aXRjaFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVJbm5lcigpO1xuICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICB0aGlzLmFkZCh0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZUlubmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRoaXMuYWN0aXZlID4gMCA/IHRoaXMuYWN0aXZlIC0gMSA6IDA7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChpbm5lclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVJbm5lcigpO1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wbGV0ZWQgJiYgdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSwgZW1pdHRpbmcgdmFsdWVzIG9ubHkgZnJvbSB0aGUgbW9zdCByZWNlbnRseSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgc3dpdGNofS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zd2l0Y2hNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiAoc28tY2FsbGVkIFwiaW5uZXJcIikgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZVxuICogaW5uZXIgT2JzZXJ2YWJsZXMsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnlcbiAqIHRoYXQgaW5uZXIgT2JzZXJ2YWJsZS4gV2hlbiBhIG5ldyBpbm5lciBPYnNlcnZhYmxlIGlzIGVtaXR0ZWQsIGBzd2l0Y2hNYXBgXG4gKiBzdG9wcyBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBlYXJsaWVyLWVtaXR0ZWQgaW5uZXIgT2JzZXJ2YWJsZSBhbmQgYmVnaW5zXG4gKiBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBuZXcgb25lLiBJdCBjb250aW51ZXMgdG8gYmVoYXZlIGxpa2UgdGhpcyBmb3JcbiAqIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnN3aXRjaE1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgdGFraW5nIG9ubHkgdGhlIHZhbHVlcyBmcm9tIHRoZSBtb3N0IHJlY2VudGx5XG4gKiBwcm9qZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoTWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzd2l0Y2hNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTd2l0Y2hNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvcikpO1xufVxuZXhwb3J0cy5zd2l0Y2hNYXAgPSBzd2l0Y2hNYXA7XG52YXIgU3dpdGNoTWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9XG4gICAgU3dpdGNoTWFwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hNYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy5yZXN1bHRTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaE1hcE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3dpdGNoTWFwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN3aXRjaE1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoTWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lubmVyU3ViKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9pbm5lclN1YiA9IGZ1bmN0aW9uIChyZXN1bHQsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSB0aGlzLmlubmVyU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoaW5uZXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGlubmVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGQodGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0LCB2YWx1ZSwgaW5kZXgpKTtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKCFpbm5lclN1YnNjcmlwdGlvbiB8fCBpbm5lclN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeU5vdGlmeU5leHQob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOb3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaE1hcFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoTWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBFbWl0cyBvbmx5IHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VGFrZXMgdGhlIGZpcnN0IGBjb3VudGAgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSwgdGhlblxuICogY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rha2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRha2VgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGZpcnN0IGBjb3VudGAgdmFsdWVzIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgdGhlIHNvdXJjZSBlbWl0cyBmZXdlciB0aGFuIGBjb3VudGAgdmFsdWVzIHRoZW5cbiAqIGFsbCBvZiBpdHMgdmFsdWVzIGFyZSBlbWl0dGVkLiBBZnRlciB0aGF0LCBpdCBjb21wbGV0ZXMsIHJlZ2FyZGxlc3MgaWYgdGhlXG4gKiBzb3VyY2UgY29tcGxldGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRha2UgdGhlIGZpcnN0IDUgc2Vjb25kcyBvZiBhbiBpbmZpbml0ZSAxLXNlY29uZCBpbnRlcnZhbCBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBmaXZlID0gaW50ZXJ2YWwudGFrZSg1KTtcbiAqIGZpdmUuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICogQHNlZSB7QGxpbmsgdGFrZVVudGlsfVxuICogQHNlZSB7QGxpbmsgdGFrZVdoaWxlfVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAdGhyb3dzIHtBcmd1bWVudE91dE9mUmFuZ2VFcnJvcn0gV2hlbiB1c2luZyBgdGFrZShpKWAsIGl0IGRlbGl2ZXJzIGFuXG4gKiBBcmd1bWVudE91dE9yUmFuZ2VFcnJvciB0byB0aGUgT2JzZXJ2ZXIncyBgZXJyb3JgIGNhbGxiYWNrIGlmIGBpIDwgMGAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IFRoZSBtYXhpbXVtIG51bWJlciBvZiBgbmV4dGAgdmFsdWVzIHRvIGVtaXQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgb25seSB0aGUgZmlyc3QgYGNvdW50YFxuICogdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBvciBhbGwgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIGlmIHRoZSBzb3VyY2UgZW1pdHMgZmV3ZXIgdGhhbiBgY291bnRgIHZhbHVlcy5cbiAqIEBtZXRob2QgdGFrZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGFrZShjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGFrZU9wZXJhdG9yKGNvdW50KSk7XG4gICAgfVxufVxuZXhwb3J0cy50YWtlID0gdGFrZTtcbnZhciBUYWtlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRha2VPcGVyYXRvcih0b3RhbCkge1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGFrZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy50b3RhbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRha2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFrZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFrZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHRvdGFsKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG4gICAgVGFrZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMudG90YWw7XG4gICAgICAgIHZhciBjb3VudCA9ICsrdGhpcy5jb3VudDtcbiAgICAgICAgaWYgKGNvdW50IDw9IHRvdGFsKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUYWtlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDb21iaW5lcyB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCBvdGhlciBPYnNlcnZhYmxlcyB0byBjcmVhdGUgYW4gT2JzZXJ2YWJsZVxuICogd2hvc2UgdmFsdWVzIGFyZSBjYWxjdWxhdGVkIGZyb20gdGhlIGxhdGVzdCB2YWx1ZXMgb2YgZWFjaCwgb25seSB3aGVuIHRoZVxuICogc291cmNlIGVtaXRzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5XaGVuZXZlciB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSwgaXRcbiAqIGNvbXB1dGVzIGEgZm9ybXVsYSB1c2luZyB0aGF0IHZhbHVlIHBsdXMgdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSBvdGhlciBpbnB1dFxuICogT2JzZXJ2YWJsZXMsIHRoZW4gZW1pdHMgdGhlIG91dHB1dCBvZiB0aGF0IGZvcm11bGEuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2l0aExhdGVzdEZyb20ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHdpdGhMYXRlc3RGcm9tYCBjb21iaW5lcyBlYWNoIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlICh0aGVcbiAqIGluc3RhbmNlKSB3aXRoIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gdGhlIG90aGVyIGlucHV0IE9ic2VydmFibGVzIG9ubHkgd2hlblxuICogdGhlIHNvdXJjZSBlbWl0cyBhIHZhbHVlLCBvcHRpb25hbGx5IHVzaW5nIGEgYHByb2plY3RgIGZ1bmN0aW9uIHRvIGRldGVybWluZVxuICogdGhlIHZhbHVlIHRvIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBBbGwgaW5wdXQgT2JzZXJ2YWJsZXMgbXVzdFxuICogZW1pdCBhdCBsZWFzdCBvbmUgdmFsdWUgYmVmb3JlIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSB3aWxsIGVtaXQgYSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljayBldmVudCwgZW1pdCBhbiBhcnJheSB3aXRoIHRoZSBsYXRlc3QgdGltZXIgZXZlbnQgcGx1cyB0aGUgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2l0aExhdGVzdEZyb20odGltZXIpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lTGF0ZXN0fVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbWJpbmUgd2l0aCB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcm9qZWN0XSBQcm9qZWN0aW9uIGZ1bmN0aW9uIGZvciBjb21iaW5pbmcgdmFsdWVzXG4gKiB0b2dldGhlci4gUmVjZWl2ZXMgYWxsIHZhbHVlcyBpbiBvcmRlciBvZiB0aGUgT2JzZXJ2YWJsZXMgcGFzc2VkLCB3aGVyZSB0aGVcbiAqIGZpcnN0IHBhcmFtZXRlciBpcyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiAoZS5nLlxuICogYGEud2l0aExhdGVzdEZyb20oYiwgYywgKGExLCBiMSwgYzEpID0+IGExICsgYjEgKyBjMSlgKS4gSWYgdGhpcyBpcyBub3RcbiAqIHBhc3NlZCwgYXJyYXlzIHdpbGwgYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHByb2plY3RlZCB2YWx1ZXMgZnJvbSB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlcyBmcm9tIGVhY2ggaW5wdXQgT2JzZXJ2YWJsZSwgb3IgYW4gYXJyYXkgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlcyBmcm9tXG4gKiBlYWNoIGlucHV0IE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHdpdGhMYXRlc3RGcm9tXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbSgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBwcm9qZWN0O1xuICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb2plY3QgPSBhcmdzLnBvcCgpO1xuICAgIH1cbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBhcmdzO1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFdpdGhMYXRlc3RGcm9tT3BlcmF0b3Iob2JzZXJ2YWJsZXMsIHByb2plY3QpKTtcbn1cbmV4cG9ydHMud2l0aExhdGVzdEZyb20gPSB3aXRoTGF0ZXN0RnJvbTtcbnZhciBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yKG9ic2VydmFibGVzLCBwcm9qZWN0KSB7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZXMgPSBvYnNlcnZhYmxlcztcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICB9XG4gICAgV2l0aExhdGVzdEZyb21PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9ic2VydmFibGVzLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgb2JzZXJ2YWJsZXMsIHByb2plY3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gb2JzZXJ2YWJsZXM7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMudG9SZXNwb25kID0gW107XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZhYmxlcy5sZW5ndGg7XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudG9SZXNwb25kLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIG9ic2VydmFibGUgPSBvYnNlcnZhYmxlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZSwgaSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnZhbHVlc1tvdXRlckluZGV4XSA9IGlubmVyVmFsdWU7XG4gICAgICAgIHZhciB0b1Jlc3BvbmQgPSB0aGlzLnRvUmVzcG9uZDtcbiAgICAgICAgaWYgKHRvUmVzcG9uZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQgPSB0b1Jlc3BvbmQuaW5kZXhPZihvdXRlckluZGV4KTtcbiAgICAgICAgICAgIGlmIChmb3VuZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0b1Jlc3BvbmQuc3BsaWNlKGZvdW5kLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH07XG4gICAgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy50b1Jlc3BvbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFt2YWx1ZV0uY29uY2F0KHRoaXMudmFsdWVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2plY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cnlQcm9qZWN0KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcm9qZWN0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpdGhMYXRlc3RGcm9tLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9pdGVyYXRvcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQHBhcmFtIG9ic2VydmFibGVzXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fVxuICogQG1ldGhvZCB6aXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHppcFByb3RvKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0LmNhbGwoemlwU3RhdGljLmFwcGx5KHZvaWQgMCwgW3RoaXNdLmNvbmNhdChvYnNlcnZhYmxlcykpKTtcbn1cbmV4cG9ydHMuemlwUHJvdG8gPSB6aXBQcm90bztcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvIGNyZWF0ZSBhbiBPYnNlcnZhYmxlIHdob3NlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiBlYWNoXG4gKiBvZiBpdHMgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKlxuICogSWYgdGhlIGxhdGVzdCBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiwgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlIGNyZWF0ZWQgdmFsdWUgZnJvbSB0aGUgaW5wdXQgdmFsdWVzLlxuICogT3RoZXJ3aXNlLCBhbiBhcnJheSBvZiB0aGUgaW5wdXQgdmFsdWVzIGlzIHJldHVybmVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbWJpbmUgYWdlIGFuZCBuYW1lIGZyb20gZGlmZmVyZW50IHNvdXJjZXM8L2NhcHRpb24+XG4gKlxuICogbGV0IGFnZSQgPSBPYnNlcnZhYmxlLm9mPG51bWJlcj4oMjcsIDI1LCAyOSk7XG4gKiBsZXQgbmFtZSQgPSBPYnNlcnZhYmxlLm9mPHN0cmluZz4oJ0ZvbycsICdCYXInLCAnQmVlcicpO1xuICogbGV0IGlzRGV2JCA9IE9ic2VydmFibGUub2Y8Ym9vbGVhbj4odHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICpcbiAqIE9ic2VydmFibGVcbiAqICAgICAuemlwKGFnZSQsXG4gKiAgICAgICAgICBuYW1lJCxcbiAqICAgICAgICAgIGlzRGV2JCxcbiAqICAgICAgICAgIChhZ2U6IG51bWJlciwgbmFtZTogc3RyaW5nLCBpc0RldjogYm9vbGVhbikgPT4gKHsgYWdlLCBuYW1lLCBpc0RldiB9KSlcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIG91dHB1dHNcbiAqIC8vIHsgYWdlOiAyNywgbmFtZTogJ0ZvbycsIGlzRGV2OiB0cnVlIH1cbiAqIC8vIHsgYWdlOiAyNSwgbmFtZTogJ0JhcicsIGlzRGV2OiB0cnVlIH1cbiAqIC8vIHsgYWdlOiAyOSwgbmFtZTogJ0JlZXInLCBpc0RldjogZmFsc2UgfVxuICpcbiAqIEBwYXJhbSBvYnNlcnZhYmxlc1xuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn1cbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgemlwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB6aXBTdGF0aWMoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBwcm9qZWN0ID0gb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHR5cGVvZiBwcm9qZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9ic2VydmFibGVzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShvYnNlcnZhYmxlcykubGlmdChuZXcgWmlwT3BlcmF0b3IocHJvamVjdCkpO1xufVxuZXhwb3J0cy56aXBTdGF0aWMgPSB6aXBTdGF0aWM7XG52YXIgWmlwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFppcE9wZXJhdG9yKHByb2plY3QpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICB9XG4gICAgWmlwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBaaXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuWmlwT3BlcmF0b3IgPSBaaXBPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgWmlwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFppcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWmlwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkgeyB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5pdGVyYXRvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLnByb2plY3QgPSAodHlwZW9mIHByb2plY3QgPT09ICdmdW5jdGlvbicpID8gcHJvamVjdCA6IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgICAgIGlmIChpc0FycmF5XzEuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9ycy5wdXNoKG5ldyBTdGF0aWNBcnJheUl0ZXJhdG9yKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlW2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9ycy5wdXNoKG5ldyBTdGF0aWNJdGVyYXRvcih2YWx1ZVtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdG9ycy5wdXNoKG5ldyBaaXBCdWZmZXJJdGVyYXRvcih0aGlzLmRlc3RpbmF0aW9uLCB0aGlzLCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICAgICAgdmFyIGxlbiA9IGl0ZXJhdG9ycy5sZW5ndGg7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gbGVuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvcnNbaV07XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3Iuc3RpbGxVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChpdGVyYXRvci5zdWJzY3JpYmUoaXRlcmF0b3IsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlLS07IC8vIG5vdCBhbiBvYnNlcnZhYmxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUluYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZS0tO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuY2hlY2tJdGVyYXRvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICAgICAgdmFyIGxlbiA9IGl0ZXJhdG9ycy5sZW5ndGg7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIC8vIGFib3J0IGlmIG5vdCBhbGwgb2YgdGhlbSBoYXZlIHZhbHVlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvcnNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yLmhhc1ZhbHVlID09PSAnZnVuY3Rpb24nICYmICFpdGVyYXRvci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvcnNbaV07XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIGl0J3MgY29tcGxldGVkIG5vdyB0aGF0IHlvdSd2ZSBnb3R0ZW5cbiAgICAgICAgICAgIC8vIHRoZSBuZXh0IHZhbHVlLlxuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmhhc0NvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLnB1c2gocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9qZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl90cnlQcm9qZWN0KGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkQ29tcGxldGUpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcm9qZWN0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuWmlwU3Vic2NyaWJlciA9IFppcFN1YnNjcmliZXI7XG52YXIgU3RhdGljSXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRpY0l0ZXJhdG9yKGl0ZXJhdG9yKSB7XG4gICAgICAgIHRoaXMuaXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgICAgICAgdGhpcy5uZXh0UmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIH1cbiAgICBTdGF0aWNJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgU3RhdGljSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLm5leHRSZXN1bHQ7XG4gICAgICAgIHRoaXMubmV4dFJlc3VsdCA9IHRoaXMuaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU3RhdGljSXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSZXN1bHQgPSB0aGlzLm5leHRSZXN1bHQ7XG4gICAgICAgIHJldHVybiBuZXh0UmVzdWx0ICYmIG5leHRSZXN1bHQuZG9uZTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNJdGVyYXRvcjtcbn0oKSk7XG52YXIgU3RhdGljQXJyYXlJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljQXJyYXlJdGVyYXRvcihhcnJheSkge1xuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIH1cbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZVtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFN0YXRpY0FycmF5SXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICAgIHJldHVybiBpIDwgdGhpcy5sZW5ndGggPyB7IHZhbHVlOiBhcnJheVtpXSwgZG9uZTogZmFsc2UgfSA6IHsgdmFsdWU6IG51bGwsIGRvbmU6IHRydWUgfTtcbiAgICB9O1xuICAgIFN0YXRpY0FycmF5SXRlcmF0b3IucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggPiB0aGlzLmluZGV4O1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUuaGFzQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggPT09IHRoaXMuaW5kZXg7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljQXJyYXlJdGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFppcEJ1ZmZlckl0ZXJhdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWmlwQnVmZmVySXRlcmF0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWmlwQnVmZmVySXRlcmF0b3IoZGVzdGluYXRpb24sIHBhcmVudCwgb2JzZXJ2YWJsZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLnN0aWxsVW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5pc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgfVxuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZVtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIE5PVEU6IHRoZXJlIGlzIGFjdHVhbGx5IGEgbmFtZSBjb2xsaXNpb24gaGVyZSB3aXRoIFN1YnNjcmliZXIubmV4dCBhbmQgSXRlcmF0b3IubmV4dFxuICAgIC8vICAgIHRoaXMgaXMgbGVnaXQgYmVjYXVzZSBgbmV4dCgpYCB3aWxsIG5ldmVyIGJlIGNhbGxlZCBieSBhIHN1YnNjcmlwdGlvbiBpbiB0aGlzIGNhc2UuXG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDAgJiYgdGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGJ1ZmZlci5zaGlmdCgpLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQ29tcGxldGU7XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5SW5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbm5lclZhbHVlKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hlY2tJdGVyYXRvcnMoKTtcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHRoaXMub2JzZXJ2YWJsZSwgdGhpcywgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcEJ1ZmZlckl0ZXJhdG9yO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEltbWVkaWF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9JbW1lZGlhdGUnKTtcbnZhciBBc3luY0FjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc3luY0FjdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBBc2FwQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXNhcEFjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc2FwQWN0aW9uKHNjaGVkdWxlciwgd29yaykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy53b3JrID0gd29yaztcbiAgICB9XG4gICAgQXNhcEFjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIC8vIElmIGRlbGF5IGlzIGdyZWF0ZXIgdGhhbiAwLCByZXF1ZXN0IGFzIGFuIGFzeW5jIGFjdGlvbi5cbiAgICAgICAgaWYgKGRlbGF5ICE9PSBudWxsICYmIGRlbGF5ID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHVzaCB0aGUgYWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIHNjaGVkdWxlciBxdWV1ZS5cbiAgICAgICAgc2NoZWR1bGVyLmFjdGlvbnMucHVzaCh0aGlzKTtcbiAgICAgICAgLy8gSWYgYSBtaWNyb3Rhc2sgaGFzIGFscmVhZHkgYmVlbiBzY2hlZHVsZWQsIGRvbid0IHNjaGVkdWxlIGFub3RoZXJcbiAgICAgICAgLy8gb25lLiBJZiBhIG1pY3JvdGFzayBoYXNuJ3QgYmVlbiBzY2hlZHVsZWQgeWV0LCBzY2hlZHVsZSBvbmUgbm93LiBSZXR1cm5cbiAgICAgICAgLy8gdGhlIGN1cnJlbnQgc2NoZWR1bGVkIG1pY3JvdGFzayBpZC5cbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZWQgfHwgKHNjaGVkdWxlci5zY2hlZHVsZWQgPSBJbW1lZGlhdGVfMS5JbW1lZGlhdGUuc2V0SW1tZWRpYXRlKHNjaGVkdWxlci5mbHVzaC5iaW5kKHNjaGVkdWxlciwgbnVsbCkpKTtcbiAgICB9O1xuICAgIEFzYXBBY3Rpb24ucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICAvLyBJZiBkZWxheSBleGlzdHMgYW5kIGlzIGdyZWF0ZXIgdGhhbiAwLCBvciBpZiB0aGUgZGVsYXkgaXMgbnVsbCAodGhlXG4gICAgICAgIC8vIGFjdGlvbiB3YXNuJ3QgcmVzY2hlZHVsZWQpIGJ1dCB3YXMgb3JpZ2luYWxseSBzY2hlZHVsZWQgYXMgYW4gYXN5bmNcbiAgICAgICAgLy8gYWN0aW9uLCB0aGVuIHJlY3ljbGUgYXMgYW4gYXN5bmMgYWN0aW9uLlxuICAgICAgICBpZiAoKGRlbGF5ICE9PSBudWxsICYmIGRlbGF5ID4gMCkgfHwgKGRlbGF5ID09PSBudWxsICYmIHRoaXMuZGVsYXkgPiAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHNjaGVkdWxlciBxdWV1ZSBpcyBlbXB0eSwgY2FuY2VsIHRoZSByZXF1ZXN0ZWQgbWljcm90YXNrIGFuZFxuICAgICAgICAvLyBzZXQgdGhlIHNjaGVkdWxlZCBmbGFnIHRvIHVuZGVmaW5lZCBzbyB0aGUgbmV4dCBBc2FwQWN0aW9uIHdpbGwgc2NoZWR1bGVcbiAgICAgICAgLy8gaXRzIG93bi5cbiAgICAgICAgaWYgKHNjaGVkdWxlci5hY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgSW1tZWRpYXRlXzEuSW1tZWRpYXRlLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICAgICAgICAgIHNjaGVkdWxlci5zY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBzbyB0aGUgYWN0aW9uIGtub3dzIHRvIHJlcXVlc3QgYSBuZXcgYXN5bmMgaWQgaWYgaXQncyByZXNjaGVkdWxlZC5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHJldHVybiBBc2FwQWN0aW9uO1xufShBc3luY0FjdGlvbl8xLkFzeW5jQWN0aW9uKSk7XG5leHBvcnRzLkFzYXBBY3Rpb24gPSBBc2FwQWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXNhcEFjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEFzeW5jU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuL0FzeW5jU2NoZWR1bGVyJyk7XG52YXIgQXNhcFNjaGVkdWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzYXBTY2hlZHVsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXNhcFNjaGVkdWxlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIEFzYXBTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgdmFyIGNvdW50ID0gYWN0aW9ucy5sZW5ndGg7XG4gICAgICAgIGFjdGlvbiA9IGFjdGlvbiB8fCBhY3Rpb25zLnNoaWZ0KCk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9IGFjdGlvbi5leGVjdXRlKGFjdGlvbi5zdGF0ZSwgYWN0aW9uLmRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlICgrK2luZGV4IDwgY291bnQgJiYgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkpO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgY291bnQgJiYgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXNhcFNjaGVkdWxlcjtcbn0oQXN5bmNTY2hlZHVsZXJfMS5Bc3luY1NjaGVkdWxlcikpO1xuZXhwb3J0cy5Bc2FwU2NoZWR1bGVyID0gQXNhcFNjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzYXBTY2hlZHVsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXNhcEFjdGlvbl8xID0gcmVxdWlyZSgnLi9Bc2FwQWN0aW9uJyk7XG52YXIgQXNhcFNjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi9Bc2FwU2NoZWR1bGVyJyk7XG4vKipcbiAqXG4gKiBBc2FwIFNjaGVkdWxlclxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5QZXJmb3JtIHRhc2sgYXMgZmFzdCBhcyBpdCBjYW4gYmUgcGVyZm9ybWVkIGFzeW5jaHJvbm91c2x5PC9zcGFuPlxuICpcbiAqIGBhc2FwYCBzY2hlZHVsZXIgYmVoYXZlcyB0aGUgc2FtZSBhcyB7QGxpbmsgYXN5bmN9IHNjaGVkdWxlciB3aGVuIHlvdSB1c2UgaXQgdG8gZGVsYXkgdGFza1xuICogaW4gdGltZS4gSWYgaG93ZXZlciB5b3Ugc2V0IGRlbGF5IHRvIGAwYCwgYGFzYXBgIHdpbGwgd2FpdCBmb3IgY3VycmVudCBzeW5jaHJvbm91c2x5IGV4ZWN1dGluZ1xuICogY29kZSB0byBlbmQgYW5kIHRoZW4gaXQgd2lsbCB0cnkgdG8gZXhlY3V0ZSBnaXZlbiB0YXNrIGFzIGZhc3QgYXMgcG9zc2libGUuXG4gKlxuICogYGFzYXBgIHNjaGVkdWxlciB3aWxsIGRvIGl0cyBiZXN0IHRvIG1pbmltaXplIHRpbWUgYmV0d2VlbiBlbmQgb2YgY3VycmVudGx5IGV4ZWN1dGluZyBjb2RlXG4gKiBhbmQgc3RhcnQgb2Ygc2NoZWR1bGVkIHRhc2suIFRoaXMgbWFrZXMgaXQgYmVzdCBjYW5kaWRhdGUgZm9yIHBlcmZvcm1pbmcgc28gY2FsbGVkIFwiZGVmZXJyaW5nXCIuXG4gKiBUcmFkaXRpb25hbGx5IHRoaXMgd2FzIGFjaGlldmVkIGJ5IGNhbGxpbmcgYHNldFRpbWVvdXQoZGVmZXJyZWRUYXNrLCAwKWAsIGJ1dCB0aGF0IHRlY2huaXF1ZSBpbnZvbHZlc1xuICogc29tZSAoYWx0aG91Z2ggbWluaW1hbCkgdW53YW50ZWQgZGVsYXkuXG4gKlxuICogTm90ZSB0aGF0IHVzaW5nIGBhc2FwYCBzY2hlZHVsZXIgZG9lcyBub3QgbmVjZXNzYXJpbHkgbWVhbiB0aGF0IHlvdXIgdGFzayB3aWxsIGJlIGZpcnN0IHRvIHByb2Nlc3NcbiAqIGFmdGVyIGN1cnJlbnRseSBleGVjdXRpbmcgY29kZS4gSW4gcGFydGljdWxhciwgaWYgc29tZSB0YXNrIHdhcyBhbHNvIHNjaGVkdWxlZCB3aXRoIGBhc2FwYCBiZWZvcmUsXG4gKiB0aGF0IHRhc2sgd2lsbCBleGVjdXRlIGZpcnN0LiBUaGF0IGJlaW5nIHNhaWQsIGlmIHlvdSBuZWVkIHRvIHNjaGVkdWxlIHRhc2sgYXN5bmNocm9ub3VzbHksIGJ1dFxuICogYXMgc29vbiBhcyBwb3NzaWJsZSwgYGFzYXBgIHNjaGVkdWxlciBpcyB5b3VyIGJlc3QgYmV0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbXBhcmUgYXN5bmMgYW5kIGFzYXAgc2NoZWR1bGVyPC9jYXB0aW9uPlxuICpcbiAqIFJ4LlNjaGVkdWxlci5hc3luYy5zY2hlZHVsZSgoKSA9PiBjb25zb2xlLmxvZygnYXN5bmMnKSk7IC8vIHNjaGVkdWxpbmcgJ2FzeW5jJyBmaXJzdC4uLlxuICogUnguU2NoZWR1bGVyLmFzYXAuc2NoZWR1bGUoKCkgPT4gY29uc29sZS5sb2coJ2FzYXAnKSk7XG4gKlxuICogLy8gTG9nczpcbiAqIC8vIFwiYXNhcFwiXG4gKiAvLyBcImFzeW5jXCJcbiAqIC8vIC4uLiBidXQgJ2FzYXAnIGdvZXMgZmlyc3QhXG4gKlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBhc2FwXG4gKiBAb3duZXIgU2NoZWR1bGVyXG4gKi9cbmV4cG9ydHMuYXNhcCA9IG5ldyBBc2FwU2NoZWR1bGVyXzEuQXNhcFNjaGVkdWxlcihBc2FwQWN0aW9uXzEuQXNhcEFjdGlvbik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc2FwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xuZnVuY3Rpb24gc3ltYm9sSXRlcmF0b3JQb255ZmlsbChyb290KSB7XG4gICAgdmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICghU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICBTeW1ib2wuaXRlcmF0b3IgPSBTeW1ib2woJ2l0ZXJhdG9yIHBvbHlmaWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN5bWJvbC5pdGVyYXRvcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFtmb3IgTW96aWxsYSBHZWNrbyAyNy0zNTpdKGh0dHBzOi8vbXpsLmxhLzJld0UxekMpXG4gICAgICAgIHZhciBTZXRfMSA9IHJvb3QuU2V0O1xuICAgICAgICBpZiAoU2V0XzEgJiYgdHlwZW9mIG5ldyBTZXRfMSgpWydAQGl0ZXJhdG9yJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiAnQEBpdGVyYXRvcic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE1hcF8xID0gcm9vdC5NYXA7XG4gICAgICAgIC8vIHJlcXVpcmVkIGZvciBjb21wYXRhYmlsaXR5IHdpdGggZXM2LXNoaW1cbiAgICAgICAgaWYgKE1hcF8xKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE1hcF8xLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAvLyBhY2NvcmRpbmcgdG8gc3BlYywgTWFwLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSBhbmQgTWFwLm9yb3RvdHlwZS5lbnRyaWVzIG11c3QgYmUgZXF1YWwuXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2VudHJpZXMnICYmIGtleSAhPT0gJ3NpemUnICYmIE1hcF8xLnByb3RvdHlwZVtrZXldID09PSBNYXBfMS5wcm90b3R5cGVbJ2VudHJpZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0BAaXRlcmF0b3InO1xuICAgIH1cbn1cbmV4cG9ydHMuc3ltYm9sSXRlcmF0b3JQb255ZmlsbCA9IHN5bWJvbEl0ZXJhdG9yUG9ueWZpbGw7XG5leHBvcnRzLiQkaXRlcmF0b3IgPSBzeW1ib2xJdGVyYXRvclBvbnlmaWxsKHJvb3RfMS5yb290KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZXJhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGFuIGVsZW1lbnQgd2FzIHF1ZXJpZWQgYXQgYSBjZXJ0YWluIGluZGV4IG9mIGFuXG4gKiBPYnNlcnZhYmxlLCBidXQgbm8gc3VjaCBpbmRleCBvciBwb3NpdGlvbiBleGlzdHMgaW4gdGhhdCBzZXF1ZW5jZS5cbiAqXG4gKiBAc2VlIHtAbGluayBlbGVtZW50QXR9XG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICogQHNlZSB7QGxpbmsgdGFrZUxhc3R9XG4gKlxuICogQGNsYXNzIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXG4gKi9cbnZhciBBcmd1bWVudE91dE9mUmFuZ2VFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yKCkge1xuICAgICAgICB2YXIgZXJyID0gX3N1cGVyLmNhbGwodGhpcywgJ2FyZ3VtZW50IG91dCBvZiByYW5nZScpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdBcmd1bWVudE91dE9mUmFuZ2VFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yID0gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci5qcy5tYXAiLCIvKipcblNvbWUgY3JlZGl0IGZvciB0aGlzIGhlbHBlciBnb2VzIHRvIGh0dHA6Ly9naXRodWIuY29tL1l1enVKUy9zZXRJbW1lZGlhdGVcbiovXG5cInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbnZhciBJbW1lZGlhdGVEZWZpbml0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbW1lZGlhdGVEZWZpbml0aW9uKHJvb3QpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgaWYgKHJvb3Quc2V0SW1tZWRpYXRlICYmIHR5cGVvZiByb290LnNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5zZXRJbW1lZGlhdGUgPSByb290LnNldEltbWVkaWF0ZS5iaW5kKHJvb3QpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckltbWVkaWF0ZSA9IHJvb3QuY2xlYXJJbW1lZGlhdGUuYmluZChyb290KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dEhhbmRsZSA9IDE7XG4gICAgICAgICAgICB0aGlzLnRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpZiAodGhpcy5jYW5Vc2VQcm9jZXNzTmV4dFRpY2soKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgICAgICAgICB0aGlzLnNldEltbWVkaWF0ZSA9IHRoaXMuY3JlYXRlUHJvY2Vzc05leHRUaWNrU2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbW1lZGlhdGUgPSB0aGlzLmNyZWF0ZVBvc3RNZXNzYWdlU2V0SW1tZWRpYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNhblVzZU1lc3NhZ2VDaGFubmVsKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0SW1tZWRpYXRlID0gdGhpcy5jcmVhdGVNZXNzYWdlQ2hhbm5lbFNldEltbWVkaWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jYW5Vc2VSZWFkeVN0YXRlQ2hhbmdlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgICAgICAgICB0aGlzLnNldEltbWVkaWF0ZSA9IHRoaXMuY3JlYXRlUmVhZHlTdGF0ZUNoYW5nZVNldEltbWVkaWF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbW1lZGlhdGUgPSB0aGlzLmNyZWF0ZVNldFRpbWVvdXRTZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaSA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjbGVhckltbWVkaWF0ZS5pbnN0YW5jZS50YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2kuaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jbGVhckltbWVkaWF0ZSA9IGNpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmlkZW50aWZ5ID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5jYW5Vc2VQcm9jZXNzTmV4dFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkZW50aWZ5KHRoaXMucm9vdC5wcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuY2FuVXNlTWVzc2FnZUNoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMucm9vdC5NZXNzYWdlQ2hhbm5lbCk7XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5jYW5Vc2VSZWFkeVN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLnJvb3QuZG9jdW1lbnQ7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGRvY3VtZW50ICYmICdvbnJlYWR5c3RhdGVjaGFuZ2UnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKTtcbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmNhblVzZVBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgcm9vdC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChyb290LnBvc3RNZXNzYWdlICYmICFyb290LmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzXzEgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IHJvb3Qub25tZXNzYWdlO1xuICAgICAgICAgICAgcm9vdC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91c18xID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcm9vdC5wb3N0TWVzc2FnZSgnJywgJyonKTtcbiAgICAgICAgICAgIHJvb3Qub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXNfMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHNldEltbWVkaWF0ZSwgYnV0XG4gICAgLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmVxdWlyZXMgbm8gYXJndW1lbnRzLlxuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLnBhcnRpYWxseUFwcGxpZWQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiByZXN1bHQoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSByZXN1bHQsIGhhbmRsZXIgPSBfYS5oYW5kbGVyLCBhcmdzID0gX2EuYXJncztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIChuZXcgRnVuY3Rpb24oJycgKyBoYW5kbGVyKSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm4uaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIGZuLmFyZ3MgPSBhcmdzO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5hZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdGhpcy50YXNrc0J5SGFuZGxlW3RoaXMubmV4dEhhbmRsZV0gPSB0aGlzLnBhcnRpYWxseUFwcGxpZWQuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dEhhbmRsZSsrO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuY3JlYXRlUHJvY2Vzc05leHRUaWNrU2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBzZXRJbW1lZGlhdGUuaW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gaW5zdGFuY2UuYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgaW5zdGFuY2Uucm9vdC5wcm9jZXNzLm5leHRUaWNrKGluc3RhbmNlLnBhcnRpYWxseUFwcGxpZWQoaW5zdGFuY2UucnVuSWZQcmVzZW50LCBoYW5kbGUpKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgICAgIGZuLmluc3RhbmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuY3JlYXRlUG9zdE1lc3NhZ2VTZXRJbW1lZGlhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuICAgICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSAnc2V0SW1tZWRpYXRlJCcgKyByb290Lk1hdGgucmFuZG9tKCkgKyAnJCc7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbiBnbG9iYWxNZXNzYWdlSGFuZGxlcihldmVudCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZ2xvYmFsTWVzc2FnZUhhbmRsZXIuaW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSByb290ICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG9uR2xvYmFsTWVzc2FnZS5pbnN0YW5jZSA9IHRoaXM7XG4gICAgICAgIHJvb3QuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBzZXRJbW1lZGlhdGUsIG1lc3NhZ2VQcmVmaXggPSBfYS5tZXNzYWdlUHJlZml4LCBpbnN0YW5jZSA9IF9hLmluc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGluc3RhbmNlLmFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnJvb3QucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgJyonKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgICAgIGZuLmluc3RhbmNlID0gdGhpcztcbiAgICAgICAgZm4ubWVzc2FnZVByZWZpeCA9IG1lc3NhZ2VQcmVmaXg7XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLnJ1bklmUHJlc2VudCA9IGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogJ1dhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLidcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gJ3RvbyBtdWNoIHJlY3Vyc2lvbicgZXJyb3IuXG4gICAgICAgICAgICB0aGlzLnJvb3Quc2V0VGltZW91dCh0aGlzLnBhcnRpYWxseUFwcGxpZWQodGhpcy5ydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0aGlzLnRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEltbWVkaWF0ZURlZmluaXRpb24ucHJvdG90eXBlLmNyZWF0ZU1lc3NhZ2VDaGFubmVsU2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyB0aGlzLnJvb3QuTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgX3RoaXMucnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHNldEltbWVkaWF0ZSwgY2hhbm5lbCA9IF9hLmNoYW5uZWwsIGluc3RhbmNlID0gX2EuaW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gaW5zdGFuY2UuYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICAgICAgZm4uY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIGZuLmluc3RhbmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgSW1tZWRpYXRlRGVmaW5pdGlvbi5wcm90b3R5cGUuY3JlYXRlUmVhZHlTdGF0ZUNoYW5nZVNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gc2V0SW1tZWRpYXRlKCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gc2V0SW1tZWRpYXRlLmluc3RhbmNlO1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBpbnN0YW5jZS5yb290O1xuICAgICAgICAgICAgdmFyIGRvYyA9IHJvb3QuZG9jdW1lbnQ7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gaW5zdGFuY2UuYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgfTtcbiAgICAgICAgZm4uaW5zdGFuY2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfTtcbiAgICBJbW1lZGlhdGVEZWZpbml0aW9uLnByb3RvdHlwZS5jcmVhdGVTZXRUaW1lb3V0U2V0SW1tZWRpYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBzZXRJbW1lZGlhdGUuaW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gaW5zdGFuY2UuYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgICAgICAgaW5zdGFuY2Uucm9vdC5zZXRUaW1lb3V0KGluc3RhbmNlLnBhcnRpYWxseUFwcGxpZWQoaW5zdGFuY2UucnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgICAgIH07XG4gICAgICAgIGZuLmluc3RhbmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgcmV0dXJuIEltbWVkaWF0ZURlZmluaXRpb247XG59KCkpO1xuZXhwb3J0cy5JbW1lZGlhdGVEZWZpbml0aW9uID0gSW1tZWRpYXRlRGVmaW5pdGlvbjtcbmV4cG9ydHMuSW1tZWRpYXRlID0gbmV3IEltbWVkaWF0ZURlZmluaXRpb24ocm9vdF8xLnJvb3QpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1tZWRpYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGFuIGFjdGlvbiBpcyBpbnZhbGlkIGJlY2F1c2UgdGhlIG9iamVjdCBoYXMgYmVlblxuICogdW5zdWJzY3JpYmVkLlxuICpcbiAqIEBzZWUge0BsaW5rIFN1YmplY3R9XG4gKiBAc2VlIHtAbGluayBCZWhhdmlvclN1YmplY3R9XG4gKlxuICogQGNsYXNzIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXG4gKi9cbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9iamVjdFVuc3Vic2NyaWJlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCkge1xuICAgICAgICB2YXIgZXJyID0gX3N1cGVyLmNhbGwodGhpcywgJ29iamVjdCB1bnN1YnNjcmliZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5PYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmlzQXJyYXlMaWtlID0gKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcic7IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNBcnJheUxpa2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTigrdmFsdWUpO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0RhdGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNQcm9taXNlID0gaXNQcm9taXNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNQcm9taXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNTY2hlZHVsZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnNjaGVkdWxlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc1NjaGVkdWxlciA9IGlzU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNTY2hlZHVsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIHdpbmRvdzogYnJvd3NlciBpbiBET00gbWFpbiB0aHJlYWRcbiAqIHNlbGY6IGJyb3dzZXIgaW4gV2ViV29ya2VyXG4gKiBnbG9iYWw6IE5vZGUuanMvb3RoZXJcbiAqL1xuZXhwb3J0cy5yb290ID0gKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93LndpbmRvdyA9PT0gd2luZG93ICYmIHdpbmRvd1xuICAgIHx8IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmXG4gICAgfHwgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsKTtcbmlmICghZXhwb3J0cy5yb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSeEpTIGNvdWxkIG5vdCBmaW5kIGFueSBnbG9iYWwgY29udGV4dCAod2luZG93LCBzZWxmLCBnbG9iYWwpJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb290LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4vcm9vdCcpO1xudmFyIGlzQXJyYXlMaWtlXzEgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG52YXIgaXNQcm9taXNlXzEgPSByZXF1aXJlKCcuL2lzUHJvbWlzZScpO1xudmFyIGlzT2JqZWN0XzEgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGl0ZXJhdG9yXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvaXRlcmF0b3InKTtcbnZhciBJbm5lclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL0lubmVyU3Vic2NyaWJlcicpO1xudmFyIG9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG5mdW5jdGlvbiBzdWJzY3JpYmVUb1Jlc3VsdChvdXRlclN1YnNjcmliZXIsIHJlc3VsdCwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCkge1xuICAgIHZhciBkZXN0aW5hdGlvbiA9IG5ldyBJbm5lclN1YnNjcmliZXJfMS5Jbm5lclN1YnNjcmliZXIob3V0ZXJTdWJzY3JpYmVyLCBvdXRlclZhbHVlLCBvdXRlckluZGV4KTtcbiAgICBpZiAoZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5faXNTY2FsYXIpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuc3Vic2NyaWJlKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0FycmF5TGlrZV8xLmlzQXJyYXlMaWtlKHJlc3VsdCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW4gJiYgIWRlc3RpbmF0aW9uLmNsb3NlZDsgaSsrKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3VsdFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQcm9taXNlXzEuaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIWRlc3RpbmF0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGRlc3RpbmF0aW9uLmVycm9yKGVycik7IH0pXG4gICAgICAgICAgICAudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAvLyBFc2NhcGluZyB0aGUgUHJvbWlzZSB0cmFwOiBnbG9iYWxseSB0aHJvdyB1bmhhbmRsZWQgZXJyb3JzXG4gICAgICAgICAgICByb290XzEucm9vdC5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHRbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSByZXN1bHRbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSgpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W29ic2VydmFibGVfMS4kJG9ic2VydmFibGVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBvYnMgPSByZXN1bHRbb2JzZXJ2YWJsZV8xLiQkb2JzZXJ2YWJsZV0oKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnMuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgVHlwZUVycm9yKCdQcm92aWRlZCBvYmplY3QgZG9lcyBub3QgY29ycmVjdGx5IGltcGxlbWVudCBTeW1ib2wub2JzZXJ2YWJsZScpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvYnMuc3Vic2NyaWJlKG5ldyBJbm5lclN1YnNjcmliZXJfMS5Jbm5lclN1YnNjcmliZXIob3V0ZXJTdWJzY3JpYmVyLCBvdXRlclZhbHVlLCBvdXRlckluZGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGlzT2JqZWN0XzEuaXNPYmplY3QocmVzdWx0KSA/ICdhbiBpbnZhbGlkIG9iamVjdCcgOiBcIidcIiArIHJlc3VsdCArIFwiJ1wiO1xuICAgICAgICB2YXIgbXNnID0gKFwiWW91IHByb3ZpZGVkIFwiICsgdmFsdWUgKyBcIiB3aGVyZSBhIHN0cmVhbSB3YXMgZXhwZWN0ZWQuXCIpXG4gICAgICAgICAgICArICcgWW91IGNhbiBwcm92aWRlIGFuIE9ic2VydmFibGUsIFByb21pc2UsIEFycmF5LCBvciBJdGVyYWJsZS4nO1xuICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgVHlwZUVycm9yKG1zZykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuc3Vic2NyaWJlVG9SZXN1bHQgPSBzdWJzY3JpYmVUb1Jlc3VsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YnNjcmliZVRvUmVzdWx0LmpzLm1hcCIsIi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgdXJsIGlzIGV4dGVybmFsXG4gKlxuICogQHBhcmFtICAge3N0cmluZ30gICAgdXJsIC0gdXJsIGJlaW5nIGV2YWx1YXRlZFxuICogQHNlZSAgICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82MjM4MzUxL2Zhc3Rlc3Qtd2F5LXRvLWRldGVjdC1leHRlcm5hbC11cmxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVybmFsKHVybCkge1xuICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaCgvXihbXjpcXC8/I10rOik/KD86XFwvXFwvKFteXFwvPyNdKikpPyhbXj8jXSspPyhcXD9bXiNdKik/KCMuKik/Lyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcblxuICBpZiAodHlwZW9mIG1hdGNoWzFdID09PSAnc3RyaW5nJyAmJlxuICAgICAgbWF0Y2hbMV0ubGVuZ3RoID4gMCAmJlxuICAgICAgbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSAhPT0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sXG4gICAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBwb3J0ID0geyBodHRwOiA4MCwgaHR0cHM6IDQ0MyB9W3dpbmRvdy5sb2NhdGlvbi5wcm90b2NvbF07XG5cbiAgaWYgKHR5cGVvZiBtYXRjaFsyXSA9PT0gJ3N0cmluZycgJiZcbiAgICBtYXRjaFsyXS5sZW5ndGggPiAwICYmXG4gICAgbWF0Y2hbMl0ucmVwbGFjZShuZXcgUmVnRXhwKGA6KCR7cG9ydH0pPyRgKSwgJycpICE9PSB3aW5kb3cubG9jYXRpb24uaG9zdCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFN0cmlwcyB0aGUgaGFzaCBmcm9tIGEgdXJsIGFuZCByZXR1cm5zIHRoZSBuZXcgaHJlZlxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIGhyZWYgLSB1cmwgYmVpbmcgZXZhbHVhdGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEhhc2goaHJlZikge1xuICByZXR1cm4gaHJlZi5yZXBsYWNlKC8jLiovLCAnJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgdXJsIGlzIGFuIGludGVybmFsIGhhc2hcbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSAgICBocmVmIC0gdXJsIGJlaW5nIGV2YWx1YXRlZFxuICogQHBhcmFtICAge3N0cmluZ30gICAgcHJldiAtIHByZXZpb3VzIHVybCAob3B0aW9uYWwpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hhc2goaHJlZiwgcHJldikge1xuICBjb25zdCBwID0gcHJldiB8fCB3aW5kb3cubG9jYXRpb24uaHJlZjtcblxuICBjb25zdCBoYXNIYXNoID0gaHJlZi5pbmRleE9mKCcjJykgPiAtMTtcbiAgY29uc3Qgc2FtZVBhdGggPSBzdHJpcEhhc2goaHJlZikgPT09IHN0cmlwSGFzaChwKTtcblxuICByZXR1cm4gKGhhc0hhc2ggJiYgc2FtZVBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIChlbC5tYXRjaGVzIHx8IGVsLm1hdGNoZXNTZWxlY3RvciB8fCBlbC5tc01hdGNoZXNTZWxlY3RvciB8fCBlbC5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWwub01hdGNoZXNTZWxlY3RvcikuY2FsbChlbCwgc2VsZWN0b3IpO1xuICAvLyBpZiAoIW1hdGNoZXMubWVtbykge1xuICAvLyAgIG1hdGNoZXMubWVtbyA9XG4gIC8vICAgICBlbC5tYXRjaGVzIHx8XG4gIC8vICAgICBlbC5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgLy8gICAgIGVsLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gIC8vICAgICBlbC5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgLy8gICAgIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuICAvLyAgICAgZWwub01hdGNoZXNTZWxlY3RvcjtcbiAgLy8gfVxuICAvLyByZXR1cm4gbWF0Y2hlcy5tZW1vLmNhbGwoZWwsIHNlbGVjdG9yKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JJbnYoZWwsIHNlbGVjdG9yKSB7XG4gIGxldCBjdXJyID0gZWw7XG4gIHdoaWxlIChjdXJyICE9PSBkb2N1bWVudCAmJiBjdXJyICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICBpZiAobWF0Y2hlcyhjdXJyLCBzZWxlY3RvcikpIHJldHVybiBjdXJyO1xuICAgIGN1cnIgPSBjdXJyLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB3ZSBzaG91bGQgYmUgbG9hZGluZyB0aGlzIFVSTFxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIHVybCAtIHVybCBiZWluZyBldmFsdWF0ZWRcbiAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIGJsYWNrbGlzdCAtIGpxdWVyeSBzZWxlY3RvclxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkTG9hZEFuY2hvcihhbmNob3IsIGJsYWNrbGlzdCwgaHJlZlJlZ2V4KSB7XG4gIGNvbnN0IGhyZWYgPSBhbmNob3IuaHJlZjtcbiAgLy8gVVJMIHdpbGwgb25seSBiZSBsb2FkZWQgaWYgaXQncyBub3QgYW4gZXh0ZXJuYWwgbGluaywgaGFzaCwgb3JcbiAgLy8gYmxhY2tsaXN0ZWRcbiAgcmV0dXJuIChcbiAgICAhaXNFeHRlcm5hbChocmVmKSAmJlxuICAgICFpc0hhc2goaHJlZikgJiZcbiAgICAhbWF0Y2hlcyhhbmNob3IsIGJsYWNrbGlzdCkgJiZcbiAgICBhbmNob3IudGFyZ2V0ID09PSAnJyAmJiAoXG4gICAgICBocmVmUmVnZXggPT09IG51bGwgfHxcbiAgICAgIGhyZWYuc2VhcmNoKGhyZWZSZWdleCkgIT09IC0xXG4gICAgKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsSGVpZ2h0KCkge1xuICBjb25zdCBoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBjb25zdCBiID0gZG9jdW1lbnQuYm9keTtcbiAgY29uc3Qgc2ggPSAnc2Nyb2xsSGVpZ2h0JztcbiAgcmV0dXJuIGhbc2hdIHx8IGJbc2hdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsVG9wKCkge1xuICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0O1xufVxuIiwiLypcbiAqIEFkYXB0ZWQgZnJvbSBNaWd1ZWwgw4FuZ2VsIFDDqXJleidzIHNtb290aFN0YXRlLmpzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWlndWVsLXBlcmV6L3Ntb290aFN0YXRlLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZsb3JpYW4gS2xhbXBmZXJcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXMsIGltcG9ydC9uby11bnJlc29sdmVkLCBpbXBvcnQvZXh0ZW5zaW9ucyAqL1xuXG4vLyBjb25zdCBKU19GRUFUVVJFUyA9IFtcbi8vICAgJ2ZuL2FycmF5L2Zvci1lYWNoJyxcbi8vICAgJ2ZuL2Z1bmN0aW9uL2JpbmQnLFxuLy8gICAnZm4vbnVtYmVyL2NvbnN0cnVjdG9yJyxcbi8vICAgJ2ZuL29iamVjdC9hc3NpZ24nLFxuLy8gICAnZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eScsXG4vLyAgICdmbi9vYmplY3Qva2V5cycsXG4vLyBdO1xuLy9cbi8vIGNvbnN0IE1PREVSTklaUl9URVNUUyA9IFtcbi8vICAgJ2N1c3RvbWV2ZW50Jyxcbi8vICAgJ2RvY3VtZW50ZnJhZ21lbnQnLFxuLy8gICAnZXZlbnRsaXN0ZW5lcicsXG4vLyAgICdoaXN0b3J5Jyxcbi8vICAgJ3JlcXVlc3RhbmltYXRpb25mcmFtZScsXG4vLyAgICdxdWVyeXNlbGVjdG9yJyxcbi8vIF07XG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBhc2FwIH0gZnJvbSAncnhqcy9zY2hlZHVsZXIvYXNhcCc7XG5cbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9kZWZlcic7XG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvZW1wdHknO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvbWVyZ2UnO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL29mJztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS90aHJvdyc7XG5cbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9kb20vYWpheCc7XG5cbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvY2F0Y2gnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9kZWxheSc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvZG8nO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9maWx0ZXInO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tYXAnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tZXJnZSc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL21lcmdlQWxsJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivb2JzZXJ2ZU9uJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivc2hhcmUnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9zdGFydFdpdGgnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9zd2l0Y2gnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9zd2l0Y2hNYXAnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci90YWtlJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivd2l0aExhdGVzdEZyb20nO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci96aXAnO1xuXG5pbXBvcnQgY29tcG9uZW50Q29yZSBmcm9tICd5LWNvbXBvbmVudC9zcmMvY29tcG9uZW50LWNvcmUnO1xuXG5pbXBvcnQgeyBzaG91bGRMb2FkQW5jaG9yLCBnZXRTY3JvbGxUb3AsIGdldFNjcm9sbEhlaWdodCB9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgeyBQdXNoLCBIaW50LCBQb3AgfSBmcm9tICcuL2tpbmQnO1xuXG5jb25zdCBkZWYgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkuYmluZChPYmplY3QpO1xuXG5mdW5jdGlvbiBmcmFnbWVudEZyb21TdHJpbmcoc3RySFRNTCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKS5jcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQoc3RySFRNTCk7XG59XG5cbi8vIH4gbWl4aW4gcHVzaFN0YXRlQ29yZSB3aXRoIGNvbXBvbmVudENvcmUgeyAuLi5cbmV4cG9ydCBkZWZhdWx0IEMgPT4gY2xhc3MgZXh0ZW5kcyBjb21wb25lbnRDb3JlKEMpIHtcblxuICAvLyBAb3ZlcnJpZGVcbiAgZ2V0Q29tcG9uZW50TmFtZSgpIHtcbiAgICByZXR1cm4gJ3ktcHVzaC1zdGF0ZSc7XG4gIH1cblxuICAvLyBAb3ZlcnJpZGVcbiAgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcGxhY2VJZHM6IFtdLFxuICAgICAgbGlua1NlbGVjdG9yOiAnYVtocmVmXScsXG4gICAgICBzY3JvbGxSZXN0b3JhdGlvbjogZmFsc2UsXG4gICAgICBocmVmUmVnZXg6IG51bGwsXG4gICAgICBibGFja2xpc3Q6IG51bGwsXG4gICAgICBkdXJhdGlvbjogMCxcbiAgICB9O1xuICB9XG5cbiAgLy8gQG92ZXJyaWRlXG4gIHNpZGVFZmZlY3RzKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHN0YXJ0SGlzdG9yeSgpIHtcbiAgICB0aGlzLmNoZWNrUHJlQ29uZGl0aW9uKCk7XG4gICAgdGhpcy5zZXR1cFNjcm9sbFJlc3RvcmF0aW9uKCk7XG4gICAgdGhpcy5yZXNldFNjcm9sbFBvc3Rpb24oKTtcbiAgICB0aGlzLmNhY2hlVGl0bGVFbGVtZW50KCk7XG4gICAgdGhpcy5zZXR1cE9ic2VydmFibGVzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjaGVja1ByZUNvbmRpdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZXBsYWNlSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmVsLmlkO1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gcmVwbGFjZSBpZHMgcHJvdmlkZWQuIFdpbGwgcmVwbGFjZSBlbnRpcmUgY29udGVudCBvZiAjJHtpZH1gKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcignTm8gcmVwbGFjZSBpZHMgcHJvdmlkZWQgbm9yIGRvZXMgdGhpcyBjb21wb25lbnQgaGF2ZSBhbmQgaWQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0dXBTY3JvbGxSZXN0b3JhdGlvbigpIHtcbiAgICBpZiAoJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiBoaXN0b3J5KSB7XG4gICAgICBpZiAodGhpcy5zY3JvbGxSZXN0b3JhdGlvbikgaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnO1xuICAgICAgZWxzZSBoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICB0aGlzLnJlc2V0U2Nyb2xsUG9zdGlvbigpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsICgpID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVIaXN0b3J5U3RhdGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlVGl0bGVFbGVtZW50KCkge1xuICAgIGRlZih0aGlzLCAndGl0bGVFbGVtZW50JywgeyB2YWx1ZTogZG9jdW1lbnQucXVlcnlTZWxlY3RvcigndGl0bGUnKSB8fCB7fSB9KTtcbiAgfVxuXG4gIGJpbmRQdXNoRXZlbnRzKGxpbmskKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbUV2ZW50cyhsaW5rJCwgJ2NsaWNrJylcbiAgICAgIC5tYXAoZXZlbnQgPT4gbmV3IFB1c2goZXZlbnQpKVxuICAgICAgLmZpbHRlcihraW5kID0+IHRoaXMuaXNQYWdlQ2hhbmdlRXZlbnQoa2luZCkpXG4gICAgICAuZG8oKHsgZXZlbnQgfSkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUhpc3RvcnlTdGF0ZSgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG4gIH1cblxuICBiaW5kSGludEV2ZW50cyhsaW5rJCkge1xuICAgIHJldHVybiBPYnNlcnZhYmxlLm1lcmdlKFxuICAgICAgICB0aGlzLmZyb21FdmVudHMobGluayQsICdtb3VzZWVudGVyJyksXG4gICAgICAgIHRoaXMuZnJvbUV2ZW50cyhsaW5rJCwgJ3RvdWNoc3RhcnQnKSlcbiAgICAgIC5tZXJnZShcbiAgICAgICAgdGhpcy5mcm9tRXZlbnRzKGxpbmskLCAnZm9jdXMnKSlcbiAgICAgIC5tYXAoZXZlbnQgPT4gbmV3IEhpbnQoZXZlbnQpKVxuICAgICAgLmZpbHRlcihraW5kID0+IHRoaXMuaXNQYWdlQ2hhbmdlQW5jaG9yKGtpbmQpKTtcbiAgfVxuXG4gIGJpbmRQb3BzdGF0ZUV2ZW50KCkge1xuICAgIHJldHVybiBPYnNlcnZhYmxlLmZyb21FdmVudCh3aW5kb3csICdwb3BzdGF0ZScpXG4gICAgICAubWFwKGV2ZW50ID0+IG5ldyBQb3AoZXZlbnQpKVxuICAgICAgLmZpbHRlcigoKSA9PiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSAhPSBudWxsKTtcbiAgfVxuXG4gIGxpbmtPYnNlcnZhYmxlKCkge1xuICAgIHJldHVybiBPYnNlcnZhYmxlLm9mKHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCh0aGlzLmxpbmtTZWxlY3RvcikpO1xuICB9XG5cbiAgZnJvbUV2ZW50cyhsaW5rJCwgZXZlbnQpIHtcbiAgICByZXR1cm4gbGluayQubWFwKGxpbmsgPT4gT2JzZXJ2YWJsZS5mcm9tRXZlbnQobGluaywgZXZlbnQpKS5tZXJnZUFsbCgpO1xuICB9XG5cbiAgZmV0Y2hQYWdlKGtpbmQpIHtcbiAgICBjb25zdCByZXF1ZXN0RGF0YSA9IHRoaXMuaHJlZlRvUmVxdWVzdERhdGEoa2luZCk7XG4gICAgcmV0dXJuIE9ic2VydmFibGVcbiAgICAgIC5hamF4KHJlcXVlc3REYXRhKVxuICAgICAgLm1hcCgoeyByZXNwb25zZSB9KSA9PiBPYmplY3QuYXNzaWduKGtpbmQsIHsgcmVzcG9uc2UgfSkpXG4gICAgICAuY2F0Y2goZXJyb3IgPT4gdGhpcy5yZWNvdmVyV2hlblJlc3BvbnNlKGtpbmQsIGVycm9yKSk7XG4gIH1cblxuICBocmVmVG9SZXF1ZXN0RGF0YSh7IGhyZWYgfSkge1xuICAgIHJldHVybiB7XG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgdXJsOiBocmVmLFxuICAgICAgcmVzcG9uc2VUeXBlOiAndGV4dCcsXG4gICAgfTtcbiAgfVxuXG4gIHJlY292ZXJXaGVuUmVzcG9uc2Uoa2luZCwgZXJyb3IpIHtcbiAgICBjb25zdCB7IHN0YXR1cywgeGhyIH0gPSBlcnJvcjtcblxuICAgIGlmIChzdGF0dXMgJiYgc3RhdHVzID4gNDAwICYmIHhocikge1xuICAgICAgLy8gUmVjb3ZlciB3aXRoIGVycm9yIHBhZ2UgcmV0dXJuZWQgZnJvbSBzZXJ2ZXIuXG4gICAgICAvLyBBc3N1bWVzIGVycm9yIHBhZ2UgY29udGFpbnMgdGhlIHNhbWUgaWRzIGFzIG90aGVyIHBhZ2VzLlxuICAgICAgcmV0dXJuIE9ic2VydmFibGUub2YoT2JqZWN0LmFzc2lnbihraW5kLCB7IHJlc3BvbnNlOiB4aHIucmVzcG9uc2UgfSkpO1xuICAgIH1cblxuICAgIC8vIFRPRE86IERvbid0IHRocm93IGhlcmU/XG4gICAgcmV0dXJuIE9ic2VydmFibGUudGhyb3coZXJyb3IpO1xuICB9XG5cbiAgc2V0dXBPYnNlcnZhYmxlcygpIHtcbiAgICAvLyBTZWUgYHJlbmV3RXZlbnRMaXN0ZW5lcnNgXG4gICAgLy8gVE9ETzogUG9zc2libGUgd2l0aG91dCBzdWJqZWN0cz9cbiAgICB0aGlzLnB1c2gkJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgdGhpcy5oaW50JCQgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgY29uc3QgcHVzaCQgPSB0aGlzLnB1c2gkJC5zd2l0Y2goKTtcbiAgICBjb25zdCBwb3AkID0gdGhpcy5iaW5kUG9wc3RhdGVFdmVudCgpO1xuXG4gICAgLy8gRGVmaW5pdGl2ZSBwYWdlIGNoYW5nZSAoaS5lLiBlaXRoZXIgcHVzaCBvciBwb3AgZXZlbnQpXG4gICAgdGhpcy5wYWdlJCA9IE9ic2VydmFibGUubWVyZ2UocHVzaCQsIHBvcCQpO1xuXG4gICAgLy8gV2FpdCBhdCBsZWFzdCBhcyBsb25nIGFzIGl0IHRha2VzIGZvciB0aGUgYW5pbWF0aW9uIHRvIGZpbmlzaCBiZWZvcmUgY2hhbmdpbmcgdGhlIERPTVxuICAgIC8vIChkZWZhdWx0ID0gMG1zKVxuICAgIHRoaXMuYW5pbWF0aW9uJCA9IHRoaXMucGFnZSQuZGVsYXkodGhpcy5kdXJhdGlvbik7XG5cbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIHByZWZldGNoIChpLmUuIHVzZSBiYW5kd2lkdGgpIGZvciBhIF9wcm9iYWJpbGlzdGljXyBwYWdlIGxvYWQsXG4gICAgLy8gd2hpbGUgYSBfZGVmaW5pdGl2ZV8gcGFnZSBsb2FkIGlzIGdvaW5nIG9uID0+IGBwYXVzZXIkYCBzdHJlYW0uXG4gICAgLy8gTmVlZHMgdG8gYmUgZGVmZXJyZWQgYi9jIG9mIFwiY3ljbGljYWxcIiBkZXBlbmRlbmN5LlxuICAgIGNvbnN0IHBhdXNlciQgPSBPYnNlcnZhYmxlLmRlZmVyKCgpID0+XG4gICAgICBPYnNlcnZhYmxlLm1lcmdlKFxuICAgICAgICAvLyBBIHBhZ2UgY2hhbmdlIGV2ZW50IG1lYW5zIHdlIHdhbnQgdG8gcGF1c2UgcHJlZmV0Y2hpbmdcbiAgICAgICAgdGhpcy5wYWdlJC5tYXAoKCkgPT4gdHJ1ZSksXG4gICAgICAgIC8vIEEgcmVuZGVyIGNvbXBsZXRlIGV2ZW50IG1lYW5zIHdlIHdhbnQgdG8gcmVzdW1lIHByZWZldGNoaW5nXG4gICAgICAgIHRoaXMucmVuZGVyJC5tYXAoKCkgPT4gZmFsc2UpLFxuICAgICAgKVxuICAgICAgICAvLyBTdGFydCB3aXRoIHByZWZldGNoaW5nXG4gICAgICAgIC5zdGFydFdpdGgoZmFsc2UpLFxuICAgICk7XG5cbiAgICAvLyBUaGUgc3RyZWFtIG9mIGhpbnQgKHByZWZldGNoKSBldmVudHMsIHBvc3NpYmx5IHBhdXNlZC5cbiAgICAvLyBEcmVhbSBzeW50YXggKG5vdCBzdXBwb3J0ZWQsIHlldCk6IGB0aGlzLmhpbnQkJC5zd2l0Y2goKS5wYXVzZWFibGUocGF1c2VyJClgXG4gICAgdGhpcy5oaW50JCA9IHRoaXMuaGludCQkLnN3aXRjaCgpXG4gICAgICAud2l0aExhdGVzdEZyb20ocGF1c2VyJClcbiAgICAgIC5zd2l0Y2hNYXAoKFtoaW50LCBwYXVzZWRdKSA9PiAocGF1c2VkID9cbiAgICAgICAgT2JzZXJ2YWJsZS5lbXB0eSgpIDpcbiAgICAgICAgT2JzZXJ2YWJsZS5vZihoaW50KSksXG4gICAgICApO1xuXG4gICAgLy8gVGhlIHN0cmVhbSBvZiAocHJlLSlmZXRjaCBldmVudHMuXG4gICAgLy8gSW5jbHVkZXMgZGVmaW5pdGl2ZSBwYWdlIGNoYW5nZSBldmVudHMgZG8gZGVhbCB3aXRoIHVuZXhwZWN0ZWQgcGFnZSBjaGFuZ2VzLlxuICAgIGNvbnN0IHByZWZldGNoJCA9IE9ic2VydmFibGUubWVyZ2UodGhpcy5oaW50JCwgdGhpcy5wYWdlJClcbiAgICAgIC5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgnaHJlZicpIC8vIERvbid0IGFib3J0IGEgcmVxdWVzdCBpZiB0aGUgdXNlciBcImppZ2dsZXNcIiBvdmVyIGEgbGlua1xuICAgICAgLnN3aXRjaE1hcChraW5kID0+IHRoaXMuZmV0Y2hQYWdlKGtpbmQpKVxuICAgICAgLnN0YXJ0V2l0aCh7fSkgLy8gU3RhcnQgd2l0aCBzb21lIHZhbHVlIHNvIGB3aXRoTGF0ZXN0RnJvbWAgYmVsb3cgZG9lc24ndCBcImJsb2NrXCJcbiAgICAgIC5zaGFyZSgpO1xuXG4gICAgdGhpcy5yZW5kZXIkID0gdGhpcy5wYWdlJFxuICAgICAgLmRvKHRoaXMuc2V0V2lsbENoYW5nZS5iaW5kKHRoaXMpKVxuICAgICAgLmRvKHRoaXMub25CZWZvcmUuYmluZCh0aGlzKSlcbiAgICAgIC53aXRoTGF0ZXN0RnJvbShwcmVmZXRjaCQpXG4gICAgICAuc3dpdGNoTWFwKChba2luZCwgcHJlZmV0Y2hdKSA9PiAoa2luZC5ocmVmID09PSBwcmVmZXRjaC5ocmVmID9cbiAgICAgICAgICAvLyBQcmVmZXRjaCBhbHJlYWR5IGNvbXBsZXRlLCB1c2UgcmVzdWx0XG4gICAgICAgICAgT2JzZXJ2YWJsZS5vZihba2luZCwgcHJlZmV0Y2hdKSA6XG4gICAgICAgICAgLy8gUHJlZmV0Y2ggaW4gcHJvZ3Jlc3MsIHVzZSBuZXh0IHJlc3VsdCAodGhpcyBpcyB3aHkgYHByZWZldGNoJGAgaGFkIHRvIGJlIGBzaGFyZWBkKVxuICAgICAgICAgIHByZWZldGNoJC50YWtlKDEpLm1hcChmZXRjaCA9PiBba2luZCwgZmV0Y2hdKVxuICAgICAgKSlcbiAgICAgIC8vIGVuc3VyZSBgZHVyYXRpb25gIG1zIGhhdmUgcGFzc2VkIHNpbmNlIHRoZSBldmVudFxuICAgICAgLnppcCh0aGlzLmFuaW1hdGlvbiQsIHggPT4geClcbiAgICAgIC5kbygoW2tpbmQsIHByZWZldGNoXSkgPT4gdGhpcy51cGRhdGVET00oa2luZCwgcHJlZmV0Y2gpKVxuICAgICAgLmRvKHRoaXMub25BZnRlci5iaW5kKHRoaXMpKVxuICAgICAgLy8gUHVzaCByZW5ld2luZyBldmVudCBsaXN0ZW5lcnMgb3V0IGFmdGVyIGxheW91dC9wYWludGluZyBpcyBjb21wbGV0ZVxuICAgICAgLm9ic2VydmVPbihhc2FwKVxuICAgICAgLmRvKHRoaXMudW5zZXRXaWxsQ2hhbmdlLmJpbmQodGhpcykpXG4gICAgICAuZG8odGhpcy5yZW5ld0V2ZW50TGlzdGVuZXJzLmJpbmQodGhpcykpXG4gICAgICAvLyBgc2hhcmVgaW5nIHRoZSBzdHJlYW0gYmV0d2VlbiB0aGUgc3Vic2NyaXB0aW9uIGJlbG93IGFuZCBgcGF1c2VyJGAuXG4gICAgICAuc2hhcmUoKTtcblxuICAgIC8vIFN0YXJ0IHB1bGxpbmcgdmFsdWVzXG4gICAgdGhpcy5yZW5kZXIkLnN1YnNjcmliZSgoKSA9PiB7fSk7XG5cbiAgICAvLyBQdXNoIHN0cmVhbXMgaW50byBgcHVzaCQkYCBhbmQgYGhpbnQkJGBcbiAgICB0aGlzLnJlbmV3RXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIHJlbmV3RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgbGluayQgPSB0aGlzLmxpbmtPYnNlcnZhYmxlKCk7XG4gICAgdGhpcy5wdXNoJCQubmV4dCh0aGlzLmJpbmRQdXNoRXZlbnRzKGxpbmskKSk7XG4gICAgdGhpcy5oaW50JCQubmV4dCh0aGlzLmJpbmRIaW50RXZlbnRzKGxpbmskKSk7XG4gIH1cblxuICB1cGRhdGVET00oa2luZCwgeyByZXNwb25zZSB9KSB7XG4gICAgY29uc3QgeyBocmVmIH0gPSBraW5kO1xuICAgIGNvbnN0IHsgdGl0bGUsIGNvbnRlbnQgfSA9IHRoaXMucmVzcG9uc2VUb0hUTUwocmVzcG9uc2UpO1xuXG4gICAgaWYgKGtpbmQgaW5zdGFuY2VvZiBQdXNoKSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoeyBpZDogdGhpcy5jb21wb25lbnROYW1lIH0sIHRpdGxlLCBocmVmKTtcbiAgICB9XG5cbiAgICB0aGlzLnRpdGxlRWxlbWVudC50ZXh0Q29udGVudCA9IHRpdGxlO1xuICAgIHRoaXMucmVzZXRTY3JvbGxQb3N0aW9uKCk7XG4gICAgdGhpcy5yZXBsYWNlQ29udGVudChjb250ZW50KTtcbiAgfVxuXG4gIHJlc3BvbnNlVG9IVE1MKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgZG9jdW1lbnRGcmFnbWVudCA9IGZyYWdtZW50RnJvbVN0cmluZyhyZXNwb25zZSk7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLmdldFRpdGxlRnJvbURvY3VtZW50RnJhZ21lbnQoZG9jdW1lbnRGcmFnbWVudCk7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudEZyb21Eb2N1bWVudEZyYWdtZW50KGRvY3VtZW50RnJhZ21lbnQpO1xuICAgIHJldHVybiB7IHRpdGxlLCBjb250ZW50IH07XG4gIH1cblxuICBvbkJlZm9yZSgpIHtcbiAgICB0aGlzLmZpcmVFdmVudCgnYmVmb3JlJyk7XG4gIH1cblxuICBvbkFmdGVyKCkge1xuICAgIHRoaXMuZmlyZUV2ZW50KCdhZnRlcicpO1xuICB9XG5cbiAgLy8gb25FcnJvcigpIHtcbiAgLy8gICB0aGlzLmVsLnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgLy8gICBkb2N1bWVudC5ib2R5LnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgLy8gICB0aGlzLmZpcmVFdmVudCgnZXJyb3InKTtcbiAgLy8gfVxuXG4gIHNldFdpbGxDaGFuZ2UoKSB7XG4gICAgLy8gdGhpcy5lbC5zdHlsZS53aWxsQ2hhbmdlID0gJ2NvbnRlbnQnO1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUud2lsbENoYW5nZSA9ICdzY3JvbGwtcG9zaXRpb24nO1xuICB9XG5cbiAgdW5zZXRXaWxsQ2hhbmdlKCkge1xuICAgIC8vIHRoaXMuZWwuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIGRvY3VtZW50LmJvZHkuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICB9XG5cbiAgaXNQYWdlQ2hhbmdlRXZlbnQoa2luZCkge1xuICAgIGNvbnN0IHsgZXZlbnQgfSA9IGtpbmQ7XG4gICAgcmV0dXJuIChcbiAgICAgICFldmVudC5tZXRhS2V5ICYmXG4gICAgICAhZXZlbnQuY3RybEtleSAmJlxuICAgICAgdGhpcy5pc1BhZ2VDaGFuZ2VBbmNob3Ioa2luZClcbiAgICApO1xuICB9XG5cbiAgaXNQYWdlQ2hhbmdlQW5jaG9yKHsgZXZlbnQ6IHsgY3VycmVudFRhcmdldDogYW5jaG9yIH0gfSkge1xuICAgIHJldHVybiAoXG4gICAgICBhbmNob3IgIT0gbnVsbCAmJlxuICAgICAgc2hvdWxkTG9hZEFuY2hvcihhbmNob3IsIHRoaXMuYmxhY2tsaXN0LCB0aGlzLmhyZWZSZWdleClcbiAgICApO1xuICB9XG5cbiAgZ2V0VGl0bGVGcm9tRG9jdW1lbnRGcmFnbWVudChkb2N1bWVudEZyYWdtZW50KSB7XG4gICAgcmV0dXJuIChkb2N1bWVudEZyYWdtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RpdGxlJykgfHwge30pLnRleHRDb250ZW50O1xuICB9XG5cbiAgZ2V0Q29udGVudEZyb21Eb2N1bWVudEZyYWdtZW50KGRvY3VtZW50RnJhZ21lbnQpIHtcbiAgICBpZiAodGhpcy5yZXBsYWNlSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VJZHMubWFwKGlkID0+IGRvY3VtZW50RnJhZ21lbnQucXVlcnlTZWxlY3RvcihgIyR7aWR9YCkpO1xuICAgIH1cblxuICAgIHJldHVybiBkb2N1bWVudEZyYWdtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZWwuaWQpO1xuICB9XG5cbiAgcmVwbGFjZUNvbnRlbnQoY29udGVudCkge1xuICAgIGlmICh0aGlzLnJlcGxhY2VJZHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5yZXBsYWNlQ29udGVudEJ5SWRzKGNvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlcGxhY2VDb250ZW50V2hvbGVzYWxlKGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IFJlbmFtZVxuICBjaGVja0NvbmRpdGlvbihvbGRFbGVtZW50cywgY29udGVudCkge1xuICAgIC8vIFRPRE86IEp1c3QgcmVwbGFjZSBleGlzdGluZyBpZHMsIHJlbW92ZSBtaXNzaW5nIGlkZXNcbiAgICAvLyBUT0RPOiBSZW1vdmUgaW4gcHJvZHVjdGlvbiBidWlsZHNcbiAgICBpZiAoY29udGVudC5sZW5ndGggIT09IG9sZEVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJOZXcgZG9jdW1lbnQgZG9lc24ndCBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBpZHNcIik7XG4gICAgfVxuICB9XG5cbiAgcmVwbGFjZUNvbnRlbnRCeUlkcyhjb250ZW50KSB7XG4gICAgY29uc3Qgb2xkRWxlbWVudHMgPSB0aGlzLnJlcGxhY2VJZHNcbiAgICAgIC5tYXAoaWQgPT4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcblxuICAgIHRoaXMuY2hlY2tDb25kaXRpb24ob2xkRWxlbWVudHMsIGNvbnRlbnQpO1xuXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChvbGRFbGVtZW50cywgKG9sZEVsZW1lbnQpID0+IHtcbiAgICAgIG9sZEVsZW1lbnQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoY29udGVudC5zaGlmdCgpLCBvbGRFbGVtZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlcGxhY2VDb250ZW50V2hvbGVzYWxlKGNvbnRlbnQpIHtcbiAgICB0aGlzLmVsLmlubmVySFRNTCA9IGNvbnRlbnQuaW5uZXJIVE1MO1xuICB9XG5cbiAgc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHN0YXRlLCB7XG4gICAgICAgIHNjcm9sbFRvcDogZ2V0U2Nyb2xsVG9wKCksXG4gICAgICAgIHNjcm9sbEhlaWdodDogZ2V0U2Nyb2xsSGVpZ2h0KCksXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgdXBkYXRlSGlzdG9yeVN0YXRlKCkge1xuICAgIGNvbnN0IHN0YXRlID0gaGlzdG9yeS5zdGF0ZSB8fCB7IGlkOiB0aGlzLmNvbXBvbmVudE5hbWUgfTtcbiAgICBjb25zdCBzdGF0ZVdpdGhTY3JvbGxQb3NpdGlvbiA9IHRoaXMuc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlKTtcbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZVdpdGhTY3JvbGxQb3NpdGlvbiwgZG9jdW1lbnQudGl0bGUsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgfVxuXG4gIHJlc2V0U2Nyb2xsUG9zdGlvbigpIHtcbiAgICBpZiAodGhpcy5zY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgY29uc3Qgc3RhdGUgPSBoaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5taW5IZWlnaHQgPSBgJHtzdGF0ZS5zY3JvbGxIZWlnaHQgfHwgMH1weGA7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8od2luZG93LnBhZ2VYT2Zmc2V0LCBzdGF0ZS5zY3JvbGxUb3AgfHwgMCk7XG4gICAgfVxuICB9XG59O1xuIiwiZXhwb3J0IGNsYXNzIEtpbmQge1xuICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHVzaCBleHRlbmRzIEtpbmQge1xuICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgIHN1cGVyKGV2ZW50KTtcbiAgICB0aGlzLmhyZWYgPSBldmVudC5jdXJyZW50VGFyZ2V0LmhyZWY7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEhpbnQgZXh0ZW5kcyBLaW5kIHtcbiAgY29uc3RydWN0b3IoZXZlbnQpIHtcbiAgICBzdXBlcihldmVudCk7XG4gICAgdGhpcy5ocmVmID0gZXZlbnQuY3VycmVudFRhcmdldC5ocmVmO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBQb3AgZXh0ZW5kcyBLaW5kIHtcbiAgY29uc3RydWN0b3IoZXZlbnQpIHtcbiAgICBzdXBlcihldmVudCk7XG4gICAgdGhpcy5ocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmxvcmlhbiBLbGFtcGZlclxuICogTGljZW5zZWQgdW5kZXIgTUlUXG4gKi9cbmltcG9ydCBwdXNoU3RhdGVDb3JlIGZyb20gJy4uL2NvcmUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXNoU3RhdGUgZXh0ZW5kcyBwdXNoU3RhdGVDb3JlKCkge1xuICBjb25zdHJ1Y3RvcihlbCwgcHJvcHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2V0dXBDb21wb25lbnQoZWwsIHByb3BzKTtcbiAgfVxuXG4gIC8vIEBvdmVycmlkZVxuICBzZXR1cERPTShlbCkge1xuICAgIGlmICghZWwpIHRocm93IEVycm9yKCdObyBlbGVtZW50IHByb3ZpZGVkJyk7XG4gICAgcmV0dXJuIGVsO1xuICB9XG59XG4iXX0=
