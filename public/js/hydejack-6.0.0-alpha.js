(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

/*! modernizr 3.4.0 (Custom Build) | MIT *
 * https://modernizr.com/download/?-classlist-cssanimations-csspointerevents-cssremunit-csstransforms-dataset-documentfragment-eventlistener-history-matchmedia-opacity-queryselector-requestanimationframe-touchevents !*/
!function (e, t, n) {
  function r(e, t) {
    return typeof e === t;
  }function o() {
    var e, t, n, o, i, s, a;for (var u in g) if (g.hasOwnProperty(u)) {
      if (e = [], t = g[u], t.name && (e.push(t.name.toLowerCase()), t.options && t.options.aliases && t.options.aliases.length)) for (n = 0; n < t.options.aliases.length; n++) e.push(t.options.aliases[n].toLowerCase());for (o = r(t.fn, "function") ? t.fn() : t.fn, i = 0; i < e.length; i++) s = e[i], a = s.split("."), 1 === a.length ? Modernizr[a[0]] = o : (!Modernizr[a[0]] || Modernizr[a[0]] instanceof Boolean || (Modernizr[a[0]] = new Boolean(Modernizr[a[0]])), Modernizr[a[0]][a[1]] = o), S.push((o ? "" : "no-") + a.join("-"));
    }
  }function i(e) {
    return e.replace(/([a-z])-([a-z])/g, function (e, t, n) {
      return t + n.toUpperCase();
    }).replace(/^-/, "");
  }function s() {
    return "function" != typeof t.createElement ? t.createElement(arguments[0]) : w ? t.createElementNS.call(t, "http://www.w3.org/2000/svg", arguments[0]) : t.createElement.apply(t, arguments);
  }function a() {
    var e = t.body;return e || (e = s(w ? "svg" : "body"), e.fake = !0), e;
  }function u(e, n, r, o) {
    var i,
        u,
        l,
        f,
        d = "modernizr",
        c = s("div"),
        p = a();if (parseInt(r, 10)) for (; r--;) l = s("div"), l.id = o ? o[r] : d + (r + 1), c.appendChild(l);return i = s("style"), i.type = "text/css", i.id = "s" + d, (p.fake ? p : c).appendChild(i), p.appendChild(c), i.styleSheet ? i.styleSheet.cssText = e : i.appendChild(t.createTextNode(e)), c.id = d, p.fake && (p.style.background = "", p.style.overflow = "hidden", f = T.style.overflow, T.style.overflow = "hidden", T.appendChild(p)), u = n(c, e), p.fake ? (p.parentNode.removeChild(p), T.style.overflow = f, T.offsetHeight) : c.parentNode.removeChild(c), !!u;
  }function l(e, t) {
    return !!~("" + e).indexOf(t);
  }function f(e, t) {
    return function () {
      return e.apply(t, arguments);
    };
  }function d(e, t, n) {
    var o;for (var i in e) if (e[i] in t) return n === !1 ? e[i] : (o = t[e[i]], r(o, "function") ? f(o, n || t) : o);return !1;
  }function c(e) {
    return e.replace(/([A-Z])/g, function (e, t) {
      return "-" + t.toLowerCase();
    }).replace(/^ms-/, "-ms-");
  }function p(t, n, r) {
    var o;if ("getComputedStyle" in e) {
      o = getComputedStyle.call(e, t, n);var i = e.console;if (null !== o) r && (o = o.getPropertyValue(r));else if (i) {
        var s = i.error ? "error" : "log";i[s].call(i, "getComputedStyle returning null, its possible modernizr test results are inaccurate");
      }
    } else o = !n && t.currentStyle && t.currentStyle[r];return o;
  }function m(t, r) {
    var o = t.length;if ("CSS" in e && "supports" in e.CSS) {
      for (; o--;) if (e.CSS.supports(c(t[o]), r)) return !0;return !1;
    }if ("CSSSupportsRule" in e) {
      for (var i = []; o--;) i.push("(" + c(t[o]) + ":" + r + ")");return i = i.join(" or "), u("@supports (" + i + ") { #modernizr { position: absolute; } }", function (e) {
        return "absolute" == p(e, null, "position");
      });
    }return n;
  }function v(e, t, o, a) {
    function u() {
      d && (delete P.style, delete P.modElem);
    }if (a = r(a, "undefined") ? !1 : a, !r(o, "undefined")) {
      var f = m(e, o);if (!r(f, "undefined")) return f;
    }for (var d, c, p, v, y, h = ["modernizr", "tspan", "samp"]; !P.style && h.length;) d = !0, P.modElem = s(h.shift()), P.style = P.modElem.style;for (p = e.length, c = 0; p > c; c++) if (v = e[c], y = P.style[v], l(v, "-") && (v = i(v)), P.style[v] !== n) {
      if (a || r(o, "undefined")) return u(), "pfx" == t ? v : !0;try {
        P.style[v] = o;
      } catch (g) {}if (P.style[v] != y) return u(), "pfx" == t ? v : !0;
    }return u(), !1;
  }function y(e, t, n, o, i) {
    var s = e.charAt(0).toUpperCase() + e.slice(1),
        a = (e + " " + z.join(s + " ") + s).split(" ");return r(t, "string") || r(t, "undefined") ? v(a, t, o, i) : (a = (e + " " + E.join(s + " ") + s).split(" "), d(a, t, n));
  }function h(e, t, r) {
    return y(e, n, n, t, r);
  }var g = [],
      C = { _version: "3.4.0", _config: { classPrefix: "", enableClasses: !0, enableJSClass: !0, usePrefixes: !0 }, _q: [], on: function (e, t) {
      var n = this;setTimeout(function () {
        t(n[e]);
      }, 0);
    }, addTest: function (e, t, n) {
      g.push({ name: e, fn: t, options: n });
    }, addAsyncTest: function (e) {
      g.push({ name: null, fn: e });
    } },
      Modernizr = function () {};Modernizr.prototype = C, Modernizr = new Modernizr(), Modernizr.addTest("eventlistener", "addEventListener" in e), Modernizr.addTest("history", function () {
    var t = navigator.userAgent;return -1 === t.indexOf("Android 2.") && -1 === t.indexOf("Android 4.0") || -1 === t.indexOf("Mobile Safari") || -1 !== t.indexOf("Chrome") || -1 !== t.indexOf("Windows Phone") || "file:" === location.protocol ? e.history && "pushState" in e.history : !1;
  }), Modernizr.addTest("queryselector", "querySelector" in t && "querySelectorAll" in t);var S = [],
      x = C._config.usePrefixes ? " -webkit- -moz- -o- -ms- ".split(" ") : ["", ""];C._prefixes = x;var T = t.documentElement;Modernizr.addTest("classlist", "classList" in T), Modernizr.addTest("documentfragment", function () {
    return "createDocumentFragment" in t && "appendChild" in T;
  });var w = "svg" === T.nodeName.toLowerCase();Modernizr.addTest("opacity", function () {
    var e = s("a").style;return e.cssText = x.join("opacity:.55;"), /^0.55$/.test(e.opacity);
  }), Modernizr.addTest("csspointerevents", function () {
    var e = s("a").style;return e.cssText = "pointer-events:auto", "auto" === e.pointerEvents;
  }), Modernizr.addTest("cssremunit", function () {
    var e = s("a").style;try {
      e.fontSize = "3rem";
    } catch (t) {}return (/rem/.test(e.fontSize)
    );
  }), Modernizr.addTest("dataset", function () {
    var e = s("div");return e.setAttribute("data-a-b", "c"), !(!e.dataset || "c" !== e.dataset.aB);
  });var _ = C.testStyles = u;Modernizr.addTest("touchevents", function () {
    var n;if ("ontouchstart" in e || e.DocumentTouch && t instanceof DocumentTouch) n = !0;else {
      var r = ["@media (", x.join("touch-enabled),("), "heartz", ")", "{#modernizr{top:9px;position:absolute}}"].join("");_(r, function (e) {
        n = 9 === e.offsetTop;
      });
    }return n;
  });var b = "Moz O ms Webkit",
      z = C._config.usePrefixes ? b.split(" ") : [];C._cssomPrefixes = z;var A = function (t) {
    var r,
        o = x.length,
        i = e.CSSRule;if ("undefined" == typeof i) return n;if (!t) return !1;if (t = t.replace(/^@/, ""), r = t.replace(/-/g, "_").toUpperCase() + "_RULE", r in i) return "@" + t;for (var s = 0; o > s; s++) {
      var a = x[s],
          u = a.toUpperCase() + "_" + r;if (u in i) return "@-" + a.toLowerCase() + "-" + t;
    }return !1;
  };C.atRule = A;var E = C._config.usePrefixes ? b.toLowerCase().split(" ") : [];C._domPrefixes = E;var O = { elem: s("modernizr") };Modernizr._q.push(function () {
    delete O.elem;
  });var P = { style: O.elem.style };Modernizr._q.unshift(function () {
    delete P.style;
  }), C.testAllProps = y;var q = C.prefixed = function (e, t, n) {
    return 0 === e.indexOf("@") ? A(e) : (-1 != e.indexOf("-") && (e = i(e)), t ? y(e, t, n) : y(e, "pfx"));
  };Modernizr.addTest("requestanimationframe", !!q("requestAnimationFrame", e), { aliases: ["raf"] }), Modernizr.addTest("matchmedia", !!q("matchMedia", e)), C.testAllProps = h, Modernizr.addTest("cssanimations", h("animationName", "a", !0)), Modernizr.addTest("csstransforms", function () {
    return -1 === navigator.userAgent.indexOf("Android 2.") && h("transform", "scale(1)", !0);
  }), o(), delete C.addTest, delete C.addAsyncTest;for (var L = 0; L < Modernizr._q.length; L++) Modernizr._q[L]();e.Modernizr = Modernizr;
}(window, document);

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unhide = undefined;
exports.hasFeatures = hasFeatures;
exports.show = show;
exports.hide = hide;
exports.unshow = unshow;
exports.defineCustomElement = defineCustomElement;
exports.ensureCustomElements = ensureCustomElements;
exports.matches = matches;
exports.animate = animate;

var _Observable = require('rxjs/Observable');

require('../lib/modernizr');

function hasFeatures(features) {
  let acc = true;
  for (let i = 0; i < features.length; i += 1) {
    const feature = features[i];
    const hasFeature = window.Modernizr[feature];
    // if (!hasFeature) console.warn('Feature "' + feature + '" missing!');
    acc = acc && hasFeature;
  }
  return acc;
}

function show(el) {
  el.style.display = 'block'; // eslint-disable-line no-param-reassign
  el.style.visibility = 'visible'; // eslint-disable-line no-param-reassign
}

function hide(el) {
  el.style.display = 'none'; // eslint-disable-line no-param-reassign
  el.style.visibility = 'hidden'; // eslint-disable-line no-param-reassign
}

function unshow(el) {
  el.style.display = ''; // eslint-disable-line no-param-reassign
  el.style.visibility = ''; // eslint-disable-line no-param-reassign
}

const unhide = exports.unhide = unshow;

function defineCustomElement(tagName, CustomHTMLElement) {
  if ('customElements' in window) {
    customElements.define(tagName, CustomHTMLElement);
  } else if ('registerElement' in document) {
    document.registerElement(tagName, CustomHTMLElement);
  }
}

function ensureCustomElements(f) {
  if ('customElements' in window || 'registerElement' in document) {
    f();
  } else {
    if (!window.loadingCustomElements) loadJSDeferred('https://unpkg.com/webcomponents.js@0.7.22/CustomElements.min.js');
    window.loadingCustomElements = true;
    window.addEventListener('WebComponentsReady', f);
  }
}

function matches(el, selector) {
  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
}

function animate(el, keyframes, options) {
  return _Observable.Observable.create(observer => {
    const anim = el.animate(keyframes, options);

    anim.addEventListener('finish', e => {
      observer.next(e);
      observer.complete();
    });

    return () => {
      // if (anim.playState !== 'finished') anim.cancel();
    };
  });
}

},{"../lib/modernizr":1,"rxjs/Observable":107}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Observable = require('rxjs/Observable');

var _empty = require('rxjs/observable/empty');

var _fromEvent = require('rxjs/observable/fromEvent');

var _timer = require('rxjs/observable/timer');

var _do = require('rxjs/operator/do');

var _finally = require('rxjs/operator/finally');

var _map = require('rxjs/operator/map');

var _zip = require('rxjs/operator/zip');

var _common = require('./common');

const { find } = Array.prototype; /*
                                  eslint-disable
                                  no-param-reassign,
                                  import/no-extraneous-dependencies,
                                  import/no-unresolved,
                                  import/extensions,
                                  class-methods-use-this,
                                  */

function updateStyle({ font = 'serif', fontHeading = 'sans-serif', color = '#00f' } = {}) {
  this.rules[0].style.fontFamily = font; // html
  this.rules[1].style.fontFamily = fontHeading; // h1, h2, h3, h4, h5, h6, .heading
  this.rules[2].style.color = color; // .content a
  this.rules[3].style.outlineColor = color; // :focus
  this.rules[4].style.backgroundColor = color; // ::selection
}

class CrossFader {
  constructor({ duration }) {
    var _context;

    this.sidebar = document.getElementById('_sidebar');
    this.duration = duration;

    const pageStyle = document.getElementById('_pageStyle');
    const styleSheet = (_context = document.styleSheets, find).call(_context, ss => ss.ownerNode === pageStyle);
    this.rules = styleSheet.cssRules || styleSheet.rules;
    this.lastImage = document.getElementById('_main').getAttribute('data-image');
  }

  fetchImage(dataset) {
    var _context3;

    const { color, image } = dataset;

    if (image === this.lastImage) {
      return _empty.empty.call(_Observable.Observable);
    }

    let res$;
    if (image === '') {
      res$ = _timer.timer.call(_Observable.Observable, this.duration);
    } else {
      var _context2;

      const imgObj = new Image();

      res$ = (_context2 = (_context2 = _fromEvent.fromEvent.call(_Observable.Observable, imgObj, 'load'), _zip.zipProto).call(_context2, _timer.timer.call(_Observable.Observable, this.duration), x => x), _finally._finally).call(_context2, () => {
        imgObj.src = '';
      });

      imgObj.src = image;
    }

    return (_context3 = (_context3 = res$, _do._do).call(_context3, () => {
      updateStyle.call(this, dataset);
      this.lastImage = image;
    }), _map.map).call(_context3, () => {
      const div = document.createElement('div');
      div.classList.add('sidebar-bg');
      div.style.backgroundColor = color;
      if (image !== '') div.style.backgroundImage = `url(${image})`;
      return div;
    });
  }

  crossFade([prevDiv, div]) {
    var _context4;

    prevDiv.parentNode.insertBefore(div, prevDiv.nextElementSibling);

    return (_context4 = (0, _common.animate)(div, [{ opacity: 0 }, { opacity: 1 }], {
      duration: this.duration
    }), _finally._finally).call(_context4, () => prevDiv.parentNode.removeChild(prevDiv));
  }
}
exports.default = CrossFader;

},{"./common":2,"rxjs/Observable":107,"rxjs/observable/empty":121,"rxjs/observable/fromEvent":122,"rxjs/observable/timer":124,"rxjs/operator/do":128,"rxjs/operator/finally":131,"rxjs/operator/map":132,"rxjs/operator/zip":141}],4:[function(require,module,exports){
'use strict';

var _vanilla = require('y-drawer/src/vanilla');

var _vanilla2 = _interopRequireDefault(_vanilla);

var _common = require('./common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

const REQUIREMENTS = ['eventlistener', 'queryselector', 'matchmedia', 'requestanimationframe', 'classlist', 'opacity', 'csstransforms', 'csspointerevents', 'cssremunit'];

const MEDIA_QUERY = '(min-width: 801px)';

function resizeCallback() {
  const hasChanged = window.isDesktop !== window.matchMedia(MEDIA_QUERY).matches;
  if (hasChanged) {
    window.isDesktop = !window.isDesktop;
    window.drawer.persistent = window.isDesktop;
    window.drawer.jumpTo(window.isDesktop);
  }
}

function menuClickClallback(e) {
  if (!window.isDesktop) {
    e.preventDefault();
    window.drawer.toggle();
  }
}

function addEventListeners(drawer) {
  window.drawer = drawer;
  window.addEventListener('resize', resizeCallback);
  document.getElementById('_menu').addEventListener('click', menuClickClallback);
}

if ((0, _common.hasFeatures)(REQUIREMENTS)) {
  window.isDesktop = window.matchMedia(MEDIA_QUERY).matches;
  const drawer = document.getElementById('_yDrawer');

  addEventListeners(new _vanilla2.default(drawer, {
    opened: window.isDesktop,
    persistent: window.isDesktop,
    transitionDuration: 150
  }));

  drawer.classList.add('loaded');
}

},{"./common":2,"y-drawer/src/vanilla":168}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Observable = require('rxjs/Observable');

var _empty = require('rxjs/observable/empty');

/*
eslint-disable
class-methods-use-this
*/

class Flip {
  static create(type, ...args) {
    return Flip.types[type] != null ? new Flip.types[type](...args) : new Flip(...args);
  }

  constructor({ shadowMain, duration }) {
    this.shadowMain = shadowMain;
    this.duration = duration;
  }

  start() {
    return _empty.empty.call(_Observable.Observable);
  }

  ready() {
    return _empty.empty.call(_Observable.Observable);
  }
}

exports.default = Flip;
Flip.types = {};

},{"rxjs/Observable":107,"rxjs/observable/empty":121}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Observable = require('rxjs/Observable');

var _of = require('rxjs/observable/of');

var _fromEvent = require('rxjs/observable/fromEvent');

var _timer = require('rxjs/observable/timer');

var _do = require('rxjs/operator/do');

var _finally = require('rxjs/operator/finally');

var _zip = require('rxjs/operator/zip');

var _common = require('../common');

var _flip = require('./flip');

var _flip2 = _interopRequireDefault(_flip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ProjectFlip extends _flip2.default {
  start(currentTarget) {
    var _context;

    const img = currentTarget.querySelector('.img');

    this.shadowMain.querySelector('.page').innerHTML = `
      <h1 class="page-title" style="opacity:0">|</h1>
      <div class="post-date heading" style="opacity:0">|</div>
    `;

    const placeholder = document.createElement('div');
    placeholder.classList.add('sixteen-nine');

    img.parentNode.insertBefore(placeholder, img);
    img.classList.add('lead');
    img.style.transformOrigin = 'left top';

    this.shadowMain.querySelector('.page').appendChild(img);
    this.shadowMain.style.position = 'fixed';
    this.shadowMain.style.opacity = 1;

    const first = placeholder.getBoundingClientRect();
    const last = img.getBoundingClientRect();

    const invertX = first.left - last.left;
    const invertY = first.top - last.top;
    const invertScale = first.width / last.width;

    return (_context = (0, _common.animate)(img, [{ transform: `translate3d(${invertX}px, ${invertY}px, 0) scale(${invertScale})` }, { transform: 'translate3d(0, 0, 0) scale(1)' }], {
      duration: this.duration,
      // easing: 'ease',
      easing: 'cubic-bezier(0,0,0.32,1)'
    }), _do._do).call(_context, () => {
      this.shadowMain.style.position = 'absolute';
    });
  }

  ready(main) {
    var _context2;

    this.shadowMain.style.willChange = 'opacity';

    const img = main.querySelector('.img');

    if (img != null) {
      img.style.opacity = 0;
      img.style.willChange = 'opacity';
    }

    const realImg = img.querySelector('img');
    return (_context2 = (_context2 = (_context2 = realImg == null ? _of.of.call(_Observable.Observable, true) : _fromEvent.fromEvent.call(_Observable.Observable, realImg, 'load'),
    // HACK: add some extra time to prevent hiccups
    _zip.zipProto).call(_context2, _timer.timer.call(_Observable.Observable, this.duration + 100)), _do._do).call(_context2, () => {
      if (img != null) {
        img.style.opacity = 1;
        img.style.willChange = '';
      }
    }), _finally._finally).call(_context2, () => {
      this.shadowMain.style.opacity = 0;
      this.shadowMain.style.willChange = '';
    });
  }
}

exports.default = ProjectFlip; /*
                               eslint-disable
                               no-param-reassign,
                               import/no-extraneous-dependencies,
                               import/no-unresolved,
                               import/extensions,
                               class-methods-use-this,
                               */

_flip2.default.types.project = ProjectFlip;

},{"../common":2,"./flip":5,"rxjs/Observable":107,"rxjs/observable/fromEvent":122,"rxjs/observable/of":123,"rxjs/observable/timer":124,"rxjs/operator/do":128,"rxjs/operator/finally":131,"rxjs/operator/zip":141}],7:[function(require,module,exports){
'use strict';

var _Observable = require('rxjs/Observable');

var _timer = require('rxjs/observable/timer');

var _do = require('rxjs/operator/do');

var _finally = require('rxjs/operator/finally');

var _common = require('../common');

var _flip = require('./flip');

var _flip2 = _interopRequireDefault(_flip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
eslint-disable
no-param-reassign,
import/no-extraneous-dependencies,
import/no-unresolved,
import/extensions,
class-methods-use-this,
*/

const TITLE_SELECTOR = '.page-title, .post-title';

class TitleFlip extends _flip2.default {
  start(currentTarget) {
    var _context;

    const title = document.createElement('h1');

    title.classList.add('page-title');
    title.textContent = currentTarget.textContent;
    title.style.transformOrigin = 'left top';

    this.shadowMain.querySelector('.page').innerHTML = '';
    this.shadowMain.querySelector('.page').appendChild(title);
    this.shadowMain.style.position = 'fixed';
    this.shadowMain.style.opacity = 1;

    const first = currentTarget.getBoundingClientRect();
    const firstFontSize = parseInt(getComputedStyle(currentTarget).fontSize, 10);
    const last = title.getBoundingClientRect();
    const lastFontSize = parseInt(getComputedStyle(title).fontSize, 10);

    const invertX = first.left - last.left;
    const invertY = first.top - last.top;
    const invertScale = firstFontSize / lastFontSize;

    currentTarget.style.opacity = 0;

    return (_context = (0, _common.animate)(title, [{ transform: `translate3d(${invertX}px, ${invertY}px, 0) scale(${invertScale})` }, { transform: 'translate3d(0, 0, 0) scale(1)' }], {
      duration: this.duration,
      // easing: 'ease',
      easing: 'cubic-bezier(0,0,0.32,1)'
    }), _do._do).call(_context, () => {
      this.shadowMain.style.position = 'absolute';
    });
  }

  ready(main) {
    var _context2;

    this.shadowMain.style.willChange = 'opacity';

    const title = main.querySelector(TITLE_SELECTOR);

    if (title != null) {
      title.style.opacity = 0;
      title.style.willChange = 'opacity';
    }

    // HACK: add some extra time to prevent hiccups
    return (_context2 = (_context2 = _timer.timer.call(_Observable.Observable, this.duration + 100), _do._do).call(_context2, () => {
      if (title != null) {
        title.style.opacity = 1;
        title.style.willChange = '';
      }
    }), _finally._finally).call(_context2, () => {
      this.shadowMain.style.opacity = 0;
      this.shadowMain.style.willChange = '';
    });
  }
}

_flip2.default.types.title = TitleFlip;

},{"../common":2,"./flip":5,"rxjs/Observable":107,"rxjs/observable/timer":124,"rxjs/operator/do":128,"rxjs/operator/finally":131}],8:[function(require,module,exports){
'use strict';

require('core-js/fn/array/for-each');

require('core-js/fn/function/bind');

require('core-js/fn/number/constructor');

require('core-js/fn/object/assign');

require('core-js/fn/object/define-property');

require('core-js/fn/object/keys');

require('core-js/fn/array/reduce');

require('web-animations-js');

require('./style');

require('./katex');

require('./drawer');

require('./push-state');

},{"./drawer":4,"./katex":9,"./push-state":10,"./style":11,"core-js/fn/array/for-each":12,"core-js/fn/array/reduce":13,"core-js/fn/function/bind":14,"core-js/fn/number/constructor":15,"core-js/fn/object/assign":16,"core-js/fn/object/define-property":17,"core-js/fn/object/keys":18,"web-animations-js":164}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = upgradeMathBlocks;

var _loadCSS = require('fg-loadcss/src/loadCSS');

var _katex = require('katex');

var _katex2 = _interopRequireDefault(_katex);

var _common = require('./common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const REQUIREMENTS = ['eventlistener', 'queryselector']; /* eslint-disable no-param-reassign */

function willChangeContent(mathBlocks) {
  Array.prototype.forEach.call(mathBlocks, el => {
    el.style.willChange = 'content'; // eslint-disable-line no-param-reassign
  });
}

function replaceMathBlock(el, tex) {
  el.outerHTML = _katex2.default.renderToString(tex, {
    displayMode: el.type === 'math/tex; mode=display'
  });
}

function renderKatex(el, tex) {
  try {
    const prev = el.previousElementSibling;
    replaceMathBlock(el, tex);
    if (prev && (0, _common.matches)(prev, '.MathJax_Preview')) (0, _common.hide)(prev);
  } catch (e) {
    // TODO: remove in production builds?
    console.error(e); // eslint-disable-line no-console
  } finally {
    el.style.willChange = '';
  }
}

function readTexSource(el) {
  return el.textContent.replace('% <![CDATA[', '').replace('%]]>', '');
}

function changeContent(mathBlocks) {
  // kramdown generates script tags with type "math/tex"
  Array.prototype.forEach.call(mathBlocks, script => {
    const tex = readTexSource(script);
    renderKatex(script, tex);
  });
}

function upgradeMathBlocks() {
  if ((0, _common.hasFeatures)(REQUIREMENTS)) {
    const mathBlocks = document.querySelectorAll('script[type^="math/tex"]');
    if (mathBlocks.length) {
      willChangeContent(mathBlocks);
      changeContent(mathBlocks);
    }
  }
}

if ((0, _common.hasFeatures)(REQUIREMENTS)) {
  const ref = document.getElementsByTagName('style')[0];
  const style = (0, _loadCSS.loadCSS)('https://unpkg.com/katex@0.6.0/dist/katex.min.css', ref);
  style.addEventListener('load', upgradeMathBlocks);
}

},{"./common":2,"fg-loadcss/src/loadCSS":80,"katex":81}],10:[function(require,module,exports){
'use strict';

var _Observable = require('rxjs/Observable');

var _fromEvent = require('rxjs/observable/fromEvent');

var _catch = require('rxjs/operator/catch');

var _do = require('rxjs/operator/do');

var _debounceTime = require('rxjs/operator/debounceTime');

var _exhaustMap = require('rxjs/operator/exhaustMap');

var _filter = require('rxjs/operator/filter');

var _map = require('rxjs/operator/map');

var _mergeMap = require('rxjs/operator/mergeMap');

var _pairwise = require('rxjs/operator/pairwise');

var _share = require('rxjs/operator/share');

var _startWith = require('rxjs/operator/startWith');

var _switchMap = require('rxjs/operator/switchMap');

var _takeUntil = require('rxjs/operator/takeUntil');

var _zip = require('rxjs/operator/zip');

var _vanilla = require('y-push-state/src/vanilla');

var _vanilla2 = _interopRequireDefault(_vanilla);

var _common = require('./common');

var _crossFader = require('./cross-fader');

var _crossFader2 = _interopRequireDefault(_crossFader);

var _katex = require('./katex');

var _katex2 = _interopRequireDefault(_katex);

var _flip = require('./flip/flip');

var _flip2 = _interopRequireDefault(_flip);

require('./flip/title');

require('./flip/project');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
eslint-disable
no-param-reassign,
import/no-extraneous-dependencies,
import/no-unresolved,
import/extensions
*/

const REQUIREMENTS = ['eventlistener', 'queryselector', 'requestanimationframe', 'classlist', 'documentfragment', 'history', 'opacity', 'cssanimations', 'dataset'];

const DURATION = 250;
const FADE_DURATION = 600;

// whenever the source observable encounters an error,
// we log it to the console, but continue as if it never happend
function makeUnstoppable() {
  return _catch._catch.call(this, (error, caught) => {
    console.error(error); // eslint-disable-line
    return caught;
  });
}

if ((0, _common.hasFeatures)(REQUIREMENTS)) {
  var _context;

  const ua = navigator.userAgent.toLowerCase();
  const isSafari = ua.indexOf('safari') > 0 && ua.indexOf('chrome') < 0;

  const crossFader = new _crossFader2.default({ duration: FADE_DURATION });

  const pushState = document.getElementById('_yPushState');
  const loading = document.getElementById('_loading');

  const shadowMain = document.createElement('div');
  shadowMain.classList.add('shadow-main');
  shadowMain.innerHTML = `
    <div class="content container">
      <div class="page"></div>
    </div>`;
  pushState.parentNode.insertBefore(shadowMain, pushState);

  const start$ = (_context = (_context = (_context = (_context = _fromEvent.fromEvent.call(_Observable.Observable, pushState, 'y-push-state-start'), _map.map).call(_context, ({ detail }) => detail), _map.map).call(_context, detail => [detail, document.getElementById('_main')]), _do._do).call(_context, () => {
    // If a link on the drawer has been clicked, close it
    if (!window.isDesktop && window.drawer.opened) {
      window.drawer.close();
    }
  }), _share.share).call(_context);

  const ready$ = (_context = (_context = _fromEvent.fromEvent.call(_Observable.Observable, pushState, 'y-push-state-ready'), _map.map).call(_context, ({ detail }) => detail), _share.share).call(_context);

  const progress$ = (_context = _fromEvent.fromEvent.call(_Observable.Observable, pushState, 'y-push-state-progress'), _map.map).call(_context, ({ detail }) => detail);
  // ::share();

  const after$ = (_context = (_context = _fromEvent.fromEvent.call(_Observable.Observable, pushState, 'y-push-state-after'), _map.map).call(_context, ({ detail }) => detail), _share.share).call(_context);

  // const error$ = Observable.fromEvent(pushState, 'y-push-state-error');

  // HACK
  if (isSafari) {
    _fromEvent.fromEvent.call(_Observable.Observable, window, 'popstate').subscribe(() => {
      document.body.style.minHeight = '999999px';
    });

    after$.subscribe(() => {
      document.body.style.minHeight = '';
    });
  }

  // FLIP animation (when applicable)
  (_context = _switchMap.switchMap.call(start$, ([detail]) => {
    const { event: { currentTarget } } = detail;

    const flip = _flip2.default.create(currentTarget.dataset && currentTarget.dataset.flip, {
      shadowMain,
      currentTarget,
      duration: DURATION
    });

    // HACK: This assumes knowledge of the internal rx pipeline.
    // Could possibly be replaced with `withLatestFrom` shinanigans,
    // but it's more convenient like that.
    detail.flip = flip;

    return flip.start(currentTarget);
  }), makeUnstoppable).call(_context).subscribe();

  // Fade main content out
  (_context = (_context = (_context = _do._do.call(start$, ([, main]) => {
    main.style.opacity = 0;
  }), _filter.filter).call(_context, ([{ type }]) => type === 'push' || !isSafari), _exhaustMap.exhaustMap).call(_context, ([{ type }, main]) => {
    var _context2;

    return (_context2 = (_context2 = (0, _common.animate)(main, [{ opacity: 1 }, { opacity: 0 }], {
      duration: DURATION,
      // easing: 'ease',
      easing: 'cubic-bezier(0,0,0.32,1)'
    }), _do._do).call(_context2, () => {
      if (type === 'push') window.scroll(0, 0);
    }), _zip.zipProto).call(_context2, after$);
  }), makeUnstoppable).call(_context).subscribe();

  // Show loading bar when taking longer than expected
  (_context = _do._do.call(progress$, () => {
    loading.style.display = 'block';
  }), makeUnstoppable).call(_context).subscribe();

  // TODO: error message!?
  // error$
  //   // .delay(DURATION) // HACK
  //   .do(() => {
  //     loading.style.display = 'none';
  //   })
  //   .subscribe();

  // Prepare showing the new content
  (_context = (_context = (_context = _do._do.call(ready$, () => {
    loading.style.display = 'none';
  }), _filter.filter).call(_context, ({ type }) => type === 'push' || !isSafari), _switchMap.switchMap).call(_context, ({ flip, content: [main] }) => {
    var _context3;

    return (_context3 = flip.ready(main), _takeUntil.takeUntil).call(_context3, start$);
  }), makeUnstoppable).call(_context).subscribe();

  (_context = (_context = (_context = (_context = _switchMap.switchMap.call(ready$, ({ content: [main] }) => {
    var _context4;

    return (_context4 = crossFader.fetchImage(main.dataset), _takeUntil.takeUntil).call(_context4, start$);
  }), _startWith.startWith).call(_context, document.querySelector('.sidebar-bg')), _pairwise.pairwise).call(_context), _mergeMap.mergeMap).call(_context, crossFader.crossFade.bind(crossFader)), makeUnstoppable).call(_context).subscribe();

  // Animate the new content
  (_context = (_context = (_context = _filter.filter.call(after$, ({ type }) => type === 'push' || !isSafari), _map.map).call(_context, kind => [kind, document.querySelector('main')]), _switchMap.switchMap).call(_context, ([, main]) => (0, _common.animate)(main, [{ transform: 'translateY(-2rem)', opacity: 0 }, { transform: 'translateY(0)', opacity: 1 }], {
    duration: DURATION,
    // easing: 'ease',
    easing: 'cubic-bezier(0,0,0.32,1)'
  })), makeUnstoppable).call(_context).subscribe();

  (_context = (_context =
  // Don't send a pageview when the user blasts through the history..
  _debounceTime.debounceTime.call(after$, 2 * DURATION), _do._do).call(_context, () => {
    // Send google analytics pageview
    if (window.ga) window.ga('send', 'pageview');

    // Upgrade math blocks
    (0, _katex2.default)();
  }), makeUnstoppable).call(_context).subscribe();

  new _vanilla2.default(pushState, {
    replaceIds: ['_main'],
    linkSelector: 'a[href^="/"]',
    duration: DURATION,
    noPopDuration: isSafari,
    scrollRestoration: !isSafari
  }).startHistory();
}

},{"./common":2,"./cross-fader":3,"./flip/flip":5,"./flip/project":6,"./flip/title":7,"./katex":9,"rxjs/Observable":107,"rxjs/observable/fromEvent":122,"rxjs/operator/catch":125,"rxjs/operator/debounceTime":127,"rxjs/operator/do":128,"rxjs/operator/exhaustMap":129,"rxjs/operator/filter":130,"rxjs/operator/map":132,"rxjs/operator/mergeMap":134,"rxjs/operator/pairwise":136,"rxjs/operator/share":137,"rxjs/operator/startWith":138,"rxjs/operator/switchMap":139,"rxjs/operator/takeUntil":140,"rxjs/operator/zip":141,"y-push-state/src/vanilla":268}],11:[function(require,module,exports){
'use strict';

var _loadCSS = require('fg-loadcss/src/loadCSS');

function hasPreloadSupport() {
  try {
    return document.createElement('link').relList.supports('preload');
  } catch (e) {
    return false;
  }
}

// loop preload links and fetch using loadCSS
function polyfill() {
  const links = document.getElementsByTagName('link');

  for (let i = 0; i < links.length; i += 1) {
    const link = links[i];
    if (link.rel === 'preload' && link.getAttribute('as') === 'style') {
      (0, _loadCSS.loadCSS)(link.href, link);
      link.rel = null;
    }
  }
}

if (!hasPreloadSupport()) {
  polyfill();
}

},{"fg-loadcss/src/loadCSS":80}],12:[function(require,module,exports){
require('../../modules/es6.array.for-each');
module.exports = require('../../modules/_core').Array.forEach;
},{"../../modules/_core":28,"../../modules/es6.array.for-each":73}],13:[function(require,module,exports){
require('../../modules/es6.array.reduce');
module.exports = require('../../modules/_core').Array.reduce;
},{"../../modules/_core":28,"../../modules/es6.array.reduce":74}],14:[function(require,module,exports){
require('../../modules/es6.function.bind');
module.exports = require('../../modules/_core').Function.bind;
},{"../../modules/_core":28,"../../modules/es6.function.bind":75}],15:[function(require,module,exports){
require('../../modules/es6.number.constructor');
module.exports = Number;
},{"../../modules/es6.number.constructor":76}],16:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;
},{"../../modules/_core":28,"../../modules/es6.object.assign":77}],17:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc){
  return $Object.defineProperty(it, key, desc);
};
},{"../../modules/_core":28,"../../modules/es6.object.define-property":78}],18:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/_core').Object.keys;
},{"../../modules/_core":28,"../../modules/es6.object.keys":79}],19:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],20:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":45}],21:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":65,"./_to-iobject":67,"./_to-length":68}],22:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = require('./_ctx')
  , IObject  = require('./_iobject')
  , toObject = require('./_to-object')
  , toLength = require('./_to-length')
  , asc      = require('./_array-species-create');
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./_array-species-create":25,"./_ctx":29,"./_iobject":43,"./_to-length":68,"./_to-object":69}],23:[function(require,module,exports){
var aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , IObject   = require('./_iobject')
  , toLength  = require('./_to-length');

module.exports = function(that, callbackfn, aLen, memo, isRight){
  aFunction(callbackfn);
  var O      = toObject(that)
    , self   = IObject(O)
    , length = toLength(O.length)
    , index  = isRight ? length - 1 : 0
    , i      = isRight ? -1 : 1;
  if(aLen < 2)for(;;){
    if(index in self){
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if(isRight ? index < 0 : length <= index){
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};
},{"./_a-function":19,"./_iobject":43,"./_to-length":68,"./_to-object":69}],24:[function(require,module,exports){
var isObject = require('./_is-object')
  , isArray  = require('./_is-array')
  , SPECIES  = require('./_wks')('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};
},{"./_is-array":44,"./_is-object":45,"./_wks":72}],25:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};
},{"./_array-species-constructor":24}],26:[function(require,module,exports){
'use strict';
var aFunction  = require('./_a-function')
  , isObject   = require('./_is-object')
  , invoke     = require('./_invoke')
  , arraySlice = [].slice
  , factories  = {};

var construct = function(F, len, args){
  if(!(len in factories)){
    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /*, args... */){
  var fn       = aFunction(this)
    , partArgs = arraySlice.call(arguments, 1);
  var bound = function(/* args... */){
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if(isObject(fn.prototype))bound.prototype = fn.prototype;
  return bound;
};
},{"./_a-function":19,"./_invoke":42,"./_is-object":45}],27:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],28:[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],29:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":19}],30:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],31:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":35}],32:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":36,"./_is-object":45}],33:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],34:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , hide      = require('./_hide')
  , redefine  = require('./_redefine')
  , ctx       = require('./_ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":28,"./_ctx":29,"./_global":36,"./_hide":38,"./_redefine":58}],35:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],36:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],37:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],38:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":31,"./_object-dp":48,"./_property-desc":57}],39:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":36}],40:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":31,"./_dom-create":32,"./_fails":35}],41:[function(require,module,exports){
var isObject       = require('./_is-object')
  , setPrototypeOf = require('./_set-proto').set;
module.exports = function(that, target, C){
  var P, S = target.constructor;
  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
    setPrototypeOf(that, P);
  } return that;
};
},{"./_is-object":45,"./_set-proto":59}],42:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],43:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":27}],44:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":27}],45:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],46:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = require('./_object-keys')
  , gOPS     = require('./_object-gops')
  , pIE      = require('./_object-pie')
  , toObject = require('./_to-object')
  , IObject  = require('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":35,"./_iobject":43,"./_object-gops":52,"./_object-keys":54,"./_object-pie":55,"./_to-object":69}],47:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":20,"./_dom-create":32,"./_enum-bug-keys":33,"./_html":39,"./_object-dps":49,"./_shared-key":60}],48:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":20,"./_descriptors":31,"./_ie8-dom-define":40,"./_to-primitive":70}],49:[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":20,"./_descriptors":31,"./_object-dp":48,"./_object-keys":54}],50:[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":31,"./_has":37,"./_ie8-dom-define":40,"./_object-pie":55,"./_property-desc":57,"./_to-iobject":67,"./_to-primitive":70}],51:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":33,"./_object-keys-internal":53}],52:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],53:[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":21,"./_has":37,"./_shared-key":60,"./_to-iobject":67}],54:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":33,"./_object-keys-internal":53}],55:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],56:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export')
  , core    = require('./_core')
  , fails   = require('./_fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./_core":28,"./_export":34,"./_fails":35}],57:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],58:[function(require,module,exports){
var global    = require('./_global')
  , hide      = require('./_hide')
  , has       = require('./_has')
  , SRC       = require('./_uid')('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
},{"./_core":28,"./_global":36,"./_has":37,"./_hide":38,"./_uid":71}],59:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object')
  , anObject = require('./_an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./_an-object":20,"./_ctx":29,"./_is-object":45,"./_object-gopd":50}],60:[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":61,"./_uid":71}],61:[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":36}],62:[function(require,module,exports){
var fails = require('./_fails');

module.exports = function(method, arg){
  return !!method && fails(function(){
    arg ? method.call(null, function(){}, 1) : method.call(null);
  });
};
},{"./_fails":35}],63:[function(require,module,exports){
var $export = require('./_export')
  , defined = require('./_defined')
  , fails   = require('./_fails')
  , spaces  = require('./_string-ws')
  , space   = '[' + spaces + ']'
  , non     = '\u200b\u0085'
  , ltrim   = RegExp('^' + space + space + '*')
  , rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function(string, TYPE){
  string = String(defined(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;
},{"./_defined":30,"./_export":34,"./_fails":35,"./_string-ws":64}],64:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
},{}],65:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":66}],66:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],67:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":30,"./_iobject":43}],68:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":66}],69:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":30}],70:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":45}],71:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],72:[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":36,"./_shared":61,"./_uid":71}],73:[function(require,module,exports){
'use strict';
var $export  = require('./_export')
  , $forEach = require('./_array-methods')(0)
  , STRICT   = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */){
    return $forEach(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":22,"./_export":34,"./_strict-method":62}],74:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});
},{"./_array-reduce":23,"./_export":34,"./_strict-method":62}],75:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', {bind: require('./_bind')});
},{"./_bind":26,"./_export":34}],76:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , has               = require('./_has')
  , cof               = require('./_cof')
  , inheritIfRequired = require('./_inherit-if-required')
  , toPrimitive       = require('./_to-primitive')
  , fails             = require('./_fails')
  , gOPN              = require('./_object-gopn').f
  , gOPD              = require('./_object-gopd').f
  , dP                = require('./_object-dp').f
  , $trim             = require('./_string-trim').trim
  , NUMBER            = 'Number'
  , $Number           = global[NUMBER]
  , Base              = $Number
  , proto             = $Number.prototype
  // Opera ~12 has broken Object#toString
  , BROKEN_COF        = cof(require('./_object-create')(proto)) == NUMBER
  , TRIM              = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function(argument){
  var it = toPrimitive(argument, false);
  if(typeof it == 'string' && it.length > 2){
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0)
      , third, radix, maxCode;
    if(first === 43 || first === 45){
      third = it.charCodeAt(2);
      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if(first === 48){
      switch(it.charCodeAt(1)){
        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default : return +it;
      }
      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if(code < 48 || code > maxCode)return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
  $Number = function Number(value){
    var it = arguments.length < 1 ? 0 : value
      , that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for(var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++){
    if(has(Base, key = keys[j]) && !has($Number, key)){
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}
},{"./_cof":27,"./_descriptors":31,"./_fails":35,"./_global":36,"./_has":37,"./_inherit-if-required":41,"./_object-create":47,"./_object-dp":48,"./_object-gopd":50,"./_object-gopn":51,"./_redefine":58,"./_string-trim":63,"./_to-primitive":70}],77:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});
},{"./_export":34,"./_object-assign":46}],78:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});
},{"./_descriptors":31,"./_export":34,"./_object-dp":48}],79:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object')
  , $keys    = require('./_object-keys');

require('./_object-sap')('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./_object-keys":54,"./_object-sap":56,"./_to-object":69}],80:[function(require,module,exports){
(function (global){
/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
(function(w){
	"use strict";
	/* exported loadCSS */
	var loadCSS = function( href, before, media ){
		// Arguments explained:
		// `href` [REQUIRED] is the URL for your CSS file.
		// `before` [OPTIONAL] is the element the script should use as a reference for injecting our stylesheet <link> before
			// By default, loadCSS attempts to inject the link after the last stylesheet or script in the DOM. However, you might desire a more specific location in your document.
		// `media` [OPTIONAL] is the media type or query of the stylesheet. By default it will be 'all'
		var doc = w.document;
		var ss = doc.createElement( "link" );
		var ref;
		if( before ){
			ref = before;
		}
		else {
			var refs = ( doc.body || doc.getElementsByTagName( "head" )[ 0 ] ).childNodes;
			ref = refs[ refs.length - 1];
		}

		var sheets = doc.styleSheets;
		ss.rel = "stylesheet";
		ss.href = href;
		// temporarily set media to something inapplicable to ensure it'll fetch without blocking render
		ss.media = "only x";

		// wait until body is defined before injecting link. This ensures a non-blocking load in IE11.
		function ready( cb ){
			if( doc.body ){
				return cb();
			}
			setTimeout(function(){
				ready( cb );
			});
		}
		// Inject link
			// Note: the ternary preserves the existing behavior of "before" argument, but we could choose to change the argument to "after" in a later release and standardize on ref.nextSibling for all refs
			// Note: `insertBefore` is used instead of `appendChild`, for safety re: http://www.paulirish.com/2011/surefire-dom-element-insertion/
		ready( function(){
			ref.parentNode.insertBefore( ss, ( before ? ref : ref.nextSibling ) );
		});
		// A method (exposed on return object for external use) that mimics onload by polling document.styleSheets until it includes the new sheet.
		var onloadcssdefined = function( cb ){
			var resolvedHref = ss.href;
			var i = sheets.length;
			while( i-- ){
				if( sheets[ i ].href === resolvedHref ){
					return cb();
				}
			}
			setTimeout(function() {
				onloadcssdefined( cb );
			});
		};

		function loadCB(){
			if( ss.addEventListener ){
				ss.removeEventListener( "load", loadCB );
			}
			ss.media = media || "all";
		}

		// once loaded, set link's media back to `all` so that the stylesheet applies once it loads
		if( ss.addEventListener ){
			ss.addEventListener( "load", loadCB);
		}
		ss.onloadcssdefined = onloadcssdefined;
		onloadcssdefined( loadCB );
		return ss;
	};
	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],81:[function(require,module,exports){
/* eslint no-console:0 */
/**
 * This is the main entry point for KaTeX. Here, we expose functions for
 * rendering expressions either to DOM nodes or to markup strings.
 *
 * We also expose the ParseError class to check if errors thrown from KaTeX are
 * errors in the expression, or errors in javascript handling.
 */

var ParseError = require("./src/ParseError");
var Settings = require("./src/Settings");

var buildTree = require("./src/buildTree");
var parseTree = require("./src/parseTree");
var utils = require("./src/utils");

/**
 * Parse and build an expression, and place that expression in the DOM node
 * given.
 */
var render = function(expression, baseNode, options) {
    utils.clearNode(baseNode);

    var settings = new Settings(options);

    var tree = parseTree(expression, settings);
    var node = buildTree(tree, expression, settings).toNode();

    baseNode.appendChild(node);
};

// KaTeX's styles don't work properly in quirks mode. Print out an error, and
// disable rendering.
if (typeof document !== "undefined") {
    if (document.compatMode !== "CSS1Compat") {
        typeof console !== "undefined" && console.warn(
            "Warning: KaTeX doesn't work in quirks mode. Make sure your " +
                "website has a suitable doctype.");

        render = function() {
            throw new ParseError("KaTeX doesn't work in quirks mode.");
        };
    }
}

/**
 * Parse and build an expression, and return the markup for that.
 */
var renderToString = function(expression, options) {
    var settings = new Settings(options);

    var tree = parseTree(expression, settings);
    return buildTree(tree, expression, settings).toMarkup();
};

/**
 * Parse an expression and return the parse tree.
 */
var generateParseTree = function(expression, options) {
    var settings = new Settings(options);
    return parseTree(expression, settings);
};

module.exports = {
    render: render,
    renderToString: renderToString,
    /**
     * NOTE: This method is not currently recommended for public use.
     * The internal tree representation is unstable and is very likely
     * to change. Use at your own risk.
     */
    __parse: generateParseTree,
    ParseError: ParseError
};

},{"./src/ParseError":85,"./src/Settings":87,"./src/buildTree":92,"./src/parseTree":101,"./src/utils":104}],82:[function(require,module,exports){
/**
 * The Lexer class handles tokenizing the input in various ways. Since our
 * parser expects us to be able to backtrack, the lexer allows lexing from any
 * given starting point.
 *
 * Its main exposed function is the `lex` function, which takes a position to
 * lex from and a type of token to lex. It defers to the appropriate `_innerLex`
 * function.
 *
 * The various `_innerLex` functions perform the actual lexing of different
 * kinds.
 */

var matchAt = require("match-at");

var ParseError = require("./ParseError");

// The main lexer class
function Lexer(input) {
    this.input = input;
    this.pos = 0;
}

/**
 * The resulting token returned from `lex`.
 *
 * It consists of the token text plus some position information.
 * The position information is essentially a range in an input string,
 * but instead of referencing the bare input string, we refer to the lexer.
 * That way it is possible to attach extra metadata to the input string,
 * like for example a file name or similar.
 *
 * The position information (all three parameters) is optional,
 * so it is OK to construct synthetic tokens if appropriate.
 * Not providing available position information may lead to
 * degraded error reporting, though.
 *
 * @param {string}  text   the text of this token
 * @param {number=} start  the start offset, zero-based inclusive
 * @param {number=} end    the end offset, zero-based exclusive
 * @param {Lexer=}  lexer  the lexer which in turn holds the input string
 */
function Token(text, start, end, lexer) {
    this.text = text;
    this.start = start;
    this.end = end;
    this.lexer = lexer;
}

/**
 * Given a pair of tokens (this and endToken), compute a Token encompassing
 * the whole input range enclosed by these two.
 *
 * @param {Token}  endToken  last token of the range, inclusive
 * @param {string} text      the text of the newly constructed token
 */
Token.prototype.range = function(endToken, text) {
    if (endToken.lexer !== this.lexer) {
        return new Token(text); // sorry, no position information available
    }
    return new Token(text, this.start, endToken.end, this.lexer);
};

/* The following tokenRegex
 * - matches typical whitespace (but not NBSP etc.) using its first group
 * - does not match any control character \x00-\x1f except whitespace
 * - does not match a bare backslash
 * - matches any ASCII character except those just mentioned
 * - does not match the BMP private use area \uE000-\uF8FF
 * - does not match bare surrogate code units
 * - matches any BMP character except for those just described
 * - matches any valid Unicode surrogate pair
 * - matches a backslash followed by one or more letters
 * - matches a backslash followed by any BMP character, including newline
 * Just because the Lexer matches something doesn't mean it's valid input:
 * If there is no matching function or symbol definition, the Parser will
 * still reject the input.
 */
var tokenRegex = new RegExp(
    "([ \r\n\t]+)|" +                                 // whitespace
    "([!-\\[\\]-\u2027\u202A-\uD7FF\uF900-\uFFFF]" +  // single codepoint
    "|[\uD800-\uDBFF][\uDC00-\uDFFF]" +               // surrogate pair
    "|\\\\(?:[a-zA-Z]+|[^\uD800-\uDFFF])" +           // function name
    ")"
);

/**
 * This function lexes a single token.
 */
Lexer.prototype.lex = function() {
    var input = this.input;
    var pos = this.pos;
    if (pos === input.length) {
        return new Token("EOF", pos, pos, this);
    }
    var match = matchAt(tokenRegex, input, pos);
    if (match === null) {
        throw new ParseError(
            "Unexpected character: '" + input[pos] + "'",
            new Token(input[pos], pos, pos + 1, this));
    }
    var text = match[2] || " ";
    var start = this.pos;
    this.pos += match[0].length;
    var end = this.pos;
    return new Token(text, start, end, this);
};

module.exports = Lexer;

},{"./ParseError":85,"match-at":105}],83:[function(require,module,exports){
/**
 * This file contains the gullet where macros are expanded
 * until only non-macro tokens remain.
 */

var Lexer = require("./Lexer");

function MacroExpander(input, macros) {
    this.lexer = new Lexer(input);
    this.macros = macros;
    this.stack = []; // contains tokens in REVERSE order
    this.discardedWhiteSpace = [];
}

/**
 * Recursively expand first token, then return first non-expandable token.
 */
MacroExpander.prototype.nextToken = function() {
    for (;;) {
        if (this.stack.length === 0) {
            this.stack.push(this.lexer.lex());
        }
        var topToken = this.stack.pop();
        var name = topToken.text;
        if (!(name.charAt(0) === "\\" && this.macros.hasOwnProperty(name))) {
            return topToken;
        }
        var expansion = this.macros[name];
        if (typeof expansion === "string") {
            var bodyLexer = new Lexer(expansion);
            expansion = [];
            var tok = bodyLexer.lex();
            while (tok.text !== "EOF") {
                expansion.push(tok);
                tok = bodyLexer.lex();
            }
            expansion.reverse(); // to fit in with stack using push and pop
            this.macros[name] = expansion;
        }
        this.stack = this.stack.concat(expansion);
    }
};

MacroExpander.prototype.get = function(ignoreSpace) {
    this.discardedWhiteSpace = [];
    var token = this.nextToken();
    if (ignoreSpace) {
        while (token.text === " ") {
            this.discardedWhiteSpace.push(token);
            token = this.nextToken();
        }
    }
    return token;
};

/**
 * Undo the effect of the preceding call to the get method.
 * A call to this method MUST be immediately preceded and immediately followed
 * by a call to get.  Only used during mode switching, i.e. after one token
 * was got in the old mode but should get got again in a new mode
 * with possibly different whitespace handling.
 */
MacroExpander.prototype.unget = function(token) {
    this.stack.push(token);
    while (this.discardedWhiteSpace.length !== 0) {
        this.stack.push(this.discardedWhiteSpace.pop());
    }
};

module.exports = MacroExpander;

},{"./Lexer":82}],84:[function(require,module,exports){
/**
 * This file contains information about the options that the Parser carries
 * around with it while parsing. Data is held in an `Options` object, and when
 * recursing, a new `Options` object can be created with the `.with*` and
 * `.reset` functions.
 */

/**
 * This is the main options class. It contains the style, size, color, and font
 * of the current parse level. It also contains the style and size of the parent
 * parse level, so size changes can be handled efficiently.
 *
 * Each of the `.with*` and `.reset` functions passes its current style and size
 * as the parentStyle and parentSize of the new options class, so parent
 * handling is taken care of automatically.
 */
function Options(data) {
    this.style = data.style;
    this.color = data.color;
    this.size = data.size;
    this.phantom = data.phantom;
    this.font = data.font;

    if (data.parentStyle === undefined) {
        this.parentStyle = data.style;
    } else {
        this.parentStyle = data.parentStyle;
    }

    if (data.parentSize === undefined) {
        this.parentSize = data.size;
    } else {
        this.parentSize = data.parentSize;
    }
}

/**
 * Returns a new options object with the same properties as "this".  Properties
 * from "extension" will be copied to the new options object.
 */
Options.prototype.extend = function(extension) {
    var data = {
        style: this.style,
        size: this.size,
        color: this.color,
        parentStyle: this.style,
        parentSize: this.size,
        phantom: this.phantom,
        font: this.font
    };

    for (var key in extension) {
        if (extension.hasOwnProperty(key)) {
            data[key] = extension[key];
        }
    }

    return new Options(data);
};

/**
 * Create a new options object with the given style.
 */
Options.prototype.withStyle = function(style) {
    return this.extend({
        style: style
    });
};

/**
 * Create a new options object with the given size.
 */
Options.prototype.withSize = function(size) {
    return this.extend({
        size: size
    });
};

/**
 * Create a new options object with the given color.
 */
Options.prototype.withColor = function(color) {
    return this.extend({
        color: color
    });
};

/**
 * Create a new options object with "phantom" set to true.
 */
Options.prototype.withPhantom = function() {
    return this.extend({
        phantom: true
    });
};

/**
 * Create a new options objects with the give font.
 */
Options.prototype.withFont = function(font) {
    return this.extend({
        font: font || this.font
    });
};

/**
 * Create a new options object with the same style, size, and color. This is
 * used so that parent style and size changes are handled correctly.
 */
Options.prototype.reset = function() {
    return this.extend({});
};

/**
 * A map of color names to CSS colors.
 * TODO(emily): Remove this when we have real macros
 */
var colorMap = {
    "katex-blue": "#6495ed",
    "katex-orange": "#ffa500",
    "katex-pink": "#ff00af",
    "katex-red": "#df0030",
    "katex-green": "#28ae7b",
    "katex-gray": "gray",
    "katex-purple": "#9d38bd",
    "katex-blueA": "#ccfaff",
    "katex-blueB": "#80f6ff",
    "katex-blueC": "#63d9ea",
    "katex-blueD": "#11accd",
    "katex-blueE": "#0c7f99",
    "katex-tealA": "#94fff5",
    "katex-tealB": "#26edd5",
    "katex-tealC": "#01d1c1",
    "katex-tealD": "#01a995",
    "katex-tealE": "#208170",
    "katex-greenA": "#b6ffb0",
    "katex-greenB": "#8af281",
    "katex-greenC": "#74cf70",
    "katex-greenD": "#1fab54",
    "katex-greenE": "#0d923f",
    "katex-goldA": "#ffd0a9",
    "katex-goldB": "#ffbb71",
    "katex-goldC": "#ff9c39",
    "katex-goldD": "#e07d10",
    "katex-goldE": "#a75a05",
    "katex-redA": "#fca9a9",
    "katex-redB": "#ff8482",
    "katex-redC": "#f9685d",
    "katex-redD": "#e84d39",
    "katex-redE": "#bc2612",
    "katex-maroonA": "#ffbde0",
    "katex-maroonB": "#ff92c6",
    "katex-maroonC": "#ed5fa6",
    "katex-maroonD": "#ca337c",
    "katex-maroonE": "#9e034e",
    "katex-purpleA": "#ddd7ff",
    "katex-purpleB": "#c6b9fc",
    "katex-purpleC": "#aa87ff",
    "katex-purpleD": "#7854ab",
    "katex-purpleE": "#543b78",
    "katex-mintA": "#f5f9e8",
    "katex-mintB": "#edf2df",
    "katex-mintC": "#e0e5cc",
    "katex-grayA": "#f6f7f7",
    "katex-grayB": "#f0f1f2",
    "katex-grayC": "#e3e5e6",
    "katex-grayD": "#d6d8da",
    "katex-grayE": "#babec2",
    "katex-grayF": "#888d93",
    "katex-grayG": "#626569",
    "katex-grayH": "#3b3e40",
    "katex-grayI": "#21242c",
    "katex-kaBlue": "#314453",
    "katex-kaGreen": "#71B307"
};

/**
 * Gets the CSS color of the current options object, accounting for the
 * `colorMap`.
 */
Options.prototype.getColor = function() {
    if (this.phantom) {
        return "transparent";
    } else {
        return colorMap[this.color] || this.color;
    }
};

module.exports = Options;

},{}],85:[function(require,module,exports){
/**
 * This is the ParseError class, which is the main error thrown by KaTeX
 * functions when something has gone wrong. This is used to distinguish internal
 * errors from errors in the expression that the user provided.
 *
 * If possible, a caller should provide a Token or ParseNode with information
 * about where in the source string the problem occurred.
 *
 * @param {string} message  The error message
 * @param {(Token|ParseNode)=} token  An object providing position information
 */
function ParseError(message, token) {
    var error = "KaTeX parse error: " + message;
    var start;
    var end;

    if (token && token.lexer && token.start <= token.end) {
        // If we have the input and a position, make the error a bit fancier

        // Get the input
        var input = token.lexer.input;

        // Prepend some information
        start = token.start;
        end = token.end;
        if (start === input.length) {
            error += " at end of input: ";
        } else {
            error += " at position " + (start + 1) + ": ";
        }

        // Underline token in question using combining underscores
        var underlined = input.slice(start, end).replace(/[^]/g, "$&\u0332");

        // Extract some context from the input and add it to the error
        var left;
        if (start > 15) {
            left = "" + input.slice(start - 15, start);
        } else {
            left = input.slice(0, start);
        }
        var right;
        if (end + 15 < input.length) {
            right = input.slice(end, end + 15) + "";
        } else {
            right = input.slice(end);
        }
        error += left + underlined + right;
    }

    // Some hackery to make ParseError a prototype of Error
    // See http://stackoverflow.com/a/8460753
    var self = new Error(error);
    self.name = "ParseError";
    self.__proto__ = ParseError.prototype;

    self.position = start;
    return self;
}

// More hackery
ParseError.prototype.__proto__ = Error.prototype;

module.exports = ParseError;

},{}],86:[function(require,module,exports){
/* eslint no-constant-condition:0 */
var functions = require("./functions");
var environments = require("./environments");
var MacroExpander = require("./MacroExpander");
var symbols = require("./symbols");
var utils = require("./utils");
var cjkRegex = require("./unicodeRegexes").cjkRegex;

var parseData = require("./parseData");
var ParseError = require("./ParseError");

/**
 * This file contains the parser used to parse out a TeX expression from the
 * input. Since TeX isn't context-free, standard parsers don't work particularly
 * well.
 *
 * The strategy of this parser is as such:
 *
 * The main functions (the `.parse...` ones) take a position in the current
 * parse string to parse tokens from. The lexer (found in Lexer.js, stored at
 * this.lexer) also supports pulling out tokens at arbitrary places. When
 * individual tokens are needed at a position, the lexer is called to pull out a
 * token, which is then used.
 *
 * The parser has a property called "mode" indicating the mode that
 * the parser is currently in. Currently it has to be one of "math" or
 * "text", which denotes whether the current environment is a math-y
 * one or a text-y one (e.g. inside \text). Currently, this serves to
 * limit the functions which can be used in text mode.
 *
 * The main functions then return an object which contains the useful data that
 * was parsed at its given point, and a new position at the end of the parsed
 * data. The main functions can call each other and continue the parsing by
 * using the returned position as a new starting point.
 *
 * There are also extra `.handle...` functions, which pull out some reused
 * functionality into self-contained functions.
 *
 * The earlier functions return ParseNodes.
 * The later functions (which are called deeper in the parse) sometimes return
 * ParseFuncOrArgument, which contain a ParseNode as well as some data about
 * whether the parsed object is a function which is missing some arguments, or a
 * standalone object which can be used as an argument to another function.
 */

/**
 * Main Parser class
 */
function Parser(input, settings) {
    // Create a new macro expander (gullet) and (indirectly via that) also a
    // new lexer (mouth) for this parser (stomach, in the language of TeX)
    this.gullet = new MacroExpander(input, settings.macros);
    // Store the settings for use in parsing
    this.settings = settings;
    // Count leftright depth (for \middle errors)
    this.leftrightDepth = 0;
}

var ParseNode = parseData.ParseNode;

/**
 * An initial function (without its arguments), or an argument to a function.
 * The `result` argument should be a ParseNode.
 */
function ParseFuncOrArgument(result, isFunction, token) {
    this.result = result;
    // Is this a function (i.e. is it something defined in functions.js)?
    this.isFunction = isFunction;
    this.token = token;
}

/**
 * Checks a result to make sure it has the right type, and throws an
 * appropriate error otherwise.
 *
 * @param {boolean=} consume whether to consume the expected token,
 *                           defaults to true
 */
Parser.prototype.expect = function(text, consume) {
    if (this.nextToken.text !== text) {
        throw new ParseError(
            "Expected '" + text + "', got '" + this.nextToken.text + "'",
            this.nextToken
        );
    }
    if (consume !== false) {
        this.consume();
    }
};

/**
 * Considers the current look ahead token as consumed,
 * and fetches the one after that as the new look ahead.
 */
Parser.prototype.consume = function() {
    this.nextToken = this.gullet.get(this.mode === "math");
};

Parser.prototype.switchMode = function(newMode) {
    this.gullet.unget(this.nextToken);
    this.mode = newMode;
    this.consume();
};

/**
 * Main parsing function, which parses an entire input.
 *
 * @return {?Array.<ParseNode>}
 */
Parser.prototype.parse = function() {
    // Try to parse the input
    this.mode = "math";
    this.consume();
    var parse = this.parseInput();
    return parse;
};

/**
 * Parses an entire input tree.
 */
Parser.prototype.parseInput = function() {
    // Parse an expression
    var expression = this.parseExpression(false);
    // If we succeeded, make sure there's an EOF at the end
    this.expect("EOF", false);
    return expression;
};

var endOfExpression = ["}", "\\end", "\\right", "&", "\\\\", "\\cr"];

/**
 * Parses an "expression", which is a list of atoms.
 *
 * @param {boolean} breakOnInfix  Should the parsing stop when we hit infix
 *                  nodes? This happens when functions have higher precendence
 *                  than infix nodes in implicit parses.
 *
 * @param {?string} breakOnTokenText  The text of the token that the expression
 *                  should end with, or `null` if something else should end the
 *                  expression.
 *
 * @return {ParseNode}
 */
Parser.prototype.parseExpression = function(breakOnInfix, breakOnTokenText) {
    var body = [];
    // Keep adding atoms to the body until we can't parse any more atoms (either
    // we reached the end, a }, or a \right)
    while (true) {
        var lex = this.nextToken;
        if (endOfExpression.indexOf(lex.text) !== -1) {
            break;
        }
        if (breakOnTokenText && lex.text === breakOnTokenText) {
            break;
        }
        if (breakOnInfix && functions[lex.text] && functions[lex.text].infix) {
            break;
        }
        var atom = this.parseAtom();
        if (!atom) {
            if (!this.settings.throwOnError && lex.text[0] === "\\") {
                var errorNode = this.handleUnsupportedCmd();
                body.push(errorNode);
                continue;
            }

            break;
        }
        body.push(atom);
    }
    return this.handleInfixNodes(body);
};

/**
 * Rewrites infix operators such as \over with corresponding commands such
 * as \frac.
 *
 * There can only be one infix operator per group.  If there's more than one
 * then the expression is ambiguous.  This can be resolved by adding {}.
 *
 * @returns {Array}
 */
Parser.prototype.handleInfixNodes = function(body) {
    var overIndex = -1;
    var funcName;

    for (var i = 0; i < body.length; i++) {
        var node = body[i];
        if (node.type === "infix") {
            if (overIndex !== -1) {
                throw new ParseError(
                    "only one infix operator per group",
                    node.value.token);
            }
            overIndex = i;
            funcName = node.value.replaceWith;
        }
    }

    if (overIndex !== -1) {
        var numerNode;
        var denomNode;

        var numerBody = body.slice(0, overIndex);
        var denomBody = body.slice(overIndex + 1);

        if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
            numerNode = numerBody[0];
        } else {
            numerNode = new ParseNode("ordgroup", numerBody, this.mode);
        }

        if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
            denomNode = denomBody[0];
        } else {
            denomNode = new ParseNode("ordgroup", denomBody, this.mode);
        }

        var value = this.callFunction(
            funcName, [numerNode, denomNode], null);
        return [new ParseNode(value.type, value, this.mode)];
    } else {
        return body;
    }
};

// The greediness of a superscript or subscript
var SUPSUB_GREEDINESS = 1;

/**
 * Handle a subscript or superscript with nice errors.
 */
Parser.prototype.handleSupSubscript = function(name) {
    var symbolToken = this.nextToken;
    var symbol = symbolToken.text;
    this.consume();
    var group = this.parseGroup();

    if (!group) {
        if (!this.settings.throwOnError && this.nextToken.text[0] === "\\") {
            return this.handleUnsupportedCmd();
        } else {
            throw new ParseError(
                "Expected group after '" + symbol + "'",
                symbolToken
            );
        }
    } else if (group.isFunction) {
        // ^ and _ have a greediness, so handle interactions with functions'
        // greediness
        var funcGreediness = functions[group.result].greediness;
        if (funcGreediness > SUPSUB_GREEDINESS) {
            return this.parseFunction(group);
        } else {
            throw new ParseError(
                "Got function '" + group.result + "' with no arguments " +
                    "as " + name, symbolToken);
        }
    } else {
        return group.result;
    }
};

/**
 * Converts the textual input of an unsupported command into a text node
 * contained within a color node whose color is determined by errorColor
 */
Parser.prototype.handleUnsupportedCmd = function() {
    var text = this.nextToken.text;
    var textordArray = [];

    for (var i = 0; i < text.length; i++) {
        textordArray.push(new ParseNode("textord", text[i], "text"));
    }

    var textNode = new ParseNode(
        "text",
        {
            body: textordArray,
            type: "text"
        },
        this.mode);

    var colorNode = new ParseNode(
        "color",
        {
            color: this.settings.errorColor,
            value: [textNode],
            type: "color"
        },
        this.mode);

    this.consume();
    return colorNode;
};

/**
 * Parses a group with optional super/subscripts.
 *
 * @return {?ParseNode}
 */
Parser.prototype.parseAtom = function() {
    // The body of an atom is an implicit group, so that things like
    // \left(x\right)^2 work correctly.
    var base = this.parseImplicitGroup();

    // In text mode, we don't have superscripts or subscripts
    if (this.mode === "text") {
        return base;
    }

    // Note that base may be empty (i.e. null) at this point.

    var superscript;
    var subscript;
    while (true) {
        // Lex the first token
        var lex = this.nextToken;

        if (lex.text === "\\limits" || lex.text === "\\nolimits") {
            // We got a limit control
            if (!base || base.type !== "op") {
                throw new ParseError(
                    "Limit controls must follow a math operator",
                    lex);
            } else {
                var limits = lex.text === "\\limits";
                base.value.limits = limits;
                base.value.alwaysHandleSupSub = true;
            }
            this.consume();
        } else if (lex.text === "^") {
            // We got a superscript start
            if (superscript) {
                throw new ParseError("Double superscript", lex);
            }
            superscript = this.handleSupSubscript("superscript");
        } else if (lex.text === "_") {
            // We got a subscript start
            if (subscript) {
                throw new ParseError("Double subscript", lex);
            }
            subscript = this.handleSupSubscript("subscript");
        } else if (lex.text === "'") {
            // We got a prime
            var prime = new ParseNode("textord", "\\prime", this.mode);

            // Many primes can be grouped together, so we handle this here
            var primes = [prime];
            this.consume();
            // Keep lexing tokens until we get something that's not a prime
            while (this.nextToken.text === "'") {
                // For each one, add another prime to the list
                primes.push(prime);
                this.consume();
            }
            // Put them into an ordgroup as the superscript
            superscript = new ParseNode("ordgroup", primes, this.mode);
        } else {
            // If it wasn't ^, _, or ', stop parsing super/subscripts
            break;
        }
    }

    if (superscript || subscript) {
        // If we got either a superscript or subscript, create a supsub
        return new ParseNode("supsub", {
            base: base,
            sup: superscript,
            sub: subscript
        }, this.mode);
    } else {
        // Otherwise return the original body
        return base;
    }
};

// A list of the size-changing functions, for use in parseImplicitGroup
var sizeFuncs = [
    "\\tiny", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize",
    "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"
];

// A list of the style-changing functions, for use in parseImplicitGroup
var styleFuncs = [
    "\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"
];

/**
 * Parses an implicit group, which is a group that starts at the end of a
 * specified, and ends right before a higher explicit group ends, or at EOL. It
 * is used for functions that appear to affect the current style, like \Large or
 * \textrm, where instead of keeping a style we just pretend that there is an
 * implicit grouping after it until the end of the group. E.g.
 *   small text {\Large large text} small text again
 * It is also used for \left and \right to get the correct grouping.
 *
 * @return {?ParseNode}
 */
Parser.prototype.parseImplicitGroup = function() {
    var start = this.parseSymbol();

    if (start == null) {
        // If we didn't get anything we handle, fall back to parseFunction
        return this.parseFunction();
    }

    var func = start.result;
    var body;

    if (func === "\\left") {
        // If we see a left:
        // Parse the entire left function (including the delimiter)
        var left = this.parseFunction(start);
        // Parse out the implicit body
        ++this.leftrightDepth;
        body = this.parseExpression(false);
        --this.leftrightDepth;
        // Check the next token
        this.expect("\\right", false);
        var right = this.parseFunction();
        return new ParseNode("leftright", {
            body: body,
            left: left.value.value,
            right: right.value.value
        }, this.mode);
    } else if (func === "\\begin") {
        // begin...end is similar to left...right
        var begin = this.parseFunction(start);
        var envName = begin.value.name;
        if (!environments.hasOwnProperty(envName)) {
            throw new ParseError(
                "No such environment: " + envName, begin.value.nameGroup);
        }
        // Build the environment object. Arguments and other information will
        // be made available to the begin and end methods using properties.
        var env = environments[envName];
        var args = this.parseArguments("\\begin{" + envName + "}", env);
        var context = {
            mode: this.mode,
            envName: envName,
            parser: this,
            positions: args.pop()
        };
        var result = env.handler(context, args);
        this.expect("\\end", false);
        var endNameToken = this.nextToken;
        var end = this.parseFunction();
        if (end.value.name !== envName) {
            throw new ParseError(
                "Mismatch: \\begin{" + envName + "} matched " +
                "by \\end{" + end.value.name + "}",
                endNameToken);
        }
        result.position = end.position;
        return result;
    } else if (utils.contains(sizeFuncs, func)) {
        // If we see a sizing function, parse out the implict body
        body = this.parseExpression(false);
        return new ParseNode("sizing", {
            // Figure out what size to use based on the list of functions above
            size: "size" + (utils.indexOf(sizeFuncs, func) + 1),
            value: body
        }, this.mode);
    } else if (utils.contains(styleFuncs, func)) {
        // If we see a styling function, parse out the implict body
        body = this.parseExpression(true);
        return new ParseNode("styling", {
            // Figure out what style to use by pulling out the style from
            // the function name
            style: func.slice(1, func.length - 5),
            value: body
        }, this.mode);
    } else {
        // Defer to parseFunction if it's not a function we handle
        return this.parseFunction(start);
    }
};

/**
 * Parses an entire function, including its base and all of its arguments.
 * The base might either have been parsed already, in which case
 * it is provided as an argument, or it's the next group in the input.
 *
 * @param {ParseFuncOrArgument=} baseGroup optional as described above
 * @return {?ParseNode}
 */
Parser.prototype.parseFunction = function(baseGroup) {
    if (!baseGroup) {
        baseGroup = this.parseGroup();
    }

    if (baseGroup) {
        if (baseGroup.isFunction) {
            var func = baseGroup.result;
            var funcData = functions[func];
            if (this.mode === "text" && !funcData.allowedInText) {
                throw new ParseError(
                    "Can't use function '" + func + "' in text mode",
                    baseGroup.token);
            }

            var args = this.parseArguments(func, funcData);
            var token = baseGroup.token;
            var result = this.callFunction(func, args, args.pop(), token);
            return new ParseNode(result.type, result, this.mode);
        } else {
            return baseGroup.result;
        }
    } else {
        return null;
    }
};

/**
 * Call a function handler with a suitable context and arguments.
 */
Parser.prototype.callFunction = function(name, args, positions, token) {
    var context = {
        funcName: name,
        parser: this,
        positions: positions,
        token: token
    };
    return functions[name].handler(context, args);
};

/**
 * Parses the arguments of a function or environment
 *
 * @param {string} func  "\name" or "\begin{name}"
 * @param {{numArgs:number,numOptionalArgs:number|undefined}} funcData
 * @return the array of arguments, with the list of positions as last element
 */
Parser.prototype.parseArguments = function(func, funcData) {
    var totalArgs = funcData.numArgs + funcData.numOptionalArgs;
    if (totalArgs === 0) {
        return [[this.pos]];
    }

    var baseGreediness = funcData.greediness;
    var positions = [this.pos];
    var args = [];

    for (var i = 0; i < totalArgs; i++) {
        var nextToken = this.nextToken;
        var argType = funcData.argTypes && funcData.argTypes[i];
        var arg;
        if (i < funcData.numOptionalArgs) {
            if (argType) {
                arg = this.parseGroupOfType(argType, true);
            } else {
                arg = this.parseGroup(true);
            }
            if (!arg) {
                args.push(null);
                positions.push(this.pos);
                continue;
            }
        } else {
            if (argType) {
                arg = this.parseGroupOfType(argType);
            } else {
                arg = this.parseGroup();
            }
            if (!arg) {
                if (!this.settings.throwOnError &&
                    this.nextToken.text[0] === "\\") {
                    arg = new ParseFuncOrArgument(
                        this.handleUnsupportedCmd(this.nextToken.text),
                        false);
                } else {
                    throw new ParseError(
                        "Expected group after '" + func + "'", nextToken);
                }
            }
        }
        var argNode;
        if (arg.isFunction) {
            var argGreediness =
                functions[arg.result].greediness;
            if (argGreediness > baseGreediness) {
                argNode = this.parseFunction(arg);
            } else {
                throw new ParseError(
                    "Got function '" + arg.result + "' as " +
                    "argument to '" + func + "'", nextToken);
            }
        } else {
            argNode = arg.result;
        }
        args.push(argNode);
        positions.push(this.pos);
    }

    args.push(positions);

    return args;
};


/**
 * Parses a group when the mode is changing.
 *
 * @return {?ParseFuncOrArgument}
 */
Parser.prototype.parseGroupOfType = function(innerMode, optional) {
    var outerMode = this.mode;
    // Handle `original` argTypes
    if (innerMode === "original") {
        innerMode = outerMode;
    }

    if (innerMode === "color") {
        return this.parseColorGroup(optional);
    }
    if (innerMode === "size") {
        return this.parseSizeGroup(optional);
    }

    this.switchMode(innerMode);
    if (innerMode === "text") {
        // text mode is special because it should ignore the whitespace before
        // it
        while (this.nextToken.text === " ") {
            this.consume();
        }
    }
    // By the time we get here, innerMode is one of "text" or "math".
    // We switch the mode of the parser, recurse, then restore the old mode.
    var res = this.parseGroup(optional);
    this.switchMode(outerMode);
    return res;
};

/**
 * Parses a group, essentially returning the string formed by the
 * brace-enclosed tokens plus some position information.
 *
 * @param {string} modeName  Used to describe the mode in error messages
 * @param {boolean=} optional  Whether the group is optional or required
 */
Parser.prototype.parseStringGroup = function(modeName, optional) {
    if (optional && this.nextToken.text !== "[") {
        return null;
    }
    var outerMode = this.mode;
    this.mode = "text";
    this.expect(optional ? "[" : "{");
    var str = "";
    var firstToken = this.nextToken;
    var lastToken = firstToken;
    while (this.nextToken.text !== (optional ? "]" : "}")) {
        if (this.nextToken.text === "EOF") {
            throw new ParseError(
                "Unexpected end of input in " + modeName,
                firstToken.range(this.nextToken, str));
        }
        lastToken = this.nextToken;
        str += lastToken.text;
        this.consume();
    }
    this.mode = outerMode;
    this.expect(optional ? "]" : "}");
    return firstToken.range(lastToken, str);
};

/**
 * Parses a regex-delimited group: the largest sequence of tokens
 * whose concatenated strings match `regex`. Returns the string
 * formed by the tokens plus some position information.
 *
 * @param {RegExp} regex
 * @param {string} modeName  Used to describe the mode in error messages
 */
Parser.prototype.parseRegexGroup = function(regex, modeName) {
    var outerMode = this.mode;
    this.mode = "text";
    var firstToken = this.nextToken;
    var lastToken = firstToken;
    var str = "";
    while (this.nextToken.text !== "EOF"
           && regex.test(str + this.nextToken.text)) {
        lastToken = this.nextToken;
        str += lastToken.text;
        this.consume();
    }
    if (str === "") {
        throw new ParseError(
            "Invalid " + modeName + ": '" + firstToken.text + "'",
            firstToken);
    }
    this.mode = outerMode;
    return firstToken.range(lastToken, str);
};

/**
 * Parses a color description.
 */
Parser.prototype.parseColorGroup = function(optional) {
    var res = this.parseStringGroup("color", optional);
    if (!res) {
        return null;
    }
    var match = (/^(#[a-z0-9]+|[a-z]+)$/i).exec(res.text);
    if (!match) {
        throw new ParseError("Invalid color: '" + res.text + "'", res);
    }
    return new ParseFuncOrArgument(
        new ParseNode("color", match[0], this.mode),
        false);
};

/**
 * Parses a size specification, consisting of magnitude and unit.
 */
Parser.prototype.parseSizeGroup = function(optional) {
    var res;
    if (!optional && this.nextToken.text !== "{") {
        res = this.parseRegexGroup(
            /^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2}$/, "size");
    } else {
        res = this.parseStringGroup("size", optional);
    }
    if (!res) {
        return null;
    }
    var match = (/([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/).exec(res.text);
    if (!match) {
        throw new ParseError("Invalid size: '" + res.text + "'", res);
    }
    var data = {
        number: +(match[1] + match[2]), // sign + magnitude, cast to number
        unit: match[3]
    };
    if (data.unit !== "em" && data.unit !== "ex" && data.unit !== "mu") {
        throw new ParseError("Invalid unit: '" + data.unit + "'", res);
    }
    return new ParseFuncOrArgument(
        new ParseNode("color", data, this.mode),
        false);
};

/**
 * If the argument is false or absent, this parses an ordinary group,
 * which is either a single nucleus (like "x") or an expression
 * in braces (like "{x+y}").
 * If the argument is true, it parses either a bracket-delimited expression
 * (like "[x+y]") or returns null to indicate the absence of a
 * bracket-enclosed group.
 *
 * @param {boolean=} optional  Whether the group is optional or required
 * @return {?ParseFuncOrArgument}
 */
Parser.prototype.parseGroup = function(optional) {
    var firstToken = this.nextToken;
    // Try to parse an open brace
    if (this.nextToken.text === (optional ? "[" : "{")) {
        // If we get a brace, parse an expression
        this.consume();
        var expression = this.parseExpression(false, optional ? "]" : null);
        var lastToken = this.nextToken;
        // Make sure we get a close brace
        this.expect(optional ? "]" : "}");
        if (this.mode === "text") {
            this.formLigatures(expression);
        }
        return new ParseFuncOrArgument(
            new ParseNode("ordgroup", expression, this.mode,
                          firstToken, lastToken),
            false);
    } else {
        // Otherwise, just return a nucleus, or nothing for an optional group
        return optional ? null : this.parseSymbol();
    }
};

/**
 * Form ligature-like combinations of characters for text mode.
 * This includes inputs like "--", "---", "``" and "''".
 * The result will simply replace multiple textord nodes with a single
 * character in each value by a single textord node having multiple
 * characters in its value.  The representation is still ASCII source.
 *
 * @param {Array.<ParseNode>} group  the nodes of this group,
 *                                   list will be moified in place
 */
Parser.prototype.formLigatures = function(group) {
    var i;
    var n = group.length - 1;
    for (i = 0; i < n; ++i) {
        var a = group[i];
        var v = a.value;
        if (v === "-" && group[i + 1].value === "-") {
            if (i + 1 < n && group[i + 2].value === "-") {
                group.splice(i, 3, new ParseNode(
                    "textord", "---", "text", a, group[i + 2]));
                n -= 2;
            } else {
                group.splice(i, 2, new ParseNode(
                    "textord", "--", "text", a, group[i + 1]));
                n -= 1;
            }
        }
        if ((v === "'" || v === "`") && group[i + 1].value === v) {
            group.splice(i, 2, new ParseNode(
                "textord", v + v, "text", a, group[i + 1]));
            n -= 1;
        }
    }
};

/**
 * Parse a single symbol out of the string. Here, we handle both the functions
 * we have defined, as well as the single character symbols
 *
 * @return {?ParseFuncOrArgument}
 */
Parser.prototype.parseSymbol = function() {
    var nucleus = this.nextToken;

    if (functions[nucleus.text]) {
        this.consume();
        // If there exists a function with this name, we return the function and
        // say that it is a function.
        return new ParseFuncOrArgument(
            nucleus.text,
            true, nucleus);
    } else if (symbols[this.mode][nucleus.text]) {
        this.consume();
        // Otherwise if this is a no-argument function, find the type it
        // corresponds to in the symbols map
        return new ParseFuncOrArgument(
            new ParseNode(symbols[this.mode][nucleus.text].group,
                          nucleus.text, this.mode, nucleus),
            false, nucleus);
    } else if (this.mode === "text" && cjkRegex.test(nucleus.text)) {
        this.consume();
        return new ParseFuncOrArgument(
            new ParseNode("textord", nucleus.text, this.mode, nucleus),
            false, nucleus);
    } else {
        return null;
    }
};

Parser.prototype.ParseNode = ParseNode;

module.exports = Parser;

},{"./MacroExpander":83,"./ParseError":85,"./environments":95,"./functions":98,"./parseData":100,"./symbols":102,"./unicodeRegexes":103,"./utils":104}],87:[function(require,module,exports){
/**
 * This is a module for storing settings passed into KaTeX. It correctly handles
 * default settings.
 */

/**
 * Helper function for getting a default value if the value is undefined
 */
function get(option, defaultValue) {
    return option === undefined ? defaultValue : option;
}

/**
 * The main Settings object
 *
 * The current options stored are:
 *  - displayMode: Whether the expression should be typeset by default in
 *                 textstyle or displaystyle (default false)
 */
function Settings(options) {
    // allow null options
    options = options || {};
    this.displayMode = get(options.displayMode, false);
    this.throwOnError = get(options.throwOnError, true);
    this.errorColor = get(options.errorColor, "#cc0000");
    this.macros = options.macros || {};
}

module.exports = Settings;

},{}],88:[function(require,module,exports){
/**
 * This file contains information and classes for the various kinds of styles
 * used in TeX. It provides a generic `Style` class, which holds information
 * about a specific style. It then provides instances of all the different kinds
 * of styles possible, and provides functions to move between them and get
 * information about them.
 */

var sigmas = require("./fontMetrics.js").sigmas;

var metrics = [{}, {}, {}];
var i;
for (var key in sigmas) {
    if (sigmas.hasOwnProperty(key)) {
        for (i = 0; i < 3; i++) {
            metrics[i][key] = sigmas[key][i];
        }
    }
}
for (i = 0; i < 3; i++) {
    metrics[i].emPerEx = sigmas.xHeight[i] / sigmas.quad[i];
}

/**
 * The main style class. Contains a unique id for the style, a size (which is
 * the same for cramped and uncramped version of a style), a cramped flag, and a
 * size multiplier, which gives the size difference between a style and
 * textstyle.
 */
function Style(id, size, multiplier, cramped) {
    this.id = id;
    this.size = size;
    this.cramped = cramped;
    this.sizeMultiplier = multiplier;
    this.metrics = metrics[size > 0 ? size - 1 : 0];
}

/**
 * Get the style of a superscript given a base in the current style.
 */
Style.prototype.sup = function() {
    return styles[sup[this.id]];
};

/**
 * Get the style of a subscript given a base in the current style.
 */
Style.prototype.sub = function() {
    return styles[sub[this.id]];
};

/**
 * Get the style of a fraction numerator given the fraction in the current
 * style.
 */
Style.prototype.fracNum = function() {
    return styles[fracNum[this.id]];
};

/**
 * Get the style of a fraction denominator given the fraction in the current
 * style.
 */
Style.prototype.fracDen = function() {
    return styles[fracDen[this.id]];
};

/**
 * Get the cramped version of a style (in particular, cramping a cramped style
 * doesn't change the style).
 */
Style.prototype.cramp = function() {
    return styles[cramp[this.id]];
};

/**
 * HTML class name, like "displaystyle cramped"
 */
Style.prototype.cls = function() {
    return sizeNames[this.size] + (this.cramped ? " cramped" : " uncramped");
};

/**
 * HTML Reset class name, like "reset-textstyle"
 */
Style.prototype.reset = function() {
    return resetNames[this.size];
};

/**
 * Return if this style is tightly spaced (scriptstyle/scriptscriptstyle)
 */
Style.prototype.isTight = function() {
    return this.size >= 2;
};

// IDs of the different styles
var D = 0;
var Dc = 1;
var T = 2;
var Tc = 3;
var S = 4;
var Sc = 5;
var SS = 6;
var SSc = 7;

// String names for the different sizes
var sizeNames = [
    "displaystyle textstyle",
    "textstyle",
    "scriptstyle",
    "scriptscriptstyle"
];

// Reset names for the different sizes
var resetNames = [
    "reset-textstyle",
    "reset-textstyle",
    "reset-scriptstyle",
    "reset-scriptscriptstyle"
];

// Instances of the different styles
var styles = [
    new Style(D, 0, 1.0, false),
    new Style(Dc, 0, 1.0, true),
    new Style(T, 1, 1.0, false),
    new Style(Tc, 1, 1.0, true),
    new Style(S, 2, 0.7, false),
    new Style(Sc, 2, 0.7, true),
    new Style(SS, 3, 0.5, false),
    new Style(SSc, 3, 0.5, true)
];

// Lookup tables for switching from one style to another
var sup = [S, Sc, S, Sc, SS, SSc, SS, SSc];
var sub = [Sc, Sc, Sc, Sc, SSc, SSc, SSc, SSc];
var fracNum = [T, Tc, S, Sc, SS, SSc, SS, SSc];
var fracDen = [Tc, Tc, Sc, Sc, SSc, SSc, SSc, SSc];
var cramp = [Dc, Dc, Tc, Tc, Sc, Sc, SSc, SSc];

// We only export some of the styles. Also, we don't export the `Style` class so
// no more styles can be generated.
module.exports = {
    DISPLAY: styles[D],
    TEXT: styles[T],
    SCRIPT: styles[S],
    SCRIPTSCRIPT: styles[SS]
};

},{"./fontMetrics.js":96}],89:[function(require,module,exports){
/* eslint no-console:0 */
/**
 * This module contains general functions that can be used for building
 * different kinds of domTree nodes in a consistent manner.
 */

var domTree = require("./domTree");
var fontMetrics = require("./fontMetrics");
var symbols = require("./symbols");
var utils = require("./utils");

var greekCapitals = [
    "\\Gamma",
    "\\Delta",
    "\\Theta",
    "\\Lambda",
    "\\Xi",
    "\\Pi",
    "\\Sigma",
    "\\Upsilon",
    "\\Phi",
    "\\Psi",
    "\\Omega"
];

// The following have to be loaded from Main-Italic font, using class mainit
var mainitLetters = [
    "\u0131",   // dotless i, \imath
    "\u0237",   // dotless j, \jmath
    "\u00a3"   // \pounds
];

/**
 * Makes a symbolNode after translation via the list of symbols in symbols.js.
 * Correctly pulls out metrics for the character, and optionally takes a list of
 * classes to be attached to the node.
 *
 * TODO: make argument order closer to makeSpan
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 */
var makeSymbol = function(value, fontFamily, mode, options, classes) {
    // Replace the value with its replaced value from symbol.js
    if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var metrics = fontMetrics.getCharacterMetrics(value, fontFamily);

    var symbolNode;
    if (metrics) {
        var italic = metrics.italic;
        if (mode === "text") {
            italic = 0;
        }
        symbolNode = new domTree.symbolNode(
            value, metrics.height, metrics.depth, italic, metrics.skew,
            classes);
    } else {
        // TODO(emily): Figure out a good way to only print this in development
        typeof console !== "undefined" && console.warn(
            "No character metrics for '" + value + "' in style '" +
                fontFamily + "'");
        symbolNode = new domTree.symbolNode(value, 0, 0, 0, 0, classes);
    }

    if (options) {
        if (options.style.isTight()) {
            symbolNode.classes.push("mtight");
        }
        if (options.getColor()) {
            symbolNode.style.color = options.getColor();
        }
    }

    return symbolNode;
};

/**
 * Makes a symbol in Main-Regular or AMS-Regular.
 * Used for rel, bin, open, close, inner, and punct.
 */
var mathsym = function(value, mode, options, classes) {
    // Decide what font to render the symbol in by its entry in the symbols
    // table.
    // Have a special case for when the value = \ because the \ is used as a
    // textord in unsupported command errors but cannot be parsed as a regular
    // text ordinal and is therefore not present as a symbol in the symbols
    // table for text
    if (value === "\\" || symbols[mode][value].font === "main") {
        return makeSymbol(value, "Main-Regular", mode, options, classes);
    } else {
        return makeSymbol(
            value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
    }
};

/**
 * Makes a symbol in the default font for mathords and textords.
 */
var mathDefault = function(value, mode, options, classes, type) {
    if (type === "mathord") {
        return mathit(value, mode, options, classes);
    } else if (type === "textord") {
        return makeSymbol(
            value, "Main-Regular", mode, options, classes.concat(["mathrm"]));
    } else {
        throw new Error("unexpected type: " + type + " in mathDefault");
    }
};

/**
 * Makes a symbol in the italic math font.
 */
var mathit = function(value, mode, options, classes) {
    if (/[0-9]/.test(value.charAt(0)) ||
            // glyphs for \imath and \jmath do not exist in Math-Italic so we
            // need to use Main-Italic instead
            utils.contains(mainitLetters, value) ||
            utils.contains(greekCapitals, value)) {
        return makeSymbol(
            value, "Main-Italic", mode, options, classes.concat(["mainit"]));
    } else {
        return makeSymbol(
            value, "Math-Italic", mode, options, classes.concat(["mathit"]));
    }
};

/**
 * Makes either a mathord or textord in the correct font and color.
 */
var makeOrd = function(group, options, type) {
    var mode = group.mode;
    var value = group.value;
    if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var classes = ["mord"];

    var font = options.font;
    if (font) {
        if (font === "mathit" || utils.contains(mainitLetters, value)) {
            return mathit(value, mode, options, classes);
        } else {
            var fontName = fontMap[font].fontName;
            if (fontMetrics.getCharacterMetrics(value, fontName)) {
                return makeSymbol(
                    value, fontName, mode, options, classes.concat([font]));
            } else {
                return mathDefault(value, mode, options, classes, type);
            }
        }
    } else {
        return mathDefault(value, mode, options, classes, type);
    }
};

/**
 * Calculate the height, depth, and maxFontSize of an element based on its
 * children.
 */
var sizeElementFromChildren = function(elem) {
    var height = 0;
    var depth = 0;
    var maxFontSize = 0;

    if (elem.children) {
        for (var i = 0; i < elem.children.length; i++) {
            if (elem.children[i].height > height) {
                height = elem.children[i].height;
            }
            if (elem.children[i].depth > depth) {
                depth = elem.children[i].depth;
            }
            if (elem.children[i].maxFontSize > maxFontSize) {
                maxFontSize = elem.children[i].maxFontSize;
            }
        }
    }

    elem.height = height;
    elem.depth = depth;
    elem.maxFontSize = maxFontSize;
};

/**
 * Makes a span with the given list of classes, list of children, and options.
 *
 * TODO: Ensure that `options` is always provided (currently some call sites
 * don't pass it).
 * TODO: add a separate argument for math class (e.g. `mop`, `mbin`), which
 * should if present come first in `classes`.
 */
var makeSpan = function(classes, children, options) {
    var span = new domTree.span(classes, children, options);

    sizeElementFromChildren(span);

    return span;
};

/**
 * Prepends the given children to the given span, updating height, depth, and
 * maxFontSize.
 */
var prependChildren = function(span, children) {
    span.children = children.concat(span.children);

    sizeElementFromChildren(span);
};

/**
 * Makes a document fragment with the given list of children.
 */
var makeFragment = function(children) {
    var fragment = new domTree.documentFragment(children);

    sizeElementFromChildren(fragment);

    return fragment;
};

/**
 * Makes an element placed in each of the vlist elements to ensure that each
 * element has the same max font size. To do this, we create a zero-width space
 * with the correct font size.
 */
var makeFontSizer = function(options, fontSize) {
    var fontSizeInner = makeSpan([], [new domTree.symbolNode("\u200b")]);
    fontSizeInner.style.fontSize =
        (fontSize / options.style.sizeMultiplier) + "em";

    var fontSizer = makeSpan(
        ["fontsize-ensurer", "reset-" + options.size, "size5"],
        [fontSizeInner]);

    return fontSizer;
};

/**
 * Makes a vertical list by stacking elements and kerns on top of each other.
 * Allows for many different ways of specifying the positioning method.
 *
 * Arguments:
 *  - children: A list of child or kern nodes to be stacked on top of each other
 *              (i.e. the first element will be at the bottom, and the last at
 *              the top). Element nodes are specified as
 *                {type: "elem", elem: node}
 *              while kern nodes are specified as
 *                {type: "kern", size: size}
 *  - positionType: The method by which the vlist should be positioned. Valid
 *                  values are:
 *                   - "individualShift": The children list only contains elem
 *                                        nodes, and each node contains an extra
 *                                        "shift" value of how much it should be
 *                                        shifted (note that shifting is always
 *                                        moving downwards). positionData is
 *                                        ignored.
 *                   - "top": The positionData specifies the topmost point of
 *                            the vlist (note this is expected to be a height,
 *                            so positive values move up)
 *                   - "bottom": The positionData specifies the bottommost point
 *                               of the vlist (note this is expected to be a
 *                               depth, so positive values move down
 *                   - "shift": The vlist will be positioned such that its
 *                              baseline is positionData away from the baseline
 *                              of the first child. Positive values move
 *                              downwards.
 *                   - "firstBaseline": The vlist will be positioned such that
 *                                      its baseline is aligned with the
 *                                      baseline of the first child.
 *                                      positionData is ignored. (this is
 *                                      equivalent to "shift" with
 *                                      positionData=0)
 *  - positionData: Data used in different ways depending on positionType
 *  - options: An Options object
 *
 */
var makeVList = function(children, positionType, positionData, options) {
    var depth;
    var currPos;
    var i;
    if (positionType === "individualShift") {
        var oldChildren = children;
        children = [oldChildren[0]];

        // Add in kerns to the list of children to get each element to be
        // shifted to the correct specified shift
        depth = -oldChildren[0].shift - oldChildren[0].elem.depth;
        currPos = depth;
        for (i = 1; i < oldChildren.length; i++) {
            var diff = -oldChildren[i].shift - currPos -
                oldChildren[i].elem.depth;
            var size = diff -
                (oldChildren[i - 1].elem.height +
                 oldChildren[i - 1].elem.depth);

            currPos = currPos + diff;

            children.push({type: "kern", size: size});
            children.push(oldChildren[i]);
        }
    } else if (positionType === "top") {
        // We always start at the bottom, so calculate the bottom by adding up
        // all the sizes
        var bottom = positionData;
        for (i = 0; i < children.length; i++) {
            if (children[i].type === "kern") {
                bottom -= children[i].size;
            } else {
                bottom -= children[i].elem.height + children[i].elem.depth;
            }
        }
        depth = bottom;
    } else if (positionType === "bottom") {
        depth = -positionData;
    } else if (positionType === "shift") {
        depth = -children[0].elem.depth - positionData;
    } else if (positionType === "firstBaseline") {
        depth = -children[0].elem.depth;
    } else {
        depth = 0;
    }

    // Make the fontSizer
    var maxFontSize = 0;
    for (i = 0; i < children.length; i++) {
        if (children[i].type === "elem") {
            maxFontSize = Math.max(maxFontSize, children[i].elem.maxFontSize);
        }
    }
    var fontSizer = makeFontSizer(options, maxFontSize);

    // Create a new list of actual children at the correct offsets
    var realChildren = [];
    currPos = depth;
    for (i = 0; i < children.length; i++) {
        if (children[i].type === "kern") {
            currPos += children[i].size;
        } else {
            var child = children[i].elem;

            var shift = -child.depth - currPos;
            currPos += child.height + child.depth;

            var childWrap = makeSpan([], [fontSizer, child]);
            childWrap.height -= shift;
            childWrap.depth += shift;
            childWrap.style.top = shift + "em";

            realChildren.push(childWrap);
        }
    }

    // Add in an element at the end with no offset to fix the calculation of
    // baselines in some browsers (namely IE, sometimes safari)
    var baselineFix = makeSpan(
        ["baseline-fix"], [fontSizer, new domTree.symbolNode("\u200b")]);
    realChildren.push(baselineFix);

    var vlist = makeSpan(["vlist"], realChildren);
    // Fix the final height and depth, in case there were kerns at the ends
    // since the makeSpan calculation won't take that in to account.
    vlist.height = Math.max(currPos, vlist.height);
    vlist.depth = Math.max(-depth, vlist.depth);
    return vlist;
};

// A table of size -> font size for the different sizing functions
var sizingMultiplier = {
    size1: 0.5,
    size2: 0.7,
    size3: 0.8,
    size4: 0.9,
    size5: 1.0,
    size6: 1.2,
    size7: 1.44,
    size8: 1.73,
    size9: 2.07,
    size10: 2.49
};

// A map of spacing functions to their attributes, like size and corresponding
// CSS class
var spacingFunctions = {
    "\\qquad": {
        size: "2em",
        className: "qquad"
    },
    "\\quad": {
        size: "1em",
        className: "quad"
    },
    "\\enspace": {
        size: "0.5em",
        className: "enspace"
    },
    "\\;": {
        size: "0.277778em",
        className: "thickspace"
    },
    "\\:": {
        size: "0.22222em",
        className: "mediumspace"
    },
    "\\,": {
        size: "0.16667em",
        className: "thinspace"
    },
    "\\!": {
        size: "-0.16667em",
        className: "negativethinspace"
    }
};

/**
 * Maps TeX font commands to objects containing:
 * - variant: string used for "mathvariant" attribute in buildMathML.js
 * - fontName: the "style" parameter to fontMetrics.getCharacterMetrics
 */
// A map between tex font commands an MathML mathvariant attribute values
var fontMap = {
    // styles
    "mathbf": {
        variant: "bold",
        fontName: "Main-Bold"
    },
    "mathrm": {
        variant: "normal",
        fontName: "Main-Regular"
    },
    "textit": {
        variant: "italic",
        fontName: "Main-Italic"
    },

    // "mathit" is missing because it requires the use of two fonts: Main-Italic
    // and Math-Italic.  This is handled by a special case in makeOrd which ends
    // up calling mathit.

    // families
    "mathbb": {
        variant: "double-struck",
        fontName: "AMS-Regular"
    },
    "mathcal": {
        variant: "script",
        fontName: "Caligraphic-Regular"
    },
    "mathfrak": {
        variant: "fraktur",
        fontName: "Fraktur-Regular"
    },
    "mathscr": {
        variant: "script",
        fontName: "Script-Regular"
    },
    "mathsf": {
        variant: "sans-serif",
        fontName: "SansSerif-Regular"
    },
    "mathtt": {
        variant: "monospace",
        fontName: "Typewriter-Regular"
    }
};

module.exports = {
    fontMap: fontMap,
    makeSymbol: makeSymbol,
    mathsym: mathsym,
    makeSpan: makeSpan,
    makeFragment: makeFragment,
    makeVList: makeVList,
    makeOrd: makeOrd,
    prependChildren: prependChildren,
    sizingMultiplier: sizingMultiplier,
    spacingFunctions: spacingFunctions
};

},{"./domTree":94,"./fontMetrics":96,"./symbols":102,"./utils":104}],90:[function(require,module,exports){
/* eslint no-console:0 */
/**
 * This file does the main work of building a domTree structure from a parse
 * tree. The entry point is the `buildHTML` function, which takes a parse tree.
 * Then, the buildExpression, buildGroup, and various groupTypes functions are
 * called, to produce a final HTML tree.
 */

var ParseError = require("./ParseError");
var Style = require("./Style");

var buildCommon = require("./buildCommon");
var delimiter = require("./delimiter");
var domTree = require("./domTree");
var fontMetrics = require("./fontMetrics");
var utils = require("./utils");

var makeSpan = buildCommon.makeSpan;

var isSpace = function(node) {
    return node instanceof domTree.span && node.classes[0] === "mspace";
};

// Binary atoms (first class `mbin`) change into ordinary atoms (`mord`)
// depending on their surroundings. See TeXbook pg. 442-446, Rules 5 and 6,
// and the text before Rule 19.

var isBin = function(node) {
    return node && node.classes[0] === "mbin";
};

var isBinLeftCanceller = function(node, isRealGroup) {
    // TODO: This code assumes that a node's math class is the first element
    // of its `classes` array. A later cleanup should ensure this, for
    // instance by changing the signature of `makeSpan`.
    if (node) {
        return utils.contains(["mbin", "mopen", "mrel", "mop", "mpunct"],
                              node.classes[0]);
    } else {
        return isRealGroup;
    }
};

var isBinRightCanceller = function(node, isRealGroup) {
    if (node) {
        return utils.contains(["mrel", "mclose", "mpunct"], node.classes[0]);
    } else {
        return isRealGroup;
    }
};

/**
 * Take a list of nodes, build them in order, and return a list of the built
 * nodes. documentFragments are flattened into their contents, so the
 * returned list contains no fragments. `isRealGroup` is true if `expression`
 * is a real group (no atoms will be added on either side), as opposed to
 * a partial group (e.g. one created by \color).
 */
var buildExpression = function(expression, options, isRealGroup) {
    // Parse expressions into `groups`.
    var groups = [];
    for (var i = 0; i < expression.length; i++) {
        var group = expression[i];
        var output = buildGroup(group, options);
        if (output instanceof domTree.documentFragment) {
            Array.prototype.push.apply(groups, output.children);
        } else {
            groups.push(output);
        }
    }
    // At this point `groups` consists entirely of `symbolNode`s and `span`s.

    // Explicit spaces (e.g., \;, \,) should be ignored with respect to atom
    // spacing (e.g., "add thick space between mord and mrel"). Since CSS
    // adjacency rules implement atom spacing, spaces should be invisible to
    // CSS. So we splice them out of `groups` and into the atoms themselves.
    var spaces = null;
    for (i = 0; i < groups.length; i++) {
        if (isSpace(groups[i])) {
            spaces = spaces || [];
            spaces.push(groups[i]);
            groups.splice(i, 1);
            i--;
        } else if (spaces) {
            if (groups[i] instanceof domTree.symbolNode) {
                groups[i] = makeSpan([].concat(groups[i].classes), [groups[i]]);
            }
            buildCommon.prependChildren(groups[i], spaces);
            spaces = null;
        }
    }
    if (spaces) {
        Array.prototype.push.apply(groups, spaces);
    }

    // Binary operators change to ordinary symbols in some contexts.
    for (i = 0; i < groups.length; i++) {
        if (isBin(groups[i])
            && (isBinLeftCanceller(groups[i - 1], isRealGroup)
                || isBinRightCanceller(groups[i + 1], isRealGroup))) {
            groups[i].classes[0] = "mord";
        }
    }

    return groups;
};

// Return math atom class (mclass) of a domTree.
var getTypeOfDomTree = function(node) {
    if (node instanceof domTree.documentFragment) {
        if (node.children.length) {
            return getTypeOfDomTree(
                node.children[node.children.length - 1]);
        }
    } else {
        if (utils.contains(["mord", "mop", "mbin", "mrel", "mopen", "mclose",
            "mpunct", "minner"], node.classes[0])) {
            return node.classes[0];
        }
    }
    return null;
};

/**
 * Sometimes, groups perform special rules when they have superscripts or
 * subscripts attached to them. This function lets the `supsub` group know that
 * its inner element should handle the superscripts and subscripts instead of
 * handling them itself.
 */
var shouldHandleSupSub = function(group, options) {
    if (!group) {
        return false;
    } else if (group.type === "op") {
        // Operators handle supsubs differently when they have limits
        // (e.g. `\displaystyle\sum_2^3`)
        return group.value.limits &&
            (options.style.size === Style.DISPLAY.size ||
            group.value.alwaysHandleSupSub);
    } else if (group.type === "accent") {
        return isCharacterBox(group.value.base);
    } else {
        return null;
    }
};

/**
 * Sometimes we want to pull out the innermost element of a group. In most
 * cases, this will just be the group itself, but when ordgroups and colors have
 * a single element, we want to pull that out.
 */
var getBaseElem = function(group) {
    if (!group) {
        return false;
    } else if (group.type === "ordgroup") {
        if (group.value.length === 1) {
            return getBaseElem(group.value[0]);
        } else {
            return group;
        }
    } else if (group.type === "color") {
        if (group.value.value.length === 1) {
            return getBaseElem(group.value.value[0]);
        } else {
            return group;
        }
    } else if (group.type === "font") {
        return getBaseElem(group.value.body);
    } else {
        return group;
    }
};

/**
 * TeXbook algorithms often reference "character boxes", which are simply groups
 * with a single character in them. To decide if something is a character box,
 * we find its innermost group, and see if it is a single character.
 */
var isCharacterBox = function(group) {
    var baseElem = getBaseElem(group);

    // These are all they types of groups which hold single characters
    return baseElem.type === "mathord" ||
        baseElem.type === "textord" ||
        baseElem.type === "bin" ||
        baseElem.type === "rel" ||
        baseElem.type === "inner" ||
        baseElem.type === "open" ||
        baseElem.type === "close" ||
        baseElem.type === "punct";
};

var makeNullDelimiter = function(options, classes) {
    return makeSpan(classes.concat([
        "sizing", "reset-" + options.size, "size5",
        options.style.reset(), Style.TEXT.cls(),
        "nulldelimiter"]));
};

/**
 * This is a map of group types to the function used to handle that type.
 * Simpler types come at the beginning, while complicated types come afterwards.
 */
var groupTypes = {};

groupTypes.mathord = function(group, options) {
    return buildCommon.makeOrd(group, options, "mathord");
};

groupTypes.textord = function(group, options) {
    return buildCommon.makeOrd(group, options, "textord");
};

groupTypes.bin = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mbin"]);
};

groupTypes.rel = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mrel"]);
};

groupTypes.open = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mopen"]);
};

groupTypes.close = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mclose"]);
};

groupTypes.inner = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["minner"]);
};

groupTypes.punct = function(group, options) {
    return buildCommon.mathsym(
        group.value, group.mode, options, ["mpunct"]);
};

groupTypes.ordgroup = function(group, options) {
    return makeSpan(
        ["mord", options.style.cls()],
        buildExpression(group.value, options.reset(), true),
        options
    );
};

groupTypes.text = function(group, options) {
    var newOptions = options.withFont(group.value.style);
    var inner = buildExpression(group.value.body, newOptions, true);
    for (var i = 0; i < inner.length - 1; i++) {
        if (inner[i].tryCombine(inner[i + 1])) {
            inner.splice(i + 1, 1);
            i--;
        }
    }
    return makeSpan(["mord", "text", newOptions.style.cls()],
        inner, newOptions);
};

groupTypes.color = function(group, options) {
    var elements = buildExpression(
        group.value.value,
        options.withColor(group.value.color),
        false
    );

    // \color isn't supposed to affect the type of the elements it contains.
    // To accomplish this, we wrap the results in a fragment, so the inner
    // elements will be able to directly interact with their neighbors. For
    // example, `\color{red}{2 +} 3` has the same spacing as `2 + 3`
    return new buildCommon.makeFragment(elements);
};

groupTypes.supsub = function(group, options) {
    // Superscript and subscripts are handled in the TeXbook on page
    // 445-446, rules 18(a-f).

    // Here is where we defer to the inner group if it should handle
    // superscripts and subscripts itself.
    if (shouldHandleSupSub(group.value.base, options)) {
        return groupTypes[group.value.base.type](group, options);
    }

    var base = buildGroup(group.value.base, options.reset());
    var supmid;
    var submid;
    var sup;
    var sub;

    var style = options.style;
    var newOptions;

    if (group.value.sup) {
        newOptions = options.withStyle(style.sup());
        sup = buildGroup(group.value.sup, newOptions);
        supmid = makeSpan([style.reset(), style.sup().cls()],
            [sup], newOptions);
    }

    if (group.value.sub) {
        newOptions = options.withStyle(style.sub());
        sub = buildGroup(group.value.sub, newOptions);
        submid = makeSpan([style.reset(), style.sub().cls()],
            [sub], newOptions);
    }

    // Rule 18a
    var supShift;
    var subShift;
    if (isCharacterBox(group.value.base)) {
        supShift = 0;
        subShift = 0;
    } else {
        supShift = base.height - style.metrics.supDrop;
        subShift = base.depth + style.metrics.subDrop;
    }

    // Rule 18c
    var minSupShift;
    if (style === Style.DISPLAY) {
        minSupShift = style.metrics.sup1;
    } else if (style.cramped) {
        minSupShift = style.metrics.sup3;
    } else {
        minSupShift = style.metrics.sup2;
    }

    // scriptspace is a font-size-independent size, so scale it
    // appropriately
    var multiplier = Style.TEXT.sizeMultiplier *
            style.sizeMultiplier;
    var scriptspace =
        (0.5 / fontMetrics.metrics.ptPerEm) / multiplier + "em";

    var supsub;
    if (!group.value.sup) {
        // Rule 18b
        subShift = Math.max(
            subShift, style.metrics.sub1,
            sub.height - 0.8 * style.metrics.xHeight);

        supsub = buildCommon.makeVList([
            {type: "elem", elem: submid}
        ], "shift", subShift, options);

        supsub.children[0].style.marginRight = scriptspace;

        // Subscripts shouldn't be shifted by the base's italic correction.
        // Account for that by shifting the subscript back the appropriate
        // amount. Note we only do this when the base is a single symbol.
        if (base instanceof domTree.symbolNode) {
            supsub.children[0].style.marginLeft = -base.italic + "em";
        }
    } else if (!group.value.sub) {
        // Rule 18c, d
        supShift = Math.max(supShift, minSupShift,
            sup.depth + 0.25 * style.metrics.xHeight);

        supsub = buildCommon.makeVList([
            {type: "elem", elem: supmid}
        ], "shift", -supShift, options);

        supsub.children[0].style.marginRight = scriptspace;
    } else {
        supShift = Math.max(
            supShift, minSupShift, sup.depth + 0.25 * style.metrics.xHeight);
        subShift = Math.max(subShift, style.metrics.sub2);

        var ruleWidth = fontMetrics.metrics.defaultRuleThickness;

        // Rule 18e
        if ((supShift - sup.depth) - (sub.height - subShift) <
                4 * ruleWidth) {
            subShift = 4 * ruleWidth - (supShift - sup.depth) + sub.height;
            var psi = 0.8 * style.metrics.xHeight - (supShift - sup.depth);
            if (psi > 0) {
                supShift += psi;
                subShift -= psi;
            }
        }

        supsub = buildCommon.makeVList([
            {type: "elem", elem: submid, shift: subShift},
            {type: "elem", elem: supmid, shift: -supShift}
        ], "individualShift", null, options);

        // See comment above about subscripts not being shifted
        if (base instanceof domTree.symbolNode) {
            supsub.children[0].style.marginLeft = -base.italic + "em";
        }

        supsub.children[0].style.marginRight = scriptspace;
        supsub.children[1].style.marginRight = scriptspace;
    }

    // We ensure to wrap the supsub vlist in a span.msupsub to reset text-align
    var mclass = getTypeOfDomTree(base) || "mord";
    return makeSpan([mclass],
        [base, makeSpan(["msupsub"], [supsub])],
        options);
};

groupTypes.genfrac = function(group, options) {
    // Fractions are handled in the TeXbook on pages 444-445, rules 15(a-e).
    // Figure out what style this fraction should be in based on the
    // function used
    var style = options.style;
    if (group.value.size === "display") {
        style = Style.DISPLAY;
    } else if (group.value.size === "text") {
        style = Style.TEXT;
    }

    var nstyle = style.fracNum();
    var dstyle = style.fracDen();
    var newOptions;

    newOptions = options.withStyle(nstyle);
    var numer = buildGroup(group.value.numer, newOptions);
    var numerreset = makeSpan([style.reset(), nstyle.cls()],
        [numer], newOptions);

    newOptions = options.withStyle(dstyle);
    var denom = buildGroup(group.value.denom, newOptions);
    var denomreset = makeSpan([style.reset(), dstyle.cls()],
        [denom], newOptions);

    var ruleWidth;
    if (group.value.hasBarLine) {
        ruleWidth = fontMetrics.metrics.defaultRuleThickness /
            options.style.sizeMultiplier;
    } else {
        ruleWidth = 0;
    }

    // Rule 15b
    var numShift;
    var clearance;
    var denomShift;
    if (style.size === Style.DISPLAY.size) {
        numShift = style.metrics.num1;
        if (ruleWidth > 0) {
            clearance = 3 * ruleWidth;
        } else {
            clearance = 7 * fontMetrics.metrics.defaultRuleThickness;
        }
        denomShift = style.metrics.denom1;
    } else {
        if (ruleWidth > 0) {
            numShift = style.metrics.num2;
            clearance = ruleWidth;
        } else {
            numShift = style.metrics.num3;
            clearance = 3 * fontMetrics.metrics.defaultRuleThickness;
        }
        denomShift = style.metrics.denom2;
    }

    var frac;
    if (ruleWidth === 0) {
        // Rule 15c
        var candidateClearance =
            (numShift - numer.depth) - (denom.height - denomShift);
        if (candidateClearance < clearance) {
            numShift += 0.5 * (clearance - candidateClearance);
            denomShift += 0.5 * (clearance - candidateClearance);
        }

        frac = buildCommon.makeVList([
            {type: "elem", elem: denomreset, shift: denomShift},
            {type: "elem", elem: numerreset, shift: -numShift}
        ], "individualShift", null, options);
    } else {
        // Rule 15d
        var axisHeight = style.metrics.axisHeight;

        if ((numShift - numer.depth) - (axisHeight + 0.5 * ruleWidth) <
                clearance) {
            numShift +=
                clearance - ((numShift - numer.depth) -
                             (axisHeight + 0.5 * ruleWidth));
        }

        if ((axisHeight - 0.5 * ruleWidth) - (denom.height - denomShift) <
                clearance) {
            denomShift +=
                clearance - ((axisHeight - 0.5 * ruleWidth) -
                             (denom.height - denomShift));
        }

        var mid = makeSpan(
            [options.style.reset(), Style.TEXT.cls(), "frac-line"]);
        // Manually set the height of the line because its height is
        // created in CSS
        mid.height = ruleWidth;

        var midShift = -(axisHeight - 0.5 * ruleWidth);

        frac = buildCommon.makeVList([
            {type: "elem", elem: denomreset, shift: denomShift},
            {type: "elem", elem: mid,        shift: midShift},
            {type: "elem", elem: numerreset, shift: -numShift}
        ], "individualShift", null, options);
    }

    // Since we manually change the style sometimes (with \dfrac or \tfrac),
    // account for the possible size change here.
    frac.height *= style.sizeMultiplier / options.style.sizeMultiplier;
    frac.depth *= style.sizeMultiplier / options.style.sizeMultiplier;

    // Rule 15e
    var delimSize;
    if (style.size === Style.DISPLAY.size) {
        delimSize = style.metrics.delim1;
    } else {
        delimSize = style.metrics.delim2;
    }

    var leftDelim;
    var rightDelim;
    if (group.value.leftDelim == null) {
        leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
        leftDelim = delimiter.customSizedDelim(
            group.value.leftDelim, delimSize, true,
            options.withStyle(style), group.mode, ["mopen"]);
    }
    if (group.value.rightDelim == null) {
        rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
        rightDelim = delimiter.customSizedDelim(
            group.value.rightDelim, delimSize, true,
            options.withStyle(style), group.mode, ["mclose"]);
    }

    return makeSpan(
        ["mord", options.style.reset(), style.cls()],
        [leftDelim, makeSpan(["mfrac"], [frac]), rightDelim],
        options);
};

var calculateSize = function(sizeValue, style) {
    var x = sizeValue.number;
    if (sizeValue.unit === "ex") {
        x *= style.metrics.emPerEx;
    } else if (sizeValue.unit === "mu") {
        x /= 18;
    }
    return x;
};

groupTypes.array = function(group, options) {
    var r;
    var c;
    var nr = group.value.body.length;
    var nc = 0;
    var body = new Array(nr);

    var style = options.style;

    // Horizontal spacing
    var pt = 1 / fontMetrics.metrics.ptPerEm;
    var arraycolsep = 5 * pt; // \arraycolsep in article.cls

    // Vertical spacing
    var baselineskip = 12 * pt; // see size10.clo
    // Default \arraystretch from lttab.dtx
    // TODO(gagern): may get redefined once we have user-defined macros
    var arraystretch = utils.deflt(group.value.arraystretch, 1);
    var arrayskip = arraystretch * baselineskip;
    var arstrutHeight = 0.7 * arrayskip; // \strutbox in ltfsstrc.dtx and
    var arstrutDepth = 0.3 * arrayskip;  // \@arstrutbox in lttab.dtx

    var totalHeight = 0;
    for (r = 0; r < group.value.body.length; ++r) {
        var inrow = group.value.body[r];
        var height = arstrutHeight; // \@array adds an \@arstrut
        var depth = arstrutDepth;   // to each tow (via the template)

        if (nc < inrow.length) {
            nc = inrow.length;
        }

        var outrow = new Array(inrow.length);
        for (c = 0; c < inrow.length; ++c) {
            var elt = buildGroup(inrow[c], options);
            if (depth < elt.depth) {
                depth = elt.depth;
            }
            if (height < elt.height) {
                height = elt.height;
            }
            outrow[c] = elt;
        }

        var gap = 0;
        if (group.value.rowGaps[r]) {
            gap = calculateSize(group.value.rowGaps[r].value, style);
            if (gap > 0) { // \@argarraycr
                gap += arstrutDepth;
                if (depth < gap) {
                    depth = gap; // \@xargarraycr
                }
                gap = 0;
            }
        }

        outrow.height = height;
        outrow.depth = depth;
        totalHeight += height;
        outrow.pos = totalHeight;
        totalHeight += depth + gap; // \@yargarraycr
        body[r] = outrow;
    }

    var offset = totalHeight / 2 + style.metrics.axisHeight;
    var colDescriptions = group.value.cols || [];
    var cols = [];
    var colSep;
    var colDescrNum;
    for (c = 0, colDescrNum = 0;
         // Continue while either there are more columns or more column
         // descriptions, so trailing separators don't get lost.
         c < nc || colDescrNum < colDescriptions.length;
         ++c, ++colDescrNum) {

        var colDescr = colDescriptions[colDescrNum] || {};

        var firstSeparator = true;
        while (colDescr.type === "separator") {
            // If there is more than one separator in a row, add a space
            // between them.
            if (!firstSeparator) {
                colSep = makeSpan(["arraycolsep"], []);
                colSep.style.width =
                    fontMetrics.metrics.doubleRuleSep + "em";
                cols.push(colSep);
            }

            if (colDescr.separator === "|") {
                var separator = makeSpan(
                    ["vertical-separator"],
                    []);
                separator.style.height = totalHeight + "em";
                separator.style.verticalAlign =
                    -(totalHeight - offset) + "em";

                cols.push(separator);
            } else {
                throw new ParseError(
                    "Invalid separator type: " + colDescr.separator);
            }

            colDescrNum++;
            colDescr = colDescriptions[colDescrNum] || {};
            firstSeparator = false;
        }

        if (c >= nc) {
            continue;
        }

        var sepwidth;
        if (c > 0 || group.value.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
            if (sepwidth !== 0) {
                colSep = makeSpan(["arraycolsep"], []);
                colSep.style.width = sepwidth + "em";
                cols.push(colSep);
            }
        }

        var col = [];
        for (r = 0; r < nr; ++r) {
            var row = body[r];
            var elem = row[c];
            if (!elem) {
                continue;
            }
            var shift = row.pos - offset;
            elem.depth = row.depth;
            elem.height = row.height;
            col.push({type: "elem", elem: elem, shift: shift});
        }

        col = buildCommon.makeVList(col, "individualShift", null, options);
        col = makeSpan(
            ["col-align-" + (colDescr.align || "c")],
            [col]);
        cols.push(col);

        if (c < nc - 1 || group.value.hskipBeforeAndAfter) {
            sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
            if (sepwidth !== 0) {
                colSep = makeSpan(["arraycolsep"], []);
                colSep.style.width = sepwidth + "em";
                cols.push(colSep);
            }
        }
    }
    body = makeSpan(["mtable"], cols);
    return makeSpan(["mord"], [body], options);
};

groupTypes.spacing = function(group, options) {
    if (group.value === "\\ " || group.value === "\\space" ||
        group.value === " " || group.value === "~") {
        // Spaces are generated by adding an actual space. Each of these
        // things has an entry in the symbols table, so these will be turned
        // into appropriate outputs.
        if (group.mode === "text") {
            return buildCommon.makeOrd(group, options, "textord");
        } else {
            return makeSpan(["mspace"],
                [buildCommon.mathsym(group.value, group.mode, options)],
                options);
        }
    } else {
        // Other kinds of spaces are of arbitrary width. We use CSS to
        // generate these.
        return makeSpan(
            ["mspace",
                buildCommon.spacingFunctions[group.value].className],
            [], options);
    }
};

groupTypes.llap = function(group, options) {
    var inner = makeSpan(
        ["inner"], [buildGroup(group.value.body, options.reset())]);
    var fix = makeSpan(["fix"], []);
    return makeSpan(
        ["mord", "llap", options.style.cls()], [inner, fix], options);
};

groupTypes.rlap = function(group, options) {
    var inner = makeSpan(
        ["inner"], [buildGroup(group.value.body, options.reset())]);
    var fix = makeSpan(["fix"], []);
    return makeSpan(
        ["mord", "rlap", options.style.cls()], [inner, fix], options);
};

groupTypes.op = function(group, options) {
    // Operators are handled in the TeXbook pg. 443-444, rule 13(a).
    var supGroup;
    var subGroup;
    var hasLimits = false;
    if (group.type === "supsub") {
        // If we have limits, supsub will pass us its group to handle. Pull
        // out the superscript and subscript and set the group to the op in
        // its base.
        supGroup = group.value.sup;
        subGroup = group.value.sub;
        group = group.value.base;
        hasLimits = true;
    }

    var style = options.style;

    // Most operators have a large successor symbol, but these don't.
    var noSuccessor = [
        "\\smallint"
    ];

    var large = false;
    if (style.size === Style.DISPLAY.size &&
        group.value.symbol &&
        !utils.contains(noSuccessor, group.value.body)) {

        // Most symbol operators get larger in displaystyle (rule 13)
        large = true;
    }

    var base;
    var baseShift = 0;
    var slant = 0;
    if (group.value.symbol) {
        // If this is a symbol, create the symbol.
        var fontName = large ? "Size2-Regular" : "Size1-Regular";
        base = buildCommon.makeSymbol(
            group.value.body, fontName, "math", options,
            ["mop", "op-symbol", large ? "large-op" : "small-op"]);

        // Shift the symbol so its center lies on the axis (rule 13). It
        // appears that our fonts have the centers of the symbols already
        // almost on the axis, so these numbers are very small. Note we
        // don't actually apply this here, but instead it is used either in
        // the vlist creation or separately when there are no limits.
        baseShift = (base.height - base.depth) / 2 -
            style.metrics.axisHeight * style.sizeMultiplier;

        // The slant of the symbol is just its italic correction.
        slant = base.italic;
    } else if (group.value.value) {
        // If this is a list, compose that list.
        var inner = buildExpression(group.value.value, options, true);

        base = makeSpan(["mop"], inner, options);
    } else {
        // Otherwise, this is a text operator. Build the text from the
        // operator's name.
        // TODO(emily): Add a space in the middle of some of these
        // operators, like \limsup
        var output = [];
        for (var i = 1; i < group.value.body.length; i++) {
            output.push(buildCommon.mathsym(group.value.body[i], group.mode));
        }
        base = makeSpan(["mop"], output, options);
    }

    if (hasLimits) {
        // IE 8 clips \int if it is in a display: inline-block. We wrap it
        // in a new span so it is an inline, and works.
        base = makeSpan([], [base]);

        var supmid;
        var supKern;
        var submid;
        var subKern;
        var newOptions;
        // We manually have to handle the superscripts and subscripts. This,
        // aside from the kern calculations, is copied from supsub.
        if (supGroup) {
            newOptions = options.withStyle(style.sup());
            var sup = buildGroup(supGroup, newOptions);
            supmid = makeSpan([style.reset(), style.sup().cls()],
                [sup], newOptions);

            supKern = Math.max(
                fontMetrics.metrics.bigOpSpacing1,
                fontMetrics.metrics.bigOpSpacing3 - sup.depth);
        }

        if (subGroup) {
            newOptions = options.withStyle(style.sub());
            var sub = buildGroup(subGroup, newOptions);
            submid = makeSpan([style.reset(), style.sub().cls()],
                [sub], newOptions);

            subKern = Math.max(
                fontMetrics.metrics.bigOpSpacing2,
                fontMetrics.metrics.bigOpSpacing4 - sub.height);
        }

        // Build the final group as a vlist of the possible subscript, base,
        // and possible superscript.
        var finalGroup;
        var top;
        var bottom;
        if (!supGroup) {
            top = base.height - baseShift;

            finalGroup = buildCommon.makeVList([
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5},
                {type: "elem", elem: submid},
                {type: "kern", size: subKern},
                {type: "elem", elem: base}
            ], "top", top, options);

            // Here, we shift the limits by the slant of the symbol. Note
            // that we are supposed to shift the limits by 1/2 of the slant,
            // but since we are centering the limits adding a full slant of
            // margin will shift by 1/2 that.
            finalGroup.children[0].style.marginLeft = -slant + "em";
        } else if (!subGroup) {
            bottom = base.depth + baseShift;

            finalGroup = buildCommon.makeVList([
                {type: "elem", elem: base},
                {type: "kern", size: supKern},
                {type: "elem", elem: supmid},
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5}
            ], "bottom", bottom, options);

            // See comment above about slants
            finalGroup.children[1].style.marginLeft = slant + "em";
        } else if (!supGroup && !subGroup) {
            // This case probably shouldn't occur (this would mean the
            // supsub was sending us a group with no superscript or
            // subscript) but be safe.
            return base;
        } else {
            bottom = fontMetrics.metrics.bigOpSpacing5 +
                submid.height + submid.depth +
                subKern +
                base.depth + baseShift;

            finalGroup = buildCommon.makeVList([
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5},
                {type: "elem", elem: submid},
                {type: "kern", size: subKern},
                {type: "elem", elem: base},
                {type: "kern", size: supKern},
                {type: "elem", elem: supmid},
                {type: "kern", size: fontMetrics.metrics.bigOpSpacing5}
            ], "bottom", bottom, options);

            // See comment above about slants
            finalGroup.children[0].style.marginLeft = -slant + "em";
            finalGroup.children[2].style.marginLeft = slant + "em";
        }

        return makeSpan(["mop", "op-limits"], [finalGroup], options);
    } else {
        if (group.value.symbol) {
            base.style.top = baseShift + "em";
        }

        return base;
    }
};

groupTypes.mod = function(group, options) {
    var inner = [];

    if (group.value.modType === "bmod") {
        // \nonscript\mskip-\medmuskip\mkern5mu
        if (!options.style.isTight()) {
            inner.push(makeSpan(
                ["mspace", "negativemediumspace"], [], options));
        }
        inner.push(makeSpan(["mspace", "thickspace"], [], options));
    } else if (options.style.size === Style.DISPLAY.size) {
        inner.push(makeSpan(["mspace", "quad"], [], options));
    } else if (group.value.modType === "mod") {
        inner.push(makeSpan(["mspace", "twelvemuspace"], [], options));
    } else {
        inner.push(makeSpan(["mspace", "eightmuspace"], [], options));
    }

    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(buildCommon.mathsym("(", group.mode));
    }

    if (group.value.modType !== "pod") {
        var modInner = [
            buildCommon.mathsym("m", group.mode),
            buildCommon.mathsym("o", group.mode),
            buildCommon.mathsym("d", group.mode)];
        if (group.value.modType === "bmod") {
            inner.push(makeSpan(["mbin"], modInner, options));
            // \mkern5mu\nonscript\mskip-\medmuskip
            inner.push(makeSpan(["mspace", "thickspace"], [], options));
            if (!options.style.isTight()) {
                inner.push(makeSpan(
                    ["mspace", "negativemediumspace"], [], options));
            }
        } else {
            Array.prototype.push.apply(inner, modInner);
            inner.push(makeSpan(["mspace", "sixmuspace"], [], options));
        }
    }

    if (group.value.value) {
        Array.prototype.push.apply(inner,
            buildExpression(group.value.value, options, false));
    }

    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(buildCommon.mathsym(")", group.mode));
    }

    return buildCommon.makeFragment(inner);
};

groupTypes.katex = function(group, options) {
    // The KaTeX logo. The offsets for the K and a were chosen to look
    // good, but the offsets for the T, E, and X were taken from the
    // definition of \TeX in TeX (see TeXbook pg. 356)
    var k = makeSpan(
        ["k"], [buildCommon.mathsym("K", group.mode)], options);
    var a = makeSpan(
        ["a"], [buildCommon.mathsym("A", group.mode)], options);

    a.height = (a.height + 0.2) * 0.75;
    a.depth = (a.height - 0.2) * 0.75;

    var t = makeSpan(
        ["t"], [buildCommon.mathsym("T", group.mode)], options);
    var e = makeSpan(
        ["e"], [buildCommon.mathsym("E", group.mode)], options);

    e.height = (e.height - 0.2155);
    e.depth = (e.depth + 0.2155);

    var x = makeSpan(
        ["x"], [buildCommon.mathsym("X", group.mode)], options);

    return makeSpan(
        ["mord", "katex-logo"], [k, a, t, e, x], options);
};

groupTypes.overline = function(group, options) {
    // Overlines are handled in the TeXbook pg 443, Rule 9.
    var style = options.style;

    // Build the inner group in the cramped style.
    var innerGroup = buildGroup(group.value.body,
            options.withStyle(style.cramp()));

    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
        style.sizeMultiplier;

    // Create the line above the body
    var line = makeSpan(
        [style.reset(), Style.TEXT.cls(), "overline-line"]);
    line.height = ruleWidth;
    line.maxFontSize = 1.0;

    // Generate the vlist, with the appropriate kerns
    var vlist = buildCommon.makeVList([
        {type: "elem", elem: innerGroup},
        {type: "kern", size: 3 * ruleWidth},
        {type: "elem", elem: line},
        {type: "kern", size: ruleWidth}
    ], "firstBaseline", null, options);

    return makeSpan(["mord", "overline"], [vlist], options);
};

groupTypes.underline = function(group, options) {
    // Underlines are handled in the TeXbook pg 443, Rule 10.
    var style = options.style;

    // Build the inner group.
    var innerGroup = buildGroup(group.value.body, options);

    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
        style.sizeMultiplier;

    // Create the line above the body
    var line = makeSpan([style.reset(), Style.TEXT.cls(), "underline-line"]);
    line.height = ruleWidth;
    line.maxFontSize = 1.0;

    // Generate the vlist, with the appropriate kerns
    var vlist = buildCommon.makeVList([
        {type: "kern", size: ruleWidth},
        {type: "elem", elem: line},
        {type: "kern", size: 3 * ruleWidth},
        {type: "elem", elem: innerGroup}
    ], "top", innerGroup.height, options);

    return makeSpan(["mord", "underline"], [vlist], options);
};

groupTypes.sqrt = function(group, options) {
    // Square roots are handled in the TeXbook pg. 443, Rule 11.
    var style = options.style;

    // First, we do the same steps as in overline to build the inner group
    // and line
    var inner = buildGroup(group.value.body, options.withStyle(style.cramp()));

    var ruleWidth = fontMetrics.metrics.defaultRuleThickness /
        style.sizeMultiplier;

    var line = makeSpan(
        [style.reset(), Style.TEXT.cls(), "sqrt-line"], [],
        options);
    line.height = ruleWidth;
    line.maxFontSize = 1.0;

    var phi = ruleWidth;
    if (style.id < Style.TEXT.id) {
        phi = style.metrics.xHeight;
    }

    // Calculate the clearance between the body and line
    var lineClearance = ruleWidth + phi / 4;

    var innerHeight = (inner.height + inner.depth) * style.sizeMultiplier;
    var minDelimiterHeight = innerHeight + lineClearance + ruleWidth;

    // Create a \surd delimiter of the required minimum size
    var delim = makeSpan(["sqrt-sign"], [
        delimiter.customSizedDelim("\\surd", minDelimiterHeight,
                                   false, options, group.mode)],
                         options);

    var delimDepth = (delim.height + delim.depth) - ruleWidth;

    // Adjust the clearance based on the delimiter size
    if (delimDepth > inner.height + inner.depth + lineClearance) {
        lineClearance =
            (lineClearance + delimDepth - inner.height - inner.depth) / 2;
    }

    // Shift the delimiter so that its top lines up with the top of the line
    var delimShift = -(inner.height + lineClearance + ruleWidth) + delim.height;
    delim.style.top = delimShift + "em";
    delim.height -= delimShift;
    delim.depth += delimShift;

    // We add a special case here, because even when `inner` is empty, we
    // still get a line. So, we use a simple heuristic to decide if we
    // should omit the body entirely. (note this doesn't work for something
    // like `\sqrt{\rlap{x}}`, but if someone is doing that they deserve for
    // it not to work.
    var body;
    if (inner.height === 0 && inner.depth === 0) {
        body = makeSpan();
    } else {
        body = buildCommon.makeVList([
            {type: "elem", elem: inner},
            {type: "kern", size: lineClearance},
            {type: "elem", elem: line},
            {type: "kern", size: ruleWidth}
        ], "firstBaseline", null, options);
    }

    if (!group.value.index) {
        return makeSpan(["mord", "sqrt"], [delim, body], options);
    } else {
        // Handle the optional root index

        // The index is always in scriptscript style
        var newOptions = options.withStyle(Style.SCRIPTSCRIPT);
        var root = buildGroup(group.value.index, newOptions);
        var rootWrap = makeSpan(
            [style.reset(), Style.SCRIPTSCRIPT.cls()],
            [root],
            newOptions);

        // Figure out the height and depth of the inner part
        var innerRootHeight = Math.max(delim.height, body.height);
        var innerRootDepth = Math.max(delim.depth, body.depth);

        // The amount the index is shifted by. This is taken from the TeX
        // source, in the definition of `\r@@t`.
        var toShift = 0.6 * (innerRootHeight - innerRootDepth);

        // Build a VList with the superscript shifted up correctly
        var rootVList = buildCommon.makeVList(
            [{type: "elem", elem: rootWrap}],
            "shift", -toShift, options);
        // Add a class surrounding it so we can add on the appropriate
        // kerning
        var rootVListWrap = makeSpan(["root"], [rootVList]);

        return makeSpan(["mord", "sqrt"],
            [rootVListWrap, delim, body], options);
    }
};

groupTypes.sizing = function(group, options) {
    // Handle sizing operators like \Huge. Real TeX doesn't actually allow
    // these functions inside of math expressions, so we do some special
    // handling.
    var inner = buildExpression(group.value.value,
            options.withSize(group.value.size), false);

    // Compute the correct maxFontSize.
    var style = options.style;
    var fontSize = buildCommon.sizingMultiplier[group.value.size];
    fontSize = fontSize * style.sizeMultiplier;

    // Add size-resetting classes to the inner list and set maxFontSize
    // manually. Handle nested size changes.
    for (var i = 0; i < inner.length; i++) {
        var pos = utils.indexOf(inner[i].classes, "sizing");
        if (pos < 0) {
            inner[i].classes.push("sizing", "reset-" + options.size,
                                  group.value.size, style.cls());
            inner[i].maxFontSize = fontSize;
        } else if (inner[i].classes[pos + 1] === "reset-" + group.value.size) {
            // This is a nested size change: e.g., inner[i] is the "b" in
            // `\Huge a \small b`. Override the old size (the `reset-` class)
            // but not the new size.
            inner[i].classes[pos + 1] = "reset-" + options.size;
        }
    }

    return buildCommon.makeFragment(inner);
};

groupTypes.styling = function(group, options) {
    // Style changes are handled in the TeXbook on pg. 442, Rule 3.

    // Figure out what style we're changing to.
    var styleMap = {
        "display": Style.DISPLAY,
        "text": Style.TEXT,
        "script": Style.SCRIPT,
        "scriptscript": Style.SCRIPTSCRIPT
    };

    var newStyle = styleMap[group.value.style];
    var newOptions = options.withStyle(newStyle);

    // Build the inner expression in the new style.
    var inner = buildExpression(
        group.value.value, newOptions, false);

    // Add style-resetting classes to the inner list. Handle nested changes.
    for (var i = 0; i < inner.length; i++) {
        var pos = utils.indexOf(inner[i].classes, newStyle.reset());
        if (pos < 0) {
            inner[i].classes.push(options.style.reset(), newStyle.cls());
        } else {
            // This is a nested style change, as `\textstyle a\scriptstyle b`.
            // Only override the old style (the reset class).
            inner[i].classes[pos] = options.style.reset();
        }
    }

    return new buildCommon.makeFragment(inner);
};

groupTypes.font = function(group, options) {
    var font = group.value.font;
    return buildGroup(group.value.body, options.withFont(font));
};

groupTypes.delimsizing = function(group, options) {
    var delim = group.value.value;

    if (delim === ".") {
        // Empty delimiters still count as elements, even though they don't
        // show anything.
        return makeSpan([group.value.mclass]);
    }

    // Use delimiter.sizedDelim to generate the delimiter.
    return delimiter.sizedDelim(
            delim, group.value.size, options, group.mode,
            [group.value.mclass]);
};

groupTypes.leftright = function(group, options) {
    // Build the inner expression
    var inner = buildExpression(group.value.body, options.reset(), true);

    var innerHeight = 0;
    var innerDepth = 0;
    var hadMiddle = false;

    // Calculate its height and depth
    for (var i = 0; i < inner.length; i++) {
        if (inner[i].isMiddle) {
            hadMiddle = true;
        } else {
            innerHeight = Math.max(inner[i].height, innerHeight);
            innerDepth = Math.max(inner[i].depth, innerDepth);
        }
    }

    var style = options.style;

    // The size of delimiters is the same, regardless of what style we are
    // in. Thus, to correctly calculate the size of delimiter we need around
    // a group, we scale down the inner size based on the size.
    innerHeight *= style.sizeMultiplier;
    innerDepth *= style.sizeMultiplier;

    var leftDelim;
    if (group.value.left === ".") {
        // Empty delimiters in \left and \right make null delimiter spaces.
        leftDelim = makeNullDelimiter(options, ["mopen"]);
    } else {
        // Otherwise, use leftRightDelim to generate the correct sized
        // delimiter.
        leftDelim = delimiter.leftRightDelim(
            group.value.left, innerHeight, innerDepth, options,
            group.mode, ["mopen"]);
    }
    // Add it to the beginning of the expression
    inner.unshift(leftDelim);

    // Handle middle delimiters
    if (hadMiddle) {
        for (i = 1; i < inner.length; i++) {
            if (inner[i].isMiddle) {
                // Apply the options that were active when \middle was called
                inner[i] = delimiter.leftRightDelim(
                    inner[i].isMiddle.value, innerHeight, innerDepth,
                    inner[i].isMiddle.options, group.mode, []);
            }
        }
    }

    var rightDelim;
    // Same for the right delimiter
    if (group.value.right === ".") {
        rightDelim = makeNullDelimiter(options, ["mclose"]);
    } else {
        rightDelim = delimiter.leftRightDelim(
            group.value.right, innerHeight, innerDepth, options,
            group.mode, ["mclose"]);
    }
    // Add it to the end of the expression.
    inner.push(rightDelim);

    return makeSpan(
        ["minner", style.cls()], inner, options);
};

groupTypes.middle = function(group, options) {
    var middleDelim;
    if (group.value.value === ".") {
        middleDelim = makeNullDelimiter(options, []);
    } else {
        middleDelim = delimiter.sizedDelim(
            group.value.value, 1, options,
            group.mode, []);
        middleDelim.isMiddle = {value: group.value.value, options: options};
    }
    return middleDelim;
};

groupTypes.rule = function(group, options) {
    // Make an empty span for the rule
    var rule = makeSpan(["mord", "rule"], [], options);
    var style = options.style;

    // Calculate the shift, width, and height of the rule, and account for units
    var shift = 0;
    if (group.value.shift) {
        shift = calculateSize(group.value.shift, style);
    }

    var width = calculateSize(group.value.width, style);
    var height = calculateSize(group.value.height, style);

    // The sizes of rules are absolute, so make it larger if we are in a
    // smaller style.
    shift /= style.sizeMultiplier;
    width /= style.sizeMultiplier;
    height /= style.sizeMultiplier;

    // Style the rule to the right size
    rule.style.borderRightWidth = width + "em";
    rule.style.borderTopWidth = height + "em";
    rule.style.bottom = shift + "em";

    // Record the height and width
    rule.width = width;
    rule.height = height + shift;
    rule.depth = -shift;

    return rule;
};

groupTypes.kern = function(group, options) {
    // Make an empty span for the rule
    var rule = makeSpan(["mord", "rule"], [], options);
    var style = options.style;

    var dimension = 0;
    if (group.value.dimension) {
        dimension = calculateSize(group.value.dimension, style);
    }

    dimension /= style.sizeMultiplier;

    rule.style.marginLeft = dimension + "em";

    return rule;
};

groupTypes.accent = function(group, options) {
    // Accents are handled in the TeXbook pg. 443, rule 12.
    var base = group.value.base;
    var style = options.style;

    var supsubGroup;
    if (group.type === "supsub") {
        // If our base is a character box, and we have superscripts and
        // subscripts, the supsub will defer to us. In particular, we want
        // to attach the superscripts and subscripts to the inner body (so
        // that the position of the superscripts and subscripts won't be
        // affected by the height of the accent). We accomplish this by
        // sticking the base of the accent into the base of the supsub, and
        // rendering that, while keeping track of where the accent is.

        // The supsub group is the group that was passed in
        var supsub = group;
        // The real accent group is the base of the supsub group
        group = supsub.value.base;
        // The character box is the base of the accent group
        base = group.value.base;
        // Stick the character box into the base of the supsub group
        supsub.value.base = base;

        // Rerender the supsub group with its new base, and store that
        // result.
        supsubGroup = buildGroup(
            supsub, options.reset());
    }

    // Build the base group
    var body = buildGroup(
        base, options.withStyle(style.cramp()));

    // Calculate the skew of the accent. This is based on the line "If the
    // nucleus is not a single character, let s = 0; otherwise set s to the
    // kern amount for the nucleus followed by the \skewchar of its font."
    // Note that our skew metrics are just the kern between each character
    // and the skewchar.
    var skew;
    if (isCharacterBox(base)) {
        // If the base is a character box, then we want the skew of the
        // innermost character. To do that, we find the innermost character:
        var baseChar = getBaseElem(base);
        // Then, we render its group to get the symbol inside it
        var baseGroup = buildGroup(
            baseChar, options.withStyle(style.cramp()));
        // Finally, we pull the skew off of the symbol.
        skew = baseGroup.skew;
        // Note that we now throw away baseGroup, because the layers we
        // removed with getBaseElem might contain things like \color which
        // we can't get rid of.
        // TODO(emily): Find a better way to get the skew
    } else {
        skew = 0;
    }

    // calculate the amount of space between the body and the accent
    var clearance = Math.min(
        body.height,
        style.metrics.xHeight);

    // Build the accent
    var accent = buildCommon.makeSymbol(
        group.value.accent, "Main-Regular", "math", options);
    // Remove the italic correction of the accent, because it only serves to
    // shift the accent over to a place we don't want.
    accent.italic = 0;

    // The \vec character that the fonts use is a combining character, and
    // thus shows up much too far to the left. To account for this, we add a
    // specific class which shifts the accent over to where we want it.
    // TODO(emily): Fix this in a better way, like by changing the font
    var vecClass = group.value.accent === "\\vec" ? "accent-vec" : null;

    var accentBody = makeSpan(["accent-body", vecClass], [
        makeSpan([], [accent])]);

    accentBody = buildCommon.makeVList([
        {type: "elem", elem: body},
        {type: "kern", size: -clearance},
        {type: "elem", elem: accentBody}
    ], "firstBaseline", null, options);

    // Shift the accent over by the skew. Note we shift by twice the skew
    // because we are centering the accent, so by adding 2*skew to the left,
    // we shift it to the right by 1*skew.
    accentBody.children[1].style.marginLeft = 2 * skew + "em";

    var accentWrap = makeSpan(["mord", "accent"], [accentBody], options);

    if (supsubGroup) {
        // Here, we replace the "base" child of the supsub with our newly
        // generated accent.
        supsubGroup.children[0] = accentWrap;

        // Since we don't rerun the height calculation after replacing the
        // accent, we manually recalculate height.
        supsubGroup.height = Math.max(accentWrap.height, supsubGroup.height);

        // Accents should always be ords, even when their innards are not.
        supsubGroup.classes[0] = "mord";

        return supsubGroup;
    } else {
        return accentWrap;
    }
};

groupTypes.phantom = function(group, options) {
    var elements = buildExpression(
        group.value.value,
        options.withPhantom(),
        false
    );

    // \phantom isn't supposed to affect the elements it contains.
    // See "color" for more details.
    return new buildCommon.makeFragment(elements);
};

groupTypes.mclass = function(group, options) {
    var elements = buildExpression(group.value.value, options, true);

    return makeSpan([group.value.mclass], elements, options);
};

/**
 * buildGroup is the function that takes a group and calls the correct groupType
 * function for it. It also handles the interaction of size and style changes
 * between parents and children.
 */
var buildGroup = function(group, options) {
    if (!group) {
        return makeSpan();
    }

    if (groupTypes[group.type]) {
        // Call the groupTypes function
        var groupNode = groupTypes[group.type](group, options);
        var multiplier;

        // If the style changed between the parent and the current group,
        // account for the size difference
        if (options.style !== options.parentStyle) {
            multiplier = options.style.sizeMultiplier /
                    options.parentStyle.sizeMultiplier;

            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
        }

        // If the size changed between the parent and the current group, account
        // for that size difference.
        if (options.size !== options.parentSize) {
            multiplier = buildCommon.sizingMultiplier[options.size] /
                    buildCommon.sizingMultiplier[options.parentSize];

            groupNode.height *= multiplier;
            groupNode.depth *= multiplier;
        }

        return groupNode;
    } else {
        throw new ParseError(
            "Got group of unknown type: '" + group.type + "'");
    }
};

/**
 * Take an entire parse tree, and build it into an appropriate set of HTML
 * nodes.
 */
var buildHTML = function(tree, options) {
    // buildExpression is destructive, so we need to make a clone
    // of the incoming tree so that it isn't accidentally changed
    tree = JSON.parse(JSON.stringify(tree));

    // Build the expression contained in the tree
    var expression = buildExpression(tree, options, true);
    var body = makeSpan(["base", options.style.cls()], expression, options);

    // Add struts, which ensure that the top of the HTML element falls at the
    // height of the expression, and the bottom of the HTML element falls at the
    // depth of the expression.
    var topStrut = makeSpan(["strut"]);
    var bottomStrut = makeSpan(["strut", "bottom"]);

    topStrut.style.height = body.height + "em";
    bottomStrut.style.height = (body.height + body.depth) + "em";
    // We'd like to use `vertical-align: top` but in IE 9 this lowers the
    // baseline of the box to the bottom of this strut (instead staying in the
    // normal place) so we use an absolute value for vertical-align instead
    bottomStrut.style.verticalAlign = -body.depth + "em";

    // Wrap the struts and body together
    var htmlNode = makeSpan(["katex-html"], [topStrut, bottomStrut, body]);

    htmlNode.setAttribute("aria-hidden", "true");

    return htmlNode;
};

module.exports = buildHTML;

},{"./ParseError":85,"./Style":88,"./buildCommon":89,"./delimiter":93,"./domTree":94,"./fontMetrics":96,"./utils":104}],91:[function(require,module,exports){
/**
 * This file converts a parse tree into a cooresponding MathML tree. The main
 * entry point is the `buildMathML` function, which takes a parse tree from the
 * parser.
 */

var buildCommon = require("./buildCommon");
var fontMetrics = require("./fontMetrics");
var mathMLTree = require("./mathMLTree");
var ParseError = require("./ParseError");
var symbols = require("./symbols");
var utils = require("./utils");

var makeSpan = buildCommon.makeSpan;
var fontMap = buildCommon.fontMap;

/**
 * Takes a symbol and converts it into a MathML text node after performing
 * optional replacement from symbols.js.
 */
var makeText = function(text, mode) {
    if (symbols[mode][text] && symbols[mode][text].replace) {
        text = symbols[mode][text].replace;
    }

    return new mathMLTree.TextNode(text);
};

/**
 * Returns the math variant as a string or null if none is required.
 */
var getVariant = function(group, options) {
    var font = options.font;
    if (!font) {
        return null;
    }

    var mode = group.mode;
    if (font === "mathit") {
        return "italic";
    }

    var value = group.value;
    if (utils.contains(["\\imath", "\\jmath"], value)) {
        return null;
    }

    if (symbols[mode][value] && symbols[mode][value].replace) {
        value = symbols[mode][value].replace;
    }

    var fontName = fontMap[font].fontName;
    if (fontMetrics.getCharacterMetrics(value, fontName)) {
        return fontMap[options.font].variant;
    }

    return null;
};

/**
 * Functions for handling the different types of groups found in the parse
 * tree. Each function should take a parse group and return a MathML node.
 */
var groupTypes = {};

groupTypes.mathord = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mi",
        [makeText(group.value, group.mode)]);

    var variant = getVariant(group, options);
    if (variant) {
        node.setAttribute("mathvariant", variant);
    }
    return node;
};

groupTypes.textord = function(group, options) {
    var text = makeText(group.value, group.mode);

    var variant = getVariant(group, options) || "normal";

    var node;
    if (/[0-9]/.test(group.value)) {
        // TODO(kevinb) merge adjacent <mn> nodes
        // do it as a post processing step
        node = new mathMLTree.MathNode("mn", [text]);
        if (options.font) {
            node.setAttribute("mathvariant", variant);
        }
    } else {
        node = new mathMLTree.MathNode("mi", [text]);
        node.setAttribute("mathvariant", variant);
    }

    return node;
};

groupTypes.bin = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.rel = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.open = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.close = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.inner = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    return node;
};

groupTypes.punct = function(group) {
    var node = new mathMLTree.MathNode(
        "mo", [makeText(group.value, group.mode)]);

    node.setAttribute("separator", "true");

    return node;
};

groupTypes.ordgroup = function(group, options) {
    var inner = buildExpression(group.value, options);

    var node = new mathMLTree.MathNode("mrow", inner);

    return node;
};

groupTypes.text = function(group, options) {
    var inner = buildExpression(group.value.body, options);

    var node = new mathMLTree.MathNode("mtext", inner);

    return node;
};

groupTypes.color = function(group, options) {
    var inner = buildExpression(group.value.value, options);

    var node = new mathMLTree.MathNode("mstyle", inner);

    node.setAttribute("mathcolor", group.value.color);

    return node;
};

groupTypes.supsub = function(group, options) {
    var children = [buildGroup(group.value.base, options)];

    if (group.value.sub) {
        children.push(buildGroup(group.value.sub, options));
    }

    if (group.value.sup) {
        children.push(buildGroup(group.value.sup, options));
    }

    var nodeType;
    if (!group.value.sub) {
        nodeType = "msup";
    } else if (!group.value.sup) {
        nodeType = "msub";
    } else {
        nodeType = "msubsup";
    }

    var node = new mathMLTree.MathNode(nodeType, children);

    return node;
};

groupTypes.genfrac = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mfrac",
        [buildGroup(group.value.numer, options),
            buildGroup(group.value.denom, options)]);

    if (!group.value.hasBarLine) {
        node.setAttribute("linethickness", "0px");
    }

    if (group.value.leftDelim != null || group.value.rightDelim != null) {
        var withDelims = [];

        if (group.value.leftDelim != null) {
            var leftOp = new mathMLTree.MathNode(
                "mo", [new mathMLTree.TextNode(group.value.leftDelim)]);

            leftOp.setAttribute("fence", "true");

            withDelims.push(leftOp);
        }

        withDelims.push(node);

        if (group.value.rightDelim != null) {
            var rightOp = new mathMLTree.MathNode(
                "mo", [new mathMLTree.TextNode(group.value.rightDelim)]);

            rightOp.setAttribute("fence", "true");

            withDelims.push(rightOp);
        }

        var outerNode = new mathMLTree.MathNode("mrow", withDelims);

        return outerNode;
    }

    return node;
};

groupTypes.array = function(group, options) {
    return new mathMLTree.MathNode(
        "mtable", group.value.body.map(function(row) {
            return new mathMLTree.MathNode(
                "mtr", row.map(function(cell) {
                    return new mathMLTree.MathNode(
                        "mtd", [buildGroup(cell, options)]);
                }));
        }));
};

groupTypes.sqrt = function(group, options) {
    var node;
    if (group.value.index) {
        node = new mathMLTree.MathNode(
            "mroot", [
                buildGroup(group.value.body, options),
                buildGroup(group.value.index, options)
            ]);
    } else {
        node = new mathMLTree.MathNode(
            "msqrt", [buildGroup(group.value.body, options)]);
    }

    return node;
};

groupTypes.leftright = function(group, options) {
    var inner = buildExpression(group.value.body, options);

    if (group.value.left !== ".") {
        var leftNode = new mathMLTree.MathNode(
            "mo", [makeText(group.value.left, group.mode)]);

        leftNode.setAttribute("fence", "true");

        inner.unshift(leftNode);
    }

    if (group.value.right !== ".") {
        var rightNode = new mathMLTree.MathNode(
            "mo", [makeText(group.value.right, group.mode)]);

        rightNode.setAttribute("fence", "true");

        inner.push(rightNode);
    }

    var outerNode = new mathMLTree.MathNode("mrow", inner);

    return outerNode;
};

groupTypes.middle = function(group, options) {
    var middleNode = new mathMLTree.MathNode(
        "mo", [makeText(group.value.middle, group.mode)]);
    middleNode.setAttribute("fence", "true");
    return middleNode;
};

groupTypes.accent = function(group, options) {
    var accentNode = new mathMLTree.MathNode(
        "mo", [makeText(group.value.accent, group.mode)]);

    var node = new mathMLTree.MathNode(
        "mover",
        [buildGroup(group.value.base, options),
            accentNode]);

    node.setAttribute("accent", "true");

    return node;
};

groupTypes.spacing = function(group) {
    var node;

    if (group.value === "\\ " || group.value === "\\space" ||
        group.value === " " || group.value === "~") {
        node = new mathMLTree.MathNode(
            "mtext", [new mathMLTree.TextNode("\u00a0")]);
    } else {
        node = new mathMLTree.MathNode("mspace");

        node.setAttribute(
            "width", buildCommon.spacingFunctions[group.value].size);
    }

    return node;
};

groupTypes.op = function(group, options) {
    var node;

    // TODO(emily): handle big operators using the `largeop` attribute

    if (group.value.symbol) {
        // This is a symbol. Just add the symbol.
        node = new mathMLTree.MathNode(
            "mo", [makeText(group.value.body, group.mode)]);
    } else if (group.value.value) {
        // This is an operator with children. Add them.
        node = new mathMLTree.MathNode(
            "mo", buildExpression(group.value.value, options));
    } else {
        // This is a text operator. Add all of the characters from the
        // operator's name.
        // TODO(emily): Add a space in the middle of some of these
        // operators, like \limsup.
        node = new mathMLTree.MathNode(
            "mi", [new mathMLTree.TextNode(group.value.body.slice(1))]);
    }

    return node;
};

groupTypes.mod = function(group, options) {
    var inner = [];

    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(new mathMLTree.MathNode(
            "mo", [makeText("(", group.mode)]));
    }
    if (group.value.modType !== "pod") {
        inner.push(new mathMLTree.MathNode(
            "mo", [makeText("mod", group.mode)]));
    }
    if (group.value.value) {
        var space = new mathMLTree.MathNode("mspace");
        space.setAttribute("width", "0.333333em");
        inner.push(space);
        inner = inner.concat(buildExpression(group.value.value, options));
    }
    if (group.value.modType === "pod" || group.value.modType === "pmod") {
        inner.push(new mathMLTree.MathNode(
            "mo", [makeText(")", group.mode)]));
    }

    return new mathMLTree.MathNode("mo", inner);
};

groupTypes.katex = function(group) {
    var node = new mathMLTree.MathNode(
        "mtext", [new mathMLTree.TextNode("KaTeX")]);

    return node;
};

groupTypes.font = function(group, options) {
    var font = group.value.font;
    return buildGroup(group.value.body, options.withFont(font));
};

groupTypes.delimsizing = function(group) {
    var children = [];

    if (group.value.value !== ".") {
        children.push(makeText(group.value.value, group.mode));
    }

    var node = new mathMLTree.MathNode("mo", children);

    if (group.value.mclass === "mopen" ||
        group.value.mclass === "mclose") {
        // Only some of the delimsizing functions act as fences, and they
        // return "mopen" or "mclose" mclass.
        node.setAttribute("fence", "true");
    } else {
        // Explicitly disable fencing if it's not a fence, to override the
        // defaults.
        node.setAttribute("fence", "false");
    }

    return node;
};

groupTypes.styling = function(group, options) {
    var inner = buildExpression(group.value.value, options);

    var node = new mathMLTree.MathNode("mstyle", inner);

    var styleAttributes = {
        "display": ["0", "true"],
        "text": ["0", "false"],
        "script": ["1", "false"],
        "scriptscript": ["2", "false"]
    };

    var attr = styleAttributes[group.value.style];

    node.setAttribute("scriptlevel", attr[0]);
    node.setAttribute("displaystyle", attr[1]);

    return node;
};

groupTypes.sizing = function(group, options) {
    var inner = buildExpression(group.value.value, options);

    var node = new mathMLTree.MathNode("mstyle", inner);

    // TODO(emily): This doesn't produce the correct size for nested size
    // changes, because we don't keep state of what style we're currently
    // in, so we can't reset the size to normal before changing it.  Now
    // that we're passing an options parameter we should be able to fix
    // this.
    node.setAttribute(
        "mathsize", buildCommon.sizingMultiplier[group.value.size] + "em");

    return node;
};

groupTypes.overline = function(group, options) {
    var operator = new mathMLTree.MathNode(
        "mo", [new mathMLTree.TextNode("\u203e")]);
    operator.setAttribute("stretchy", "true");

    var node = new mathMLTree.MathNode(
        "mover",
        [buildGroup(group.value.body, options),
            operator]);
    node.setAttribute("accent", "true");

    return node;
};

groupTypes.underline = function(group, options) {
    var operator = new mathMLTree.MathNode(
        "mo", [new mathMLTree.TextNode("\u203e")]);
    operator.setAttribute("stretchy", "true");

    var node = new mathMLTree.MathNode(
        "munder",
        [buildGroup(group.value.body, options),
            operator]);
    node.setAttribute("accentunder", "true");

    return node;
};

groupTypes.rule = function(group) {
    // TODO(emily): Figure out if there's an actual way to draw black boxes
    // in MathML.
    var node = new mathMLTree.MathNode("mrow");

    return node;
};

groupTypes.kern = function(group) {
    // TODO(kevin): Figure out if there's a way to add space in MathML
    var node = new mathMLTree.MathNode("mrow");

    return node;
};

groupTypes.llap = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mpadded", [buildGroup(group.value.body, options)]);

    node.setAttribute("lspace", "-1width");
    node.setAttribute("width", "0px");

    return node;
};

groupTypes.rlap = function(group, options) {
    var node = new mathMLTree.MathNode(
        "mpadded", [buildGroup(group.value.body, options)]);

    node.setAttribute("width", "0px");

    return node;
};

groupTypes.phantom = function(group, options) {
    var inner = buildExpression(group.value.value, options);
    return new mathMLTree.MathNode("mphantom", inner);
};

groupTypes.mclass = function(group, options) {
    var inner = buildExpression(group.value.value, options);
    return new mathMLTree.MathNode("mstyle", inner);
};

/**
 * Takes a list of nodes, builds them, and returns a list of the generated
 * MathML nodes. A little simpler than the HTML version because we don't do any
 * previous-node handling.
 */
var buildExpression = function(expression, options) {
    var groups = [];
    for (var i = 0; i < expression.length; i++) {
        var group = expression[i];
        groups.push(buildGroup(group, options));
    }
    return groups;
};

/**
 * Takes a group from the parser and calls the appropriate groupTypes function
 * on it to produce a MathML node.
 */
var buildGroup = function(group, options) {
    if (!group) {
        return new mathMLTree.MathNode("mrow");
    }

    if (groupTypes[group.type]) {
        // Call the groupTypes function
        return groupTypes[group.type](group, options);
    } else {
        throw new ParseError(
            "Got group of unknown type: '" + group.type + "'");
    }
};

/**
 * Takes a full parse tree and settings and builds a MathML representation of
 * it. In particular, we put the elements from building the parse tree into a
 * <semantics> tag so we can also include that TeX source as an annotation.
 *
 * Note that we actually return a domTree element with a `<math>` inside it so
 * we can do appropriate styling.
 */
var buildMathML = function(tree, texExpression, options) {
    var expression = buildExpression(tree, options);

    // Wrap up the expression in an mrow so it is presented in the semantics
    // tag correctly.
    var wrapper = new mathMLTree.MathNode("mrow", expression);

    // Build a TeX annotation of the source
    var annotation = new mathMLTree.MathNode(
        "annotation", [new mathMLTree.TextNode(texExpression)]);

    annotation.setAttribute("encoding", "application/x-tex");

    var semantics = new mathMLTree.MathNode(
        "semantics", [wrapper, annotation]);

    var math = new mathMLTree.MathNode("math", [semantics]);

    // You can't style <math> nodes, so we wrap the node in a span.
    return makeSpan(["katex-mathml"], [math]);
};

module.exports = buildMathML;

},{"./ParseError":85,"./buildCommon":89,"./fontMetrics":96,"./mathMLTree":99,"./symbols":102,"./utils":104}],92:[function(require,module,exports){
var buildHTML = require("./buildHTML");
var buildMathML = require("./buildMathML");
var buildCommon = require("./buildCommon");
var Options = require("./Options");
var Settings = require("./Settings");
var Style = require("./Style");

var makeSpan = buildCommon.makeSpan;

var buildTree = function(tree, expression, settings) {
    settings = settings || new Settings({});

    var startStyle = Style.TEXT;
    if (settings.displayMode) {
        startStyle = Style.DISPLAY;
    }

    // Setup the default options
    var options = new Options({
        style: startStyle,
        size: "size5"
    });

    // `buildHTML` sometimes messes with the parse tree (like turning bins ->
    // ords), so we build the MathML version first.
    var mathMLNode = buildMathML(tree, expression, options);
    var htmlNode = buildHTML(tree, options);

    var katexNode = makeSpan(["katex"], [
        mathMLNode, htmlNode
    ]);

    if (settings.displayMode) {
        return makeSpan(["katex-display"], [katexNode]);
    } else {
        return katexNode;
    }
};

module.exports = buildTree;

},{"./Options":84,"./Settings":87,"./Style":88,"./buildCommon":89,"./buildHTML":90,"./buildMathML":91}],93:[function(require,module,exports){
/**
 * This file deals with creating delimiters of various sizes. The TeXbook
 * discusses these routines on page 441-442, in the "Another subroutine sets box
 * x to a specified variable delimiter" paragraph.
 *
 * There are three main routines here. `makeSmallDelim` makes a delimiter in the
 * normal font, but in either text, script, or scriptscript style.
 * `makeLargeDelim` makes a delimiter in textstyle, but in one of the Size1,
 * Size2, Size3, or Size4 fonts. `makeStackedDelim` makes a delimiter out of
 * smaller pieces that are stacked on top of one another.
 *
 * The functions take a parameter `center`, which determines if the delimiter
 * should be centered around the axis.
 *
 * Then, there are three exposed functions. `sizedDelim` makes a delimiter in
 * one of the given sizes. This is used for things like `\bigl`.
 * `customSizedDelim` makes a delimiter with a given total height+depth. It is
 * called in places like `\sqrt`. `leftRightDelim` makes an appropriate
 * delimiter which surrounds an expression of a given height an depth. It is
 * used in `\left` and `\right`.
 */

var ParseError = require("./ParseError");
var Style = require("./Style");

var buildCommon = require("./buildCommon");
var fontMetrics = require("./fontMetrics");
var symbols = require("./symbols");
var utils = require("./utils");

var makeSpan = buildCommon.makeSpan;

/**
 * Get the metrics for a given symbol and font, after transformation (i.e.
 * after following replacement from symbols.js)
 */
var getMetrics = function(symbol, font) {
    if (symbols.math[symbol] && symbols.math[symbol].replace) {
        return fontMetrics.getCharacterMetrics(
            symbols.math[symbol].replace, font);
    } else {
        return fontMetrics.getCharacterMetrics(
            symbol, font);
    }
};

/**
 * Builds a symbol in the given font size (note size is an integer)
 */
var mathrmSize = function(value, size, mode, options) {
    return buildCommon.makeSymbol(value, "Size" + size + "-Regular",
        mode, options);
};

/**
 * Puts a delimiter span in a given style, and adds appropriate height, depth,
 * and maxFontSizes.
 */
var styleWrap = function(delim, toStyle, options, classes) {
    classes = classes || [];
    var span = makeSpan(
        classes.concat(["style-wrap", options.style.reset(), toStyle.cls()]),
        [delim], options);

    var multiplier = toStyle.sizeMultiplier / options.style.sizeMultiplier;

    span.height *= multiplier;
    span.depth *= multiplier;
    span.maxFontSize = toStyle.sizeMultiplier;

    return span;
};

/**
 * Makes a small delimiter. This is a delimiter that comes in the Main-Regular
 * font, but is restyled to either be in textstyle, scriptstyle, or
 * scriptscriptstyle.
 */
var makeSmallDelim = function(delim, style, center, options, mode, classes) {
    var text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);

    var span = styleWrap(text, style, options, classes);

    if (center) {
        var shift =
            (1 - options.style.sizeMultiplier / style.sizeMultiplier) *
            options.style.metrics.axisHeight;

        span.style.top = shift + "em";
        span.height -= shift;
        span.depth += shift;
    }

    return span;
};

/**
 * Makes a large delimiter. This is a delimiter that comes in the Size1, Size2,
 * Size3, or Size4 fonts. It is always rendered in textstyle.
 */
var makeLargeDelim = function(delim, size, center, options, mode, classes) {
    var inner = mathrmSize(delim, size, mode, options);

    var span = styleWrap(
        makeSpan(["delimsizing", "size" + size], [inner], options),
        Style.TEXT, options, classes);

    if (center) {
        var shift = (1 - options.style.sizeMultiplier) *
            options.style.metrics.axisHeight;

        span.style.top = shift + "em";
        span.height -= shift;
        span.depth += shift;
    }

    return span;
};

/**
 * Make an inner span with the given offset and in the given font. This is used
 * in `makeStackedDelim` to make the stacking pieces for the delimiter.
 */
var makeInner = function(symbol, font, mode) {
    var sizeClass;
    // Apply the correct CSS class to choose the right font.
    if (font === "Size1-Regular") {
        sizeClass = "delim-size1";
    } else if (font === "Size4-Regular") {
        sizeClass = "delim-size4";
    }

    var inner = makeSpan(
        ["delimsizinginner", sizeClass],
        [makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);

    // Since this will be passed into `makeVList` in the end, wrap the element
    // in the appropriate tag that VList uses.
    return {type: "elem", elem: inner};
};

/**
 * Make a stacked delimiter out of a given delimiter, with the total height at
 * least `heightTotal`. This routine is mentioned on page 442 of the TeXbook.
 */
var makeStackedDelim = function(delim, heightTotal, center, options, mode,
                                classes) {
    // There are four parts, the top, an optional middle, a repeated part, and a
    // bottom.
    var top;
    var middle;
    var repeat;
    var bottom;
    top = repeat = bottom = delim;
    middle = null;
    // Also keep track of what font the delimiters are in
    var font = "Size1-Regular";

    // We set the parts and font based on the symbol. Note that we use
    // '\u23d0' instead of '|' and '\u2016' instead of '\\|' for the
    // repeats of the arrows
    if (delim === "\\uparrow") {
        repeat = bottom = "\u23d0";
    } else if (delim === "\\Uparrow") {
        repeat = bottom = "\u2016";
    } else if (delim === "\\downarrow") {
        top = repeat = "\u23d0";
    } else if (delim === "\\Downarrow") {
        top = repeat = "\u2016";
    } else if (delim === "\\updownarrow") {
        top = "\\uparrow";
        repeat = "\u23d0";
        bottom = "\\downarrow";
    } else if (delim === "\\Updownarrow") {
        top = "\\Uparrow";
        repeat = "\u2016";
        bottom = "\\Downarrow";
    } else if (delim === "[" || delim === "\\lbrack") {
        top = "\u23a1";
        repeat = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
    } else if (delim === "]" || delim === "\\rbrack") {
        top = "\u23a4";
        repeat = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
    } else if (delim === "\\lfloor") {
        repeat = top = "\u23a2";
        bottom = "\u23a3";
        font = "Size4-Regular";
    } else if (delim === "\\lceil") {
        top = "\u23a1";
        repeat = bottom = "\u23a2";
        font = "Size4-Regular";
    } else if (delim === "\\rfloor") {
        repeat = top = "\u23a5";
        bottom = "\u23a6";
        font = "Size4-Regular";
    } else if (delim === "\\rceil") {
        top = "\u23a4";
        repeat = bottom = "\u23a5";
        font = "Size4-Regular";
    } else if (delim === "(") {
        top = "\u239b";
        repeat = "\u239c";
        bottom = "\u239d";
        font = "Size4-Regular";
    } else if (delim === ")") {
        top = "\u239e";
        repeat = "\u239f";
        bottom = "\u23a0";
        font = "Size4-Regular";
    } else if (delim === "\\{" || delim === "\\lbrace") {
        top = "\u23a7";
        middle = "\u23a8";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\}" || delim === "\\rbrace") {
        top = "\u23ab";
        middle = "\u23ac";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\lgroup") {
        top = "\u23a7";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\rgroup") {
        top = "\u23ab";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\lmoustache") {
        top = "\u23a7";
        bottom = "\u23ad";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\rmoustache") {
        top = "\u23ab";
        bottom = "\u23a9";
        repeat = "\u23aa";
        font = "Size4-Regular";
    } else if (delim === "\\surd") {
        top = "\ue001";
        bottom = "\u23b7";
        repeat = "\ue000";
        font = "Size4-Regular";
    }

    // Get the metrics of the four sections
    var topMetrics = getMetrics(top, font);
    var topHeightTotal = topMetrics.height + topMetrics.depth;
    var repeatMetrics = getMetrics(repeat, font);
    var repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
    var bottomMetrics = getMetrics(bottom, font);
    var bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
    var middleHeightTotal = 0;
    var middleFactor = 1;
    if (middle !== null) {
        var middleMetrics = getMetrics(middle, font);
        middleHeightTotal = middleMetrics.height + middleMetrics.depth;
        middleFactor = 2; // repeat symmetrically above and below middle
    }

    // Calcuate the minimal height that the delimiter can have.
    // It is at least the size of the top, bottom, and optional middle combined.
    var minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;

    // Compute the number of copies of the repeat symbol we will need
    var repeatCount = Math.ceil(
        (heightTotal - minHeight) / (middleFactor * repeatHeightTotal));

    // Compute the total height of the delimiter including all the symbols
    var realHeightTotal =
        minHeight + repeatCount * middleFactor * repeatHeightTotal;

    // The center of the delimiter is placed at the center of the axis. Note
    // that in this context, "center" means that the delimiter should be
    // centered around the axis in the current style, while normally it is
    // centered around the axis in textstyle.
    var axisHeight = options.style.metrics.axisHeight;
    if (center) {
        axisHeight *= options.style.sizeMultiplier;
    }
    // Calculate the depth
    var depth = realHeightTotal / 2 - axisHeight;

    // Now, we start building the pieces that will go into the vlist

    // Keep a list of the inner pieces
    var inners = [];

    // Add the bottom symbol
    inners.push(makeInner(bottom, font, mode));

    var i;
    if (middle === null) {
        // Add that many symbols
        for (i = 0; i < repeatCount; i++) {
            inners.push(makeInner(repeat, font, mode));
        }
    } else {
        // When there is a middle bit, we need the middle part and two repeated
        // sections
        for (i = 0; i < repeatCount; i++) {
            inners.push(makeInner(repeat, font, mode));
        }
        inners.push(makeInner(middle, font, mode));
        for (i = 0; i < repeatCount; i++) {
            inners.push(makeInner(repeat, font, mode));
        }
    }

    // Add the top symbol
    inners.push(makeInner(top, font, mode));

    // Finally, build the vlist
    var inner = buildCommon.makeVList(inners, "bottom", depth, options);

    return styleWrap(
        makeSpan(["delimsizing", "mult"], [inner], options),
        Style.TEXT, options, classes);
};

// There are three kinds of delimiters, delimiters that stack when they become
// too large
var stackLargeDelimiters = [
    "(", ")", "[", "\\lbrack", "]", "\\rbrack",
    "\\{", "\\lbrace", "\\}", "\\rbrace",
    "\\lfloor", "\\rfloor", "\\lceil", "\\rceil",
    "\\surd"
];

// delimiters that always stack
var stackAlwaysDelimiters = [
    "\\uparrow", "\\downarrow", "\\updownarrow",
    "\\Uparrow", "\\Downarrow", "\\Updownarrow",
    "|", "\\|", "\\vert", "\\Vert",
    "\\lvert", "\\rvert", "\\lVert", "\\rVert",
    "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache"
];

// and delimiters that never stack
var stackNeverDelimiters = [
    "<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"
];

// Metrics of the different sizes. Found by looking at TeX's output of
// $\bigl| // \Bigl| \biggl| \Biggl| \showlists$
// Used to create stacked delimiters of appropriate sizes in makeSizedDelim.
var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3.0];

/**
 * Used to create a delimiter of a specific size, where `size` is 1, 2, 3, or 4.
 */
var makeSizedDelim = function(delim, size, options, mode, classes) {
    // < and > turn into \langle and \rangle in delimiters
    if (delim === "<" || delim === "\\lt") {
        delim = "\\langle";
    } else if (delim === ">" || delim === "\\gt") {
        delim = "\\rangle";
    }

    // Sized delimiters are never centered.
    if (utils.contains(stackLargeDelimiters, delim) ||
        utils.contains(stackNeverDelimiters, delim)) {
        return makeLargeDelim(delim, size, false, options, mode, classes);
    } else if (utils.contains(stackAlwaysDelimiters, delim)) {
        return makeStackedDelim(
            delim, sizeToMaxHeight[size], false, options, mode, classes);
    } else {
        throw new ParseError("Illegal delimiter: '" + delim + "'");
    }
};

/**
 * There are three different sequences of delimiter sizes that the delimiters
 * follow depending on the kind of delimiter. This is used when creating custom
 * sized delimiters to decide whether to create a small, large, or stacked
 * delimiter.
 *
 * In real TeX, these sequences aren't explicitly defined, but are instead
 * defined inside the font metrics. Since there are only three sequences that
 * are possible for the delimiters that TeX defines, it is easier to just encode
 * them explicitly here.
 */

// Delimiters that never stack try small delimiters and large delimiters only
var stackNeverDelimiterSequence = [
    {type: "small", style: Style.SCRIPTSCRIPT},
    {type: "small", style: Style.SCRIPT},
    {type: "small", style: Style.TEXT},
    {type: "large", size: 1},
    {type: "large", size: 2},
    {type: "large", size: 3},
    {type: "large", size: 4}
];

// Delimiters that always stack try the small delimiters first, then stack
var stackAlwaysDelimiterSequence = [
    {type: "small", style: Style.SCRIPTSCRIPT},
    {type: "small", style: Style.SCRIPT},
    {type: "small", style: Style.TEXT},
    {type: "stack"}
];

// Delimiters that stack when large try the small and then large delimiters, and
// stack afterwards
var stackLargeDelimiterSequence = [
    {type: "small", style: Style.SCRIPTSCRIPT},
    {type: "small", style: Style.SCRIPT},
    {type: "small", style: Style.TEXT},
    {type: "large", size: 1},
    {type: "large", size: 2},
    {type: "large", size: 3},
    {type: "large", size: 4},
    {type: "stack"}
];

/**
 * Get the font used in a delimiter based on what kind of delimiter it is.
 */
var delimTypeToFont = function(type) {
    if (type.type === "small") {
        return "Main-Regular";
    } else if (type.type === "large") {
        return "Size" + type.size + "-Regular";
    } else if (type.type === "stack") {
        return "Size4-Regular";
    }
};

/**
 * Traverse a sequence of types of delimiters to decide what kind of delimiter
 * should be used to create a delimiter of the given height+depth.
 */
var traverseSequence = function(delim, height, sequence, options) {
    // Here, we choose the index we should start at in the sequences. In smaller
    // sizes (which correspond to larger numbers in style.size) we start earlier
    // in the sequence. Thus, scriptscript starts at index 3-3=0, script starts
    // at index 3-2=1, text starts at 3-1=2, and display starts at min(2,3-0)=2
    var start = Math.min(2, 3 - options.style.size);
    for (var i = start; i < sequence.length; i++) {
        if (sequence[i].type === "stack") {
            // This is always the last delimiter, so we just break the loop now.
            break;
        }

        var metrics = getMetrics(delim, delimTypeToFont(sequence[i]));
        var heightDepth = metrics.height + metrics.depth;

        // Small delimiters are scaled down versions of the same font, so we
        // account for the style change size.

        if (sequence[i].type === "small") {
            heightDepth *= sequence[i].style.sizeMultiplier;
        }

        // Check if the delimiter at this size works for the given height.
        if (heightDepth > height) {
            return sequence[i];
        }
    }

    // If we reached the end of the sequence, return the last sequence element.
    return sequence[sequence.length - 1];
};

/**
 * Make a delimiter of a given height+depth, with optional centering. Here, we
 * traverse the sequences, and create a delimiter that the sequence tells us to.
 */
var makeCustomSizedDelim = function(delim, height, center, options, mode,
                                    classes) {
    if (delim === "<" || delim === "\\lt") {
        delim = "\\langle";
    } else if (delim === ">" || delim === "\\gt") {
        delim = "\\rangle";
    }

    // Decide what sequence to use
    var sequence;
    if (utils.contains(stackNeverDelimiters, delim)) {
        sequence = stackNeverDelimiterSequence;
    } else if (utils.contains(stackLargeDelimiters, delim)) {
        sequence = stackLargeDelimiterSequence;
    } else {
        sequence = stackAlwaysDelimiterSequence;
    }

    // Look through the sequence
    var delimType = traverseSequence(delim, height, sequence, options);

    // Depending on the sequence element we decided on, call the appropriate
    // function.
    if (delimType.type === "small") {
        return makeSmallDelim(delim, delimType.style, center, options, mode,
                              classes);
    } else if (delimType.type === "large") {
        return makeLargeDelim(delim, delimType.size, center, options, mode,
                              classes);
    } else if (delimType.type === "stack") {
        return makeStackedDelim(delim, height, center, options, mode, classes);
    }
};

/**
 * Make a delimiter for use with `\left` and `\right`, given a height and depth
 * of an expression that the delimiters surround.
 */
var makeLeftRightDelim = function(delim, height, depth, options, mode,
                                  classes) {
    // We always center \left/\right delimiters, so the axis is always shifted
    var axisHeight =
        options.style.metrics.axisHeight * options.style.sizeMultiplier;

    // Taken from TeX source, tex.web, function make_left_right
    var delimiterFactor = 901;
    var delimiterExtend = 5.0 / fontMetrics.metrics.ptPerEm;

    var maxDistFromAxis = Math.max(
        height - axisHeight, depth + axisHeight);

    var totalHeight = Math.max(
        // In real TeX, calculations are done using integral values which are
        // 65536 per pt, or 655360 per em. So, the division here truncates in
        // TeX but doesn't here, producing different results. If we wanted to
        // exactly match TeX's calculation, we could do
        //   Math.floor(655360 * maxDistFromAxis / 500) *
        //    delimiterFactor / 655360
        // (To see the difference, compare
        //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
        // in TeX and KaTeX)
        maxDistFromAxis / 500 * delimiterFactor,
        2 * maxDistFromAxis - delimiterExtend);

    // Finally, we defer to `makeCustomSizedDelim` with our calculated total
    // height
    return makeCustomSizedDelim(delim, totalHeight, true, options, mode,
                                classes);
};

module.exports = {
    sizedDelim: makeSizedDelim,
    customSizedDelim: makeCustomSizedDelim,
    leftRightDelim: makeLeftRightDelim
};

},{"./ParseError":85,"./Style":88,"./buildCommon":89,"./fontMetrics":96,"./symbols":102,"./utils":104}],94:[function(require,module,exports){
/**
 * These objects store the data about the DOM nodes we create, as well as some
 * extra data. They can then be transformed into real DOM nodes with the
 * `toNode` function or HTML markup using `toMarkup`. They are useful for both
 * storing extra properties on the nodes, as well as providing a way to easily
 * work with the DOM.
 *
 * Similar functions for working with MathML nodes exist in mathMLTree.js.
 */
var unicodeRegexes = require("./unicodeRegexes");
var utils = require("./utils");

/**
 * Create an HTML className based on a list of classes. In addition to joining
 * with spaces, we also remove null or empty classes.
 */
var createClass = function(classes) {
    classes = classes.slice();
    for (var i = classes.length - 1; i >= 0; i--) {
        if (!classes[i]) {
            classes.splice(i, 1);
        }
    }

    return classes.join(" ");
};

/**
 * This node represents a span node, with a className, a list of children, and
 * an inline style. It also contains information about its height, depth, and
 * maxFontSize.
 */
function span(classes, children, options) {
    this.classes = classes || [];
    this.children = children || [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
    this.style = {};
    this.attributes = {};
    if (options) {
        if (options.style.isTight()) {
            this.classes.push("mtight");
        }
        if (options.getColor()) {
            this.style.color = options.getColor();
        }
    }
}

/**
 * Sets an arbitrary attribute on the span. Warning: use this wisely. Not all
 * browsers support attributes the same, and having too many custom attributes
 * is probably bad.
 */
span.prototype.setAttribute = function(attribute, value) {
    this.attributes[attribute] = value;
};

span.prototype.tryCombine = function(sibling) {
    return false;
};

/**
 * Convert the span into an HTML node
 */
span.prototype.toNode = function() {
    var span = document.createElement("span");

    // Apply the class
    span.className = createClass(this.classes);

    // Apply inline styles
    for (var style in this.style) {
        if (Object.prototype.hasOwnProperty.call(this.style, style)) {
            span.style[style] = this.style[style];
        }
    }

    // Apply attributes
    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            span.setAttribute(attr, this.attributes[attr]);
        }
    }

    // Append the children, also as HTML nodes
    for (var i = 0; i < this.children.length; i++) {
        span.appendChild(this.children[i].toNode());
    }

    return span;
};

/**
 * Convert the span into an HTML markup string
 */
span.prototype.toMarkup = function() {
    var markup = "<span";

    // Add the class
    if (this.classes.length) {
        markup += " class=\"";
        markup += utils.escape(createClass(this.classes));
        markup += "\"";
    }

    var styles = "";

    // Add the styles, after hyphenation
    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
    }

    if (styles) {
        markup += " style=\"" + utils.escape(styles) + "\"";
    }

    // Add the attributes
    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "=\"";
            markup += utils.escape(this.attributes[attr]);
            markup += "\"";
        }
    }

    markup += ">";

    // Add the markup of the children, also as markup
    for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
    }

    markup += "</span>";

    return markup;
};

/**
 * This node represents a document fragment, which contains elements, but when
 * placed into the DOM doesn't have any representation itself. Thus, it only
 * contains children and doesn't have any HTML properties. It also keeps track
 * of a height, depth, and maxFontSize.
 */
function documentFragment(children) {
    this.children = children || [];
    this.height = 0;
    this.depth = 0;
    this.maxFontSize = 0;
}

/**
 * Convert the fragment into a node
 */
documentFragment.prototype.toNode = function() {
    // Create a fragment
    var frag = document.createDocumentFragment();

    // Append the children
    for (var i = 0; i < this.children.length; i++) {
        frag.appendChild(this.children[i].toNode());
    }

    return frag;
};

/**
 * Convert the fragment into HTML markup
 */
documentFragment.prototype.toMarkup = function() {
    var markup = "";

    // Simply concatenate the markup for the children together
    for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
    }

    return markup;
};

var iCombinations = {
    '': '\u0131\u0302',
    '': '\u0131\u0308',
    '': '\u0131\u0301',
    // '': '\u0131\u0304', // enable when we add Extended Latin
    '': '\u0131\u0300'
};

/**
 * A symbol node contains information about a single symbol. It either renders
 * to a single text node, or a span with a single text node in it, depending on
 * whether it has CSS classes, styles, or needs italic correction.
 */
function symbolNode(value, height, depth, italic, skew, classes, style) {
    this.value = value || "";
    this.height = height || 0;
    this.depth = depth || 0;
    this.italic = italic || 0;
    this.skew = skew || 0;
    this.classes = classes || [];
    this.style = style || {};
    this.maxFontSize = 0;

    // Mark CJK characters with specific classes so that we can specify which
    // fonts to use.  This allows us to render these characters with a serif
    // font in situations where the browser would either default to a sans serif
    // or render a placeholder character.
    if (unicodeRegexes.cjkRegex.test(value)) {
        // I couldn't find any fonts that contained Hangul as well as all of
        // the other characters we wanted to test there for it gets its own
        // CSS class.
        if (unicodeRegexes.hangulRegex.test(value)) {
            this.classes.push('hangul_fallback');
        } else {
            this.classes.push('cjk_fallback');
        }
    }

    if (/[]/.test(this.value)) {    // add  when we add Extended Latin
        this.value = iCombinations[this.value];
    }
}

symbolNode.prototype.tryCombine = function(sibling) {
    if (!sibling
        || !(sibling instanceof symbolNode)
        || this.italic > 0
        || createClass(this.classes) !== createClass(sibling.classes)
        || this.skew !== sibling.skew
        || this.maxFontSize !== sibling.maxFontSize) {
        return false;
    }
    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)
            && this.style[style] !== sibling.style[style]) {
            return false;
        }
    }
    for (style in sibling.style) {
        if (sibling.style.hasOwnProperty(style)
            && this.style[style] !== sibling.style[style]) {
            return false;
        }
    }
    this.value += sibling.value;
    this.height = Math.max(this.height, sibling.height);
    this.depth = Math.max(this.depth, sibling.depth);
    this.italic = sibling.italic;
    return true;
};

/**
 * Creates a text node or span from a symbol node. Note that a span is only
 * created if it is needed.
 */
symbolNode.prototype.toNode = function() {
    var node = document.createTextNode(this.value);
    var span = null;

    if (this.italic > 0) {
        span = document.createElement("span");
        span.style.marginRight = this.italic + "em";
    }

    if (this.classes.length > 0) {
        span = span || document.createElement("span");
        span.className = createClass(this.classes);
    }

    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
            span = span || document.createElement("span");
            span.style[style] = this.style[style];
        }
    }

    if (span) {
        span.appendChild(node);
        return span;
    } else {
        return node;
    }
};

/**
 * Creates markup for a symbol node.
 */
symbolNode.prototype.toMarkup = function() {
    // TODO(alpert): More duplication than I'd like from
    // span.prototype.toMarkup and symbolNode.prototype.toNode...
    var needsSpan = false;

    var markup = "<span";

    if (this.classes.length) {
        needsSpan = true;
        markup += " class=\"";
        markup += utils.escape(createClass(this.classes));
        markup += "\"";
    }

    var styles = "";

    if (this.italic > 0) {
        styles += "margin-right:" + this.italic + "em;";
    }
    for (var style in this.style) {
        if (this.style.hasOwnProperty(style)) {
            styles += utils.hyphenate(style) + ":" + this.style[style] + ";";
        }
    }

    if (styles) {
        needsSpan = true;
        markup += " style=\"" + utils.escape(styles) + "\"";
    }

    var escaped = utils.escape(this.value);
    if (needsSpan) {
        markup += ">";
        markup += escaped;
        markup += "</span>";
        return markup;
    } else {
        return escaped;
    }
};

module.exports = {
    span: span,
    documentFragment: documentFragment,
    symbolNode: symbolNode
};

},{"./unicodeRegexes":103,"./utils":104}],95:[function(require,module,exports){
/* eslint no-constant-condition:0 */
var parseData = require("./parseData");
var ParseError = require("./ParseError");
var Style = require("./Style");

var ParseNode = parseData.ParseNode;

/**
 * Parse the body of the environment, with rows delimited by \\ and
 * columns delimited by &, and create a nested list in row-major order
 * with one group per cell.
 */
function parseArray(parser, result) {
    var row = [];
    var body = [row];
    var rowGaps = [];
    while (true) {
        var cell = parser.parseExpression(false, null);
        row.push(new ParseNode("ordgroup", cell, parser.mode));
        var next = parser.nextToken.text;
        if (next === "&") {
            parser.consume();
        } else if (next === "\\end") {
            break;
        } else if (next === "\\\\" || next === "\\cr") {
            var cr = parser.parseFunction();
            rowGaps.push(cr.value.size);
            row = [];
            body.push(row);
        } else {
            throw new ParseError("Expected & or \\\\ or \\end",
                                 parser.nextToken);
        }
    }
    result.body = body;
    result.rowGaps = rowGaps;
    return new ParseNode(result.type, result, parser.mode);
}

/*
 * An environment definition is very similar to a function definition:
 * it is declared with a name or a list of names, a set of properties
 * and a handler containing the actual implementation.
 *
 * The properties include:
 *  - numArgs: The number of arguments after the \begin{name} function.
 *  - argTypes: (optional) Just like for a function
 *  - allowedInText: (optional) Whether or not the environment is allowed inside
 *                   text mode (default false) (not enforced yet)
 *  - numOptionalArgs: (optional) Just like for a function
 * A bare number instead of that object indicates the numArgs value.
 *
 * The handler function will receive two arguments
 *  - context: information and references provided by the parser
 *  - args: an array of arguments passed to \begin{name}
 * The context contains the following properties:
 *  - envName: the name of the environment, one of the listed names.
 *  - parser: the parser object
 *  - lexer: the lexer object
 *  - positions: the positions associated with these arguments from args.
 * The handler must return a ParseResult.
 */

function defineEnvironment(names, props, handler) {
    if (typeof names === "string") {
        names = [names];
    }
    if (typeof props === "number") {
        props = { numArgs: props };
    }
    // Set default values of environments
    var data = {
        numArgs: props.numArgs || 0,
        argTypes: props.argTypes,
        greediness: 1,
        allowedInText: !!props.allowedInText,
        numOptionalArgs: props.numOptionalArgs || 0,
        handler: handler
    };
    for (var i = 0; i < names.length; ++i) {
        module.exports[names[i]] = data;
    }
}

// Arrays are part of LaTeX, defined in lttab.dtx so its documentation
// is part of the source2e.pdf file of LaTeX2e source documentation.
defineEnvironment("array", {
    numArgs: 1
}, function(context, args) {
    var colalign = args[0];
    colalign = colalign.value.map ? colalign.value : [colalign];
    var cols = colalign.map(function(node) {
        var ca = node.value;
        if ("lcr".indexOf(ca) !== -1) {
            return {
                type: "align",
                align: ca
            };
        } else if (ca === "|") {
            return {
                type: "separator",
                separator: "|"
            };
        }
        throw new ParseError(
            "Unknown column alignment: " + node.value,
            node);
    });
    var res = {
        type: "array",
        cols: cols,
        hskipBeforeAndAfter: true // \@preamble in lttab.dtx
    };
    res = parseArray(context.parser, res);
    return res;
});

// The matrix environments of amsmath builds on the array environment
// of LaTeX, which is discussed above.
defineEnvironment([
    "matrix",
    "pmatrix",
    "bmatrix",
    "Bmatrix",
    "vmatrix",
    "Vmatrix"
], {
}, function(context) {
    var delimiters = {
        "matrix": null,
        "pmatrix": ["(", ")"],
        "bmatrix": ["[", "]"],
        "Bmatrix": ["\\{", "\\}"],
        "vmatrix": ["|", "|"],
        "Vmatrix": ["\\Vert", "\\Vert"]
    }[context.envName];
    var res = {
        type: "array",
        hskipBeforeAndAfter: false // \hskip -\arraycolsep in amsmath
    };
    res = parseArray(context.parser, res);
    if (delimiters) {
        res = new ParseNode("leftright", {
            body: [res],
            left: delimiters[0],
            right: delimiters[1]
        }, context.mode);
    }
    return res;
});

// A cases environment (in amsmath.sty) is almost equivalent to
// \def\arraystretch{1.2}%
// \left\{\begin{array}{@{}l@{\quad}l@{}}  \end{array}\right.
defineEnvironment("cases", {
}, function(context) {
    var res = {
        type: "array",
        arraystretch: 1.2,
        cols: [{
            type: "align",
            align: "l",
            pregap: 0,
            // TODO(kevinb) get the current style.
            // For now we use the metrics for TEXT style which is what we were
            // doing before.  Before attempting to get the current style we
            // should look at TeX's behavior especially for \over and matrices.
            postgap: Style.TEXT.metrics.quad
        }, {
            type: "align",
            align: "l",
            pregap: 0,
            postgap: 0
        }]
    };
    res = parseArray(context.parser, res);
    res = new ParseNode("leftright", {
        body: [res],
        left: "\\{",
        right: "."
    }, context.mode);
    return res;
});

// An aligned environment is like the align* environment
// except it operates within math mode.
// Note that we assume \nomallineskiplimit to be zero,
// so that \strut@ is the same as \strut.
defineEnvironment("aligned", {
}, function(context) {
    var res = {
        type: "array",
        cols: []
    };
    res = parseArray(context.parser, res);
    var emptyGroup = new ParseNode("ordgroup", [], context.mode);
    var numCols = 0;
    res.value.body.forEach(function(row) {
        var i;
        for (i = 1; i < row.length; i += 2) {
            row[i].value.unshift(emptyGroup);
        }
        if (numCols < row.length) {
            numCols = row.length;
        }
    });
    for (var i = 0; i < numCols; ++i) {
        var align = "r";
        var pregap = 0;
        if (i % 2 === 1) {
            align = "l";
        } else if (i > 0) {
            pregap = 2; // one \qquad between columns
        }
        res.value.cols[i] = {
            type: "align",
            align: align,
            pregap: pregap,
            postgap: 0
        };
    }
    return res;
});

},{"./ParseError":85,"./Style":88,"./parseData":100}],96:[function(require,module,exports){
/* eslint no-unused-vars:0 */

var Style = require("./Style");
var cjkRegex = require("./unicodeRegexes").cjkRegex;

/**
 * This file contains metrics regarding fonts and individual symbols. The sigma
 * and xi variables, as well as the metricMap map contain data extracted from
 * TeX, TeX font metrics, and the TTF files. These data are then exposed via the
 * `metrics` variable and the getCharacterMetrics function.
 */

// In TeX, there are actually three sets of dimensions, one for each of
// textstyle, scriptstyle, and scriptscriptstyle.  These are provided in the
// the arrays below, in that order.
//
// The font metrics are stored in fonts cmsy10, cmsy7, and cmsy5 respsectively.
// This was determined by running the folllowing script:
//
//     latex -interaction=nonstopmode \
//     '\documentclass{article}\usepackage{amsmath}\begin{document}' \
//     '$a$ \expandafter\show\the\textfont2' \
//     '\expandafter\show\the\scriptfont2' \
//     '\expandafter\show\the\scriptscriptfont2' \
//     '\stop'
//
// The metrics themselves were retreived using the following commands:
//
//     tftopl cmsy10
//     tftopl cmsy7
//     tftopl cmsy5
//
// The output of each of these commands is quite lengthy.  The only part we
// care about is the FONTDIMEN section. Each value is measured in EMs.
var sigmas = {
    slant: [0.250, 0.250, 0.250],       // sigma1
    space: [0.000, 0.000, 0.000],       // sigma2
    stretch: [0.000, 0.000, 0.000],     // sigma3
    shrink: [0.000, 0.000, 0.000],      // sigma4
    xHeight: [0.431, 0.431, 0.431],     // sigma5
    quad: [1.000, 1.171, 1.472],        // sigma6
    extraSpace: [0.000, 0.000, 0.000],  // sigma7
    num1: [0.677, 0.732, 0.925],        // sigma8
    num2: [0.394, 0.384, 0.387],        // sigma9
    num3: [0.444, 0.471, 0.504],        // sigma10
    denom1: [0.686, 0.752, 1.025],      // sigma11
    denom2: [0.345, 0.344, 0.532],      // sigma12
    sup1: [0.413, 0.503, 0.504],        // sigma13
    sup2: [0.363, 0.431, 0.404],        // sigma14
    sup3: [0.289, 0.286, 0.294],        // sigma15
    sub1: [0.150, 0.143, 0.200],        // sigma16
    sub2: [0.247, 0.286, 0.400],        // sigma17
    supDrop: [0.386, 0.353, 0.494],     // sigma18
    subDrop: [0.050, 0.071, 0.100],     // sigma19
    delim1: [2.390, 1.700, 1.980],      // sigma20
    delim2: [1.010, 1.157, 1.420],      // sigma21
    axisHeight: [0.250, 0.250, 0.250]  // sigma22
};

// These font metrics are extracted from TeX by using
// \font\a=cmex10
// \showthe\fontdimenX\a
// where X is the corresponding variable number. These correspond to the font
// parameters of the extension fonts (family 3). See the TeXbook, page 441.
var xi1 = 0;
var xi2 = 0;
var xi3 = 0;
var xi4 = 0;
var xi5 = 0.431;
var xi6 = 1;
var xi7 = 0;
var xi8 = 0.04;
var xi9 = 0.111;
var xi10 = 0.166;
var xi11 = 0.2;
var xi12 = 0.6;
var xi13 = 0.1;

// This value determines how large a pt is, for metrics which are defined in
// terms of pts.
// This value is also used in katex.less; if you change it make sure the values
// match.
var ptPerEm = 10.0;

// The space between adjacent `|` columns in an array definition. From
// `\showthe\doublerulesep` in LaTeX.
var doubleRuleSep = 2.0 / ptPerEm;

/**
 * This is just a mapping from common names to real metrics
 */
var metrics = {
    defaultRuleThickness: xi8,
    bigOpSpacing1: xi9,
    bigOpSpacing2: xi10,
    bigOpSpacing3: xi11,
    bigOpSpacing4: xi12,
    bigOpSpacing5: xi13,
    ptPerEm: ptPerEm,
    doubleRuleSep: doubleRuleSep
};

// This map contains a mapping from font name and character code to character
// metrics, including height, depth, italic correction, and skew (kern from the
// character to the corresponding \skewchar)
// This map is generated via `make metrics`. It should not be changed manually.
var metricMap = require("./fontMetricsData");

// These are very rough approximations.  We default to Times New Roman which
// should have Latin-1 and Cyrillic characters, but may not depending on the
// operating system.  The metrics do not account for extra height from the
// accents.  In the case of Cyrillic characters which have both ascenders and
// descenders we prefer approximations with ascenders, primarily to prevent
// the fraction bar or root line from intersecting the glyph.
// TODO(kevinb) allow union of multiple glyph metrics for better accuracy.
var extraCharacterMap = {
    // Latin-1
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'A',
    '': 'C',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'E',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'I',
    '': 'D',
    '': 'N',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'O',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'U',
    '': 'Y',
    '': 'o',
    '': 'B',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'a',
    '': 'c',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'e',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'i',
    '': 'd',
    '': 'n',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'o',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'u',
    '': 'y',
    '': 'o',
    '': 'y',

    // Cyrillic
    '': 'A',
    '': 'B',
    '': 'B',
    '': 'F',
    '': 'A',
    '': 'E',
    '': 'K',
    '': '3',
    '': 'N',
    '': 'N',
    '': 'K',
    '': 'N',
    '': 'M',
    '': 'H',
    '': 'O',
    '': 'N',
    '': 'P',
    '': 'C',
    '': 'T',
    '': 'y',
    '': 'O',
    '': 'X',
    '': 'U',
    '': 'h',
    '': 'W',
    '': 'W',
    '': 'B',
    '': 'X',
    '': 'B',
    '': '3',
    '': 'X',
    '': 'R',
    '': 'a',
    '': 'b',
    '': 'a',
    '': 'r',
    '': 'y',
    '': 'e',
    '': 'm',
    '': 'e',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'n',
    '': 'm',
    '': 'n',
    '': 'o',
    '': 'n',
    '': 'p',
    '': 'c',
    '': 'o',
    '': 'y',
    '': 'b',
    '': 'x',
    '': 'n',
    '': 'n',
    '': 'w',
    '': 'w',
    '': 'a',
    '': 'm',
    '': 'a',
    '': 'e',
    '': 'm',
    '': 'r'
};

/**
 * This function is a convenience function for looking up information in the
 * metricMap table. It takes a character as a string, and a style.
 *
 * Note: the `width` property may be undefined if fontMetricsData.js wasn't
 * built using `Make extended_metrics`.
 */
var getCharacterMetrics = function(character, style) {
    var ch = character.charCodeAt(0);
    if (character[0] in extraCharacterMap) {
        ch = extraCharacterMap[character[0]].charCodeAt(0);
    } else if (cjkRegex.test(character[0])) {
        ch = 'M'.charCodeAt(0);
    }
    var metrics = metricMap[style][ch];
    if (metrics) {
        return {
            depth: metrics[0],
            height: metrics[1],
            italic: metrics[2],
            skew: metrics[3],
            width: metrics[4]
        };
    }
};

module.exports = {
    metrics: metrics,
    sigmas: sigmas,
    getCharacterMetrics: getCharacterMetrics
};

},{"./Style":88,"./fontMetricsData":97,"./unicodeRegexes":103}],97:[function(require,module,exports){
module.exports = {
    "AMS-Regular": {
        "65": [0, 0.68889, 0, 0],
        "66": [0, 0.68889, 0, 0],
        "67": [0, 0.68889, 0, 0],
        "68": [0, 0.68889, 0, 0],
        "69": [0, 0.68889, 0, 0],
        "70": [0, 0.68889, 0, 0],
        "71": [0, 0.68889, 0, 0],
        "72": [0, 0.68889, 0, 0],
        "73": [0, 0.68889, 0, 0],
        "74": [0.16667, 0.68889, 0, 0],
        "75": [0, 0.68889, 0, 0],
        "76": [0, 0.68889, 0, 0],
        "77": [0, 0.68889, 0, 0],
        "78": [0, 0.68889, 0, 0],
        "79": [0.16667, 0.68889, 0, 0],
        "80": [0, 0.68889, 0, 0],
        "81": [0.16667, 0.68889, 0, 0],
        "82": [0, 0.68889, 0, 0],
        "83": [0, 0.68889, 0, 0],
        "84": [0, 0.68889, 0, 0],
        "85": [0, 0.68889, 0, 0],
        "86": [0, 0.68889, 0, 0],
        "87": [0, 0.68889, 0, 0],
        "88": [0, 0.68889, 0, 0],
        "89": [0, 0.68889, 0, 0],
        "90": [0, 0.68889, 0, 0],
        "107": [0, 0.68889, 0, 0],
        "165": [0, 0.675, 0.025, 0],
        "174": [0.15559, 0.69224, 0, 0],
        "240": [0, 0.68889, 0, 0],
        "295": [0, 0.68889, 0, 0],
        "710": [0, 0.825, 0, 0],
        "732": [0, 0.9, 0, 0],
        "770": [0, 0.825, 0, 0],
        "771": [0, 0.9, 0, 0],
        "989": [0.08167, 0.58167, 0, 0],
        "1008": [0, 0.43056, 0.04028, 0],
        "8245": [0, 0.54986, 0, 0],
        "8463": [0, 0.68889, 0, 0],
        "8487": [0, 0.68889, 0, 0],
        "8498": [0, 0.68889, 0, 0],
        "8502": [0, 0.68889, 0, 0],
        "8503": [0, 0.68889, 0, 0],
        "8504": [0, 0.68889, 0, 0],
        "8513": [0, 0.68889, 0, 0],
        "8592": [-0.03598, 0.46402, 0, 0],
        "8594": [-0.03598, 0.46402, 0, 0],
        "8602": [-0.13313, 0.36687, 0, 0],
        "8603": [-0.13313, 0.36687, 0, 0],
        "8606": [0.01354, 0.52239, 0, 0],
        "8608": [0.01354, 0.52239, 0, 0],
        "8610": [0.01354, 0.52239, 0, 0],
        "8611": [0.01354, 0.52239, 0, 0],
        "8619": [0, 0.54986, 0, 0],
        "8620": [0, 0.54986, 0, 0],
        "8621": [-0.13313, 0.37788, 0, 0],
        "8622": [-0.13313, 0.36687, 0, 0],
        "8624": [0, 0.69224, 0, 0],
        "8625": [0, 0.69224, 0, 0],
        "8630": [0, 0.43056, 0, 0],
        "8631": [0, 0.43056, 0, 0],
        "8634": [0.08198, 0.58198, 0, 0],
        "8635": [0.08198, 0.58198, 0, 0],
        "8638": [0.19444, 0.69224, 0, 0],
        "8639": [0.19444, 0.69224, 0, 0],
        "8642": [0.19444, 0.69224, 0, 0],
        "8643": [0.19444, 0.69224, 0, 0],
        "8644": [0.1808, 0.675, 0, 0],
        "8646": [0.1808, 0.675, 0, 0],
        "8647": [0.1808, 0.675, 0, 0],
        "8648": [0.19444, 0.69224, 0, 0],
        "8649": [0.1808, 0.675, 0, 0],
        "8650": [0.19444, 0.69224, 0, 0],
        "8651": [0.01354, 0.52239, 0, 0],
        "8652": [0.01354, 0.52239, 0, 0],
        "8653": [-0.13313, 0.36687, 0, 0],
        "8654": [-0.13313, 0.36687, 0, 0],
        "8655": [-0.13313, 0.36687, 0, 0],
        "8666": [0.13667, 0.63667, 0, 0],
        "8667": [0.13667, 0.63667, 0, 0],
        "8669": [-0.13313, 0.37788, 0, 0],
        "8672": [-0.064, 0.437, 0, 0],
        "8674": [-0.064, 0.437, 0, 0],
        "8705": [0, 0.825, 0, 0],
        "8708": [0, 0.68889, 0, 0],
        "8709": [0.08167, 0.58167, 0, 0],
        "8717": [0, 0.43056, 0, 0],
        "8722": [-0.03598, 0.46402, 0, 0],
        "8724": [0.08198, 0.69224, 0, 0],
        "8726": [0.08167, 0.58167, 0, 0],
        "8733": [0, 0.69224, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8737": [0, 0.69224, 0, 0],
        "8738": [0.03517, 0.52239, 0, 0],
        "8739": [0.08167, 0.58167, 0, 0],
        "8740": [0.25142, 0.74111, 0, 0],
        "8741": [0.08167, 0.58167, 0, 0],
        "8742": [0.25142, 0.74111, 0, 0],
        "8756": [0, 0.69224, 0, 0],
        "8757": [0, 0.69224, 0, 0],
        "8764": [-0.13313, 0.36687, 0, 0],
        "8765": [-0.13313, 0.37788, 0, 0],
        "8769": [-0.13313, 0.36687, 0, 0],
        "8770": [-0.03625, 0.46375, 0, 0],
        "8774": [0.30274, 0.79383, 0, 0],
        "8776": [-0.01688, 0.48312, 0, 0],
        "8778": [0.08167, 0.58167, 0, 0],
        "8782": [0.06062, 0.54986, 0, 0],
        "8783": [0.06062, 0.54986, 0, 0],
        "8785": [0.08198, 0.58198, 0, 0],
        "8786": [0.08198, 0.58198, 0, 0],
        "8787": [0.08198, 0.58198, 0, 0],
        "8790": [0, 0.69224, 0, 0],
        "8791": [0.22958, 0.72958, 0, 0],
        "8796": [0.08198, 0.91667, 0, 0],
        "8806": [0.25583, 0.75583, 0, 0],
        "8807": [0.25583, 0.75583, 0, 0],
        "8808": [0.25142, 0.75726, 0, 0],
        "8809": [0.25142, 0.75726, 0, 0],
        "8812": [0.25583, 0.75583, 0, 0],
        "8814": [0.20576, 0.70576, 0, 0],
        "8815": [0.20576, 0.70576, 0, 0],
        "8816": [0.30274, 0.79383, 0, 0],
        "8817": [0.30274, 0.79383, 0, 0],
        "8818": [0.22958, 0.72958, 0, 0],
        "8819": [0.22958, 0.72958, 0, 0],
        "8822": [0.1808, 0.675, 0, 0],
        "8823": [0.1808, 0.675, 0, 0],
        "8828": [0.13667, 0.63667, 0, 0],
        "8829": [0.13667, 0.63667, 0, 0],
        "8830": [0.22958, 0.72958, 0, 0],
        "8831": [0.22958, 0.72958, 0, 0],
        "8832": [0.20576, 0.70576, 0, 0],
        "8833": [0.20576, 0.70576, 0, 0],
        "8840": [0.30274, 0.79383, 0, 0],
        "8841": [0.30274, 0.79383, 0, 0],
        "8842": [0.13597, 0.63597, 0, 0],
        "8843": [0.13597, 0.63597, 0, 0],
        "8847": [0.03517, 0.54986, 0, 0],
        "8848": [0.03517, 0.54986, 0, 0],
        "8858": [0.08198, 0.58198, 0, 0],
        "8859": [0.08198, 0.58198, 0, 0],
        "8861": [0.08198, 0.58198, 0, 0],
        "8862": [0, 0.675, 0, 0],
        "8863": [0, 0.675, 0, 0],
        "8864": [0, 0.675, 0, 0],
        "8865": [0, 0.675, 0, 0],
        "8872": [0, 0.69224, 0, 0],
        "8873": [0, 0.69224, 0, 0],
        "8874": [0, 0.69224, 0, 0],
        "8876": [0, 0.68889, 0, 0],
        "8877": [0, 0.68889, 0, 0],
        "8878": [0, 0.68889, 0, 0],
        "8879": [0, 0.68889, 0, 0],
        "8882": [0.03517, 0.54986, 0, 0],
        "8883": [0.03517, 0.54986, 0, 0],
        "8884": [0.13667, 0.63667, 0, 0],
        "8885": [0.13667, 0.63667, 0, 0],
        "8888": [0, 0.54986, 0, 0],
        "8890": [0.19444, 0.43056, 0, 0],
        "8891": [0.19444, 0.69224, 0, 0],
        "8892": [0.19444, 0.69224, 0, 0],
        "8901": [0, 0.54986, 0, 0],
        "8903": [0.08167, 0.58167, 0, 0],
        "8905": [0.08167, 0.58167, 0, 0],
        "8906": [0.08167, 0.58167, 0, 0],
        "8907": [0, 0.69224, 0, 0],
        "8908": [0, 0.69224, 0, 0],
        "8909": [-0.03598, 0.46402, 0, 0],
        "8910": [0, 0.54986, 0, 0],
        "8911": [0, 0.54986, 0, 0],
        "8912": [0.03517, 0.54986, 0, 0],
        "8913": [0.03517, 0.54986, 0, 0],
        "8914": [0, 0.54986, 0, 0],
        "8915": [0, 0.54986, 0, 0],
        "8916": [0, 0.69224, 0, 0],
        "8918": [0.0391, 0.5391, 0, 0],
        "8919": [0.0391, 0.5391, 0, 0],
        "8920": [0.03517, 0.54986, 0, 0],
        "8921": [0.03517, 0.54986, 0, 0],
        "8922": [0.38569, 0.88569, 0, 0],
        "8923": [0.38569, 0.88569, 0, 0],
        "8926": [0.13667, 0.63667, 0, 0],
        "8927": [0.13667, 0.63667, 0, 0],
        "8928": [0.30274, 0.79383, 0, 0],
        "8929": [0.30274, 0.79383, 0, 0],
        "8934": [0.23222, 0.74111, 0, 0],
        "8935": [0.23222, 0.74111, 0, 0],
        "8936": [0.23222, 0.74111, 0, 0],
        "8937": [0.23222, 0.74111, 0, 0],
        "8938": [0.20576, 0.70576, 0, 0],
        "8939": [0.20576, 0.70576, 0, 0],
        "8940": [0.30274, 0.79383, 0, 0],
        "8941": [0.30274, 0.79383, 0, 0],
        "8994": [0.19444, 0.69224, 0, 0],
        "8995": [0.19444, 0.69224, 0, 0],
        "9416": [0.15559, 0.69224, 0, 0],
        "9484": [0, 0.69224, 0, 0],
        "9488": [0, 0.69224, 0, 0],
        "9492": [0, 0.37788, 0, 0],
        "9496": [0, 0.37788, 0, 0],
        "9585": [0.19444, 0.68889, 0, 0],
        "9586": [0.19444, 0.74111, 0, 0],
        "9632": [0, 0.675, 0, 0],
        "9633": [0, 0.675, 0, 0],
        "9650": [0, 0.54986, 0, 0],
        "9651": [0, 0.54986, 0, 0],
        "9654": [0.03517, 0.54986, 0, 0],
        "9660": [0, 0.54986, 0, 0],
        "9661": [0, 0.54986, 0, 0],
        "9664": [0.03517, 0.54986, 0, 0],
        "9674": [0.11111, 0.69224, 0, 0],
        "9733": [0.19444, 0.69224, 0, 0],
        "10003": [0, 0.69224, 0, 0],
        "10016": [0, 0.69224, 0, 0],
        "10731": [0.11111, 0.69224, 0, 0],
        "10846": [0.19444, 0.75583, 0, 0],
        "10877": [0.13667, 0.63667, 0, 0],
        "10878": [0.13667, 0.63667, 0, 0],
        "10885": [0.25583, 0.75583, 0, 0],
        "10886": [0.25583, 0.75583, 0, 0],
        "10887": [0.13597, 0.63597, 0, 0],
        "10888": [0.13597, 0.63597, 0, 0],
        "10889": [0.26167, 0.75726, 0, 0],
        "10890": [0.26167, 0.75726, 0, 0],
        "10891": [0.48256, 0.98256, 0, 0],
        "10892": [0.48256, 0.98256, 0, 0],
        "10901": [0.13667, 0.63667, 0, 0],
        "10902": [0.13667, 0.63667, 0, 0],
        "10933": [0.25142, 0.75726, 0, 0],
        "10934": [0.25142, 0.75726, 0, 0],
        "10935": [0.26167, 0.75726, 0, 0],
        "10936": [0.26167, 0.75726, 0, 0],
        "10937": [0.26167, 0.75726, 0, 0],
        "10938": [0.26167, 0.75726, 0, 0],
        "10949": [0.25583, 0.75583, 0, 0],
        "10950": [0.25583, 0.75583, 0, 0],
        "10955": [0.28481, 0.79383, 0, 0],
        "10956": [0.28481, 0.79383, 0, 0],
        "57350": [0.08167, 0.58167, 0, 0],
        "57351": [0.08167, 0.58167, 0, 0],
        "57352": [0.08167, 0.58167, 0, 0],
        "57353": [0, 0.43056, 0.04028, 0],
        "57356": [0.25142, 0.75726, 0, 0],
        "57357": [0.25142, 0.75726, 0, 0],
        "57358": [0.41951, 0.91951, 0, 0],
        "57359": [0.30274, 0.79383, 0, 0],
        "57360": [0.30274, 0.79383, 0, 0],
        "57361": [0.41951, 0.91951, 0, 0],
        "57366": [0.25142, 0.75726, 0, 0],
        "57367": [0.25142, 0.75726, 0, 0],
        "57368": [0.25142, 0.75726, 0, 0],
        "57369": [0.25142, 0.75726, 0, 0],
        "57370": [0.13597, 0.63597, 0, 0],
        "57371": [0.13597, 0.63597, 0, 0]
    },
    "Caligraphic-Regular": {
        "48": [0, 0.43056, 0, 0],
        "49": [0, 0.43056, 0, 0],
        "50": [0, 0.43056, 0, 0],
        "51": [0.19444, 0.43056, 0, 0],
        "52": [0.19444, 0.43056, 0, 0],
        "53": [0.19444, 0.43056, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0.19444, 0.43056, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0.19444, 0.43056, 0, 0],
        "65": [0, 0.68333, 0, 0.19445],
        "66": [0, 0.68333, 0.03041, 0.13889],
        "67": [0, 0.68333, 0.05834, 0.13889],
        "68": [0, 0.68333, 0.02778, 0.08334],
        "69": [0, 0.68333, 0.08944, 0.11111],
        "70": [0, 0.68333, 0.09931, 0.11111],
        "71": [0.09722, 0.68333, 0.0593, 0.11111],
        "72": [0, 0.68333, 0.00965, 0.11111],
        "73": [0, 0.68333, 0.07382, 0],
        "74": [0.09722, 0.68333, 0.18472, 0.16667],
        "75": [0, 0.68333, 0.01445, 0.05556],
        "76": [0, 0.68333, 0, 0.13889],
        "77": [0, 0.68333, 0, 0.13889],
        "78": [0, 0.68333, 0.14736, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.11111],
        "80": [0, 0.68333, 0.08222, 0.08334],
        "81": [0.09722, 0.68333, 0, 0.11111],
        "82": [0, 0.68333, 0, 0.08334],
        "83": [0, 0.68333, 0.075, 0.13889],
        "84": [0, 0.68333, 0.25417, 0],
        "85": [0, 0.68333, 0.09931, 0.08334],
        "86": [0, 0.68333, 0.08222, 0],
        "87": [0, 0.68333, 0.08222, 0.08334],
        "88": [0, 0.68333, 0.14643, 0.13889],
        "89": [0.09722, 0.68333, 0.08222, 0.08334],
        "90": [0, 0.68333, 0.07944, 0.13889]
    },
    "Fraktur-Regular": {
        "33": [0, 0.69141, 0, 0],
        "34": [0, 0.69141, 0, 0],
        "38": [0, 0.69141, 0, 0],
        "39": [0, 0.69141, 0, 0],
        "40": [0.24982, 0.74947, 0, 0],
        "41": [0.24982, 0.74947, 0, 0],
        "42": [0, 0.62119, 0, 0],
        "43": [0.08319, 0.58283, 0, 0],
        "44": [0, 0.10803, 0, 0],
        "45": [0.08319, 0.58283, 0, 0],
        "46": [0, 0.10803, 0, 0],
        "47": [0.24982, 0.74947, 0, 0],
        "48": [0, 0.47534, 0, 0],
        "49": [0, 0.47534, 0, 0],
        "50": [0, 0.47534, 0, 0],
        "51": [0.18906, 0.47534, 0, 0],
        "52": [0.18906, 0.47534, 0, 0],
        "53": [0.18906, 0.47534, 0, 0],
        "54": [0, 0.69141, 0, 0],
        "55": [0.18906, 0.47534, 0, 0],
        "56": [0, 0.69141, 0, 0],
        "57": [0.18906, 0.47534, 0, 0],
        "58": [0, 0.47534, 0, 0],
        "59": [0.12604, 0.47534, 0, 0],
        "61": [-0.13099, 0.36866, 0, 0],
        "63": [0, 0.69141, 0, 0],
        "65": [0, 0.69141, 0, 0],
        "66": [0, 0.69141, 0, 0],
        "67": [0, 0.69141, 0, 0],
        "68": [0, 0.69141, 0, 0],
        "69": [0, 0.69141, 0, 0],
        "70": [0.12604, 0.69141, 0, 0],
        "71": [0, 0.69141, 0, 0],
        "72": [0.06302, 0.69141, 0, 0],
        "73": [0, 0.69141, 0, 0],
        "74": [0.12604, 0.69141, 0, 0],
        "75": [0, 0.69141, 0, 0],
        "76": [0, 0.69141, 0, 0],
        "77": [0, 0.69141, 0, 0],
        "78": [0, 0.69141, 0, 0],
        "79": [0, 0.69141, 0, 0],
        "80": [0.18906, 0.69141, 0, 0],
        "81": [0.03781, 0.69141, 0, 0],
        "82": [0, 0.69141, 0, 0],
        "83": [0, 0.69141, 0, 0],
        "84": [0, 0.69141, 0, 0],
        "85": [0, 0.69141, 0, 0],
        "86": [0, 0.69141, 0, 0],
        "87": [0, 0.69141, 0, 0],
        "88": [0, 0.69141, 0, 0],
        "89": [0.18906, 0.69141, 0, 0],
        "90": [0.12604, 0.69141, 0, 0],
        "91": [0.24982, 0.74947, 0, 0],
        "93": [0.24982, 0.74947, 0, 0],
        "94": [0, 0.69141, 0, 0],
        "97": [0, 0.47534, 0, 0],
        "98": [0, 0.69141, 0, 0],
        "99": [0, 0.47534, 0, 0],
        "100": [0, 0.62119, 0, 0],
        "101": [0, 0.47534, 0, 0],
        "102": [0.18906, 0.69141, 0, 0],
        "103": [0.18906, 0.47534, 0, 0],
        "104": [0.18906, 0.69141, 0, 0],
        "105": [0, 0.69141, 0, 0],
        "106": [0, 0.69141, 0, 0],
        "107": [0, 0.69141, 0, 0],
        "108": [0, 0.69141, 0, 0],
        "109": [0, 0.47534, 0, 0],
        "110": [0, 0.47534, 0, 0],
        "111": [0, 0.47534, 0, 0],
        "112": [0.18906, 0.52396, 0, 0],
        "113": [0.18906, 0.47534, 0, 0],
        "114": [0, 0.47534, 0, 0],
        "115": [0, 0.47534, 0, 0],
        "116": [0, 0.62119, 0, 0],
        "117": [0, 0.47534, 0, 0],
        "118": [0, 0.52396, 0, 0],
        "119": [0, 0.52396, 0, 0],
        "120": [0.18906, 0.47534, 0, 0],
        "121": [0.18906, 0.47534, 0, 0],
        "122": [0.18906, 0.47534, 0, 0],
        "8216": [0, 0.69141, 0, 0],
        "8217": [0, 0.69141, 0, 0],
        "58112": [0, 0.62119, 0, 0],
        "58113": [0, 0.62119, 0, 0],
        "58114": [0.18906, 0.69141, 0, 0],
        "58115": [0.18906, 0.69141, 0, 0],
        "58116": [0.18906, 0.47534, 0, 0],
        "58117": [0, 0.69141, 0, 0],
        "58118": [0, 0.62119, 0, 0],
        "58119": [0, 0.47534, 0, 0]
    },
    "Main-Bold": {
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.13333, 0.63333, 0, 0],
        "44": [0.19444, 0.15556, 0, 0],
        "45": [0, 0.44444, 0, 0],
        "46": [0, 0.15556, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.64444, 0, 0],
        "49": [0, 0.64444, 0, 0],
        "50": [0, 0.64444, 0, 0],
        "51": [0, 0.64444, 0, 0],
        "52": [0, 0.64444, 0, 0],
        "53": [0, 0.64444, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0, 0.64444, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0, 0.64444, 0, 0],
        "58": [0, 0.44444, 0, 0],
        "59": [0.19444, 0.44444, 0, 0],
        "60": [0.08556, 0.58556, 0, 0],
        "61": [-0.10889, 0.39111, 0, 0],
        "62": [0.08556, 0.58556, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.68611, 0, 0],
        "66": [0, 0.68611, 0, 0],
        "67": [0, 0.68611, 0, 0],
        "68": [0, 0.68611, 0, 0],
        "69": [0, 0.68611, 0, 0],
        "70": [0, 0.68611, 0, 0],
        "71": [0, 0.68611, 0, 0],
        "72": [0, 0.68611, 0, 0],
        "73": [0, 0.68611, 0, 0],
        "74": [0, 0.68611, 0, 0],
        "75": [0, 0.68611, 0, 0],
        "76": [0, 0.68611, 0, 0],
        "77": [0, 0.68611, 0, 0],
        "78": [0, 0.68611, 0, 0],
        "79": [0, 0.68611, 0, 0],
        "80": [0, 0.68611, 0, 0],
        "81": [0.19444, 0.68611, 0, 0],
        "82": [0, 0.68611, 0, 0],
        "83": [0, 0.68611, 0, 0],
        "84": [0, 0.68611, 0, 0],
        "85": [0, 0.68611, 0, 0],
        "86": [0, 0.68611, 0.01597, 0],
        "87": [0, 0.68611, 0.01597, 0],
        "88": [0, 0.68611, 0, 0],
        "89": [0, 0.68611, 0.02875, 0],
        "90": [0, 0.68611, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "92": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.31, 0.13444, 0.03194, 0],
        "96": [0, 0.69444, 0, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0, 0.69444, 0.10903, 0],
        "103": [0.19444, 0.44444, 0.01597, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.69444, 0, 0],
        "106": [0.19444, 0.69444, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0, 0],
        "114": [0, 0.44444, 0, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.63492, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.01597, 0],
        "119": [0, 0.44444, 0.01597, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.01597, 0],
        "122": [0, 0.44444, 0, 0],
        "123": [0.25, 0.75, 0, 0],
        "124": [0.25, 0.75, 0, 0],
        "125": [0.25, 0.75, 0, 0],
        "126": [0.35, 0.34444, 0, 0],
        "168": [0, 0.69444, 0, 0],
        "172": [0, 0.44444, 0, 0],
        "175": [0, 0.59611, 0, 0],
        "176": [0, 0.69444, 0, 0],
        "177": [0.13333, 0.63333, 0, 0],
        "180": [0, 0.69444, 0, 0],
        "215": [0.13333, 0.63333, 0, 0],
        "247": [0.13333, 0.63333, 0, 0],
        "305": [0, 0.44444, 0, 0],
        "567": [0.19444, 0.44444, 0, 0],
        "710": [0, 0.69444, 0, 0],
        "711": [0, 0.63194, 0, 0],
        "713": [0, 0.59611, 0, 0],
        "714": [0, 0.69444, 0, 0],
        "715": [0, 0.69444, 0, 0],
        "728": [0, 0.69444, 0, 0],
        "729": [0, 0.69444, 0, 0],
        "730": [0, 0.69444, 0, 0],
        "732": [0, 0.69444, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.69444, 0, 0],
        "772": [0, 0.59611, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.69444, 0, 0],
        "776": [0, 0.69444, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.63194, 0, 0],
        "824": [0.19444, 0.69444, 0, 0],
        "915": [0, 0.68611, 0, 0],
        "916": [0, 0.68611, 0, 0],
        "920": [0, 0.68611, 0, 0],
        "923": [0, 0.68611, 0, 0],
        "926": [0, 0.68611, 0, 0],
        "928": [0, 0.68611, 0, 0],
        "931": [0, 0.68611, 0, 0],
        "933": [0, 0.68611, 0, 0],
        "934": [0, 0.68611, 0, 0],
        "936": [0, 0.68611, 0, 0],
        "937": [0, 0.68611, 0, 0],
        "8211": [0, 0.44444, 0.03194, 0],
        "8212": [0, 0.44444, 0.03194, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0],
        "8224": [0.19444, 0.69444, 0, 0],
        "8225": [0.19444, 0.69444, 0, 0],
        "8242": [0, 0.55556, 0, 0],
        "8407": [0, 0.72444, 0.15486, 0],
        "8463": [0, 0.69444, 0, 0],
        "8465": [0, 0.69444, 0, 0],
        "8467": [0, 0.69444, 0, 0],
        "8472": [0.19444, 0.44444, 0, 0],
        "8476": [0, 0.69444, 0, 0],
        "8501": [0, 0.69444, 0, 0],
        "8592": [-0.10889, 0.39111, 0, 0],
        "8593": [0.19444, 0.69444, 0, 0],
        "8594": [-0.10889, 0.39111, 0, 0],
        "8595": [0.19444, 0.69444, 0, 0],
        "8596": [-0.10889, 0.39111, 0, 0],
        "8597": [0.25, 0.75, 0, 0],
        "8598": [0.19444, 0.69444, 0, 0],
        "8599": [0.19444, 0.69444, 0, 0],
        "8600": [0.19444, 0.69444, 0, 0],
        "8601": [0.19444, 0.69444, 0, 0],
        "8636": [-0.10889, 0.39111, 0, 0],
        "8637": [-0.10889, 0.39111, 0, 0],
        "8640": [-0.10889, 0.39111, 0, 0],
        "8641": [-0.10889, 0.39111, 0, 0],
        "8656": [-0.10889, 0.39111, 0, 0],
        "8657": [0.19444, 0.69444, 0, 0],
        "8658": [-0.10889, 0.39111, 0, 0],
        "8659": [0.19444, 0.69444, 0, 0],
        "8660": [-0.10889, 0.39111, 0, 0],
        "8661": [0.25, 0.75, 0, 0],
        "8704": [0, 0.69444, 0, 0],
        "8706": [0, 0.69444, 0.06389, 0],
        "8707": [0, 0.69444, 0, 0],
        "8709": [0.05556, 0.75, 0, 0],
        "8711": [0, 0.68611, 0, 0],
        "8712": [0.08556, 0.58556, 0, 0],
        "8715": [0.08556, 0.58556, 0, 0],
        "8722": [0.13333, 0.63333, 0, 0],
        "8723": [0.13333, 0.63333, 0, 0],
        "8725": [0.25, 0.75, 0, 0],
        "8726": [0.25, 0.75, 0, 0],
        "8727": [-0.02778, 0.47222, 0, 0],
        "8728": [-0.02639, 0.47361, 0, 0],
        "8729": [-0.02639, 0.47361, 0, 0],
        "8730": [0.18, 0.82, 0, 0],
        "8733": [0, 0.44444, 0, 0],
        "8734": [0, 0.44444, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8739": [0.25, 0.75, 0, 0],
        "8741": [0.25, 0.75, 0, 0],
        "8743": [0, 0.55556, 0, 0],
        "8744": [0, 0.55556, 0, 0],
        "8745": [0, 0.55556, 0, 0],
        "8746": [0, 0.55556, 0, 0],
        "8747": [0.19444, 0.69444, 0.12778, 0],
        "8764": [-0.10889, 0.39111, 0, 0],
        "8768": [0.19444, 0.69444, 0, 0],
        "8771": [0.00222, 0.50222, 0, 0],
        "8776": [0.02444, 0.52444, 0, 0],
        "8781": [0.00222, 0.50222, 0, 0],
        "8801": [0.00222, 0.50222, 0, 0],
        "8804": [0.19667, 0.69667, 0, 0],
        "8805": [0.19667, 0.69667, 0, 0],
        "8810": [0.08556, 0.58556, 0, 0],
        "8811": [0.08556, 0.58556, 0, 0],
        "8826": [0.08556, 0.58556, 0, 0],
        "8827": [0.08556, 0.58556, 0, 0],
        "8834": [0.08556, 0.58556, 0, 0],
        "8835": [0.08556, 0.58556, 0, 0],
        "8838": [0.19667, 0.69667, 0, 0],
        "8839": [0.19667, 0.69667, 0, 0],
        "8846": [0, 0.55556, 0, 0],
        "8849": [0.19667, 0.69667, 0, 0],
        "8850": [0.19667, 0.69667, 0, 0],
        "8851": [0, 0.55556, 0, 0],
        "8852": [0, 0.55556, 0, 0],
        "8853": [0.13333, 0.63333, 0, 0],
        "8854": [0.13333, 0.63333, 0, 0],
        "8855": [0.13333, 0.63333, 0, 0],
        "8856": [0.13333, 0.63333, 0, 0],
        "8857": [0.13333, 0.63333, 0, 0],
        "8866": [0, 0.69444, 0, 0],
        "8867": [0, 0.69444, 0, 0],
        "8868": [0, 0.69444, 0, 0],
        "8869": [0, 0.69444, 0, 0],
        "8900": [-0.02639, 0.47361, 0, 0],
        "8901": [-0.02639, 0.47361, 0, 0],
        "8902": [-0.02778, 0.47222, 0, 0],
        "8968": [0.25, 0.75, 0, 0],
        "8969": [0.25, 0.75, 0, 0],
        "8970": [0.25, 0.75, 0, 0],
        "8971": [0.25, 0.75, 0, 0],
        "8994": [-0.13889, 0.36111, 0, 0],
        "8995": [-0.13889, 0.36111, 0, 0],
        "9651": [0.19444, 0.69444, 0, 0],
        "9657": [-0.02778, 0.47222, 0, 0],
        "9661": [0.19444, 0.69444, 0, 0],
        "9667": [-0.02778, 0.47222, 0, 0],
        "9711": [0.19444, 0.69444, 0, 0],
        "9824": [0.12963, 0.69444, 0, 0],
        "9825": [0.12963, 0.69444, 0, 0],
        "9826": [0.12963, 0.69444, 0, 0],
        "9827": [0.12963, 0.69444, 0, 0],
        "9837": [0, 0.75, 0, 0],
        "9838": [0.19444, 0.69444, 0, 0],
        "9839": [0.19444, 0.69444, 0, 0],
        "10216": [0.25, 0.75, 0, 0],
        "10217": [0.25, 0.75, 0, 0],
        "10815": [0, 0.68611, 0, 0],
        "10927": [0.19667, 0.69667, 0, 0],
        "10928": [0.19667, 0.69667, 0, 0]
    },
    "Main-Italic": {
        "33": [0, 0.69444, 0.12417, 0],
        "34": [0, 0.69444, 0.06961, 0],
        "35": [0.19444, 0.69444, 0.06616, 0],
        "37": [0.05556, 0.75, 0.13639, 0],
        "38": [0, 0.69444, 0.09694, 0],
        "39": [0, 0.69444, 0.12417, 0],
        "40": [0.25, 0.75, 0.16194, 0],
        "41": [0.25, 0.75, 0.03694, 0],
        "42": [0, 0.75, 0.14917, 0],
        "43": [0.05667, 0.56167, 0.03694, 0],
        "44": [0.19444, 0.10556, 0, 0],
        "45": [0, 0.43056, 0.02826, 0],
        "46": [0, 0.10556, 0, 0],
        "47": [0.25, 0.75, 0.16194, 0],
        "48": [0, 0.64444, 0.13556, 0],
        "49": [0, 0.64444, 0.13556, 0],
        "50": [0, 0.64444, 0.13556, 0],
        "51": [0, 0.64444, 0.13556, 0],
        "52": [0.19444, 0.64444, 0.13556, 0],
        "53": [0, 0.64444, 0.13556, 0],
        "54": [0, 0.64444, 0.13556, 0],
        "55": [0.19444, 0.64444, 0.13556, 0],
        "56": [0, 0.64444, 0.13556, 0],
        "57": [0, 0.64444, 0.13556, 0],
        "58": [0, 0.43056, 0.0582, 0],
        "59": [0.19444, 0.43056, 0.0582, 0],
        "61": [-0.13313, 0.36687, 0.06616, 0],
        "63": [0, 0.69444, 0.1225, 0],
        "64": [0, 0.69444, 0.09597, 0],
        "65": [0, 0.68333, 0, 0],
        "66": [0, 0.68333, 0.10257, 0],
        "67": [0, 0.68333, 0.14528, 0],
        "68": [0, 0.68333, 0.09403, 0],
        "69": [0, 0.68333, 0.12028, 0],
        "70": [0, 0.68333, 0.13305, 0],
        "71": [0, 0.68333, 0.08722, 0],
        "72": [0, 0.68333, 0.16389, 0],
        "73": [0, 0.68333, 0.15806, 0],
        "74": [0, 0.68333, 0.14028, 0],
        "75": [0, 0.68333, 0.14528, 0],
        "76": [0, 0.68333, 0, 0],
        "77": [0, 0.68333, 0.16389, 0],
        "78": [0, 0.68333, 0.16389, 0],
        "79": [0, 0.68333, 0.09403, 0],
        "80": [0, 0.68333, 0.10257, 0],
        "81": [0.19444, 0.68333, 0.09403, 0],
        "82": [0, 0.68333, 0.03868, 0],
        "83": [0, 0.68333, 0.11972, 0],
        "84": [0, 0.68333, 0.13305, 0],
        "85": [0, 0.68333, 0.16389, 0],
        "86": [0, 0.68333, 0.18361, 0],
        "87": [0, 0.68333, 0.18361, 0],
        "88": [0, 0.68333, 0.15806, 0],
        "89": [0, 0.68333, 0.19383, 0],
        "90": [0, 0.68333, 0.14528, 0],
        "91": [0.25, 0.75, 0.1875, 0],
        "93": [0.25, 0.75, 0.10528, 0],
        "94": [0, 0.69444, 0.06646, 0],
        "95": [0.31, 0.12056, 0.09208, 0],
        "97": [0, 0.43056, 0.07671, 0],
        "98": [0, 0.69444, 0.06312, 0],
        "99": [0, 0.43056, 0.05653, 0],
        "100": [0, 0.69444, 0.10333, 0],
        "101": [0, 0.43056, 0.07514, 0],
        "102": [0.19444, 0.69444, 0.21194, 0],
        "103": [0.19444, 0.43056, 0.08847, 0],
        "104": [0, 0.69444, 0.07671, 0],
        "105": [0, 0.65536, 0.1019, 0],
        "106": [0.19444, 0.65536, 0.14467, 0],
        "107": [0, 0.69444, 0.10764, 0],
        "108": [0, 0.69444, 0.10333, 0],
        "109": [0, 0.43056, 0.07671, 0],
        "110": [0, 0.43056, 0.07671, 0],
        "111": [0, 0.43056, 0.06312, 0],
        "112": [0.19444, 0.43056, 0.06312, 0],
        "113": [0.19444, 0.43056, 0.08847, 0],
        "114": [0, 0.43056, 0.10764, 0],
        "115": [0, 0.43056, 0.08208, 0],
        "116": [0, 0.61508, 0.09486, 0],
        "117": [0, 0.43056, 0.07671, 0],
        "118": [0, 0.43056, 0.10764, 0],
        "119": [0, 0.43056, 0.10764, 0],
        "120": [0, 0.43056, 0.12042, 0],
        "121": [0.19444, 0.43056, 0.08847, 0],
        "122": [0, 0.43056, 0.12292, 0],
        "126": [0.35, 0.31786, 0.11585, 0],
        "163": [0, 0.69444, 0, 0],
        "305": [0, 0.43056, 0, 0.02778],
        "567": [0.19444, 0.43056, 0, 0.08334],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0.09694, 0],
        "770": [0, 0.69444, 0.06646, 0],
        "771": [0, 0.66786, 0.11585, 0],
        "772": [0, 0.56167, 0.10333, 0],
        "774": [0, 0.69444, 0.10806, 0],
        "775": [0, 0.66786, 0.11752, 0],
        "776": [0, 0.66786, 0.10474, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0.1225, 0],
        "780": [0, 0.62847, 0.08295, 0],
        "915": [0, 0.68333, 0.13305, 0],
        "916": [0, 0.68333, 0, 0],
        "920": [0, 0.68333, 0.09403, 0],
        "923": [0, 0.68333, 0, 0],
        "926": [0, 0.68333, 0.15294, 0],
        "928": [0, 0.68333, 0.16389, 0],
        "931": [0, 0.68333, 0.12028, 0],
        "933": [0, 0.68333, 0.11111, 0],
        "934": [0, 0.68333, 0.05986, 0],
        "936": [0, 0.68333, 0.11111, 0],
        "937": [0, 0.68333, 0.10257, 0],
        "8211": [0, 0.43056, 0.09208, 0],
        "8212": [0, 0.43056, 0.09208, 0],
        "8216": [0, 0.69444, 0.12417, 0],
        "8217": [0, 0.69444, 0.12417, 0],
        "8220": [0, 0.69444, 0.1685, 0],
        "8221": [0, 0.69444, 0.06961, 0],
        "8463": [0, 0.68889, 0, 0]
    },
    "Main-Regular": {
        "32": [0, 0, 0, 0],
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.08333, 0.58333, 0, 0],
        "44": [0.19444, 0.10556, 0, 0],
        "45": [0, 0.43056, 0, 0],
        "46": [0, 0.10556, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.64444, 0, 0],
        "49": [0, 0.64444, 0, 0],
        "50": [0, 0.64444, 0, 0],
        "51": [0, 0.64444, 0, 0],
        "52": [0, 0.64444, 0, 0],
        "53": [0, 0.64444, 0, 0],
        "54": [0, 0.64444, 0, 0],
        "55": [0, 0.64444, 0, 0],
        "56": [0, 0.64444, 0, 0],
        "57": [0, 0.64444, 0, 0],
        "58": [0, 0.43056, 0, 0],
        "59": [0.19444, 0.43056, 0, 0],
        "60": [0.0391, 0.5391, 0, 0],
        "61": [-0.13313, 0.36687, 0, 0],
        "62": [0.0391, 0.5391, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.68333, 0, 0],
        "66": [0, 0.68333, 0, 0],
        "67": [0, 0.68333, 0, 0],
        "68": [0, 0.68333, 0, 0],
        "69": [0, 0.68333, 0, 0],
        "70": [0, 0.68333, 0, 0],
        "71": [0, 0.68333, 0, 0],
        "72": [0, 0.68333, 0, 0],
        "73": [0, 0.68333, 0, 0],
        "74": [0, 0.68333, 0, 0],
        "75": [0, 0.68333, 0, 0],
        "76": [0, 0.68333, 0, 0],
        "77": [0, 0.68333, 0, 0],
        "78": [0, 0.68333, 0, 0],
        "79": [0, 0.68333, 0, 0],
        "80": [0, 0.68333, 0, 0],
        "81": [0.19444, 0.68333, 0, 0],
        "82": [0, 0.68333, 0, 0],
        "83": [0, 0.68333, 0, 0],
        "84": [0, 0.68333, 0, 0],
        "85": [0, 0.68333, 0, 0],
        "86": [0, 0.68333, 0.01389, 0],
        "87": [0, 0.68333, 0.01389, 0],
        "88": [0, 0.68333, 0, 0],
        "89": [0, 0.68333, 0.025, 0],
        "90": [0, 0.68333, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "92": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.31, 0.12056, 0.02778, 0],
        "96": [0, 0.69444, 0, 0],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.43056, 0, 0],
        "102": [0, 0.69444, 0.07778, 0],
        "103": [0.19444, 0.43056, 0.01389, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.66786, 0, 0],
        "106": [0.19444, 0.66786, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0],
        "112": [0.19444, 0.43056, 0, 0],
        "113": [0.19444, 0.43056, 0, 0],
        "114": [0, 0.43056, 0, 0],
        "115": [0, 0.43056, 0, 0],
        "116": [0, 0.61508, 0, 0],
        "117": [0, 0.43056, 0, 0],
        "118": [0, 0.43056, 0.01389, 0],
        "119": [0, 0.43056, 0.01389, 0],
        "120": [0, 0.43056, 0, 0],
        "121": [0.19444, 0.43056, 0.01389, 0],
        "122": [0, 0.43056, 0, 0],
        "123": [0.25, 0.75, 0, 0],
        "124": [0.25, 0.75, 0, 0],
        "125": [0.25, 0.75, 0, 0],
        "126": [0.35, 0.31786, 0, 0],
        "160": [0, 0, 0, 0],
        "168": [0, 0.66786, 0, 0],
        "172": [0, 0.43056, 0, 0],
        "175": [0, 0.56778, 0, 0],
        "176": [0, 0.69444, 0, 0],
        "177": [0.08333, 0.58333, 0, 0],
        "180": [0, 0.69444, 0, 0],
        "215": [0.08333, 0.58333, 0, 0],
        "247": [0.08333, 0.58333, 0, 0],
        "305": [0, 0.43056, 0, 0],
        "567": [0.19444, 0.43056, 0, 0],
        "710": [0, 0.69444, 0, 0],
        "711": [0, 0.62847, 0, 0],
        "713": [0, 0.56778, 0, 0],
        "714": [0, 0.69444, 0, 0],
        "715": [0, 0.69444, 0, 0],
        "728": [0, 0.69444, 0, 0],
        "729": [0, 0.66786, 0, 0],
        "730": [0, 0.69444, 0, 0],
        "732": [0, 0.66786, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.66786, 0, 0],
        "772": [0, 0.56778, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.66786, 0, 0],
        "776": [0, 0.66786, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.62847, 0, 0],
        "824": [0.19444, 0.69444, 0, 0],
        "915": [0, 0.68333, 0, 0],
        "916": [0, 0.68333, 0, 0],
        "920": [0, 0.68333, 0, 0],
        "923": [0, 0.68333, 0, 0],
        "926": [0, 0.68333, 0, 0],
        "928": [0, 0.68333, 0, 0],
        "931": [0, 0.68333, 0, 0],
        "933": [0, 0.68333, 0, 0],
        "934": [0, 0.68333, 0, 0],
        "936": [0, 0.68333, 0, 0],
        "937": [0, 0.68333, 0, 0],
        "8211": [0, 0.43056, 0.02778, 0],
        "8212": [0, 0.43056, 0.02778, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0],
        "8224": [0.19444, 0.69444, 0, 0],
        "8225": [0.19444, 0.69444, 0, 0],
        "8230": [0, 0.12, 0, 0],
        "8242": [0, 0.55556, 0, 0],
        "8407": [0, 0.71444, 0.15382, 0],
        "8463": [0, 0.68889, 0, 0],
        "8465": [0, 0.69444, 0, 0],
        "8467": [0, 0.69444, 0, 0.11111],
        "8472": [0.19444, 0.43056, 0, 0.11111],
        "8476": [0, 0.69444, 0, 0],
        "8501": [0, 0.69444, 0, 0],
        "8592": [-0.13313, 0.36687, 0, 0],
        "8593": [0.19444, 0.69444, 0, 0],
        "8594": [-0.13313, 0.36687, 0, 0],
        "8595": [0.19444, 0.69444, 0, 0],
        "8596": [-0.13313, 0.36687, 0, 0],
        "8597": [0.25, 0.75, 0, 0],
        "8598": [0.19444, 0.69444, 0, 0],
        "8599": [0.19444, 0.69444, 0, 0],
        "8600": [0.19444, 0.69444, 0, 0],
        "8601": [0.19444, 0.69444, 0, 0],
        "8614": [0.011, 0.511, 0, 0],
        "8617": [0.011, 0.511, 0, 0],
        "8618": [0.011, 0.511, 0, 0],
        "8636": [-0.13313, 0.36687, 0, 0],
        "8637": [-0.13313, 0.36687, 0, 0],
        "8640": [-0.13313, 0.36687, 0, 0],
        "8641": [-0.13313, 0.36687, 0, 0],
        "8652": [0.011, 0.671, 0, 0],
        "8656": [-0.13313, 0.36687, 0, 0],
        "8657": [0.19444, 0.69444, 0, 0],
        "8658": [-0.13313, 0.36687, 0, 0],
        "8659": [0.19444, 0.69444, 0, 0],
        "8660": [-0.13313, 0.36687, 0, 0],
        "8661": [0.25, 0.75, 0, 0],
        "8704": [0, 0.69444, 0, 0],
        "8706": [0, 0.69444, 0.05556, 0.08334],
        "8707": [0, 0.69444, 0, 0],
        "8709": [0.05556, 0.75, 0, 0],
        "8711": [0, 0.68333, 0, 0],
        "8712": [0.0391, 0.5391, 0, 0],
        "8715": [0.0391, 0.5391, 0, 0],
        "8722": [0.08333, 0.58333, 0, 0],
        "8723": [0.08333, 0.58333, 0, 0],
        "8725": [0.25, 0.75, 0, 0],
        "8726": [0.25, 0.75, 0, 0],
        "8727": [-0.03472, 0.46528, 0, 0],
        "8728": [-0.05555, 0.44445, 0, 0],
        "8729": [-0.05555, 0.44445, 0, 0],
        "8730": [0.2, 0.8, 0, 0],
        "8733": [0, 0.43056, 0, 0],
        "8734": [0, 0.43056, 0, 0],
        "8736": [0, 0.69224, 0, 0],
        "8739": [0.25, 0.75, 0, 0],
        "8741": [0.25, 0.75, 0, 0],
        "8743": [0, 0.55556, 0, 0],
        "8744": [0, 0.55556, 0, 0],
        "8745": [0, 0.55556, 0, 0],
        "8746": [0, 0.55556, 0, 0],
        "8747": [0.19444, 0.69444, 0.11111, 0],
        "8764": [-0.13313, 0.36687, 0, 0],
        "8768": [0.19444, 0.69444, 0, 0],
        "8771": [-0.03625, 0.46375, 0, 0],
        "8773": [-0.022, 0.589, 0, 0],
        "8776": [-0.01688, 0.48312, 0, 0],
        "8781": [-0.03625, 0.46375, 0, 0],
        "8784": [-0.133, 0.67, 0, 0],
        "8800": [0.215, 0.716, 0, 0],
        "8801": [-0.03625, 0.46375, 0, 0],
        "8804": [0.13597, 0.63597, 0, 0],
        "8805": [0.13597, 0.63597, 0, 0],
        "8810": [0.0391, 0.5391, 0, 0],
        "8811": [0.0391, 0.5391, 0, 0],
        "8826": [0.0391, 0.5391, 0, 0],
        "8827": [0.0391, 0.5391, 0, 0],
        "8834": [0.0391, 0.5391, 0, 0],
        "8835": [0.0391, 0.5391, 0, 0],
        "8838": [0.13597, 0.63597, 0, 0],
        "8839": [0.13597, 0.63597, 0, 0],
        "8846": [0, 0.55556, 0, 0],
        "8849": [0.13597, 0.63597, 0, 0],
        "8850": [0.13597, 0.63597, 0, 0],
        "8851": [0, 0.55556, 0, 0],
        "8852": [0, 0.55556, 0, 0],
        "8853": [0.08333, 0.58333, 0, 0],
        "8854": [0.08333, 0.58333, 0, 0],
        "8855": [0.08333, 0.58333, 0, 0],
        "8856": [0.08333, 0.58333, 0, 0],
        "8857": [0.08333, 0.58333, 0, 0],
        "8866": [0, 0.69444, 0, 0],
        "8867": [0, 0.69444, 0, 0],
        "8868": [0, 0.69444, 0, 0],
        "8869": [0, 0.69444, 0, 0],
        "8872": [0.249, 0.75, 0, 0],
        "8900": [-0.05555, 0.44445, 0, 0],
        "8901": [-0.05555, 0.44445, 0, 0],
        "8902": [-0.03472, 0.46528, 0, 0],
        "8904": [0.005, 0.505, 0, 0],
        "8942": [0.03, 0.9, 0, 0],
        "8943": [-0.19, 0.31, 0, 0],
        "8945": [-0.1, 0.82, 0, 0],
        "8968": [0.25, 0.75, 0, 0],
        "8969": [0.25, 0.75, 0, 0],
        "8970": [0.25, 0.75, 0, 0],
        "8971": [0.25, 0.75, 0, 0],
        "8994": [-0.14236, 0.35764, 0, 0],
        "8995": [-0.14236, 0.35764, 0, 0],
        "9136": [0.244, 0.744, 0, 0],
        "9137": [0.244, 0.744, 0, 0],
        "9651": [0.19444, 0.69444, 0, 0],
        "9657": [-0.03472, 0.46528, 0, 0],
        "9661": [0.19444, 0.69444, 0, 0],
        "9667": [-0.03472, 0.46528, 0, 0],
        "9711": [0.19444, 0.69444, 0, 0],
        "9824": [0.12963, 0.69444, 0, 0],
        "9825": [0.12963, 0.69444, 0, 0],
        "9826": [0.12963, 0.69444, 0, 0],
        "9827": [0.12963, 0.69444, 0, 0],
        "9837": [0, 0.75, 0, 0],
        "9838": [0.19444, 0.69444, 0, 0],
        "9839": [0.19444, 0.69444, 0, 0],
        "10216": [0.25, 0.75, 0, 0],
        "10217": [0.25, 0.75, 0, 0],
        "10222": [0.244, 0.744, 0, 0],
        "10223": [0.244, 0.744, 0, 0],
        "10229": [0.011, 0.511, 0, 0],
        "10230": [0.011, 0.511, 0, 0],
        "10231": [0.011, 0.511, 0, 0],
        "10232": [0.024, 0.525, 0, 0],
        "10233": [0.024, 0.525, 0, 0],
        "10234": [0.024, 0.525, 0, 0],
        "10236": [0.011, 0.511, 0, 0],
        "10815": [0, 0.68333, 0, 0],
        "10927": [0.13597, 0.63597, 0, 0],
        "10928": [0.13597, 0.63597, 0, 0]
    },
    "Math-BoldItalic": {
        "47": [0.19444, 0.69444, 0, 0],
        "65": [0, 0.68611, 0, 0],
        "66": [0, 0.68611, 0.04835, 0],
        "67": [0, 0.68611, 0.06979, 0],
        "68": [0, 0.68611, 0.03194, 0],
        "69": [0, 0.68611, 0.05451, 0],
        "70": [0, 0.68611, 0.15972, 0],
        "71": [0, 0.68611, 0, 0],
        "72": [0, 0.68611, 0.08229, 0],
        "73": [0, 0.68611, 0.07778, 0],
        "74": [0, 0.68611, 0.10069, 0],
        "75": [0, 0.68611, 0.06979, 0],
        "76": [0, 0.68611, 0, 0],
        "77": [0, 0.68611, 0.11424, 0],
        "78": [0, 0.68611, 0.11424, 0],
        "79": [0, 0.68611, 0.03194, 0],
        "80": [0, 0.68611, 0.15972, 0],
        "81": [0.19444, 0.68611, 0, 0],
        "82": [0, 0.68611, 0.00421, 0],
        "83": [0, 0.68611, 0.05382, 0],
        "84": [0, 0.68611, 0.15972, 0],
        "85": [0, 0.68611, 0.11424, 0],
        "86": [0, 0.68611, 0.25555, 0],
        "87": [0, 0.68611, 0.15972, 0],
        "88": [0, 0.68611, 0.07778, 0],
        "89": [0, 0.68611, 0.25555, 0],
        "90": [0, 0.68611, 0.06979, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0.19444, 0.69444, 0.11042, 0],
        "103": [0.19444, 0.44444, 0.03704, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.69326, 0, 0],
        "106": [0.19444, 0.69326, 0.0622, 0],
        "107": [0, 0.69444, 0.01852, 0],
        "108": [0, 0.69444, 0.0088, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0.03704, 0],
        "114": [0, 0.44444, 0.03194, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.63492, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.03704, 0],
        "119": [0, 0.44444, 0.02778, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.03704, 0],
        "122": [0, 0.44444, 0.04213, 0],
        "915": [0, 0.68611, 0.15972, 0],
        "916": [0, 0.68611, 0, 0],
        "920": [0, 0.68611, 0.03194, 0],
        "923": [0, 0.68611, 0, 0],
        "926": [0, 0.68611, 0.07458, 0],
        "928": [0, 0.68611, 0.08229, 0],
        "931": [0, 0.68611, 0.05451, 0],
        "933": [0, 0.68611, 0.15972, 0],
        "934": [0, 0.68611, 0, 0],
        "936": [0, 0.68611, 0.11653, 0],
        "937": [0, 0.68611, 0.04835, 0],
        "945": [0, 0.44444, 0, 0],
        "946": [0.19444, 0.69444, 0.03403, 0],
        "947": [0.19444, 0.44444, 0.06389, 0],
        "948": [0, 0.69444, 0.03819, 0],
        "949": [0, 0.44444, 0, 0],
        "950": [0.19444, 0.69444, 0.06215, 0],
        "951": [0.19444, 0.44444, 0.03704, 0],
        "952": [0, 0.69444, 0.03194, 0],
        "953": [0, 0.44444, 0, 0],
        "954": [0, 0.44444, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.44444, 0, 0],
        "957": [0, 0.44444, 0.06898, 0],
        "958": [0.19444, 0.69444, 0.03021, 0],
        "959": [0, 0.44444, 0, 0],
        "960": [0, 0.44444, 0.03704, 0],
        "961": [0.19444, 0.44444, 0, 0],
        "962": [0.09722, 0.44444, 0.07917, 0],
        "963": [0, 0.44444, 0.03704, 0],
        "964": [0, 0.44444, 0.13472, 0],
        "965": [0, 0.44444, 0.03704, 0],
        "966": [0.19444, 0.44444, 0, 0],
        "967": [0.19444, 0.44444, 0, 0],
        "968": [0.19444, 0.69444, 0.03704, 0],
        "969": [0, 0.44444, 0.03704, 0],
        "977": [0, 0.69444, 0, 0],
        "981": [0.19444, 0.69444, 0, 0],
        "982": [0, 0.44444, 0.03194, 0],
        "1009": [0.19444, 0.44444, 0, 0],
        "1013": [0, 0.44444, 0, 0]
    },
    "Math-Italic": {
        "47": [0.19444, 0.69444, 0, 0],
        "65": [0, 0.68333, 0, 0.13889],
        "66": [0, 0.68333, 0.05017, 0.08334],
        "67": [0, 0.68333, 0.07153, 0.08334],
        "68": [0, 0.68333, 0.02778, 0.05556],
        "69": [0, 0.68333, 0.05764, 0.08334],
        "70": [0, 0.68333, 0.13889, 0.08334],
        "71": [0, 0.68333, 0, 0.08334],
        "72": [0, 0.68333, 0.08125, 0.05556],
        "73": [0, 0.68333, 0.07847, 0.11111],
        "74": [0, 0.68333, 0.09618, 0.16667],
        "75": [0, 0.68333, 0.07153, 0.05556],
        "76": [0, 0.68333, 0, 0.02778],
        "77": [0, 0.68333, 0.10903, 0.08334],
        "78": [0, 0.68333, 0.10903, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.08334],
        "80": [0, 0.68333, 0.13889, 0.08334],
        "81": [0.19444, 0.68333, 0, 0.08334],
        "82": [0, 0.68333, 0.00773, 0.08334],
        "83": [0, 0.68333, 0.05764, 0.08334],
        "84": [0, 0.68333, 0.13889, 0.08334],
        "85": [0, 0.68333, 0.10903, 0.02778],
        "86": [0, 0.68333, 0.22222, 0],
        "87": [0, 0.68333, 0.13889, 0],
        "88": [0, 0.68333, 0.07847, 0.08334],
        "89": [0, 0.68333, 0.22222, 0],
        "90": [0, 0.68333, 0.07153, 0.08334],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0.05556],
        "100": [0, 0.69444, 0, 0.16667],
        "101": [0, 0.43056, 0, 0.05556],
        "102": [0.19444, 0.69444, 0.10764, 0.16667],
        "103": [0.19444, 0.43056, 0.03588, 0.02778],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.65952, 0, 0],
        "106": [0.19444, 0.65952, 0.05724, 0],
        "107": [0, 0.69444, 0.03148, 0],
        "108": [0, 0.69444, 0.01968, 0.08334],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0.05556],
        "112": [0.19444, 0.43056, 0, 0.08334],
        "113": [0.19444, 0.43056, 0.03588, 0.08334],
        "114": [0, 0.43056, 0.02778, 0.05556],
        "115": [0, 0.43056, 0, 0.05556],
        "116": [0, 0.61508, 0, 0.08334],
        "117": [0, 0.43056, 0, 0.02778],
        "118": [0, 0.43056, 0.03588, 0.02778],
        "119": [0, 0.43056, 0.02691, 0.08334],
        "120": [0, 0.43056, 0, 0.02778],
        "121": [0.19444, 0.43056, 0.03588, 0.05556],
        "122": [0, 0.43056, 0.04398, 0.05556],
        "915": [0, 0.68333, 0.13889, 0.08334],
        "916": [0, 0.68333, 0, 0.16667],
        "920": [0, 0.68333, 0.02778, 0.08334],
        "923": [0, 0.68333, 0, 0.16667],
        "926": [0, 0.68333, 0.07569, 0.08334],
        "928": [0, 0.68333, 0.08125, 0.05556],
        "931": [0, 0.68333, 0.05764, 0.08334],
        "933": [0, 0.68333, 0.13889, 0.05556],
        "934": [0, 0.68333, 0, 0.08334],
        "936": [0, 0.68333, 0.11, 0.05556],
        "937": [0, 0.68333, 0.05017, 0.08334],
        "945": [0, 0.43056, 0.0037, 0.02778],
        "946": [0.19444, 0.69444, 0.05278, 0.08334],
        "947": [0.19444, 0.43056, 0.05556, 0],
        "948": [0, 0.69444, 0.03785, 0.05556],
        "949": [0, 0.43056, 0, 0.08334],
        "950": [0.19444, 0.69444, 0.07378, 0.08334],
        "951": [0.19444, 0.43056, 0.03588, 0.05556],
        "952": [0, 0.69444, 0.02778, 0.08334],
        "953": [0, 0.43056, 0, 0.05556],
        "954": [0, 0.43056, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.43056, 0, 0.02778],
        "957": [0, 0.43056, 0.06366, 0.02778],
        "958": [0.19444, 0.69444, 0.04601, 0.11111],
        "959": [0, 0.43056, 0, 0.05556],
        "960": [0, 0.43056, 0.03588, 0],
        "961": [0.19444, 0.43056, 0, 0.08334],
        "962": [0.09722, 0.43056, 0.07986, 0.08334],
        "963": [0, 0.43056, 0.03588, 0],
        "964": [0, 0.43056, 0.1132, 0.02778],
        "965": [0, 0.43056, 0.03588, 0.02778],
        "966": [0.19444, 0.43056, 0, 0.08334],
        "967": [0.19444, 0.43056, 0, 0.05556],
        "968": [0.19444, 0.69444, 0.03588, 0.11111],
        "969": [0, 0.43056, 0.03588, 0],
        "977": [0, 0.69444, 0, 0.08334],
        "981": [0.19444, 0.69444, 0, 0.08334],
        "982": [0, 0.43056, 0.02778, 0],
        "1009": [0.19444, 0.43056, 0, 0.08334],
        "1013": [0, 0.43056, 0, 0.05556]
    },
    "Math-Regular": {
        "65": [0, 0.68333, 0, 0.13889],
        "66": [0, 0.68333, 0.05017, 0.08334],
        "67": [0, 0.68333, 0.07153, 0.08334],
        "68": [0, 0.68333, 0.02778, 0.05556],
        "69": [0, 0.68333, 0.05764, 0.08334],
        "70": [0, 0.68333, 0.13889, 0.08334],
        "71": [0, 0.68333, 0, 0.08334],
        "72": [0, 0.68333, 0.08125, 0.05556],
        "73": [0, 0.68333, 0.07847, 0.11111],
        "74": [0, 0.68333, 0.09618, 0.16667],
        "75": [0, 0.68333, 0.07153, 0.05556],
        "76": [0, 0.68333, 0, 0.02778],
        "77": [0, 0.68333, 0.10903, 0.08334],
        "78": [0, 0.68333, 0.10903, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.08334],
        "80": [0, 0.68333, 0.13889, 0.08334],
        "81": [0.19444, 0.68333, 0, 0.08334],
        "82": [0, 0.68333, 0.00773, 0.08334],
        "83": [0, 0.68333, 0.05764, 0.08334],
        "84": [0, 0.68333, 0.13889, 0.08334],
        "85": [0, 0.68333, 0.10903, 0.02778],
        "86": [0, 0.68333, 0.22222, 0],
        "87": [0, 0.68333, 0.13889, 0],
        "88": [0, 0.68333, 0.07847, 0.08334],
        "89": [0, 0.68333, 0.22222, 0],
        "90": [0, 0.68333, 0.07153, 0.08334],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.43056, 0, 0.05556],
        "100": [0, 0.69444, 0, 0.16667],
        "101": [0, 0.43056, 0, 0.05556],
        "102": [0.19444, 0.69444, 0.10764, 0.16667],
        "103": [0.19444, 0.43056, 0.03588, 0.02778],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.65952, 0, 0],
        "106": [0.19444, 0.65952, 0.05724, 0],
        "107": [0, 0.69444, 0.03148, 0],
        "108": [0, 0.69444, 0.01968, 0.08334],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0.05556],
        "112": [0.19444, 0.43056, 0, 0.08334],
        "113": [0.19444, 0.43056, 0.03588, 0.08334],
        "114": [0, 0.43056, 0.02778, 0.05556],
        "115": [0, 0.43056, 0, 0.05556],
        "116": [0, 0.61508, 0, 0.08334],
        "117": [0, 0.43056, 0, 0.02778],
        "118": [0, 0.43056, 0.03588, 0.02778],
        "119": [0, 0.43056, 0.02691, 0.08334],
        "120": [0, 0.43056, 0, 0.02778],
        "121": [0.19444, 0.43056, 0.03588, 0.05556],
        "122": [0, 0.43056, 0.04398, 0.05556],
        "915": [0, 0.68333, 0.13889, 0.08334],
        "916": [0, 0.68333, 0, 0.16667],
        "920": [0, 0.68333, 0.02778, 0.08334],
        "923": [0, 0.68333, 0, 0.16667],
        "926": [0, 0.68333, 0.07569, 0.08334],
        "928": [0, 0.68333, 0.08125, 0.05556],
        "931": [0, 0.68333, 0.05764, 0.08334],
        "933": [0, 0.68333, 0.13889, 0.05556],
        "934": [0, 0.68333, 0, 0.08334],
        "936": [0, 0.68333, 0.11, 0.05556],
        "937": [0, 0.68333, 0.05017, 0.08334],
        "945": [0, 0.43056, 0.0037, 0.02778],
        "946": [0.19444, 0.69444, 0.05278, 0.08334],
        "947": [0.19444, 0.43056, 0.05556, 0],
        "948": [0, 0.69444, 0.03785, 0.05556],
        "949": [0, 0.43056, 0, 0.08334],
        "950": [0.19444, 0.69444, 0.07378, 0.08334],
        "951": [0.19444, 0.43056, 0.03588, 0.05556],
        "952": [0, 0.69444, 0.02778, 0.08334],
        "953": [0, 0.43056, 0, 0.05556],
        "954": [0, 0.43056, 0, 0],
        "955": [0, 0.69444, 0, 0],
        "956": [0.19444, 0.43056, 0, 0.02778],
        "957": [0, 0.43056, 0.06366, 0.02778],
        "958": [0.19444, 0.69444, 0.04601, 0.11111],
        "959": [0, 0.43056, 0, 0.05556],
        "960": [0, 0.43056, 0.03588, 0],
        "961": [0.19444, 0.43056, 0, 0.08334],
        "962": [0.09722, 0.43056, 0.07986, 0.08334],
        "963": [0, 0.43056, 0.03588, 0],
        "964": [0, 0.43056, 0.1132, 0.02778],
        "965": [0, 0.43056, 0.03588, 0.02778],
        "966": [0.19444, 0.43056, 0, 0.08334],
        "967": [0.19444, 0.43056, 0, 0.05556],
        "968": [0.19444, 0.69444, 0.03588, 0.11111],
        "969": [0, 0.43056, 0.03588, 0],
        "977": [0, 0.69444, 0, 0.08334],
        "981": [0.19444, 0.69444, 0, 0.08334],
        "982": [0, 0.43056, 0.02778, 0],
        "1009": [0.19444, 0.43056, 0, 0.08334],
        "1013": [0, 0.43056, 0, 0.05556]
    },
    "SansSerif-Regular": {
        "33": [0, 0.69444, 0, 0],
        "34": [0, 0.69444, 0, 0],
        "35": [0.19444, 0.69444, 0, 0],
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": [0, 0.69444, 0, 0],
        "39": [0, 0.69444, 0, 0],
        "40": [0.25, 0.75, 0, 0],
        "41": [0.25, 0.75, 0, 0],
        "42": [0, 0.75, 0, 0],
        "43": [0.08333, 0.58333, 0, 0],
        "44": [0.125, 0.08333, 0, 0],
        "45": [0, 0.44444, 0, 0],
        "46": [0, 0.08333, 0, 0],
        "47": [0.25, 0.75, 0, 0],
        "48": [0, 0.65556, 0, 0],
        "49": [0, 0.65556, 0, 0],
        "50": [0, 0.65556, 0, 0],
        "51": [0, 0.65556, 0, 0],
        "52": [0, 0.65556, 0, 0],
        "53": [0, 0.65556, 0, 0],
        "54": [0, 0.65556, 0, 0],
        "55": [0, 0.65556, 0, 0],
        "56": [0, 0.65556, 0, 0],
        "57": [0, 0.65556, 0, 0],
        "58": [0, 0.44444, 0, 0],
        "59": [0.125, 0.44444, 0, 0],
        "61": [-0.13, 0.37, 0, 0],
        "63": [0, 0.69444, 0, 0],
        "64": [0, 0.69444, 0, 0],
        "65": [0, 0.69444, 0, 0],
        "66": [0, 0.69444, 0, 0],
        "67": [0, 0.69444, 0, 0],
        "68": [0, 0.69444, 0, 0],
        "69": [0, 0.69444, 0, 0],
        "70": [0, 0.69444, 0, 0],
        "71": [0, 0.69444, 0, 0],
        "72": [0, 0.69444, 0, 0],
        "73": [0, 0.69444, 0, 0],
        "74": [0, 0.69444, 0, 0],
        "75": [0, 0.69444, 0, 0],
        "76": [0, 0.69444, 0, 0],
        "77": [0, 0.69444, 0, 0],
        "78": [0, 0.69444, 0, 0],
        "79": [0, 0.69444, 0, 0],
        "80": [0, 0.69444, 0, 0],
        "81": [0.125, 0.69444, 0, 0],
        "82": [0, 0.69444, 0, 0],
        "83": [0, 0.69444, 0, 0],
        "84": [0, 0.69444, 0, 0],
        "85": [0, 0.69444, 0, 0],
        "86": [0, 0.69444, 0.01389, 0],
        "87": [0, 0.69444, 0.01389, 0],
        "88": [0, 0.69444, 0, 0],
        "89": [0, 0.69444, 0.025, 0],
        "90": [0, 0.69444, 0, 0],
        "91": [0.25, 0.75, 0, 0],
        "93": [0.25, 0.75, 0, 0],
        "94": [0, 0.69444, 0, 0],
        "95": [0.35, 0.09444, 0.02778, 0],
        "97": [0, 0.44444, 0, 0],
        "98": [0, 0.69444, 0, 0],
        "99": [0, 0.44444, 0, 0],
        "100": [0, 0.69444, 0, 0],
        "101": [0, 0.44444, 0, 0],
        "102": [0, 0.69444, 0.06944, 0],
        "103": [0.19444, 0.44444, 0.01389, 0],
        "104": [0, 0.69444, 0, 0],
        "105": [0, 0.67937, 0, 0],
        "106": [0.19444, 0.67937, 0, 0],
        "107": [0, 0.69444, 0, 0],
        "108": [0, 0.69444, 0, 0],
        "109": [0, 0.44444, 0, 0],
        "110": [0, 0.44444, 0, 0],
        "111": [0, 0.44444, 0, 0],
        "112": [0.19444, 0.44444, 0, 0],
        "113": [0.19444, 0.44444, 0, 0],
        "114": [0, 0.44444, 0.01389, 0],
        "115": [0, 0.44444, 0, 0],
        "116": [0, 0.57143, 0, 0],
        "117": [0, 0.44444, 0, 0],
        "118": [0, 0.44444, 0.01389, 0],
        "119": [0, 0.44444, 0.01389, 0],
        "120": [0, 0.44444, 0, 0],
        "121": [0.19444, 0.44444, 0.01389, 0],
        "122": [0, 0.44444, 0, 0],
        "126": [0.35, 0.32659, 0, 0],
        "305": [0, 0.44444, 0, 0],
        "567": [0.19444, 0.44444, 0, 0],
        "768": [0, 0.69444, 0, 0],
        "769": [0, 0.69444, 0, 0],
        "770": [0, 0.69444, 0, 0],
        "771": [0, 0.67659, 0, 0],
        "772": [0, 0.60889, 0, 0],
        "774": [0, 0.69444, 0, 0],
        "775": [0, 0.67937, 0, 0],
        "776": [0, 0.67937, 0, 0],
        "778": [0, 0.69444, 0, 0],
        "779": [0, 0.69444, 0, 0],
        "780": [0, 0.63194, 0, 0],
        "915": [0, 0.69444, 0, 0],
        "916": [0, 0.69444, 0, 0],
        "920": [0, 0.69444, 0, 0],
        "923": [0, 0.69444, 0, 0],
        "926": [0, 0.69444, 0, 0],
        "928": [0, 0.69444, 0, 0],
        "931": [0, 0.69444, 0, 0],
        "933": [0, 0.69444, 0, 0],
        "934": [0, 0.69444, 0, 0],
        "936": [0, 0.69444, 0, 0],
        "937": [0, 0.69444, 0, 0],
        "8211": [0, 0.44444, 0.02778, 0],
        "8212": [0, 0.44444, 0.02778, 0],
        "8216": [0, 0.69444, 0, 0],
        "8217": [0, 0.69444, 0, 0],
        "8220": [0, 0.69444, 0, 0],
        "8221": [0, 0.69444, 0, 0]
    },
    "Script-Regular": {
        "65": [0, 0.7, 0.22925, 0],
        "66": [0, 0.7, 0.04087, 0],
        "67": [0, 0.7, 0.1689, 0],
        "68": [0, 0.7, 0.09371, 0],
        "69": [0, 0.7, 0.18583, 0],
        "70": [0, 0.7, 0.13634, 0],
        "71": [0, 0.7, 0.17322, 0],
        "72": [0, 0.7, 0.29694, 0],
        "73": [0, 0.7, 0.19189, 0],
        "74": [0.27778, 0.7, 0.19189, 0],
        "75": [0, 0.7, 0.31259, 0],
        "76": [0, 0.7, 0.19189, 0],
        "77": [0, 0.7, 0.15981, 0],
        "78": [0, 0.7, 0.3525, 0],
        "79": [0, 0.7, 0.08078, 0],
        "80": [0, 0.7, 0.08078, 0],
        "81": [0, 0.7, 0.03305, 0],
        "82": [0, 0.7, 0.06259, 0],
        "83": [0, 0.7, 0.19189, 0],
        "84": [0, 0.7, 0.29087, 0],
        "85": [0, 0.7, 0.25815, 0],
        "86": [0, 0.7, 0.27523, 0],
        "87": [0, 0.7, 0.27523, 0],
        "88": [0, 0.7, 0.26006, 0],
        "89": [0, 0.7, 0.2939, 0],
        "90": [0, 0.7, 0.24037, 0]
    },
    "Size1-Regular": {
        "40": [0.35001, 0.85, 0, 0],
        "41": [0.35001, 0.85, 0, 0],
        "47": [0.35001, 0.85, 0, 0],
        "91": [0.35001, 0.85, 0, 0],
        "92": [0.35001, 0.85, 0, 0],
        "93": [0.35001, 0.85, 0, 0],
        "123": [0.35001, 0.85, 0, 0],
        "125": [0.35001, 0.85, 0, 0],
        "710": [0, 0.72222, 0, 0],
        "732": [0, 0.72222, 0, 0],
        "770": [0, 0.72222, 0, 0],
        "771": [0, 0.72222, 0, 0],
        "8214": [-0.00099, 0.601, 0, 0],
        "8593": [1e-05, 0.6, 0, 0],
        "8595": [1e-05, 0.6, 0, 0],
        "8657": [1e-05, 0.6, 0, 0],
        "8659": [1e-05, 0.6, 0, 0],
        "8719": [0.25001, 0.75, 0, 0],
        "8720": [0.25001, 0.75, 0, 0],
        "8721": [0.25001, 0.75, 0, 0],
        "8730": [0.35001, 0.85, 0, 0],
        "8739": [-0.00599, 0.606, 0, 0],
        "8741": [-0.00599, 0.606, 0, 0],
        "8747": [0.30612, 0.805, 0.19445, 0],
        "8748": [0.306, 0.805, 0.19445, 0],
        "8749": [0.306, 0.805, 0.19445, 0],
        "8750": [0.30612, 0.805, 0.19445, 0],
        "8896": [0.25001, 0.75, 0, 0],
        "8897": [0.25001, 0.75, 0, 0],
        "8898": [0.25001, 0.75, 0, 0],
        "8899": [0.25001, 0.75, 0, 0],
        "8968": [0.35001, 0.85, 0, 0],
        "8969": [0.35001, 0.85, 0, 0],
        "8970": [0.35001, 0.85, 0, 0],
        "8971": [0.35001, 0.85, 0, 0],
        "9168": [-0.00099, 0.601, 0, 0],
        "10216": [0.35001, 0.85, 0, 0],
        "10217": [0.35001, 0.85, 0, 0],
        "10752": [0.25001, 0.75, 0, 0],
        "10753": [0.25001, 0.75, 0, 0],
        "10754": [0.25001, 0.75, 0, 0],
        "10756": [0.25001, 0.75, 0, 0],
        "10758": [0.25001, 0.75, 0, 0]
    },
    "Size2-Regular": {
        "40": [0.65002, 1.15, 0, 0],
        "41": [0.65002, 1.15, 0, 0],
        "47": [0.65002, 1.15, 0, 0],
        "91": [0.65002, 1.15, 0, 0],
        "92": [0.65002, 1.15, 0, 0],
        "93": [0.65002, 1.15, 0, 0],
        "123": [0.65002, 1.15, 0, 0],
        "125": [0.65002, 1.15, 0, 0],
        "710": [0, 0.75, 0, 0],
        "732": [0, 0.75, 0, 0],
        "770": [0, 0.75, 0, 0],
        "771": [0, 0.75, 0, 0],
        "8719": [0.55001, 1.05, 0, 0],
        "8720": [0.55001, 1.05, 0, 0],
        "8721": [0.55001, 1.05, 0, 0],
        "8730": [0.65002, 1.15, 0, 0],
        "8747": [0.86225, 1.36, 0.44445, 0],
        "8748": [0.862, 1.36, 0.44445, 0],
        "8749": [0.862, 1.36, 0.44445, 0],
        "8750": [0.86225, 1.36, 0.44445, 0],
        "8896": [0.55001, 1.05, 0, 0],
        "8897": [0.55001, 1.05, 0, 0],
        "8898": [0.55001, 1.05, 0, 0],
        "8899": [0.55001, 1.05, 0, 0],
        "8968": [0.65002, 1.15, 0, 0],
        "8969": [0.65002, 1.15, 0, 0],
        "8970": [0.65002, 1.15, 0, 0],
        "8971": [0.65002, 1.15, 0, 0],
        "10216": [0.65002, 1.15, 0, 0],
        "10217": [0.65002, 1.15, 0, 0],
        "10752": [0.55001, 1.05, 0, 0],
        "10753": [0.55001, 1.05, 0, 0],
        "10754": [0.55001, 1.05, 0, 0],
        "10756": [0.55001, 1.05, 0, 0],
        "10758": [0.55001, 1.05, 0, 0]
    },
    "Size3-Regular": {
        "40": [0.95003, 1.45, 0, 0],
        "41": [0.95003, 1.45, 0, 0],
        "47": [0.95003, 1.45, 0, 0],
        "91": [0.95003, 1.45, 0, 0],
        "92": [0.95003, 1.45, 0, 0],
        "93": [0.95003, 1.45, 0, 0],
        "123": [0.95003, 1.45, 0, 0],
        "125": [0.95003, 1.45, 0, 0],
        "710": [0, 0.75, 0, 0],
        "732": [0, 0.75, 0, 0],
        "770": [0, 0.75, 0, 0],
        "771": [0, 0.75, 0, 0],
        "8730": [0.95003, 1.45, 0, 0],
        "8968": [0.95003, 1.45, 0, 0],
        "8969": [0.95003, 1.45, 0, 0],
        "8970": [0.95003, 1.45, 0, 0],
        "8971": [0.95003, 1.45, 0, 0],
        "10216": [0.95003, 1.45, 0, 0],
        "10217": [0.95003, 1.45, 0, 0]
    },
    "Size4-Regular": {
        "40": [1.25003, 1.75, 0, 0],
        "41": [1.25003, 1.75, 0, 0],
        "47": [1.25003, 1.75, 0, 0],
        "91": [1.25003, 1.75, 0, 0],
        "92": [1.25003, 1.75, 0, 0],
        "93": [1.25003, 1.75, 0, 0],
        "123": [1.25003, 1.75, 0, 0],
        "125": [1.25003, 1.75, 0, 0],
        "710": [0, 0.825, 0, 0],
        "732": [0, 0.825, 0, 0],
        "770": [0, 0.825, 0, 0],
        "771": [0, 0.825, 0, 0],
        "8730": [1.25003, 1.75, 0, 0],
        "8968": [1.25003, 1.75, 0, 0],
        "8969": [1.25003, 1.75, 0, 0],
        "8970": [1.25003, 1.75, 0, 0],
        "8971": [1.25003, 1.75, 0, 0],
        "9115": [0.64502, 1.155, 0, 0],
        "9116": [1e-05, 0.6, 0, 0],
        "9117": [0.64502, 1.155, 0, 0],
        "9118": [0.64502, 1.155, 0, 0],
        "9119": [1e-05, 0.6, 0, 0],
        "9120": [0.64502, 1.155, 0, 0],
        "9121": [0.64502, 1.155, 0, 0],
        "9122": [-0.00099, 0.601, 0, 0],
        "9123": [0.64502, 1.155, 0, 0],
        "9124": [0.64502, 1.155, 0, 0],
        "9125": [-0.00099, 0.601, 0, 0],
        "9126": [0.64502, 1.155, 0, 0],
        "9127": [1e-05, 0.9, 0, 0],
        "9128": [0.65002, 1.15, 0, 0],
        "9129": [0.90001, 0, 0, 0],
        "9130": [0, 0.3, 0, 0],
        "9131": [1e-05, 0.9, 0, 0],
        "9132": [0.65002, 1.15, 0, 0],
        "9133": [0.90001, 0, 0, 0],
        "9143": [0.88502, 0.915, 0, 0],
        "10216": [1.25003, 1.75, 0, 0],
        "10217": [1.25003, 1.75, 0, 0],
        "57344": [-0.00499, 0.605, 0, 0],
        "57345": [-0.00499, 0.605, 0, 0],
        "57680": [0, 0.12, 0, 0],
        "57681": [0, 0.12, 0, 0],
        "57682": [0, 0.12, 0, 0],
        "57683": [0, 0.12, 0, 0]
    },
    "Typewriter-Regular": {
        "33": [0, 0.61111, 0, 0],
        "34": [0, 0.61111, 0, 0],
        "35": [0, 0.61111, 0, 0],
        "36": [0.08333, 0.69444, 0, 0],
        "37": [0.08333, 0.69444, 0, 0],
        "38": [0, 0.61111, 0, 0],
        "39": [0, 0.61111, 0, 0],
        "40": [0.08333, 0.69444, 0, 0],
        "41": [0.08333, 0.69444, 0, 0],
        "42": [0, 0.52083, 0, 0],
        "43": [-0.08056, 0.53055, 0, 0],
        "44": [0.13889, 0.125, 0, 0],
        "45": [-0.08056, 0.53055, 0, 0],
        "46": [0, 0.125, 0, 0],
        "47": [0.08333, 0.69444, 0, 0],
        "48": [0, 0.61111, 0, 0],
        "49": [0, 0.61111, 0, 0],
        "50": [0, 0.61111, 0, 0],
        "51": [0, 0.61111, 0, 0],
        "52": [0, 0.61111, 0, 0],
        "53": [0, 0.61111, 0, 0],
        "54": [0, 0.61111, 0, 0],
        "55": [0, 0.61111, 0, 0],
        "56": [0, 0.61111, 0, 0],
        "57": [0, 0.61111, 0, 0],
        "58": [0, 0.43056, 0, 0],
        "59": [0.13889, 0.43056, 0, 0],
        "60": [-0.05556, 0.55556, 0, 0],
        "61": [-0.19549, 0.41562, 0, 0],
        "62": [-0.05556, 0.55556, 0, 0],
        "63": [0, 0.61111, 0, 0],
        "64": [0, 0.61111, 0, 0],
        "65": [0, 0.61111, 0, 0],
        "66": [0, 0.61111, 0, 0],
        "67": [0, 0.61111, 0, 0],
        "68": [0, 0.61111, 0, 0],
        "69": [0, 0.61111, 0, 0],
        "70": [0, 0.61111, 0, 0],
        "71": [0, 0.61111, 0, 0],
        "72": [0, 0.61111, 0, 0],
        "73": [0, 0.61111, 0, 0],
        "74": [0, 0.61111, 0, 0],
        "75": [0, 0.61111, 0, 0],
        "76": [0, 0.61111, 0, 0],
        "77": [0, 0.61111, 0, 0],
        "78": [0, 0.61111, 0, 0],
        "79": [0, 0.61111, 0, 0],
        "80": [0, 0.61111, 0, 0],
        "81": [0.13889, 0.61111, 0, 0],
        "82": [0, 0.61111, 0, 0],
        "83": [0, 0.61111, 0, 0],
        "84": [0, 0.61111, 0, 0],
        "85": [0, 0.61111, 0, 0],
        "86": [0, 0.61111, 0, 0],
        "87": [0, 0.61111, 0, 0],
        "88": [0, 0.61111, 0, 0],
        "89": [0, 0.61111, 0, 0],
        "90": [0, 0.61111, 0, 0],
        "91": [0.08333, 0.69444, 0, 0],
        "92": [0.08333, 0.69444, 0, 0],
        "93": [0.08333, 0.69444, 0, 0],
        "94": [0, 0.61111, 0, 0],
        "95": [0.09514, 0, 0, 0],
        "96": [0, 0.61111, 0, 0],
        "97": [0, 0.43056, 0, 0],
        "98": [0, 0.61111, 0, 0],
        "99": [0, 0.43056, 0, 0],
        "100": [0, 0.61111, 0, 0],
        "101": [0, 0.43056, 0, 0],
        "102": [0, 0.61111, 0, 0],
        "103": [0.22222, 0.43056, 0, 0],
        "104": [0, 0.61111, 0, 0],
        "105": [0, 0.61111, 0, 0],
        "106": [0.22222, 0.61111, 0, 0],
        "107": [0, 0.61111, 0, 0],
        "108": [0, 0.61111, 0, 0],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0],
        "112": [0.22222, 0.43056, 0, 0],
        "113": [0.22222, 0.43056, 0, 0],
        "114": [0, 0.43056, 0, 0],
        "115": [0, 0.43056, 0, 0],
        "116": [0, 0.55358, 0, 0],
        "117": [0, 0.43056, 0, 0],
        "118": [0, 0.43056, 0, 0],
        "119": [0, 0.43056, 0, 0],
        "120": [0, 0.43056, 0, 0],
        "121": [0.22222, 0.43056, 0, 0],
        "122": [0, 0.43056, 0, 0],
        "123": [0.08333, 0.69444, 0, 0],
        "124": [0.08333, 0.69444, 0, 0],
        "125": [0.08333, 0.69444, 0, 0],
        "126": [0, 0.61111, 0, 0],
        "127": [0, 0.61111, 0, 0],
        "305": [0, 0.43056, 0, 0],
        "567": [0.22222, 0.43056, 0, 0],
        "768": [0, 0.61111, 0, 0],
        "769": [0, 0.61111, 0, 0],
        "770": [0, 0.61111, 0, 0],
        "771": [0, 0.61111, 0, 0],
        "772": [0, 0.56555, 0, 0],
        "774": [0, 0.61111, 0, 0],
        "776": [0, 0.61111, 0, 0],
        "778": [0, 0.61111, 0, 0],
        "780": [0, 0.56597, 0, 0],
        "915": [0, 0.61111, 0, 0],
        "916": [0, 0.61111, 0, 0],
        "920": [0, 0.61111, 0, 0],
        "923": [0, 0.61111, 0, 0],
        "926": [0, 0.61111, 0, 0],
        "928": [0, 0.61111, 0, 0],
        "931": [0, 0.61111, 0, 0],
        "933": [0, 0.61111, 0, 0],
        "934": [0, 0.61111, 0, 0],
        "936": [0, 0.61111, 0, 0],
        "937": [0, 0.61111, 0, 0],
        "2018": [0, 0.61111, 0, 0],
        "2019": [0, 0.61111, 0, 0],
        "8242": [0, 0.61111, 0, 0]
    }
};

},{}],98:[function(require,module,exports){
var utils = require("./utils");
var ParseError = require("./ParseError");
var parseData = require("./parseData");
var ParseNode = parseData.ParseNode;

/* This file contains a list of functions that we parse, identified by
 * the calls to defineFunction.
 *
 * The first argument to defineFunction is a single name or a list of names.
 * All functions named in such a list will share a single implementation.
 *
 * Each declared function can have associated properties, which
 * include the following:
 *
 *  - numArgs: The number of arguments the function takes.
 *             If this is the only property, it can be passed as a number
 *             instead of an element of a properties object.
 *  - argTypes: (optional) An array corresponding to each argument of the
 *              function, giving the type of argument that should be parsed. Its
 *              length should be equal to `numArgs + numOptionalArgs`. Valid
 *              types:
 *               - "size": A size-like thing, such as "1em" or "5ex"
 *               - "color": An html color, like "#abc" or "blue"
 *               - "original": The same type as the environment that the
 *                             function being parsed is in (e.g. used for the
 *                             bodies of functions like \color where the first
 *                             argument is special and the second argument is
 *                             parsed normally)
 *              Other possible types (probably shouldn't be used)
 *               - "text": Text-like (e.g. \text)
 *               - "math": Normal math
 *              If undefined, this will be treated as an appropriate length
 *              array of "original" strings
 *  - greediness: (optional) The greediness of the function to use ungrouped
 *                arguments.
 *
 *                E.g. if you have an expression
 *                  \sqrt \frac 1 2
 *                since \frac has greediness=2 vs \sqrt's greediness=1, \frac
 *                will use the two arguments '1' and '2' as its two arguments,
 *                then that whole function will be used as the argument to
 *                \sqrt. On the other hand, the expressions
 *                  \frac \frac 1 2 3
 *                and
 *                  \frac \sqrt 1 2
 *                will fail because \frac and \frac have equal greediness
 *                and \sqrt has a lower greediness than \frac respectively. To
 *                make these parse, we would have to change them to:
 *                  \frac {\frac 1 2} 3
 *                and
 *                  \frac {\sqrt 1} 2
 *
 *                The default value is `1`
 *  - allowedInText: (optional) Whether or not the function is allowed inside
 *                   text mode (default false)
 *  - numOptionalArgs: (optional) The number of optional arguments the function
 *                     should parse. If the optional arguments aren't found,
 *                     `null` will be passed to the handler in their place.
 *                     (default 0)
 *  - infix: (optional) Must be true if the function is an infix operator.
 *
 * The last argument is that implementation, the handler for the function(s).
 * It is called to handle these functions and their arguments.
 * It receives two arguments:
 *  - context contains information and references provided by the parser
 *  - args is an array of arguments obtained from TeX input
 * The context contains the following properties:
 *  - funcName: the text (i.e. name) of the function, including \
 *  - parser: the parser object
 *  - lexer: the lexer object
 *  - positions: the positions in the overall string of the function
 *               and the arguments.
 * The latter three should only be used to produce error messages.
 *
 * The function should return an object with the following keys:
 *  - type: The type of element that this is. This is then used in
 *          buildHTML/buildMathML to determine which function
 *          should be called to build this node into a DOM node
 * Any other data can be added to the object, which will be passed
 * in to the function in buildHTML/buildMathML as `group.value`.
 */

function defineFunction(names, props, handler) {
    if (typeof names === "string") {
        names = [names];
    }
    if (typeof props === "number") {
        props = { numArgs: props };
    }
    // Set default values of functions
    var data = {
        numArgs: props.numArgs,
        argTypes: props.argTypes,
        greediness: (props.greediness === undefined) ? 1 : props.greediness,
        allowedInText: !!props.allowedInText,
        numOptionalArgs: props.numOptionalArgs || 0,
        infix: !!props.infix,
        handler: handler
    };
    for (var i = 0; i < names.length; ++i) {
        module.exports[names[i]] = data;
    }
}

// Since the corresponding buildHTML/buildMathML function expects a
// list of elements, we normalize for different kinds of arguments
var ordargument = function(arg) {
    if (arg.type === "ordgroup") {
        return arg.value;
    } else {
        return [arg];
    }
};

// A normal square root
defineFunction("\\sqrt", {
    numArgs: 1,
    numOptionalArgs: 1
}, function(context, args) {
    var index = args[0];
    var body = args[1];
    return {
        type: "sqrt",
        body: body,
        index: index
    };
});

// Non-mathy text, possibly in a font
var textFunctionStyles = {
    "\\text": undefined, "\\textrm": "mathrm", "\\textsf": "mathsf",
    "\\texttt": "mathtt", "\\textnormal": "mathrm", "\\textbf": "mathbf",
    "\\textit": "textit"
};

defineFunction([
    "\\text", "\\textrm", "\\textsf", "\\texttt", "\\textnormal",
    "\\textbf", "\\textit"
], {
    numArgs: 1,
    argTypes: ["text"],
    greediness: 2,
    allowedInText: true
}, function(context, args) {
    var body = args[0];
    return {
        type: "text",
        body: ordargument(body),
        style: textFunctionStyles[context.funcName]
    };
});

// A two-argument custom color
defineFunction("\\color", {
    numArgs: 2,
    allowedInText: true,
    greediness: 3,
    argTypes: ["color", "original"]
}, function(context, args) {
    var color = args[0];
    var body = args[1];
    return {
        type: "color",
        color: color.value,
        value: ordargument(body)
    };
});

// An overline
defineFunction("\\overline", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "overline",
        body: body
    };
});

// An underline
defineFunction("\\underline", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "underline",
        body: body
    };
});

// A box of the width and height
defineFunction("\\rule", {
    numArgs: 2,
    numOptionalArgs: 1,
    argTypes: ["size", "size", "size"]
}, function(context, args) {
    var shift = args[0];
    var width = args[1];
    var height = args[2];
    return {
        type: "rule",
        shift: shift && shift.value,
        width: width.value,
        height: height.value
    };
});

// TODO: In TeX, \mkern only accepts mu-units, and \kern does not accept
// mu-units. In current KaTeX we relax this; both commands accept any unit.
defineFunction(["\\kern", "\\mkern"], {
    numArgs: 1,
    argTypes: ["size"]
}, function(context, args) {
    return {
        type: "kern",
        dimension: args[0].value
    };
});

// A KaTeX logo
defineFunction("\\KaTeX", {
    numArgs: 0
}, function(context) {
    return {
        type: "katex"
    };
});

defineFunction("\\phantom", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "phantom",
        value: ordargument(body)
    };
});

// Math class commands except \mathop
defineFunction([
    "\\mathord", "\\mathbin", "\\mathrel", "\\mathopen",
    "\\mathclose", "\\mathpunct", "\\mathinner"
], {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "mclass",
        mclass: "m" + context.funcName.substr(5),
        value: ordargument(body)
    };
});

// Build a relation by placing one symbol on top of another
defineFunction("\\stackrel", {
    numArgs: 2
}, function(context, args) {
    var top = args[0];
    var bottom = args[1];

    var bottomop = new ParseNode("op", {
        type: "op",
        limits: true,
        alwaysHandleSupSub: true,
        symbol: false,
        value: ordargument(bottom)
    }, bottom.mode);

    var supsub = new ParseNode("supsub", {
        base: bottomop,
        sup: top,
        sub: null
    }, top.mode);

    return {
        type: "mclass",
        mclass: "mrel",
        value: [supsub]
    };
});

// \mod-type functions
defineFunction("\\bmod", {
    numArgs: 0
}, function(context, args) {
    return {
        type: "mod",
        modType: "bmod",
        value: null
    };
});

defineFunction(["\\pod", "\\pmod", "\\mod"], {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "mod",
        modType: context.funcName.substr(1),
        value: ordargument(body)
    };
});

// Extra data needed for the delimiter handler down below
var delimiterSizes = {
    "\\bigl" : {mclass: "mopen",    size: 1},
    "\\Bigl" : {mclass: "mopen",    size: 2},
    "\\biggl": {mclass: "mopen",    size: 3},
    "\\Biggl": {mclass: "mopen",    size: 4},
    "\\bigr" : {mclass: "mclose",   size: 1},
    "\\Bigr" : {mclass: "mclose",   size: 2},
    "\\biggr": {mclass: "mclose",   size: 3},
    "\\Biggr": {mclass: "mclose",   size: 4},
    "\\bigm" : {mclass: "mrel",     size: 1},
    "\\Bigm" : {mclass: "mrel",     size: 2},
    "\\biggm": {mclass: "mrel",     size: 3},
    "\\Biggm": {mclass: "mrel",     size: 4},
    "\\big"  : {mclass: "mord",     size: 1},
    "\\Big"  : {mclass: "mord",     size: 2},
    "\\bigg" : {mclass: "mord",     size: 3},
    "\\Bigg" : {mclass: "mord",     size: 4}
};

var delimiters = [
    "(", ")", "[", "\\lbrack", "]", "\\rbrack",
    "\\{", "\\lbrace", "\\}", "\\rbrace",
    "\\lfloor", "\\rfloor", "\\lceil", "\\rceil",
    "<", ">", "\\langle", "\\rangle", "\\lt", "\\gt",
    "\\lvert", "\\rvert", "\\lVert", "\\rVert",
    "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache",
    "/", "\\backslash",
    "|", "\\vert", "\\|", "\\Vert",
    "\\uparrow", "\\Uparrow",
    "\\downarrow", "\\Downarrow",
    "\\updownarrow", "\\Updownarrow",
    "."
];

var fontAliases = {
    "\\Bbb": "\\mathbb",
    "\\bold": "\\mathbf",
    "\\frak": "\\mathfrak"
};

// Single-argument color functions
defineFunction([
    "\\blue", "\\orange", "\\pink", "\\red",
    "\\green", "\\gray", "\\purple",
    "\\blueA", "\\blueB", "\\blueC", "\\blueD", "\\blueE",
    "\\tealA", "\\tealB", "\\tealC", "\\tealD", "\\tealE",
    "\\greenA", "\\greenB", "\\greenC", "\\greenD", "\\greenE",
    "\\goldA", "\\goldB", "\\goldC", "\\goldD", "\\goldE",
    "\\redA", "\\redB", "\\redC", "\\redD", "\\redE",
    "\\maroonA", "\\maroonB", "\\maroonC", "\\maroonD", "\\maroonE",
    "\\purpleA", "\\purpleB", "\\purpleC", "\\purpleD", "\\purpleE",
    "\\mintA", "\\mintB", "\\mintC",
    "\\grayA", "\\grayB", "\\grayC", "\\grayD", "\\grayE",
    "\\grayF", "\\grayG", "\\grayH", "\\grayI",
    "\\kaBlue", "\\kaGreen"
], {
    numArgs: 1,
    allowedInText: true,
    greediness: 3
}, function(context, args) {
    var body = args[0];
    return {
        type: "color",
        color: "katex-" + context.funcName.slice(1),
        value: ordargument(body)
    };
});

// There are 2 flags for operators; whether they produce limits in
// displaystyle, and whether they are symbols and should grow in
// displaystyle. These four groups cover the four possible choices.

// No limits, not symbols
defineFunction([
    "\\arcsin", "\\arccos", "\\arctan", "\\arg", "\\cos", "\\cosh",
    "\\cot", "\\coth", "\\csc", "\\deg", "\\dim", "\\exp", "\\hom",
    "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh",
    "\\tan", "\\tanh"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: false,
        symbol: false,
        body: context.funcName
    };
});

// Limits, not symbols
defineFunction([
    "\\det", "\\gcd", "\\inf", "\\lim", "\\liminf", "\\limsup", "\\max",
    "\\min", "\\Pr", "\\sup"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: true,
        symbol: false,
        body: context.funcName
    };
});

// No limits, symbols
defineFunction([
    "\\int", "\\iint", "\\iiint", "\\oint"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: false,
        symbol: true,
        body: context.funcName
    };
});

// Limits, symbols
defineFunction([
    "\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap",
    "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes",
    "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint"
], {
    numArgs: 0
}, function(context) {
    return {
        type: "op",
        limits: true,
        symbol: true,
        body: context.funcName
    };
});

// \mathop class command
defineFunction("\\mathop", {
    numArgs: 1
}, function(context, args) {
    var body = args[0];
    return {
        type: "op",
        limits: false,
        symbol: false,
        value: ordargument(body)
    };
});

// Fractions
defineFunction([
    "\\dfrac", "\\frac", "\\tfrac",
    "\\dbinom", "\\binom", "\\tbinom",
    "\\\\atopfrac" // cant be entered directly
], {
    numArgs: 2,
    greediness: 2
}, function(context, args) {
    var numer = args[0];
    var denom = args[1];
    var hasBarLine;
    var leftDelim = null;
    var rightDelim = null;
    var size = "auto";

    switch (context.funcName) {
        case "\\dfrac":
        case "\\frac":
        case "\\tfrac":
            hasBarLine = true;
            break;
        case "\\\\atopfrac":
            hasBarLine = false;
            break;
        case "\\dbinom":
        case "\\binom":
        case "\\tbinom":
            hasBarLine = false;
            leftDelim = "(";
            rightDelim = ")";
            break;
        default:
            throw new Error("Unrecognized genfrac command");
    }

    switch (context.funcName) {
        case "\\dfrac":
        case "\\dbinom":
            size = "display";
            break;
        case "\\tfrac":
        case "\\tbinom":
            size = "text";
            break;
    }

    return {
        type: "genfrac",
        numer: numer,
        denom: denom,
        hasBarLine: hasBarLine,
        leftDelim: leftDelim,
        rightDelim: rightDelim,
        size: size
    };
});

// Left and right overlap functions
defineFunction(["\\llap", "\\rlap"], {
    numArgs: 1,
    allowedInText: true
}, function(context, args) {
    var body = args[0];
    return {
        type: context.funcName.slice(1),
        body: body
    };
});

// Delimiter functions
var checkDelimiter = function(delim, context) {
    if (utils.contains(delimiters, delim.value)) {
        return delim;
    } else {
        throw new ParseError(
            "Invalid delimiter: '" + delim.value + "' after '" +
            context.funcName + "'", delim);
    }
};

defineFunction([
    "\\bigl", "\\Bigl", "\\biggl", "\\Biggl",
    "\\bigr", "\\Bigr", "\\biggr", "\\Biggr",
    "\\bigm", "\\Bigm", "\\biggm", "\\Biggm",
    "\\big",  "\\Big",  "\\bigg",  "\\Bigg"
], {
    numArgs: 1
}, function(context, args) {
    var delim = checkDelimiter(args[0], context);

    return {
        type: "delimsizing",
        size: delimiterSizes[context.funcName].size,
        mclass: delimiterSizes[context.funcName].mclass,
        value: delim.value
    };
});

defineFunction([
    "\\left", "\\right"
], {
    numArgs: 1
}, function(context, args) {
    var delim = checkDelimiter(args[0], context);

    // \left and \right are caught somewhere in Parser.js, which is
    // why this data doesn't match what is in buildHTML.
    return {
        type: "leftright",
        value: delim.value
    };
});

defineFunction("\\middle", {
    numArgs: 1
}, function(context, args) {
    var delim = checkDelimiter(args[0], context);
    if (!context.parser.leftrightDepth) {
        throw new ParseError("\\middle without preceding \\left", delim);
    }

    return {
        type: "middle",
        value: delim.value
    };
});

// Sizing functions (handled in Parser.js explicitly, hence no handler)
defineFunction([
    "\\tiny", "\\scriptsize", "\\footnotesize", "\\small",
    "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"
], 0, null);

// Style changing functions (handled in Parser.js explicitly, hence no
// handler)
defineFunction([
    "\\displaystyle", "\\textstyle", "\\scriptstyle",
    "\\scriptscriptstyle"
], 0, null);

defineFunction([
    // styles
    "\\mathrm", "\\mathit", "\\mathbf",

    // families
    "\\mathbb", "\\mathcal", "\\mathfrak", "\\mathscr", "\\mathsf",
    "\\mathtt",

    // aliases
    "\\Bbb", "\\bold", "\\frak"
], {
    numArgs: 1,
    greediness: 2
}, function(context, args) {
    var body = args[0];
    var func = context.funcName;
    if (func in fontAliases) {
        func = fontAliases[func];
    }
    return {
        type: "font",
        font: func.slice(1),
        body: body
    };
});

// Accents
defineFunction([
    "\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve",
    "\\check", "\\hat", "\\vec", "\\dot"
    // We don't support expanding accents yet
    // "\\widetilde", "\\widehat"
], {
    numArgs: 1
}, function(context, args) {
    var base = args[0];
    return {
        type: "accent",
        accent: context.funcName,
        base: base
    };
});

// Infix generalized fractions
defineFunction(["\\over", "\\choose", "\\atop"], {
    numArgs: 0,
    infix: true
}, function(context) {
    var replaceWith;
    switch (context.funcName) {
        case "\\over":
            replaceWith = "\\frac";
            break;
        case "\\choose":
            replaceWith = "\\binom";
            break;
        case "\\atop":
            replaceWith = "\\\\atopfrac";
            break;
        default:
            throw new Error("Unrecognized infix genfrac command");
    }
    return {
        type: "infix",
        replaceWith: replaceWith,
        token: context.token
    };
});

// Row breaks for aligned data
defineFunction(["\\\\", "\\cr"], {
    numArgs: 0,
    numOptionalArgs: 1,
    argTypes: ["size"]
}, function(context, args) {
    var size = args[0];
    return {
        type: "cr",
        size: size
    };
});

// Environment delimiters
defineFunction(["\\begin", "\\end"], {
    numArgs: 1,
    argTypes: ["text"]
}, function(context, args) {
    var nameGroup = args[0];
    if (nameGroup.type !== "ordgroup") {
        throw new ParseError("Invalid environment name", nameGroup);
    }
    var name = "";
    for (var i = 0; i < nameGroup.value.length; ++i) {
        name += nameGroup.value[i].value;
    }
    return {
        type: "environment",
        name: name,
        nameGroup: nameGroup
    };
});

},{"./ParseError":85,"./parseData":100,"./utils":104}],99:[function(require,module,exports){
/**
 * These objects store data about MathML nodes. This is the MathML equivalent
 * of the types in domTree.js. Since MathML handles its own rendering, and
 * since we're mainly using MathML to improve accessibility, we don't manage
 * any of the styling state that the plain DOM nodes do.
 *
 * The `toNode` and `toMarkup` functions work simlarly to how they do in
 * domTree.js, creating namespaced DOM nodes and HTML text markup respectively.
 */

var utils = require("./utils");

/**
 * This node represents a general purpose MathML node of any type. The
 * constructor requires the type of node to create (for example, `"mo"` or
 * `"mspace"`, corresponding to `<mo>` and `<mspace>` tags).
 */
function MathNode(type, children) {
    this.type = type;
    this.attributes = {};
    this.children = children || [];
}

/**
 * Sets an attribute on a MathML node. MathML depends on attributes to convey a
 * semantic content, so this is used heavily.
 */
MathNode.prototype.setAttribute = function(name, value) {
    this.attributes[name] = value;
};

/**
 * Converts the math node into a MathML-namespaced DOM element.
 */
MathNode.prototype.toNode = function() {
    var node = document.createElementNS(
        "http://www.w3.org/1998/Math/MathML", this.type);

    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            node.setAttribute(attr, this.attributes[attr]);
        }
    }

    for (var i = 0; i < this.children.length; i++) {
        node.appendChild(this.children[i].toNode());
    }

    return node;
};

/**
 * Converts the math node into an HTML markup string.
 */
MathNode.prototype.toMarkup = function() {
    var markup = "<" + this.type;

    // Add the attributes
    for (var attr in this.attributes) {
        if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
            markup += " " + attr + "=\"";
            markup += utils.escape(this.attributes[attr]);
            markup += "\"";
        }
    }

    markup += ">";

    for (var i = 0; i < this.children.length; i++) {
        markup += this.children[i].toMarkup();
    }

    markup += "</" + this.type + ">";

    return markup;
};

/**
 * This node represents a piece of text.
 */
function TextNode(text) {
    this.text = text;
}

/**
 * Converts the text node into a DOM text node.
 */
TextNode.prototype.toNode = function() {
    return document.createTextNode(this.text);
};

/**
 * Converts the text node into HTML markup (which is just the text itself).
 */
TextNode.prototype.toMarkup = function() {
    return utils.escape(this.text);
};

module.exports = {
    MathNode: MathNode,
    TextNode: TextNode
};

},{"./utils":104}],100:[function(require,module,exports){
/**
 * The resulting parse tree nodes of the parse tree.
 *
 * It is possible to provide position information, so that a ParseNode can
 * fulfil a role similar to a Token in error reporting.
 * For details on the corresponding properties see Token constructor.
 * Providing such information can lead to better error reporting.
 *
 * @param {string}  type       type of node, like e.g. "ordgroup"
 * @param {?object} value      type-specific representation of the node
 * @param {string}  mode       parse mode in action for this node,
 *                             "math" or "text"
 * @param {Token=} firstToken  first token of the input for this node,
 *                             will omit position information if unset
 * @param {Token=} lastToken   last token of the input for this node,
 *                             will default to firstToken if unset
 */
function ParseNode(type, value, mode, firstToken, lastToken) {
    this.type = type;
    this.value = value;
    this.mode = mode;
    if (firstToken && (!lastToken || lastToken.lexer === firstToken.lexer)) {
        this.lexer = firstToken.lexer;
        this.start = firstToken.start;
        this.end = (lastToken || firstToken).end;
    }
}

module.exports = {
    ParseNode: ParseNode
};


},{}],101:[function(require,module,exports){
/**
 * Provides a single function for parsing an expression using a Parser
 * TODO(emily): Remove this
 */

var Parser = require("./Parser");

/**
 * Parses an expression using a Parser, then returns the parsed result.
 */
var parseTree = function(toParse, settings) {
    if (!(typeof toParse === 'string' || toParse instanceof String)) {
        throw new TypeError('KaTeX can only parse string typed expression');
    }
    var parser = new Parser(toParse, settings);

    return parser.parse();
};

module.exports = parseTree;

},{"./Parser":86}],102:[function(require,module,exports){
/**
 * This file holds a list of all no-argument functions and single-character
 * symbols (like 'a' or ';').
 *
 * For each of the symbols, there are three properties they can have:
 * - font (required): the font to be used for this symbol. Either "main" (the
     normal font), or "ams" (the ams fonts).
 * - group (required): the ParseNode group type the symbol should have (i.e.
     "textord", "mathord", etc).
     See https://github.com/Khan/KaTeX/wiki/Examining-TeX#group-types
 * - replace: the character that this symbol or function should be
 *   replaced with (i.e. "\phi" has a replace value of "\u03d5", the phi
 *   character in the main font).
 *
 * The outermost map in the table indicates what mode the symbols should be
 * accepted in (e.g. "math" or "text").
 */

module.exports = {
    math: {},
    text: {}
};

function defineSymbol(mode, font, group, replace, name) {
    module.exports[mode][name] = {
        font: font,
        group: group,
        replace: replace
    };
}

// Some abbreviations for commonly used strings.
// This helps minify the code, and also spotting typos using jshint.

// modes:
var math = "math";
var text = "text";

// fonts:
var main = "main";
var ams = "ams";

// groups:
var accent = "accent";
var bin = "bin";
var close = "close";
var inner = "inner";
var mathord = "mathord";
var op = "op";
var open = "open";
var punct = "punct";
var rel = "rel";
var spacing = "spacing";
var textord = "textord";

// Now comes the symbol table

// Relation Symbols
defineSymbol(math, main, rel, "\u2261", "\\equiv");
defineSymbol(math, main, rel, "\u227a", "\\prec");
defineSymbol(math, main, rel, "\u227b", "\\succ");
defineSymbol(math, main, rel, "\u223c", "\\sim");
defineSymbol(math, main, rel, "\u22a5", "\\perp");
defineSymbol(math, main, rel, "\u2aaf", "\\preceq");
defineSymbol(math, main, rel, "\u2ab0", "\\succeq");
defineSymbol(math, main, rel, "\u2243", "\\simeq");
defineSymbol(math, main, rel, "\u2223", "\\mid");
defineSymbol(math, main, rel, "\u226a", "\\ll");
defineSymbol(math, main, rel, "\u226b", "\\gg");
defineSymbol(math, main, rel, "\u224d", "\\asymp");
defineSymbol(math, main, rel, "\u2225", "\\parallel");
defineSymbol(math, main, rel, "\u22c8", "\\bowtie");
defineSymbol(math, main, rel, "\u2323", "\\smile");
defineSymbol(math, main, rel, "\u2291", "\\sqsubseteq");
defineSymbol(math, main, rel, "\u2292", "\\sqsupseteq");
defineSymbol(math, main, rel, "\u2250", "\\doteq");
defineSymbol(math, main, rel, "\u2322", "\\frown");
defineSymbol(math, main, rel, "\u220b", "\\ni");
defineSymbol(math, main, rel, "\u221d", "\\propto");
defineSymbol(math, main, rel, "\u22a2", "\\vdash");
defineSymbol(math, main, rel, "\u22a3", "\\dashv");
defineSymbol(math, main, rel, "\u220b", "\\owns");

// Punctuation
defineSymbol(math, main, punct, "\u002e", "\\ldotp");
defineSymbol(math, main, punct, "\u22c5", "\\cdotp");

// Misc Symbols
defineSymbol(math, main, textord, "\u0023", "\\#");
defineSymbol(text, main, textord, "\u0023", "\\#");
defineSymbol(math, main, textord, "\u0026", "\\&");
defineSymbol(text, main, textord, "\u0026", "\\&");
defineSymbol(math, main, textord, "\u2135", "\\aleph");
defineSymbol(math, main, textord, "\u2200", "\\forall");
defineSymbol(math, main, textord, "\u210f", "\\hbar");
defineSymbol(math, main, textord, "\u2203", "\\exists");
defineSymbol(math, main, textord, "\u2207", "\\nabla");
defineSymbol(math, main, textord, "\u266d", "\\flat");
defineSymbol(math, main, textord, "\u2113", "\\ell");
defineSymbol(math, main, textord, "\u266e", "\\natural");
defineSymbol(math, main, textord, "\u2663", "\\clubsuit");
defineSymbol(math, main, textord, "\u2118", "\\wp");
defineSymbol(math, main, textord, "\u266f", "\\sharp");
defineSymbol(math, main, textord, "\u2662", "\\diamondsuit");
defineSymbol(math, main, textord, "\u211c", "\\Re");
defineSymbol(math, main, textord, "\u2661", "\\heartsuit");
defineSymbol(math, main, textord, "\u2111", "\\Im");
defineSymbol(math, main, textord, "\u2660", "\\spadesuit");

// Math and Text
defineSymbol(math, main, textord, "\u2020", "\\dag");
defineSymbol(math, main, textord, "\u2021", "\\ddag");

// Large Delimiters
defineSymbol(math, main, close, "\u23b1", "\\rmoustache");
defineSymbol(math, main, open, "\u23b0", "\\lmoustache");
defineSymbol(math, main, close, "\u27ef", "\\rgroup");
defineSymbol(math, main, open, "\u27ee", "\\lgroup");

// Binary Operators
defineSymbol(math, main, bin, "\u2213", "\\mp");
defineSymbol(math, main, bin, "\u2296", "\\ominus");
defineSymbol(math, main, bin, "\u228e", "\\uplus");
defineSymbol(math, main, bin, "\u2293", "\\sqcap");
defineSymbol(math, main, bin, "\u2217", "\\ast");
defineSymbol(math, main, bin, "\u2294", "\\sqcup");
defineSymbol(math, main, bin, "\u25ef", "\\bigcirc");
defineSymbol(math, main, bin, "\u2219", "\\bullet");
defineSymbol(math, main, bin, "\u2021", "\\ddagger");
defineSymbol(math, main, bin, "\u2240", "\\wr");
defineSymbol(math, main, bin, "\u2a3f", "\\amalg");

// Arrow Symbols
defineSymbol(math, main, rel, "\u27f5", "\\longleftarrow");
defineSymbol(math, main, rel, "\u21d0", "\\Leftarrow");
defineSymbol(math, main, rel, "\u27f8", "\\Longleftarrow");
defineSymbol(math, main, rel, "\u27f6", "\\longrightarrow");
defineSymbol(math, main, rel, "\u21d2", "\\Rightarrow");
defineSymbol(math, main, rel, "\u27f9", "\\Longrightarrow");
defineSymbol(math, main, rel, "\u2194", "\\leftrightarrow");
defineSymbol(math, main, rel, "\u27f7", "\\longleftrightarrow");
defineSymbol(math, main, rel, "\u21d4", "\\Leftrightarrow");
defineSymbol(math, main, rel, "\u27fa", "\\Longleftrightarrow");
defineSymbol(math, main, rel, "\u21a6", "\\mapsto");
defineSymbol(math, main, rel, "\u27fc", "\\longmapsto");
defineSymbol(math, main, rel, "\u2197", "\\nearrow");
defineSymbol(math, main, rel, "\u21a9", "\\hookleftarrow");
defineSymbol(math, main, rel, "\u21aa", "\\hookrightarrow");
defineSymbol(math, main, rel, "\u2198", "\\searrow");
defineSymbol(math, main, rel, "\u21bc", "\\leftharpoonup");
defineSymbol(math, main, rel, "\u21c0", "\\rightharpoonup");
defineSymbol(math, main, rel, "\u2199", "\\swarrow");
defineSymbol(math, main, rel, "\u21bd", "\\leftharpoondown");
defineSymbol(math, main, rel, "\u21c1", "\\rightharpoondown");
defineSymbol(math, main, rel, "\u2196", "\\nwarrow");
defineSymbol(math, main, rel, "\u21cc", "\\rightleftharpoons");

// AMS Negated Binary Relations
defineSymbol(math, ams, rel, "\u226e", "\\nless");
defineSymbol(math, ams, rel, "\ue010", "\\nleqslant");
defineSymbol(math, ams, rel, "\ue011", "\\nleqq");
defineSymbol(math, ams, rel, "\u2a87", "\\lneq");
defineSymbol(math, ams, rel, "\u2268", "\\lneqq");
defineSymbol(math, ams, rel, "\ue00c", "\\lvertneqq");
defineSymbol(math, ams, rel, "\u22e6", "\\lnsim");
defineSymbol(math, ams, rel, "\u2a89", "\\lnapprox");
defineSymbol(math, ams, rel, "\u2280", "\\nprec");
defineSymbol(math, ams, rel, "\u22e0", "\\npreceq");
defineSymbol(math, ams, rel, "\u22e8", "\\precnsim");
defineSymbol(math, ams, rel, "\u2ab9", "\\precnapprox");
defineSymbol(math, ams, rel, "\u2241", "\\nsim");
defineSymbol(math, ams, rel, "\ue006", "\\nshortmid");
defineSymbol(math, ams, rel, "\u2224", "\\nmid");
defineSymbol(math, ams, rel, "\u22ac", "\\nvdash");
defineSymbol(math, ams, rel, "\u22ad", "\\nvDash");
defineSymbol(math, ams, rel, "\u22ea", "\\ntriangleleft");
defineSymbol(math, ams, rel, "\u22ec", "\\ntrianglelefteq");
defineSymbol(math, ams, rel, "\u228a", "\\subsetneq");
defineSymbol(math, ams, rel, "\ue01a", "\\varsubsetneq");
defineSymbol(math, ams, rel, "\u2acb", "\\subsetneqq");
defineSymbol(math, ams, rel, "\ue017", "\\varsubsetneqq");
defineSymbol(math, ams, rel, "\u226f", "\\ngtr");
defineSymbol(math, ams, rel, "\ue00f", "\\ngeqslant");
defineSymbol(math, ams, rel, "\ue00e", "\\ngeqq");
defineSymbol(math, ams, rel, "\u2a88", "\\gneq");
defineSymbol(math, ams, rel, "\u2269", "\\gneqq");
defineSymbol(math, ams, rel, "\ue00d", "\\gvertneqq");
defineSymbol(math, ams, rel, "\u22e7", "\\gnsim");
defineSymbol(math, ams, rel, "\u2a8a", "\\gnapprox");
defineSymbol(math, ams, rel, "\u2281", "\\nsucc");
defineSymbol(math, ams, rel, "\u22e1", "\\nsucceq");
defineSymbol(math, ams, rel, "\u22e9", "\\succnsim");
defineSymbol(math, ams, rel, "\u2aba", "\\succnapprox");
defineSymbol(math, ams, rel, "\u2246", "\\ncong");
defineSymbol(math, ams, rel, "\ue007", "\\nshortparallel");
defineSymbol(math, ams, rel, "\u2226", "\\nparallel");
defineSymbol(math, ams, rel, "\u22af", "\\nVDash");
defineSymbol(math, ams, rel, "\u22eb", "\\ntriangleright");
defineSymbol(math, ams, rel, "\u22ed", "\\ntrianglerighteq");
defineSymbol(math, ams, rel, "\ue018", "\\nsupseteqq");
defineSymbol(math, ams, rel, "\u228b", "\\supsetneq");
defineSymbol(math, ams, rel, "\ue01b", "\\varsupsetneq");
defineSymbol(math, ams, rel, "\u2acc", "\\supsetneqq");
defineSymbol(math, ams, rel, "\ue019", "\\varsupsetneqq");
defineSymbol(math, ams, rel, "\u22ae", "\\nVdash");
defineSymbol(math, ams, rel, "\u2ab5", "\\precneqq");
defineSymbol(math, ams, rel, "\u2ab6", "\\succneqq");
defineSymbol(math, ams, rel, "\ue016", "\\nsubseteqq");
defineSymbol(math, ams, bin, "\u22b4", "\\unlhd");
defineSymbol(math, ams, bin, "\u22b5", "\\unrhd");

// AMS Negated Arrows
defineSymbol(math, ams, rel, "\u219a", "\\nleftarrow");
defineSymbol(math, ams, rel, "\u219b", "\\nrightarrow");
defineSymbol(math, ams, rel, "\u21cd", "\\nLeftarrow");
defineSymbol(math, ams, rel, "\u21cf", "\\nRightarrow");
defineSymbol(math, ams, rel, "\u21ae", "\\nleftrightarrow");
defineSymbol(math, ams, rel, "\u21ce", "\\nLeftrightarrow");

// AMS Misc
defineSymbol(math, ams, rel, "\u25b3", "\\vartriangle");
defineSymbol(math, ams, textord, "\u210f", "\\hslash");
defineSymbol(math, ams, textord, "\u25bd", "\\triangledown");
defineSymbol(math, ams, textord, "\u25ca", "\\lozenge");
defineSymbol(math, ams, textord, "\u24c8", "\\circledS");
defineSymbol(math, ams, textord, "\u00ae", "\\circledR");
defineSymbol(math, ams, textord, "\u2221", "\\measuredangle");
defineSymbol(math, ams, textord, "\u2204", "\\nexists");
defineSymbol(math, ams, textord, "\u2127", "\\mho");
defineSymbol(math, ams, textord, "\u2132", "\\Finv");
defineSymbol(math, ams, textord, "\u2141", "\\Game");
defineSymbol(math, ams, textord, "\u006b", "\\Bbbk");
defineSymbol(math, ams, textord, "\u2035", "\\backprime");
defineSymbol(math, ams, textord, "\u25b2", "\\blacktriangle");
defineSymbol(math, ams, textord, "\u25bc", "\\blacktriangledown");
defineSymbol(math, ams, textord, "\u25a0", "\\blacksquare");
defineSymbol(math, ams, textord, "\u29eb", "\\blacklozenge");
defineSymbol(math, ams, textord, "\u2605", "\\bigstar");
defineSymbol(math, ams, textord, "\u2222", "\\sphericalangle");
defineSymbol(math, ams, textord, "\u2201", "\\complement");
defineSymbol(math, ams, textord, "\u00f0", "\\eth");
defineSymbol(math, ams, textord, "\u2571", "\\diagup");
defineSymbol(math, ams, textord, "\u2572", "\\diagdown");
defineSymbol(math, ams, textord, "\u25a1", "\\square");
defineSymbol(math, ams, textord, "\u25a1", "\\Box");
defineSymbol(math, ams, textord, "\u25ca", "\\Diamond");
defineSymbol(math, ams, textord, "\u00a5", "\\yen");
defineSymbol(math, ams, textord, "\u2713", "\\checkmark");

// AMS Hebrew
defineSymbol(math, ams, textord, "\u2136", "\\beth");
defineSymbol(math, ams, textord, "\u2138", "\\daleth");
defineSymbol(math, ams, textord, "\u2137", "\\gimel");

// AMS Greek
defineSymbol(math, ams, textord, "\u03dd", "\\digamma");
defineSymbol(math, ams, textord, "\u03f0", "\\varkappa");

// AMS Delimiters
defineSymbol(math, ams, open, "\u250c", "\\ulcorner");
defineSymbol(math, ams, close, "\u2510", "\\urcorner");
defineSymbol(math, ams, open, "\u2514", "\\llcorner");
defineSymbol(math, ams, close, "\u2518", "\\lrcorner");

// AMS Binary Relations
defineSymbol(math, ams, rel, "\u2266", "\\leqq");
defineSymbol(math, ams, rel, "\u2a7d", "\\leqslant");
defineSymbol(math, ams, rel, "\u2a95", "\\eqslantless");
defineSymbol(math, ams, rel, "\u2272", "\\lesssim");
defineSymbol(math, ams, rel, "\u2a85", "\\lessapprox");
defineSymbol(math, ams, rel, "\u224a", "\\approxeq");
defineSymbol(math, ams, bin, "\u22d6", "\\lessdot");
defineSymbol(math, ams, rel, "\u22d8", "\\lll");
defineSymbol(math, ams, rel, "\u2276", "\\lessgtr");
defineSymbol(math, ams, rel, "\u22da", "\\lesseqgtr");
defineSymbol(math, ams, rel, "\u2a8b", "\\lesseqqgtr");
defineSymbol(math, ams, rel, "\u2251", "\\doteqdot");
defineSymbol(math, ams, rel, "\u2253", "\\risingdotseq");
defineSymbol(math, ams, rel, "\u2252", "\\fallingdotseq");
defineSymbol(math, ams, rel, "\u223d", "\\backsim");
defineSymbol(math, ams, rel, "\u22cd", "\\backsimeq");
defineSymbol(math, ams, rel, "\u2ac5", "\\subseteqq");
defineSymbol(math, ams, rel, "\u22d0", "\\Subset");
defineSymbol(math, ams, rel, "\u228f", "\\sqsubset");
defineSymbol(math, ams, rel, "\u227c", "\\preccurlyeq");
defineSymbol(math, ams, rel, "\u22de", "\\curlyeqprec");
defineSymbol(math, ams, rel, "\u227e", "\\precsim");
defineSymbol(math, ams, rel, "\u2ab7", "\\precapprox");
defineSymbol(math, ams, rel, "\u22b2", "\\vartriangleleft");
defineSymbol(math, ams, rel, "\u22b4", "\\trianglelefteq");
defineSymbol(math, ams, rel, "\u22a8", "\\vDash");
defineSymbol(math, ams, rel, "\u22aa", "\\Vvdash");
defineSymbol(math, ams, rel, "\u2323", "\\smallsmile");
defineSymbol(math, ams, rel, "\u2322", "\\smallfrown");
defineSymbol(math, ams, rel, "\u224f", "\\bumpeq");
defineSymbol(math, ams, rel, "\u224e", "\\Bumpeq");
defineSymbol(math, ams, rel, "\u2267", "\\geqq");
defineSymbol(math, ams, rel, "\u2a7e", "\\geqslant");
defineSymbol(math, ams, rel, "\u2a96", "\\eqslantgtr");
defineSymbol(math, ams, rel, "\u2273", "\\gtrsim");
defineSymbol(math, ams, rel, "\u2a86", "\\gtrapprox");
defineSymbol(math, ams, bin, "\u22d7", "\\gtrdot");
defineSymbol(math, ams, rel, "\u22d9", "\\ggg");
defineSymbol(math, ams, rel, "\u2277", "\\gtrless");
defineSymbol(math, ams, rel, "\u22db", "\\gtreqless");
defineSymbol(math, ams, rel, "\u2a8c", "\\gtreqqless");
defineSymbol(math, ams, rel, "\u2256", "\\eqcirc");
defineSymbol(math, ams, rel, "\u2257", "\\circeq");
defineSymbol(math, ams, rel, "\u225c", "\\triangleq");
defineSymbol(math, ams, rel, "\u223c", "\\thicksim");
defineSymbol(math, ams, rel, "\u2248", "\\thickapprox");
defineSymbol(math, ams, rel, "\u2ac6", "\\supseteqq");
defineSymbol(math, ams, rel, "\u22d1", "\\Supset");
defineSymbol(math, ams, rel, "\u2290", "\\sqsupset");
defineSymbol(math, ams, rel, "\u227d", "\\succcurlyeq");
defineSymbol(math, ams, rel, "\u22df", "\\curlyeqsucc");
defineSymbol(math, ams, rel, "\u227f", "\\succsim");
defineSymbol(math, ams, rel, "\u2ab8", "\\succapprox");
defineSymbol(math, ams, rel, "\u22b3", "\\vartriangleright");
defineSymbol(math, ams, rel, "\u22b5", "\\trianglerighteq");
defineSymbol(math, ams, rel, "\u22a9", "\\Vdash");
defineSymbol(math, ams, rel, "\u2223", "\\shortmid");
defineSymbol(math, ams, rel, "\u2225", "\\shortparallel");
defineSymbol(math, ams, rel, "\u226c", "\\between");
defineSymbol(math, ams, rel, "\u22d4", "\\pitchfork");
defineSymbol(math, ams, rel, "\u221d", "\\varpropto");
defineSymbol(math, ams, rel, "\u25c0", "\\blacktriangleleft");
defineSymbol(math, ams, rel, "\u2234", "\\therefore");
defineSymbol(math, ams, rel, "\u220d", "\\backepsilon");
defineSymbol(math, ams, rel, "\u25b6", "\\blacktriangleright");
defineSymbol(math, ams, rel, "\u2235", "\\because");
defineSymbol(math, ams, rel, "\u22d8", "\\llless");
defineSymbol(math, ams, rel, "\u22d9", "\\gggtr");
defineSymbol(math, ams, bin, "\u22b2", "\\lhd");
defineSymbol(math, ams, bin, "\u22b3", "\\rhd");
defineSymbol(math, ams, rel, "\u2242", "\\eqsim");
defineSymbol(math, main, rel, "\u22c8", "\\Join");
defineSymbol(math, ams, rel, "\u2251", "\\Doteq");

// AMS Binary Operators
defineSymbol(math, ams, bin, "\u2214", "\\dotplus");
defineSymbol(math, ams, bin, "\u2216", "\\smallsetminus");
defineSymbol(math, ams, bin, "\u22d2", "\\Cap");
defineSymbol(math, ams, bin, "\u22d3", "\\Cup");
defineSymbol(math, ams, bin, "\u2a5e", "\\doublebarwedge");
defineSymbol(math, ams, bin, "\u229f", "\\boxminus");
defineSymbol(math, ams, bin, "\u229e", "\\boxplus");
defineSymbol(math, ams, bin, "\u22c7", "\\divideontimes");
defineSymbol(math, ams, bin, "\u22c9", "\\ltimes");
defineSymbol(math, ams, bin, "\u22ca", "\\rtimes");
defineSymbol(math, ams, bin, "\u22cb", "\\leftthreetimes");
defineSymbol(math, ams, bin, "\u22cc", "\\rightthreetimes");
defineSymbol(math, ams, bin, "\u22cf", "\\curlywedge");
defineSymbol(math, ams, bin, "\u22ce", "\\curlyvee");
defineSymbol(math, ams, bin, "\u229d", "\\circleddash");
defineSymbol(math, ams, bin, "\u229b", "\\circledast");
defineSymbol(math, ams, bin, "\u22c5", "\\centerdot");
defineSymbol(math, ams, bin, "\u22ba", "\\intercal");
defineSymbol(math, ams, bin, "\u22d2", "\\doublecap");
defineSymbol(math, ams, bin, "\u22d3", "\\doublecup");
defineSymbol(math, ams, bin, "\u22a0", "\\boxtimes");

// AMS Arrows
defineSymbol(math, ams, rel, "\u21e2", "\\dashrightarrow");
defineSymbol(math, ams, rel, "\u21e0", "\\dashleftarrow");
defineSymbol(math, ams, rel, "\u21c7", "\\leftleftarrows");
defineSymbol(math, ams, rel, "\u21c6", "\\leftrightarrows");
defineSymbol(math, ams, rel, "\u21da", "\\Lleftarrow");
defineSymbol(math, ams, rel, "\u219e", "\\twoheadleftarrow");
defineSymbol(math, ams, rel, "\u21a2", "\\leftarrowtail");
defineSymbol(math, ams, rel, "\u21ab", "\\looparrowleft");
defineSymbol(math, ams, rel, "\u21cb", "\\leftrightharpoons");
defineSymbol(math, ams, rel, "\u21b6", "\\curvearrowleft");
defineSymbol(math, ams, rel, "\u21ba", "\\circlearrowleft");
defineSymbol(math, ams, rel, "\u21b0", "\\Lsh");
defineSymbol(math, ams, rel, "\u21c8", "\\upuparrows");
defineSymbol(math, ams, rel, "\u21bf", "\\upharpoonleft");
defineSymbol(math, ams, rel, "\u21c3", "\\downharpoonleft");
defineSymbol(math, ams, rel, "\u22b8", "\\multimap");
defineSymbol(math, ams, rel, "\u21ad", "\\leftrightsquigarrow");
defineSymbol(math, ams, rel, "\u21c9", "\\rightrightarrows");
defineSymbol(math, ams, rel, "\u21c4", "\\rightleftarrows");
defineSymbol(math, ams, rel, "\u21a0", "\\twoheadrightarrow");
defineSymbol(math, ams, rel, "\u21a3", "\\rightarrowtail");
defineSymbol(math, ams, rel, "\u21ac", "\\looparrowright");
defineSymbol(math, ams, rel, "\u21b7", "\\curvearrowright");
defineSymbol(math, ams, rel, "\u21bb", "\\circlearrowright");
defineSymbol(math, ams, rel, "\u21b1", "\\Rsh");
defineSymbol(math, ams, rel, "\u21ca", "\\downdownarrows");
defineSymbol(math, ams, rel, "\u21be", "\\upharpoonright");
defineSymbol(math, ams, rel, "\u21c2", "\\downharpoonright");
defineSymbol(math, ams, rel, "\u21dd", "\\rightsquigarrow");
defineSymbol(math, ams, rel, "\u21dd", "\\leadsto");
defineSymbol(math, ams, rel, "\u21db", "\\Rrightarrow");
defineSymbol(math, ams, rel, "\u21be", "\\restriction");

defineSymbol(math, main, textord, "\u2018", "`");
defineSymbol(math, main, textord, "$", "\\$");
defineSymbol(text, main, textord, "$", "\\$");
defineSymbol(math, main, textord, "%", "\\%");
defineSymbol(text, main, textord, "%", "\\%");
defineSymbol(math, main, textord, "_", "\\_");
defineSymbol(text, main, textord, "_", "\\_");
defineSymbol(math, main, textord, "\u2220", "\\angle");
defineSymbol(math, main, textord, "\u221e", "\\infty");
defineSymbol(math, main, textord, "\u2032", "\\prime");
defineSymbol(math, main, textord, "\u25b3", "\\triangle");
defineSymbol(math, main, textord, "\u0393", "\\Gamma");
defineSymbol(math, main, textord, "\u0394", "\\Delta");
defineSymbol(math, main, textord, "\u0398", "\\Theta");
defineSymbol(math, main, textord, "\u039b", "\\Lambda");
defineSymbol(math, main, textord, "\u039e", "\\Xi");
defineSymbol(math, main, textord, "\u03a0", "\\Pi");
defineSymbol(math, main, textord, "\u03a3", "\\Sigma");
defineSymbol(math, main, textord, "\u03a5", "\\Upsilon");
defineSymbol(math, main, textord, "\u03a6", "\\Phi");
defineSymbol(math, main, textord, "\u03a8", "\\Psi");
defineSymbol(math, main, textord, "\u03a9", "\\Omega");
defineSymbol(math, main, textord, "\u00ac", "\\neg");
defineSymbol(math, main, textord, "\u00ac", "\\lnot");
defineSymbol(math, main, textord, "\u22a4", "\\top");
defineSymbol(math, main, textord, "\u22a5", "\\bot");
defineSymbol(math, main, textord, "\u2205", "\\emptyset");
defineSymbol(math, ams, textord, "\u2205", "\\varnothing");
defineSymbol(math, main, mathord, "\u03b1", "\\alpha");
defineSymbol(math, main, mathord, "\u03b2", "\\beta");
defineSymbol(math, main, mathord, "\u03b3", "\\gamma");
defineSymbol(math, main, mathord, "\u03b4", "\\delta");
defineSymbol(math, main, mathord, "\u03f5", "\\epsilon");
defineSymbol(math, main, mathord, "\u03b6", "\\zeta");
defineSymbol(math, main, mathord, "\u03b7", "\\eta");
defineSymbol(math, main, mathord, "\u03b8", "\\theta");
defineSymbol(math, main, mathord, "\u03b9", "\\iota");
defineSymbol(math, main, mathord, "\u03ba", "\\kappa");
defineSymbol(math, main, mathord, "\u03bb", "\\lambda");
defineSymbol(math, main, mathord, "\u03bc", "\\mu");
defineSymbol(math, main, mathord, "\u03bd", "\\nu");
defineSymbol(math, main, mathord, "\u03be", "\\xi");
defineSymbol(math, main, mathord, "o", "\\omicron");
defineSymbol(math, main, mathord, "\u03c0", "\\pi");
defineSymbol(math, main, mathord, "\u03c1", "\\rho");
defineSymbol(math, main, mathord, "\u03c3", "\\sigma");
defineSymbol(math, main, mathord, "\u03c4", "\\tau");
defineSymbol(math, main, mathord, "\u03c5", "\\upsilon");
defineSymbol(math, main, mathord, "\u03d5", "\\phi");
defineSymbol(math, main, mathord, "\u03c7", "\\chi");
defineSymbol(math, main, mathord, "\u03c8", "\\psi");
defineSymbol(math, main, mathord, "\u03c9", "\\omega");
defineSymbol(math, main, mathord, "\u03b5", "\\varepsilon");
defineSymbol(math, main, mathord, "\u03d1", "\\vartheta");
defineSymbol(math, main, mathord, "\u03d6", "\\varpi");
defineSymbol(math, main, mathord, "\u03f1", "\\varrho");
defineSymbol(math, main, mathord, "\u03c2", "\\varsigma");
defineSymbol(math, main, mathord, "\u03c6", "\\varphi");
defineSymbol(math, main, bin, "\u2217", "*");
defineSymbol(math, main, bin, "+", "+");
defineSymbol(math, main, bin, "\u2212", "-");
defineSymbol(math, main, bin, "\u22c5", "\\cdot");
defineSymbol(math, main, bin, "\u2218", "\\circ");
defineSymbol(math, main, bin, "\u00f7", "\\div");
defineSymbol(math, main, bin, "\u00b1", "\\pm");
defineSymbol(math, main, bin, "\u00d7", "\\times");
defineSymbol(math, main, bin, "\u2229", "\\cap");
defineSymbol(math, main, bin, "\u222a", "\\cup");
defineSymbol(math, main, bin, "\u2216", "\\setminus");
defineSymbol(math, main, bin, "\u2227", "\\land");
defineSymbol(math, main, bin, "\u2228", "\\lor");
defineSymbol(math, main, bin, "\u2227", "\\wedge");
defineSymbol(math, main, bin, "\u2228", "\\vee");
defineSymbol(math, main, textord, "\u221a", "\\surd");
defineSymbol(math, main, open, "(", "(");
defineSymbol(math, main, open, "[", "[");
defineSymbol(math, main, open, "\u27e8", "\\langle");
defineSymbol(math, main, open, "\u2223", "\\lvert");
defineSymbol(math, main, open, "\u2225", "\\lVert");
defineSymbol(math, main, close, ")", ")");
defineSymbol(math, main, close, "]", "]");
defineSymbol(math, main, close, "?", "?");
defineSymbol(math, main, close, "!", "!");
defineSymbol(math, main, close, "\u27e9", "\\rangle");
defineSymbol(math, main, close, "\u2223", "\\rvert");
defineSymbol(math, main, close, "\u2225", "\\rVert");
defineSymbol(math, main, rel, "=", "=");
defineSymbol(math, main, rel, "<", "<");
defineSymbol(math, main, rel, ">", ">");
defineSymbol(math, main, rel, ":", ":");
defineSymbol(math, main, rel, "\u2248", "\\approx");
defineSymbol(math, main, rel, "\u2245", "\\cong");
defineSymbol(math, main, rel, "\u2265", "\\ge");
defineSymbol(math, main, rel, "\u2265", "\\geq");
defineSymbol(math, main, rel, "\u2190", "\\gets");
defineSymbol(math, main, rel, ">", "\\gt");
defineSymbol(math, main, rel, "\u2208", "\\in");
defineSymbol(math, main, rel, "\u2209", "\\notin");
defineSymbol(math, main, rel, "\u2282", "\\subset");
defineSymbol(math, main, rel, "\u2283", "\\supset");
defineSymbol(math, main, rel, "\u2286", "\\subseteq");
defineSymbol(math, main, rel, "\u2287", "\\supseteq");
defineSymbol(math, ams, rel, "\u2288", "\\nsubseteq");
defineSymbol(math, ams, rel, "\u2289", "\\nsupseteq");
defineSymbol(math, main, rel, "\u22a8", "\\models");
defineSymbol(math, main, rel, "\u2190", "\\leftarrow");
defineSymbol(math, main, rel, "\u2264", "\\le");
defineSymbol(math, main, rel, "\u2264", "\\leq");
defineSymbol(math, main, rel, "<", "\\lt");
defineSymbol(math, main, rel, "\u2260", "\\ne");
defineSymbol(math, main, rel, "\u2260", "\\neq");
defineSymbol(math, main, rel, "\u2192", "\\rightarrow");
defineSymbol(math, main, rel, "\u2192", "\\to");
defineSymbol(math, ams, rel, "\u2271", "\\ngeq");
defineSymbol(math, ams, rel, "\u2270", "\\nleq");
defineSymbol(math, main, spacing, null, "\\!");
defineSymbol(math, main, spacing, "\u00a0", "\\ ");
defineSymbol(math, main, spacing, "\u00a0", "~");
defineSymbol(math, main, spacing, null, "\\,");
defineSymbol(math, main, spacing, null, "\\:");
defineSymbol(math, main, spacing, null, "\\;");
defineSymbol(math, main, spacing, null, "\\enspace");
defineSymbol(math, main, spacing, null, "\\qquad");
defineSymbol(math, main, spacing, null, "\\quad");
defineSymbol(math, main, spacing, "\u00a0", "\\space");
defineSymbol(math, main, punct, ",", ",");
defineSymbol(math, main, punct, ";", ";");
defineSymbol(math, main, punct, ":", "\\colon");
defineSymbol(math, ams, bin, "\u22bc", "\\barwedge");
defineSymbol(math, ams, bin, "\u22bb", "\\veebar");
defineSymbol(math, main, bin, "\u2299", "\\odot");
defineSymbol(math, main, bin, "\u2295", "\\oplus");
defineSymbol(math, main, bin, "\u2297", "\\otimes");
defineSymbol(math, main, textord, "\u2202", "\\partial");
defineSymbol(math, main, bin, "\u2298", "\\oslash");
defineSymbol(math, ams, bin, "\u229a", "\\circledcirc");
defineSymbol(math, ams, bin, "\u22a1", "\\boxdot");
defineSymbol(math, main, bin, "\u25b3", "\\bigtriangleup");
defineSymbol(math, main, bin, "\u25bd", "\\bigtriangledown");
defineSymbol(math, main, bin, "\u2020", "\\dagger");
defineSymbol(math, main, bin, "\u22c4", "\\diamond");
defineSymbol(math, main, bin, "\u22c6", "\\star");
defineSymbol(math, main, bin, "\u25c3", "\\triangleleft");
defineSymbol(math, main, bin, "\u25b9", "\\triangleright");
defineSymbol(math, main, open, "{", "\\{");
defineSymbol(text, main, textord, "{", "\\{");
defineSymbol(math, main, close, "}", "\\}");
defineSymbol(text, main, textord, "}", "\\}");
defineSymbol(math, main, open, "{", "\\lbrace");
defineSymbol(math, main, close, "}", "\\rbrace");
defineSymbol(math, main, open, "[", "\\lbrack");
defineSymbol(math, main, close, "]", "\\rbrack");
defineSymbol(math, main, open, "\u230a", "\\lfloor");
defineSymbol(math, main, close, "\u230b", "\\rfloor");
defineSymbol(math, main, open, "\u2308", "\\lceil");
defineSymbol(math, main, close, "\u2309", "\\rceil");
defineSymbol(math, main, textord, "\\", "\\backslash");
defineSymbol(math, main, textord, "\u2223", "|");
defineSymbol(math, main, textord, "\u2223", "\\vert");
defineSymbol(math, main, textord, "\u2225", "\\|");
defineSymbol(math, main, textord, "\u2225", "\\Vert");
defineSymbol(math, main, rel, "\u2191", "\\uparrow");
defineSymbol(math, main, rel, "\u21d1", "\\Uparrow");
defineSymbol(math, main, rel, "\u2193", "\\downarrow");
defineSymbol(math, main, rel, "\u21d3", "\\Downarrow");
defineSymbol(math, main, rel, "\u2195", "\\updownarrow");
defineSymbol(math, main, rel, "\u21d5", "\\Updownarrow");
defineSymbol(math, math, op, "\u2210", "\\coprod");
defineSymbol(math, math, op, "\u22c1", "\\bigvee");
defineSymbol(math, math, op, "\u22c0", "\\bigwedge");
defineSymbol(math, math, op, "\u2a04", "\\biguplus");
defineSymbol(math, math, op, "\u22c2", "\\bigcap");
defineSymbol(math, math, op, "\u22c3", "\\bigcup");
defineSymbol(math, math, op, "\u222b", "\\int");
defineSymbol(math, math, op, "\u222b", "\\intop");
defineSymbol(math, math, op, "\u222c", "\\iint");
defineSymbol(math, math, op, "\u222d", "\\iiint");
defineSymbol(math, math, op, "\u220f", "\\prod");
defineSymbol(math, math, op, "\u2211", "\\sum");
defineSymbol(math, math, op, "\u2a02", "\\bigotimes");
defineSymbol(math, math, op, "\u2a01", "\\bigoplus");
defineSymbol(math, math, op, "\u2a00", "\\bigodot");
defineSymbol(math, math, op, "\u222e", "\\oint");
defineSymbol(math, math, op, "\u2a06", "\\bigsqcup");
defineSymbol(math, math, op, "\u222b", "\\smallint");
defineSymbol(text, main, inner, "\u2026", "\\textellipsis");
defineSymbol(math, main, inner, "\u2026", "\\mathellipsis");
defineSymbol(text, main, inner, "\u2026", "\\ldots");
defineSymbol(math, main, inner, "\u2026", "\\ldots");
defineSymbol(math, main, inner, "\u22ef", "\\cdots");
defineSymbol(math, main, inner, "\u22f1", "\\ddots");
defineSymbol(math, main, textord, "\u22ee", "\\vdots");
defineSymbol(math, main, accent, "\u00b4", "\\acute");
defineSymbol(math, main, accent, "\u0060", "\\grave");
defineSymbol(math, main, accent, "\u00a8", "\\ddot");
defineSymbol(math, main, accent, "\u007e", "\\tilde");
defineSymbol(math, main, accent, "\u00af", "\\bar");
defineSymbol(math, main, accent, "\u02d8", "\\breve");
defineSymbol(math, main, accent, "\u02c7", "\\check");
defineSymbol(math, main, accent, "\u005e", "\\hat");
defineSymbol(math, main, accent, "\u20d7", "\\vec");
defineSymbol(math, main, accent, "\u02d9", "\\dot");
defineSymbol(math, main, mathord, "\u0131", "\\imath");
defineSymbol(math, main, mathord, "\u0237", "\\jmath");

defineSymbol(text, main, textord, "\u2013", "--");
defineSymbol(text, main, textord, "\u2014", "---");
defineSymbol(text, main, textord, "\u2018", "`");
defineSymbol(text, main, textord, "\u2019", "'");
defineSymbol(text, main, textord, "\u201c", "``");
defineSymbol(text, main, textord, "\u201d", "''");
defineSymbol(math, main, textord, "\u00b0", "\\degree");
defineSymbol(text, main, textord, "\u00b0", "\\degree");
defineSymbol(math, main, mathord, "\u00a3", "\\pounds");
defineSymbol(math, ams, textord, "\u2720", "\\maltese");
defineSymbol(text, ams, textord, "\u2720", "\\maltese");

defineSymbol(text, main, spacing, "\u00a0", "\\ ");
defineSymbol(text, main, spacing, "\u00a0", " ");
defineSymbol(text, main, spacing, "\u00a0", "~");

// There are lots of symbols which are the same, so we add them in afterwards.
var i;
var ch;

// All of these are textords in math mode
var mathTextSymbols = "0123456789/@.\"";
for (i = 0; i < mathTextSymbols.length; i++) {
    ch = mathTextSymbols.charAt(i);
    defineSymbol(math, main, textord, ch, ch);
}

// All of these are textords in text mode
var textSymbols = "0123456789!@*()-=+[]\";:?/.,";
for (i = 0; i < textSymbols.length; i++) {
    ch = textSymbols.charAt(i);
    defineSymbol(text, main, textord, ch, ch);
}

// All of these are textords in text mode, and mathords in math mode
var letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
for (i = 0; i < letters.length; i++) {
    ch = letters.charAt(i);
    defineSymbol(math, main, mathord, ch, ch);
    defineSymbol(text, main, textord, ch, ch);
}

// Latin-1 letters
for (i = 0x00C0; i <= 0x00D6; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

for (i = 0x00D8; i <= 0x00F6; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

for (i = 0x00F8; i <= 0x00FF; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

// Cyrillic
for (i = 0x0410; i <= 0x044F; i++) {
    ch = String.fromCharCode(i);
    defineSymbol(text, main, textord, ch, ch);
}

// Unicode versions of existing characters
defineSymbol(text, main, textord, "\u2013", "");
defineSymbol(text, main, textord, "\u2014", "");
defineSymbol(text, main, textord, "\u2018", "");
defineSymbol(text, main, textord, "\u2019", "");
defineSymbol(text, main, textord, "\u201c", "");
defineSymbol(text, main, textord, "\u201d", "");

},{}],103:[function(require,module,exports){
var hangulRegex = /[\uAC00-\uD7AF]/;

// This regex combines
// - Hiragana: [\u3040-\u309F]
// - Katakana: [\u30A0-\u30FF]
// - CJK ideograms: [\u4E00-\u9FAF]
// - Hangul syllables: [\uAC00-\uD7AF]
// Notably missing are halfwidth Katakana and Romanji glyphs.
var cjkRegex =
    /[\u3040-\u309F]|[\u30A0-\u30FF]|[\u4E00-\u9FAF]|[\uAC00-\uD7AF]/;

module.exports = {
    cjkRegex: cjkRegex,
    hangulRegex: hangulRegex
};

},{}],104:[function(require,module,exports){
/**
 * This file contains a list of utility functions which are useful in other
 * files.
 */

/**
 * Provide an `indexOf` function which works in IE8, but defers to native if
 * possible.
 */
var nativeIndexOf = Array.prototype.indexOf;
var indexOf = function(list, elem) {
    if (list == null) {
        return -1;
    }
    if (nativeIndexOf && list.indexOf === nativeIndexOf) {
        return list.indexOf(elem);
    }
    var i = 0;
    var l = list.length;
    for (; i < l; i++) {
        if (list[i] === elem) {
            return i;
        }
    }
    return -1;
};

/**
 * Return whether an element is contained in a list
 */
var contains = function(list, elem) {
    return indexOf(list, elem) !== -1;
};

/**
 * Provide a default value if a setting is undefined
 */
var deflt = function(setting, defaultIfUndefined) {
    return setting === undefined ? defaultIfUndefined : setting;
};

// hyphenate and escape adapted from Facebook's React under Apache 2 license

var uppercase = /([A-Z])/g;
var hyphenate = function(str) {
    return str.replace(uppercase, "-$1").toLowerCase();
};

var ESCAPE_LOOKUP = {
    "&": "&amp;",
    ">": "&gt;",
    "<": "&lt;",
    "\"": "&quot;",
    "'": "&#x27;"
};

var ESCAPE_REGEX = /[&><"']/g;

function escaper(match) {
    return ESCAPE_LOOKUP[match];
}

/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escape(text) {
    return ("" + text).replace(ESCAPE_REGEX, escaper);
}

/**
 * A function to set the text content of a DOM element in all supported
 * browsers. Note that we don't define this if there is no document.
 */
var setTextContent;
if (typeof document !== "undefined") {
    var testNode = document.createElement("span");
    if ("textContent" in testNode) {
        setTextContent = function(node, text) {
            node.textContent = text;
        };
    } else {
        setTextContent = function(node, text) {
            node.innerText = text;
        };
    }
}

/**
 * A function to clear a node.
 */
function clearNode(node) {
    setTextContent(node, "");
}

module.exports = {
    contains: contains,
    deflt: deflt,
    escape: escape,
    hyphenate: hyphenate,
    indexOf: indexOf,
    setTextContent: setTextContent,
    clearNode: clearNode
};

},{}],105:[function(require,module,exports){
/** @flow */

"use strict";

function getRelocatable(re) {
  // In the future, this could use a WeakMap instead of an expando.
  if (!re.__matchAtRelocatable) {
    // Disjunctions are the lowest-precedence operator, so we can make any
    // pattern match the empty string by appending `|()` to it:
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-patterns
    var source = re.source + "|()";

    // We always make the new regex global.
    var flags = "g" + (re.ignoreCase ? "i" : "") + (re.multiline ? "m" : "") + (re.unicode ? "u" : "")
    // sticky (/.../y) doesn't make sense in conjunction with our relocation
    // logic, so we ignore it here.
    ;

    re.__matchAtRelocatable = new RegExp(source, flags);
  }
  return re.__matchAtRelocatable;
}

function matchAt(re, str, pos) {
  if (re.global || re.sticky) {
    throw new Error("matchAt(...): Only non-global regexes are supported");
  }
  var reloc = getRelocatable(re);
  reloc.lastIndex = pos;
  var match = reloc.exec(str);
  // Last capturing group is our sentinel that indicates whether the regex
  // matched at the given location.
  if (match[match.length - 1] == null) {
    // Original regex matched.
    match.length = match.length - 1;
    return match;
  } else {
    return null;
  }
}

module.exports = matchAt;
},{}],106:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber);
exports.InnerSubscriber = InnerSubscriber;


},{"./Subscriber":113}],107:[function(require,module,exports){
"use strict";

var root_1 = require('./util/root');
var toSubscriber_1 = require('./util/toSubscriber');
var observable_1 = require('./symbol/observable');
/**
 * A representation of any set of values over any amount of time. This the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is  called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        } else {
            sink.add(this._trySubscribe(sink));
        }
        if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
                throw sink.syncErrorValue;
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        } catch (err) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, PromiseCtor) {
        var _this = this;
        if (!PromiseCtor) {
            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
                PromiseCtor = root_1.root.Rx.config.Promise;
            } else if (root_1.root.Promise) {
                PromiseCtor = root_1.root.Promise;
            }
        }
        if (!PromiseCtor) {
            throw new Error('no Promise impl found');
        }
        return new PromiseCtor(function (resolve, reject) {
            var subscription = _this.subscribe(function (value) {
                if (subscription) {
                    // if there is a subscription, then we can surmise
                    // the next handling is asynchronous. Any errors thrown
                    // need to be rejected explicitly and unsubscribe must be
                    // called manually
                    try {
                        next(value);
                    } catch (err) {
                        reject(err);
                        subscription.unsubscribe();
                    }
                } else {
                    // if there is NO subscription, then we're getting a nexted
                    // value synchronously during subscription. We can just call it.
                    // If it errors, Observable's `subscribe` will ensure the
                    // unsubscription logic is called, then synchronously rethrow the error.
                    // After that, Promise will trap the error and send it
                    // down the rejection path.
                    next(value);
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        return this.source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable_1.$$observable] = function () {
        return this;
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}();
exports.Observable = Observable;


},{"./symbol/observable":147,"./util/root":160,"./util/toSubscriber":162}],108:[function(require,module,exports){
"use strict";

exports.empty = {
    closed: true,
    next: function (value) {},
    error: function (err) {
        throw err;
    },
    complete: function () {}
};


},{}],109:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber);
exports.OuterSubscriber = OuterSubscriber;


},{"./Subscriber":113}],110:[function(require,module,exports){
"use strict";
/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 */

var Scheduler = function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = Date.now ? Date.now : function () {
        return +new Date();
    };
    return Scheduler;
}();
exports.Scheduler = Scheduler;


},{}],111:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber);
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        } else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable);
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        } else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject);
exports.AnonymousSubject = AnonymousSubject;


},{"./Observable":107,"./SubjectSubscription":112,"./Subscriber":113,"./Subscription":114,"./symbol/rxSubscriber":148,"./util/ObjectUnsubscribedError":149}],112:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription);
exports.SubjectSubscription = SubjectSubscription;


},{"./Subscription":114}],113:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    } else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return this;
    };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription);
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        } else if (observerOrNext) {
            context = observerOrNext;
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (isFunction_1.isFunction(context.unsubscribe)) {
                this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            } else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            } else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._complete);
                    this.unsubscribe();
                }
            } else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber);


},{"./Observer":108,"./Subscription":114,"./symbol/rxSubscriber":148,"./util/isFunction":155}],114:[function(require,module,exports){
"use strict";

var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents,
            _unsubscribe = _a._unsubscribe,
            _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        } else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || teardown === Subscription.EMPTY) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                } else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                } else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        } else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        } else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription());
    return Subscription;
}();
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) {
        return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
    }, []);
}


},{"./util/UnsubscriptionError":150,"./util/errorObject":151,"./util/isArray":152,"./util/isFunction":155,"./util/isObject":157,"./util/tryCatch":163}],115:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var ScalarObservable_1 = require('./ScalarObservable');
var EmptyObservable_1 = require('./EmptyObservable');
var isScheduler_1 = require('../util/isScheduler');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        } else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        } else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        } else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array,
            index = state.index,
            count = state.count,
            subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable);
exports.ArrayObservable = ArrayObservable;


},{"../Observable":107,"../util/isScheduler":159,"./EmptyObservable":117,"./ScalarObservable":119}],116:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('../Subject');
var Observable_1 = require('../Observable');
var Subscriber_1 = require('../Subscriber');
var Subscription_1 = require('../Subscription');
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            } else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return this.lift(new RefCountOperator(this));
    };
    return ConnectableObservable;
}(Observable_1.Observable);
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subscribe: { value: ConnectableObservable.prototype._subscribe },
    getSubject: { value: ConnectableObservable.prototype.getSubject },
    connect: { value: ConnectableObservable.prototype.connect },
    refCount: { value: ConnectableObservable.prototype.refCount }
};
var ConnectableSubscriber = function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber);
var RefCountOperator = function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}();
var RefCountSubscriber = function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber);


},{"../Observable":107,"../Subject":111,"../Subscriber":113,"../Subscription":114}],117:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        } else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable);
exports.EmptyObservable = EmptyObservable;


},{"../Observable":107}],118:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var tryCatch_1 = require('../util/tryCatch');
var isFunction_1 = require('../util/isFunction');
var errorObject_1 = require('../util/errorObject');
var Subscription_1 = require('../Subscription');
var toString = Object.prototype.toString;
function isNodeStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isNodeList(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
}
function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
}
function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventObservable = function (_super) {
    __extends(FromEventObservable, _super);
    function FromEventObservable(sourceObj, eventName, selector, options) {
        _super.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
        this.options = options;
    }
    /* tslint:enable:max-line-length */
    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * Creates an Observable by attaching an event listener to an "event target",
     * which may be an object with `addEventListener` and `removeEventListener`,
     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
     * the output Observable is subscribed, and removed when the Subscription is
     * unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console everytime a click
     * // occurs on the document.
     *
     * @see {@link from}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOMElement, event target, Node.js
     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @param {SelectorMethodSignature<T>} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    FromEventObservable.create = function (target, eventName, options, selector) {
        if (isFunction_1.isFunction(options)) {
            selector = options;
            options = undefined;
        }
        return new FromEventObservable(target, eventName, selector, options);
    };
    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        } else if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function () {
                return source_1.removeEventListener(eventName, handler);
            };
        } else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function () {
                return source_2.off(eventName, handler);
            };
        } else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function () {
                return source_3.removeListener(eventName, handler);
            };
        } else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(new Subscription_1.Subscription(unsubscribe));
    };
    FromEventObservable.prototype._subscribe = function (subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var options = this.options;
        var selector = this.selector;
        var handler = selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
            if (result === errorObject_1.errorObject) {
                subscriber.error(errorObject_1.errorObject.e);
            } else {
                subscriber.next(result);
            }
        } : function (e) {
            return subscriber.next(e);
        };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
    };
    return FromEventObservable;
}(Observable_1.Observable);
exports.FromEventObservable = FromEventObservable;


},{"../Observable":107,"../Subscription":114,"../util/errorObject":151,"../util/isFunction":155,"../util/tryCatch":163}],119:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done,
            value = state.value,
            subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        } else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable);
exports.ScalarObservable = ScalarObservable;


},{"../Observable":107}],120:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = require('../util/isNumeric');
var Observable_1 = require('../Observable');
var async_1 = require('../scheduler/async');
var isScheduler_1 = require('../util/isScheduler');
var isDate_1 = require('../util/isDate');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = function (_super) {
    __extends(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) {
            dueTime = 0;
        }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        } else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ? +dueTime - this.scheduler.now() : dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) {
            initialDelay = 0;
        }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index,
            period = state.period,
            subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        } else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            period = _a.period,
            dueTime = _a.dueTime,
            scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable);
exports.TimerObservable = TimerObservable;


},{"../Observable":107,"../scheduler/async":145,"../util/isDate":154,"../util/isNumeric":156,"../util/isScheduler":159}],121:[function(require,module,exports){
"use strict";

var EmptyObservable_1 = require('./EmptyObservable');
exports.empty = EmptyObservable_1.EmptyObservable.create;


},{"./EmptyObservable":117}],122:[function(require,module,exports){
"use strict";

var FromEventObservable_1 = require('./FromEventObservable');
exports.fromEvent = FromEventObservable_1.FromEventObservable.create;


},{"./FromEventObservable":118}],123:[function(require,module,exports){
"use strict";

var ArrayObservable_1 = require('./ArrayObservable');
exports.of = ArrayObservable_1.ArrayObservable.of;


},{"./ArrayObservable":115}],124:[function(require,module,exports){
"use strict";

var TimerObservable_1 = require('./TimerObservable');
exports.timer = TimerObservable_1.TimerObservable.create;


},{"./TimerObservable":120}],125:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @name catch
 * @owner Observable
 */
function _catch(selector) {
    var operator = new CatchOperator(selector);
    var caught = this.lift(operator);
    return operator.caught = caught;
}
exports._catch = _catch;
var CatchOperator = function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            } catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":109,"../util/subscribeToResult":161}],126:[function(require,module,exports){
"use strict";

var Observable_1 = require('../Observable');
var isScheduler_1 = require('../util/isScheduler');
var ArrayObservable_1 = require('../observable/ArrayObservable');
var mergeAll_1 = require('./mergeAll');
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from every
 * given input Observable after the current Observable.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * Joins this Observable with multiple other Observables by subscribing to them
 * one at a time, starting with the source, and merging their results into the
 * output Observable. Will wait for each Observable to complete before moving
 * on to the next.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = timer.concat(sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 * @example <caption>Concatenate 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = timer1.concat(timer2, timer3);
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} other An input Observable to concatenate after the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @method concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));
}
exports.concat = concat;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from given
 * Observable and then moves on to the next.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * `concat` joins multiple Observables together, by subscribing to them one at a time and
 * merging their results into the output Observable. You can pass either an array of
 * Observables, or put them directly as arguments. Passing an empty array will result
 * in Observable that completes immediately.
 *
 * `concat` will subscribe to first input Observable and emit all its values, without
 * changing or affecting them in any way. When that Observable completes, it will
 * subscribe to then next Observable passed and, again, emit its values. This will be
 * repeated, until the operator runs out of Observables. When last input Observable completes,
 * `concat` will complete as well. At any given moment only one Observable passed to operator
 * emits values. If you would like to emit values from passed Observables concurrently, check out
 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
 *
 * Note that if some input Observable never completes, `concat` will also never complete
 * and Observables following the one that did not complete will never be subscribed. On the other
 * hand, if some Observable simply completes immediately after it is subscribed, it will be
 * invisible for `concat`, which will just move on to the next Observable.
 *
 * If any Observable in chain errors, instead of passing control to the next Observable,
 * `concat` will error immediately as well. Observables that would be subscribed after
 * the one that emitted error, never will.
 *
 * If you pass to `concat` the same Observable many times, its stream of values
 * will be "replayed" on every subscription, which means you can repeat given Observable
 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
 * you can always use {@link repeat}.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 *
 * @example <caption>Concatenate an array of 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 *
 * @example <caption>Concatenate the same Observable to repeat it</caption>
 * const timer = Rx.Observable.interval(1000).take(2);
 *
 * Rx.Observable.concat(timer, timer) // concating the same Observable!
 * .subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('...and it is done!')
 * );
 *
 * // Logs:
 * // 0 after 1s
 * // 1 after 2s
 * // 0 after 3s
 * // 1 after 4s
 * // "...and it is done!" also after 4s
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} input1 An input Observable to concatenate with others.
 * @param {ObservableInput} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */
function concatStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var scheduler = null;
    var args = observables;
    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
        scheduler = args.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
}
exports.concatStatic = concatStatic;


},{"../Observable":107,"../observable/ArrayObservable":115,"../util/isScheduler":159,"./mergeAll":133}],127:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var async_1 = require('../scheduler/async');
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber);
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}


},{"../Subscriber":113,"../scheduler/async":145}],128:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
function _do(nextOrObserver, error, complete) {
    return this.lift(new DoOperator(nextOrObserver, error, complete));
}
exports._do = _do;
var DoOperator = function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":113}],129:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable only if the previous projected Observable has completed.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link exhaust}.</span>
 *
 * <img src="./img/exhaustMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. When it projects a source value to
 * an Observable, the output Observable begins emitting the items emitted by
 * that projected Observable. However, `exhaustMap` ignores every new projected
 * Observable if the previous projected Observable has not yet completed. Once
 * that one completes, it will accept and flatten the next projected Observable
 * and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaust}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable containing projected Observables
 * of each item of the source, ignoring projected Observables that start before
 * their preceding Observable has completed.
 * @method exhaustMap
 * @owner Observable
 */
function exhaustMap(project, resultSelector) {
    return this.lift(new SwitchFirstMapOperator(project, resultSelector));
}
exports.exhaustMap = exhaustMap;
var SwitchFirstMapOperator = function () {
    function SwitchFirstMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchFirstMapOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstMapSubscriber = function (_super) {
    __extends(SwitchFirstMapSubscriber, _super);
    function SwitchFirstMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.hasSubscription = false;
        this.hasCompleted = false;
        this.index = 0;
    }
    SwitchFirstMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
        var index = this.index++;
        var destination = this.destination;
        try {
            var result = this.project(value, index);
            this.hasSubscription = true;
            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
        } catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        if (resultSelector) {
            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            destination.next(innerValue);
        }
    };
    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
        var _a = this,
            resultSelector = _a.resultSelector,
            destination = _a.destination;
        try {
            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
            destination.next(result);
        } catch (err) {
            destination.error(err);
        }
    };
    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":109,"../util/subscribeToResult":161}],130:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return this.lift(new FilterOperator(predicate, thisArg));
}
exports.filter = filter;
var FilterOperator = function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
        this.predicate = predicate;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":113}],131:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var Subscription_1 = require('../Subscription');
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */
function _finally(callback) {
    return this.lift(new FinallyOperator(callback));
}
exports._finally = _finally;
var FinallyOperator = function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        _super.call(this, destination);
        this.add(new Subscription_1.Subscription(callback));
    }
    return FinallySubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":113,"../Subscription":114}],132:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return this.lift(new MapOperator(project, thisArg));
}
exports.map = map;
var MapOperator = function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}();
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":113}],133:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return this.lift(new MergeAllOperator(concurrent));
}
exports.mergeAll = mergeAll;
var MergeAllOperator = function () {
    function MergeAllOperator(concurrent) {
        this.concurrent = concurrent;
    }
    MergeAllOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
    };
    return MergeAllOperator;
}();
exports.MergeAllOperator = MergeAllOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeAllSubscriber = function (_super) {
    __extends(MergeAllSubscriber, _super);
    function MergeAllSubscriber(destination, concurrent) {
        _super.call(this, destination);
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
    }
    MergeAllSubscriber.prototype._next = function (observable) {
        if (this.active < this.concurrent) {
            this.active++;
            this.add(subscribeToResult_1.subscribeToResult(this, observable));
        } else {
            this.buffer.push(observable);
        }
    };
    MergeAllSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeAllSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeAllSubscriber = MergeAllSubscriber;


},{"../OuterSubscriber":109,"../util/subscribeToResult":161}],134:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var subscribeToResult_1 = require('../util/subscribeToResult');
var OuterSubscriber_1 = require('../OuterSubscriber');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
        resultSelector = null;
    }
    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
}
exports.mergeMap = mergeMap;
var MergeMapOperator = function () {
    function MergeMapOperator(project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
    };
    return MergeMapOperator;
}();
exports.MergeMapOperator = MergeMapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        } else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeMapSubscriber = MergeMapSubscriber;


},{"../OuterSubscriber":109,"../util/subscribeToResult":161}],135:[function(require,module,exports){
"use strict";

var ConnectableObservable_1 = require('../observable/ConnectableObservable');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} An Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */
function multicast(subjectOrSubjectFactory, selector) {
    var subjectFactory;
    if (typeof subjectOrSubjectFactory === 'function') {
        subjectFactory = subjectOrSubjectFactory;
    } else {
        subjectFactory = function subjectFactory() {
            return subjectOrSubjectFactory;
        };
    }
    if (typeof selector === 'function') {
        return this.lift(new MulticastOperator(subjectFactory, selector));
    }
    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);
    connectable.source = this;
    connectable.subjectFactory = subjectFactory;
    return connectable;
}
exports.multicast = multicast;
var MulticastOperator = function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}();
exports.MulticastOperator = MulticastOperator;


},{"../observable/ConnectableObservable":116}],136:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */
function pairwise() {
    return this.lift(new PairwiseOperator());
}
exports.pairwise = pairwise;
var PairwiseOperator = function () {
    function PairwiseOperator() {}
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        _super.call(this, destination);
        this.hasPrev = false;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        } else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":113}],137:[function(require,module,exports){
"use strict";

var multicast_1 = require('./multicast');
var Subject_1 = require('../Subject');
function shareSubjectFactory() {
    return new Subject_1.Subject();
}
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .publish().refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */
function share() {
    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();
}
exports.share = share;
;


},{"../Subject":111,"./multicast":135}],138:[function(require,module,exports){
"use strict";

var ArrayObservable_1 = require('../observable/ArrayObservable');
var ScalarObservable_1 = require('../observable/ScalarObservable');
var EmptyObservable_1 = require('../observable/EmptyObservable');
var concat_1 = require('./concat');
var isScheduler_1 = require('../util/isScheduler');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i - 0] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        array.pop();
    } else {
        scheduler = null;
    }
    var len = array.length;
    if (len === 1) {
        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
    } else if (len > 1) {
        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
    } else {
        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
    }
}
exports.startWith = startWith;


},{"../observable/ArrayObservable":115,"../observable/EmptyObservable":117,"../observable/ScalarObservable":119,"../util/isScheduler":159,"./concat":126}],139:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return this.lift(new SwitchMapOperator(project, resultSelector));
}
exports.switchMap = switchMap;
var SwitchMapOperator = function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":109,"../util/subscribeToResult":161}],140:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return this.lift(new TakeUntilOperator(notifier));
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":109,"../util/subscribeToResult":161}],141:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = require('../observable/ArrayObservable');
var isArray_1 = require('../util/isArray');
var Subscriber_1 = require('../Subscriber');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
var iterator_1 = require('../symbol/iterator');
/* tslint:enable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
function zipProto() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));
}
exports.zipProto = zipProto;
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the latest parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * @example <caption>Combine age and name from different sources</caption>
 *
 * let age$ = Observable.of<number>(27, 25, 29);
 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
 * let isDev$ = Observable.of<boolean>(true, true, false);
 *
 * Observable
 *     .zip(age$,
 *          name$,
 *          isDev$,
 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
 *     .subscribe(x => console.log(x));
 *
 * // outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 *
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */
function zipStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}
exports.zipStatic = zipStatic;
var ZipOperator = function () {
    function ZipOperator(project) {
        this.project = project;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.project));
    };
    return ZipOperator;
}();
exports.ZipOperator = ZipOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = typeof project === 'function' ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[iterator_1.$$iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.$$iterator]()));
        } else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                this.add(iterator.subscribe(iterator, i));
            } else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        } else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber);
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}();
var StaticArrayIterator = function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.$$iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator_1.$$iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        } else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        } else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":109,"../Subscriber":113,"../observable/ArrayObservable":115,"../symbol/iterator":146,"../util/isArray":152,"../util/subscribeToResult":161}],142:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('../Subscription');
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription_1.Subscription);
exports.Action = Action;


},{"../Subscription":114}],143:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Action_1 = require('./Action');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        } else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        } catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.delay = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
    };
    return AsyncAction;
}(Action_1.Action);
exports.AsyncAction = AsyncAction;


},{"../util/root":160,"./Action":142}],144:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = require('../Scheduler');
var AsyncScheduler = function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler);
exports.AsyncScheduler = AsyncScheduler;


},{"../Scheduler":110}],145:[function(require,module,exports){
"use strict";

var AsyncAction_1 = require('./AsyncAction');
var AsyncScheduler_1 = require('./AsyncScheduler');
/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);


},{"./AsyncAction":143,"./AsyncScheduler":144}],146:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function symbolIteratorPonyfill(root) {
    var Symbol = root.Symbol;
    if (typeof Symbol === 'function') {
        if (!Symbol.iterator) {
            Symbol.iterator = Symbol('iterator polyfill');
        }
        return Symbol.iterator;
    } else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.$$iterator = symbolIteratorPonyfill(root_1.root);


},{"../util/root":160}],147:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function getSymbolObservable(context) {
    var $$observable;
    var Symbol = context.Symbol;
    if (typeof Symbol === 'function') {
        if (Symbol.observable) {
            $$observable = Symbol.observable;
        } else {
            $$observable = Symbol('observable');
            Symbol.observable = $$observable;
        }
    } else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.$$observable = getSymbolObservable(root_1.root);


},{"../util/root":160}],148:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
var Symbol = root_1.root.Symbol;
exports.$$rxSubscriber = typeof Symbol === 'function' && typeof Symbol.for === 'function' ? Symbol.for('rxSubscriber') : '@@rxSubscriber';


},{"../util/root":160}],149:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error);
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;


},{}],150:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) {
            return i + 1 + ") " + err.toString();
        }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error);
exports.UnsubscriptionError = UnsubscriptionError;


},{}],151:[function(require,module,exports){
"use strict";
// typeof any so that it we don't have to cast when comparing a result to the error object

exports.errorObject = { e: {} };


},{}],152:[function(require,module,exports){
"use strict";

exports.isArray = Array.isArray || function (x) {
  return x && typeof x.length === 'number';
};


},{}],153:[function(require,module,exports){
"use strict";

exports.isArrayLike = function (x) {
  return x && typeof x.length === 'number';
};


},{}],154:[function(require,module,exports){
"use strict";

function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
exports.isDate = isDate;


},{}],155:[function(require,module,exports){
"use strict";

function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;


},{}],156:[function(require,module,exports){
"use strict";

var isArray_1 = require('../util/isArray');
function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray_1.isArray(val) && val - parseFloat(val) + 1 >= 0;
}
exports.isNumeric = isNumeric;
;


},{"../util/isArray":152}],157:[function(require,module,exports){
"use strict";

function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;


},{}],158:[function(require,module,exports){
"use strict";

function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;


},{}],159:[function(require,module,exports){
"use strict";

function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;


},{}],160:[function(require,module,exports){
(function (global){
"use strict";
/**
 * window: browser in DOM main thread
 * self: browser in WebWorker
 * global: Node.js/other
 */

exports.root = typeof window == 'object' && window.window === window && window || typeof self == 'object' && self.self === self && self || typeof global == 'object' && global.global === global && global;
if (!exports.root) {
    throw new Error('RxJS could not find any global context (window, self, global)');
}


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],161:[function(require,module,exports){
"use strict";

var root_1 = require('./root');
var isArrayLike_1 = require('./isArrayLike');
var isPromise_1 = require('./isPromise');
var isObject_1 = require('./isObject');
var Observable_1 = require('../Observable');
var iterator_1 = require('../symbol/iterator');
var InnerSubscriber_1 = require('../InnerSubscriber');
var observable_1 = require('../symbol/observable');
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    if (destination.closed) {
        return null;
    }
    if (result instanceof Observable_1.Observable) {
        if (result._isScalar) {
            destination.next(result.value);
            destination.complete();
            return null;
        } else {
            return result.subscribe(destination);
        }
    } else if (isArrayLike_1.isArrayLike(result)) {
        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
            destination.next(result[i]);
        }
        if (!destination.closed) {
            destination.complete();
        }
    } else if (isPromise_1.isPromise(result)) {
        result.then(function (value) {
            if (!destination.closed) {
                destination.next(value);
                destination.complete();
            }
        }, function (err) {
            return destination.error(err);
        }).then(null, function (err) {
            // Escaping the Promise trap: globally throw unhandled errors
            root_1.root.setTimeout(function () {
                throw err;
            });
        });
        return destination;
    } else if (result && typeof result[iterator_1.$$iterator] === 'function') {
        var iterator = result[iterator_1.$$iterator]();
        do {
            var item = iterator.next();
            if (item.done) {
                destination.complete();
                break;
            }
            destination.next(item.value);
            if (destination.closed) {
                break;
            }
        } while (true);
    } else if (result && typeof result[observable_1.$$observable] === 'function') {
        var obs = result[observable_1.$$observable]();
        if (typeof obs.subscribe !== 'function') {
            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
        } else {
            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
        }
    } else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
        destination.error(new TypeError(msg));
    }
    return null;
}
exports.subscribeToResult = subscribeToResult;


},{"../InnerSubscriber":106,"../Observable":107,"../symbol/iterator":146,"../symbol/observable":147,"./isArrayLike":153,"./isObject":157,"./isPromise":158,"./root":160}],162:[function(require,module,exports){
"use strict";

var Subscriber_1 = require('../Subscriber');
var rxSubscriber_1 = require('../symbol/rxSubscriber');
var Observer_1 = require('../Observer');
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber_1.$$rxSubscriber]) {
            return nextOrObserver[rxSubscriber_1.$$rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer_1.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;


},{"../Observer":108,"../Subscriber":113,"../symbol/rxSubscriber":148}],163:[function(require,module,exports){
"use strict";

var errorObject_1 = require('./errorObject');
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    } catch (e) {
        errorObject_1.errorObject.e = e;
        return errorObject_1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;
;


},{"./errorObject":151}],164:[function(require,module,exports){
// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//     You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//     See the License for the specific language governing permissions and
// limitations under the License.

!function(a,b){var c={},d={},e={},f=null;!function(a,b){function c(a){if("number"==typeof a)return a;var b={};for(var c in a)b[c]=a[c];return b}function d(){this._delay=0,this._endDelay=0,this._fill="none",this._iterationStart=0,this._iterations=1,this._duration=0,this._playbackRate=1,this._direction="normal",this._easing="linear",this._easingFunction=x}function e(){return a.isDeprecated("Invalid timing inputs","2016-03-02","TypeError exceptions will be thrown instead.",!0)}function f(b,c,e){var f=new d;return c&&(f.fill="both",f.duration="auto"),"number"!=typeof b||isNaN(b)?void 0!==b&&Object.getOwnPropertyNames(b).forEach(function(c){if("auto"!=b[c]){if(("number"==typeof f[c]||"duration"==c)&&("number"!=typeof b[c]||isNaN(b[c])))return;if("fill"==c&&v.indexOf(b[c])==-1)return;if("direction"==c&&w.indexOf(b[c])==-1)return;if("playbackRate"==c&&1!==b[c]&&a.isDeprecated("AnimationEffectTiming.playbackRate","2014-11-28","Use Animation.playbackRate instead."))return;f[c]=b[c]}}):f.duration=b,f}function g(a){return"number"==typeof a&&(a=isNaN(a)?{duration:0}:{duration:a}),a}function h(b,c){return b=a.numericTimingToObject(b),f(b,c)}function i(a,b,c,d){return a<0||a>1||c<0||c>1?x:function(e){function f(a,b,c){return 3*a*(1-c)*(1-c)*c+3*b*(1-c)*c*c+c*c*c}if(e<=0){var g=0;return a>0?g=b/a:!b&&c>0&&(g=d/c),g*e}if(e>=1){var h=0;return c<1?h=(d-1)/(c-1):1==c&&a<1&&(h=(b-1)/(a-1)),1+h*(e-1)}for(var i=0,j=1;i<j;){var k=(i+j)/2,l=f(a,c,k);if(Math.abs(e-l)<1e-5)return f(b,d,k);l<e?i=k:j=k}return f(b,d,k)}}function j(a,b){return function(c){if(c>=1)return 1;var d=1/a;return c+=b*d,c-c%d}}function k(a){C||(C=document.createElement("div").style),C.animationTimingFunction="",C.animationTimingFunction=a;var b=C.animationTimingFunction;if(""==b&&e())throw new TypeError(a+" is not a valid value for easing");return b}function l(a){if("linear"==a)return x;var b=E.exec(a);if(b)return i.apply(this,b.slice(1).map(Number));var c=F.exec(a);if(c)return j(Number(c[1]),{start:y,middle:z,end:A}[c[2]]);var d=B[a];return d?d:x}function m(a){return Math.abs(n(a)/a.playbackRate)}function n(a){return 0===a.duration||0===a.iterations?0:a.duration*a.iterations}function o(a,b,c){if(null==b)return G;var d=c.delay+a+c.endDelay;return b<Math.min(c.delay,d)?H:b>=Math.min(c.delay+a,d)?I:J}function p(a,b,c,d,e){switch(d){case H:return"backwards"==b||"both"==b?0:null;case J:return c-e;case I:return"forwards"==b||"both"==b?a:null;case G:return null}}function q(a,b,c,d,e){var f=e;return 0===a?b!==H&&(f+=c):f+=d/a,f}function r(a,b,c,d,e,f){var g=a===1/0?b%1:a%1;return 0!==g||c!==I||0===d||0===e&&0!==f||(g=1),g}function s(a,b,c,d){return a===I&&b===1/0?1/0:1===c?Math.floor(d)-1:Math.floor(d)}function t(a,b,c){var d=a;if("normal"!==a&&"reverse"!==a){var e=b;"alternate-reverse"===a&&(e+=1),d="normal",e!==1/0&&e%2!==0&&(d="reverse")}return"normal"===d?c:1-c}function u(a,b,c){var d=o(a,b,c),e=p(a,c.fill,b,d,c.delay);if(null===e)return null;var f=q(c.duration,d,c.iterations,e,c.iterationStart),g=r(f,c.iterationStart,d,c.iterations,e,c.duration),h=s(d,c.iterations,g,f),i=t(c.direction,h,g);return c._easingFunction(i)}var v="backwards|forwards|both|none".split("|"),w="reverse|alternate|alternate-reverse".split("|"),x=function(a){return a};d.prototype={_setMember:function(b,c){this["_"+b]=c,this._effect&&(this._effect._timingInput[b]=c,this._effect._timing=a.normalizeTimingInput(this._effect._timingInput),this._effect.activeDuration=a.calculateActiveDuration(this._effect._timing),this._effect._animation&&this._effect._animation._rebuildUnderlyingAnimation())},get playbackRate(){return this._playbackRate},set delay(a){this._setMember("delay",a)},get delay(){return this._delay},set endDelay(a){this._setMember("endDelay",a)},get endDelay(){return this._endDelay},set fill(a){this._setMember("fill",a)},get fill(){return this._fill},set iterationStart(a){if((isNaN(a)||a<0)&&e())throw new TypeError("iterationStart must be a non-negative number, received: "+timing.iterationStart);this._setMember("iterationStart",a)},get iterationStart(){return this._iterationStart},set duration(a){if("auto"!=a&&(isNaN(a)||a<0)&&e())throw new TypeError("duration must be non-negative or auto, received: "+a);this._setMember("duration",a)},get duration(){return this._duration},set direction(a){this._setMember("direction",a)},get direction(){return this._direction},set easing(a){this._easingFunction=l(k(a)),this._setMember("easing",a)},get easing(){return this._easing},set iterations(a){if((isNaN(a)||a<0)&&e())throw new TypeError("iterations must be non-negative, received: "+a);this._setMember("iterations",a)},get iterations(){return this._iterations}};var y=1,z=.5,A=0,B={ease:i(.25,.1,.25,1),"ease-in":i(.42,0,1,1),"ease-out":i(0,0,.58,1),"ease-in-out":i(.42,0,.58,1),"step-start":j(1,y),"step-middle":j(1,z),"step-end":j(1,A)},C=null,D="\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*",E=new RegExp("cubic-bezier\\("+D+","+D+","+D+","+D+"\\)"),F=/steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/,G=0,H=1,I=2,J=3;a.cloneTimingInput=c,a.makeTiming=f,a.numericTimingToObject=g,a.normalizeTimingInput=h,a.calculateActiveDuration=m,a.calculateIterationProgress=u,a.calculatePhase=o,a.normalizeEasing=k,a.parseEasingFunction=l}(c,f),function(a,b){function c(a,b){return a in k?k[a][b]||b:b}function d(a){return"display"===a||0===a.lastIndexOf("animation",0)||0===a.lastIndexOf("transition",0)}function e(a,b,e){if(!d(a)){var f=h[a];if(f){i.style[a]=b;for(var g in f){var j=f[g],k=i.style[j];e[j]=c(j,k)}}else e[a]=c(a,b)}}function f(a){var b=[];for(var c in a)if(!(c in["easing","offset","composite"])){var d=a[c];Array.isArray(d)||(d=[d]);for(var e,f=d.length,g=0;g<f;g++)e={},"offset"in a?e.offset=a.offset:1==f?e.offset=1:e.offset=g/(f-1),"easing"in a&&(e.easing=a.easing),"composite"in a&&(e.composite=a.composite),e[c]=d[g],b.push(e)}return b.sort(function(a,b){return a.offset-b.offset}),b}function g(b){function c(){var a=d.length;null==d[a-1].offset&&(d[a-1].offset=1),a>1&&null==d[0].offset&&(d[0].offset=0);for(var b=0,c=d[0].offset,e=1;e<a;e++){var f=d[e].offset;if(null!=f){for(var g=1;g<e-b;g++)d[b+g].offset=c+(f-c)*g/(e-b);b=e,c=f}}}if(null==b)return[];window.Symbol&&Symbol.iterator&&Array.prototype.from&&b[Symbol.iterator]&&(b=Array.from(b)),Array.isArray(b)||(b=f(b));for(var d=b.map(function(b){var c={};for(var d in b){var f=b[d];if("offset"==d){if(null!=f){if(f=Number(f),!isFinite(f))throw new TypeError("Keyframe offsets must be numbers.");if(f<0||f>1)throw new TypeError("Keyframe offsets must be between 0 and 1.")}}else if("composite"==d){if("add"==f||"accumulate"==f)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"add compositing is not supported"};if("replace"!=f)throw new TypeError("Invalid composite mode "+f+".")}else f="easing"==d?a.normalizeEasing(f):""+f;e(d,f,c)}return void 0==c.offset&&(c.offset=null),void 0==c.easing&&(c.easing="linear"),c}),g=!0,h=-(1/0),i=0;i<d.length;i++){var j=d[i].offset;if(null!=j){if(j<h)throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");h=j}else g=!1}return d=d.filter(function(a){return a.offset>=0&&a.offset<=1}),g||c(),d}var h={background:["backgroundImage","backgroundPosition","backgroundSize","backgroundRepeat","backgroundAttachment","backgroundOrigin","backgroundClip","backgroundColor"],border:["borderTopColor","borderTopStyle","borderTopWidth","borderRightColor","borderRightStyle","borderRightWidth","borderBottomColor","borderBottomStyle","borderBottomWidth","borderLeftColor","borderLeftStyle","borderLeftWidth"],borderBottom:["borderBottomWidth","borderBottomStyle","borderBottomColor"],borderColor:["borderTopColor","borderRightColor","borderBottomColor","borderLeftColor"],borderLeft:["borderLeftWidth","borderLeftStyle","borderLeftColor"],borderRadius:["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],borderRight:["borderRightWidth","borderRightStyle","borderRightColor"],borderTop:["borderTopWidth","borderTopStyle","borderTopColor"],borderWidth:["borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth"],flex:["flexGrow","flexShrink","flexBasis"],font:["fontFamily","fontSize","fontStyle","fontVariant","fontWeight","lineHeight"],margin:["marginTop","marginRight","marginBottom","marginLeft"],outline:["outlineColor","outlineStyle","outlineWidth"],padding:["paddingTop","paddingRight","paddingBottom","paddingLeft"]},i=document.createElementNS("http://www.w3.org/1999/xhtml","div"),j={thin:"1px",medium:"3px",thick:"5px"},k={borderBottomWidth:j,borderLeftWidth:j,borderRightWidth:j,borderTopWidth:j,fontSize:{"xx-small":"60%","x-small":"75%",small:"89%",medium:"100%",large:"120%","x-large":"150%","xx-large":"200%"},fontWeight:{normal:"400",bold:"700"},outlineWidth:j,textShadow:{none:"0px 0px 0px transparent"},boxShadow:{none:"0px 0px 0px 0px transparent"}};a.convertToArrayForm=f,a.normalizeKeyframes=g}(c,f),function(a){var b={};a.isDeprecated=function(a,c,d,e){var f=e?"are":"is",g=new Date,h=new Date(c);return h.setMonth(h.getMonth()+3),!(g<h&&(a in b||console.warn("Web Animations: "+a+" "+f+" deprecated and will stop working on "+h.toDateString()+". "+d),b[a]=!0,1))},a.deprecated=function(b,c,d,e){var f=e?"are":"is";if(a.isDeprecated(b,c,d,e))throw new Error(b+" "+f+" no longer supported. "+d)}}(c),function(){if(document.documentElement.animate){var a=document.documentElement.animate([],0),b=!0;if(a&&(b=!1,"play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState".split("|").forEach(function(c){void 0===a[c]&&(b=!0)})),!b)return}!function(a,b,c){function d(a){for(var b={},c=0;c<a.length;c++)for(var d in a[c])if("offset"!=d&&"easing"!=d&&"composite"!=d){var e={offset:a[c].offset,easing:a[c].easing,value:a[c][d]};b[d]=b[d]||[],b[d].push(e)}for(var f in b){var g=b[f];if(0!=g[0].offset||1!=g[g.length-1].offset)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"Partial keyframes are not supported"}}return b}function e(c){var d=[];for(var e in c)for(var f=c[e],g=0;g<f.length-1;g++){var h=g,i=g+1,j=f[h].offset,k=f[i].offset,l=j,m=k;0==g&&(l=-(1/0),0==k&&(i=h)),g==f.length-2&&(m=1/0,1==j&&(h=i)),d.push({applyFrom:l,applyTo:m,startOffset:f[h].offset,endOffset:f[i].offset,easingFunction:a.parseEasingFunction(f[h].easing),property:e,interpolation:b.propertyInterpolation(e,f[h].value,f[i].value)})}return d.sort(function(a,b){return a.startOffset-b.startOffset}),d}b.convertEffectInput=function(c){var f=a.normalizeKeyframes(c),g=d(f),h=e(g);return function(a,c){if(null!=c)h.filter(function(a){return c>=a.applyFrom&&c<a.applyTo}).forEach(function(d){var e=c-d.startOffset,f=d.endOffset-d.startOffset,g=0==f?0:d.easingFunction(e/f);b.apply(a,d.property,d.interpolation(g))});else for(var d in g)"offset"!=d&&"easing"!=d&&"composite"!=d&&b.clear(a,d)}}}(c,d,f),function(a,b,c){function d(a){return a.replace(/-(.)/g,function(a,b){return b.toUpperCase()})}function e(a,b,c){h[c]=h[c]||[],h[c].push([a,b])}function f(a,b,c){for(var f=0;f<c.length;f++){var g=c[f];e(a,b,d(g))}}function g(c,e,f){var g=c;/-/.test(c)&&!a.isDeprecated("Hyphenated property names","2016-03-22","Use camelCase instead.",!0)&&(g=d(c)),"initial"!=e&&"initial"!=f||("initial"==e&&(e=i[g]),"initial"==f&&(f=i[g]));for(var j=e==f?[]:h[g],k=0;j&&k<j.length;k++){var l=j[k][0](e),m=j[k][0](f);if(void 0!==l&&void 0!==m){var n=j[k][1](l,m);if(n){var o=b.Interpolation.apply(null,n);return function(a){return 0==a?e:1==a?f:o(a)}}}}return b.Interpolation(!1,!0,function(a){return a?f:e})}var h={};b.addPropertiesHandler=f;var i={backgroundColor:"transparent",backgroundPosition:"0% 0%",borderBottomColor:"currentColor",borderBottomLeftRadius:"0px",borderBottomRightRadius:"0px",borderBottomWidth:"3px",borderLeftColor:"currentColor",borderLeftWidth:"3px",borderRightColor:"currentColor",borderRightWidth:"3px",borderSpacing:"2px",borderTopColor:"currentColor",borderTopLeftRadius:"0px",borderTopRightRadius:"0px",borderTopWidth:"3px",bottom:"auto",clip:"rect(0px, 0px, 0px, 0px)",color:"black",fontSize:"100%",fontWeight:"400",height:"auto",left:"auto",letterSpacing:"normal",lineHeight:"120%",marginBottom:"0px",marginLeft:"0px",marginRight:"0px",marginTop:"0px",maxHeight:"none",maxWidth:"none",minHeight:"0px",minWidth:"0px",opacity:"1.0",outlineColor:"invert",outlineOffset:"0px",outlineWidth:"3px",paddingBottom:"0px",paddingLeft:"0px",paddingRight:"0px",paddingTop:"0px",right:"auto",textIndent:"0px",textShadow:"0px 0px 0px transparent",top:"auto",transform:"",verticalAlign:"0px",visibility:"visible",width:"auto",wordSpacing:"normal",zIndex:"auto"};b.propertyInterpolation=g}(c,d,f),function(a,b,c){function d(b){var c=a.calculateActiveDuration(b),d=function(d){return a.calculateIterationProgress(c,d,b)};return d._totalDuration=b.delay+c+b.endDelay,d}b.KeyframeEffect=function(c,e,f,g){var h,i=d(a.normalizeTimingInput(f)),j=b.convertEffectInput(e),k=function(){j(c,h)};return k._update=function(a){return h=i(a),null!==h},k._clear=function(){j(c,null)},k._hasSameTarget=function(a){return c===a},k._target=c,k._totalDuration=i._totalDuration,k._id=g,k},b.NullEffect=function(a){var b=function(){a&&(a(),a=null)};return b._update=function(){return null},b._totalDuration=0,b._hasSameTarget=function(){return!1},b}}(c,d,f),function(a,b){function c(a,b,c){c.enumerable=!0,c.configurable=!0,Object.defineProperty(a,b,c)}function d(a){this._surrogateStyle=document.createElementNS("http://www.w3.org/1999/xhtml","div").style,this._style=a.style,this._length=0,this._isAnimatedProperty={};for(var b=0;b<this._style.length;b++){var c=this._style[b];this._surrogateStyle[c]=this._style[c]}this._updateIndices()}function e(a){if(!a._webAnimationsPatchedStyle){var b=new d(a);try{c(a,"style",{get:function(){return b}})}catch(b){a.style._set=function(b,c){a.style[b]=c},a.style._clear=function(b){a.style[b]=""}}a._webAnimationsPatchedStyle=a.style}}var f={cssText:1,length:1,parentRule:1},g={getPropertyCSSValue:1,getPropertyPriority:1,getPropertyValue:1,item:1,removeProperty:1,setProperty:1},h={removeProperty:1,setProperty:1};d.prototype={get cssText(){return this._surrogateStyle.cssText},set cssText(a){for(var b={},c=0;c<this._surrogateStyle.length;c++)b[this._surrogateStyle[c]]=!0;this._surrogateStyle.cssText=a,this._updateIndices();for(var c=0;c<this._surrogateStyle.length;c++)b[this._surrogateStyle[c]]=!0;for(var d in b)this._isAnimatedProperty[d]||this._style.setProperty(d,this._surrogateStyle.getPropertyValue(d))},get length(){return this._surrogateStyle.length},get parentRule(){return this._style.parentRule},_updateIndices:function(){for(;this._length<this._surrogateStyle.length;)Object.defineProperty(this,this._length,{configurable:!0,enumerable:!1,get:function(a){return function(){return this._surrogateStyle[a]}}(this._length)}),this._length++;for(;this._length>this._surrogateStyle.length;)this._length--,Object.defineProperty(this,this._length,{configurable:!0,enumerable:!1,value:void 0})},_set:function(a,b){this._style[a]=b,this._isAnimatedProperty[a]=!0},_clear:function(a){this._style[a]=this._surrogateStyle[a],delete this._isAnimatedProperty[a]}};for(var i in g)d.prototype[i]=function(a,b){return function(){var c=this._surrogateStyle[a].apply(this._surrogateStyle,arguments);return b&&(this._isAnimatedProperty[arguments[0]]||this._style[a].apply(this._style,arguments),this._updateIndices()),c}}(i,i in h);for(var j in document.documentElement.style)j in f||j in g||!function(a){c(d.prototype,a,{get:function(){return this._surrogateStyle[a]},set:function(b){this._surrogateStyle[a]=b,this._updateIndices(),this._isAnimatedProperty[a]||(this._style[a]=b)}})}(j);a.apply=function(b,c,d){e(b),b.style._set(a.propertyName(c),d)},a.clear=function(b,c){b._webAnimationsPatchedStyle&&b.style._clear(a.propertyName(c))}}(d,f),function(a){window.Element.prototype.animate=function(b,c){var d="";return c&&c.id&&(d=c.id),a.timeline._play(a.KeyframeEffect(this,b,c,d))}}(d),function(a,b){function c(a,b,d){if("number"==typeof a&&"number"==typeof b)return a*(1-d)+b*d;if("boolean"==typeof a&&"boolean"==typeof b)return d<.5?a:b;if(a.length==b.length){for(var e=[],f=0;f<a.length;f++)e.push(c(a[f],b[f],d));return e}throw"Mismatched interpolation arguments "+a+":"+b}a.Interpolation=function(a,b,d){return function(e){return d(c(a,b,e))}}}(d,f),function(a,b){function c(a,b,c){return Math.max(Math.min(a,c),b)}function d(b,d,e){var f=a.dot(b,d);f=c(f,-1,1);var g=[];if(1===f)g=b;else for(var h=Math.acos(f),i=1*Math.sin(e*h)/Math.sqrt(1-f*f),j=0;j<4;j++)g.push(b[j]*(Math.cos(e*h)-f*i)+d[j]*i);return g}var e=function(){function a(a,b){for(var c=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]],d=0;d<4;d++)for(var e=0;e<4;e++)for(var f=0;f<4;f++)c[d][e]+=b[d][f]*a[f][e];return c}function b(a){return 0==a[0][2]&&0==a[0][3]&&0==a[1][2]&&0==a[1][3]&&0==a[2][0]&&0==a[2][1]&&1==a[2][2]&&0==a[2][3]&&0==a[3][2]&&1==a[3][3]}function c(c,d,e,f,g){for(var h=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],i=0;i<4;i++)h[i][3]=g[i];for(var i=0;i<3;i++)for(var j=0;j<3;j++)h[3][i]+=c[j]*h[j][i];var k=f[0],l=f[1],m=f[2],n=f[3],o=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];o[0][0]=1-2*(l*l+m*m),o[0][1]=2*(k*l-m*n),o[0][2]=2*(k*m+l*n),o[1][0]=2*(k*l+m*n),o[1][1]=1-2*(k*k+m*m),o[1][2]=2*(l*m-k*n),o[2][0]=2*(k*m-l*n),o[2][1]=2*(l*m+k*n),o[2][2]=1-2*(k*k+l*l),h=a(h,o);var p=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];e[2]&&(p[2][1]=e[2],h=a(h,p)),e[1]&&(p[2][1]=0,p[2][0]=e[0],h=a(h,p)),e[0]&&(p[2][0]=0,p[1][0]=e[0],h=a(h,p));for(var i=0;i<3;i++)for(var j=0;j<3;j++)h[i][j]*=d[i];return b(h)?[h[0][0],h[0][1],h[1][0],h[1][1],h[3][0],h[3][1]]:h[0].concat(h[1],h[2],h[3])}return c}();a.composeMatrix=e,a.quat=d}(d,f),function(a,b,c){a.sequenceNumber=0;var d=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="finish",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()};b.Animation=function(b){this.id="",b&&b._id&&(this.id=b._id),this._sequenceNumber=a.sequenceNumber++,this._currentTime=0,this._startTime=null,this._paused=!1,this._playbackRate=1,this._inTimeline=!0,this._finishedFlag=!0,this.onfinish=null,this._finishHandlers=[],this._effect=b,this._inEffect=this._effect._update(0),this._idle=!0,this._currentTimePending=!1},b.Animation.prototype={_ensureAlive:function(){this.playbackRate<0&&0===this.currentTime?this._inEffect=this._effect._update(-1):this._inEffect=this._effect._update(this.currentTime),this._inTimeline||!this._inEffect&&this._finishedFlag||(this._inTimeline=!0,b.timeline._animations.push(this))},_tickCurrentTime:function(a,b){a!=this._currentTime&&(this._currentTime=a,this._isFinished&&!b&&(this._currentTime=this._playbackRate>0?this._totalDuration:0),this._ensureAlive())},get currentTime(){return this._idle||this._currentTimePending?null:this._currentTime},set currentTime(a){a=+a,isNaN(a)||(b.restart(),this._paused||null==this._startTime||(this._startTime=this._timeline.currentTime-a/this._playbackRate),this._currentTimePending=!1,this._currentTime!=a&&(this._idle&&(this._idle=!1,this._paused=!0),this._tickCurrentTime(a,!0),b.applyDirtiedAnimation(this)))},get startTime(){return this._startTime},set startTime(a){a=+a,isNaN(a)||this._paused||this._idle||(this._startTime=a,this._tickCurrentTime((this._timeline.currentTime-this._startTime)*this.playbackRate),b.applyDirtiedAnimation(this))},get playbackRate(){return this._playbackRate},set playbackRate(a){if(a!=this._playbackRate){var c=this.currentTime;this._playbackRate=a,this._startTime=null,"paused"!=this.playState&&"idle"!=this.playState&&(this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),b.applyDirtiedAnimation(this)),null!=c&&(this.currentTime=c)}},get _isFinished(){return!this._idle&&(this._playbackRate>0&&this._currentTime>=this._totalDuration||this._playbackRate<0&&this._currentTime<=0)},get _totalDuration(){return this._effect._totalDuration},get playState(){return this._idle?"idle":null==this._startTime&&!this._paused&&0!=this.playbackRate||this._currentTimePending?"pending":this._paused?"paused":this._isFinished?"finished":"running"},_rewind:function(){if(this._playbackRate>=0)this._currentTime=0;else{if(!(this._totalDuration<1/0))throw new DOMException("Unable to rewind negative playback rate animation with infinite duration","InvalidStateError");this._currentTime=this._totalDuration}},play:function(){this._paused=!1,(this._isFinished||this._idle)&&(this._rewind(),this._startTime=null),this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),b.applyDirtiedAnimation(this)},pause:function(){this._isFinished||this._paused||this._idle?this._idle&&(this._rewind(),this._idle=!1):this._currentTimePending=!0,this._startTime=null,this._paused=!0},finish:function(){this._idle||(this.currentTime=this._playbackRate>0?this._totalDuration:0,this._startTime=this._totalDuration-this.currentTime,this._currentTimePending=!1,b.applyDirtiedAnimation(this))},cancel:function(){this._inEffect&&(this._inEffect=!1,this._idle=!0,this._paused=!1,this._isFinished=!0,this._finishedFlag=!0,this._currentTime=0,this._startTime=null,this._effect._update(null),b.applyDirtiedAnimation(this))},reverse:function(){this.playbackRate*=-1,this.play()},addEventListener:function(a,b){"function"==typeof b&&"finish"==a&&this._finishHandlers.push(b)},removeEventListener:function(a,b){if("finish"==a){var c=this._finishHandlers.indexOf(b);c>=0&&this._finishHandlers.splice(c,1)}},_fireEvents:function(a){if(this._isFinished){if(!this._finishedFlag){var b=new d(this,this._currentTime,a),c=this._finishHandlers.concat(this.onfinish?[this.onfinish]:[]);setTimeout(function(){c.forEach(function(a){a.call(b.target,b)})},0),this._finishedFlag=!0}}else this._finishedFlag=!1},_tick:function(a,b){this._idle||this._paused||(null==this._startTime?b&&(this.startTime=a-this._currentTime/this.playbackRate):this._isFinished||this._tickCurrentTime((a-this._startTime)*this.playbackRate)),b&&(this._currentTimePending=!1,this._fireEvents(a))},get _needsTick(){return this.playState in{pending:1,running:1}||!this._finishedFlag},_targetAnimations:function(){var a=this._effect._target;return a._activeAnimations||(a._activeAnimations=[]),a._activeAnimations},_markTarget:function(){var a=this._targetAnimations();a.indexOf(this)===-1&&a.push(this)},_unmarkTarget:function(){var a=this._targetAnimations(),b=a.indexOf(this);b!==-1&&a.splice(b,1)}}}(c,d,f),function(a,b,c){function d(a){var b=j;j=[],a<q.currentTime&&(a=q.currentTime),q._animations.sort(e),q._animations=h(a,!0,q._animations)[0],b.forEach(function(b){b[1](a)}),g(),l=void 0}function e(a,b){return a._sequenceNumber-b._sequenceNumber}function f(){this._animations=[],this.currentTime=window.performance&&performance.now?performance.now():0}function g(){o.forEach(function(a){a()}),o.length=0}function h(a,c,d){p=!0,n=!1;var e=b.timeline;e.currentTime=a,m=!1;var f=[],g=[],h=[],i=[];return d.forEach(function(b){b._tick(a,c),b._inEffect?(g.push(b._effect),b._markTarget()):(f.push(b._effect),b._unmarkTarget()),b._needsTick&&(m=!0);var d=b._inEffect||b._needsTick;b._inTimeline=d,d?h.push(b):i.push(b)}),o.push.apply(o,f),o.push.apply(o,g),m&&requestAnimationFrame(function(){}),p=!1,[h,i]}var i=window.requestAnimationFrame,j=[],k=0;window.requestAnimationFrame=function(a){var b=k++;return 0==j.length&&i(d),j.push([b,a]),b},window.cancelAnimationFrame=function(a){j.forEach(function(b){b[0]==a&&(b[1]=function(){})})},f.prototype={_play:function(c){c._timing=a.normalizeTimingInput(c.timing);var d=new b.Animation(c);return d._idle=!1,d._timeline=this,this._animations.push(d),b.restart(),b.applyDirtiedAnimation(d),d}};var l=void 0,m=!1,n=!1;b.restart=function(){return m||(m=!0,requestAnimationFrame(function(){}),n=!0),n},b.applyDirtiedAnimation=function(a){if(!p){a._markTarget();var c=a._targetAnimations();c.sort(e);var d=h(b.timeline.currentTime,!1,c.slice())[1];d.forEach(function(a){var b=q._animations.indexOf(a);b!==-1&&q._animations.splice(b,1)}),g()}};var o=[],p=!1,q=new f;b.timeline=q}(c,d,f),function(a,b){function c(a,b){for(var c=0,d=0;d<a.length;d++)c+=a[d]*b[d];return c}function d(a,b){return[a[0]*b[0]+a[4]*b[1]+a[8]*b[2]+a[12]*b[3],a[1]*b[0]+a[5]*b[1]+a[9]*b[2]+a[13]*b[3],a[2]*b[0]+a[6]*b[1]+a[10]*b[2]+a[14]*b[3],a[3]*b[0]+a[7]*b[1]+a[11]*b[2]+a[15]*b[3],a[0]*b[4]+a[4]*b[5]+a[8]*b[6]+a[12]*b[7],a[1]*b[4]+a[5]*b[5]+a[9]*b[6]+a[13]*b[7],a[2]*b[4]+a[6]*b[5]+a[10]*b[6]+a[14]*b[7],a[3]*b[4]+a[7]*b[5]+a[11]*b[6]+a[15]*b[7],a[0]*b[8]+a[4]*b[9]+a[8]*b[10]+a[12]*b[11],a[1]*b[8]+a[5]*b[9]+a[9]*b[10]+a[13]*b[11],a[2]*b[8]+a[6]*b[9]+a[10]*b[10]+a[14]*b[11],a[3]*b[8]+a[7]*b[9]+a[11]*b[10]+a[15]*b[11],a[0]*b[12]+a[4]*b[13]+a[8]*b[14]+a[12]*b[15],a[1]*b[12]+a[5]*b[13]+a[9]*b[14]+a[13]*b[15],a[2]*b[12]+a[6]*b[13]+a[10]*b[14]+a[14]*b[15],a[3]*b[12]+a[7]*b[13]+a[11]*b[14]+a[15]*b[15]]}function e(a){var b=a.rad||0,c=a.deg||0,d=a.grad||0,e=a.turn||0,f=(c/360+d/400+e)*(2*Math.PI)+b;return f}function f(a){switch(a.t){case"rotatex":var b=e(a.d[0]);return[1,0,0,0,0,Math.cos(b),Math.sin(b),0,0,-Math.sin(b),Math.cos(b),0,0,0,0,1];case"rotatey":var b=e(a.d[0]);return[Math.cos(b),0,-Math.sin(b),0,0,1,0,0,Math.sin(b),0,Math.cos(b),0,0,0,0,1];case"rotate":case"rotatez":var b=e(a.d[0]);return[Math.cos(b),Math.sin(b),0,0,-Math.sin(b),Math.cos(b),0,0,0,0,1,0,0,0,0,1];case"rotate3d":var c=a.d[0],d=a.d[1],f=a.d[2],b=e(a.d[3]),g=c*c+d*d+f*f;if(0===g)c=1,d=0,f=0;else if(1!==g){var h=Math.sqrt(g);c/=h,d/=h,f/=h}var i=Math.sin(b/2),j=i*Math.cos(b/2),k=i*i;return[1-2*(d*d+f*f)*k,2*(c*d*k+f*j),2*(c*f*k-d*j),0,2*(c*d*k-f*j),1-2*(c*c+f*f)*k,2*(d*f*k+c*j),0,2*(c*f*k+d*j),2*(d*f*k-c*j),1-2*(c*c+d*d)*k,0,0,0,0,1];case"scale":return[a.d[0],0,0,0,0,a.d[1],0,0,0,0,1,0,0,0,0,1];case"scalex":return[a.d[0],0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];case"scaley":return[1,0,0,0,0,a.d[0],0,0,0,0,1,0,0,0,0,1];case"scalez":return[1,0,0,0,0,1,0,0,0,0,a.d[0],0,0,0,0,1];case"scale3d":return[a.d[0],0,0,0,0,a.d[1],0,0,0,0,a.d[2],0,0,0,0,1];case"skew":var l=e(a.d[0]),m=e(a.d[1]);return[1,Math.tan(m),0,0,Math.tan(l),1,0,0,0,0,1,0,0,0,0,1];case"skewx":var b=e(a.d[0]);return[1,0,0,0,Math.tan(b),1,0,0,0,0,1,0,0,0,0,1];case"skewy":var b=e(a.d[0]);return[1,Math.tan(b),0,0,0,1,0,0,0,0,1,0,0,0,0,1];case"translate":var c=a.d[0].px||0,d=a.d[1].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,d,0,1];case"translatex":var c=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,0,0,1];case"translatey":var d=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,0,d,0,1];case"translatez":var f=a.d[0].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,0,0,f,1];case"translate3d":var c=a.d[0].px||0,d=a.d[1].px||0,f=a.d[2].px||0;return[1,0,0,0,0,1,0,0,0,0,1,0,c,d,f,1];case"perspective":var n=a.d[0].px?-1/a.d[0].px:0;return[1,0,0,0,0,1,0,0,0,0,1,n,0,0,0,1];case"matrix":return[a.d[0],a.d[1],0,0,a.d[2],a.d[3],0,0,0,0,1,0,a.d[4],a.d[5],0,1];case"matrix3d":return a.d}}function g(a){return 0===a.length?[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]:a.map(f).reduce(d)}function h(a){return[i(g(a))]}var i=function(){function a(a){return a[0][0]*a[1][1]*a[2][2]+a[1][0]*a[2][1]*a[0][2]+a[2][0]*a[0][1]*a[1][2]-a[0][2]*a[1][1]*a[2][0]-a[1][2]*a[2][1]*a[0][0]-a[2][2]*a[0][1]*a[1][0]}function b(b){for(var c=1/a(b),d=b[0][0],e=b[0][1],f=b[0][2],g=b[1][0],h=b[1][1],i=b[1][2],j=b[2][0],k=b[2][1],l=b[2][2],m=[[(h*l-i*k)*c,(f*k-e*l)*c,(e*i-f*h)*c,0],[(i*j-g*l)*c,(d*l-f*j)*c,(f*g-d*i)*c,0],[(g*k-h*j)*c,(j*e-d*k)*c,(d*h-e*g)*c,0]],n=[],o=0;o<3;o++){for(var p=0,q=0;q<3;q++)p+=b[3][q]*m[q][o];n.push(p)}return n.push(1),m.push(n),m}function d(a){return[[a[0][0],a[1][0],a[2][0],a[3][0]],[a[0][1],a[1][1],a[2][1],a[3][1]],[a[0][2],a[1][2],a[2][2],a[3][2]],[a[0][3],a[1][3],a[2][3],a[3][3]]]}function e(a,b){for(var c=[],d=0;d<4;d++){for(var e=0,f=0;f<4;f++)e+=a[f]*b[f][d];c.push(e)}return c}function f(a){var b=g(a);return[a[0]/b,a[1]/b,a[2]/b]}function g(a){return Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2])}function h(a,b,c,d){return[c*a[0]+d*b[0],c*a[1]+d*b[1],c*a[2]+d*b[2]]}function i(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]]}function j(j){var k=[j.slice(0,4),j.slice(4,8),j.slice(8,12),j.slice(12,16)];if(1!==k[3][3])return null;for(var l=[],m=0;m<4;m++)l.push(k[m].slice());for(var m=0;m<3;m++)l[m][3]=0;if(0===a(l))return!1;var n,o=[];if(k[0][3]||k[1][3]||k[2][3]){o.push(k[0][3]),o.push(k[1][3]),o.push(k[2][3]),o.push(k[3][3]);var p=b(l),q=d(p);n=e(o,q)}else n=[0,0,0,1];var r=k[3].slice(0,3),s=[];s.push(k[0].slice(0,3));var t=[];t.push(g(s[0])),s[0]=f(s[0]);var u=[];s.push(k[1].slice(0,3)),u.push(c(s[0],s[1])),s[1]=h(s[1],s[0],1,-u[0]),t.push(g(s[1])),s[1]=f(s[1]),u[0]/=t[1],s.push(k[2].slice(0,3)),u.push(c(s[0],s[2])),s[2]=h(s[2],s[0],1,-u[1]),u.push(c(s[1],s[2])),s[2]=h(s[2],s[1],1,-u[2]),t.push(g(s[2])),s[2]=f(s[2]),u[1]/=t[2],u[2]/=t[2];var v=i(s[1],s[2]);if(c(s[0],v)<0)for(var m=0;m<3;m++)t[m]*=-1,s[m][0]*=-1,s[m][1]*=-1,s[m][2]*=-1;var w,x,y=s[0][0]+s[1][1]+s[2][2]+1;return y>1e-4?(w=.5/Math.sqrt(y),x=[(s[2][1]-s[1][2])*w,(s[0][2]-s[2][0])*w,(s[1][0]-s[0][1])*w,.25/w]):s[0][0]>s[1][1]&&s[0][0]>s[2][2]?(w=2*Math.sqrt(1+s[0][0]-s[1][1]-s[2][2]),x=[.25*w,(s[0][1]+s[1][0])/w,(s[0][2]+s[2][0])/w,(s[2][1]-s[1][2])/w]):s[1][1]>s[2][2]?(w=2*Math.sqrt(1+s[1][1]-s[0][0]-s[2][2]),x=[(s[0][1]+s[1][0])/w,.25*w,(s[1][2]+s[2][1])/w,(s[0][2]-s[2][0])/w]):(w=2*Math.sqrt(1+s[2][2]-s[0][0]-s[1][1]),x=[(s[0][2]+s[2][0])/w,(s[1][2]+s[2][1])/w,.25*w,(s[1][0]-s[0][1])/w]),[r,t,u,x,n]}return j}();a.dot=c,a.makeMatrixDecomposition=h}(d,f),function(a){function b(a,b){var c=a.exec(b);if(c)return c=a.ignoreCase?c[0].toLowerCase():c[0],[c,b.substr(c.length)]}function c(a,b){b=b.replace(/^\s*/,"");var c=a(b);if(c)return[c[0],c[1].replace(/^\s*/,"")]}function d(a,d,e){a=c.bind(null,a);for(var f=[];;){var g=a(e);if(!g)return[f,e];if(f.push(g[0]),e=g[1],g=b(d,e),!g||""==g[1])return[f,e];e=g[1]}}function e(a,b){for(var c=0,d=0;d<b.length&&(!/\s|,/.test(b[d])||0!=c);d++)if("("==b[d])c++;else if(")"==b[d]&&(c--,0==c&&d++,c<=0))break;var e=a(b.substr(0,d));return void 0==e?void 0:[e,b.substr(d)]}function f(a,b){for(var c=a,d=b;c&&d;)c>d?c%=d:d%=c;return c=a*b/(c+d)}function g(a){return function(b){var c=a(b);return c&&(c[0]=void 0),c}}function h(a,b){return function(c){var d=a(c);return d?d:[b,c]}}function i(b,c){for(var d=[],e=0;e<b.length;e++){var f=a.consumeTrimmed(b[e],c);if(!f||""==f[0])return;void 0!==f[0]&&d.push(f[0]),c=f[1]}if(""==c)return d}function j(a,b,c,d,e){for(var g=[],h=[],i=[],j=f(d.length,e.length),k=0;k<j;k++){var l=b(d[k%d.length],e[k%e.length]);if(!l)return;g.push(l[0]),h.push(l[1]),i.push(l[2])}return[g,h,function(b){var d=b.map(function(a,b){return i[b](a)}).join(c);return a?a(d):d}]}function k(a,b,c){for(var d=[],e=[],f=[],g=0,h=0;h<c.length;h++)if("function"==typeof c[h]){var i=c[h](a[g],b[g++]);d.push(i[0]),e.push(i[1]),f.push(i[2])}else!function(a){d.push(!1),e.push(!1),f.push(function(){return c[a]})}(h);return[d,e,function(a){for(var b="",c=0;c<a.length;c++)b+=f[c](a[c]);return b}]}a.consumeToken=b,a.consumeTrimmed=c,a.consumeRepeated=d,a.consumeParenthesised=e,a.ignore=g,a.optional=h,a.consumeList=i,a.mergeNestedRepeated=j.bind(null,null),a.mergeWrappedNestedRepeated=j,a.mergeList=k}(d),function(a){function b(b){function c(b){var c=a.consumeToken(/^inset/i,b);if(c)return d.inset=!0,c;var c=a.consumeLengthOrPercent(b);if(c)return d.lengths.push(c[0]),c;var c=a.consumeColor(b);return c?(d.color=c[0],c):void 0}var d={inset:!1,lengths:[],color:null},e=a.consumeRepeated(c,/^/,b);if(e&&e[0].length)return[d,e[1]]}function c(c){var d=a.consumeRepeated(b,/^,/,c);if(d&&""==d[1])return d[0]}function d(b,c){for(;b.lengths.length<Math.max(b.lengths.length,c.lengths.length);)b.lengths.push({px:0});for(;c.lengths.length<Math.max(b.lengths.length,c.lengths.length);)c.lengths.push({px:0});if(b.inset==c.inset&&!!b.color==!!c.color){for(var d,e=[],f=[[],0],g=[[],0],h=0;h<b.lengths.length;h++){var i=a.mergeDimensions(b.lengths[h],c.lengths[h],2==h);f[0].push(i[0]),g[0].push(i[1]),e.push(i[2])}if(b.color&&c.color){var j=a.mergeColors(b.color,c.color);f[1]=j[0],g[1]=j[1],d=j[2];
}return[f,g,function(a){for(var c=b.inset?"inset ":" ",f=0;f<e.length;f++)c+=e[f](a[0][f])+" ";return d&&(c+=d(a[1])),c}]}}function e(b,c,d,e){function f(a){return{inset:a,color:[0,0,0,0],lengths:[{px:0},{px:0},{px:0},{px:0}]}}for(var g=[],h=[],i=0;i<d.length||i<e.length;i++){var j=d[i]||f(e[i].inset),k=e[i]||f(d[i].inset);g.push(j),h.push(k)}return a.mergeNestedRepeated(b,c,g,h)}var f=e.bind(null,d,", ");a.addPropertiesHandler(c,f,["box-shadow","text-shadow"])}(d),function(a,b){function c(a){return a.toFixed(3).replace(".000","")}function d(a,b,c){return Math.min(b,Math.max(a,c))}function e(a){if(/^\s*[-+]?(\d*\.)?\d+\s*$/.test(a))return Number(a)}function f(a,b){return[a,b,c]}function g(a,b){if(0!=a)return i(0,1/0)(a,b)}function h(a,b){return[a,b,function(a){return Math.round(d(1,1/0,a))}]}function i(a,b){return function(e,f){return[e,f,function(e){return c(d(a,b,e))}]}}function j(a,b){return[a,b,Math.round]}a.clamp=d,a.addPropertiesHandler(e,i(0,1/0),["border-image-width","line-height"]),a.addPropertiesHandler(e,i(0,1),["opacity","shape-image-threshold"]),a.addPropertiesHandler(e,g,["flex-grow","flex-shrink"]),a.addPropertiesHandler(e,h,["orphans","widows"]),a.addPropertiesHandler(e,j,["z-index"]),a.parseNumber=e,a.mergeNumbers=f,a.numberToString=c}(d,f),function(a,b){function c(a,b){if("visible"==a||"visible"==b)return[0,1,function(c){return c<=0?a:c>=1?b:"visible"}]}a.addPropertiesHandler(String,c,["visibility"])}(d),function(a,b){function c(a){a=a.trim(),f.fillStyle="#000",f.fillStyle=a;var b=f.fillStyle;if(f.fillStyle="#fff",f.fillStyle=a,b==f.fillStyle){f.fillRect(0,0,1,1);var c=f.getImageData(0,0,1,1).data;f.clearRect(0,0,1,1);var d=c[3]/255;return[c[0]*d,c[1]*d,c[2]*d,d]}}function d(b,c){return[b,c,function(b){function c(a){return Math.max(0,Math.min(255,a))}if(b[3])for(var d=0;d<3;d++)b[d]=Math.round(c(b[d]/b[3]));return b[3]=a.numberToString(a.clamp(0,1,b[3])),"rgba("+b.join(",")+")"}]}var e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");e.width=e.height=1;var f=e.getContext("2d");a.addPropertiesHandler(c,d,["background-color","border-bottom-color","border-left-color","border-right-color","border-top-color","color","outline-color","text-decoration-color"]),a.consumeColor=a.consumeParenthesised.bind(null,c),a.mergeColors=d}(d,f),function(a,b){function c(a,b){if(b=b.trim().toLowerCase(),"0"==b&&"px".search(a)>=0)return{px:0};if(/^[^(]*$|^calc/.test(b)){b=b.replace(/calc\(/g,"(");var c={};b=b.replace(a,function(a){return c[a]=null,"U"+a});for(var d="U("+a.source+")",e=b.replace(/[-+]?(\d*\.)?\d+/g,"N").replace(new RegExp("N"+d,"g"),"D").replace(/\s[+-]\s/g,"O").replace(/\s/g,""),f=[/N\*(D)/g,/(N|D)[*\/]N/g,/(N|D)O\1/g,/\((N|D)\)/g],g=0;g<f.length;)f[g].test(e)?(e=e.replace(f[g],"$1"),g=0):g++;if("D"==e){for(var h in c){var i=eval(b.replace(new RegExp("U"+h,"g"),"").replace(new RegExp(d,"g"),"*0"));if(!isFinite(i))return;c[h]=i}return c}}}function d(a,b){return e(a,b,!0)}function e(b,c,d){var e,f=[];for(e in b)f.push(e);for(e in c)f.indexOf(e)<0&&f.push(e);return b=f.map(function(a){return b[a]||0}),c=f.map(function(a){return c[a]||0}),[b,c,function(b){var c=b.map(function(c,e){return 1==b.length&&d&&(c=Math.max(c,0)),a.numberToString(c)+f[e]}).join(" + ");return b.length>1?"calc("+c+")":c}]}var f="px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc",g=c.bind(null,new RegExp(f,"g")),h=c.bind(null,new RegExp(f+"|%","g")),i=c.bind(null,/deg|rad|grad|turn/g);a.parseLength=g,a.parseLengthOrPercent=h,a.consumeLengthOrPercent=a.consumeParenthesised.bind(null,h),a.parseAngle=i,a.mergeDimensions=e;var j=a.consumeParenthesised.bind(null,g),k=a.consumeRepeated.bind(void 0,j,/^/),l=a.consumeRepeated.bind(void 0,k,/^,/);a.consumeSizePairList=l;var m=function(a){var b=l(a);if(b&&""==b[1])return b[0]},n=a.mergeNestedRepeated.bind(void 0,d," "),o=a.mergeNestedRepeated.bind(void 0,n,",");a.mergeNonNegativeSizePair=n,a.addPropertiesHandler(m,o,["background-size"]),a.addPropertiesHandler(h,d,["border-bottom-width","border-image-width","border-left-width","border-right-width","border-top-width","flex-basis","font-size","height","line-height","max-height","max-width","outline-width","width"]),a.addPropertiesHandler(h,e,["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius","bottom","left","letter-spacing","margin-bottom","margin-left","margin-right","margin-top","min-height","min-width","outline-offset","padding-bottom","padding-left","padding-right","padding-top","perspective","right","shape-margin","text-indent","top","vertical-align","word-spacing"])}(d,f),function(a,b){function c(b){return a.consumeLengthOrPercent(b)||a.consumeToken(/^auto/,b)}function d(b){var d=a.consumeList([a.ignore(a.consumeToken.bind(null,/^rect/)),a.ignore(a.consumeToken.bind(null,/^\(/)),a.consumeRepeated.bind(null,c,/^,/),a.ignore(a.consumeToken.bind(null,/^\)/))],b);if(d&&4==d[0].length)return d[0]}function e(b,c){return"auto"==b||"auto"==c?[!0,!1,function(d){var e=d?b:c;if("auto"==e)return"auto";var f=a.mergeDimensions(e,e);return f[2](f[0])}]:a.mergeDimensions(b,c)}function f(a){return"rect("+a+")"}var g=a.mergeWrappedNestedRepeated.bind(null,f,e,", ");a.parseBox=d,a.mergeBoxes=g,a.addPropertiesHandler(d,g,["clip"])}(d,f),function(a,b){function c(a){return function(b){var c=0;return a.map(function(a){return a===k?b[c++]:a})}}function d(a){return a}function e(b){if(b=b.toLowerCase().trim(),"none"==b)return[];for(var c,d=/\s*(\w+)\(([^)]*)\)/g,e=[],f=0;c=d.exec(b);){if(c.index!=f)return;f=c.index+c[0].length;var g=c[1],h=n[g];if(!h)return;var i=c[2].split(","),j=h[0];if(j.length<i.length)return;for(var k=[],o=0;o<j.length;o++){var p,q=i[o],r=j[o];if(p=q?{A:function(b){return"0"==b.trim()?m:a.parseAngle(b)},N:a.parseNumber,T:a.parseLengthOrPercent,L:a.parseLength}[r.toUpperCase()](q):{a:m,n:k[0],t:l}[r],void 0===p)return;k.push(p)}if(e.push({t:g,d:k}),d.lastIndex==b.length)return e}}function f(a){return a.toFixed(6).replace(".000000","")}function g(b,c){if(b.decompositionPair!==c){b.decompositionPair=c;var d=a.makeMatrixDecomposition(b)}if(c.decompositionPair!==b){c.decompositionPair=b;var e=a.makeMatrixDecomposition(c)}return null==d[0]||null==e[0]?[[!1],[!0],function(a){return a?c[0].d:b[0].d}]:(d[0].push(0),e[0].push(1),[d,e,function(b){var c=a.quat(d[0][3],e[0][3],b[5]),g=a.composeMatrix(b[0],b[1],b[2],c,b[4]),h=g.map(f).join(",");return h}])}function h(a){return a.replace(/[xy]/,"")}function i(a){return a.replace(/(x|y|z|3d)?$/,"3d")}function j(b,c){var d=a.makeMatrixDecomposition&&!0,e=!1;if(!b.length||!c.length){b.length||(e=!0,b=c,c=[]);for(var f=0;f<b.length;f++){var j=b[f].t,k=b[f].d,l="scale"==j.substr(0,5)?1:0;c.push({t:j,d:k.map(function(a){if("number"==typeof a)return l;var b={};for(var c in a)b[c]=l;return b})})}}var m=function(a,b){return"perspective"==a&&"perspective"==b||("matrix"==a||"matrix3d"==a)&&("matrix"==b||"matrix3d"==b)},o=[],p=[],q=[];if(b.length!=c.length){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]]}else for(var f=0;f<b.length;f++){var j,s=b[f].t,t=c[f].t,u=b[f].d,v=c[f].d,w=n[s],x=n[t];if(m(s,t)){if(!d)return;var r=g([b[f]],[c[f]]);o.push(r[0]),p.push(r[1]),q.push(["matrix",[r[2]]])}else{if(s==t)j=s;else if(w[2]&&x[2]&&h(s)==h(t))j=h(s),u=w[2](u),v=x[2](v);else{if(!w[1]||!x[1]||i(s)!=i(t)){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]];break}j=i(s),u=w[1](u),v=x[1](v)}for(var y=[],z=[],A=[],B=0;B<u.length;B++){var C="number"==typeof u[B]?a.mergeNumbers:a.mergeDimensions,r=C(u[B],v[B]);y[B]=r[0],z[B]=r[1],A.push(r[2])}o.push(y),p.push(z),q.push([j,A])}}if(e){var D=o;o=p,p=D}return[o,p,function(a){return a.map(function(a,b){var c=a.map(function(a,c){return q[b][1][c](a)}).join(",");return"matrix"==q[b][0]&&16==c.split(",").length&&(q[b][0]="matrix3d"),q[b][0]+"("+c+")"}).join(" ")}]}var k=null,l={px:0},m={deg:0},n={matrix:["NNNNNN",[k,k,0,0,k,k,0,0,0,0,1,0,k,k,0,1],d],matrix3d:["NNNNNNNNNNNNNNNN",d],rotate:["A"],rotatex:["A"],rotatey:["A"],rotatez:["A"],rotate3d:["NNNA"],perspective:["L"],scale:["Nn",c([k,k,1]),d],scalex:["N",c([k,1,1]),c([k,1])],scaley:["N",c([1,k,1]),c([1,k])],scalez:["N",c([1,1,k])],scale3d:["NNN",d],skew:["Aa",null,d],skewx:["A",null,c([k,m])],skewy:["A",null,c([m,k])],translate:["Tt",c([k,k,l]),d],translatex:["T",c([k,l,l]),c([k,l])],translatey:["T",c([l,k,l]),c([l,k])],translatez:["L",c([l,l,k])],translate3d:["TTL",d]};a.addPropertiesHandler(e,j,["transform"])}(d,f),function(a){function b(a){var b=Number(a);if(!(isNaN(b)||b<100||b>900||b%100!==0))return b}function c(b){return b=100*Math.round(b/100),b=a.clamp(100,900,b),400===b?"normal":700===b?"bold":String(b)}function d(a,b){return[a,b,c]}a.addPropertiesHandler(b,d,["font-weight"])}(d),function(a){function b(a){var b={};for(var c in a)b[c]=-a[c];return b}function c(b){return a.consumeToken(/^(left|center|right|top|bottom)\b/i,b)||a.consumeLengthOrPercent(b)}function d(b,d){var e=a.consumeRepeated(c,/^/,d);if(e&&""==e[1]){var f=e[0];if(f[0]=f[0]||"center",f[1]=f[1]||"center",3==b&&(f[2]=f[2]||{px:0}),f.length==b){if(/top|bottom/.test(f[0])||/left|right/.test(f[1])){var h=f[0];f[0]=f[1],f[1]=h}if(/left|right|center|Object/.test(f[0])&&/top|bottom|center|Object/.test(f[1]))return f.map(function(a){return"object"==typeof a?a:g[a]})}}}function e(d){var e=a.consumeRepeated(c,/^/,d);if(e){for(var f=e[0],h=[{"%":50},{"%":50}],i=0,j=!1,k=0;k<f.length;k++){var l=f[k];"string"==typeof l?(j=/bottom|right/.test(l),i={left:0,right:0,center:i,top:1,bottom:1}[l],h[i]=g[l],"center"==l&&i++):(j&&(l=b(l),l["%"]=(l["%"]||0)+100),h[i]=l,i++,j=!1)}return[h,e[1]]}}function f(b){var c=a.consumeRepeated(e,/^,/,b);if(c&&""==c[1])return c[0]}var g={left:{"%":0},center:{"%":50},right:{"%":100},top:{"%":0},bottom:{"%":100}},h=a.mergeNestedRepeated.bind(null,a.mergeDimensions," ");a.addPropertiesHandler(d.bind(null,3),h,["transform-origin"]),a.addPropertiesHandler(d.bind(null,2),h,["perspective-origin"]),a.consumePosition=e,a.mergeOffsetList=h;var i=a.mergeNestedRepeated.bind(null,h,", ");a.addPropertiesHandler(f,i,["background-position","object-position"])}(d),function(a){function b(b){var c=a.consumeToken(/^circle/,b);if(c&&c[0])return["circle"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),d,a.ignore(a.consumeToken.bind(void 0,/^at/)),a.consumePosition,a.ignore(a.consumeToken.bind(void 0,/^\)/))],c[1]));var f=a.consumeToken(/^ellipse/,b);if(f&&f[0])return["ellipse"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),e,a.ignore(a.consumeToken.bind(void 0,/^at/)),a.consumePosition,a.ignore(a.consumeToken.bind(void 0,/^\)/))],f[1]));var g=a.consumeToken(/^polygon/,b);return g&&g[0]?["polygon"].concat(a.consumeList([a.ignore(a.consumeToken.bind(void 0,/^\(/)),a.optional(a.consumeToken.bind(void 0,/^nonzero\s*,|^evenodd\s*,/),"nonzero,"),a.consumeSizePairList,a.ignore(a.consumeToken.bind(void 0,/^\)/))],g[1])):void 0}function c(b,c){if(b[0]===c[0])return"circle"==b[0]?a.mergeList(b.slice(1),c.slice(1),["circle(",a.mergeDimensions," at ",a.mergeOffsetList,")"]):"ellipse"==b[0]?a.mergeList(b.slice(1),c.slice(1),["ellipse(",a.mergeNonNegativeSizePair," at ",a.mergeOffsetList,")"]):"polygon"==b[0]&&b[1]==c[1]?a.mergeList(b.slice(2),c.slice(2),["polygon(",b[1],g,")"]):void 0}var d=a.consumeParenthesised.bind(null,a.parseLengthOrPercent),e=a.consumeRepeated.bind(void 0,d,/^/),f=a.mergeNestedRepeated.bind(void 0,a.mergeDimensions," "),g=a.mergeNestedRepeated.bind(void 0,f,",");a.addPropertiesHandler(b,c,["shape-outside"])}(d),function(a,b){function c(a,b){b.concat([a]).forEach(function(b){b in document.documentElement.style&&(d[a]=b)})}var d={};c("transform",["webkitTransform","msTransform"]),c("transformOrigin",["webkitTransformOrigin"]),c("perspective",["webkitPerspective"]),c("perspectiveOrigin",["webkitPerspectiveOrigin"]),a.propertyName=function(a){return d[a]||a}}(d,f)}(),!function(){if(void 0===document.createElement("div").animate([]).oncancel){var a;if(window.performance&&performance.now)var a=function(){return performance.now()};else var a=function(){return Date.now()};var b=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="cancel",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()},c=window.Element.prototype.animate;window.Element.prototype.animate=function(d,e){var f=c.call(this,d,e);f._cancelHandlers=[],f.oncancel=null;var g=f.cancel;f.cancel=function(){g.call(this);var c=new b(this,null,a()),d=this._cancelHandlers.concat(this.oncancel?[this.oncancel]:[]);setTimeout(function(){d.forEach(function(a){a.call(c.target,c)})},0)};var h=f.addEventListener;f.addEventListener=function(a,b){"function"==typeof b&&"cancel"==a?this._cancelHandlers.push(b):h.call(this,a,b)};var i=f.removeEventListener;return f.removeEventListener=function(a,b){if("cancel"==a){var c=this._cancelHandlers.indexOf(b);c>=0&&this._cancelHandlers.splice(c,1)}else i.call(this,a,b)},f}}}(),function(a){var b=document.documentElement,c=null,d=!1;try{var e=getComputedStyle(b).getPropertyValue("opacity"),f="0"==e?"1":"0";c=b.animate({opacity:[f,f]},{duration:1}),c.currentTime=0,d=getComputedStyle(b).getPropertyValue("opacity")==f}catch(a){}finally{c&&c.cancel()}if(!d){var g=window.Element.prototype.animate;window.Element.prototype.animate=function(b,c){return window.Symbol&&Symbol.iterator&&Array.prototype.from&&b[Symbol.iterator]&&(b=Array.from(b)),Array.isArray(b)||null===b||(b=a.convertToArrayForm(b)),g.call(this,b,c)}}}(c),b.true=a}({},function(){return this}());

},{}],165:[function(require,module,exports){
(function (global){
'use strict';

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
};

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof2(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/*
 * Copyright (c) 2016 Florian Klampfer
 * Licensed under MIT
 */

// const JS_FEATURES = [
//   'fn/array/for-each',
//   'fn/function/bind',
//   'fn/number/constructor',
//   'fn/object/assign',
//   'fn/object/define-property',
//   'fn/object/keys',
// ];

// const MODERNIZR_TESTS = [
//   'customevent',
// ];

var Mix = function Mix() {
  _classCallCheck(this, Mix);
};

var _Symbol = global.Symbol || function (x) {
  return '_' + x;
};

var def = Object.defineProperty.bind(Object);

var ROOT = _Symbol('root');
var STATE = _Symbol('state');

function createEvent(eventName) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  try {
    return new CustomEvent(eventName, data);
  } catch (e) {
    var event = document.createEvent('CustomEvent');
    event.initCustomEvent(eventName, true, true, data.detail);
    return event;
  }
}

function setupProperty(key, sideEffect) {
  var _this = this;

  def(this, key, {
    enumerable: true,
    get: function get() {
      return _this[STATE][key];
    },
    set: function set(value) {
      if (sideEffect != null) {
        sideEffect(value);
      } else {
        _this.setState(key, value);
      }
    }
  });
}

// TODO: study how native elements deal with attributes/properites
function setupProperties() {
  var _this2 = this;

  var sideEffects = this.sideEffects();

  Object.keys(this[STATE]).forEach(function (key) {
    if (typeof _this2[key] === 'undefined') {
      var sideEffect = sideEffects[key];
      setupProperty.call(_this2, key, sideEffect);
    }
  });
}

exports.default = function () {
  var C = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Mix;
  return function (_C) {
    _inherits(_class, _C);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'getComponentName',
      value: function getComponentName() {
        throw Error('Component needs to have a name, e.g. `my-tag`. Override `getComponentName`');
      }
    }, {
      key: 'setupComponent',
      value: function setupComponent(el, state) {
        def(this, STATE, { value: Object.assign({}, this.defaults(), state) });
        setupProperties.call(this);
        def(this, ROOT, { value: this.setupDOM(el) });
        return this;
      }
    }, {
      key: 'setupDOM',
      value: function setupDOM(el) {
        return el;
      }
    }, {
      key: 'getRoot',
      value: function getRoot() {
        return this[ROOT];
      }
    }, {
      key: 'getEl',
      value: function getEl() {
        return this[ROOT];
      }
    }, {
      key: 'fireEvent',
      value: function fireEvent(eventName, data) {
        var eventNameNS = this.componentName + '-' + eventName;
        this.el.dispatchEvent(createEvent(eventNameNS, data));
      }
    }, {
      key: 'defaults',
      value: function defaults() {
        // TODO: production builds with preprocess?
        console.warn('defaults not provided'); // eslint-disable-line no-console
        return {};
      }
    }, {
      key: 'sideEffects',
      value: function sideEffects() {
        // TODO: production builds with preprocess?
        console.warn('sideEffects not provided'); // eslint-disable-line no-console
        return {};
      }
    }, {
      key: 'setState',
      value: function setState(keyOrMap, value) {
        if (typeof keyOrMap === 'string') {
          this.setStateKV(keyOrMap, value);
        } else if ((typeof keyOrMap === 'undefined' ? 'undefined' : _typeof(keyOrMap)) === 'object') {
          this.setStateMap(keyOrMap);
        } else {
          throw Error('setState needs argument');
        }
      }
    }, {
      key: 'setStateKV',
      value: function setStateKV(key, value) {
        this[STATE][key] = value;
      }
    }, {
      key: 'setStateMap',
      value: function setStateMap(map) {
        var _this4 = this;

        Object.keys(this[STATE]).forEach(function (key) {
          _this4.setStateKV(key, map[key]);
        });
      }
    }, {
      key: 'componentName',
      get: function get() {
        return this.getComponentName();
      }
    }, {
      key: 'root',
      get: function get() {
        return this.getRoot();
      }
    }, {
      key: 'el',
      get: function get() {
        return this.getEl();
      }
    }]);

    return _class;
  }(C);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],166:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
  * @param t current time
  * @param b start value
  * @param c change in value
  * @param d duration
  * @returns {number}
  */
function linearTween(t, b, c, d) {
  return c * t / d + b;
}

function pageDist(p1, p2) {
  return Math.sqrt(Math.pow(p1.pageX - p2.pageX, 2) + Math.pow(p1.pageY - p2.pageY, 2));
}

function contains(target, className) {
  var t = target;
  while (t != null) {
    if (t.classList && t.classList.contains(className)) {
      return true;
    }
    t = t.parentNode;
  }
  return false;
}

exports.linearTween = linearTween;
exports.pageDist = pageDist;
exports.contains = contains;

},{}],167:[function(require,module,exports){
(function (global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _get = function get(object, property, receiver) {
  if (object === null) object = Function.prototype;var desc = Object.getOwnPropertyDescriptor(object, property);if (desc === undefined) {
    var parent = Object.getPrototypeOf(object);if (parent === null) {
      return undefined;
    } else {
      return get(parent, property, receiver);
    }
  } else if ("value" in desc) {
    return desc.value;
  } else {
    var getter = desc.get;if (getter === undefined) {
      return undefined;
    }return getter.call(receiver);
  }
};

var _componentCore2 = require('y-component/src/component-core');

var _componentCore3 = _interopRequireDefault(_componentCore2);

var _common = require('../common');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /*
   * Adapted from Ratchet's sliders.js
   * http://goratchet.com/components#sliders
   *
   * Adapted from Brad Birdsall's Swipe
   * https://github.com/thebird/Swipe
   *
   * Copyright (c) 2016 Florian Klampfer
   * Licensed under MIT
   */
/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

// const JS_FEATURES = [
//   'fn/array/for-each',
//   'fn/function/bind',
//   'fn/number/constructor',
//   'fn/object/assign',
//   'fn/object/define-property',
//   'fn/object/keys',
//   'fn/array/reduce',
// ];
//
// const MODERNIZR_TESTS = [
//   'customevent',
//   'eventlistener',
//   'queryselector',
//   'requestanimationframe',
//   'classlist',
//   'opacity',
//   'csstransforms',
//   'csspointerevents',
// ];

var _Symbol = global.Symbol || function (x) {
  return '_' + x;
};

var IDLE = _Symbol('idle');
var TOUCHING = _Symbol('touching');
var START_ANIMATING = _Symbol('startAnimating');
var ANIMATING = _Symbol('animating');

var VELOCITY_THRESHOLD = 0.2;
var VELOCITY_LINEAR_COMBINATION = 0.8;

var def = Object.defineProperty.bind(Object);

exports.default = function (C) {
  return function (_componentCore) {
    _inherits(_class, _componentCore);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'getComponentName',

      // @override
      value: function getComponentName() {
        return 'y-drawer';
      }

      // @override

    }, {
      key: 'defaults',
      value: function defaults() {
        return {
          opened: false,
          transitionDuration: 200,
          persistent: false
        };
      }

      // @override

    }, {
      key: 'sideEffects',
      value: function sideEffects() {
        var _this2 = this;

        return {
          opened: function opened(o) {
            if (o === true) _this2.open();else _this2.close();
          },
          persistent: function persistent(d) {
            if (d === true) _this2.persist();else _this2.unpersist();
          }
        };
      }

      // @override

    }, {
      key: 'setupComponent',
      value: function setupComponent(el, props) {
        _get(_class.prototype.__proto__ || Object.getPrototypeOf(_class.prototype), 'setupComponent', this).call(this, el, props);

        this.cacheDOMElements();
        this.defProperties();
        this.bindCallbacks();

        this.jumpTo(this.opened);
        if (!this.persistent) this.addEventListeners();
        if (this.persistent) this.scrim.style.display = 'none';

        return this;
      }
    }, {
      key: 'cacheDOMElements',
      value: function cacheDOMElements() {
        def(this, 'scrim', { value: this.root.querySelector('.y-drawer-scrim') });
        def(this, 'content', { value: this.root.querySelector('.y-drawer-content') });
      }
    }, {
      key: 'defProperties',
      value: function defProperties() {
        def(this, 'startX', { value: 0, writable: true });
        def(this, 'startY', { value: 0, writable: true });
        def(this, 'pageX', { value: 0, writable: true });
        def(this, 'pageY', { value: 0, writable: true });
        def(this, 'lastPageX', { value: 0, writable: true });
        def(this, 'lastPageY', { value: 0, writable: true });
        def(this, 'isScrolling', { writable: true });
        def(this, 'startedMoving', { value: false, writable: true });
        def(this, 'loopState', { value: IDLE, writable: true });
        def(this, 'velocity', { value: 0, writable: true });
        def(this, 'startTranslateX', { value: 0, writable: true });
        def(this, 'translateX', { value: 0, writable: true });
        def(this, 'animationFrameRequested', { value: false, writable: true });
        def(this, 'touching', { value: false, writable: true });
        def(this, 'lastTime', { writable: true });
        def(this, 'sliderWidth', { writable: true });
        def(this, 'animation', { writable: true, configurable: true });
      }
    }, {
      key: 'bindCallbacks',
      value: function bindCallbacks() {
        def(this, 'touchStartCallback', { value: this.touchStartCallback.bind(this) });
        def(this, 'touchMoveCallback', { value: this.touchMoveCallback.bind(this) });
        def(this, 'touchEndCallback', { value: this.touchEndCallback.bind(this) });
        def(this, 'scrimClickCallback', { value: this.scrimClickCallback.bind(this) });
        def(this, 'animationFrameCallback', { value: this.animationFrameCallback.bind(this) });
      }
    }, {
      key: 'addEventListeners',
      value: function addEventListeners() {
        document.addEventListener('touchstart', this.touchStartCallback, { passive: false });
        document.addEventListener('touchmove', this.touchMoveCallback, { passive: false });
        document.addEventListener('touchend', this.touchEndCallback, { passive: false });

        this.scrim.addEventListener('click', this.scrimClickCallback);
      }
    }, {
      key: 'removeEventListeners',
      value: function removeEventListeners() {
        document.removeEventListener('touchstart', this.touchStartCallback, { passive: false });
        document.removeEventListener('touchmove', this.touchMoveCallback, { passive: false });
        document.removeEventListener('touchend', this.touchEndCallback, { passive: false });

        this.scrim.removeEventListener('click', this.scrimClickCallback);
      }
    }, {
      key: 'requestAnimationLoop',
      value: function requestAnimationLoop() {
        if (!this.animationFrameRequested) {
          this.animationFrameRequested = true;
          requestAnimationFrame(this.animationFrameCallback);
        }
      }
    }, {
      key: 'getNearestTouch',
      value: function getNearestTouch(touches) {
        var _this3 = this;

        if (touches.length === 1) return touches[0];
        return Array.prototype.reduce.call(touches, function (acc, touch) {
          var dist = (0, _common.pageDist)(_this3, touch);
          return dist < acc.dist ? {
            dist: dist,
            touch: touch
          } : acc;
        }, {
          dist: Number.POSITIVE_INFINITY,
          touch: null
        }).touch;
      }
    }, {
      key: 'touchStartCallback',
      value: function touchStartCallback(e) {
        if (e.touches.length === 1) {
          this.isScrolling = undefined;

          var touch = e.touches[0];
          this.startX = touch.pageX;
          this.startY = touch.pageY;
          this.pageX = touch.pageX;
          this.pageY = touch.pageY;
          this.lastPageX = touch.pageX;
          this.lastPageY = touch.pageY;

          if (this.opened || this.pageX < window.innerWidth / 3) {
            this.prepInteraction();
            this.touching = true;
            this.loopState = TOUCHING;
          }
        }
      }
    }, {
      key: 'touchMoveCallback',
      value: function touchMoveCallback(e) {
        if (this.touching) {
          var touch = this.getNearestTouch(e.touches);
          this.pageX = touch.pageX;
          this.pageY = touch.pageY;

          if (typeof this.isScrolling === 'undefined' && this.startedMoving) {
            this.isScrolling = Math.abs(this.startY - this.pageY) > Math.abs(this.startX - this.pageX);
            if (!this.isScrolling) {
              this.loopState = TOUCHING;
              this.requestAnimationLoop();
            }
          }

          if (this.isScrolling) {
            return;
          }

          e.preventDefault();

          this.startedMoving = true;
        }
      }
    }, {
      key: 'updateMenuOpen',
      value: function updateMenuOpen() {
        if (this.velocity > VELOCITY_THRESHOLD) {
          this.setState('opened', true);
        } else if (this.velocity < -VELOCITY_THRESHOLD) {
          this.setState('opened', false);
        } else if (this.translateX >= this.sliderWidth / 2) {
          this.setState('opened', true);
        } else {
          this.setState('opened', false);
        }
      }
    }, {
      key: 'touchEndCallback',
      value: function touchEndCallback(e) {
        if (this.touching) {
          if (this.isScrolling || e.touches.length > 0) {
            return;
          }

          if (this.startedMoving) {
            this.updateMenuOpen();
          }

          if (this.opened) {
            this.scrim.style.pointerEvents = 'all';
          } else {
            this.scrim.style.pointerEvents = '';
          }

          this.loopState = START_ANIMATING;
          this.startedMoving = false;
          this.touching = false;
        }
      }
    }, {
      key: 'scrimClickCallback',
      value: function scrimClickCallback() {
        this.close();
      }
    }, {
      key: 'prepInteraction',
      value: function prepInteraction() {
        this.content.style.willChange = 'transform';
        this.scrim.style.willChange = 'opacity';
        this.content.classList.remove('y-drawer-opened');
        this.sliderWidth = this.getMovableSliderWidth();
      }
    }, {
      key: 'getMovableSliderWidth',
      value: function getMovableSliderWidth() {
        // Since part of the slider could be visible,
        // the width that is "movable" is less than the complete slider width
        // and given by
        return -this.content.offsetLeft;
      }
    }, {
      key: 'animateTo',
      value: function animateTo(opened) {
        this.prepInteraction();
        this.setState('opened', opened);
        this.loopState = START_ANIMATING;
        this.requestAnimationLoop();
      }
    }, {
      key: 'jumpTo',
      value: function jumpTo(opened) {
        this.prepInteraction();
        this.setState('opened', opened);
        this.loopState = IDLE;
        this.startTranslateX = opened * this.sliderWidth;
        this.endAnimating();
        this.updateDOM(this.startTranslateX, this.sliderWidth);
      }
    }, {
      key: 'updateTranslateX',
      value: function updateTranslateX() {
        var deltaX = this.pageX - this.startX;
        this.translateX = this.startTranslateX + deltaX;
        this.translateX = Math.max(0, Math.min(this.sliderWidth, this.translateX));
        return deltaX;
      }
    }, {
      key: 'animationFrameCallback',
      value: function animationFrameCallback(time) {
        switch (this.loopState) {
          case TOUCHING:
            {
              this.touchingFrame(time);
              break;
            }

          case START_ANIMATING:
            {
              this.startAnimatingFrame(time);
              this.loopState = ANIMATING;
              this.animationFrameCallback(time); // jump to next case block
              break;
            }

          case ANIMATING:
            {
              this.animatingFrame(time);
              break;
            }

          default:
            {
              break;
            }
        }
      }
    }, {
      key: 'touchingFrame',
      value: function touchingFrame(time) {
        var timeDiff = time - this.lastTime;

        if (timeDiff > 0) {
          var pageXDiff = this.pageX - this.lastPageX;
          this.velocity = VELOCITY_LINEAR_COMBINATION * (pageXDiff / timeDiff) + (1 - VELOCITY_LINEAR_COMBINATION) * this.velocity;
        }

        this.updateTranslateX();
        this.updateDOM(this.translateX, this.sliderWidth);

        this.lastTime = time;
        this.lastPageX = this.pageX;
        this.lastPageY = this.pageY;

        requestAnimationFrame(this.animationFrameCallback);
      }
    }, {
      key: 'startAnimatingFrame',
      value: function startAnimatingFrame(time) {
        this.updateTranslateX();

        // store all animation related data in this object,
        // delete after animation is completed
        var animation = {};
        animation.startX = this.translateX;
        animation.endX = (this.opened ? 1 : 0) * this.sliderWidth;
        animation.changeInValue = animation.endX - animation.startX;
        animation.startTime = time;
        this.animation = animation;
      }
    }, {
      key: 'animatingFrame',
      value: function animatingFrame(time) {
        var timeInAnimation = time - this.animation.startTime;

        if (timeInAnimation < this.transitionDuration) {
          this.animatingCont(timeInAnimation);
        } else {
          this.animatingEnd();
        }

        this.updateDOM(this.startTranslateX, this.sliderWidth);
      }
    }, {
      key: 'animatingCont',
      value: function animatingCont(timeInAnimation) {
        var startValue = this.animation.startX;
        var changeInValue = this.animation.changeInValue;
        this.startTranslateX = (0, _common.linearTween)(timeInAnimation, startValue, changeInValue, this.transitionDuration);
        requestAnimationFrame(this.animationFrameCallback);
      }
    }, {
      key: 'animatingEnd',
      value: function animatingEnd() {
        // end animation
        this.startTranslateX = this.animation.endX;
        delete this.animation;
        this.endAnimating();
      }
    }, {
      key: 'endAnimating',
      value: function endAnimating() {
        this.animationFrameRequested = false;
        this.loopState = IDLE;
        this.velocity = 0;

        if (this.opened) {
          // document.body.style.overflowY = 'hidden';
          this.scrim.style.pointerEvents = 'all';
          this.content.classList.add('y-drawer-opened');
        } else {
          // document.body.style.overflowY = '';
          this.scrim.style.pointerEvents = '';
        }

        this.content.style.willChange = '';
        this.scrim.style.willChange = '';

        this.fireEvent('transitioned');
      }
    }, {
      key: 'updateDOM',
      value: function updateDOM(translateX, sliderWidth) {
        this.content.style.transform = 'translateX(' + translateX + 'px)';
        this.scrim.style.opacity = translateX / sliderWidth;
      }
    }, {
      key: 'close',
      value: function close() {
        this.animateTo(false);
        return this;
      }
    }, {
      key: 'open',
      value: function open() {
        this.animateTo(true);
        return this;
      }
    }, {
      key: 'toggle',
      value: function toggle() {
        if (this.opened) {
          this.close();
        } else {
          this.open();
        }
        return this;
      }
    }, {
      key: 'persist',
      value: function persist() {
        this.scrim.style.display = 'none';
        this.removeEventListeners();
        this.setState('persistent', true);
      }
    }, {
      key: 'unpersist',
      value: function unpersist() {
        this.scrim.style.display = '';
        this.addEventListeners();
        this.setState('persistent', false);
      }
    }]);

    return _class;
  }((0, _componentCore3.default)(C));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../common":166,"y-component/src/component-core":165}],168:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /*
   * Copyright (c) 2016 Florian Klampfer
   * Licensed under MIT
   */

/* eslint-disable import/no-extraneous-dependencies, import/no-unresolved, import/extensions */

var style = '\n<style>\n@media screen {\n  .y-drawer-scrim {\n    display: block;\n    position: fixed;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    opacity: 0;\n    z-index: 0;\n    pointer-events: none;\n    transform: translate3d(0,0,0);\n    -webkit-tap-highlight-color: transparent;\n\n    background: rgba(0, 0, 0, 0.67);\n  }\n\n  .y-drawer-content {\n    position: fixed;\n    left: 0;\n    bottom: 0;\n    top: 0;\n    z-index: 1;\n    overflow-x: hidden;\n    overflow-y: auto;\n    transform: translate3d(0,0,0);\n    -webkit-overflow-scrolling: touch;\n    contain: strict;\n\n    left: -18rem;\n    width: 18rem;\n    background: #e8e8e8;\n  }\n\n  .y-drawer-content.y-drawer-opened {\n    left: 0!important;\n    transform: translate3d(0,0,0)!important;\n  }\n}\n\n@media print {\n  .y-drawer-scrim {\n    display: none!important;\n  }\n\n  .y-drawer-content {\n    transform: none!important;\n  }\n}\n\n</style>';

function fragmentFromString(strHTML) {
  return document.createRange().createContextualFragment(strHTML);
}

var Drawer = function (_drawerCore) {
  _inherits(Drawer, _drawerCore);

  function Drawer(el, props) {
    _classCallCheck(this, Drawer);

    var _this = _possibleConstructorReturn(this, (Drawer.__proto__ || Object.getPrototypeOf(Drawer)).call(this));

    _this.setupComponent(el, props);
    return _this;
  }

  // @override


  _createClass(Drawer, [{
    key: 'setupDOM',
    value: function setupDOM(el) {
      if (!el) throw Error('No element provided');

      var scrim = document.createElement('div');
      scrim.classList.add('y-drawer-scrim');

      var content = document.createElement('div');
      content.classList.add('y-drawer-content');
      while (el.children.length > 0) {
        content.appendChild(el.children[0]);
      }

      el.appendChild(scrim);
      el.appendChild(content);

      var ref = document.getElementsByTagName('style')[0];
      ref.parentNode.insertBefore(fragmentFromString(style), ref);

      return el;
    }
  }]);

  return Drawer;
}((0, _core2.default)());

exports.default = Drawer;

},{"../core":167}],169:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        _super.call(this);
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber);
exports.InnerSubscriber = InnerSubscriber;


},{"./Subscriber":177}],170:[function(require,module,exports){
"use strict";

var Observable_1 = require('./Observable');
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        } else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Observable_1.Observable.of(this.value);
            case 'E':
                return Observable_1.Observable.throw(this.error);
            case 'C':
                return Observable_1.Observable.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return this.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     */
    Notification.createComplete = function () {
        return this.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}();
exports.Notification = Notification;


},{"./Observable":171}],171:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"./symbol/observable":247,"./util/root":261,"./util/toSubscriber":263,"dup":107}],172:[function(require,module,exports){
"use strict";

exports.empty = {
    closed: true,
    next: function next(value) {},
    error: function error(err) {
        throw err;
    },
    complete: function complete() {}
};


},{}],173:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('./Subscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        _super.apply(this, arguments);
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber);
exports.OuterSubscriber = OuterSubscriber;


},{"./Subscriber":177}],174:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],175:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('./Observable');
var Subscriber_1 = require('./Subscriber');
var Subscription_1 = require('./Subscription');
var ObjectUnsubscribedError_1 = require('./util/ObjectUnsubscribedError');
var SubjectSubscription_1 = require('./SubjectSubscription');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        _super.call(this, destination);
        this.destination = destination;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber);
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = function (_super) {
    __extends(Subject, _super);
    function Subject() {
        _super.call(this);
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
    }
    Subject.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        } else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        } else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        } else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable);
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        _super.call(this);
        this.destination = destination;
        this.source = source;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        } else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject);
exports.AnonymousSubject = AnonymousSubject;


},{"./Observable":171,"./SubjectSubscription":176,"./Subscriber":177,"./Subscription":178,"./symbol/rxSubscriber":248,"./util/ObjectUnsubscribedError":250}],176:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('./Subscription');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        _super.call(this);
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription);
exports.SubjectSubscription = SubjectSubscription;


},{"./Subscription":178}],177:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isFunction_1 = require('./util/isFunction');
var Subscription_1 = require('./Subscription');
var Observer_1 = require('./Observer');
var rxSubscriber_1 = require('./symbol/rxSubscriber');
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        _super.call(this);
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
            case 0:
                this.destination = Observer_1.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    this.destination = Observer_1.empty;
                    break;
                }
                if ((typeof destinationOrNext === 'undefined' ? 'undefined' : _typeof(destinationOrNext)) === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        this.destination = destinationOrNext;
                        this.destination.add(this);
                    } else {
                        this.syncErrorThrowable = true;
                        this.destination = new SafeSubscriber(this, destinationOrNext);
                    }
                    break;
                }
            default:
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
                break;
        }
    }
    Subscriber.prototype[rxSubscriber_1.$$rxSubscriber] = function () {
        return this;
    };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription);
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        _super.call(this);
        this._parentSubscriber = _parentSubscriber;
        var next;
        var context = this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        } else if (observerOrNext) {
            context = observerOrNext;
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (isFunction_1.isFunction(context.unsubscribe)) {
                this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._error) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            } else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                throw err;
            } else {
                _parentSubscriber.syncErrorValue = err;
                _parentSubscriber.syncErrorThrown = true;
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                if (!_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._complete);
                    this.unsubscribe();
                } else {
                    this.__tryOrSetError(_parentSubscriber, this._complete);
                    this.unsubscribe();
                }
            } else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            this.unsubscribe();
            throw err;
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        try {
            fn.call(this._context, value);
        } catch (err) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber);


},{"./Observer":172,"./Subscription":178,"./symbol/rxSubscriber":248,"./util/isFunction":256}],178:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isArray_1 = require('./util/isArray');
var isObject_1 = require('./util/isObject');
var isFunction_1 = require('./util/isFunction');
var tryCatch_1 = require('./util/tryCatch');
var errorObject_1 = require('./util/errorObject');
var UnsubscriptionError_1 = require('./util/UnsubscriptionError');
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents,
            _unsubscribe = _a._unsubscribe,
            _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject_1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ? flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
            }
        }
        if (isArray_1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject_1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject_1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        } else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || teardown === Subscription.EMPTY) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown === 'undefined' ? 'undefined' : _typeof(teardown)) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                } else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                } else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                        var tmp = subscription;
                        subscription = new Subscription();
                        subscription._subscriptions = [tmp];
                    }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.prototype._addParent = function (parent) {
        var _a = this,
            _parent = _a._parent,
            _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        } else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        } else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    Subscription.EMPTY = function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription());
    return Subscription;
}();
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) {
        return errs.concat(err instanceof UnsubscriptionError_1.UnsubscriptionError ? err.errors : err);
    }, []);
}


},{"./util/UnsubscriptionError":251,"./util/errorObject":252,"./util/isArray":253,"./util/isFunction":256,"./util/isObject":258,"./util/tryCatch":264}],179:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var defer_1 = require('../../observable/defer');
Observable_1.Observable.defer = defer_1.defer;


},{"../../Observable":171,"../../observable/defer":212}],180:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../../Observable');
var ajax_1 = require('../../../observable/dom/ajax');
Observable_1.Observable.ajax = ajax_1.ajax;


},{"../../../Observable":171,"../../../observable/dom/ajax":214}],181:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var fromEvent_1 = require('../../observable/fromEvent');
Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;


},{"../../Observable":171,"../../observable/fromEvent":215}],182:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var merge_1 = require('../../observable/merge');
Observable_1.Observable.merge = merge_1.merge;


},{"../../Observable":171,"../../observable/merge":216}],183:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var of_1 = require('../../observable/of');
Observable_1.Observable.of = of_1.of;


},{"../../Observable":171,"../../observable/of":217}],184:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var throw_1 = require('../../observable/throw');
Observable_1.Observable.throw = throw_1._throw;


},{"../../Observable":171,"../../observable/throw":218}],185:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var timer_1 = require('../../observable/timer');
Observable_1.Observable.timer = timer_1.timer;


},{"../../Observable":171,"../../observable/timer":219}],186:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var catch_1 = require('../../operator/catch');
Observable_1.Observable.prototype.catch = catch_1._catch;
Observable_1.Observable.prototype._catch = catch_1._catch;


},{"../../Observable":171,"../../operator/catch":220}],187:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var debounceTime_1 = require('../../operator/debounceTime');
Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;


},{"../../Observable":171,"../../operator/debounceTime":222}],188:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var delay_1 = require('../../operator/delay');
Observable_1.Observable.prototype.delay = delay_1.delay;


},{"../../Observable":171,"../../operator/delay":223}],189:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var distinctUntilKeyChanged_1 = require('../../operator/distinctUntilKeyChanged');
Observable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;


},{"../../Observable":171,"../../operator/distinctUntilKeyChanged":225}],190:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var do_1 = require('../../operator/do');
Observable_1.Observable.prototype.do = do_1._do;
Observable_1.Observable.prototype._do = do_1._do;


},{"../../Observable":171,"../../operator/do":226}],191:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var filter_1 = require('../../operator/filter');
Observable_1.Observable.prototype.filter = filter_1.filter;


},{"../../Observable":171,"../../operator/filter":227}],192:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var map_1 = require('../../operator/map');
Observable_1.Observable.prototype.map = map_1.map;


},{"../../Observable":171,"../../operator/map":228}],193:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var mergeAll_1 = require('../../operator/mergeAll');
Observable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;


},{"../../Observable":171,"../../operator/mergeAll":230}],194:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var retryWhen_1 = require('../../operator/retryWhen');
Observable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;


},{"../../Observable":171,"../../operator/retryWhen":232}],195:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var share_1 = require('../../operator/share');
Observable_1.Observable.prototype.share = share_1.share;


},{"../../Observable":171,"../../operator/share":233}],196:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var startWith_1 = require('../../operator/startWith');
Observable_1.Observable.prototype.startWith = startWith_1.startWith;


},{"../../Observable":171,"../../operator/startWith":234}],197:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var switch_1 = require('../../operator/switch');
Observable_1.Observable.prototype.switch = switch_1._switch;
Observable_1.Observable.prototype._switch = switch_1._switch;


},{"../../Observable":171,"../../operator/switch":235}],198:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var switchMap_1 = require('../../operator/switchMap');
Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;


},{"../../Observable":171,"../../operator/switchMap":236}],199:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var take_1 = require('../../operator/take');
Observable_1.Observable.prototype.take = take_1.take;


},{"../../Observable":171,"../../operator/take":237}],200:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var takeUntil_1 = require('../../operator/takeUntil');
Observable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;


},{"../../Observable":171,"../../operator/takeUntil":238}],201:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var throttleTime_1 = require('../../operator/throttleTime');
Observable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;


},{"../../Observable":171,"../../operator/throttleTime":239}],202:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var withLatestFrom_1 = require('../../operator/withLatestFrom');
Observable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;


},{"../../Observable":171,"../../operator/withLatestFrom":240}],203:[function(require,module,exports){
"use strict";

var Observable_1 = require('../../Observable');
var zip_1 = require('../../operator/zip');
Observable_1.Observable.prototype.zip = zip_1.zipProto;


},{"../../Observable":171,"../../operator/zip":241}],204:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var ScalarObservable_1 = require('./ScalarObservable');
var EmptyObservable_1 = require('./EmptyObservable');
var isScheduler_1 = require('../util/isScheduler');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ArrayObservable = function (_super) {
    __extends(ArrayObservable, _super);
    function ArrayObservable(array, scheduler) {
        _super.call(this);
        this.array = array;
        this.scheduler = scheduler;
        if (!scheduler && array.length === 1) {
            this._isScalar = true;
            this.value = array[0];
        }
    }
    ArrayObservable.create = function (array, scheduler) {
        return new ArrayObservable(array, scheduler);
    };
    /**
     * Creates an Observable that emits some values you specify as arguments,
     * immediately one after the other, and then emits a complete notification.
     *
     * <span class="informal">Emits the arguments you provide, then completes.
     * </span>
     *
     * <img src="./img/of.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the arguments given, and the complete notification thereafter. It can
     * be used for composing with other Observables, such as with {@link concat}.
     * By default, it uses a `null` IScheduler, which means the `next`
     * notifications are sent synchronously, although with a different IScheduler
     * it is possible to determine when those notifications will be delivered.
     *
     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
     * var numbers = Rx.Observable.of(10, 20, 30);
     * var letters = Rx.Observable.of('a', 'b', 'c');
     * var interval = Rx.Observable.interval(1000);
     * var result = numbers.concat(letters).concat(interval);
     * result.subscribe(x => console.log(x));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link throw}
     *
     * @param {...T} values Arguments that represent `next` values to be emitted.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emissions of the `next` notifications.
     * @return {Observable<T>} An Observable that emits each given input value.
     * @static true
     * @name of
     * @owner Observable
     */
    ArrayObservable.of = function () {
        var array = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            array[_i - 0] = arguments[_i];
        }
        var scheduler = array[array.length - 1];
        if (isScheduler_1.isScheduler(scheduler)) {
            array.pop();
        } else {
            scheduler = null;
        }
        var len = array.length;
        if (len > 1) {
            return new ArrayObservable(array, scheduler);
        } else if (len === 1) {
            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
        } else {
            return new EmptyObservable_1.EmptyObservable(scheduler);
        }
    };
    ArrayObservable.dispatch = function (state) {
        var array = state.array,
            index = state.index,
            count = state.count,
            subscriber = state.subscriber;
        if (index >= count) {
            subscriber.complete();
            return;
        }
        subscriber.next(array[index]);
        if (subscriber.closed) {
            return;
        }
        state.index = index + 1;
        this.schedule(state);
    };
    ArrayObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var array = this.array;
        var count = array.length;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ArrayObservable.dispatch, 0, {
                array: array, index: index, count: count, subscriber: subscriber
            });
        } else {
            for (var i = 0; i < count && !subscriber.closed; i++) {
                subscriber.next(array[i]);
            }
            subscriber.complete();
        }
    };
    return ArrayObservable;
}(Observable_1.Observable);
exports.ArrayObservable = ArrayObservable;


},{"../Observable":171,"../util/isScheduler":260,"./EmptyObservable":207,"./ScalarObservable":210}],205:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('../Subject');
var Observable_1 = require('../Observable');
var Subscriber_1 = require('../Subscriber');
var Subscription_1 = require('../Subscription');
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        _super.call(this);
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            } else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return this.lift(new RefCountOperator(this));
    };
    return ConnectableObservable;
}(Observable_1.Observable);
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subscribe: { value: ConnectableObservable.prototype._subscribe },
    getSubject: { value: ConnectableObservable.prototype.getSubject },
    connect: { value: ConnectableObservable.prototype.connect },
    refCount: { value: ConnectableObservable.prototype.refCount }
};
var ConnectableSubscriber = function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber);
var RefCountOperator = function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}();
var RefCountSubscriber = function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        _super.call(this, destination);
        this.connectable = connectable;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber);


},{"../Observable":171,"../Subject":175,"../Subscriber":177,"../Subscription":178}],206:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var subscribeToResult_1 = require('../util/subscribeToResult');
var OuterSubscriber_1 = require('../OuterSubscriber');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var DeferObservable = function (_super) {
    __extends(DeferObservable, _super);
    function DeferObservable(observableFactory) {
        _super.call(this);
        this.observableFactory = observableFactory;
    }
    /**
     * Creates an Observable that, on subscribe, calls an Observable factory to
     * make an Observable for each new Observer.
     *
     * <span class="informal">Creates the Observable lazily, that is, only when it
     * is subscribed.
     * </span>
     *
     * <img src="./img/defer.png" width="100%">
     *
     * `defer` allows you to create the Observable only when the Observer
     * subscribes, and create a fresh Observable for each Observer. It waits until
     * an Observer subscribes to it, and then it generates an Observable,
     * typically with an Observable factory function. It does this afresh for each
     * subscriber, so although each subscriber may think it is subscribing to the
     * same Observable, in fact each subscriber gets its own individual
     * Observable.
     *
     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
     * var clicksOrInterval = Rx.Observable.defer(function () {
     *   if (Math.random() > 0.5) {
     *     return Rx.Observable.fromEvent(document, 'click');
     *   } else {
     *     return Rx.Observable.interval(1000);
     *   }
     * });
     * clicksOrInterval.subscribe(x => console.log(x));
     *
     * // Results in the following behavior:
     * // If the result of Math.random() is greater than 0.5 it will listen
     * // for clicks anywhere on the "document"; when document is clicked it
     * // will log a MouseEvent object to the console. If the result is less
     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
     *
     * @see {@link create}
     *
     * @param {function(): SubscribableOrPromise} observableFactory The Observable
     * factory function to invoke for each Observer that subscribes to the output
     * Observable. May also return a Promise, which will be converted on the fly
     * to an Observable.
     * @return {Observable} An Observable whose Observers' subscriptions trigger
     * an invocation of the given Observable factory function.
     * @static true
     * @name defer
     * @owner Observable
     */
    DeferObservable.create = function (observableFactory) {
        return new DeferObservable(observableFactory);
    };
    DeferObservable.prototype._subscribe = function (subscriber) {
        return new DeferSubscriber(subscriber, this.observableFactory);
    };
    return DeferObservable;
}(Observable_1.Observable);
exports.DeferObservable = DeferObservable;
var DeferSubscriber = function (_super) {
    __extends(DeferSubscriber, _super);
    function DeferSubscriber(destination, factory) {
        _super.call(this, destination);
        this.factory = factory;
        this.tryDefer();
    }
    DeferSubscriber.prototype.tryDefer = function () {
        try {
            this._callFactory();
        } catch (err) {
            this._error(err);
        }
    };
    DeferSubscriber.prototype._callFactory = function () {
        var result = this.factory();
        if (result) {
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return DeferSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../Observable":171,"../OuterSubscriber":173,"../util/subscribeToResult":262}],207:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var EmptyObservable = function (_super) {
    __extends(EmptyObservable, _super);
    function EmptyObservable(scheduler) {
        _super.call(this);
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits a complete notification.
     *
     * <span class="informal">Just emits 'complete', and nothing else.
     * </span>
     *
     * <img src="./img/empty.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the complete notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then complete.</caption>
     * var result = Rx.Observable.empty().startWith(7);
     * result.subscribe(x => console.log(x));
     *
     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
     * );
     * result.subscribe(x => console.log(x));
     *
     * // Results in the following to the console:
     * // x is equal to the count on the interval eg(0,1,2,3,...)
     * // x will occur every 1000ms
     * // if x % 2 is equal to 1 print abc
     * // if x % 2 is not equal to 1 nothing will be output
     *
     * @see {@link create}
     * @see {@link never}
     * @see {@link of}
     * @see {@link throw}
     *
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the complete notification.
     * @return {Observable} An "empty" Observable: emits only the complete
     * notification.
     * @static true
     * @name empty
     * @owner Observable
     */
    EmptyObservable.create = function (scheduler) {
        return new EmptyObservable(scheduler);
    };
    EmptyObservable.dispatch = function (arg) {
        var subscriber = arg.subscriber;
        subscriber.complete();
    };
    EmptyObservable.prototype._subscribe = function (subscriber) {
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
        } else {
            subscriber.complete();
        }
    };
    return EmptyObservable;
}(Observable_1.Observable);
exports.EmptyObservable = EmptyObservable;


},{"../Observable":171}],208:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ErrorObservable = function (_super) {
    __extends(ErrorObservable, _super);
    function ErrorObservable(error, scheduler) {
        _super.call(this);
        this.error = error;
        this.scheduler = scheduler;
    }
    /**
     * Creates an Observable that emits no items to the Observer and immediately
     * emits an error notification.
     *
     * <span class="informal">Just emits 'error', and nothing else.
     * </span>
     *
     * <img src="./img/throw.png" width="100%">
     *
     * This static operator is useful for creating a simple Observable that only
     * emits the error notification. It can be used for composing with other
     * Observables, such as in a {@link mergeMap}.
     *
     * @example <caption>Emit the number 7, then emit an error.</caption>
     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
     * var interval = Rx.Observable.interval(1000);
     * var result = interval.mergeMap(x =>
     *   x === 13 ?
     *     Rx.Observable.throw('Thirteens are bad') :
     *     Rx.Observable.of('a', 'b', 'c')
     * );
     * result.subscribe(x => console.log(x), e => console.error(e));
     *
     * @see {@link create}
     * @see {@link empty}
     * @see {@link never}
     * @see {@link of}
     *
     * @param {any} error The particular Error to pass to the error notification.
     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
     * the emission of the error notification.
     * @return {Observable} An error Observable: emits only the error notification
     * using the given error argument.
     * @static true
     * @name throw
     * @owner Observable
     */
    ErrorObservable.create = function (error, scheduler) {
        return new ErrorObservable(error, scheduler);
    };
    ErrorObservable.dispatch = function (arg) {
        var error = arg.error,
            subscriber = arg.subscriber;
        subscriber.error(error);
    };
    ErrorObservable.prototype._subscribe = function (subscriber) {
        var error = this.error;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ErrorObservable.dispatch, 0, {
                error: error, subscriber: subscriber
            });
        } else {
            subscriber.error(error);
        }
    };
    return ErrorObservable;
}(Observable_1.Observable);
exports.ErrorObservable = ErrorObservable;


},{"../Observable":171}],209:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
var tryCatch_1 = require('../util/tryCatch');
var isFunction_1 = require('../util/isFunction');
var errorObject_1 = require('../util/errorObject');
var Subscription_1 = require('../Subscription');
var toString = Object.prototype.toString;
function isNodeStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isNodeList(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
}
function isHTMLCollection(sourceObj) {
    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
}
function isEventTarget(sourceObj) {
    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var FromEventObservable = function (_super) {
    __extends(FromEventObservable, _super);
    function FromEventObservable(sourceObj, eventName, selector, options) {
        _super.call(this);
        this.sourceObj = sourceObj;
        this.eventName = eventName;
        this.selector = selector;
        this.options = options;
    }
    /* tslint:enable:max-line-length */
    /**
     * Creates an Observable that emits events of a specific type coming from the
     * given event target.
     *
     * <span class="informal">Creates an Observable from DOM events, or Node
     * EventEmitter events or others.</span>
     *
     * <img src="./img/fromEvent.png" width="100%">
     *
     * Creates an Observable by attaching an event listener to an "event target",
     * which may be an object with `addEventListener` and `removeEventListener`,
     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
     * the output Observable is subscribed, and removed when the Subscription is
     * unsubscribed.
     *
     * @example <caption>Emits clicks happening on the DOM document</caption>
     * var clicks = Rx.Observable.fromEvent(document, 'click');
     * clicks.subscribe(x => console.log(x));
     *
     * // Results in:
     * // MouseEvent object logged to console everytime a click
     * // occurs on the document.
     *
     * @see {@link from}
     * @see {@link fromEventPattern}
     *
     * @param {EventTargetLike} target The DOMElement, event target, Node.js
     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
     * @param {string} eventName The event name of interest, being emitted by the
     * `target`.
     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
     * @param {SelectorMethodSignature<T>} [selector] An optional function to
     * post-process results. It takes the arguments from the event handler and
     * should return a single value.
     * @return {Observable<T>}
     * @static true
     * @name fromEvent
     * @owner Observable
     */
    FromEventObservable.create = function (target, eventName, options, selector) {
        if (isFunction_1.isFunction(options)) {
            selector = options;
            options = undefined;
        }
        return new FromEventObservable(target, eventName, selector, options);
    };
    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
        var unsubscribe;
        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
            for (var i = 0, len = sourceObj.length; i < len; i++) {
                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
            }
        } else if (isEventTarget(sourceObj)) {
            var source_1 = sourceObj;
            sourceObj.addEventListener(eventName, handler, options);
            unsubscribe = function unsubscribe() {
                return source_1.removeEventListener(eventName, handler);
            };
        } else if (isJQueryStyleEventEmitter(sourceObj)) {
            var source_2 = sourceObj;
            sourceObj.on(eventName, handler);
            unsubscribe = function unsubscribe() {
                return source_2.off(eventName, handler);
            };
        } else if (isNodeStyleEventEmitter(sourceObj)) {
            var source_3 = sourceObj;
            sourceObj.addListener(eventName, handler);
            unsubscribe = function unsubscribe() {
                return source_3.removeListener(eventName, handler);
            };
        } else {
            throw new TypeError('Invalid event target');
        }
        subscriber.add(new Subscription_1.Subscription(unsubscribe));
    };
    FromEventObservable.prototype._subscribe = function (subscriber) {
        var sourceObj = this.sourceObj;
        var eventName = this.eventName;
        var options = this.options;
        var selector = this.selector;
        var handler = selector ? function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
            if (result === errorObject_1.errorObject) {
                subscriber.error(errorObject_1.errorObject.e);
            } else {
                subscriber.next(result);
            }
        } : function (e) {
            return subscriber.next(e);
        };
        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
    };
    return FromEventObservable;
}(Observable_1.Observable);
exports.FromEventObservable = FromEventObservable;


},{"../Observable":171,"../Subscription":178,"../util/errorObject":252,"../util/isFunction":256,"../util/tryCatch":264}],210:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Observable_1 = require('../Observable');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var ScalarObservable = function (_super) {
    __extends(ScalarObservable, _super);
    function ScalarObservable(value, scheduler) {
        _super.call(this);
        this.value = value;
        this.scheduler = scheduler;
        this._isScalar = true;
        if (scheduler) {
            this._isScalar = false;
        }
    }
    ScalarObservable.create = function (value, scheduler) {
        return new ScalarObservable(value, scheduler);
    };
    ScalarObservable.dispatch = function (state) {
        var done = state.done,
            value = state.value,
            subscriber = state.subscriber;
        if (done) {
            subscriber.complete();
            return;
        }
        subscriber.next(value);
        if (subscriber.closed) {
            return;
        }
        state.done = true;
        this.schedule(state);
    };
    ScalarObservable.prototype._subscribe = function (subscriber) {
        var value = this.value;
        var scheduler = this.scheduler;
        if (scheduler) {
            return scheduler.schedule(ScalarObservable.dispatch, 0, {
                done: false, value: value, subscriber: subscriber
            });
        } else {
            subscriber.next(value);
            if (!subscriber.closed) {
                subscriber.complete();
            }
        }
    };
    return ScalarObservable;
}(Observable_1.Observable);
exports.ScalarObservable = ScalarObservable;


},{"../Observable":171}],211:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var isNumeric_1 = require('../util/isNumeric');
var Observable_1 = require('../Observable');
var async_1 = require('../scheduler/async');
var isScheduler_1 = require('../util/isScheduler');
var isDate_1 = require('../util/isDate');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var TimerObservable = function (_super) {
    __extends(TimerObservable, _super);
    function TimerObservable(dueTime, period, scheduler) {
        if (dueTime === void 0) {
            dueTime = 0;
        }
        _super.call(this);
        this.period = -1;
        this.dueTime = 0;
        if (isNumeric_1.isNumeric(period)) {
            this.period = Number(period) < 1 && 1 || Number(period);
        } else if (isScheduler_1.isScheduler(period)) {
            scheduler = period;
        }
        if (!isScheduler_1.isScheduler(scheduler)) {
            scheduler = async_1.async;
        }
        this.scheduler = scheduler;
        this.dueTime = isDate_1.isDate(dueTime) ? +dueTime - this.scheduler.now() : dueTime;
    }
    /**
     * Creates an Observable that starts emitting after an `initialDelay` and
     * emits ever increasing numbers after each `period` of time thereafter.
     *
     * <span class="informal">Its like {@link interval}, but you can specify when
     * should the emissions start.</span>
     *
     * <img src="./img/timer.png" width="100%">
     *
     * `timer` returns an Observable that emits an infinite sequence of ascending
     * integers, with a constant interval of time, `period` of your choosing
     * between those emissions. The first emission happens after the specified
     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
     * operator uses the `async` IScheduler to provide a notion of time, but you
     * may pass any IScheduler to it. If `period` is not specified, the output
     * Observable emits only one value, `0`. Otherwise, it emits an infinite
     * sequence.
     *
     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
     * var numbers = Rx.Observable.timer(3000, 1000);
     * numbers.subscribe(x => console.log(x));
     *
     * @example <caption>Emits one number after five seconds</caption>
     * var numbers = Rx.Observable.timer(5000);
     * numbers.subscribe(x => console.log(x));
     *
     * @see {@link interval}
     * @see {@link delay}
     *
     * @param {number|Date} initialDelay The initial delay time to wait before
     * emitting the first value of `0`.
     * @param {number} [period] The period of time between emissions of the
     * subsequent numbers.
     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
     * the emission of values, and providing a notion of "time".
     * @return {Observable} An Observable that emits a `0` after the
     * `initialDelay` and ever increasing numbers after each `period` of time
     * thereafter.
     * @static true
     * @name timer
     * @owner Observable
     */
    TimerObservable.create = function (initialDelay, period, scheduler) {
        if (initialDelay === void 0) {
            initialDelay = 0;
        }
        return new TimerObservable(initialDelay, period, scheduler);
    };
    TimerObservable.dispatch = function (state) {
        var index = state.index,
            period = state.period,
            subscriber = state.subscriber;
        var action = this;
        subscriber.next(index);
        if (subscriber.closed) {
            return;
        } else if (period === -1) {
            return subscriber.complete();
        }
        state.index = index + 1;
        action.schedule(state, period);
    };
    TimerObservable.prototype._subscribe = function (subscriber) {
        var index = 0;
        var _a = this,
            period = _a.period,
            dueTime = _a.dueTime,
            scheduler = _a.scheduler;
        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
            index: index, period: period, subscriber: subscriber
        });
    };
    return TimerObservable;
}(Observable_1.Observable);
exports.TimerObservable = TimerObservable;


},{"../Observable":171,"../scheduler/async":245,"../util/isDate":255,"../util/isNumeric":257,"../util/isScheduler":260}],212:[function(require,module,exports){
"use strict";

var DeferObservable_1 = require('./DeferObservable');
exports.defer = DeferObservable_1.DeferObservable.create;


},{"./DeferObservable":206}],213:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../../util/root');
var tryCatch_1 = require('../../util/tryCatch');
var errorObject_1 = require('../../util/errorObject');
var Observable_1 = require('../../Observable');
var Subscriber_1 = require('../../Subscriber');
var map_1 = require('../../operator/map');
function getCORSRequest() {
    if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
    } else if (!!root_1.root.XDomainRequest) {
        return new root_1.root.XDomainRequest();
    } else {
        throw new Error('CORS is not supported by your browser');
    }
}
function getXMLHttpRequest() {
    if (root_1.root.XMLHttpRequest) {
        return new root_1.root.XMLHttpRequest();
    } else {
        var progId = void 0;
        try {
            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
            for (var i = 0; i < 3; i++) {
                try {
                    progId = progIds[i];
                    if (new root_1.root.ActiveXObject(progId)) {
                        break;
                    }
                } catch (e) {}
            }
            return new root_1.root.ActiveXObject(progId);
        } catch (e) {
            throw new Error('XMLHttpRequest is not supported by your browser');
        }
    }
}
function ajaxGet(url, headers) {
    if (headers === void 0) {
        headers = null;
    }
    return new AjaxObservable({ method: 'GET', url: url, headers: headers });
}
exports.ajaxGet = ajaxGet;
;
function ajaxPost(url, body, headers) {
    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });
}
exports.ajaxPost = ajaxPost;
;
function ajaxDelete(url, headers) {
    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });
}
exports.ajaxDelete = ajaxDelete;
;
function ajaxPut(url, body, headers) {
    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });
}
exports.ajaxPut = ajaxPut;
;
function ajaxPatch(url, body, headers) {
    return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });
}
exports.ajaxPatch = ajaxPatch;
;
function ajaxGetJSON(url, headers) {
    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers }).lift(new map_1.MapOperator(function (x, index) {
        return x.response;
    }, null));
}
exports.ajaxGetJSON = ajaxGetJSON;
;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var AjaxObservable = function (_super) {
    __extends(AjaxObservable, _super);
    function AjaxObservable(urlOrRequest) {
        _super.call(this);
        var request = {
            async: true,
            createXHR: function createXHR() {
                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();
            },
            crossDomain: false,
            withCredentials: false,
            headers: {},
            method: 'GET',
            responseType: 'json',
            timeout: 0
        };
        if (typeof urlOrRequest === 'string') {
            request.url = urlOrRequest;
        } else {
            for (var prop in urlOrRequest) {
                if (urlOrRequest.hasOwnProperty(prop)) {
                    request[prop] = urlOrRequest[prop];
                }
            }
        }
        this.request = request;
    }
    AjaxObservable.prototype._subscribe = function (subscriber) {
        return new AjaxSubscriber(subscriber, this.request);
    };
    /**
     * Creates an observable for an Ajax request with either a request object with
     * url, headers, etc or a string for a URL.
     *
     * @example
     * source = Rx.Observable.ajax('/products');
     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });
     *
     * @param {string|Object} request Can be one of the following:
     *   A string of the URL to make the Ajax call.
     *   An object with the following properties
     *   - url: URL of the request
     *   - body: The body of the request
     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
     *   - async: Whether the request is async
     *   - headers: Optional headers
     *   - crossDomain: true if a cross domain request, else false
     *   - createXHR: a function to override if you need to use an alternate
     *   XMLHttpRequest implementation.
     *   - resultSelector: a function to use to alter the output value type of
     *   the Observable. Gets {@link AjaxResponse} as an argument.
     * @return {Observable} An observable sequence containing the XMLHttpRequest.
     * @static true
     * @name ajax
     * @owner Observable
    */
    AjaxObservable.create = function () {
        var create = function create(urlOrRequest) {
            return new AjaxObservable(urlOrRequest);
        };
        create.get = ajaxGet;
        create.post = ajaxPost;
        create.delete = ajaxDelete;
        create.put = ajaxPut;
        create.patch = ajaxPatch;
        create.getJSON = ajaxGetJSON;
        return create;
    }();
    return AjaxObservable;
}(Observable_1.Observable);
exports.AjaxObservable = AjaxObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AjaxSubscriber = function (_super) {
    __extends(AjaxSubscriber, _super);
    function AjaxSubscriber(destination, request) {
        _super.call(this, destination);
        this.request = request;
        this.done = false;
        var headers = request.headers = request.headers || {};
        // force CORS if requested
        if (!request.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
        }
        // ensure content type is set
        if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {
            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
        }
        // properly serialize body
        request.body = this.serializeBody(request.body, request.headers['Content-Type']);
        this.send();
    }
    AjaxSubscriber.prototype.next = function (e) {
        this.done = true;
        var _a = this,
            xhr = _a.xhr,
            request = _a.request,
            destination = _a.destination;
        var response = new AjaxResponse(e, xhr, request);
        destination.next(response);
    };
    AjaxSubscriber.prototype.send = function () {
        var _a = this,
            request = _a.request,
            _b = _a.request,
            user = _b.user,
            method = _b.method,
            url = _b.url,
            async = _b.async,
            password = _b.password,
            headers = _b.headers,
            body = _b.body;
        var createXHR = request.createXHR;
        var xhr = tryCatch_1.tryCatch(createXHR).call(request);
        if (xhr === errorObject_1.errorObject) {
            this.error(errorObject_1.errorObject.e);
        } else {
            this.xhr = xhr;
            // set up the events before open XHR
            // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
            // You need to add the event listeners before calling open() on the request.
            // Otherwise the progress events will not fire.
            this.setupEvents(xhr, request);
            // open XHR
            var result = void 0;
            if (user) {
                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);
            } else {
                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);
            }
            if (result === errorObject_1.errorObject) {
                this.error(errorObject_1.errorObject.e);
                return null;
            }
            // timeout, responseType and withCredentials can be set once the XHR is open
            xhr.timeout = request.timeout;
            xhr.responseType = request.responseType;
            if ('withCredentials' in xhr) {
                xhr.withCredentials = !!request.withCredentials;
            }
            // set headers
            this.setHeaders(xhr, headers);
            // finally send the request
            result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);
            if (result === errorObject_1.errorObject) {
                this.error(errorObject_1.errorObject.e);
                return null;
            }
        }
        return xhr;
    };
    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {
        if (!body || typeof body === 'string') {
            return body;
        } else if (root_1.root.FormData && body instanceof root_1.root.FormData) {
            return body;
        }
        if (contentType) {
            var splitIndex = contentType.indexOf(';');
            if (splitIndex !== -1) {
                contentType = contentType.substring(0, splitIndex);
            }
        }
        switch (contentType) {
            case 'application/x-www-form-urlencoded':
                return Object.keys(body).map(function (key) {
                    return encodeURI(key) + "=" + encodeURI(body[key]);
                }).join('&');
            case 'application/json':
                return JSON.stringify(body);
            default:
                return body;
        }
    };
    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {
        for (var key in headers) {
            if (headers.hasOwnProperty(key)) {
                xhr.setRequestHeader(key, headers[key]);
            }
        }
    };
    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {
        var progressSubscriber = request.progressSubscriber;
        function xhrTimeout(e) {
            var _a = xhrTimeout,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
            if (progressSubscriber) {
                progressSubscriber.error(e);
            }
            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.
        }
        ;
        xhr.ontimeout = xhrTimeout;
        xhrTimeout.request = request;
        xhrTimeout.subscriber = this;
        xhrTimeout.progressSubscriber = progressSubscriber;
        if (xhr.upload && 'withCredentials' in xhr) {
            if (progressSubscriber) {
                var _xhrProgress_;
                _xhrProgress_ = function xhrProgress_1(e) {
                    var progressSubscriber = _xhrProgress_.progressSubscriber;
                    progressSubscriber.next(e);
                };
                if (root_1.root.XDomainRequest) {
                    xhr.onprogress = _xhrProgress_;
                } else {
                    xhr.upload.onprogress = _xhrProgress_;
                }
                _xhrProgress_.progressSubscriber = progressSubscriber;
            }
            var _xhrError_;
            _xhrError_ = function xhrError_1(e) {
                var _a = _xhrError_,
                    progressSubscriber = _a.progressSubscriber,
                    subscriber = _a.subscriber,
                    request = _a.request;
                if (progressSubscriber) {
                    progressSubscriber.error(e);
                }
                subscriber.error(new AjaxError('ajax error', this, request));
            };
            xhr.onerror = _xhrError_;
            _xhrError_.request = request;
            _xhrError_.subscriber = this;
            _xhrError_.progressSubscriber = progressSubscriber;
        }
        function xhrReadyStateChange(e) {
            var _a = xhrReadyStateChange,
                subscriber = _a.subscriber,
                progressSubscriber = _a.progressSubscriber,
                request = _a.request;
            if (this.readyState === 4) {
                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                var status_1 = this.status === 1223 ? 204 : this.status;
                var response = this.responseType === 'text' ? this.response || this.responseText : this.response;
                // fix status code when it is 0 (0 status is undocumented).
                // Occurs when accessing file resources or on Android 4.1 stock browser
                // while retrieving files from application cache.
                if (status_1 === 0) {
                    status_1 = response ? 200 : 0;
                }
                if (200 <= status_1 && status_1 < 300) {
                    if (progressSubscriber) {
                        progressSubscriber.complete();
                    }
                    subscriber.next(e);
                    subscriber.complete();
                } else {
                    if (progressSubscriber) {
                        progressSubscriber.error(e);
                    }
                    subscriber.error(new AjaxError('ajax error ' + status_1, this, request));
                }
            }
        }
        ;
        xhr.onreadystatechange = xhrReadyStateChange;
        xhrReadyStateChange.subscriber = this;
        xhrReadyStateChange.progressSubscriber = progressSubscriber;
        xhrReadyStateChange.request = request;
    };
    AjaxSubscriber.prototype.unsubscribe = function () {
        var _a = this,
            done = _a.done,
            xhr = _a.xhr;
        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {
            xhr.abort();
        }
        _super.prototype.unsubscribe.call(this);
    };
    return AjaxSubscriber;
}(Subscriber_1.Subscriber);
exports.AjaxSubscriber = AjaxSubscriber;
/**
 * A normalized AJAX response.
 *
 * @see {@link ajax}
 *
 * @class AjaxResponse
 */
var AjaxResponse = function () {
    function AjaxResponse(originalEvent, xhr, request) {
        this.originalEvent = originalEvent;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
        this.responseType = xhr.responseType || request.responseType;
        switch (this.responseType) {
            case 'json':
                if ('response' in xhr) {
                    //IE does not support json as responseType, parse it internally
                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
                } else {
                    this.response = JSON.parse(xhr.responseText || 'null');
                }
                break;
            case 'xml':
                this.response = xhr.responseXML;
                break;
            case 'text':
            default:
                this.response = 'response' in xhr ? xhr.response : xhr.responseText;
                break;
        }
    }
    return AjaxResponse;
}();
exports.AjaxResponse = AjaxResponse;
/**
 * A normalized AJAX error.
 *
 * @see {@link ajax}
 *
 * @class AjaxError
 */
var AjaxError = function (_super) {
    __extends(AjaxError, _super);
    function AjaxError(message, xhr, request) {
        _super.call(this, message);
        this.message = message;
        this.xhr = xhr;
        this.request = request;
        this.status = xhr.status;
    }
    return AjaxError;
}(Error);
exports.AjaxError = AjaxError;
/**
 * @see {@link ajax}
 *
 * @class AjaxTimeoutError
 */
var AjaxTimeoutError = function (_super) {
    __extends(AjaxTimeoutError, _super);
    function AjaxTimeoutError(xhr, request) {
        _super.call(this, 'ajax timeout', xhr, request);
    }
    return AjaxTimeoutError;
}(AjaxError);
exports.AjaxTimeoutError = AjaxTimeoutError;


},{"../../Observable":171,"../../Subscriber":177,"../../operator/map":228,"../../util/errorObject":252,"../../util/root":261,"../../util/tryCatch":264}],214:[function(require,module,exports){
"use strict";

var AjaxObservable_1 = require('./AjaxObservable');
exports.ajax = AjaxObservable_1.AjaxObservable.create;


},{"./AjaxObservable":213}],215:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"./FromEventObservable":209,"dup":122}],216:[function(require,module,exports){
"use strict";

var merge_1 = require('../operator/merge');
exports.merge = merge_1.mergeStatic;


},{"../operator/merge":229}],217:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"./ArrayObservable":204,"dup":123}],218:[function(require,module,exports){
"use strict";

var ErrorObservable_1 = require('./ErrorObservable');
exports._throw = ErrorObservable_1.ErrorObservable.create;


},{"./ErrorObservable":208}],219:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"./TimerObservable":211,"dup":124}],220:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
 *
 * <img src="./img/catch.png" width="100%">
 *
 * @example <caption>Continues with a different Observable when there's an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n == 4) {
 * 	     throw 'four!';
 *     }
 *	   return n;
 *   })
 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, I, II, III, IV, V
 *
 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 * 	   if (n === 4) {
 * 	     throw 'four!';
 *     }
 * 	   return n;
 *   })
 *   .catch((err, caught) => caught)
 *   .take(30)
 *   .subscribe(x => console.log(x));
 *   // 1, 2, 3, 1, 2, 3, ...
 *
 * @example <caption>Throws a new error when the source Observable throws an error</caption>
 *
 * Observable.of(1, 2, 3, 4, 5)
 *   .map(n => {
 *     if (n == 4) {
 *       throw 'four!';
 *     }
 *     return n;
 *   })
 *   .catch(err => {
 *     throw 'error in source. Details: ' + err;
 *   })
 *   .subscribe(
 *     x => console.log(x),
 *     err => console.log(err)
 *   );
 *   // 1, 2, 3, error in source. Details: four!
 *
 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
 *  is returned by the `selector` will be used to continue the observable chain.
 * @return {Observable} An observable that originates from either the source or the observable returned by the
 *  catch `selector` function.
 * @method catch
 * @name catch
 * @owner Observable
 */
function _catch(selector) {
    var operator = new CatchOperator(selector);
    var caught = this.lift(operator);
    return operator.caught = caught;
}
exports._catch = _catch;
var CatchOperator = function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        _super.call(this, destination);
        this.selector = selector;
        this.caught = caught;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            } catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult_1.subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":173,"../util/subscribeToResult":262}],221:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"../Observable":171,"../observable/ArrayObservable":204,"../util/isScheduler":260,"./mergeAll":230,"dup":126}],222:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var async_1 = require('../scheduler/async');
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */
function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
}
exports.debounceTime = debounceTime;
var DebounceTimeOperator = function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        _super.call(this, destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            this.destination.next(this.lastValue);
            this.lastValue = null;
            this.hasValue = false;
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber_1.Subscriber);
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}


},{"../Subscriber":177,"../scheduler/async":245}],223:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var async_1 = require('../scheduler/async');
var isDate_1 = require('../util/isDate');
var Subscriber_1 = require('../Subscriber');
var Notification_1 = require('../Notification');
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * <img src="./img/delay.png" width="100%">
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * @example <caption>Delay each click by one second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @example <caption>Delay all clicks until a future date happens</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var date = new Date('March 15, 2050 12:00:00'); // in the future
 * var delayedClicks = clicks.delay(date); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {Scheduler} [scheduler=async] The IScheduler to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */
function delay(delay, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    var absoluteDelay = isDate_1.isDate(delay);
    var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);
    return this.lift(new DelayOperator(delayFor, scheduler));
}
exports.delay = delay;
var DelayOperator = function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        _super.call(this, destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        } else {
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification_1.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification_1.Notification.createComplete());
    };
    return DelaySubscriber;
}(Subscriber_1.Subscriber);
var DelayMessage = function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}();


},{"../Notification":170,"../Subscriber":177,"../scheduler/async":245,"../util/isDate":255}],224:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var tryCatch_1 = require('../util/tryCatch');
var errorObject_1 = require('../util/errorObject');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */
function distinctUntilChanged(compare, keySelector) {
    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
}
exports.distinctUntilChanged = distinctUntilChanged;
var DistinctUntilChangedOperator = function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        _super.call(this, destination);
        this.keySelector = keySelector;
        this.hasKey = false;
        if (typeof compare === 'function') {
            this.compare = compare;
        }
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch_1.tryCatch(this.keySelector)(value);
            if (key === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
            if (result === errorObject_1.errorObject) {
                return this.destination.error(errorObject_1.errorObject.e);
            }
        } else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":177,"../util/errorObject":252,"../util/tryCatch":264}],225:[function(require,module,exports){
"use strict";

var distinctUntilChanged_1 = require('./distinctUntilChanged');
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
 * using a property accessed by using the key provided to check if the two items are distinct.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>An example comparing the name of persons</caption>
 *
 *  interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'},
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilKeyChanged('name')
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @example <caption>An example comparing the first letters of the name</caption>
 *
 * interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo1'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo2'},
 *     { age: 6, name: 'Foo3'})
 *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo1' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo2' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 *
 * @param {string} key String key for object property lookup on each item.
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.
 * @method distinctUntilKeyChanged
 * @owner Observable
 */
function distinctUntilKeyChanged(key, compare) {
    return distinctUntilChanged_1.distinctUntilChanged.call(this, function (x, y) {
        if (compare) {
            return compare(x[key], y[key]);
        }
        return x[key] === y[key];
    });
}
exports.distinctUntilKeyChanged = distinctUntilKeyChanged;


},{"./distinctUntilChanged":224}],226:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @method do
 * @name do
 * @owner Observable
 */
function _do(nextOrObserver, error, complete) {
    return this.lift(new DoOperator(nextOrObserver, error, complete));
}
exports._do = _do;
var DoOperator = function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DoSubscriber = function (_super) {
    __extends(DoSubscriber, _super);
    function DoSubscriber(destination, nextOrObserver, error, complete) {
        _super.call(this, destination);
        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
        safeSubscriber.syncErrorThrowable = true;
        this.add(safeSubscriber);
        this.safeSubscriber = safeSubscriber;
    }
    DoSubscriber.prototype._next = function (value) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.next(value);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.next(value);
        }
    };
    DoSubscriber.prototype._error = function (err) {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.error(err);
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.error(err);
        }
    };
    DoSubscriber.prototype._complete = function () {
        var safeSubscriber = this.safeSubscriber;
        safeSubscriber.complete();
        if (safeSubscriber.syncErrorThrown) {
            this.destination.error(safeSubscriber.syncErrorValue);
        } else {
            this.destination.complete();
        }
    };
    return DoSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":177}],227:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return this.lift(new FilterOperator(predicate, thisArg));
}
exports.filter = filter;
var FilterOperator = function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        _super.call(this, destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
        this.predicate = predicate;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":177}],228:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    if (typeof project !== 'function') {
        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }
    return this.lift(new MapOperator(project, thisArg));
}
exports.map = map;
var MapOperator = function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}();
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        _super.call(this, destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":177}],229:[function(require,module,exports){
"use strict";

var Observable_1 = require('../Observable');
var ArrayObservable_1 = require('../observable/ArrayObservable');
var mergeAll_1 = require('./mergeAll');
var isScheduler_1 = require('../util/isScheduler');
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (either the source or an
 * Observable given as argument), and simply forwards (without doing any
 * transformation) all the values from all the input Observables to the output
 * Observable. The output Observable only completes once all input Observables
 * have completed. Any error delivered by an input Observable will be immediately
 * emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = clicks.merge(timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = timer1.merge(timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {ObservableInput} other An input Observable to merge with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} An Observable that emits items that are the result of
 * every input Observable.
 * @method merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
}
exports.merge = merge;
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (as arguments), and simply
 * forwards (without doing any transformation) all the values from all the input
 * Observables to the output Observable. The output Observable only completes
 * once all input Observables have completed. Any error delivered by an input
 * Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // timer will emit ascending values, one every second(1000ms) to console
 * // clicks logs MouseEvents to console everytime the "document" is clicked
 * // Since the two streams are merged you see these happening
 * // as they occur.
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - First timer1 and timer2 will run concurrently
 * // - timer1 will emit a value every 1000ms for 10 iterations
 * // - timer2 will emit a value every 2000ms for 6 iterations
 * // - after timer1 hits it's max iteration, timer2 will
 * //   continue, and timer3 will start to run concurrently with timer2
 * // - when timer2 hits it's max iteration it terminates, and
 * //   timer3 will continue to emit a value every 500ms until it is complete
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {...ObservableInput} observables Input Observables to merge together.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @static true
 * @name merge
 * @owner Observable
 */
function mergeStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    } else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
}
exports.mergeStatic = mergeStatic;


},{"../Observable":171,"../observable/ArrayObservable":204,"../util/isScheduler":260,"./mergeAll":230}],230:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return this.lift(new MergeAllOperator(concurrent));
}
exports.mergeAll = mergeAll;
var MergeAllOperator = function () {
    function MergeAllOperator(concurrent) {
        this.concurrent = concurrent;
    }
    MergeAllOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
    };
    return MergeAllOperator;
}();
exports.MergeAllOperator = MergeAllOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeAllSubscriber = function (_super) {
    __extends(MergeAllSubscriber, _super);
    function MergeAllSubscriber(destination, concurrent) {
        _super.call(this, destination);
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
    }
    MergeAllSubscriber.prototype._next = function (observable) {
        if (this.active < this.concurrent) {
            this.active++;
            this.add(subscribeToResult_1.subscribeToResult(this, observable));
        } else {
            this.buffer.push(observable);
        }
    };
    MergeAllSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeAllSubscriber;
}(OuterSubscriber_1.OuterSubscriber);
exports.MergeAllSubscriber = MergeAllSubscriber;


},{"../OuterSubscriber":173,"../util/subscribeToResult":262}],231:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"../observable/ConnectableObservable":205,"dup":135}],232:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subject_1 = require('../Subject');
var tryCatch_1 = require('../util/tryCatch');
var errorObject_1 = require('../util/errorObject');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.
 * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child
 * subscription. Otherwise this method will resubscribe to the source Observable.
 *
 * <img src="./img/retryWhen.png" width="100%">
 *
 * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a
 * user can `complete` or `error`, aborting the retry.
 * @return {Observable} The source Observable modified with retry logic.
 * @method retryWhen
 * @owner Observable
 */
function retryWhen(notifier) {
    return this.lift(new RetryWhenOperator(notifier, this));
}
exports.retryWhen = retryWhen;
var RetryWhenOperator = function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetryWhenSubscriber = function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject_1.Subject();
                retries = tryCatch_1.tryCatch(this.notifier)(errors);
                if (retries === errorObject_1.errorObject) {
                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);
                }
                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
            } else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this,
            errors = _a.errors,
            retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _a = this,
            errors = _a.errors,
            retries = _a.retries,
            retriesSubscription = _a.retriesSubscription;
        this.errors = null;
        this.retries = null;
        this.retriesSubscription = null;
        this._unsubscribeAndRecycle();
        this.errors = errors;
        this.retries = retries;
        this.retriesSubscription = retriesSubscription;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":173,"../Subject":175,"../util/errorObject":252,"../util/subscribeToResult":262,"../util/tryCatch":264}],233:[function(require,module,exports){
arguments[4][137][0].apply(exports,arguments)
},{"../Subject":175,"./multicast":231,"dup":137}],234:[function(require,module,exports){
arguments[4][138][0].apply(exports,arguments)
},{"../observable/ArrayObservable":204,"../observable/EmptyObservable":207,"../observable/ScalarObservable":210,"../util/isScheduler":260,"./concat":221,"dup":138}],235:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Converts a higher-order Observable into a first-order Observable by
 * subscribing to only the most recently emitted of those inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * previous inner Observable once a new one appears.</span>
 *
 * <img src="./img/switch.png" width="100%">
 *
 * `switch` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable subscribes to the inner Observable and
 * begins emitting the items emitted by that. So far, it behaves
 * like {@link mergeAll}. However, when a new inner Observable is emitted,
 * `switch` unsubscribes from the earlier-emitted inner Observable and
 * subscribes to the new inner Observable and begins emitting items from it. It
 * continues to behave like this for subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * // Each click event is mapped to an Observable that ticks every second
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var switched = higherOrder.switch();
 * // The outcome is that `switched` is essentially a timer that restarts
 * // on every click. The interval Observables from older clicks do not merge
 * // with the current interval Observable.
 * switched.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switchMap}
 * @see {@link switchMapTo}
 * @see {@link zipAll}
 *
 * @return {Observable<T>} An Observable that emits the items emitted by the
 * Observable most recently emitted by the source Observable.
 * @method switch
 * @name switch
 * @owner Observable
 */
function _switch() {
    return this.lift(new SwitchOperator());
}
exports._switch = _switch;
var SwitchOperator = function () {
    function SwitchOperator() {}
    SwitchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchSubscriber(subscriber));
    };
    return SwitchOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchSubscriber = function (_super) {
    __extends(SwitchSubscriber, _super);
    function SwitchSubscriber(destination) {
        _super.call(this, destination);
        this.active = 0;
        this.hasCompleted = false;
    }
    SwitchSubscriber.prototype._next = function (value) {
        this.unsubscribeInner();
        this.active++;
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, value));
    };
    SwitchSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    SwitchSubscriber.prototype.unsubscribeInner = function () {
        this.active = this.active > 0 ? this.active - 1 : 0;
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
            this.remove(innerSubscription);
        }
    };
    SwitchSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    SwitchSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SwitchSubscriber.prototype.notifyComplete = function () {
        this.unsubscribeInner();
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return SwitchSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":173,"../util/subscribeToResult":262}],236:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
 * A function to produce the value on the output Observable based on the values
 * and the indices of the source (outer) emission and the inner Observable
 * emission. The arguments passed to this function are:
 * - `outerValue`: the value that came from the source
 * - `innerValue`: the value that came from the projected Observable
 * - `outerIndex`: the "index" of the value that came from the source
 * - `innerIndex`: the "index" of the value from the projected Observable
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */
function switchMap(project, resultSelector) {
    return this.lift(new SwitchMapOperator(project, resultSelector));
}
exports.switchMap = switchMap;
var SwitchMapOperator = function () {
    function SwitchMapOperator(project, resultSelector) {
        this.project = project;
        this.resultSelector = resultSelector;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
    };
    return SwitchMapOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project, resultSelector) {
        _super.call(this, destination);
        this.project = project;
        this.resultSelector = resultSelector;
        this.index = 0;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        } catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (this.resultSelector) {
            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
        } else {
            this.destination.next(innerValue);
        }
    };
    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        var result;
        try {
            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":173,"../util/subscribeToResult":262}],237:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var ArgumentOutOfRangeError_1 = require('../util/ArgumentOutOfRangeError');
var EmptyObservable_1 = require('../observable/EmptyObservable');
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */
function take(count) {
    if (count === 0) {
        return new EmptyObservable_1.EmptyObservable();
    } else {
        return this.lift(new TakeOperator(count));
    }
}
exports.take = take;
var TakeOperator = function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError();
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        _super.call(this, destination);
        this.total = total;
        this.count = 0;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber_1.Subscriber);


},{"../Subscriber":177,"../observable/EmptyObservable":207,"../util/ArgumentOutOfRangeError":249}],238:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits something. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value or a complete notification, the output Observable stops
 * mirroring the source Observable and completes.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */
function takeUntil(notifier) {
    return this.lift(new TakeUntilOperator(notifier));
}
exports.takeUntil = takeUntil;
var TakeUntilOperator = function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
    };
    return TakeUntilOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination, notifier) {
        _super.call(this, destination);
        this.notifier = notifier;
        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":173,"../util/subscribeToResult":262}],239:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscriber_1 = require('../Subscriber');
var async_1 = require('../scheduler/async');
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * <img src="./img/throttleTime.png" width="100%">
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {number} duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the sampling.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */
function throttleTime(duration, scheduler) {
    if (scheduler === void 0) {
        scheduler = async_1.async;
    }
    return this.lift(new ThrottleTimeOperator(duration, scheduler));
}
exports.throttleTime = throttleTime;
var ThrottleTimeOperator = function () {
    function ThrottleTimeOperator(duration, scheduler) {
        this.duration = duration;
        this.scheduler = scheduler;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler));
    };
    return ThrottleTimeOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleTimeSubscriber = function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler) {
        _super.call(this, destination);
        this.duration = duration;
        this.scheduler = scheduler;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (!this.throttled) {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            this.destination.next(value);
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber_1.Subscriber);
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}


},{"../Subscriber":177,"../scheduler/async":245}],240:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
/* tslint:enable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */
function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var project;
    if (typeof args[args.length - 1] === 'function') {
        project = args.pop();
    }
    var observables = args;
    return this.lift(new WithLatestFromOperator(observables, project));
}
exports.withLatestFrom = withLatestFrom;
var WithLatestFromOperator = function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WithLatestFromSubscriber = function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        _super.call(this, destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        var len = observables.length;
        this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
        }
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            } else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":173,"../util/subscribeToResult":262}],241:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ArrayObservable_1 = require('../observable/ArrayObservable');
var isArray_1 = require('../util/isArray');
var Subscriber_1 = require('../Subscriber');
var OuterSubscriber_1 = require('../OuterSubscriber');
var subscribeToResult_1 = require('../util/subscribeToResult');
var iterator_1 = require('../symbol/iterator');
/* tslint:enable:max-line-length */
/**
 * @param observables
 * @return {Observable<R>}
 * @method zip
 * @owner Observable
 */
function zipProto() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));
}
exports.zipProto = zipProto;
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the latest parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * @example <caption>Combine age and name from different sources</caption>
 *
 * let age$ = Observable.of<number>(27, 25, 29);
 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
 * let isDev$ = Observable.of<boolean>(true, true, false);
 *
 * Observable
 *     .zip(age$,
 *          name$,
 *          isDev$,
 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
 *     .subscribe(x => console.log(x));
 *
 * // outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 *
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */
function zipStatic() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i - 0] = arguments[_i];
    }
    var project = observables[observables.length - 1];
    if (typeof project === 'function') {
        observables.pop();
    }
    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
}
exports.zipStatic = zipStatic;
var ZipOperator = function () {
    function ZipOperator(project) {
        this.project = project;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.project));
    };
    return ZipOperator;
}();
exports.ZipOperator = ZipOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, project, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        _super.call(this, destination);
        this.iterators = [];
        this.active = 0;
        this.project = typeof project === 'function' ? project : null;
        this.values = values;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray_1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[iterator_1.$$iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator_1.$$iterator]()));
        } else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                this.add(iterator.subscribe(iterator, i));
            } else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.project) {
            this._tryProject(args);
        } else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        } catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber);
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}();
var StaticArrayIterator = function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator_1.$$iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}();
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        _super.call(this, destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
    }
    ZipBufferIterator.prototype[iterator_1.$$iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        } else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        } else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber);


},{"../OuterSubscriber":173,"../Subscriber":177,"../observable/ArrayObservable":204,"../symbol/iterator":246,"../util/isArray":253,"../util/subscribeToResult":262}],242:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Subscription_1 = require('../Subscription');
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        _super.call(this);
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription_1.Subscription);
exports.Action = Action;


},{"../Subscription":178}],243:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var root_1 = require('../util/root');
var Action_1 = require('./Action');
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        _super.call(this, scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // clear the interval id
        return root_1.root.clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        } else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        } catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.delay = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
    };
    return AsyncAction;
}(Action_1.Action);
exports.AsyncAction = AsyncAction;


},{"../util/root":261,"./Action":242}],244:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Scheduler_1 = require('../Scheduler');
var AsyncScheduler = function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler() {
        _super.apply(this, arguments);
        this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         */
        this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         */
        this.scheduled = undefined;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler);
exports.AsyncScheduler = AsyncScheduler;


},{"../Scheduler":174}],245:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"./AsyncAction":243,"./AsyncScheduler":244,"dup":145}],246:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function symbolIteratorPonyfill(root) {
    var _Symbol = root.Symbol;
    if (typeof _Symbol === 'function') {
        if (!_Symbol.iterator) {
            _Symbol.iterator = _Symbol('iterator polyfill');
        }
        return _Symbol.iterator;
    } else {
        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
        var Set_1 = root.Set;
        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
            return '@@iterator';
        }
        var Map_1 = root.Map;
        // required for compatability with es6-shim
        if (Map_1) {
            var keys = Object.getOwnPropertyNames(Map_1.prototype);
            for (var i = 0; i < keys.length; ++i) {
                var key = keys[i];
                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
                    return key;
                }
            }
        }
        return '@@iterator';
    }
}
exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
exports.$$iterator = symbolIteratorPonyfill(root_1.root);


},{"../util/root":261}],247:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
function getSymbolObservable(context) {
    var $$observable;
    var _Symbol = context.Symbol;
    if (typeof _Symbol === 'function') {
        if (_Symbol.observable) {
            $$observable = _Symbol.observable;
        } else {
            $$observable = _Symbol('observable');
            _Symbol.observable = $$observable;
        }
    } else {
        $$observable = '@@observable';
    }
    return $$observable;
}
exports.getSymbolObservable = getSymbolObservable;
exports.$$observable = getSymbolObservable(root_1.root);


},{"../util/root":261}],248:[function(require,module,exports){
"use strict";

var root_1 = require('../util/root');
var _Symbol = root_1.root.Symbol;
exports.$$rxSubscriber = typeof _Symbol === 'function' && typeof _Symbol.for === 'function' ? _Symbol.for('rxSubscriber') : '@@rxSubscriber';


},{"../util/root":261}],249:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = function (_super) {
    __extends(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var err = _super.call(this, 'argument out of range');
        this.name = err.name = 'ArgumentOutOfRangeError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ArgumentOutOfRangeError;
}(Error);
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;


},{}],250:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var err = _super.call(this, 'object unsubscribed');
        this.name = err.name = 'ObjectUnsubscribedError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return ObjectUnsubscribedError;
}(Error);
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;


},{}],251:[function(require,module,exports){
"use strict";

var __extends = undefined && undefined.__extends || function (d, b) {
    for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
    }function __() {
        this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        _super.call(this);
        this.errors = errors;
        var err = Error.call(this, errors ? errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) {
            return i + 1 + ") " + err.toString();
        }).join('\n  ') : '');
        this.name = err.name = 'UnsubscriptionError';
        this.stack = err.stack;
        this.message = err.message;
    }
    return UnsubscriptionError;
}(Error);
exports.UnsubscriptionError = UnsubscriptionError;


},{}],252:[function(require,module,exports){
arguments[4][151][0].apply(exports,arguments)
},{"dup":151}],253:[function(require,module,exports){
arguments[4][152][0].apply(exports,arguments)
},{"dup":152}],254:[function(require,module,exports){
arguments[4][153][0].apply(exports,arguments)
},{"dup":153}],255:[function(require,module,exports){
arguments[4][154][0].apply(exports,arguments)
},{"dup":154}],256:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"dup":155}],257:[function(require,module,exports){
arguments[4][156][0].apply(exports,arguments)
},{"../util/isArray":253,"dup":156}],258:[function(require,module,exports){
"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isObject(x) {
    return x != null && (typeof x === "undefined" ? "undefined" : _typeof(x)) === 'object';
}
exports.isObject = isObject;


},{}],259:[function(require,module,exports){
arguments[4][158][0].apply(exports,arguments)
},{"dup":158}],260:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"dup":159}],261:[function(require,module,exports){
(function (global){
"use strict";
/**
 * window: browser in DOM main thread
 * self: browser in WebWorker
 * global: Node.js/other
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.root = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) == 'object' && window.window === window && window || (typeof self === 'undefined' ? 'undefined' : _typeof(self)) == 'object' && self.self === self && self || (typeof global === 'undefined' ? 'undefined' : _typeof(global)) == 'object' && global.global === global && global;
if (!exports.root) {
    throw new Error('RxJS could not find any global context (window, self, global)');
}


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],262:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"../InnerSubscriber":169,"../Observable":171,"../symbol/iterator":246,"../symbol/observable":247,"./isArrayLike":254,"./isObject":258,"./isPromise":259,"./root":261,"dup":161}],263:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"../Observer":172,"../Subscriber":177,"../symbol/rxSubscriber":248,"dup":162}],264:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"./errorObject":252,"dup":163}],265:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isExternal = isExternal;
exports.stripHash = stripHash;
exports.isHash = isHash;
exports.matches = matches;
exports.querySelectorInv = querySelectorInv;
exports.shouldLoadAnchor = shouldLoadAnchor;
exports.getScrollHeight = getScrollHeight;
exports.getScrollLeft = getScrollLeft;
exports.getScrollTop = getScrollTop;
exports.expInterval = expInterval;
exports.fragmentFromString = fragmentFromString;

var _Observable = require('rxjs/Observable');

/**
 * Checks to see if the url is external
 *
 * @param   {string}    url - url being evaluated
 * @see     http://stackoverflow.com/questions/6238351/fastest-way-to-detect-external-urls
 */
function isExternal(url) {
  var match = url.match(/^([^:\/?#]+:)?(?:\/\/([^\/?#]*))?([^?#]+)?(\?[^#]*)?(#.*)?/); // eslint-disable-line no-useless-escape

  if (typeof match[1] === 'string' && match[1].length > 0 && match[1].toLowerCase() !== window.location.protocol) {
    return true;
  }

  var port = { http: 80, https: 443 }[window.location.protocol];

  if (typeof match[2] === 'string' && match[2].length > 0 && match[2].replace(new RegExp(':(' + port + ')?$'), '') !== window.location.host) {
    return true;
  }

  return false;
}

/**
 * Strips the hash from a url and returns the new href
 *
 * @param   {string}    href - url being evaluated
 */
function stripHash(href) {
  return href.replace(/#.*/, '');
}

/**
 * Checks to see if the url is an internal hash
 *
 * @param   {string}    href - url being evaluated
 * @param   {string}    prev - previous url (optional)
 */
function isHash(href, prev) {
  var p = prev || window.location.href;

  var hasHash = href.indexOf('#') > -1;
  var samePath = stripHash(href) === stripHash(p);

  return hasHash && samePath;
}

function matches(el, selector) {
  return (el.matches || el.matchesSelector || el.msMatchesSelector || el.mozMatchesSelector || el.webkitMatchesSelector || el.oMatchesSelector).call(el, selector);
  // if (!matches.memo) {
  //   matches.memo =
  //     el.matches ||
  //     el.matchesSelector ||
  //     el.msMatchesSelector ||
  //     el.mozMatchesSelector ||
  //     el.webkitMatchesSelector ||
  //     el.oMatchesSelector;
  // }
  // return matches.memo.call(el, selector);
}

function querySelectorInv(el, selector) {
  var curr = el;
  while (curr !== document && curr !== document.documentElement) {
    if (matches(curr, selector)) return curr;
    curr = curr.parentNode;
  }
  return null;
}

/**
 * Checks to see if we should be loading this URL
 *
 * @param   {string}    url - url being evaluated
 * @param   {string}    blacklist - jquery selector
 */
function shouldLoadAnchor(anchor, blacklist, hrefRegex) {
  var href = anchor.href;
  // URL will only be loaded if it's not an external link, hash, or
  // blacklisted
  return !isExternal(href) && !isHash(href) && !matches(anchor, blacklist) && anchor.target === '' && (hrefRegex === null || href.search(hrefRegex) !== -1);
}

function getScrollHeight() {
  var h = document.documentElement;
  var b = document.body;
  var sh = 'scrollHeight';
  return h[sh] || b[sh];
}

function getScrollLeft() {
  return window.pageXOffset || document.body.scrollLeft;
}

function getScrollTop() {
  return window.pageYOffset || document.body.scrollTop;
}

function expInterval(init, exp) {
  return _Observable.Observable.create(function (observer) {
    var n = init;
    var id = void 0;

    function next() {
      observer.next(n);
      n *= exp;
      id = setTimeout(next, n);
    }

    id = setTimeout(next, n);

    return function () {
      clearTimeout(id);
    };
  });
}

function fragmentFromString(strHTML) {
  return document.createRange().createContextualFragment(strHTML);
}

},{"rxjs/Observable":171}],266:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;_e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }return _arr;
  }return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _Observable = require('rxjs/Observable');

var _Subject = require('rxjs/Subject');

require('rxjs/add/observable/defer');

require('rxjs/add/observable/fromEvent');

require('rxjs/add/observable/merge');

require('rxjs/add/observable/of');

require('rxjs/add/observable/throw');

require('rxjs/add/observable/timer');

require('rxjs/add/observable/dom/ajax');

require('rxjs/add/operator/catch');

require('rxjs/add/operator/debounceTime');

require('rxjs/add/operator/delay');

require('rxjs/add/operator/distinctUntilKeyChanged');

require('rxjs/add/operator/do');

require('rxjs/add/operator/filter');

require('rxjs/add/operator/map');

require('rxjs/add/operator/mergeAll');

require('rxjs/add/operator/retryWhen');

require('rxjs/add/operator/share');

require('rxjs/add/operator/startWith');

require('rxjs/add/operator/switch');

require('rxjs/add/operator/switchMap');

require('rxjs/add/operator/take');

require('rxjs/add/operator/takeUntil');

require('rxjs/add/operator/throttleTime');

require('rxjs/add/operator/withLatestFrom');

require('rxjs/add/operator/zip');

var _componentCore2 = require('y-component/src/component-core');

var _componentCore3 = _interopRequireDefault(_componentCore2);

var _common = require('../common');

var _kind = require('./kind');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /*
   * Adapted from Miguel ngel Prez's smoothState.js
   * https://github.com/miguel-perez/smoothState.js
   *
   * Copyright (c) 2016 Florian Klampfer
   * Licensed under MIT
   */

/*
eslint-disable
import/no-extraneous-dependencies,
import/no-unresolved,
import/extensions,
no-console
*/

// const JS_FEATURES = [
//   'fn/array/for-each',
//   'fn/function/bind',
//   'fn/number/constructor',
//   'fn/object/assign',
//   'fn/object/define-property',
//   'fn/object/keys',
// ];
//
// const MODERNIZR_TESTS = [
//   'customevent',
//   'documentfragment',
//   'eventlistener',
//   'history',
//   'requestanimationframe',
//   'queryselector',
// ];

// ~ mixin pushStateCore with componentCore { ...
exports.default = function (C) {
  return function (_componentCore) {
    _inherits(_class, _componentCore);

    function _class() {
      _classCallCheck(this, _class);

      return _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
    }

    _createClass(_class, [{
      key: 'getComponentName',

      // @override
      value: function getComponentName() {
        return 'y-push-state';
      }

      // @override

    }, {
      key: 'defaults',
      value: function defaults() {
        return {
          replaceIds: [],
          linkSelector: 'a[href]',
          scrollRestoration: false,
          hrefRegex: null,
          blacklist: '.no-push-state',
          duration: 0,
          noPopDuration: true
        };
      }

      // @override

    }, {
      key: 'sideEffects',
      value: function sideEffects() {
        return {};
      }

      // @override

    }, {
      key: 'startHistory',
      value: function startHistory() {
        this.checkPreCondition();
        this.setupScrollRestoration();
        this.cacheTitleElement();
        this.setupObservables();
        return this;
      }
    }, {
      key: 'checkPreCondition',
      value: function checkPreCondition() {
        if (this.replaceIds.length === 0) {
          var id = this.el.id;
          if (id) {
            console.warn('No replace ids provided. Will replace entire content of #' + id);
          } else {
            throw Error('No replace ids provided nor does this component have and id');
          }
        }
      }
    }, {
      key: 'setupScrollRestoration',
      value: function setupScrollRestoration() {
        var _this2 = this;

        if ('scrollRestoration' in history) {
          history.scrollRestoration = this.scrollRestoration ? 'manual' : 'auto';
        }

        this.resetScrollPostion();
        window.addEventListener('beforeunload', function () {
          _this2.updateHistoryState();
        });
      }
    }, {
      key: 'cacheTitleElement',
      value: function cacheTitleElement() {
        this.titleElement = document.querySelector('title') || {};
      }
    }, {
      key: 'bindPushEvents',
      value: function bindPushEvents(link$) {
        var _this3 = this;

        return this.fromEvents(link$, 'click').map(function (event) {
          return new _kind.Push(event);
        }).filter(function (kind) {
          return _this3.isPageChangeEvent(kind);
        }).do(function (_ref) {
          var event = _ref.event;

          _this3.updateHistoryState();
          event.preventDefault();
        });
      }
    }, {
      key: 'bindHintEvents',
      value: function bindHintEvents(link$) {
        var _this4 = this;

        return _Observable.Observable.merge(this.fromEvents(link$, 'mouseenter'), this.fromEvents(link$, 'touchstart'), this.fromEvents(link$, 'focus')).map(function (event) {
          return new _kind.Hint(event);
        }).filter(function (kind) {
          return _this4.isPageChangeAnchor(kind);
        });
      }
    }, {
      key: 'bindPopstateEvent',
      value: function bindPopstateEvent() {
        return _Observable.Observable.fromEvent(window, 'popstate').map(function (event) {
          return new _kind.Pop(event);
        }).filter(function () {
          return window.history.state != null;
        });
      }
    }, {
      key: 'linkObservable',
      value: function linkObservable() {
        return _Observable.Observable.of(this.el.querySelectorAll(this.linkSelector));
      }
    }, {
      key: 'fromEvents',
      value: function fromEvents(link$, event) {
        return link$.map(function (link) {
          return _Observable.Observable.fromEvent(link, event);
        }).mergeAll();
      }
    }, {
      key: 'fetchPage',
      value: function fetchPage(kind) {
        var _this5 = this;

        return _Observable.Observable.ajax(this.hrefToAjax(kind)).map(function (_ref2) {
          var response = _ref2.response;
          return Object.assign(kind, { response: response });
        }).catch(function (error) {
          return _this5.recoverIfResponse(kind, error);
        }).retryWhen(function () {
          return _Observable.Observable.merge(_Observable.Observable.fromEvent(window, 'online'), (0, _common.expInterval)(1000, 2)).do(_this5.onRetry.bind(_this5, kind));
        });
      }
    }, {
      key: 'hrefToAjax',
      value: function hrefToAjax(_ref3) {
        var href = _ref3.href;

        return {
          method: 'GET',
          url: href,
          responseType: 'text'
        };
      }
    }, {
      key: 'recoverIfResponse',
      value: function recoverIfResponse(kind, error) {
        var status = error.status,
            xhr = error.xhr;

        if (xhr && status && status > 400) {
          // Recover with error page returned from server.
          // NOTE: This assumes error page contains the same ids as the other pages...
          return _Observable.Observable.of(Object.assign(kind, { response: xhr.response }));
        }

        // else
        this.onError(Object.assign(kind, error));
        return _Observable.Observable.throw(error);
      }
    }, {
      key: 'setupObservables',
      value: function setupObservables() {
        var _this6 = this;

        // See `renewEventListeners`
        // TODO: Possible without subjects?
        this.push$$ = new _Subject.Subject();
        this.hint$$ = new _Subject.Subject();

        var push$ = this.push$$.switch()
        // TODO: This prevents a whole class of concurrency bugs,
        // This is not an issue for fast animations (and prevents accidential double tapping)
        // Ideally the UI is fully repsonsive at all times though..
        // Note that spamming the back/forward button is still possible (only affects `push$`)
        .throttleTime(this.duration + 100);

        var pop$ = this.bindPopstateEvent();

        // Definitive page change (i.e. either push or pop event)
        this.page$ = _Observable.Observable.merge(push$, pop$).share();

        // We don't want to prefetch (i.e. use bandwidth) for a _probabilistic_ page load,
        // while a _definitive_ page load is going on => `pauser$` stream.
        // Needs to be deferred b/c of "cyclical" dependency.
        var pauser$ = _Observable.Observable.defer(function () {
          return _Observable.Observable.merge(
          // A page change event means we want to pause prefetching
          _this6.page$.map(function () {
            return true;
          }),
          // A render complete event means we want to resume prefetching
          _this6.render$.map(function () {
            return false;
          }))
          // Start with prefetching
          .startWith(false);
        });

        // The stream of hint (prefetch) events, possibly paused.
        // Dream syntax (not supported, yet): `this.hint$$.switch().pauseable(pauser$)`
        this.hint$ = this.hint$$.switch().withLatestFrom(pauser$).filter(function (_ref4) {
          var _ref5 = _slicedToArray(_ref4, 2),
              paused = _ref5[1];

          return paused === false;
        }).map(function (_ref6) {
          var _ref7 = _slicedToArray(_ref6, 1),
              x = _ref7[0];

          return x;
        });

        // The stream of (pre-)fetch events.
        // Includes definitive page change events do deal with unexpected page changes.
        this.prefetch$ = _Observable.Observable.merge(this.hint$, this.page$).distinctUntilKeyChanged('href') // Don't abort a request if the user "jiggles" over a link
        .switchMap(function (kind) {
          return _this6.fetchPage(kind);
        }).catch(function (err, caught) {
          return caught;
        }).startWith({}) // Start with some value so `withLatestFrom` below doesn't "block"
        .share();

        this.render$ = this.page$.do(this.onStart.bind(this)).withLatestFrom(this.prefetch$).switchMap(this.getResponse.bind(this)).map(this.responseToContent.bind(this)).do(this.onReady.bind(this)).do(this.updateDOM.bind(this)).do(this.resetScrollPostion.bind(this)).do(this.onAfter.bind(this)).catch(function (error, caught) {
          _this6.onError(error);
          return caught;
        })
        // `share`ing the stream between the subscription below and `pauser$`.
        .share();

        this.render$
        // Renewing event listeners after DOM update/layout/painting is complete
        // HACK: don't use time, use outside observable instead?
        .debounceTime(this.duration).do(this.renewEventListeners.bind(this)).subscribe();

        // fire `progress` event when fetching takes longer than `this.duration`.
        this.page$
        // HACK: add some time, jtbs
        .switchMap(function () {
          return _Observable.Observable.timer(_this6.duration + 200).takeUntil(_this6.render$);
        }).subscribe(this.onProgress.bind(this));

        // Start pulling values
        this.render$.subscribe();

        // Push streams into `push$$` and `hint$$`
        this.renewEventListeners();
      }
    }, {
      key: 'getResponse',
      value: function getResponse(_ref8) {
        var _ref9 = _slicedToArray(_ref8, 2),
            kind = _ref9[0],
            prefetch = _ref9[1];

        var res = void 0;

        // Prefetch already complete, use result
        if (kind.href === prefetch.href) {
          res = _Observable.Observable.of(Object.assign(kind, { response: prefetch.response }));

          if (kind instanceof _kind.Push || !this.noPopDuration) {
            // HACK: add some extra time to prevent 'flickering'
            // ideally, we'd like to take an animation observable as input instead
            res = res.delay(this.duration + 100);
          }
          // Prefetch in progress, use next result (this is why `prefetch$` had to be `share`d)
        } else {
          res = this.prefetch$.take(1).map(function (fetch) {
            return Object.assign(kind, { response: fetch.response });
          });

          if (kind instanceof _kind.Push || !this.noPopDuration) {
            // HACK: add some extra time to prevent 'flickering'
            // ideally, we'd like to take an animation observable as input instead
            res = res.zip(_Observable.Observable.timer(this.duration + 100), function (x) {
              return x;
            });
          }
        }

        return res;
      }
    }, {
      key: 'onStart',
      value: function onStart(sponge) {
        var href = sponge.href;

        if (sponge instanceof _kind.Push) {
          window.history.pushState({ id: this.componentName }, '', href);
        }

        this.fireEvent('start', { detail: sponge });
      }
    }, {
      key: 'onProgress',
      value: function onProgress(sponge) {
        this.fireEvent('progress', { detail: sponge });
      }
    }, {
      key: 'responseToContent',
      value: function responseToContent(sponge) {
        var response = sponge.response;

        var documentFragment = (0, _common.fragmentFromString)(response);
        var title = this.getTitleFromDocumentFragment(documentFragment);
        var content = this.getContentFromDocumentFragment(documentFragment);

        return Object.assign(sponge, { title: title, content: content });
      }
    }, {
      key: 'onReady',
      value: function onReady(sponge) {
        this.fireEvent('ready', { detail: sponge });
      }
    }, {
      key: 'updateDOM',
      value: function updateDOM(sponge) {
        try {
          var href = sponge.href,
              title = sponge.title,
              content = sponge.content;

          if (sponge instanceof _kind.Push) {
            window.history.replaceState({ id: this.componentName }, title, href);
          }

          this.titleElement.textContent = title;
          this.replaceContent(content);
        } catch (error) {
          throw Object.assign(sponge, { error: error });
        }
      }
    }, {
      key: 'onAfter',
      value: function onAfter(sponge) {
        this.fireEvent('after', { detail: sponge });
      }
    }, {
      key: 'renewEventListeners',
      value: function renewEventListeners() {
        var link$ = this.linkObservable();
        this.push$$.next(this.bindPushEvents(link$));
        this.hint$$.next(this.bindHintEvents(link$));
      }
    }, {
      key: 'onError',
      value: function onError(err) {
        this.el.style.willChange = '';
        this.fireEvent('error', { detail: err });
      }
    }, {
      key: 'onRetry',
      value: function onRetry(kind) {
        this.fireEvent('retry', { detail: kind });
      }
    }, {
      key: 'isPageChangeEvent',
      value: function isPageChangeEvent(kind) {
        var event = kind.event;

        return !event.metaKey && !event.ctrlKey && this.isPageChangeAnchor(kind);
      }
    }, {
      key: 'isPageChangeAnchor',
      value: function isPageChangeAnchor(_ref10) {
        var anchor = _ref10.event.currentTarget;

        return anchor != null && (0, _common.shouldLoadAnchor)(anchor, this.blacklist, this.hrefRegex);
      }
    }, {
      key: 'getTitleFromDocumentFragment',
      value: function getTitleFromDocumentFragment(documentFragment) {
        return (documentFragment.querySelector('title') || {}).textContent;
      }
    }, {
      key: 'getContentFromDocumentFragment',
      value: function getContentFromDocumentFragment(documentFragment) {
        if (this.replaceIds.length > 0) {
          return this.replaceIds.map(function (id) {
            return documentFragment.getElementById(id);
          });
        }

        return documentFragment.getElementById(this.el.id);
      }
    }, {
      key: 'replaceContent',
      value: function replaceContent(content) {
        if (this.replaceIds.length > 0) {
          this.replaceContentByIds(content);
        } else {
          this.replaceContentWholesale(content);
        }
      }
    }, {
      key: 'replaceContentByIds',
      value: function replaceContentByIds(elements) {
        var oldElements = this.replaceIds.map(function (id) {
          return document.getElementById(id);
        });

        Array.prototype.forEach.call(oldElements, function (oldElement) {
          oldElement.parentNode.replaceChild(elements.shift(), oldElement);
        });
      }
    }, {
      key: 'replaceContentWholesale',
      value: function replaceContentWholesale(content) {
        this.el.innerHTML = content.innerHTML;
      }
    }, {
      key: 'saveScrollPosition',
      value: function saveScrollPosition(state) {
        return Object.assign(state, {
          scrollTop: (0, _common.getScrollTop)(),
          scrollHeight: (0, _common.getScrollHeight)()
        });
      }
    }, {
      key: 'updateHistoryState',
      value: function updateHistoryState() {
        var state = history.state || { id: this.componentName };
        state = this.scrollRestoration ? this.saveScrollPosition(state) : state;
        history.replaceState(state, document.title, window.location.href);
      }
    }, {
      key: 'resetScrollPostion',
      value: function resetScrollPostion(sponge) {
        if (this.scrollRestoration) {
          if (sponge instanceof _kind.Pop) {
            var state = history.state || {};
            document.body.style.minHeight = (state.scrollHeight || 0) + 'px';
            if (state.scrollTop != null) window.scroll(window.pageXOffset, state.scrollTop);
          }

          document.body.style.minHeight = '';
        }
      }
    }]);

    return _class;
  }((0, _componentCore3.default)(C));
};

},{"../common":265,"./kind":267,"rxjs/Observable":171,"rxjs/Subject":175,"rxjs/add/observable/defer":179,"rxjs/add/observable/dom/ajax":180,"rxjs/add/observable/fromEvent":181,"rxjs/add/observable/merge":182,"rxjs/add/observable/of":183,"rxjs/add/observable/throw":184,"rxjs/add/observable/timer":185,"rxjs/add/operator/catch":186,"rxjs/add/operator/debounceTime":187,"rxjs/add/operator/delay":188,"rxjs/add/operator/distinctUntilKeyChanged":189,"rxjs/add/operator/do":190,"rxjs/add/operator/filter":191,"rxjs/add/operator/map":192,"rxjs/add/operator/mergeAll":193,"rxjs/add/operator/retryWhen":194,"rxjs/add/operator/share":195,"rxjs/add/operator/startWith":196,"rxjs/add/operator/switch":197,"rxjs/add/operator/switchMap":198,"rxjs/add/operator/take":199,"rxjs/add/operator/takeUntil":200,"rxjs/add/operator/throttleTime":201,"rxjs/add/operator/withLatestFrom":202,"rxjs/add/operator/zip":203,"y-component/src/component-core":165}],267:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Kind = exports.Kind = function Kind(event) {
  _classCallCheck(this, Kind);

  this.event = event;
};

var Push = exports.Push = function (_Kind) {
  _inherits(Push, _Kind);

  function Push(event) {
    _classCallCheck(this, Push);

    var _this = _possibleConstructorReturn(this, (Push.__proto__ || Object.getPrototypeOf(Push)).call(this, event));

    _this.href = event.currentTarget.href;
    return _this;
  }

  _createClass(Push, [{
    key: 'type',
    get: function get() {
      return 'push';
    }
  }]);

  return Push;
}(Kind);

var Hint = exports.Hint = function (_Kind2) {
  _inherits(Hint, _Kind2);

  function Hint(event) {
    _classCallCheck(this, Hint);

    var _this2 = _possibleConstructorReturn(this, (Hint.__proto__ || Object.getPrototypeOf(Hint)).call(this, event));

    _this2.href = event.currentTarget.href;
    return _this2;
  }

  _createClass(Hint, [{
    key: 'type',
    get: function get() {
      return 'hint';
    }
  }]);

  return Hint;
}(Kind);

var Pop = exports.Pop = function (_Kind3) {
  _inherits(Pop, _Kind3);

  function Pop(event) {
    _classCallCheck(this, Pop);

    var _this3 = _possibleConstructorReturn(this, (Pop.__proto__ || Object.getPrototypeOf(Pop)).call(this, event));

    _this3.href = window.location.href;
    return _this3;
  }

  _createClass(Pop, [{
    key: 'type',
    get: function get() {
      return 'pop';
    }
  }]);

  return Pop;
}(Kind);

},{}],268:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
    }
  }return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
  };
}();

var _core = require('../core');

var _core2 = _interopRequireDefault(_core);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
  }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
} /*
   * Copyright (c) 2016 Florian Klampfer
   * Licensed under MIT
   */

var PushState = function (_pushStateCore) {
  _inherits(PushState, _pushStateCore);

  function PushState(el, props) {
    _classCallCheck(this, PushState);

    var _this = _possibleConstructorReturn(this, (PushState.__proto__ || Object.getPrototypeOf(PushState)).call(this));

    _this.setupComponent(el, props);
    return _this;
  }

  // @override


  _createClass(PushState, [{
    key: 'setupDOM',
    value: function setupDOM(el) {
      if (!el) throw Error('No element provided');
      return el;
    }
  }]);

  return PushState;
}((0, _core2.default)());

exports.default = PushState;

},{"../core":266}]},{},[8])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJfanMvbGliL21vZGVybml6ci5qcyIsIl9qcy9zcmMvY29tbW9uLmpzIiwiX2pzL3NyYy9jcm9zcy1mYWRlci5qcyIsIl9qcy9zcmMvZHJhd2VyLmpzIiwiX2pzL3NyYy9mbGlwL2ZsaXAuanMiLCJfanMvc3JjL2ZsaXAvcHJvamVjdC5qcyIsIl9qcy9zcmMvZmxpcC90aXRsZS5qcyIsIl9qcy9zcmMvaW5kZXguanMiLCJfanMvc3JjL2thdGV4LmpzIiwiX2pzL3NyYy9wdXNoLXN0YXRlLmpzIiwiX2pzL3NyYy9zdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL2FycmF5L2Zvci1lYWNoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vYXJyYXkvcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vZnVuY3Rpb24vYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL251bWJlci9jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL2ZuL29iamVjdC9hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvZm4vb2JqZWN0L2tleXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYW4tb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktaW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1tZXRob2RzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktcmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYXJyYXktc3BlY2llcy1jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvZi5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2NvcmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZW51bS1idWcta2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2V4cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2ZhaWxzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGFzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faGlkZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2h0bWwuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX2luaGVyaXQtaWYtcmVxdWlyZWQuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pbnZva2UuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9faXMtYXJyYXkuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1kcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ29wZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1nb3BuLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LWdvcHMuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXBpZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX29iamVjdC1zYXAuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fcmVkZWZpbmUuanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtcHJvdG8uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc2hhcmVkLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaWN0LW1ldGhvZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3N0cmluZy10cmltLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fc3RyaW5nLXdzLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fdG8taW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLWxlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLW9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3VpZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvX3drcy5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2LmFycmF5LmZvci1lYWNoLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlLmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm51bWJlci5jb25zdHJ1Y3Rvci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24uanMiLCJub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwibm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczYub2JqZWN0LmtleXMuanMiLCJub2RlX21vZHVsZXMvZmctbG9hZGNzcy9zcmMvbG9hZENTUy5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9rYXRleC5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvTGV4ZXIuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL01hY3JvRXhwYW5kZXIuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL09wdGlvbnMuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL1BhcnNlRXJyb3IuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL1BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvU2V0dGluZ3MuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL1N0eWxlLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9idWlsZENvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvYnVpbGRIVE1MLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9idWlsZE1hdGhNTC5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvYnVpbGRUcmVlLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9kZWxpbWl0ZXIuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2RvbVRyZWUuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2Vudmlyb25tZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvZm9udE1ldHJpY3MuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL2ZvbnRNZXRyaWNzRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvZnVuY3Rpb25zLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9tYXRoTUxUcmVlLmpzIiwibm9kZV9tb2R1bGVzL2thdGV4L3NyYy9wYXJzZURhdGEuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL3BhcnNlVHJlZS5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvc3ltYm9scy5qcyIsIm5vZGVfbW9kdWxlcy9rYXRleC9zcmMvdW5pY29kZVJlZ2V4ZXMuanMiLCJub2RlX21vZHVsZXMva2F0ZXgvc3JjL3V0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21hdGNoLWF0L2xpYi9tYXRjaEF0LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvSW5uZXJTdWJzY3JpYmVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvT2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL09ic2VydmVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvT3V0ZXJTdWJzY3JpYmVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvU2NoZWR1bGVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvU3ViamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL1N1YmplY3RTdWJzY3JpcHRpb24uanMiLCJub2RlX21vZHVsZXMvcnhqcy9TdWJzY3JpYmVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvU3Vic2NyaXB0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvRW1wdHlPYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9Gcm9tRXZlbnRPYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9TY2FsYXJPYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9UaW1lck9ic2VydmFibGUuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL29mLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS90aW1lci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2NhdGNoLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvY29uY2F0LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZGVib3VuY2VUaW1lLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZG8uanMiLCJub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9leGhhdXN0TWFwLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZmluYWxseS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL21hcC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL21lcmdlQWxsLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWVyZ2VNYXAuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9tdWx0aWNhc3QuanMiLCJub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9wYWlyd2lzZS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3NoYXJlLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3Ivc3RhcnRXaXRoLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3Ivc3dpdGNoTWFwLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvdGFrZVVudGlsLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvemlwLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvc2NoZWR1bGVyL0FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9Bc3luY0FjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9Bc3luY1NjaGVkdWxlci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9hc3luYy5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3N5bWJvbC9pdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3N5bWJvbC9vYnNlcnZhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvc3ltYm9sL3J4U3Vic2NyaWJlci5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL2Vycm9yT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc0FycmF5TGlrZS5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvaXNEYXRlLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc0Z1bmN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc051bWVyaWMuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9pc1Byb21pc2UuanMiLCJub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzU2NoZWR1bGVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9yb290LmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdC5qcyIsIm5vZGVfbW9kdWxlcy9yeGpzL3V0aWwvdG9TdWJzY3JpYmVyLmpzIiwibm9kZV9tb2R1bGVzL3J4anMvdXRpbC90cnlDYXRjaC5qcyIsIm5vZGVfbW9kdWxlcy93ZWItYW5pbWF0aW9ucy1qcy93ZWItYW5pbWF0aW9ucy5taW4uanMiLCIuLi8ubnBtLXBhY2thZ2VzL2xpYi9ub2RlX21vZHVsZXMveS1jb21wb25lbnQvc3JjL2NvbXBvbmVudC1jb3JlLmpzIiwiLi4veS1kcmF3ZXIvc3JjL2NvbW1vbi5qcyIsIi4uL3ktZHJhd2VyL3NyYy9jb3JlL2luZGV4LmpzIiwiLi4veS1kcmF3ZXIvc3JjL3ZhbmlsbGEvaW5kZXguanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvSW5uZXJTdWJzY3JpYmVyLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL05vdGlmaWNhdGlvbi5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9PYnNlcnZlci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9PdXRlclN1YnNjcmliZXIuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvU3ViamVjdC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9TdWJqZWN0U3Vic2NyaXB0aW9uLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL1N1YnNjcmliZXIuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvU3Vic2NyaXB0aW9uLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL2RlZmVyLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL2RvbS9hamF4LmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS9tZXJnZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS9vZi5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS90aHJvdy5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb2JzZXJ2YWJsZS90aW1lci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvY2F0Y2guanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2RlYm91bmNlVGltZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvZGVsYXkuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9kby5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3IvZmlsdGVyLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9tYXAuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL21lcmdlQWxsLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9yZXRyeVdoZW4uanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3NoYXJlLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci9zdGFydFdpdGguanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3N3aXRjaC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci90YWtlLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL2FkZC9vcGVyYXRvci90YWtlVW50aWwuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3Rocm90dGxlVGltZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9hZGQvb3BlcmF0b3Ivd2l0aExhdGVzdEZyb20uanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvYWRkL29wZXJhdG9yL3ppcC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0RlZmVyT2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0Vycm9yT2JzZXJ2YWJsZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL0Zyb21FdmVudE9ic2VydmFibGUuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9TY2FsYXJPYnNlcnZhYmxlLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvVGltZXJPYnNlcnZhYmxlLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvZGVmZXIuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9kb20vQWpheE9ic2VydmFibGUuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb2JzZXJ2YWJsZS9kb20vYWpheC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vYnNlcnZhYmxlL21lcmdlLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29ic2VydmFibGUvdGhyb3cuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvY2F0Y2guanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvZGVib3VuY2VUaW1lLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2RlbGF5LmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxDaGFuZ2VkLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2RvLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL2ZpbHRlci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9tYXAuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWVyZ2UuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvbWVyZ2VBbGwuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvcmV0cnlXaGVuLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3N3aXRjaC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci9zd2l0Y2hNYXAuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvdGFrZS5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9vcGVyYXRvci90YWtlVW50aWwuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvb3BlcmF0b3IvdGhyb3R0bGVUaW1lLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3dpdGhMYXRlc3RGcm9tLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL29wZXJhdG9yL3ppcC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9zY2hlZHVsZXIvQWN0aW9uLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL3NjaGVkdWxlci9Bc3luY0FjdGlvbi5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy9zY2hlZHVsZXIvQXN5bmNTY2hlZHVsZXIuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvc3ltYm9sL2l0ZXJhdG9yLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL3N5bWJvbC9vYnNlcnZhYmxlLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL3N5bWJvbC9yeFN1YnNjcmliZXIuanMiLCIuLi95LXB1c2gtc3RhdGUvbm9kZV9tb2R1bGVzL3J4anMvdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yLmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvci5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9ub2RlX21vZHVsZXMvcnhqcy91dGlsL2lzT2JqZWN0LmpzIiwiLi4veS1wdXNoLXN0YXRlL25vZGVfbW9kdWxlcy9yeGpzL3V0aWwvcm9vdC5qcyIsIi4uL3ktcHVzaC1zdGF0ZS9zcmMvY29tbW9uLmpzIiwiLi4veS1wdXNoLXN0YXRlL3NyYy9jb3JlL2luZGV4LmpzIiwiLi4veS1wdXNoLXN0YXRlL3NyYy9jb3JlL2tpbmQuanMiLCIuLi95LXB1c2gtc3RhdGUvc3JjL3ZhbmlsbGEvaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBOztBQUVBLENBQUMsVUFBUyxDQUFULEVBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZTtBQUFDLFdBQVMsQ0FBVCxDQUFXLENBQVgsRUFBYSxDQUFiLEVBQWU7QUFBQyxXQUFPLE9BQU8sQ0FBUCxLQUFXLENBQWxCO0FBQW9CLFlBQVMsQ0FBVCxHQUFZO0FBQUMsUUFBSSxDQUFKLEVBQU0sQ0FBTixFQUFRLENBQVIsRUFBVSxDQUFWLEVBQVksQ0FBWixFQUFjLENBQWQsRUFBZ0IsQ0FBaEIsQ0FBa0IsS0FBSSxJQUFJLENBQVIsSUFBYSxDQUFiLEVBQWUsSUFBRyxFQUFFLGNBQUYsQ0FBaUIsQ0FBakIsQ0FBSCxFQUF1QjtBQUFDLFVBQUcsSUFBRSxFQUFGLEVBQUssSUFBRSxFQUFFLENBQUYsQ0FBUCxFQUFZLEVBQUUsSUFBRixLQUFTLEVBQUUsSUFBRixDQUFPLEVBQUUsSUFBRixDQUFPLFdBQVAsRUFBUCxHQUE2QixFQUFFLE9BQUYsSUFBVyxFQUFFLE9BQUYsQ0FBVSxPQUFyQixJQUE4QixFQUFFLE9BQUYsQ0FBVSxPQUFWLENBQWtCLE1BQXRGLENBQWYsRUFBNkcsS0FBSSxJQUFFLENBQU4sRUFBUSxJQUFFLEVBQUUsT0FBRixDQUFVLE9BQVYsQ0FBa0IsTUFBNUIsRUFBbUMsR0FBbkMsRUFBdUMsRUFBRSxJQUFGLENBQU8sRUFBRSxPQUFGLENBQVUsT0FBVixDQUFrQixDQUFsQixFQUFxQixXQUFyQixFQUFQLEVBQTJDLEtBQUksSUFBRSxFQUFFLEVBQUUsRUFBSixFQUFPLFVBQVAsSUFBbUIsRUFBRSxFQUFGLEVBQW5CLEdBQTBCLEVBQUUsRUFBOUIsRUFBaUMsSUFBRSxDQUF2QyxFQUF5QyxJQUFFLEVBQUUsTUFBN0MsRUFBb0QsR0FBcEQsRUFBd0QsSUFBRSxFQUFFLENBQUYsQ0FBRixFQUFPLElBQUUsRUFBRSxLQUFGLENBQVEsR0FBUixDQUFULEVBQXNCLE1BQUksRUFBRSxNQUFOLEdBQWEsVUFBVSxFQUFFLENBQUYsQ0FBVixJQUFnQixDQUE3QixJQUFnQyxDQUFDLFVBQVUsRUFBRSxDQUFGLENBQVYsQ0FBRCxJQUFrQixVQUFVLEVBQUUsQ0FBRixDQUFWLGFBQTBCLE9BQTVDLEtBQXNELFVBQVUsRUFBRSxDQUFGLENBQVYsSUFBZ0IsSUFBSSxPQUFKLENBQVksVUFBVSxFQUFFLENBQUYsQ0FBVixDQUFaLENBQXRFLEdBQW9HLFVBQVUsRUFBRSxDQUFGLENBQVYsRUFBZ0IsRUFBRSxDQUFGLENBQWhCLElBQXNCLENBQTFKLENBQXRCLEVBQW1MLEVBQUUsSUFBRixDQUFPLENBQUMsSUFBRSxFQUFGLEdBQUssS0FBTixJQUFhLEVBQUUsSUFBRixDQUFPLEdBQVAsQ0FBcEIsQ0FBbkw7QUFBb047QUFBQyxZQUFTLENBQVQsQ0FBVyxDQUFYLEVBQWE7QUFBQyxXQUFPLEVBQUUsT0FBRixDQUFVLGtCQUFWLEVBQTZCLFVBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYSxDQUFiLEVBQWU7QUFBQyxhQUFPLElBQUUsRUFBRSxXQUFGLEVBQVQ7QUFBeUIsS0FBdEUsRUFBd0UsT0FBeEUsQ0FBZ0YsSUFBaEYsRUFBcUYsRUFBckYsQ0FBUDtBQUFnRyxZQUFTLENBQVQsR0FBWTtBQUFDLFdBQU0sY0FBWSxPQUFPLEVBQUUsYUFBckIsR0FBbUMsRUFBRSxhQUFGLENBQWdCLFVBQVUsQ0FBVixDQUFoQixDQUFuQyxHQUFpRSxJQUFFLEVBQUUsZUFBRixDQUFrQixJQUFsQixDQUF1QixDQUF2QixFQUF5Qiw0QkFBekIsRUFBc0QsVUFBVSxDQUFWLENBQXRELENBQUYsR0FBc0UsRUFBRSxhQUFGLENBQWdCLEtBQWhCLENBQXNCLENBQXRCLEVBQXdCLFNBQXhCLENBQTdJO0FBQWdMLFlBQVMsQ0FBVCxHQUFZO0FBQUMsUUFBSSxJQUFFLEVBQUUsSUFBUixDQUFhLE9BQU8sTUFBSSxJQUFFLEVBQUUsSUFBRSxLQUFGLEdBQVEsTUFBVixDQUFGLEVBQW9CLEVBQUUsSUFBRixHQUFPLENBQUMsQ0FBaEMsR0FBbUMsQ0FBMUM7QUFBNEMsWUFBUyxDQUFULENBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZSxDQUFmLEVBQWlCLENBQWpCLEVBQW1CO0FBQUMsUUFBSSxDQUFKO0FBQUEsUUFBTSxDQUFOO0FBQUEsUUFBUSxDQUFSO0FBQUEsUUFBVSxDQUFWO0FBQUEsUUFBWSxJQUFFLFdBQWQ7QUFBQSxRQUEwQixJQUFFLEVBQUUsS0FBRixDQUE1QjtBQUFBLFFBQXFDLElBQUUsR0FBdkMsQ0FBMkMsSUFBRyxTQUFTLENBQVQsRUFBVyxFQUFYLENBQUgsRUFBa0IsT0FBSyxHQUFMLEdBQVUsSUFBRSxFQUFFLEtBQUYsQ0FBRixFQUFXLEVBQUUsRUFBRixHQUFLLElBQUUsRUFBRSxDQUFGLENBQUYsR0FBTyxLQUFHLElBQUUsQ0FBTCxDQUF2QixFQUErQixFQUFFLFdBQUYsQ0FBYyxDQUFkLENBQS9CLENBQWdELE9BQU8sSUFBRSxFQUFFLE9BQUYsQ0FBRixFQUFhLEVBQUUsSUFBRixHQUFPLFVBQXBCLEVBQStCLEVBQUUsRUFBRixHQUFLLE1BQUksQ0FBeEMsRUFBMEMsQ0FBQyxFQUFFLElBQUYsR0FBTyxDQUFQLEdBQVMsQ0FBVixFQUFhLFdBQWIsQ0FBeUIsQ0FBekIsQ0FBMUMsRUFBc0UsRUFBRSxXQUFGLENBQWMsQ0FBZCxDQUF0RSxFQUF1RixFQUFFLFVBQUYsR0FBYSxFQUFFLFVBQUYsQ0FBYSxPQUFiLEdBQXFCLENBQWxDLEdBQW9DLEVBQUUsV0FBRixDQUFjLEVBQUUsY0FBRixDQUFpQixDQUFqQixDQUFkLENBQTNILEVBQThKLEVBQUUsRUFBRixHQUFLLENBQW5LLEVBQXFLLEVBQUUsSUFBRixLQUFTLEVBQUUsS0FBRixDQUFRLFVBQVIsR0FBbUIsRUFBbkIsRUFBc0IsRUFBRSxLQUFGLENBQVEsUUFBUixHQUFpQixRQUF2QyxFQUFnRCxJQUFFLEVBQUUsS0FBRixDQUFRLFFBQTFELEVBQW1FLEVBQUUsS0FBRixDQUFRLFFBQVIsR0FBaUIsUUFBcEYsRUFBNkYsRUFBRSxXQUFGLENBQWMsQ0FBZCxDQUF0RyxDQUFySyxFQUE2UixJQUFFLEVBQUUsQ0FBRixFQUFJLENBQUosQ0FBL1IsRUFBc1MsRUFBRSxJQUFGLElBQVEsRUFBRSxVQUFGLENBQWEsV0FBYixDQUF5QixDQUF6QixHQUE0QixFQUFFLEtBQUYsQ0FBUSxRQUFSLEdBQWlCLENBQTdDLEVBQStDLEVBQUUsWUFBekQsSUFBdUUsRUFBRSxVQUFGLENBQWEsV0FBYixDQUF5QixDQUF6QixDQUE3VyxFQUF5WSxDQUFDLENBQUMsQ0FBbFo7QUFBb1osWUFBUyxDQUFULENBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZTtBQUFDLFdBQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFHLENBQUosRUFBTyxPQUFQLENBQWUsQ0FBZixDQUFUO0FBQTJCLFlBQVMsQ0FBVCxDQUFXLENBQVgsRUFBYSxDQUFiLEVBQWU7QUFBQyxXQUFPLFlBQVU7QUFBQyxhQUFPLEVBQUUsS0FBRixDQUFRLENBQVIsRUFBVSxTQUFWLENBQVA7QUFBNEIsS0FBOUM7QUFBK0MsWUFBUyxDQUFULENBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZSxDQUFmLEVBQWlCO0FBQUMsUUFBSSxDQUFKLENBQU0sS0FBSSxJQUFJLENBQVIsSUFBYSxDQUFiLEVBQWUsSUFBRyxFQUFFLENBQUYsS0FBTyxDQUFWLEVBQVksT0FBTyxNQUFJLENBQUMsQ0FBTCxHQUFPLEVBQUUsQ0FBRixDQUFQLElBQWEsSUFBRSxFQUFFLEVBQUUsQ0FBRixDQUFGLENBQUYsRUFBVSxFQUFFLENBQUYsRUFBSSxVQUFKLElBQWdCLEVBQUUsQ0FBRixFQUFJLEtBQUcsQ0FBUCxDQUFoQixHQUEwQixDQUFqRCxDQUFQLENBQTJELE9BQU0sQ0FBQyxDQUFQO0FBQVMsWUFBUyxDQUFULENBQVcsQ0FBWCxFQUFhO0FBQUMsV0FBTyxFQUFFLE9BQUYsQ0FBVSxVQUFWLEVBQXFCLFVBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYTtBQUFDLGFBQU0sTUFBSSxFQUFFLFdBQUYsRUFBVjtBQUEwQixLQUE3RCxFQUErRCxPQUEvRCxDQUF1RSxNQUF2RSxFQUE4RSxNQUE5RSxDQUFQO0FBQTZGLFlBQVMsQ0FBVCxDQUFXLENBQVgsRUFBYSxDQUFiLEVBQWUsQ0FBZixFQUFpQjtBQUFDLFFBQUksQ0FBSixDQUFNLElBQUcsc0JBQXFCLENBQXhCLEVBQTBCO0FBQUMsVUFBRSxpQkFBaUIsSUFBakIsQ0FBc0IsQ0FBdEIsRUFBd0IsQ0FBeEIsRUFBMEIsQ0FBMUIsQ0FBRixDQUErQixJQUFJLElBQUUsRUFBRSxPQUFSLENBQWdCLElBQUcsU0FBTyxDQUFWLEVBQVksTUFBSSxJQUFFLEVBQUUsZ0JBQUYsQ0FBbUIsQ0FBbkIsQ0FBTixFQUFaLEtBQThDLElBQUcsQ0FBSCxFQUFLO0FBQUMsWUFBSSxJQUFFLEVBQUUsS0FBRixHQUFRLE9BQVIsR0FBZ0IsS0FBdEIsQ0FBNEIsRUFBRSxDQUFGLEVBQUssSUFBTCxDQUFVLENBQVYsRUFBWSxxRkFBWjtBQUFtRztBQUFDLEtBQTlQLE1BQW1RLElBQUUsQ0FBQyxDQUFELElBQUksRUFBRSxZQUFOLElBQW9CLEVBQUUsWUFBRixDQUFlLENBQWYsQ0FBdEIsQ0FBd0MsT0FBTyxDQUFQO0FBQVMsWUFBUyxDQUFULENBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZTtBQUFDLFFBQUksSUFBRSxFQUFFLE1BQVIsQ0FBZSxJQUFHLFNBQVEsQ0FBUixJQUFXLGNBQWEsRUFBRSxHQUE3QixFQUFpQztBQUFDLGFBQUssR0FBTCxHQUFVLElBQUcsRUFBRSxHQUFGLENBQU0sUUFBTixDQUFlLEVBQUUsRUFBRSxDQUFGLENBQUYsQ0FBZixFQUF1QixDQUF2QixDQUFILEVBQTZCLE9BQU0sQ0FBQyxDQUFQLENBQVMsT0FBTSxDQUFDLENBQVA7QUFBUyxTQUFHLHFCQUFvQixDQUF2QixFQUF5QjtBQUFDLFdBQUksSUFBSSxJQUFFLEVBQVYsRUFBYSxHQUFiLEdBQWtCLEVBQUUsSUFBRixDQUFPLE1BQUksRUFBRSxFQUFFLENBQUYsQ0FBRixDQUFKLEdBQVksR0FBWixHQUFnQixDQUFoQixHQUFrQixHQUF6QixFQUE4QixPQUFPLElBQUUsRUFBRSxJQUFGLENBQU8sTUFBUCxDQUFGLEVBQWlCLEVBQUUsZ0JBQWMsQ0FBZCxHQUFnQiwwQ0FBbEIsRUFBNkQsVUFBUyxDQUFULEVBQVc7QUFBQyxlQUFNLGNBQVksRUFBRSxDQUFGLEVBQUksSUFBSixFQUFTLFVBQVQsQ0FBbEI7QUFBdUMsT0FBaEgsQ0FBeEI7QUFBMEksWUFBTyxDQUFQO0FBQVMsWUFBUyxDQUFULENBQVcsQ0FBWCxFQUFhLENBQWIsRUFBZSxDQUFmLEVBQWlCLENBQWpCLEVBQW1CO0FBQUMsYUFBUyxDQUFULEdBQVk7QUFBQyxZQUFJLE9BQU8sRUFBRSxLQUFULEVBQWUsT0FBTyxFQUFFLE9BQTVCO0FBQXFDLFNBQUcsSUFBRSxFQUFFLENBQUYsRUFBSSxXQUFKLElBQWlCLENBQUMsQ0FBbEIsR0FBb0IsQ0FBdEIsRUFBd0IsQ0FBQyxFQUFFLENBQUYsRUFBSSxXQUFKLENBQTVCLEVBQTZDO0FBQUMsVUFBSSxJQUFFLEVBQUUsQ0FBRixFQUFJLENBQUosQ0FBTixDQUFhLElBQUcsQ0FBQyxFQUFFLENBQUYsRUFBSSxXQUFKLENBQUosRUFBcUIsT0FBTyxDQUFQO0FBQVMsVUFBSSxJQUFJLENBQUosRUFBTSxDQUFOLEVBQVEsQ0FBUixFQUFVLENBQVYsRUFBWSxDQUFaLEVBQWMsSUFBRSxDQUFDLFdBQUQsRUFBYSxPQUFiLEVBQXFCLE1BQXJCLENBQXBCLEVBQWlELENBQUMsRUFBRSxLQUFILElBQVUsRUFBRSxNQUE3RCxHQUFxRSxJQUFFLENBQUMsQ0FBSCxFQUFLLEVBQUUsT0FBRixHQUFVLEVBQUUsRUFBRSxLQUFGLEVBQUYsQ0FBZixFQUE0QixFQUFFLEtBQUYsR0FBUSxFQUFFLE9BQUYsQ0FBVSxLQUE5QyxDQUFvRCxLQUFJLElBQUUsRUFBRSxNQUFKLEVBQVcsSUFBRSxDQUFqQixFQUFtQixJQUFFLENBQXJCLEVBQXVCLEdBQXZCLEVBQTJCLElBQUcsSUFBRSxFQUFFLENBQUYsQ0FBRixFQUFPLElBQUUsRUFBRSxLQUFGLENBQVEsQ0FBUixDQUFULEVBQW9CLEVBQUUsQ0FBRixFQUFJLEdBQUosTUFBVyxJQUFFLEVBQUUsQ0FBRixDQUFiLENBQXBCLEVBQXVDLEVBQUUsS0FBRixDQUFRLENBQVIsTUFBYSxDQUF2RCxFQUF5RDtBQUFDLFVBQUcsS0FBRyxFQUFFLENBQUYsRUFBSSxXQUFKLENBQU4sRUFBdUIsT0FBTyxLQUFJLFNBQU8sQ0FBUCxHQUFTLENBQVQsR0FBVyxDQUFDLENBQXZCLENBQXlCLElBQUc7QUFBQyxVQUFFLEtBQUYsQ0FBUSxDQUFSLElBQVcsQ0FBWDtBQUFhLE9BQWpCLENBQWlCLE9BQU0sQ0FBTixFQUFRLENBQUUsS0FBRyxFQUFFLEtBQUYsQ0FBUSxDQUFSLEtBQVksQ0FBZixFQUFpQixPQUFPLEtBQUksU0FBTyxDQUFQLEdBQVMsQ0FBVCxHQUFXLENBQUMsQ0FBdkI7QUFBeUIsWUFBTyxLQUFJLENBQUMsQ0FBWjtBQUFjLFlBQVMsQ0FBVCxDQUFXLENBQVgsRUFBYSxDQUFiLEVBQWUsQ0FBZixFQUFpQixDQUFqQixFQUFtQixDQUFuQixFQUFxQjtBQUFDLFFBQUksSUFBRSxFQUFFLE1BQUYsQ0FBUyxDQUFULEVBQVksV0FBWixLQUEwQixFQUFFLEtBQUYsQ0FBUSxDQUFSLENBQWhDO0FBQUEsUUFBMkMsSUFBRSxDQUFDLElBQUUsR0FBRixHQUFNLEVBQUUsSUFBRixDQUFPLElBQUUsR0FBVCxDQUFOLEdBQW9CLENBQXJCLEVBQXdCLEtBQXhCLENBQThCLEdBQTlCLENBQTdDLENBQWdGLE9BQU8sRUFBRSxDQUFGLEVBQUksUUFBSixLQUFlLEVBQUUsQ0FBRixFQUFJLFdBQUosQ0FBZixHQUFnQyxFQUFFLENBQUYsRUFBSSxDQUFKLEVBQU0sQ0FBTixFQUFRLENBQVIsQ0FBaEMsSUFBNEMsSUFBRSxDQUFDLElBQUUsR0FBRixHQUFNLEVBQUUsSUFBRixDQUFPLElBQUUsR0FBVCxDQUFOLEdBQW9CLENBQXJCLEVBQXdCLEtBQXhCLENBQThCLEdBQTlCLENBQUYsRUFBcUMsRUFBRSxDQUFGLEVBQUksQ0FBSixFQUFNLENBQU4sQ0FBakYsQ0FBUDtBQUFrRyxZQUFTLENBQVQsQ0FBVyxDQUFYLEVBQWEsQ0FBYixFQUFlLENBQWYsRUFBaUI7QUFBQyxXQUFPLEVBQUUsQ0FBRixFQUFJLENBQUosRUFBTSxDQUFOLEVBQVEsQ0FBUixFQUFVLENBQVYsQ0FBUDtBQUFvQixPQUFJLElBQUUsRUFBTjtBQUFBLE1BQVMsSUFBRSxFQUFDLFVBQVMsT0FBVixFQUFrQixTQUFRLEVBQUMsYUFBWSxFQUFiLEVBQWdCLGVBQWMsQ0FBQyxDQUEvQixFQUFpQyxlQUFjLENBQUMsQ0FBaEQsRUFBa0QsYUFBWSxDQUFDLENBQS9ELEVBQTFCLEVBQTRGLElBQUcsRUFBL0YsRUFBa0csSUFBRyxVQUFTLENBQVQsRUFBVyxDQUFYLEVBQWE7QUFBQyxVQUFJLElBQUUsSUFBTixDQUFXLFdBQVcsWUFBVTtBQUFDLFVBQUUsRUFBRSxDQUFGLENBQUY7QUFBUSxPQUE5QixFQUErQixDQUEvQjtBQUFrQyxLQUFoSyxFQUFpSyxTQUFRLFVBQVMsQ0FBVCxFQUFXLENBQVgsRUFBYSxDQUFiLEVBQWU7QUFBQyxRQUFFLElBQUYsQ0FBTyxFQUFDLE1BQUssQ0FBTixFQUFRLElBQUcsQ0FBWCxFQUFhLFNBQVEsQ0FBckIsRUFBUDtBQUFnQyxLQUF6TixFQUEwTixjQUFhLFVBQVMsQ0FBVCxFQUFXO0FBQUMsUUFBRSxJQUFGLENBQU8sRUFBQyxNQUFLLElBQU4sRUFBVyxJQUFHLENBQWQsRUFBUDtBQUF5QixLQUE1USxFQUFYO0FBQUEsTUFBeVIsWUFBVSxZQUFVLENBQUUsQ0FBL1MsQ0FBZ1QsVUFBVSxTQUFWLEdBQW9CLENBQXBCLEVBQXNCLFlBQVUsSUFBSSxTQUFKLEVBQWhDLEVBQThDLFVBQVUsT0FBVixDQUFrQixlQUFsQixFQUFrQyxzQkFBcUIsQ0FBdkQsQ0FBOUMsRUFBd0csVUFBVSxPQUFWLENBQWtCLFNBQWxCLEVBQTRCLFlBQVU7QUFBQyxRQUFJLElBQUUsVUFBVSxTQUFoQixDQUEwQixPQUFNLENBQUMsQ0FBRCxLQUFLLEVBQUUsT0FBRixDQUFVLFlBQVYsQ0FBTCxJQUE4QixDQUFDLENBQUQsS0FBSyxFQUFFLE9BQUYsQ0FBVSxhQUFWLENBQW5DLElBQTZELENBQUMsQ0FBRCxLQUFLLEVBQUUsT0FBRixDQUFVLGVBQVYsQ0FBbEUsSUFBOEYsQ0FBQyxDQUFELEtBQUssRUFBRSxPQUFGLENBQVUsUUFBVixDQUFuRyxJQUF3SCxDQUFDLENBQUQsS0FBSyxFQUFFLE9BQUYsQ0FBVSxlQUFWLENBQTdILElBQXlKLFlBQVUsU0FBUyxRQUE1SyxHQUFxTCxFQUFFLE9BQUYsSUFBVyxlQUFjLEVBQUUsT0FBaE4sR0FBd04sQ0FBQyxDQUEvTjtBQUFpTyxHQUFsUyxDQUF4RyxFQUE0WSxVQUFVLE9BQVYsQ0FBa0IsZUFBbEIsRUFBa0MsbUJBQWtCLENBQWxCLElBQXFCLHNCQUFxQixDQUE1RSxDQUE1WSxDQUEyZCxJQUFJLElBQUUsRUFBTjtBQUFBLE1BQVMsSUFBRSxFQUFFLE9BQUYsQ0FBVSxXQUFWLEdBQXNCLDRCQUE0QixLQUE1QixDQUFrQyxHQUFsQyxDQUF0QixHQUE2RCxDQUFDLEVBQUQsRUFBSSxFQUFKLENBQXhFLENBQWdGLEVBQUUsU0FBRixHQUFZLENBQVosQ0FBYyxJQUFJLElBQUUsRUFBRSxlQUFSLENBQXdCLFVBQVUsT0FBVixDQUFrQixXQUFsQixFQUE4QixlQUFjLENBQTVDLEdBQStDLFVBQVUsT0FBVixDQUFrQixrQkFBbEIsRUFBcUMsWUFBVTtBQUFDLFdBQU0sNEJBQTJCLENBQTNCLElBQThCLGlCQUFnQixDQUFwRDtBQUFzRCxHQUF0RyxDQUEvQyxDQUF1SixJQUFJLElBQUUsVUFBUSxFQUFFLFFBQUYsQ0FBVyxXQUFYLEVBQWQsQ0FBdUMsVUFBVSxPQUFWLENBQWtCLFNBQWxCLEVBQTRCLFlBQVU7QUFBQyxRQUFJLElBQUUsRUFBRSxHQUFGLEVBQU8sS0FBYixDQUFtQixPQUFPLEVBQUUsT0FBRixHQUFVLEVBQUUsSUFBRixDQUFPLGNBQVAsQ0FBVixFQUFpQyxTQUFTLElBQVQsQ0FBYyxFQUFFLE9BQWhCLENBQXhDO0FBQWlFLEdBQTNILEdBQTZILFVBQVUsT0FBVixDQUFrQixrQkFBbEIsRUFBcUMsWUFBVTtBQUFDLFFBQUksSUFBRSxFQUFFLEdBQUYsRUFBTyxLQUFiLENBQW1CLE9BQU8sRUFBRSxPQUFGLEdBQVUscUJBQVYsRUFBZ0MsV0FBUyxFQUFFLGFBQWxEO0FBQWdFLEdBQW5JLENBQTdILEVBQWtRLFVBQVUsT0FBVixDQUFrQixZQUFsQixFQUErQixZQUFVO0FBQUMsUUFBSSxJQUFFLEVBQUUsR0FBRixFQUFPLEtBQWIsQ0FBbUIsSUFBRztBQUFDLFFBQUUsUUFBRixHQUFXLE1BQVg7QUFBa0IsS0FBdEIsQ0FBc0IsT0FBTSxDQUFOLEVBQVEsQ0FBRSxRQUFNLE9BQU0sSUFBTixDQUFXLEVBQUUsUUFBYjtBQUFOO0FBQTZCLEdBQTFILENBQWxRLEVBQThYLFVBQVUsT0FBVixDQUFrQixTQUFsQixFQUE0QixZQUFVO0FBQUMsUUFBSSxJQUFFLEVBQUUsS0FBRixDQUFOLENBQWUsT0FBTyxFQUFFLFlBQUYsQ0FBZSxVQUFmLEVBQTBCLEdBQTFCLEdBQStCLEVBQUUsQ0FBQyxFQUFFLE9BQUgsSUFBWSxRQUFNLEVBQUUsT0FBRixDQUFVLEVBQTlCLENBQXRDO0FBQXdFLEdBQTlILENBQTlYLENBQThmLElBQUksSUFBRSxFQUFFLFVBQUYsR0FBYSxDQUFuQixDQUFxQixVQUFVLE9BQVYsQ0FBa0IsYUFBbEIsRUFBZ0MsWUFBVTtBQUFDLFFBQUksQ0FBSixDQUFNLElBQUcsa0JBQWlCLENBQWpCLElBQW9CLEVBQUUsYUFBRixJQUFpQixhQUFhLGFBQXJELEVBQW1FLElBQUUsQ0FBQyxDQUFILENBQW5FLEtBQTRFO0FBQUMsVUFBSSxJQUFFLENBQUMsVUFBRCxFQUFZLEVBQUUsSUFBRixDQUFPLGtCQUFQLENBQVosRUFBdUMsUUFBdkMsRUFBZ0QsR0FBaEQsRUFBb0QseUNBQXBELEVBQStGLElBQS9GLENBQW9HLEVBQXBHLENBQU4sQ0FBOEcsRUFBRSxDQUFGLEVBQUksVUFBUyxDQUFULEVBQVc7QUFBQyxZQUFFLE1BQUksRUFBRSxTQUFSO0FBQWtCLE9BQWxDO0FBQW9DLFlBQU8sQ0FBUDtBQUFTLEdBQXpSLEVBQTJSLElBQUksSUFBRSxpQkFBTjtBQUFBLE1BQXdCLElBQUUsRUFBRSxPQUFGLENBQVUsV0FBVixHQUFzQixFQUFFLEtBQUYsQ0FBUSxHQUFSLENBQXRCLEdBQW1DLEVBQTdELENBQWdFLEVBQUUsY0FBRixHQUFpQixDQUFqQixDQUFtQixJQUFJLElBQUUsVUFBUyxDQUFULEVBQVc7QUFBQyxRQUFJLENBQUo7QUFBQSxRQUFNLElBQUUsRUFBRSxNQUFWO0FBQUEsUUFBaUIsSUFBRSxFQUFFLE9BQXJCLENBQTZCLElBQUcsZUFBYSxPQUFPLENBQXZCLEVBQXlCLE9BQU8sQ0FBUCxDQUFTLElBQUcsQ0FBQyxDQUFKLEVBQU0sT0FBTSxDQUFDLENBQVAsQ0FBUyxJQUFHLElBQUUsRUFBRSxPQUFGLENBQVUsSUFBVixFQUFlLEVBQWYsQ0FBRixFQUFxQixJQUFFLEVBQUUsT0FBRixDQUFVLElBQVYsRUFBZSxHQUFmLEVBQW9CLFdBQXBCLEtBQWtDLE9BQXpELEVBQWlFLEtBQUssQ0FBekUsRUFBMkUsT0FBTSxNQUFJLENBQVYsQ0FBWSxLQUFJLElBQUksSUFBRSxDQUFWLEVBQVksSUFBRSxDQUFkLEVBQWdCLEdBQWhCLEVBQW9CO0FBQUMsVUFBSSxJQUFFLEVBQUUsQ0FBRixDQUFOO0FBQUEsVUFBVyxJQUFFLEVBQUUsV0FBRixLQUFnQixHQUFoQixHQUFvQixDQUFqQyxDQUFtQyxJQUFHLEtBQUssQ0FBUixFQUFVLE9BQU0sT0FBSyxFQUFFLFdBQUYsRUFBTCxHQUFxQixHQUFyQixHQUF5QixDQUEvQjtBQUFpQyxZQUFNLENBQUMsQ0FBUDtBQUFTLEdBQW5TLENBQW9TLEVBQUUsTUFBRixHQUFTLENBQVQsQ0FBVyxJQUFJLElBQUUsRUFBRSxPQUFGLENBQVUsV0FBVixHQUFzQixFQUFFLFdBQUYsR0FBZ0IsS0FBaEIsQ0FBc0IsR0FBdEIsQ0FBdEIsR0FBaUQsRUFBdkQsQ0FBMEQsRUFBRSxZQUFGLEdBQWUsQ0FBZixDQUFpQixJQUFJLElBQUUsRUFBQyxNQUFLLEVBQUUsV0FBRixDQUFOLEVBQU4sQ0FBNEIsVUFBVSxFQUFWLENBQWEsSUFBYixDQUFrQixZQUFVO0FBQUMsV0FBTyxFQUFFLElBQVQ7QUFBYyxHQUEzQyxFQUE2QyxJQUFJLElBQUUsRUFBQyxPQUFNLEVBQUUsSUFBRixDQUFPLEtBQWQsRUFBTixDQUEyQixVQUFVLEVBQVYsQ0FBYSxPQUFiLENBQXFCLFlBQVU7QUFBQyxXQUFPLEVBQUUsS0FBVDtBQUFlLEdBQS9DLEdBQWlELEVBQUUsWUFBRixHQUFlLENBQWhFLENBQWtFLElBQUksSUFBRSxFQUFFLFFBQUYsR0FBVyxVQUFTLENBQVQsRUFBVyxDQUFYLEVBQWEsQ0FBYixFQUFlO0FBQUMsV0FBTyxNQUFJLEVBQUUsT0FBRixDQUFVLEdBQVYsQ0FBSixHQUFtQixFQUFFLENBQUYsQ0FBbkIsSUFBeUIsQ0FBQyxDQUFELElBQUksRUFBRSxPQUFGLENBQVUsR0FBVixDQUFKLEtBQXFCLElBQUUsRUFBRSxDQUFGLENBQXZCLEdBQTZCLElBQUUsRUFBRSxDQUFGLEVBQUksQ0FBSixFQUFNLENBQU4sQ0FBRixHQUFXLEVBQUUsQ0FBRixFQUFJLEtBQUosQ0FBakUsQ0FBUDtBQUFvRixHQUFySCxDQUFzSCxVQUFVLE9BQVYsQ0FBa0IsdUJBQWxCLEVBQTBDLENBQUMsQ0FBQyxFQUFFLHVCQUFGLEVBQTBCLENBQTFCLENBQTVDLEVBQXlFLEVBQUMsU0FBUSxDQUFDLEtBQUQsQ0FBVCxFQUF6RSxHQUE0RixVQUFVLE9BQVYsQ0FBa0IsWUFBbEIsRUFBK0IsQ0FBQyxDQUFDLEVBQUUsWUFBRixFQUFlLENBQWYsQ0FBakMsQ0FBNUYsRUFBZ0osRUFBRSxZQUFGLEdBQWUsQ0FBL0osRUFBaUssVUFBVSxPQUFWLENBQWtCLGVBQWxCLEVBQWtDLEVBQUUsZUFBRixFQUFrQixHQUFsQixFQUFzQixDQUFDLENBQXZCLENBQWxDLENBQWpLLEVBQThOLFVBQVUsT0FBVixDQUFrQixlQUFsQixFQUFrQyxZQUFVO0FBQUMsV0FBTSxDQUFDLENBQUQsS0FBSyxVQUFVLFNBQVYsQ0FBb0IsT0FBcEIsQ0FBNEIsWUFBNUIsQ0FBTCxJQUFnRCxFQUFFLFdBQUYsRUFBYyxVQUFkLEVBQXlCLENBQUMsQ0FBMUIsQ0FBdEQ7QUFBbUYsR0FBaEksQ0FBOU4sRUFBZ1csR0FBaFcsRUFBb1csT0FBTyxFQUFFLE9BQTdXLEVBQXFYLE9BQU8sRUFBRSxZQUE5WCxDQUEyWSxLQUFJLElBQUksSUFBRSxDQUFWLEVBQVksSUFBRSxVQUFVLEVBQVYsQ0FBYSxNQUEzQixFQUFrQyxHQUFsQyxFQUFzQyxVQUFVLEVBQVYsQ0FBYSxDQUFiLElBQWtCLEVBQUUsU0FBRixHQUFZLFNBQVo7QUFBc0IsQ0FBbHRNLENBQW10TSxNQUFudE0sRUFBMHRNLFFBQTF0TSxDQUFEOzs7Ozs7Ozs7UUNFZ0IsVyxHQUFBLFc7UUFXQSxJLEdBQUEsSTtRQUtBLEksR0FBQSxJO1FBS0EsTSxHQUFBLE07UUFPQSxtQixHQUFBLG1CO1FBUUEsb0IsR0FBQSxvQjtRQVVBLE8sR0FBQSxPO1FBS0EsTyxHQUFBLE87O0FBdkRoQjs7QUFFQTs7QUFFTyxTQUFTLFdBQVQsQ0FBcUIsUUFBckIsRUFBK0I7QUFDcEMsTUFBSSxNQUFNLElBQVY7QUFDQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxNQUE3QixFQUFxQyxLQUFLLENBQTFDLEVBQTZDO0FBQzNDLFVBQU0sVUFBVSxTQUFTLENBQVQsQ0FBaEI7QUFDQSxVQUFNLGFBQWEsT0FBTyxTQUFQLENBQWlCLE9BQWpCLENBQW5CO0FBQ0E7QUFDQSxVQUFNLE9BQU8sVUFBYjtBQUNEO0FBQ0QsU0FBTyxHQUFQO0FBQ0Q7O0FBRU0sU0FBUyxJQUFULENBQWMsRUFBZCxFQUFrQjtBQUN2QixLQUFHLEtBQUgsQ0FBUyxPQUFULEdBQW1CLE9BQW5CLENBRHVCLENBQ0s7QUFDNUIsS0FBRyxLQUFILENBQVMsVUFBVCxHQUFzQixTQUF0QixDQUZ1QixDQUVVO0FBQ2xDOztBQUVNLFNBQVMsSUFBVCxDQUFjLEVBQWQsRUFBa0I7QUFDdkIsS0FBRyxLQUFILENBQVMsT0FBVCxHQUFtQixNQUFuQixDQUR1QixDQUNJO0FBQzNCLEtBQUcsS0FBSCxDQUFTLFVBQVQsR0FBc0IsUUFBdEIsQ0FGdUIsQ0FFUztBQUNqQzs7QUFFTSxTQUFTLE1BQVQsQ0FBZ0IsRUFBaEIsRUFBb0I7QUFDekIsS0FBRyxLQUFILENBQVMsT0FBVCxHQUFtQixFQUFuQixDQUR5QixDQUNGO0FBQ3ZCLEtBQUcsS0FBSCxDQUFTLFVBQVQsR0FBc0IsRUFBdEIsQ0FGeUIsQ0FFQztBQUMzQjs7QUFFTSxNQUFNLDBCQUFTLE1BQWY7O0FBRUEsU0FBUyxtQkFBVCxDQUE2QixPQUE3QixFQUFzQyxpQkFBdEMsRUFBeUQ7QUFDOUQsTUFBSSxvQkFBb0IsTUFBeEIsRUFBZ0M7QUFDOUIsbUJBQWUsTUFBZixDQUFzQixPQUF0QixFQUErQixpQkFBL0I7QUFDRCxHQUZELE1BRU8sSUFBSSxxQkFBcUIsUUFBekIsRUFBbUM7QUFDeEMsYUFBUyxlQUFULENBQXlCLE9BQXpCLEVBQWtDLGlCQUFsQztBQUNEO0FBQ0Y7O0FBRU0sU0FBUyxvQkFBVCxDQUE4QixDQUE5QixFQUFpQztBQUN0QyxNQUFJLG9CQUFvQixNQUFwQixJQUE4QixxQkFBcUIsUUFBdkQsRUFBaUU7QUFDL0Q7QUFDRCxHQUZELE1BRU87QUFDTCxRQUFJLENBQUMsT0FBTyxxQkFBWixFQUFtQyxlQUFlLGlFQUFmO0FBQ25DLFdBQU8scUJBQVAsR0FBK0IsSUFBL0I7QUFDQSxXQUFPLGdCQUFQLENBQXdCLG9CQUF4QixFQUE4QyxDQUE5QztBQUNEO0FBQ0Y7O0FBRU0sU0FBUyxPQUFULENBQWlCLEVBQWpCLEVBQXFCLFFBQXJCLEVBQStCO0FBQ3BDLFNBQU8sQ0FBQyxHQUFHLE9BQUgsSUFBYyxHQUFHLGVBQWpCLElBQW9DLEdBQUcsaUJBQXZDLElBQTRELEdBQUcsa0JBQS9ELElBQ04sR0FBRyxxQkFERyxJQUNzQixHQUFHLGdCQUQxQixFQUM0QyxJQUQ1QyxDQUNpRCxFQURqRCxFQUNxRCxRQURyRCxDQUFQO0FBRUQ7O0FBRU0sU0FBUyxPQUFULENBQWlCLEVBQWpCLEVBQXFCLFNBQXJCLEVBQWdDLE9BQWhDLEVBQXlDO0FBQzlDLFNBQU8sdUJBQVcsTUFBWCxDQUFtQixRQUFELElBQWM7QUFDckMsVUFBTSxPQUFPLEdBQUcsT0FBSCxDQUFXLFNBQVgsRUFBc0IsT0FBdEIsQ0FBYjs7QUFFQSxTQUFLLGdCQUFMLENBQXNCLFFBQXRCLEVBQWlDLENBQUQsSUFBTztBQUNyQyxlQUFTLElBQVQsQ0FBYyxDQUFkO0FBQ0EsZUFBUyxRQUFUO0FBQ0QsS0FIRDs7QUFLQSxXQUFPLE1BQU07QUFDWDtBQUNELEtBRkQ7QUFHRCxHQVhNLENBQVA7QUFZRDs7Ozs7Ozs7O0FDM0REOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUVBLE1BQU0sRUFBRSxJQUFGLEtBQVcsTUFBTSxTQUF2QixDLENBckJBOzs7Ozs7Ozs7QUF1QkEsU0FBUyxXQUFULENBQXFCLEVBQUUsT0FBTyxPQUFULEVBQWtCLGNBQWMsWUFBaEMsRUFBOEMsUUFBUSxNQUF0RCxLQUFpRSxFQUF0RixFQUEwRjtBQUN4RixPQUFLLEtBQUwsQ0FBVyxDQUFYLEVBQWMsS0FBZCxDQUFvQixVQUFwQixHQUFpQyxJQUFqQyxDQUR3RixDQUNqRDtBQUN2QyxPQUFLLEtBQUwsQ0FBVyxDQUFYLEVBQWMsS0FBZCxDQUFvQixVQUFwQixHQUFpQyxXQUFqQyxDQUZ3RixDQUUxQztBQUM5QyxPQUFLLEtBQUwsQ0FBVyxDQUFYLEVBQWMsS0FBZCxDQUFvQixLQUFwQixHQUE0QixLQUE1QixDQUh3RixDQUdyRDtBQUNuQyxPQUFLLEtBQUwsQ0FBVyxDQUFYLEVBQWMsS0FBZCxDQUFvQixZQUFwQixHQUFtQyxLQUFuQyxDQUp3RixDQUk5QztBQUMxQyxPQUFLLEtBQUwsQ0FBVyxDQUFYLEVBQWMsS0FBZCxDQUFvQixlQUFwQixHQUFzQyxLQUF0QyxDQUx3RixDQUszQztBQUM5Qzs7QUFFYyxNQUFNLFVBQU4sQ0FBaUI7QUFDOUIsY0FBWSxFQUFFLFFBQUYsRUFBWixFQUEwQjtBQUFBOztBQUN4QixTQUFLLE9BQUwsR0FBZSxTQUFTLGNBQVQsQ0FBd0IsVUFBeEIsQ0FBZjtBQUNBLFNBQUssUUFBTCxHQUFnQixRQUFoQjs7QUFFQSxVQUFNLFlBQVksU0FBUyxjQUFULENBQXdCLFlBQXhCLENBQWxCO0FBQ0EsVUFBTSxhQUFhLHFCQUFTLFdBQVQsRUFBc0IsSUFBdEIsaUJBQTJCLE1BQU0sR0FBRyxTQUFILEtBQWlCLFNBQWxELENBQW5CO0FBQ0EsU0FBSyxLQUFMLEdBQWEsV0FBVyxRQUFYLElBQXVCLFdBQVcsS0FBL0M7QUFDQSxTQUFLLFNBQUwsR0FBaUIsU0FBUyxjQUFULENBQXdCLE9BQXhCLEVBQWlDLFlBQWpDLENBQThDLFlBQTlDLENBQWpCO0FBQ0Q7O0FBRUQsYUFBVyxPQUFYLEVBQW9CO0FBQUE7O0FBQ2xCLFVBQU0sRUFBRSxLQUFGLEVBQVMsS0FBVCxLQUFtQixPQUF6Qjs7QUFFQSxRQUFJLFVBQVUsS0FBSyxTQUFuQixFQUE4QjtBQUM1QixhQUFPLHlDQUFQO0FBQ0Q7O0FBRUQsUUFBSSxJQUFKO0FBQ0EsUUFBSSxVQUFVLEVBQWQsRUFBa0I7QUFDaEIsYUFBTywwQ0FBa0IsS0FBSyxRQUF2QixDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQUE7O0FBQ0wsWUFBTSxTQUFTLElBQUksS0FBSixFQUFmOztBQUVBLGFBQU8sNEVBQXNCLE1BQXRCLEVBQThCLE1BQTlCLGtDQUNLLDBDQUFrQixLQUFLLFFBQXZCLENBREwsRUFDdUMsS0FBSyxDQUQ1QyxzQ0FFSyxNQUFNO0FBQUUsZUFBTyxHQUFQLEdBQWEsRUFBYjtBQUFrQixPQUYvQixDQUFQOztBQUlBLGFBQU8sR0FBUCxHQUFhLEtBQWI7QUFDRDs7QUFFRCxXQUFPLHlEQUNJLE1BQU07QUFDUCxpQkFBTixZQUFrQixPQUFsQjtBQUNBLFdBQUssU0FBTCxHQUFpQixLQUFqQjtBQUNELEtBSkksNkJBS0MsTUFBTTtBQUNWLFlBQU0sTUFBTSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWjtBQUNBLFVBQUksU0FBSixDQUFjLEdBQWQsQ0FBa0IsWUFBbEI7QUFDQSxVQUFJLEtBQUosQ0FBVSxlQUFWLEdBQTRCLEtBQTVCO0FBQ0EsVUFBSSxVQUFVLEVBQWQsRUFBa0IsSUFBSSxLQUFKLENBQVUsZUFBVixHQUE2QixPQUFNLEtBQU0sR0FBekM7QUFDbEIsYUFBTyxHQUFQO0FBQ0QsS0FYSSxDQUFQO0FBWUQ7O0FBRUQsWUFBVSxDQUFDLE9BQUQsRUFBVSxHQUFWLENBQVYsRUFBMEI7QUFBQTs7QUFDeEIsWUFBUSxVQUFSLENBQW1CLFlBQW5CLENBQWdDLEdBQWhDLEVBQXFDLFFBQVEsa0JBQTdDOztBQUVBLFdBQU8sa0NBQVEsR0FBUixFQUFhLENBQ2xCLEVBQUUsU0FBUyxDQUFYLEVBRGtCLEVBRWxCLEVBQUUsU0FBUyxDQUFYLEVBRmtCLENBQWIsRUFHSjtBQUNELGdCQUFVLEtBQUs7QUFEZCxLQUhJLHNDQU9HLE1BQU0sUUFBUSxVQUFSLENBQW1CLFdBQW5CLENBQStCLE9BQS9CLENBUFQsQ0FBUDtBQVFEO0FBeEQ2QjtrQkFBWCxVOzs7OztBQzdCckI7Ozs7QUFFQTs7OztBQUpBOztBQU1BLE1BQU0sZUFBZSxDQUNuQixlQURtQixFQUVuQixlQUZtQixFQUduQixZQUhtQixFQUluQix1QkFKbUIsRUFLbkIsV0FMbUIsRUFNbkIsU0FObUIsRUFPbkIsZUFQbUIsRUFRbkIsa0JBUm1CLEVBU25CLFlBVG1CLENBQXJCOztBQVlBLE1BQU0sY0FBYyxvQkFBcEI7O0FBRUEsU0FBUyxjQUFULEdBQTBCO0FBQ3hCLFFBQU0sYUFBYSxPQUFPLFNBQVAsS0FBcUIsT0FBTyxVQUFQLENBQWtCLFdBQWxCLEVBQStCLE9BQXZFO0FBQ0EsTUFBSSxVQUFKLEVBQWdCO0FBQ2QsV0FBTyxTQUFQLEdBQW1CLENBQUMsT0FBTyxTQUEzQjtBQUNBLFdBQU8sTUFBUCxDQUFjLFVBQWQsR0FBMkIsT0FBTyxTQUFsQztBQUNBLFdBQU8sTUFBUCxDQUFjLE1BQWQsQ0FBcUIsT0FBTyxTQUE1QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBUyxrQkFBVCxDQUE0QixDQUE1QixFQUErQjtBQUM3QixNQUFJLENBQUMsT0FBTyxTQUFaLEVBQXVCO0FBQ3JCLE1BQUUsY0FBRjtBQUNBLFdBQU8sTUFBUCxDQUFjLE1BQWQ7QUFDRDtBQUNGOztBQUVELFNBQVMsaUJBQVQsQ0FBMkIsTUFBM0IsRUFBbUM7QUFDakMsU0FBTyxNQUFQLEdBQWdCLE1BQWhCO0FBQ0EsU0FBTyxnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxjQUFsQztBQUNBLFdBQVMsY0FBVCxDQUF3QixPQUF4QixFQUFpQyxnQkFBakMsQ0FBa0QsT0FBbEQsRUFBMkQsa0JBQTNEO0FBQ0Q7O0FBRUQsSUFBSSx5QkFBWSxZQUFaLENBQUosRUFBK0I7QUFDN0IsU0FBTyxTQUFQLEdBQW1CLE9BQU8sVUFBUCxDQUFrQixXQUFsQixFQUErQixPQUFsRDtBQUNBLFFBQU0sU0FBUyxTQUFTLGNBQVQsQ0FBd0IsVUFBeEIsQ0FBZjs7QUFFQSxvQkFBa0Isc0JBQVksTUFBWixFQUFvQjtBQUNwQyxZQUFRLE9BQU8sU0FEcUI7QUFFcEMsZ0JBQVksT0FBTyxTQUZpQjtBQUdwQyx3QkFBb0I7QUFIZ0IsR0FBcEIsQ0FBbEI7O0FBTUEsU0FBTyxTQUFQLENBQWlCLEdBQWpCLENBQXFCLFFBQXJCO0FBQ0Q7Ozs7Ozs7OztBQ2hERDs7QUFDQTs7QUFOQTs7Ozs7QUFRZSxNQUFNLElBQU4sQ0FBVztBQUN4QixTQUFPLE1BQVAsQ0FBYyxJQUFkLEVBQW9CLEdBQUcsSUFBdkIsRUFBNkI7QUFDM0IsV0FBTyxLQUFLLEtBQUwsQ0FBVyxJQUFYLEtBQW9CLElBQXBCLEdBQ0wsSUFBSSxLQUFLLEtBQUwsQ0FBVyxJQUFYLENBQUosQ0FBcUIsR0FBRyxJQUF4QixDQURLLEdBRUwsSUFBSSxJQUFKLENBQVMsR0FBRyxJQUFaLENBRkY7QUFHRDs7QUFFRCxjQUFZLEVBQUUsVUFBRixFQUFjLFFBQWQsRUFBWixFQUFzQztBQUNwQyxTQUFLLFVBQUwsR0FBa0IsVUFBbEI7QUFDQSxTQUFLLFFBQUwsR0FBZ0IsUUFBaEI7QUFDRDs7QUFFRCxVQUFRO0FBQ04sV0FBTyx5Q0FBUDtBQUNEOztBQUVELFVBQVE7QUFDTixXQUFPLHlDQUFQO0FBQ0Q7QUFsQnVCOztrQkFBTCxJO0FBcUJyQixLQUFLLEtBQUwsR0FBYSxFQUFiOzs7Ozs7Ozs7QUNwQkE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7OztBQUVlLE1BQU0sV0FBTix3QkFBK0I7QUFDNUMsUUFBTSxhQUFOLEVBQXFCO0FBQUE7O0FBQ25CLFVBQU0sTUFBTSxjQUFjLGFBQWQsQ0FBNEIsTUFBNUIsQ0FBWjs7QUFFQSxTQUFLLFVBQUwsQ0FBZ0IsYUFBaEIsQ0FBOEIsT0FBOUIsRUFBdUMsU0FBdkMsR0FBb0Q7OztLQUFwRDs7QUFLQSxVQUFNLGNBQWMsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQXBCO0FBQ0EsZ0JBQVksU0FBWixDQUFzQixHQUF0QixDQUEwQixjQUExQjs7QUFFQSxRQUFJLFVBQUosQ0FBZSxZQUFmLENBQTRCLFdBQTVCLEVBQXlDLEdBQXpDO0FBQ0EsUUFBSSxTQUFKLENBQWMsR0FBZCxDQUFrQixNQUFsQjtBQUNBLFFBQUksS0FBSixDQUFVLGVBQVYsR0FBNEIsVUFBNUI7O0FBRUEsU0FBSyxVQUFMLENBQWdCLGFBQWhCLENBQThCLE9BQTlCLEVBQXVDLFdBQXZDLENBQW1ELEdBQW5EO0FBQ0EsU0FBSyxVQUFMLENBQWdCLEtBQWhCLENBQXNCLFFBQXRCLEdBQWlDLE9BQWpDO0FBQ0EsU0FBSyxVQUFMLENBQWdCLEtBQWhCLENBQXNCLE9BQXRCLEdBQWdDLENBQWhDOztBQUVBLFVBQU0sUUFBUSxZQUFZLHFCQUFaLEVBQWQ7QUFDQSxVQUFNLE9BQU8sSUFBSSxxQkFBSixFQUFiOztBQUVBLFVBQU0sVUFBVSxNQUFNLElBQU4sR0FBYSxLQUFLLElBQWxDO0FBQ0EsVUFBTSxVQUFVLE1BQU0sR0FBTixHQUFZLEtBQUssR0FBakM7QUFDQSxVQUFNLGNBQWMsTUFBTSxLQUFOLEdBQWMsS0FBSyxLQUF2Qzs7QUFFQSxXQUFPLGlDQUFRLEdBQVIsRUFBYSxDQUNsQixFQUFFLFdBQVksZUFBYyxPQUFRLE9BQU0sT0FBUSxnQkFBZSxXQUFZLEdBQTdFLEVBRGtCLEVBRWxCLEVBQUUsV0FBVywrQkFBYixFQUZrQixDQUFiLEVBR0o7QUFDRCxnQkFBVSxLQUFLLFFBRGQ7QUFFRDtBQUNBLGNBQVE7QUFIUCxLQUhJLDJCQVFJLE1BQU07QUFBRSxXQUFLLFVBQUwsQ0FBZ0IsS0FBaEIsQ0FBc0IsUUFBdEIsR0FBaUMsVUFBakM7QUFBOEMsS0FSMUQsQ0FBUDtBQVNEOztBQUVELFFBQU0sSUFBTixFQUFZO0FBQUE7O0FBQ1YsU0FBSyxVQUFMLENBQWdCLEtBQWhCLENBQXNCLFVBQXRCLEdBQW1DLFNBQW5DOztBQUVBLFVBQU0sTUFBTSxLQUFLLGFBQUwsQ0FBbUIsTUFBbkIsQ0FBWjs7QUFFQSxRQUFJLE9BQU8sSUFBWCxFQUFpQjtBQUNmLFVBQUksS0FBSixDQUFVLE9BQVYsR0FBb0IsQ0FBcEI7QUFDQSxVQUFJLEtBQUosQ0FBVSxVQUFWLEdBQXVCLFNBQXZCO0FBQ0Q7O0FBRUQsVUFBTSxVQUFVLElBQUksYUFBSixDQUFrQixLQUFsQixDQUFoQjtBQUNBLFdBQU8sdUNBQUMsV0FBVyxJQUFYLEdBQ04sb0NBQWUsSUFBZixDQURNLEdBRU4sa0RBQXNCLE9BQXRCLEVBQStCLE1BQS9CLENBRks7QUFJTDtBQUpLLG1DQUtLLDBDQUFrQixLQUFLLFFBQUwsR0FBZ0IsR0FBbEMsQ0FMTCw0QkFNSSxNQUFNO0FBQ2IsVUFBSSxPQUFPLElBQVgsRUFBaUI7QUFDZixZQUFJLEtBQUosQ0FBVSxPQUFWLEdBQW9CLENBQXBCO0FBQ0EsWUFBSSxLQUFKLENBQVUsVUFBVixHQUF1QixFQUF2QjtBQUNEO0FBQ0YsS0FYSSxzQ0FZSyxNQUFNO0FBQ2QsV0FBSyxVQUFMLENBQWdCLEtBQWhCLENBQXNCLE9BQXRCLEdBQWdDLENBQWhDO0FBQ0EsV0FBSyxVQUFMLENBQWdCLEtBQWhCLENBQXNCLFVBQXRCLEdBQW1DLEVBQW5DO0FBQ0QsS0FmSSxDQUFQO0FBZ0JEO0FBakUyQzs7a0JBQXpCLFcsRUFyQnJCOzs7Ozs7Ozs7QUF5RkEsZUFBSyxLQUFMLENBQVcsT0FBWCxHQUFxQixXQUFyQjs7Ozs7QUNoRkE7O0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7OztBQWhCQTs7Ozs7Ozs7O0FBa0JBLE1BQU0saUJBQWlCLDBCQUF2Qjs7QUFFQSxNQUFNLFNBQU4sd0JBQTZCO0FBQzNCLFFBQU0sYUFBTixFQUFxQjtBQUFBOztBQUNuQixVQUFNLFFBQVEsU0FBUyxhQUFULENBQXVCLElBQXZCLENBQWQ7O0FBRUEsVUFBTSxTQUFOLENBQWdCLEdBQWhCLENBQW9CLFlBQXBCO0FBQ0EsVUFBTSxXQUFOLEdBQW9CLGNBQWMsV0FBbEM7QUFDQSxVQUFNLEtBQU4sQ0FBWSxlQUFaLEdBQThCLFVBQTlCOztBQUVBLFNBQUssVUFBTCxDQUFnQixhQUFoQixDQUE4QixPQUE5QixFQUF1QyxTQUF2QyxHQUFtRCxFQUFuRDtBQUNBLFNBQUssVUFBTCxDQUFnQixhQUFoQixDQUE4QixPQUE5QixFQUF1QyxXQUF2QyxDQUFtRCxLQUFuRDtBQUNBLFNBQUssVUFBTCxDQUFnQixLQUFoQixDQUFzQixRQUF0QixHQUFpQyxPQUFqQztBQUNBLFNBQUssVUFBTCxDQUFnQixLQUFoQixDQUFzQixPQUF0QixHQUFnQyxDQUFoQzs7QUFFQSxVQUFNLFFBQVEsY0FBYyxxQkFBZCxFQUFkO0FBQ0EsVUFBTSxnQkFBZ0IsU0FBUyxpQkFBaUIsYUFBakIsRUFBZ0MsUUFBekMsRUFBbUQsRUFBbkQsQ0FBdEI7QUFDQSxVQUFNLE9BQU8sTUFBTSxxQkFBTixFQUFiO0FBQ0EsVUFBTSxlQUFlLFNBQVMsaUJBQWlCLEtBQWpCLEVBQXdCLFFBQWpDLEVBQTJDLEVBQTNDLENBQXJCOztBQUVBLFVBQU0sVUFBVSxNQUFNLElBQU4sR0FBYSxLQUFLLElBQWxDO0FBQ0EsVUFBTSxVQUFVLE1BQU0sR0FBTixHQUFZLEtBQUssR0FBakM7QUFDQSxVQUFNLGNBQWMsZ0JBQWdCLFlBQXBDOztBQUVBLGtCQUFjLEtBQWQsQ0FBb0IsT0FBcEIsR0FBOEIsQ0FBOUI7O0FBRUEsV0FBTyxpQ0FBUSxLQUFSLEVBQWUsQ0FDcEIsRUFBRSxXQUFZLGVBQWMsT0FBUSxPQUFNLE9BQVEsZ0JBQWUsV0FBWSxHQUE3RSxFQURvQixFQUVwQixFQUFFLFdBQVcsK0JBQWIsRUFGb0IsQ0FBZixFQUdKO0FBQ0QsZ0JBQVUsS0FBSyxRQURkO0FBRUQ7QUFDQSxjQUFRO0FBSFAsS0FISSwyQkFRSSxNQUFNO0FBQUUsV0FBSyxVQUFMLENBQWdCLEtBQWhCLENBQXNCLFFBQXRCLEdBQWlDLFVBQWpDO0FBQThDLEtBUjFELENBQVA7QUFTRDs7QUFFRCxRQUFNLElBQU4sRUFBWTtBQUFBOztBQUNWLFNBQUssVUFBTCxDQUFnQixLQUFoQixDQUFzQixVQUF0QixHQUFtQyxTQUFuQzs7QUFFQSxVQUFNLFFBQVEsS0FBSyxhQUFMLENBQW1CLGNBQW5CLENBQWQ7O0FBRUEsUUFBSSxTQUFTLElBQWIsRUFBbUI7QUFDakIsWUFBTSxLQUFOLENBQVksT0FBWixHQUFzQixDQUF0QjtBQUNBLFlBQU0sS0FBTixDQUFZLFVBQVosR0FBeUIsU0FBekI7QUFDRDs7QUFFRDtBQUNBLFdBQU8sb0VBQWtCLEtBQUssUUFBTCxHQUFnQixHQUFsQyw0QkFDSSxNQUFNO0FBQ2IsVUFBSSxTQUFTLElBQWIsRUFBbUI7QUFDakIsY0FBTSxLQUFOLENBQVksT0FBWixHQUFzQixDQUF0QjtBQUNBLGNBQU0sS0FBTixDQUFZLFVBQVosR0FBeUIsRUFBekI7QUFDRDtBQUNGLEtBTkksc0NBT0ssTUFBTTtBQUNkLFdBQUssVUFBTCxDQUFnQixLQUFoQixDQUFzQixPQUF0QixHQUFnQyxDQUFoQztBQUNBLFdBQUssVUFBTCxDQUFnQixLQUFoQixDQUFzQixVQUF0QixHQUFtQyxFQUFuQztBQUNELEtBVkksQ0FBUDtBQVdEO0FBekQwQjs7QUE0RDdCLGVBQUssS0FBTCxDQUFXLEtBQVgsR0FBbUIsU0FBbkI7Ozs7O0FDaEZBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOzs7Ozs7OztrQkNvQ3dCLGlCOztBQS9DeEI7O0FBQ0E7Ozs7QUFFQTs7OztBQUVBLE1BQU0sZUFBZSxDQUNuQixlQURtQixFQUVuQixlQUZtQixDQUFyQixDLENBUEE7O0FBWUEsU0FBUyxpQkFBVCxDQUEyQixVQUEzQixFQUF1QztBQUNyQyxRQUFNLFNBQU4sQ0FBZ0IsT0FBaEIsQ0FBd0IsSUFBeEIsQ0FBNkIsVUFBN0IsRUFBMEMsRUFBRCxJQUFRO0FBQy9DLE9BQUcsS0FBSCxDQUFTLFVBQVQsR0FBc0IsU0FBdEIsQ0FEK0MsQ0FDZDtBQUNsQyxHQUZEO0FBR0Q7O0FBRUQsU0FBUyxnQkFBVCxDQUEwQixFQUExQixFQUE4QixHQUE5QixFQUFtQztBQUNqQyxLQUFHLFNBQUgsR0FBZSxnQkFBTSxjQUFOLENBQXFCLEdBQXJCLEVBQTBCO0FBQ3ZDLGlCQUFhLEdBQUcsSUFBSCxLQUFZO0FBRGMsR0FBMUIsQ0FBZjtBQUdEOztBQUVELFNBQVMsV0FBVCxDQUFxQixFQUFyQixFQUF5QixHQUF6QixFQUE4QjtBQUM1QixNQUFJO0FBQ0YsVUFBTSxPQUFPLEdBQUcsc0JBQWhCO0FBQ0EscUJBQWlCLEVBQWpCLEVBQXFCLEdBQXJCO0FBQ0EsUUFBSSxRQUFRLHFCQUFRLElBQVIsRUFBYyxrQkFBZCxDQUFaLEVBQStDLGtCQUFLLElBQUw7QUFDaEQsR0FKRCxDQUlFLE9BQU8sQ0FBUCxFQUFVO0FBQ1Y7QUFDQSxZQUFRLEtBQVIsQ0FBYyxDQUFkLEVBRlUsQ0FFUTtBQUNuQixHQVBELFNBT1U7QUFDUixPQUFHLEtBQUgsQ0FBUyxVQUFULEdBQXNCLEVBQXRCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTLGFBQVQsQ0FBdUIsRUFBdkIsRUFBMkI7QUFDekIsU0FBTyxHQUFHLFdBQUgsQ0FBZSxPQUFmLENBQXVCLGFBQXZCLEVBQXNDLEVBQXRDLEVBQTBDLE9BQTFDLENBQWtELE1BQWxELEVBQTBELEVBQTFELENBQVA7QUFDRDs7QUFFRCxTQUFTLGFBQVQsQ0FBdUIsVUFBdkIsRUFBbUM7QUFDakM7QUFDQSxRQUFNLFNBQU4sQ0FBZ0IsT0FBaEIsQ0FBd0IsSUFBeEIsQ0FBNkIsVUFBN0IsRUFBMEMsTUFBRCxJQUFZO0FBQ25ELFVBQU0sTUFBTSxjQUFjLE1BQWQsQ0FBWjtBQUNBLGdCQUFZLE1BQVosRUFBb0IsR0FBcEI7QUFDRCxHQUhEO0FBSUQ7O0FBRWMsU0FBUyxpQkFBVCxHQUE2QjtBQUMxQyxNQUFJLHlCQUFZLFlBQVosQ0FBSixFQUErQjtBQUM3QixVQUFNLGFBQWEsU0FBUyxnQkFBVCxDQUEwQiwwQkFBMUIsQ0FBbkI7QUFDQSxRQUFJLFdBQVcsTUFBZixFQUF1QjtBQUNyQix3QkFBa0IsVUFBbEI7QUFDQSxvQkFBYyxVQUFkO0FBQ0Q7QUFDRjtBQUNGOztBQUVELElBQUkseUJBQVksWUFBWixDQUFKLEVBQStCO0FBQzdCLFFBQU0sTUFBTSxTQUFTLG9CQUFULENBQThCLE9BQTlCLEVBQXVDLENBQXZDLENBQVo7QUFDQSxRQUFNLFFBQVEsc0JBQVEsa0RBQVIsRUFBNEQsR0FBNUQsQ0FBZDtBQUNBLFFBQU0sZ0JBQU4sQ0FBdUIsTUFBdkIsRUFBK0IsaUJBQS9CO0FBQ0Q7Ozs7O0FDdkREOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOzs7O0FBRUE7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFqQ0E7Ozs7Ozs7O0FBbUNBLE1BQU0sZUFBZSxDQUNuQixlQURtQixFQUVuQixlQUZtQixFQUduQix1QkFIbUIsRUFJbkIsV0FKbUIsRUFLbkIsa0JBTG1CLEVBTW5CLFNBTm1CLEVBT25CLFNBUG1CLEVBUW5CLGVBUm1CLEVBU25CLFNBVG1CLENBQXJCOztBQVlBLE1BQU0sV0FBVyxHQUFqQjtBQUNBLE1BQU0sZ0JBQWdCLEdBQXRCOztBQUVBO0FBQ0E7QUFDQSxTQUFTLGVBQVQsR0FBMkI7QUFDekIsU0FBTyx5QkFBYyxDQUFDLEtBQUQsRUFBUSxNQUFSLEtBQW1CO0FBQ3RDLFlBQVEsS0FBUixDQUFjLEtBQWQsRUFEc0MsQ0FDaEI7QUFDdEIsV0FBTyxNQUFQO0FBQ0QsR0FITSxDQUFQO0FBSUQ7O0FBRUQsSUFBSSx5QkFBWSxZQUFaLENBQUosRUFBK0I7QUFBQTs7QUFDN0IsUUFBTSxLQUFLLFVBQVUsU0FBVixDQUFvQixXQUFwQixFQUFYO0FBQ0EsUUFBTSxXQUFXLEdBQUcsT0FBSCxDQUFXLFFBQVgsSUFBdUIsQ0FBdkIsSUFBNEIsR0FBRyxPQUFILENBQVcsUUFBWCxJQUF1QixDQUFwRTs7QUFFQSxRQUFNLGFBQWEseUJBQWUsRUFBRSxVQUFVLGFBQVosRUFBZixDQUFuQjs7QUFFQSxRQUFNLFlBQVksU0FBUyxjQUFULENBQXdCLGFBQXhCLENBQWxCO0FBQ0EsUUFBTSxVQUFVLFNBQVMsY0FBVCxDQUF3QixVQUF4QixDQUFoQjs7QUFFQSxRQUFNLGFBQWEsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQW5CO0FBQ0EsYUFBVyxTQUFYLENBQXFCLEdBQXJCLENBQXlCLGFBQXpCO0FBQ0EsYUFBVyxTQUFYLEdBQXdCOzs7V0FBeEI7QUFJQSxZQUFVLFVBQVYsQ0FBcUIsWUFBckIsQ0FBa0MsVUFBbEMsRUFBOEMsU0FBOUM7O0FBRUEsUUFBTSxTQUFTLGtHQUFzQixTQUF0QixFQUFpQyxvQkFBakMsNEJBQ1AsQ0FBQyxFQUFFLE1BQUYsRUFBRCxLQUFnQixNQURULDRCQUVQLFVBQVUsQ0FBQyxNQUFELEVBQVMsU0FBUyxjQUFULENBQXdCLE9BQXhCLENBQVQsQ0FGSCwyQkFHSixNQUFNO0FBQ2I7QUFDQSxRQUFJLENBQUMsT0FBTyxTQUFSLElBQXFCLE9BQU8sTUFBUCxDQUFjLE1BQXZDLEVBQStDO0FBQzdDLGFBQU8sTUFBUCxDQUFjLEtBQWQ7QUFDRDtBQUNGLEdBUlksK0JBQWY7O0FBV0EsUUFBTSxTQUFTLDBFQUFzQixTQUF0QixFQUFpQyxvQkFBakMsNEJBQ1AsQ0FBQyxFQUFFLE1BQUYsRUFBRCxLQUFnQixNQURULCtCQUFmOztBQUlBLFFBQU0sWUFBWSw4REFBc0IsU0FBdEIsRUFBaUMsdUJBQWpDLDRCQUNWLENBQUMsRUFBRSxNQUFGLEVBQUQsS0FBZ0IsTUFETixDQUFsQjtBQUVFOztBQUVGLFFBQU0sU0FBUywwRUFBc0IsU0FBdEIsRUFBaUMsb0JBQWpDLDRCQUNQLENBQUMsRUFBRSxNQUFGLEVBQUQsS0FBZ0IsTUFEVCwrQkFBZjs7QUFJQTs7QUFFQTtBQUNBLE1BQUksUUFBSixFQUFjO0FBQ1osc0RBQXNCLE1BQXRCLEVBQThCLFVBQTlCLEVBQ0csU0FESCxDQUNhLE1BQU07QUFBRSxlQUFTLElBQVQsQ0FBYyxLQUFkLENBQW9CLFNBQXBCLEdBQWdDLFVBQWhDO0FBQTZDLEtBRGxFOztBQUdBLFdBQ0csU0FESCxDQUNhLE1BQU07QUFBRSxlQUFTLElBQVQsQ0FBYyxLQUFkLENBQW9CLFNBQXBCLEdBQWdDLEVBQWhDO0FBQXFDLEtBRDFEO0FBRUQ7O0FBRUQ7QUFDQSxnREFDYyxDQUFDLENBQUMsTUFBRCxDQUFELEtBQWM7QUFDeEIsVUFBTSxFQUFFLE9BQU8sRUFBRSxhQUFGLEVBQVQsS0FBK0IsTUFBckM7O0FBRUEsVUFBTSxPQUFPLGVBQUssTUFBTCxDQUFZLGNBQWMsT0FBZCxJQUF5QixjQUFjLE9BQWQsQ0FBc0IsSUFBM0QsRUFBaUU7QUFDNUUsZ0JBRDRFO0FBRTVFLG1CQUY0RTtBQUc1RSxnQkFBVTtBQUhrRSxLQUFqRSxDQUFiOztBQU1BO0FBQ0E7QUFDQTtBQUNBLFdBQU8sSUFBUCxHQUFjLElBQWQ7O0FBRUEsV0FBTyxLQUFLLEtBQUwsQ0FBVyxhQUFYLENBQVA7QUFDRCxHQWhCSCxHQWlCSSxlQWpCSixpQkFrQkcsU0FsQkg7O0FBb0JBO0FBQ0EsMkRBQ1csQ0FBQyxHQUFHLElBQUgsQ0FBRCxLQUFjO0FBQUUsU0FBSyxLQUFMLENBQVcsT0FBWCxHQUFxQixDQUFyQjtBQUF5QixHQURwRCxrQ0FFVyxDQUFDLENBQUMsRUFBRSxJQUFGLEVBQUQsQ0FBRCxLQUFnQixTQUFTLE1BQVQsSUFBbUIsQ0FBQyxRQUYvQywwQ0FHZSxDQUFDLENBQUMsRUFBRSxJQUFGLEVBQUQsRUFBVyxJQUFYLENBQUQ7QUFBQTs7QUFBQSxXQUNYLCtDQUFRLElBQVIsRUFBYyxDQUNaLEVBQUUsU0FBUyxDQUFYLEVBRFksRUFFWixFQUFFLFNBQVMsQ0FBWCxFQUZZLENBQWQsRUFHRztBQUNELGdCQUFVLFFBRFQ7QUFFRDtBQUNBLGNBQVE7QUFIUCxLQUhILDRCQVFXLE1BQU07QUFBRSxVQUFJLFNBQVMsTUFBYixFQUFxQixPQUFPLE1BQVAsQ0FBYyxDQUFkLEVBQWlCLENBQWpCO0FBQXNCLEtBUjlELGtDQVNZLE1BVFosQ0FEVztBQUFBLEdBSGYsR0FjSSxlQWRKLGlCQWVHLFNBZkg7O0FBaUJBO0FBQ0Esc0NBQ1csTUFBTTtBQUFFLFlBQVEsS0FBUixDQUFjLE9BQWQsR0FBd0IsT0FBeEI7QUFBa0MsR0FEckQsR0FFSSxlQUZKLGlCQUdHLFNBSEg7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFDVyxNQUFNO0FBQUUsWUFBUSxLQUFSLENBQWMsT0FBZCxHQUF3QixNQUF4QjtBQUFpQyxHQURwRCxrQ0FFVyxDQUFDLEVBQUUsSUFBRixFQUFELEtBQWMsU0FBUyxNQUFULElBQW1CLENBQUMsUUFGN0Msd0NBR2MsQ0FBQyxFQUFFLElBQUYsRUFBUSxTQUFTLENBQUMsSUFBRCxDQUFqQixFQUFEO0FBQUE7O0FBQUEsV0FBK0Isa0JBQUssS0FBTCxDQUFXLElBQVgseUNBQTRCLE1BQTVCLENBQS9CO0FBQUEsR0FIZCxHQUlJLGVBSkosaUJBS0csU0FMSDs7QUFPQSxvRkFDYyxDQUFDLEVBQUUsU0FBUyxDQUFDLElBQUQsQ0FBWCxFQUFEO0FBQUE7O0FBQUEsV0FBeUIsd0JBQVcsVUFBWCxDQUFzQixLQUFLLE9BQTNCLHlDQUErQyxNQUEvQyxDQUF6QjtBQUFBLEdBRGQsd0NBRWMsU0FBUyxhQUFULENBQXVCLGFBQXZCLENBRmQsMEVBSWUsV0FBVyxTQUoxQixNQUllLFVBSmYsSUFLSSxlQUxKLGlCQU1HLFNBTkg7O0FBUUE7QUFDQSxrRUFDVyxDQUFDLEVBQUUsSUFBRixFQUFELEtBQWMsU0FBUyxNQUFULElBQW1CLENBQUMsUUFEN0MsNEJBRVEsUUFBUSxDQUFDLElBQUQsRUFBTyxTQUFTLGFBQVQsQ0FBdUIsTUFBdkIsQ0FBUCxDQUZoQix3Q0FHYyxDQUFDLEdBQUcsSUFBSCxDQUFELEtBQ1YscUJBQVEsSUFBUixFQUFjLENBQ1osRUFBRSxXQUFXLG1CQUFiLEVBQWtDLFNBQVMsQ0FBM0MsRUFEWSxFQUVaLEVBQUUsV0FBVyxlQUFiLEVBQThCLFNBQVMsQ0FBdkMsRUFGWSxDQUFkLEVBR0c7QUFDRCxjQUFVLFFBRFQ7QUFFRDtBQUNBLFlBQVE7QUFIUCxHQUhILENBSkosR0FZSSxlQVpKLGlCQWFHLFNBYkg7O0FBZUE7QUFDRTtBQURGLDBDQUVpQixJQUFJLFFBRnJCLDJCQUdXLE1BQU07QUFDYjtBQUNBLFFBQUksT0FBTyxFQUFYLEVBQWUsT0FBTyxFQUFQLENBQVUsTUFBVixFQUFrQixVQUFsQjs7QUFFZjtBQUNBO0FBQ0QsR0FUSCxHQVVJLGVBVkosaUJBV0csU0FYSDs7QUFhQSx3QkFBYyxTQUFkLEVBQXlCO0FBQ3ZCLGdCQUFZLENBQUMsT0FBRCxDQURXO0FBRXZCLGtCQUFjLGNBRlM7QUFHdkIsY0FBVSxRQUhhO0FBSXZCLG1CQUFlLFFBSlE7QUFLdkIsdUJBQW1CLENBQUM7QUFMRyxHQUF6QixFQU1HLFlBTkg7QUFPRDs7Ozs7QUN2TkQ7O0FBRUEsU0FBUyxpQkFBVCxHQUE2QjtBQUMzQixNQUFJO0FBQ0YsV0FBTyxTQUFTLGFBQVQsQ0FBdUIsTUFBdkIsRUFBK0IsT0FBL0IsQ0FBdUMsUUFBdkMsQ0FBZ0QsU0FBaEQsQ0FBUDtBQUNELEdBRkQsQ0FFRSxPQUFPLENBQVAsRUFBVTtBQUNWLFdBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxTQUFTLFFBQVQsR0FBb0I7QUFDbEIsUUFBTSxRQUFRLFNBQVMsb0JBQVQsQ0FBOEIsTUFBOUIsQ0FBZDs7QUFFQSxPQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBTSxNQUExQixFQUFrQyxLQUFLLENBQXZDLEVBQTBDO0FBQ3hDLFVBQU0sT0FBTyxNQUFNLENBQU4sQ0FBYjtBQUNBLFFBQUksS0FBSyxHQUFMLEtBQWEsU0FBYixJQUEwQixLQUFLLFlBQUwsQ0FBa0IsSUFBbEIsTUFBNEIsT0FBMUQsRUFBbUU7QUFDakUsNEJBQVEsS0FBSyxJQUFiLEVBQW1CLElBQW5CO0FBQ0EsV0FBSyxHQUFMLEdBQVcsSUFBWDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxJQUFJLENBQUMsbUJBQUwsRUFBMEI7QUFDeEI7QUFDRDs7O0FDekJEO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTs7QUNBQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2oxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqaURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNya0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4dERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNocUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDWCxBQUNOOztXQUFBLEFBQUssT0FBTyxPQUFBLEFBQU8sU0FGRixBQUVqQixBQUE0QjtXQUM3Qjs7Ozs7d0JBRVUsQUFBRTthQUFBLEFBQU8sQUFBUTs7Ozs7RSxBQU5MOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQnpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFKQTs7Ozs7SSxBQU1xQjt1QkFDbkI7O3FCQUFBLEFBQVksSUFBWixBQUFnQixPQUFPOzBCQUFBOztnSEFFckI7O1VBQUEsQUFBSyxlQUFMLEFBQW9CLElBRkMsQUFFckIsQUFBd0I7V0FDekI7QUFFRDs7Ozs7Ozs2QixBQUNTLElBQUksQUFDWDtVQUFJLENBQUosQUFBSyxJQUFJLE1BQU0sTUFBTixBQUFNLEFBQU0sQUFDckI7YUFBQSxBQUFPLEFBQ1I7Ozs7O0VBVm9DLFc7O2tCLEFBQWxCIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qISBtb2Rlcm5penIgMy40LjAgKEN1c3RvbSBCdWlsZCkgfCBNSVQgKlxuICogaHR0cHM6Ly9tb2Rlcm5penIuY29tL2Rvd25sb2FkLz8tY2xhc3NsaXN0LWNzc2FuaW1hdGlvbnMtY3NzcG9pbnRlcmV2ZW50cy1jc3NyZW11bml0LWNzc3RyYW5zZm9ybXMtZGF0YXNldC1kb2N1bWVudGZyYWdtZW50LWV2ZW50bGlzdGVuZXItaGlzdG9yeS1tYXRjaG1lZGlhLW9wYWNpdHktcXVlcnlzZWxlY3Rvci1yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtdG91Y2hldmVudHMgISovXG4hZnVuY3Rpb24oZSx0LG4pe2Z1bmN0aW9uIHIoZSx0KXtyZXR1cm4gdHlwZW9mIGU9PT10fWZ1bmN0aW9uIG8oKXt2YXIgZSx0LG4sbyxpLHMsYTtmb3IodmFyIHUgaW4gZylpZihnLmhhc093blByb3BlcnR5KHUpKXtpZihlPVtdLHQ9Z1t1XSx0Lm5hbWUmJihlLnB1c2godC5uYW1lLnRvTG93ZXJDYXNlKCkpLHQub3B0aW9ucyYmdC5vcHRpb25zLmFsaWFzZXMmJnQub3B0aW9ucy5hbGlhc2VzLmxlbmd0aCkpZm9yKG49MDtuPHQub3B0aW9ucy5hbGlhc2VzLmxlbmd0aDtuKyspZS5wdXNoKHQub3B0aW9ucy5hbGlhc2VzW25dLnRvTG93ZXJDYXNlKCkpO2ZvcihvPXIodC5mbixcImZ1bmN0aW9uXCIpP3QuZm4oKTp0LmZuLGk9MDtpPGUubGVuZ3RoO2krKylzPWVbaV0sYT1zLnNwbGl0KFwiLlwiKSwxPT09YS5sZW5ndGg/TW9kZXJuaXpyW2FbMF1dPW86KCFNb2Rlcm5penJbYVswXV18fE1vZGVybml6clthWzBdXWluc3RhbmNlb2YgQm9vbGVhbnx8KE1vZGVybml6clthWzBdXT1uZXcgQm9vbGVhbihNb2Rlcm5penJbYVswXV0pKSxNb2Rlcm5penJbYVswXV1bYVsxXV09byksUy5wdXNoKChvP1wiXCI6XCJuby1cIikrYS5qb2luKFwiLVwiKSl9fWZ1bmN0aW9uIGkoZSl7cmV0dXJuIGUucmVwbGFjZSgvKFthLXpdKS0oW2Etel0pL2csZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0K24udG9VcHBlckNhc2UoKX0pLnJlcGxhY2UoL14tLyxcIlwiKX1mdW5jdGlvbiBzKCl7cmV0dXJuXCJmdW5jdGlvblwiIT10eXBlb2YgdC5jcmVhdGVFbGVtZW50P3QuY3JlYXRlRWxlbWVudChhcmd1bWVudHNbMF0pOnc/dC5jcmVhdGVFbGVtZW50TlMuY2FsbCh0LFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixhcmd1bWVudHNbMF0pOnQuY3JlYXRlRWxlbWVudC5hcHBseSh0LGFyZ3VtZW50cyl9ZnVuY3Rpb24gYSgpe3ZhciBlPXQuYm9keTtyZXR1cm4gZXx8KGU9cyh3P1wic3ZnXCI6XCJib2R5XCIpLGUuZmFrZT0hMCksZX1mdW5jdGlvbiB1KGUsbixyLG8pe3ZhciBpLHUsbCxmLGQ9XCJtb2Rlcm5penJcIixjPXMoXCJkaXZcIikscD1hKCk7aWYocGFyc2VJbnQociwxMCkpZm9yKDtyLS07KWw9cyhcImRpdlwiKSxsLmlkPW8/b1tyXTpkKyhyKzEpLGMuYXBwZW5kQ2hpbGQobCk7cmV0dXJuIGk9cyhcInN0eWxlXCIpLGkudHlwZT1cInRleHQvY3NzXCIsaS5pZD1cInNcIitkLChwLmZha2U/cDpjKS5hcHBlbmRDaGlsZChpKSxwLmFwcGVuZENoaWxkKGMpLGkuc3R5bGVTaGVldD9pLnN0eWxlU2hlZXQuY3NzVGV4dD1lOmkuYXBwZW5kQ2hpbGQodC5jcmVhdGVUZXh0Tm9kZShlKSksYy5pZD1kLHAuZmFrZSYmKHAuc3R5bGUuYmFja2dyb3VuZD1cIlwiLHAuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIixmPVQuc3R5bGUub3ZlcmZsb3csVC5zdHlsZS5vdmVyZmxvdz1cImhpZGRlblwiLFQuYXBwZW5kQ2hpbGQocCkpLHU9bihjLGUpLHAuZmFrZT8ocC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHApLFQuc3R5bGUub3ZlcmZsb3c9ZixULm9mZnNldEhlaWdodCk6Yy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGMpLCEhdX1mdW5jdGlvbiBsKGUsdCl7cmV0dXJuISF+KFwiXCIrZSkuaW5kZXhPZih0KX1mdW5jdGlvbiBmKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUuYXBwbHkodCxhcmd1bWVudHMpfX1mdW5jdGlvbiBkKGUsdCxuKXt2YXIgbztmb3IodmFyIGkgaW4gZSlpZihlW2ldaW4gdClyZXR1cm4gbj09PSExP2VbaV06KG89dFtlW2ldXSxyKG8sXCJmdW5jdGlvblwiKT9mKG8sbnx8dCk6byk7cmV0dXJuITF9ZnVuY3Rpb24gYyhlKXtyZXR1cm4gZS5yZXBsYWNlKC8oW0EtWl0pL2csZnVuY3Rpb24oZSx0KXtyZXR1cm5cIi1cIit0LnRvTG93ZXJDYXNlKCl9KS5yZXBsYWNlKC9ebXMtLyxcIi1tcy1cIil9ZnVuY3Rpb24gcCh0LG4scil7dmFyIG87aWYoXCJnZXRDb21wdXRlZFN0eWxlXCJpbiBlKXtvPWdldENvbXB1dGVkU3R5bGUuY2FsbChlLHQsbik7dmFyIGk9ZS5jb25zb2xlO2lmKG51bGwhPT1vKXImJihvPW8uZ2V0UHJvcGVydHlWYWx1ZShyKSk7ZWxzZSBpZihpKXt2YXIgcz1pLmVycm9yP1wiZXJyb3JcIjpcImxvZ1wiO2lbc10uY2FsbChpLFwiZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5pbmcgbnVsbCwgaXRzIHBvc3NpYmxlIG1vZGVybml6ciB0ZXN0IHJlc3VsdHMgYXJlIGluYWNjdXJhdGVcIil9fWVsc2Ugbz0hbiYmdC5jdXJyZW50U3R5bGUmJnQuY3VycmVudFN0eWxlW3JdO3JldHVybiBvfWZ1bmN0aW9uIG0odCxyKXt2YXIgbz10Lmxlbmd0aDtpZihcIkNTU1wiaW4gZSYmXCJzdXBwb3J0c1wiaW4gZS5DU1Mpe2Zvcig7by0tOylpZihlLkNTUy5zdXBwb3J0cyhjKHRbb10pLHIpKXJldHVybiEwO3JldHVybiExfWlmKFwiQ1NTU3VwcG9ydHNSdWxlXCJpbiBlKXtmb3IodmFyIGk9W107by0tOylpLnB1c2goXCIoXCIrYyh0W29dKStcIjpcIityK1wiKVwiKTtyZXR1cm4gaT1pLmpvaW4oXCIgb3IgXCIpLHUoXCJAc3VwcG9ydHMgKFwiK2krXCIpIHsgI21vZGVybml6ciB7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgfSB9XCIsZnVuY3Rpb24oZSl7cmV0dXJuXCJhYnNvbHV0ZVwiPT1wKGUsbnVsbCxcInBvc2l0aW9uXCIpfSl9cmV0dXJuIG59ZnVuY3Rpb24gdihlLHQsbyxhKXtmdW5jdGlvbiB1KCl7ZCYmKGRlbGV0ZSBQLnN0eWxlLGRlbGV0ZSBQLm1vZEVsZW0pfWlmKGE9cihhLFwidW5kZWZpbmVkXCIpPyExOmEsIXIobyxcInVuZGVmaW5lZFwiKSl7dmFyIGY9bShlLG8pO2lmKCFyKGYsXCJ1bmRlZmluZWRcIikpcmV0dXJuIGZ9Zm9yKHZhciBkLGMscCx2LHksaD1bXCJtb2Rlcm5penJcIixcInRzcGFuXCIsXCJzYW1wXCJdOyFQLnN0eWxlJiZoLmxlbmd0aDspZD0hMCxQLm1vZEVsZW09cyhoLnNoaWZ0KCkpLFAuc3R5bGU9UC5tb2RFbGVtLnN0eWxlO2ZvcihwPWUubGVuZ3RoLGM9MDtwPmM7YysrKWlmKHY9ZVtjXSx5PVAuc3R5bGVbdl0sbCh2LFwiLVwiKSYmKHY9aSh2KSksUC5zdHlsZVt2XSE9PW4pe2lmKGF8fHIobyxcInVuZGVmaW5lZFwiKSlyZXR1cm4gdSgpLFwicGZ4XCI9PXQ/djohMDt0cnl7UC5zdHlsZVt2XT1vfWNhdGNoKGcpe31pZihQLnN0eWxlW3ZdIT15KXJldHVybiB1KCksXCJwZnhcIj09dD92OiEwfXJldHVybiB1KCksITF9ZnVuY3Rpb24geShlLHQsbixvLGkpe3ZhciBzPWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkrZS5zbGljZSgxKSxhPShlK1wiIFwiK3ouam9pbihzK1wiIFwiKStzKS5zcGxpdChcIiBcIik7cmV0dXJuIHIodCxcInN0cmluZ1wiKXx8cih0LFwidW5kZWZpbmVkXCIpP3YoYSx0LG8saSk6KGE9KGUrXCIgXCIrRS5qb2luKHMrXCIgXCIpK3MpLnNwbGl0KFwiIFwiKSxkKGEsdCxuKSl9ZnVuY3Rpb24gaChlLHQscil7cmV0dXJuIHkoZSxuLG4sdCxyKX12YXIgZz1bXSxDPXtfdmVyc2lvbjpcIjMuNC4wXCIsX2NvbmZpZzp7Y2xhc3NQcmVmaXg6XCJcIixlbmFibGVDbGFzc2VzOiEwLGVuYWJsZUpTQ2xhc3M6ITAsdXNlUHJlZml4ZXM6ITB9LF9xOltdLG9uOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dChuW2VdKX0sMCl9LGFkZFRlc3Q6ZnVuY3Rpb24oZSx0LG4pe2cucHVzaCh7bmFtZTplLGZuOnQsb3B0aW9uczpufSl9LGFkZEFzeW5jVGVzdDpmdW5jdGlvbihlKXtnLnB1c2goe25hbWU6bnVsbCxmbjplfSl9fSxNb2Rlcm5penI9ZnVuY3Rpb24oKXt9O01vZGVybml6ci5wcm90b3R5cGU9QyxNb2Rlcm5penI9bmV3IE1vZGVybml6cixNb2Rlcm5penIuYWRkVGVzdChcImV2ZW50bGlzdGVuZXJcIixcImFkZEV2ZW50TGlzdGVuZXJcImluIGUpLE1vZGVybml6ci5hZGRUZXN0KFwiaGlzdG9yeVwiLGZ1bmN0aW9uKCl7dmFyIHQ9bmF2aWdhdG9yLnVzZXJBZ2VudDtyZXR1cm4tMT09PXQuaW5kZXhPZihcIkFuZHJvaWQgMi5cIikmJi0xPT09dC5pbmRleE9mKFwiQW5kcm9pZCA0LjBcIil8fC0xPT09dC5pbmRleE9mKFwiTW9iaWxlIFNhZmFyaVwiKXx8LTEhPT10LmluZGV4T2YoXCJDaHJvbWVcIil8fC0xIT09dC5pbmRleE9mKFwiV2luZG93cyBQaG9uZVwiKXx8XCJmaWxlOlwiPT09bG9jYXRpb24ucHJvdG9jb2w/ZS5oaXN0b3J5JiZcInB1c2hTdGF0ZVwiaW4gZS5oaXN0b3J5OiExfSksTW9kZXJuaXpyLmFkZFRlc3QoXCJxdWVyeXNlbGVjdG9yXCIsXCJxdWVyeVNlbGVjdG9yXCJpbiB0JiZcInF1ZXJ5U2VsZWN0b3JBbGxcImluIHQpO3ZhciBTPVtdLHg9Qy5fY29uZmlnLnVzZVByZWZpeGVzP1wiIC13ZWJraXQtIC1tb3otIC1vLSAtbXMtIFwiLnNwbGl0KFwiIFwiKTpbXCJcIixcIlwiXTtDLl9wcmVmaXhlcz14O3ZhciBUPXQuZG9jdW1lbnRFbGVtZW50O01vZGVybml6ci5hZGRUZXN0KFwiY2xhc3NsaXN0XCIsXCJjbGFzc0xpc3RcImluIFQpLE1vZGVybml6ci5hZGRUZXN0KFwiZG9jdW1lbnRmcmFnbWVudFwiLGZ1bmN0aW9uKCl7cmV0dXJuXCJjcmVhdGVEb2N1bWVudEZyYWdtZW50XCJpbiB0JiZcImFwcGVuZENoaWxkXCJpbiBUfSk7dmFyIHc9XCJzdmdcIj09PVQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtNb2Rlcm5penIuYWRkVGVzdChcIm9wYWNpdHlcIixmdW5jdGlvbigpe3ZhciBlPXMoXCJhXCIpLnN0eWxlO3JldHVybiBlLmNzc1RleHQ9eC5qb2luKFwib3BhY2l0eTouNTU7XCIpLC9eMC41NSQvLnRlc3QoZS5vcGFjaXR5KX0pLE1vZGVybml6ci5hZGRUZXN0KFwiY3NzcG9pbnRlcmV2ZW50c1wiLGZ1bmN0aW9uKCl7dmFyIGU9cyhcImFcIikuc3R5bGU7cmV0dXJuIGUuY3NzVGV4dD1cInBvaW50ZXItZXZlbnRzOmF1dG9cIixcImF1dG9cIj09PWUucG9pbnRlckV2ZW50c30pLE1vZGVybml6ci5hZGRUZXN0KFwiY3NzcmVtdW5pdFwiLGZ1bmN0aW9uKCl7dmFyIGU9cyhcImFcIikuc3R5bGU7dHJ5e2UuZm9udFNpemU9XCIzcmVtXCJ9Y2F0Y2godCl7fXJldHVybi9yZW0vLnRlc3QoZS5mb250U2l6ZSl9KSxNb2Rlcm5penIuYWRkVGVzdChcImRhdGFzZXRcIixmdW5jdGlvbigpe3ZhciBlPXMoXCJkaXZcIik7cmV0dXJuIGUuc2V0QXR0cmlidXRlKFwiZGF0YS1hLWJcIixcImNcIiksISghZS5kYXRhc2V0fHxcImNcIiE9PWUuZGF0YXNldC5hQil9KTt2YXIgXz1DLnRlc3RTdHlsZXM9dTtNb2Rlcm5penIuYWRkVGVzdChcInRvdWNoZXZlbnRzXCIsZnVuY3Rpb24oKXt2YXIgbjtpZihcIm9udG91Y2hzdGFydFwiaW4gZXx8ZS5Eb2N1bWVudFRvdWNoJiZ0IGluc3RhbmNlb2YgRG9jdW1lbnRUb3VjaCluPSEwO2Vsc2V7dmFyIHI9W1wiQG1lZGlhIChcIix4LmpvaW4oXCJ0b3VjaC1lbmFibGVkKSwoXCIpLFwiaGVhcnR6XCIsXCIpXCIsXCJ7I21vZGVybml6cnt0b3A6OXB4O3Bvc2l0aW9uOmFic29sdXRlfX1cIl0uam9pbihcIlwiKTtfKHIsZnVuY3Rpb24oZSl7bj05PT09ZS5vZmZzZXRUb3B9KX1yZXR1cm4gbn0pO3ZhciBiPVwiTW96IE8gbXMgV2Via2l0XCIsej1DLl9jb25maWcudXNlUHJlZml4ZXM/Yi5zcGxpdChcIiBcIik6W107Qy5fY3Nzb21QcmVmaXhlcz16O3ZhciBBPWZ1bmN0aW9uKHQpe3ZhciByLG89eC5sZW5ndGgsaT1lLkNTU1J1bGU7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGkpcmV0dXJuIG47aWYoIXQpcmV0dXJuITE7aWYodD10LnJlcGxhY2UoL15ALyxcIlwiKSxyPXQucmVwbGFjZSgvLS9nLFwiX1wiKS50b1VwcGVyQ2FzZSgpK1wiX1JVTEVcIixyIGluIGkpcmV0dXJuXCJAXCIrdDtmb3IodmFyIHM9MDtvPnM7cysrKXt2YXIgYT14W3NdLHU9YS50b1VwcGVyQ2FzZSgpK1wiX1wiK3I7aWYodSBpbiBpKXJldHVyblwiQC1cIithLnRvTG93ZXJDYXNlKCkrXCItXCIrdH1yZXR1cm4hMX07Qy5hdFJ1bGU9QTt2YXIgRT1DLl9jb25maWcudXNlUHJlZml4ZXM/Yi50b0xvd2VyQ2FzZSgpLnNwbGl0KFwiIFwiKTpbXTtDLl9kb21QcmVmaXhlcz1FO3ZhciBPPXtlbGVtOnMoXCJtb2Rlcm5penJcIil9O01vZGVybml6ci5fcS5wdXNoKGZ1bmN0aW9uKCl7ZGVsZXRlIE8uZWxlbX0pO3ZhciBQPXtzdHlsZTpPLmVsZW0uc3R5bGV9O01vZGVybml6ci5fcS51bnNoaWZ0KGZ1bmN0aW9uKCl7ZGVsZXRlIFAuc3R5bGV9KSxDLnRlc3RBbGxQcm9wcz15O3ZhciBxPUMucHJlZml4ZWQ9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiAwPT09ZS5pbmRleE9mKFwiQFwiKT9BKGUpOigtMSE9ZS5pbmRleE9mKFwiLVwiKSYmKGU9aShlKSksdD95KGUsdCxuKTp5KGUsXCJwZnhcIikpfTtNb2Rlcm5penIuYWRkVGVzdChcInJlcXVlc3RhbmltYXRpb25mcmFtZVwiLCEhcShcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiLGUpLHthbGlhc2VzOltcInJhZlwiXX0pLE1vZGVybml6ci5hZGRUZXN0KFwibWF0Y2htZWRpYVwiLCEhcShcIm1hdGNoTWVkaWFcIixlKSksQy50ZXN0QWxsUHJvcHM9aCxNb2Rlcm5penIuYWRkVGVzdChcImNzc2FuaW1hdGlvbnNcIixoKFwiYW5pbWF0aW9uTmFtZVwiLFwiYVwiLCEwKSksTW9kZXJuaXpyLmFkZFRlc3QoXCJjc3N0cmFuc2Zvcm1zXCIsZnVuY3Rpb24oKXtyZXR1cm4tMT09PW5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkFuZHJvaWQgMi5cIikmJmgoXCJ0cmFuc2Zvcm1cIixcInNjYWxlKDEpXCIsITApfSksbygpLGRlbGV0ZSBDLmFkZFRlc3QsZGVsZXRlIEMuYWRkQXN5bmNUZXN0O2Zvcih2YXIgTD0wO0w8TW9kZXJuaXpyLl9xLmxlbmd0aDtMKyspTW9kZXJuaXpyLl9xW0xdKCk7ZS5Nb2Rlcm5penI9TW9kZXJuaXpyfSh3aW5kb3csZG9jdW1lbnQpO1xuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5cbmltcG9ydCAnLi4vbGliL21vZGVybml6cic7XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNGZWF0dXJlcyhmZWF0dXJlcykge1xuICBsZXQgYWNjID0gdHJ1ZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcbiAgICBjb25zdCBoYXNGZWF0dXJlID0gd2luZG93Lk1vZGVybml6cltmZWF0dXJlXTtcbiAgICAvLyBpZiAoIWhhc0ZlYXR1cmUpIGNvbnNvbGUud2FybignRmVhdHVyZSBcIicgKyBmZWF0dXJlICsgJ1wiIG1pc3NpbmchJyk7XG4gICAgYWNjID0gYWNjICYmIGhhc0ZlYXR1cmU7XG4gIH1cbiAgcmV0dXJuIGFjYztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3coZWwpIHtcbiAgZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgZWwuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlkZShlbCkge1xuICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGVsLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5zaG93KGVsKSB7XG4gIGVsLnN0eWxlLmRpc3BsYXkgPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBlbC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbn1cblxuZXhwb3J0IGNvbnN0IHVuaGlkZSA9IHVuc2hvdztcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUN1c3RvbUVsZW1lbnQodGFnTmFtZSwgQ3VzdG9tSFRNTEVsZW1lbnQpIHtcbiAgaWYgKCdjdXN0b21FbGVtZW50cycgaW4gd2luZG93KSB7XG4gICAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIEN1c3RvbUhUTUxFbGVtZW50KTtcbiAgfSBlbHNlIGlmICgncmVnaXN0ZXJFbGVtZW50JyBpbiBkb2N1bWVudCkge1xuICAgIGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCh0YWdOYW1lLCBDdXN0b21IVE1MRWxlbWVudCk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUN1c3RvbUVsZW1lbnRzKGYpIHtcbiAgaWYgKCdjdXN0b21FbGVtZW50cycgaW4gd2luZG93IHx8ICdyZWdpc3RlckVsZW1lbnQnIGluIGRvY3VtZW50KSB7XG4gICAgZigpO1xuICB9IGVsc2Uge1xuICAgIGlmICghd2luZG93LmxvYWRpbmdDdXN0b21FbGVtZW50cykgbG9hZEpTRGVmZXJyZWQoJ2h0dHBzOi8vdW5wa2cuY29tL3dlYmNvbXBvbmVudHMuanNAMC43LjIyL0N1c3RvbUVsZW1lbnRzLm1pbi5qcycpO1xuICAgIHdpbmRvdy5sb2FkaW5nQ3VzdG9tRWxlbWVudHMgPSB0cnVlO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdXZWJDb21wb25lbnRzUmVhZHknLCBmKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIChlbC5tYXRjaGVzIHx8IGVsLm1hdGNoZXNTZWxlY3RvciB8fCBlbC5tc01hdGNoZXNTZWxlY3RvciB8fCBlbC5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZWwub01hdGNoZXNTZWxlY3RvcikuY2FsbChlbCwgc2VsZWN0b3IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYW5pbWF0ZShlbCwga2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXIpID0+IHtcbiAgICBjb25zdCBhbmltID0gZWwuYW5pbWF0ZShrZXlmcmFtZXMsIG9wdGlvbnMpO1xuXG4gICAgYW5pbS5hZGRFdmVudExpc3RlbmVyKCdmaW5pc2gnLCAoZSkgPT4ge1xuICAgICAgb2JzZXJ2ZXIubmV4dChlKTtcbiAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gaWYgKGFuaW0ucGxheVN0YXRlICE9PSAnZmluaXNoZWQnKSBhbmltLmNhbmNlbCgpO1xuICAgIH07XG4gIH0pO1xufVxuIiwiLypcbmVzbGludC1kaXNhYmxlXG5uby1wYXJhbS1yZWFzc2lnbixcbmltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcyxcbmltcG9ydC9uby11bnJlc29sdmVkLFxuaW1wb3J0L2V4dGVuc2lvbnMsXG5jbGFzcy1tZXRob2RzLXVzZS10aGlzLFxuKi9cblxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBlbXB0eSB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9lbXB0eSc7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCB7IHRpbWVyIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL3RpbWVyJztcblxuaW1wb3J0IHsgX2RvIGFzIGVmZmVjdCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvZG8nO1xuaW1wb3J0IHsgX2ZpbmFsbHkgYXMgY2xlYW51cCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvZmluYWxseSc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9yL21hcCc7XG5pbXBvcnQgeyB6aXBQcm90byBhcyB6aXBXaXRoIH0gZnJvbSAncnhqcy9vcGVyYXRvci96aXAnO1xuXG5pbXBvcnQgeyBhbmltYXRlIH0gZnJvbSAnLi9jb21tb24nO1xuXG5jb25zdCB7IGZpbmQgfSA9IEFycmF5LnByb3RvdHlwZTtcblxuZnVuY3Rpb24gdXBkYXRlU3R5bGUoeyBmb250ID0gJ3NlcmlmJywgZm9udEhlYWRpbmcgPSAnc2Fucy1zZXJpZicsIGNvbG9yID0gJyMwMGYnIH0gPSB7fSkge1xuICB0aGlzLnJ1bGVzWzBdLnN0eWxlLmZvbnRGYW1pbHkgPSBmb250OyAvLyBodG1sXG4gIHRoaXMucnVsZXNbMV0uc3R5bGUuZm9udEZhbWlseSA9IGZvbnRIZWFkaW5nOyAvLyBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCAuaGVhZGluZ1xuICB0aGlzLnJ1bGVzWzJdLnN0eWxlLmNvbG9yID0gY29sb3I7IC8vIC5jb250ZW50IGFcbiAgdGhpcy5ydWxlc1szXS5zdHlsZS5vdXRsaW5lQ29sb3IgPSBjb2xvcjsgLy8gOmZvY3VzXG4gIHRoaXMucnVsZXNbNF0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3I7IC8vIDo6c2VsZWN0aW9uXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENyb3NzRmFkZXIge1xuICBjb25zdHJ1Y3Rvcih7IGR1cmF0aW9uIH0pIHtcbiAgICB0aGlzLnNpZGViYXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX3NpZGViYXInKTtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG5cbiAgICBjb25zdCBwYWdlU3R5bGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX3BhZ2VTdHlsZScpO1xuICAgIGNvbnN0IHN0eWxlU2hlZXQgPSBkb2N1bWVudC5zdHlsZVNoZWV0czo6ZmluZChzcyA9PiBzcy5vd25lck5vZGUgPT09IHBhZ2VTdHlsZSk7XG4gICAgdGhpcy5ydWxlcyA9IHN0eWxlU2hlZXQuY3NzUnVsZXMgfHwgc3R5bGVTaGVldC5ydWxlcztcbiAgICB0aGlzLmxhc3RJbWFnZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfbWFpbicpLmdldEF0dHJpYnV0ZSgnZGF0YS1pbWFnZScpO1xuICB9XG5cbiAgZmV0Y2hJbWFnZShkYXRhc2V0KSB7XG4gICAgY29uc3QgeyBjb2xvciwgaW1hZ2UgfSA9IGRhdGFzZXQ7XG5cbiAgICBpZiAoaW1hZ2UgPT09IHRoaXMubGFzdEltYWdlKSB7XG4gICAgICByZXR1cm4gT2JzZXJ2YWJsZTo6ZW1wdHkoKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzJDtcbiAgICBpZiAoaW1hZ2UgPT09ICcnKSB7XG4gICAgICByZXMkID0gT2JzZXJ2YWJsZTo6dGltZXIodGhpcy5kdXJhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGltZ09iaiA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICByZXMkID0gT2JzZXJ2YWJsZTo6ZnJvbUV2ZW50KGltZ09iaiwgJ2xvYWQnKVxuICAgICAgICA6OnppcFdpdGgoT2JzZXJ2YWJsZTo6dGltZXIodGhpcy5kdXJhdGlvbiksIHggPT4geClcbiAgICAgICAgOjpjbGVhbnVwKCgpID0+IHsgaW1nT2JqLnNyYyA9ICcnOyB9KTtcblxuICAgICAgaW1nT2JqLnNyYyA9IGltYWdlO1xuICAgIH1cblxuICAgIHJldHVybiByZXMkXG4gICAgICA6OmVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHRoaXM6OnVwZGF0ZVN0eWxlKGRhdGFzZXQpO1xuICAgICAgICB0aGlzLmxhc3RJbWFnZSA9IGltYWdlO1xuICAgICAgfSlcbiAgICAgIDo6bWFwKCgpID0+IHtcbiAgICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpdi5jbGFzc0xpc3QuYWRkKCdzaWRlYmFyLWJnJyk7XG4gICAgICAgIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgaWYgKGltYWdlICE9PSAnJykgZGl2LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoJHtpbWFnZX0pYDtcbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgIH0pO1xuICB9XG5cbiAgY3Jvc3NGYWRlKFtwcmV2RGl2LCBkaXZdKSB7XG4gICAgcHJldkRpdi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkaXYsIHByZXZEaXYubmV4dEVsZW1lbnRTaWJsaW5nKTtcblxuICAgIHJldHVybiBhbmltYXRlKGRpdiwgW1xuICAgICAgeyBvcGFjaXR5OiAwIH0sXG4gICAgICB7IG9wYWNpdHk6IDEgfSxcbiAgICBdLCB7XG4gICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgIC8vIGVhc2luZzogJ2N1YmljLWJlemllcigwLDAsMC4zMiwxKScsXG4gICAgfSlcbiAgICA6OmNsZWFudXAoKCkgPT4gcHJldkRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZEaXYpKTtcbiAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzLCBpbXBvcnQvbm8tdW5yZXNvbHZlZCwgaW1wb3J0L2V4dGVuc2lvbnMgKi9cblxuaW1wb3J0IFlEcmF3ZXIgZnJvbSAneS1kcmF3ZXIvc3JjL3ZhbmlsbGEnO1xuXG5pbXBvcnQgeyBoYXNGZWF0dXJlcyB9IGZyb20gJy4vY29tbW9uJztcblxuY29uc3QgUkVRVUlSRU1FTlRTID0gW1xuICAnZXZlbnRsaXN0ZW5lcicsXG4gICdxdWVyeXNlbGVjdG9yJyxcbiAgJ21hdGNobWVkaWEnLFxuICAncmVxdWVzdGFuaW1hdGlvbmZyYW1lJyxcbiAgJ2NsYXNzbGlzdCcsXG4gICdvcGFjaXR5JyxcbiAgJ2Nzc3RyYW5zZm9ybXMnLFxuICAnY3NzcG9pbnRlcmV2ZW50cycsXG4gICdjc3NyZW11bml0Jyxcbl07XG5cbmNvbnN0IE1FRElBX1FVRVJZID0gJyhtaW4td2lkdGg6IDgwMXB4KSc7XG5cbmZ1bmN0aW9uIHJlc2l6ZUNhbGxiYWNrKCkge1xuICBjb25zdCBoYXNDaGFuZ2VkID0gd2luZG93LmlzRGVza3RvcCAhPT0gd2luZG93Lm1hdGNoTWVkaWEoTUVESUFfUVVFUlkpLm1hdGNoZXM7XG4gIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgd2luZG93LmlzRGVza3RvcCA9ICF3aW5kb3cuaXNEZXNrdG9wO1xuICAgIHdpbmRvdy5kcmF3ZXIucGVyc2lzdGVudCA9IHdpbmRvdy5pc0Rlc2t0b3A7XG4gICAgd2luZG93LmRyYXdlci5qdW1wVG8od2luZG93LmlzRGVza3RvcCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVudUNsaWNrQ2xhbGxiYWNrKGUpIHtcbiAgaWYgKCF3aW5kb3cuaXNEZXNrdG9wKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHdpbmRvdy5kcmF3ZXIudG9nZ2xlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoZHJhd2VyKSB7XG4gIHdpbmRvdy5kcmF3ZXIgPSBkcmF3ZXI7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCByZXNpemVDYWxsYmFjayk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfbWVudScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgbWVudUNsaWNrQ2xhbGxiYWNrKTtcbn1cblxuaWYgKGhhc0ZlYXR1cmVzKFJFUVVJUkVNRU5UUykpIHtcbiAgd2luZG93LmlzRGVza3RvcCA9IHdpbmRvdy5tYXRjaE1lZGlhKE1FRElBX1FVRVJZKS5tYXRjaGVzO1xuICBjb25zdCBkcmF3ZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX3lEcmF3ZXInKTtcblxuICBhZGRFdmVudExpc3RlbmVycyhuZXcgWURyYXdlcihkcmF3ZXIsIHtcbiAgICBvcGVuZWQ6IHdpbmRvdy5pc0Rlc2t0b3AsXG4gICAgcGVyc2lzdGVudDogd2luZG93LmlzRGVza3RvcCxcbiAgICB0cmFuc2l0aW9uRHVyYXRpb246IDE1MCxcbiAgfSkpO1xuXG4gIGRyYXdlci5jbGFzc0xpc3QuYWRkKCdsb2FkZWQnKTtcbn1cbiIsIi8qXG5lc2xpbnQtZGlzYWJsZVxuY2xhc3MtbWV0aG9kcy11c2UtdGhpc1xuKi9cblxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBlbXB0eSB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9lbXB0eSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEZsaXAge1xuICBzdGF0aWMgY3JlYXRlKHR5cGUsIC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gRmxpcC50eXBlc1t0eXBlXSAhPSBudWxsID9cbiAgICAgIG5ldyBGbGlwLnR5cGVzW3R5cGVdKC4uLmFyZ3MpIDpcbiAgICAgIG5ldyBGbGlwKC4uLmFyZ3MpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoeyBzaGFkb3dNYWluLCBkdXJhdGlvbiB9KSB7XG4gICAgdGhpcy5zaGFkb3dNYWluID0gc2hhZG93TWFpbjtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICByZXR1cm4gT2JzZXJ2YWJsZTo6ZW1wdHkoKTtcbiAgfVxuXG4gIHJlYWR5KCkge1xuICAgIHJldHVybiBPYnNlcnZhYmxlOjplbXB0eSgpO1xuICB9XG59XG5cbkZsaXAudHlwZXMgPSB7fTtcbiIsIi8qXG5lc2xpbnQtZGlzYWJsZVxubm8tcGFyYW0tcmVhc3NpZ24sXG5pbXBvcnQvbm8tZXh0cmFuZW91cy1kZXBlbmRlbmNpZXMsXG5pbXBvcnQvbm8tdW5yZXNvbHZlZCxcbmltcG9ydC9leHRlbnNpb25zLFxuY2xhc3MtbWV0aG9kcy11c2UtdGhpcyxcbiovXG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzL29ic2VydmFibGUvb2YnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgeyB0aW1lciB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS90aW1lcic7XG5cbmltcG9ydCB7IF9kbyBhcyBlZmZlY3QgfSBmcm9tICdyeGpzL29wZXJhdG9yL2RvJztcbmltcG9ydCB7IF9maW5hbGx5IGFzIGNsZWFudXAgfSBmcm9tICdyeGpzL29wZXJhdG9yL2ZpbmFsbHknO1xuaW1wb3J0IHsgemlwUHJvdG8gYXMgemlwV2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvemlwJztcblxuaW1wb3J0IHsgYW5pbWF0ZSB9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQgRmxpcCBmcm9tICcuL2ZsaXAnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9qZWN0RmxpcCBleHRlbmRzIEZsaXAge1xuICBzdGFydChjdXJyZW50VGFyZ2V0KSB7XG4gICAgY29uc3QgaW1nID0gY3VycmVudFRhcmdldC5xdWVyeVNlbGVjdG9yKCcuaW1nJyk7XG5cbiAgICB0aGlzLnNoYWRvd01haW4ucXVlcnlTZWxlY3RvcignLnBhZ2UnKS5pbm5lckhUTUwgPSBgXG4gICAgICA8aDEgY2xhc3M9XCJwYWdlLXRpdGxlXCIgc3R5bGU9XCJvcGFjaXR5OjBcIj58PC9oMT5cbiAgICAgIDxkaXYgY2xhc3M9XCJwb3N0LWRhdGUgaGVhZGluZ1wiIHN0eWxlPVwib3BhY2l0eTowXCI+fDwvZGl2PlxuICAgIGA7XG5cbiAgICBjb25zdCBwbGFjZWhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHBsYWNlaG9sZGVyLmNsYXNzTGlzdC5hZGQoJ3NpeHRlZW4tbmluZScpO1xuXG4gICAgaW1nLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHBsYWNlaG9sZGVyLCBpbWcpO1xuICAgIGltZy5jbGFzc0xpc3QuYWRkKCdsZWFkJyk7XG4gICAgaW1nLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICdsZWZ0IHRvcCc7XG5cbiAgICB0aGlzLnNoYWRvd01haW4ucXVlcnlTZWxlY3RvcignLnBhZ2UnKS5hcHBlbmRDaGlsZChpbWcpO1xuICAgIHRoaXMuc2hhZG93TWFpbi5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgdGhpcy5zaGFkb3dNYWluLnN0eWxlLm9wYWNpdHkgPSAxO1xuXG4gICAgY29uc3QgZmlyc3QgPSBwbGFjZWhvbGRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBsYXN0ID0gaW1nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgY29uc3QgaW52ZXJ0WCA9IGZpcnN0LmxlZnQgLSBsYXN0LmxlZnQ7XG4gICAgY29uc3QgaW52ZXJ0WSA9IGZpcnN0LnRvcCAtIGxhc3QudG9wO1xuICAgIGNvbnN0IGludmVydFNjYWxlID0gZmlyc3Qud2lkdGggLyBsYXN0LndpZHRoO1xuXG4gICAgcmV0dXJuIGFuaW1hdGUoaW1nLCBbXG4gICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7aW52ZXJ0WH1weCwgJHtpbnZlcnRZfXB4LCAwKSBzY2FsZSgke2ludmVydFNjYWxlfSlgIH0sXG4gICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApIHNjYWxlKDEpJyB9LFxuICAgIF0sIHtcbiAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgLy8gZWFzaW5nOiAnZWFzZScsXG4gICAgICBlYXNpbmc6ICdjdWJpYy1iZXppZXIoMCwwLDAuMzIsMSknLFxuICAgIH0pXG4gICAgICA6OmVmZmVjdCgoKSA9PiB7IHRoaXMuc2hhZG93TWFpbi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7IH0pO1xuICB9XG5cbiAgcmVhZHkobWFpbikge1xuICAgIHRoaXMuc2hhZG93TWFpbi5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xuXG4gICAgY29uc3QgaW1nID0gbWFpbi5xdWVyeVNlbGVjdG9yKCcuaW1nJyk7XG5cbiAgICBpZiAoaW1nICE9IG51bGwpIHtcbiAgICAgIGltZy5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgIGltZy5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xuICAgIH1cblxuICAgIGNvbnN0IHJlYWxJbWcgPSBpbWcucXVlcnlTZWxlY3RvcignaW1nJyk7XG4gICAgcmV0dXJuIChyZWFsSW1nID09IG51bGwgP1xuICAgICAgT2JzZXJ2YWJsZTo6b2YodHJ1ZSkgOlxuICAgICAgT2JzZXJ2YWJsZTo6ZnJvbUV2ZW50KHJlYWxJbWcsICdsb2FkJylcbiAgICApXG4gICAgICAvLyBIQUNLOiBhZGQgc29tZSBleHRyYSB0aW1lIHRvIHByZXZlbnQgaGljY3Vwc1xuICAgICAgOjp6aXBXaXRoKE9ic2VydmFibGU6OnRpbWVyKHRoaXMuZHVyYXRpb24gKyAxMDApKVxuICAgICAgOjplZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaW1nICE9IG51bGwpIHtcbiAgICAgICAgICBpbWcuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgaW1nLnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIDo6Y2xlYW51cCgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2hhZG93TWFpbi5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5zaGFkb3dNYWluLnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgICAgIH0pO1xuICB9XG59XG5cbkZsaXAudHlwZXMucHJvamVjdCA9IFByb2plY3RGbGlwO1xuIiwiLypcbmVzbGludC1kaXNhYmxlXG5uby1wYXJhbS1yZWFzc2lnbixcbmltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcyxcbmltcG9ydC9uby11bnJlc29sdmVkLFxuaW1wb3J0L2V4dGVuc2lvbnMsXG5jbGFzcy1tZXRob2RzLXVzZS10aGlzLFxuKi9cblxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyB0aW1lciB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS90aW1lcic7XG5cbmltcG9ydCB7IF9kbyBhcyBlZmZlY3QgfSBmcm9tICdyeGpzL29wZXJhdG9yL2RvJztcbmltcG9ydCB7IF9maW5hbGx5IGFzIGNsZWFudXAgfSBmcm9tICdyeGpzL29wZXJhdG9yL2ZpbmFsbHknO1xuXG5pbXBvcnQgeyBhbmltYXRlIH0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCBGbGlwIGZyb20gJy4vZmxpcCc7XG5cbmNvbnN0IFRJVExFX1NFTEVDVE9SID0gJy5wYWdlLXRpdGxlLCAucG9zdC10aXRsZSc7XG5cbmNsYXNzIFRpdGxlRmxpcCBleHRlbmRzIEZsaXAge1xuICBzdGFydChjdXJyZW50VGFyZ2V0KSB7XG4gICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMScpO1xuXG4gICAgdGl0bGUuY2xhc3NMaXN0LmFkZCgncGFnZS10aXRsZScpO1xuICAgIHRpdGxlLnRleHRDb250ZW50ID0gY3VycmVudFRhcmdldC50ZXh0Q29udGVudDtcbiAgICB0aXRsZS5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnbGVmdCB0b3AnO1xuXG4gICAgdGhpcy5zaGFkb3dNYWluLnF1ZXJ5U2VsZWN0b3IoJy5wYWdlJykuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5zaGFkb3dNYWluLnF1ZXJ5U2VsZWN0b3IoJy5wYWdlJykuYXBwZW5kQ2hpbGQodGl0bGUpO1xuICAgIHRoaXMuc2hhZG93TWFpbi5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgdGhpcy5zaGFkb3dNYWluLnN0eWxlLm9wYWNpdHkgPSAxO1xuXG4gICAgY29uc3QgZmlyc3QgPSBjdXJyZW50VGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGZpcnN0Rm9udFNpemUgPSBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnRUYXJnZXQpLmZvbnRTaXplLCAxMCk7XG4gICAgY29uc3QgbGFzdCA9IHRpdGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGxhc3RGb250U2l6ZSA9IHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUodGl0bGUpLmZvbnRTaXplLCAxMCk7XG5cbiAgICBjb25zdCBpbnZlcnRYID0gZmlyc3QubGVmdCAtIGxhc3QubGVmdDtcbiAgICBjb25zdCBpbnZlcnRZID0gZmlyc3QudG9wIC0gbGFzdC50b3A7XG4gICAgY29uc3QgaW52ZXJ0U2NhbGUgPSBmaXJzdEZvbnRTaXplIC8gbGFzdEZvbnRTaXplO1xuXG4gICAgY3VycmVudFRhcmdldC5zdHlsZS5vcGFjaXR5ID0gMDtcblxuICAgIHJldHVybiBhbmltYXRlKHRpdGxlLCBbXG4gICAgICB7IHRyYW5zZm9ybTogYHRyYW5zbGF0ZTNkKCR7aW52ZXJ0WH1weCwgJHtpbnZlcnRZfXB4LCAwKSBzY2FsZSgke2ludmVydFNjYWxlfSlgIH0sXG4gICAgICB7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKDAsIDAsIDApIHNjYWxlKDEpJyB9LFxuICAgIF0sIHtcbiAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgLy8gZWFzaW5nOiAnZWFzZScsXG4gICAgICBlYXNpbmc6ICdjdWJpYy1iZXppZXIoMCwwLDAuMzIsMSknLFxuICAgIH0pXG4gICAgICA6OmVmZmVjdCgoKSA9PiB7IHRoaXMuc2hhZG93TWFpbi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7IH0pO1xuICB9XG5cbiAgcmVhZHkobWFpbikge1xuICAgIHRoaXMuc2hhZG93TWFpbi5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xuXG4gICAgY29uc3QgdGl0bGUgPSBtYWluLnF1ZXJ5U2VsZWN0b3IoVElUTEVfU0VMRUNUT1IpO1xuXG4gICAgaWYgKHRpdGxlICE9IG51bGwpIHtcbiAgICAgIHRpdGxlLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgdGl0bGUuc3R5bGUud2lsbENoYW5nZSA9ICdvcGFjaXR5JztcbiAgICB9XG5cbiAgICAvLyBIQUNLOiBhZGQgc29tZSBleHRyYSB0aW1lIHRvIHByZXZlbnQgaGljY3Vwc1xuICAgIHJldHVybiBPYnNlcnZhYmxlOjp0aW1lcih0aGlzLmR1cmF0aW9uICsgMTAwKVxuICAgICAgOjplZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodGl0bGUgIT0gbnVsbCkge1xuICAgICAgICAgIHRpdGxlLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgIHRpdGxlLnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIDo6Y2xlYW51cCgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2hhZG93TWFpbi5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgdGhpcy5zaGFkb3dNYWluLnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgICAgIH0pO1xuICB9XG59XG5cbkZsaXAudHlwZXMudGl0bGUgPSBUaXRsZUZsaXA7XG4iLCJpbXBvcnQgJ2NvcmUtanMvZm4vYXJyYXkvZm9yLWVhY2gnO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL2Z1bmN0aW9uL2JpbmQnO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL251bWJlci9jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgJ2NvcmUtanMvZm4vb2JqZWN0L2Fzc2lnbic7XG5pbXBvcnQgJ2NvcmUtanMvZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eSc7XG5pbXBvcnQgJ2NvcmUtanMvZm4vb2JqZWN0L2tleXMnO1xuaW1wb3J0ICdjb3JlLWpzL2ZuL2FycmF5L3JlZHVjZSc7XG5cbmltcG9ydCAnd2ViLWFuaW1hdGlvbnMtanMnO1xuXG5pbXBvcnQgJy4vc3R5bGUnO1xuaW1wb3J0ICcuL2thdGV4JztcbmltcG9ydCAnLi9kcmF3ZXInO1xuaW1wb3J0ICcuL3B1c2gtc3RhdGUnO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuaW1wb3J0IHsgbG9hZENTUyB9IGZyb20gJ2ZnLWxvYWRjc3Mvc3JjL2xvYWRDU1MnO1xuaW1wb3J0IGthdGV4IGZyb20gJ2thdGV4JztcblxuaW1wb3J0IHsgaGFzRmVhdHVyZXMsIGhpZGUsIG1hdGNoZXMgfSBmcm9tICcuL2NvbW1vbic7XG5cbmNvbnN0IFJFUVVJUkVNRU5UUyA9IFtcbiAgJ2V2ZW50bGlzdGVuZXInLFxuICAncXVlcnlzZWxlY3RvcicsXG5dO1xuXG5mdW5jdGlvbiB3aWxsQ2hhbmdlQ29udGVudChtYXRoQmxvY2tzKSB7XG4gIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwobWF0aEJsb2NrcywgKGVsKSA9PiB7XG4gICAgZWwuc3R5bGUud2lsbENoYW5nZSA9ICdjb250ZW50JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZU1hdGhCbG9jayhlbCwgdGV4KSB7XG4gIGVsLm91dGVySFRNTCA9IGthdGV4LnJlbmRlclRvU3RyaW5nKHRleCwge1xuICAgIGRpc3BsYXlNb2RlOiBlbC50eXBlID09PSAnbWF0aC90ZXg7IG1vZGU9ZGlzcGxheScsXG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW5kZXJLYXRleChlbCwgdGV4KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJldiA9IGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgcmVwbGFjZU1hdGhCbG9jayhlbCwgdGV4KTtcbiAgICBpZiAocHJldiAmJiBtYXRjaGVzKHByZXYsICcuTWF0aEpheF9QcmV2aWV3JykpIGhpZGUocHJldik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiByZW1vdmUgaW4gcHJvZHVjdGlvbiBidWlsZHM/XG4gICAgY29uc29sZS5lcnJvcihlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gIH0gZmluYWxseSB7XG4gICAgZWwuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRUZXhTb3VyY2UoZWwpIHtcbiAgcmV0dXJuIGVsLnRleHRDb250ZW50LnJlcGxhY2UoJyUgPCFbQ0RBVEFbJywgJycpLnJlcGxhY2UoJyVdXT4nLCAnJyk7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZUNvbnRlbnQobWF0aEJsb2Nrcykge1xuICAvLyBrcmFtZG93biBnZW5lcmF0ZXMgc2NyaXB0IHRhZ3Mgd2l0aCB0eXBlIFwibWF0aC90ZXhcIlxuICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG1hdGhCbG9ja3MsIChzY3JpcHQpID0+IHtcbiAgICBjb25zdCB0ZXggPSByZWFkVGV4U291cmNlKHNjcmlwdCk7XG4gICAgcmVuZGVyS2F0ZXgoc2NyaXB0LCB0ZXgpO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBncmFkZU1hdGhCbG9ja3MoKSB7XG4gIGlmIChoYXNGZWF0dXJlcyhSRVFVSVJFTUVOVFMpKSB7XG4gICAgY29uc3QgbWF0aEJsb2NrcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdFt0eXBlXj1cIm1hdGgvdGV4XCJdJyk7XG4gICAgaWYgKG1hdGhCbG9ja3MubGVuZ3RoKSB7XG4gICAgICB3aWxsQ2hhbmdlQ29udGVudChtYXRoQmxvY2tzKTtcbiAgICAgIGNoYW5nZUNvbnRlbnQobWF0aEJsb2Nrcyk7XG4gICAgfVxuICB9XG59XG5cbmlmIChoYXNGZWF0dXJlcyhSRVFVSVJFTUVOVFMpKSB7XG4gIGNvbnN0IHJlZiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHlsZScpWzBdO1xuICBjb25zdCBzdHlsZSA9IGxvYWRDU1MoJ2h0dHBzOi8vdW5wa2cuY29tL2thdGV4QDAuNi4wL2Rpc3Qva2F0ZXgubWluLmNzcycsIHJlZik7XG4gIHN0eWxlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB1cGdyYWRlTWF0aEJsb2Nrcyk7XG59XG4iLCIvKlxuZXNsaW50LWRpc2FibGVcbm5vLXBhcmFtLXJlYXNzaWduLFxuaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzLFxuaW1wb3J0L25vLXVucmVzb2x2ZWQsXG5pbXBvcnQvZXh0ZW5zaW9uc1xuKi9cblxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcblxuaW1wb3J0IHsgX2NhdGNoIGFzIHJlY292ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9yL2NhdGNoJztcbmltcG9ydCB7IF9kbyBhcyBlZmZlY3QgfSBmcm9tICdyeGpzL29wZXJhdG9yL2RvJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3IvZGVib3VuY2VUaW1lJztcbmltcG9ydCB7IGV4aGF1c3RNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9yL2V4aGF1c3RNYXAnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvci9maWx0ZXInO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvci9tYXAnO1xuaW1wb3J0IHsgbWVyZ2VNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9yL21lcmdlTWFwJztcbmltcG9ydCB7IHBhaXJ3aXNlIH0gZnJvbSAncnhqcy9vcGVyYXRvci9wYWlyd2lzZSc7XG5pbXBvcnQgeyBzaGFyZSB9IGZyb20gJ3J4anMvb3BlcmF0b3Ivc2hhcmUnO1xuaW1wb3J0IHsgc3RhcnRXaXRoIH0gZnJvbSAncnhqcy9vcGVyYXRvci9zdGFydFdpdGgnO1xuaW1wb3J0IHsgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvci9zd2l0Y2hNYXAnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvci90YWtlVW50aWwnO1xuaW1wb3J0IHsgemlwUHJvdG8gYXMgemlwV2l0aCB9IGZyb20gJ3J4anMvb3BlcmF0b3IvemlwJztcblxuaW1wb3J0IFB1c2hTdGF0ZSBmcm9tICd5LXB1c2gtc3RhdGUvc3JjL3ZhbmlsbGEnO1xuXG5pbXBvcnQgeyBoYXNGZWF0dXJlcywgYW5pbWF0ZSB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCBDcm9zc0ZhZGVyIGZyb20gJy4vY3Jvc3MtZmFkZXInO1xuaW1wb3J0IHVwZ3JhZGVNYXRoQmxvY2tzIGZyb20gJy4va2F0ZXgnO1xuXG5pbXBvcnQgRmxpcCBmcm9tICcuL2ZsaXAvZmxpcCc7XG5pbXBvcnQgJy4vZmxpcC90aXRsZSc7XG5pbXBvcnQgJy4vZmxpcC9wcm9qZWN0JztcblxuY29uc3QgUkVRVUlSRU1FTlRTID0gW1xuICAnZXZlbnRsaXN0ZW5lcicsXG4gICdxdWVyeXNlbGVjdG9yJyxcbiAgJ3JlcXVlc3RhbmltYXRpb25mcmFtZScsXG4gICdjbGFzc2xpc3QnLFxuICAnZG9jdW1lbnRmcmFnbWVudCcsXG4gICdoaXN0b3J5JyxcbiAgJ29wYWNpdHknLFxuICAnY3NzYW5pbWF0aW9ucycsXG4gICdkYXRhc2V0Jyxcbl07XG5cbmNvbnN0IERVUkFUSU9OID0gMjUwO1xuY29uc3QgRkFERV9EVVJBVElPTiA9IDYwMDtcblxuLy8gd2hlbmV2ZXIgdGhlIHNvdXJjZSBvYnNlcnZhYmxlIGVuY291bnRlcnMgYW4gZXJyb3IsXG4vLyB3ZSBsb2cgaXQgdG8gdGhlIGNvbnNvbGUsIGJ1dCBjb250aW51ZSBhcyBpZiBpdCBuZXZlciBoYXBwZW5kXG5mdW5jdGlvbiBtYWtlVW5zdG9wcGFibGUoKSB7XG4gIHJldHVybiB0aGlzOjpyZWNvdmVyKChlcnJvciwgY2F1Z2h0KSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gY2F1Z2h0O1xuICB9KTtcbn1cblxuaWYgKGhhc0ZlYXR1cmVzKFJFUVVJUkVNRU5UUykpIHtcbiAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGlzU2FmYXJpID0gdWEuaW5kZXhPZignc2FmYXJpJykgPiAwICYmIHVhLmluZGV4T2YoJ2Nocm9tZScpIDwgMDtcblxuICBjb25zdCBjcm9zc0ZhZGVyID0gbmV3IENyb3NzRmFkZXIoeyBkdXJhdGlvbjogRkFERV9EVVJBVElPTiB9KTtcblxuICBjb25zdCBwdXNoU3RhdGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX3lQdXNoU3RhdGUnKTtcbiAgY29uc3QgbG9hZGluZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfbG9hZGluZycpO1xuXG4gIGNvbnN0IHNoYWRvd01haW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgc2hhZG93TWFpbi5jbGFzc0xpc3QuYWRkKCdzaGFkb3ctbWFpbicpO1xuICBzaGFkb3dNYWluLmlubmVySFRNTCA9IGBcbiAgICA8ZGl2IGNsYXNzPVwiY29udGVudCBjb250YWluZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJwYWdlXCI+PC9kaXY+XG4gICAgPC9kaXY+YDtcbiAgcHVzaFN0YXRlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNoYWRvd01haW4sIHB1c2hTdGF0ZSk7XG5cbiAgY29uc3Qgc3RhcnQkID0gT2JzZXJ2YWJsZTo6ZnJvbUV2ZW50KHB1c2hTdGF0ZSwgJ3ktcHVzaC1zdGF0ZS1zdGFydCcpXG4gICAgOjptYXAoKHsgZGV0YWlsIH0pID0+IGRldGFpbClcbiAgICA6Om1hcChkZXRhaWwgPT4gW2RldGFpbCwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19tYWluJyldKVxuICAgIDo6ZWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIElmIGEgbGluayBvbiB0aGUgZHJhd2VyIGhhcyBiZWVuIGNsaWNrZWQsIGNsb3NlIGl0XG4gICAgICBpZiAoIXdpbmRvdy5pc0Rlc2t0b3AgJiYgd2luZG93LmRyYXdlci5vcGVuZWQpIHtcbiAgICAgICAgd2luZG93LmRyYXdlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0pXG4gICAgOjpzaGFyZSgpO1xuXG4gIGNvbnN0IHJlYWR5JCA9IE9ic2VydmFibGU6OmZyb21FdmVudChwdXNoU3RhdGUsICd5LXB1c2gtc3RhdGUtcmVhZHknKVxuICAgIDo6bWFwKCh7IGRldGFpbCB9KSA9PiBkZXRhaWwpXG4gICAgOjpzaGFyZSgpO1xuXG4gIGNvbnN0IHByb2dyZXNzJCA9IE9ic2VydmFibGU6OmZyb21FdmVudChwdXNoU3RhdGUsICd5LXB1c2gtc3RhdGUtcHJvZ3Jlc3MnKVxuICAgIDo6bWFwKCh7IGRldGFpbCB9KSA9PiBkZXRhaWwpO1xuICAgIC8vIDo6c2hhcmUoKTtcblxuICBjb25zdCBhZnRlciQgPSBPYnNlcnZhYmxlOjpmcm9tRXZlbnQocHVzaFN0YXRlLCAneS1wdXNoLXN0YXRlLWFmdGVyJylcbiAgICA6Om1hcCgoeyBkZXRhaWwgfSkgPT4gZGV0YWlsKVxuICAgIDo6c2hhcmUoKTtcblxuICAvLyBjb25zdCBlcnJvciQgPSBPYnNlcnZhYmxlLmZyb21FdmVudChwdXNoU3RhdGUsICd5LXB1c2gtc3RhdGUtZXJyb3InKTtcblxuICAvLyBIQUNLXG4gIGlmIChpc1NhZmFyaSkge1xuICAgIE9ic2VydmFibGU6OmZyb21FdmVudCh3aW5kb3csICdwb3BzdGF0ZScpXG4gICAgICAuc3Vic2NyaWJlKCgpID0+IHsgZG9jdW1lbnQuYm9keS5zdHlsZS5taW5IZWlnaHQgPSAnOTk5OTk5cHgnOyB9KTtcblxuICAgIGFmdGVyJFxuICAgICAgLnN1YnNjcmliZSgoKSA9PiB7IGRvY3VtZW50LmJvZHkuc3R5bGUubWluSGVpZ2h0ID0gJyc7IH0pO1xuICB9XG5cbiAgLy8gRkxJUCBhbmltYXRpb24gKHdoZW4gYXBwbGljYWJsZSlcbiAgc3RhcnQkXG4gICAgOjpzd2l0Y2hNYXAoKFtkZXRhaWxdKSA9PiB7XG4gICAgICBjb25zdCB7IGV2ZW50OiB7IGN1cnJlbnRUYXJnZXQgfSB9ID0gZGV0YWlsO1xuXG4gICAgICBjb25zdCBmbGlwID0gRmxpcC5jcmVhdGUoY3VycmVudFRhcmdldC5kYXRhc2V0ICYmIGN1cnJlbnRUYXJnZXQuZGF0YXNldC5mbGlwLCB7XG4gICAgICAgIHNoYWRvd01haW4sXG4gICAgICAgIGN1cnJlbnRUYXJnZXQsXG4gICAgICAgIGR1cmF0aW9uOiBEVVJBVElPTixcbiAgICAgIH0pO1xuXG4gICAgICAvLyBIQUNLOiBUaGlzIGFzc3VtZXMga25vd2xlZGdlIG9mIHRoZSBpbnRlcm5hbCByeCBwaXBlbGluZS5cbiAgICAgIC8vIENvdWxkIHBvc3NpYmx5IGJlIHJlcGxhY2VkIHdpdGggYHdpdGhMYXRlc3RGcm9tYCBzaGluYW5pZ2FucyxcbiAgICAgIC8vIGJ1dCBpdCdzIG1vcmUgY29udmVuaWVudCBsaWtlIHRoYXQuXG4gICAgICBkZXRhaWwuZmxpcCA9IGZsaXA7XG5cbiAgICAgIHJldHVybiBmbGlwLnN0YXJ0KGN1cnJlbnRUYXJnZXQpO1xuICAgIH0pXG4gICAgOjptYWtlVW5zdG9wcGFibGUoKVxuICAgIC5zdWJzY3JpYmUoKTtcblxuICAvLyBGYWRlIG1haW4gY29udGVudCBvdXRcbiAgc3RhcnQkXG4gICAgOjplZmZlY3QoKFssIG1haW5dKSA9PiB7IG1haW4uc3R5bGUub3BhY2l0eSA9IDA7IH0pXG4gICAgOjpmaWx0ZXIoKFt7IHR5cGUgfV0pID0+IHR5cGUgPT09ICdwdXNoJyB8fCAhaXNTYWZhcmkpXG4gICAgOjpleGhhdXN0TWFwKChbeyB0eXBlIH0sIG1haW5dKSA9PlxuICAgICAgYW5pbWF0ZShtYWluLCBbXG4gICAgICAgIHsgb3BhY2l0eTogMSB9LFxuICAgICAgICB7IG9wYWNpdHk6IDAgfSxcbiAgICAgIF0sIHtcbiAgICAgICAgZHVyYXRpb246IERVUkFUSU9OLFxuICAgICAgICAvLyBlYXNpbmc6ICdlYXNlJyxcbiAgICAgICAgZWFzaW5nOiAnY3ViaWMtYmV6aWVyKDAsMCwwLjMyLDEpJyxcbiAgICAgIH0pXG4gICAgICAgIDo6ZWZmZWN0KCgpID0+IHsgaWYgKHR5cGUgPT09ICdwdXNoJykgd2luZG93LnNjcm9sbCgwLCAwKTsgfSlcbiAgICAgICAgOjp6aXBXaXRoKGFmdGVyJCkpXG4gICAgOjptYWtlVW5zdG9wcGFibGUoKVxuICAgIC5zdWJzY3JpYmUoKTtcblxuICAvLyBTaG93IGxvYWRpbmcgYmFyIHdoZW4gdGFraW5nIGxvbmdlciB0aGFuIGV4cGVjdGVkXG4gIHByb2dyZXNzJFxuICAgIDo6ZWZmZWN0KCgpID0+IHsgbG9hZGluZy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsgfSlcbiAgICA6Om1ha2VVbnN0b3BwYWJsZSgpXG4gICAgLnN1YnNjcmliZSgpO1xuXG4gIC8vIFRPRE86IGVycm9yIG1lc3NhZ2UhP1xuICAvLyBlcnJvciRcbiAgLy8gICAvLyAuZGVsYXkoRFVSQVRJT04pIC8vIEhBQ0tcbiAgLy8gICAuZG8oKCkgPT4ge1xuICAvLyAgICAgbG9hZGluZy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAvLyAgIH0pXG4gIC8vICAgLnN1YnNjcmliZSgpO1xuXG4gIC8vIFByZXBhcmUgc2hvd2luZyB0aGUgbmV3IGNvbnRlbnRcbiAgcmVhZHkkXG4gICAgOjplZmZlY3QoKCkgPT4geyBsb2FkaW5nLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IH0pXG4gICAgOjpmaWx0ZXIoKHsgdHlwZSB9KSA9PiB0eXBlID09PSAncHVzaCcgfHwgIWlzU2FmYXJpKVxuICAgIDo6c3dpdGNoTWFwKCh7IGZsaXAsIGNvbnRlbnQ6IFttYWluXSB9KSA9PiBmbGlwLnJlYWR5KG1haW4pOjp0YWtlVW50aWwoc3RhcnQkKSlcbiAgICA6Om1ha2VVbnN0b3BwYWJsZSgpXG4gICAgLnN1YnNjcmliZSgpO1xuXG4gIHJlYWR5JFxuICAgIDo6c3dpdGNoTWFwKCh7IGNvbnRlbnQ6IFttYWluXSB9KSA9PiBjcm9zc0ZhZGVyLmZldGNoSW1hZ2UobWFpbi5kYXRhc2V0KTo6dGFrZVVudGlsKHN0YXJ0JCkpXG4gICAgOjpzdGFydFdpdGgoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNpZGViYXItYmcnKSlcbiAgICA6OnBhaXJ3aXNlKClcbiAgICA6Om1lcmdlTWFwKDo6Y3Jvc3NGYWRlci5jcm9zc0ZhZGUpXG4gICAgOjptYWtlVW5zdG9wcGFibGUoKVxuICAgIC5zdWJzY3JpYmUoKTtcblxuICAvLyBBbmltYXRlIHRoZSBuZXcgY29udGVudFxuICBhZnRlciRcbiAgICA6OmZpbHRlcigoeyB0eXBlIH0pID0+IHR5cGUgPT09ICdwdXNoJyB8fCAhaXNTYWZhcmkpXG4gICAgOjptYXAoa2luZCA9PiBba2luZCwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWFpbicpXSlcbiAgICA6OnN3aXRjaE1hcCgoWywgbWFpbl0pID0+XG4gICAgICBhbmltYXRlKG1haW4sIFtcbiAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC0ycmVtKScsIG9wYWNpdHk6IDAgfSxcbiAgICAgICAgeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDApJywgb3BhY2l0eTogMSB9LFxuICAgICAgXSwge1xuICAgICAgICBkdXJhdGlvbjogRFVSQVRJT04sXG4gICAgICAgIC8vIGVhc2luZzogJ2Vhc2UnLFxuICAgICAgICBlYXNpbmc6ICdjdWJpYy1iZXppZXIoMCwwLDAuMzIsMSknLFxuICAgICAgfSkpXG4gICAgOjptYWtlVW5zdG9wcGFibGUoKVxuICAgIC5zdWJzY3JpYmUoKTtcblxuICBhZnRlciRcbiAgICAvLyBEb24ndCBzZW5kIGEgcGFnZXZpZXcgd2hlbiB0aGUgdXNlciBibGFzdHMgdGhyb3VnaCB0aGUgaGlzdG9yeS4uXG4gICAgOjpkZWJvdW5jZVRpbWUoMiAqIERVUkFUSU9OKVxuICAgIDo6ZWZmZWN0KCgpID0+IHtcbiAgICAgIC8vIFNlbmQgZ29vZ2xlIGFuYWx5dGljcyBwYWdldmlld1xuICAgICAgaWYgKHdpbmRvdy5nYSkgd2luZG93LmdhKCdzZW5kJywgJ3BhZ2V2aWV3Jyk7XG5cbiAgICAgIC8vIFVwZ3JhZGUgbWF0aCBibG9ja3NcbiAgICAgIHVwZ3JhZGVNYXRoQmxvY2tzKCk7XG4gICAgfSlcbiAgICA6Om1ha2VVbnN0b3BwYWJsZSgpXG4gICAgLnN1YnNjcmliZSgpO1xuXG4gIG5ldyBQdXNoU3RhdGUocHVzaFN0YXRlLCB7XG4gICAgcmVwbGFjZUlkczogWydfbWFpbiddLFxuICAgIGxpbmtTZWxlY3RvcjogJ2FbaHJlZl49XCIvXCJdJyxcbiAgICBkdXJhdGlvbjogRFVSQVRJT04sXG4gICAgbm9Qb3BEdXJhdGlvbjogaXNTYWZhcmksXG4gICAgc2Nyb2xsUmVzdG9yYXRpb246ICFpc1NhZmFyaSxcbiAgfSkuc3RhcnRIaXN0b3J5KCk7XG59XG4iLCJpbXBvcnQgeyBsb2FkQ1NTIH0gZnJvbSAnZmctbG9hZGNzcy9zcmMvbG9hZENTUyc7XG5cbmZ1bmN0aW9uIGhhc1ByZWxvYWRTdXBwb3J0KCkge1xuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJykucmVsTGlzdC5zdXBwb3J0cygncHJlbG9hZCcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIGxvb3AgcHJlbG9hZCBsaW5rcyBhbmQgZmV0Y2ggdXNpbmcgbG9hZENTU1xuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIGNvbnN0IGxpbmtzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpbmsnKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmtzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgbGluayA9IGxpbmtzW2ldO1xuICAgIGlmIChsaW5rLnJlbCA9PT0gJ3ByZWxvYWQnICYmIGxpbmsuZ2V0QXR0cmlidXRlKCdhcycpID09PSAnc3R5bGUnKSB7XG4gICAgICBsb2FkQ1NTKGxpbmsuaHJlZiwgbGluayk7XG4gICAgICBsaW5rLnJlbCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmlmICghaGFzUHJlbG9hZFN1cHBvcnQoKSkge1xuICBwb2x5ZmlsbCgpO1xufVxuIiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkuZm9yLWVhY2gnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLkFycmF5LmZvckVhY2g7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuYXJyYXkucmVkdWNlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5BcnJheS5yZWR1Y2U7IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYuZnVuY3Rpb24uYmluZCcpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuRnVuY3Rpb24uYmluZDsiLCJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5udW1iZXIuY29uc3RydWN0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gTnVtYmVyOyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24nKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247IiwicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKXtcbiAgcmV0dXJuICRPYmplY3QuZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgZGVzYyk7XG59OyIsInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5rZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Qua2V5czsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICBpZighaXNPYmplY3QoaXQpKXRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mXG4vLyB0cnVlICAtPiBBcnJheSNpbmNsdWRlc1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgdG9JbmRleCAgID0gcmVxdWlyZSgnLi9fdG8taW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oSVNfSU5DTFVERVMpe1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGVsLCBmcm9tSW5kZXgpe1xuICAgIHZhciBPICAgICAgPSB0b0lPYmplY3QoJHRoaXMpXG4gICAgICAsIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKVxuICAgICAgLCBpbmRleCAgPSB0b0luZGV4KGZyb21JbmRleCwgbGVuZ3RoKVxuICAgICAgLCB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgaWYoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpd2hpbGUobGVuZ3RoID4gaW5kZXgpe1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgaWYodmFsdWUgIT0gdmFsdWUpcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjdG9JbmRleCBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pe1xuICAgICAgaWYoT1tpbmRleF0gPT09IGVsKXJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07IiwiLy8gMCAtPiBBcnJheSNmb3JFYWNoXG4vLyAxIC0+IEFycmF5I21hcFxuLy8gMiAtPiBBcnJheSNmaWx0ZXJcbi8vIDMgLT4gQXJyYXkjc29tZVxuLy8gNCAtPiBBcnJheSNldmVyeVxuLy8gNSAtPiBBcnJheSNmaW5kXG4vLyA2IC0+IEFycmF5I2ZpbmRJbmRleFxudmFyIGN0eCAgICAgID0gcmVxdWlyZSgnLi9fY3R4JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpXG4gICwgYXNjICAgICAgPSByZXF1aXJlKCcuL19hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihUWVBFLCAkY3JlYXRlKXtcbiAgdmFyIElTX01BUCAgICAgICAgPSBUWVBFID09IDFcbiAgICAsIElTX0ZJTFRFUiAgICAgPSBUWVBFID09IDJcbiAgICAsIElTX1NPTUUgICAgICAgPSBUWVBFID09IDNcbiAgICAsIElTX0VWRVJZICAgICAgPSBUWVBFID09IDRcbiAgICAsIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDZcbiAgICAsIE5PX0hPTEVTICAgICAgPSBUWVBFID09IDUgfHwgSVNfRklORF9JTkRFWFxuICAgICwgY3JlYXRlICAgICAgICA9ICRjcmVhdGUgfHwgYXNjO1xuICByZXR1cm4gZnVuY3Rpb24oJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpe1xuICAgIHZhciBPICAgICAgPSB0b09iamVjdCgkdGhpcylcbiAgICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICAgLCBmICAgICAgPSBjdHgoY2FsbGJhY2tmbiwgdGhhdCwgMylcbiAgICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoc2VsZi5sZW5ndGgpXG4gICAgICAsIGluZGV4ICA9IDBcbiAgICAgICwgcmVzdWx0ID0gSVNfTUFQID8gY3JlYXRlKCR0aGlzLCBsZW5ndGgpIDogSVNfRklMVEVSID8gY3JlYXRlKCR0aGlzLCAwKSA6IHVuZGVmaW5lZFxuICAgICAgLCB2YWwsIHJlcztcbiAgICBmb3IoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKWlmKE5PX0hPTEVTIHx8IGluZGV4IGluIHNlbGYpe1xuICAgICAgdmFsID0gc2VsZltpbmRleF07XG4gICAgICByZXMgPSBmKHZhbCwgaW5kZXgsIE8pO1xuICAgICAgaWYoVFlQRSl7XG4gICAgICAgIGlmKElTX01BUClyZXN1bHRbaW5kZXhdID0gcmVzOyAgICAgICAgICAgIC8vIG1hcFxuICAgICAgICBlbHNlIGlmKHJlcylzd2l0Y2goVFlQRSl7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWw7ICAgICAgICAgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHJlc3VsdC5wdXNoKHZhbCk7ICAgICAgICAgICAgICAgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZihJU19FVkVSWSlyZXR1cm4gZmFsc2U7ICAgICAgICAgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiByZXN1bHQ7XG4gIH07XG59OyIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCB0b09iamVjdCAgPSByZXF1aXJlKCcuL190by1vYmplY3QnKVxuICAsIElPYmplY3QgICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsIHRvTGVuZ3RoICA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIGNhbGxiYWNrZm4sIGFMZW4sIG1lbW8sIGlzUmlnaHQpe1xuICBhRnVuY3Rpb24oY2FsbGJhY2tmbik7XG4gIHZhciBPICAgICAgPSB0b09iamVjdCh0aGF0KVxuICAgICwgc2VsZiAgID0gSU9iamVjdChPKVxuICAgICwgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpXG4gICAgLCBpbmRleCAgPSBpc1JpZ2h0ID8gbGVuZ3RoIC0gMSA6IDBcbiAgICAsIGkgICAgICA9IGlzUmlnaHQgPyAtMSA6IDE7XG4gIGlmKGFMZW4gPCAyKWZvcig7Oyl7XG4gICAgaWYoaW5kZXggaW4gc2VsZil7XG4gICAgICBtZW1vID0gc2VsZltpbmRleF07XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGluZGV4ICs9IGk7XG4gICAgaWYoaXNSaWdodCA/IGluZGV4IDwgMCA6IGxlbmd0aCA8PSBpbmRleCl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICB9XG4gIH1cbiAgZm9yKDtpc1JpZ2h0ID8gaW5kZXggPj0gMCA6IGxlbmd0aCA+IGluZGV4OyBpbmRleCArPSBpKWlmKGluZGV4IGluIHNlbGYpe1xuICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gIH1cbiAgcmV0dXJuIG1lbW87XG59OyIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgaXNBcnJheSAgPSByZXF1aXJlKCcuL19pcy1hcnJheScpXG4gICwgU1BFQ0lFUyAgPSByZXF1aXJlKCcuL193a3MnKSgnc3BlY2llcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsKXtcbiAgdmFyIEM7XG4gIGlmKGlzQXJyYXkob3JpZ2luYWwpKXtcbiAgICBDID0gb3JpZ2luYWwuY29uc3RydWN0b3I7XG4gICAgLy8gY3Jvc3MtcmVhbG0gZmFsbGJhY2tcbiAgICBpZih0eXBlb2YgQyA9PSAnZnVuY3Rpb24nICYmIChDID09PSBBcnJheSB8fCBpc0FycmF5KEMucHJvdG90eXBlKSkpQyA9IHVuZGVmaW5lZDtcbiAgICBpZihpc09iamVjdChDKSl7XG4gICAgICBDID0gQ1tTUEVDSUVTXTtcbiAgICAgIGlmKEMgPT09IG51bGwpQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/IEFycmF5IDogQztcbn07IiwiLy8gOS40LjIuMyBBcnJheVNwZWNpZXNDcmVhdGUob3JpZ2luYWxBcnJheSwgbGVuZ3RoKVxudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4vX2FycmF5LXNwZWNpZXMtY29uc3RydWN0b3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbCwgbGVuZ3RoKXtcbiAgcmV0dXJuIG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKG9yaWdpbmFsKSkobGVuZ3RoKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiAgPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJylcbiAgLCBpc09iamVjdCAgID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0JylcbiAgLCBpbnZva2UgICAgID0gcmVxdWlyZSgnLi9faW52b2tlJylcbiAgLCBhcnJheVNsaWNlID0gW10uc2xpY2VcbiAgLCBmYWN0b3JpZXMgID0ge307XG5cbnZhciBjb25zdHJ1Y3QgPSBmdW5jdGlvbihGLCBsZW4sIGFyZ3Mpe1xuICBpZighKGxlbiBpbiBmYWN0b3JpZXMpKXtcbiAgICBmb3IodmFyIG4gPSBbXSwgaSA9IDA7IGkgPCBsZW47IGkrKyluW2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgZmFjdG9yaWVzW2xlbl0gPSBGdW5jdGlvbignRixhJywgJ3JldHVybiBuZXcgRignICsgbi5qb2luKCcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbbGVuXShGLCBhcmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uYmluZCB8fCBmdW5jdGlvbiBiaW5kKHRoYXQgLyosIGFyZ3MuLi4gKi8pe1xuICB2YXIgZm4gICAgICAgPSBhRnVuY3Rpb24odGhpcylcbiAgICAsIHBhcnRBcmdzID0gYXJyYXlTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZCA9IGZ1bmN0aW9uKC8qIGFyZ3MuLi4gKi8pe1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KGFycmF5U2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBpbnZva2UoZm4sIGFyZ3MsIHRoYXQpO1xuICB9O1xuICBpZihpc09iamVjdChmbi5wcm90b3R5cGUpKWJvdW5kLnByb3RvdHlwZSA9IGZuLnByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kO1xufTsiLCJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGl0KS5zbGljZSg4LCAtMSk7XG59OyIsInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7dmVyc2lvbjogJzIuNC4wJ307XG5pZih0eXBlb2YgX19lID09ICdudW1iZXInKV9fZSA9IGNvcmU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWYiLCIvLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuL19hLWZ1bmN0aW9uJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCB0aGF0LCBsZW5ndGgpe1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZih0aGF0ID09PSB1bmRlZmluZWQpcmV0dXJuIGZuO1xuICBzd2l0Y2gobGVuZ3RoKXtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbihhKXtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKGEsIGIsIGMpe1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSwgYiwgYyk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oLyogLi4uYXJncyAqLyl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59OyIsIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgPT0gdW5kZWZpbmVkKXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uICBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTsiLCIvLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywge2dldDogZnVuY3Rpb24oKXsgcmV0dXJuIDc7IH19KS5hICE9IDc7XG59KTsiLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKVxuICAsIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnRcbiAgLy8gaW4gb2xkIElFIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnXG4gICwgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07IiwiLy8gSUUgOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSAoXG4gICdjb25zdHJ1Y3RvcixoYXNPd25Qcm9wZXJ0eSxpc1Byb3RvdHlwZU9mLHByb3BlcnR5SXNFbnVtZXJhYmxlLHRvTG9jYWxlU3RyaW5nLHRvU3RyaW5nLHZhbHVlT2YnXG4pLnNwbGl0KCcsJyk7IiwidmFyIGdsb2JhbCAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpXG4gICwgY29yZSAgICAgID0gcmVxdWlyZSgnLi9fY29yZScpXG4gICwgaGlkZSAgICAgID0gcmVxdWlyZSgnLi9faGlkZScpXG4gICwgcmVkZWZpbmUgID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKVxuICAsIGN0eCAgICAgICA9IHJlcXVpcmUoJy4vX2N0eCcpXG4gICwgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgc291cmNlKXtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkZcbiAgICAsIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0LkdcbiAgICAsIElTX1NUQVRJQyA9IHR5cGUgJiAkZXhwb3J0LlNcbiAgICAsIElTX1BST1RPICA9IHR5cGUgJiAkZXhwb3J0LlBcbiAgICAsIElTX0JJTkQgICA9IHR5cGUgJiAkZXhwb3J0LkJcbiAgICAsIHRhcmdldCAgICA9IElTX0dMT0JBTCA/IGdsb2JhbCA6IElTX1NUQVRJQyA/IGdsb2JhbFtuYW1lXSB8fCAoZ2xvYmFsW25hbWVdID0ge30pIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXVxuICAgICwgZXhwb3J0cyAgID0gSVNfR0xPQkFMID8gY29yZSA6IGNvcmVbbmFtZV0gfHwgKGNvcmVbbmFtZV0gPSB7fSlcbiAgICAsIGV4cFByb3RvICA9IGV4cG9ydHNbUFJPVE9UWVBFXSB8fCAoZXhwb3J0c1tQUk9UT1RZUEVdID0ge30pXG4gICAgLCBrZXksIG93biwgb3V0LCBleHA7XG4gIGlmKElTX0dMT0JBTClzb3VyY2UgPSBuYW1lO1xuICBmb3Ioa2V5IGluIHNvdXJjZSl7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYodGFyZ2V0KXJlZGVmaW5lKHRhcmdldCwga2V5LCBvdXQsIHR5cGUgJiAkZXhwb3J0LlUpO1xuICAgIC8vIGV4cG9ydFxuICAgIGlmKGV4cG9ydHNba2V5XSAhPSBvdXQpaGlkZShleHBvcnRzLCBrZXksIGV4cCk7XG4gICAgaWYoSVNfUFJPVE8gJiYgZXhwUHJvdG9ba2V5XSAhPSBvdXQpZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAgXG5tb2R1bGUuZXhwb3J0cyA9ICRleHBvcnQ7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleGVjKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2goZSl7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07IiwiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZiA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZih0eXBlb2YgX19nID09ICdudW1iZXInKV9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZiIsInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCwga2V5KXtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59OyIsInZhciBkUCAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJylcbiAgLCBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24ob2JqZWN0LCBrZXksIHZhbHVlKXtcbiAgcmV0dXJuIGRQLmYob2JqZWN0LCBrZXksIGNyZWF0ZURlc2MoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbihvYmplY3QsIGtleSwgdmFsdWUpe1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsiLCJtb2R1bGUuZXhwb3J0cyA9ICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpICYmICFyZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7Z2V0OiBmdW5jdGlvbigpeyByZXR1cm4gNzsgfX0pLmEgIT0gNztcbn0pOyIsInZhciBpc09iamVjdCAgICAgICA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRoYXQsIHRhcmdldCwgQyl7XG4gIHZhciBQLCBTID0gdGFyZ2V0LmNvbnN0cnVjdG9yO1xuICBpZihTICE9PSBDICYmIHR5cGVvZiBTID09ICdmdW5jdGlvbicgJiYgKFAgPSBTLnByb3RvdHlwZSkgIT09IEMucHJvdG90eXBlICYmIGlzT2JqZWN0KFApICYmIHNldFByb3RvdHlwZU9mKXtcbiAgICBzZXRQcm90b3R5cGVPZih0aGF0LCBQKTtcbiAgfSByZXR1cm4gdGhhdDtcbn07IiwiLy8gZmFzdCBhcHBseSwgaHR0cDovL2pzcGVyZi5sbmtpdC5jb20vZmFzdC1hcHBseS81XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZuLCBhcmdzLCB0aGF0KXtcbiAgdmFyIHVuID0gdGhhdCA9PT0gdW5kZWZpbmVkO1xuICBzd2l0Y2goYXJncy5sZW5ndGgpe1xuICAgIGNhc2UgMDogcmV0dXJuIHVuID8gZm4oKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0KTtcbiAgICBjYXNlIDE6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIHVuID8gZm4oYXJnc1swXSwgYXJnc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICA6IGZuLmNhbGwodGhhdCwgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gdW4gPyBmbihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKVxuICAgICAgICAgICAgICAgICAgICAgIDogZm4uY2FsbCh0aGF0LCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICBjYXNlIDQ6IHJldHVybiB1biA/IGZuKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pXG4gICAgICAgICAgICAgICAgICAgICAgOiBmbi5jYWxsKHRoYXQsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICB9IHJldHVybiAgICAgICAgICAgICAgZm4uYXBwbHkodGhhdCwgYXJncyk7XG59OyIsIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59OyIsIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpe1xuICByZXR1cm4gY29mKGFyZykgPT0gJ0FycmF5Jztcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59OyIsIid1c2Ugc3RyaWN0Jztcbi8vIDE5LjEuMi4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UsIC4uLilcbnZhciBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJylcbiAgLCBnT1BTICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BzJylcbiAgLCBwSUUgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCBJT2JqZWN0ICA9IHJlcXVpcmUoJy4vX2lvYmplY3QnKVxuICAsICRhc3NpZ24gID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gc2hvdWxkIHdvcmsgd2l0aCBzeW1ib2xzIGFuZCBzaG91bGQgaGF2ZSBkZXRlcm1pbmlzdGljIHByb3BlcnR5IG9yZGVyIChWOCBidWcpXG5tb2R1bGUuZXhwb3J0cyA9ICEkYXNzaWduIHx8IHJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24oKXtcbiAgdmFyIEEgPSB7fVxuICAgICwgQiA9IHt9XG4gICAgLCBTID0gU3ltYm9sKClcbiAgICAsIEsgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW1NdID0gNztcbiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbihrKXsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKXsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICB2YXIgVCAgICAgPSB0b09iamVjdCh0YXJnZXQpXG4gICAgLCBhTGVuICA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGluZGV4ID0gMVxuICAgICwgZ2V0U3ltYm9scyA9IGdPUFMuZlxuICAgICwgaXNFbnVtICAgICA9IHBJRS5mO1xuICB3aGlsZShhTGVuID4gaW5kZXgpe1xuICAgIHZhciBTICAgICAgPSBJT2JqZWN0KGFyZ3VtZW50c1tpbmRleCsrXSlcbiAgICAgICwga2V5cyAgID0gZ2V0U3ltYm9scyA/IGdldEtleXMoUykuY29uY2F0KGdldFN5bWJvbHMoUykpIDogZ2V0S2V5cyhTKVxuICAgICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICAgLCBqICAgICAgPSAwXG4gICAgICAsIGtleTtcbiAgICB3aGlsZShsZW5ndGggPiBqKWlmKGlzRW51bS5jYWxsKFMsIGtleSA9IGtleXNbaisrXSkpVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247IiwiLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pXG52YXIgYW5PYmplY3QgICAgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKVxuICAsIGRQcyAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwcycpXG4gICwgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJylcbiAgLCBJRV9QUk9UTyAgICA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKVxuICAsIEVtcHR5ICAgICAgID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfVxuICAsIFBST1RPVFlQRSAgID0gJ3Byb3RvdHlwZSc7XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24oKXtcbiAgLy8gVGhyYXNoLCB3YXN0ZSBhbmQgc29kb215OiBJRSBHQyBidWdcbiAgdmFyIGlmcmFtZSA9IHJlcXVpcmUoJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJylcbiAgICAsIGkgICAgICA9IGVudW1CdWdLZXlzLmxlbmd0aFxuICAgICwgbHQgICAgID0gJzwnXG4gICAgLCBndCAgICAgPSAnPidcbiAgICAsIGlmcmFtZURvY3VtZW50O1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgcmVxdWlyZSgnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDonOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNjcmlwdC11cmxcbiAgLy8gY3JlYXRlRGljdCA9IGlmcmFtZS5jb250ZW50V2luZG93Lk9iamVjdDtcbiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgY3JlYXRlRGljdCA9IGlmcmFtZURvY3VtZW50LkY7XG4gIHdoaWxlKGktLSlkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcyl7XG4gIHZhciByZXN1bHQ7XG4gIGlmKE8gIT09IG51bGwpe1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZFBzKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ICAgICAgID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBJRThfRE9NX0RFRklORSA9IHJlcXVpcmUoJy4vX2llOC1kb20tZGVmaW5lJylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZFAgICAgICAgICAgICAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmKElFOF9ET01fREVGSU5FKXRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoKGUpeyAvKiBlbXB0eSAqLyB9XG4gIGlmKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcyl0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkIScpO1xuICBpZigndmFsdWUnIGluIEF0dHJpYnV0ZXMpT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTsiLCJ2YXIgZFAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKVxuICAsIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0JylcbiAgLCBnZXRLZXlzICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKXtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzICAgPSBnZXRLZXlzKFByb3BlcnRpZXMpXG4gICAgLCBsZW5ndGggPSBrZXlzLmxlbmd0aFxuICAgICwgaSA9IDBcbiAgICAsIFA7XG4gIHdoaWxlKGxlbmd0aCA+IGkpZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59OyIsInZhciBwSUUgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKVxuICAsIGNyZWF0ZURlc2MgICAgID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpXG4gICwgdG9JT2JqZWN0ICAgICAgPSByZXF1aXJlKCcuL190by1pb2JqZWN0JylcbiAgLCB0b1ByaW1pdGl2ZSAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgaGFzICAgICAgICAgICAgPSByZXF1aXJlKCcuL19oYXMnKVxuICAsIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKVxuICAsIGdPUEQgICAgICAgICAgID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCl7XG4gIE8gPSB0b0lPYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgaWYoSUU4X0RPTV9ERUZJTkUpdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaChlKXsgLyogZW1wdHkgKi8gfVxuICBpZihoYXMoTywgUCkpcmV0dXJuIGNyZWF0ZURlc2MoIXBJRS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTsiLCIvLyAxOS4xLjIuNyAvIDE1LjIuMy40IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG52YXIgJGtleXMgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJylcbiAgLCBoaWRkZW5LZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pe1xuICByZXR1cm4gJGtleXMoTywgaGlkZGVuS2V5cyk7XG59OyIsImV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7IiwidmFyIGhhcyAgICAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgdG9JT2JqZWN0ICAgID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpXG4gICwgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSlcbiAgLCBJRV9QUk9UTyAgICAgPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqZWN0LCBuYW1lcyl7XG4gIHZhciBPICAgICAgPSB0b0lPYmplY3Qob2JqZWN0KVxuICAgICwgaSAgICAgID0gMFxuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGtleTtcbiAgZm9yKGtleSBpbiBPKWlmKGtleSAhPSBJRV9QUk9UTyloYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlKG5hbWVzLmxlbmd0aCA+IGkpaWYoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKXtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59OyIsIi8vIDE5LjEuMi4xNCAvIDE1LjIuMy4xNCBPYmplY3Qua2V5cyhPKVxudmFyICRrZXlzICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwnKVxuICAsIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTyl7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59OyIsImV4cG9ydHMuZiA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlOyIsIi8vIG1vc3QgT2JqZWN0IG1ldGhvZHMgYnkgRVM2IHNob3VsZCBhY2NlcHQgcHJpbWl0aXZlc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsIGNvcmUgICAgPSByZXF1aXJlKCcuL19jb3JlJylcbiAgLCBmYWlscyAgID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oS0VZLCBleGVjKXtcbiAgdmFyIGZuICA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXVxuICAgICwgZXhwID0ge307XG4gIGV4cFtLRVldID0gZXhlYyhmbik7XG4gICRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogZmFpbHMoZnVuY3Rpb24oKXsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiaXRtYXAsIHZhbHVlKXtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlICA6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlICAgIDogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZSAgICAgICA6IHZhbHVlXG4gIH07XG59OyIsInZhciBnbG9iYWwgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhpZGUgICAgICA9IHJlcXVpcmUoJy4vX2hpZGUnKVxuICAsIGhhcyAgICAgICA9IHJlcXVpcmUoJy4vX2hhcycpXG4gICwgU1JDICAgICAgID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpXG4gICwgVE9fU1RSSU5HID0gJ3RvU3RyaW5nJ1xuICAsICR0b1N0cmluZyA9IEZ1bmN0aW9uW1RPX1NUUklOR11cbiAgLCBUUEwgICAgICAgPSAoJycgKyAkdG9TdHJpbmcpLnNwbGl0KFRPX1NUUklORyk7XG5cbnJlcXVpcmUoJy4vX2NvcmUnKS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTywga2V5LCB2YWwsIHNhZmUpe1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiB2YWwgPT0gJ2Z1bmN0aW9uJztcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCAnbmFtZScpIHx8IGhpZGUodmFsLCAnbmFtZScsIGtleSk7XG4gIGlmKE9ba2V5XSA9PT0gdmFsKXJldHVybjtcbiAgaWYoaXNGdW5jdGlvbiloYXModmFsLCBTUkMpIHx8IGhpZGUodmFsLCBTUkMsIE9ba2V5XSA/ICcnICsgT1trZXldIDogVFBMLmpvaW4oU3RyaW5nKGtleSkpKTtcbiAgaWYoTyA9PT0gZ2xvYmFsKXtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaWYoIXNhZmUpe1xuICAgICAgZGVsZXRlIE9ba2V5XTtcbiAgICAgIGhpZGUoTywga2V5LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZihPW2tleV0pT1trZXldID0gdmFsO1xuICAgICAgZWxzZSBoaWRlKE8sIGtleSwgdmFsKTtcbiAgICB9XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCl7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIHRoaXNbU1JDXSB8fCAkdG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pOyIsIi8vIFdvcmtzIHdpdGggX19wcm90b19fIG9ubHkuIE9sZCB2OCBjYW4ndCB3b3JrIHdpdGggbnVsbCBwcm90byBvYmplY3RzLlxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpXG4gICwgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBjaGVjayA9IGZ1bmN0aW9uKE8sIHByb3RvKXtcbiAgYW5PYmplY3QoTyk7XG4gIGlmKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24odGVzdCwgYnVnZ3ksIHNldCl7XG4gICAgICB0cnkge1xuICAgICAgICBzZXQgPSByZXF1aXJlKCcuL19jdHgnKShGdW5jdGlvbi5jYWxsLCByZXF1aXJlKCcuL19vYmplY3QtZ29wZCcpLmYoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldCwgMik7XG4gICAgICAgIHNldCh0ZXN0LCBbXSk7XG4gICAgICAgIGJ1Z2d5ID0gISh0ZXN0IGluc3RhbmNlb2YgQXJyYXkpO1xuICAgICAgfSBjYXRjaChlKXsgYnVnZ3kgPSB0cnVlOyB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pe1xuICAgICAgICBjaGVjayhPLCBwcm90byk7XG4gICAgICAgIGlmKGJ1Z2d5KU8uX19wcm90b19fID0gcHJvdG87XG4gICAgICAgIGVsc2Ugc2V0KE8sIHByb3RvKTtcbiAgICAgICAgcmV0dXJuIE87XG4gICAgICB9O1xuICAgIH0oe30sIGZhbHNlKSA6IHVuZGVmaW5lZCksXG4gIGNoZWNrOiBjaGVja1xufTsiLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKVxuICAsIHVpZCAgICA9IHJlcXVpcmUoJy4vX3VpZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXkpe1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTsiLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJylcbiAgLCBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJ1xuICAsIHN0b3JlICA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5KXtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7XG59OyIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWV0aG9kLCBhcmcpe1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24oKXtcbiAgICBhcmcgPyBtZXRob2QuY2FsbChudWxsLCBmdW5jdGlvbigpe30sIDEpIDogbWV0aG9kLmNhbGwobnVsbCk7XG4gIH0pO1xufTsiLCJ2YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKVxuICAsIGZhaWxzICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgc3BhY2VzICA9IHJlcXVpcmUoJy4vX3N0cmluZy13cycpXG4gICwgc3BhY2UgICA9ICdbJyArIHNwYWNlcyArICddJ1xuICAsIG5vbiAgICAgPSAnXFx1MjAwYlxcdTAwODUnXG4gICwgbHRyaW0gICA9IFJlZ0V4cCgnXicgKyBzcGFjZSArIHNwYWNlICsgJyonKVxuICAsIHJ0cmltICAgPSBSZWdFeHAoc3BhY2UgKyBzcGFjZSArICcqJCcpO1xuXG52YXIgZXhwb3J0ZXIgPSBmdW5jdGlvbihLRVksIGV4ZWMsIEFMSUFTKXtcbiAgdmFyIGV4cCAgID0ge307XG4gIHZhciBGT1JDRSA9IGZhaWxzKGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICEhc3BhY2VzW0tFWV0oKSB8fCBub25bS0VZXSgpICE9IG5vbjtcbiAgfSk7XG4gIHZhciBmbiA9IGV4cFtLRVldID0gRk9SQ0UgPyBleGVjKHRyaW0pIDogc3BhY2VzW0tFWV07XG4gIGlmKEFMSUFTKWV4cFtBTElBU10gPSBmbjtcbiAgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiBGT1JDRSwgJ1N0cmluZycsIGV4cCk7XG59O1xuXG4vLyAxIC0+IFN0cmluZyN0cmltTGVmdFxuLy8gMiAtPiBTdHJpbmcjdHJpbVJpZ2h0XG4vLyAzIC0+IFN0cmluZyN0cmltXG52YXIgdHJpbSA9IGV4cG9ydGVyLnRyaW0gPSBmdW5jdGlvbihzdHJpbmcsIFRZUEUpe1xuICBzdHJpbmcgPSBTdHJpbmcoZGVmaW5lZChzdHJpbmcpKTtcbiAgaWYoVFlQRSAmIDEpc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgaWYoVFlQRSAmIDIpc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocnRyaW0sICcnKTtcbiAgcmV0dXJuIHN0cmluZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZXI7IiwibW9kdWxlLmV4cG9ydHMgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgJ1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnOyIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJylcbiAgLCBtYXggICAgICAgPSBNYXRoLm1heFxuICAsIG1pbiAgICAgICA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpbmRleCwgbGVuZ3RoKXtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07IiwiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCAgPSBNYXRoLmNlaWxcbiAgLCBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGlzTmFOKGl0ID0gK2l0KSA/IDAgOiAoaXQgPiAwID8gZmxvb3IgOiBjZWlsKShpdCk7XG59OyIsIi8vIHRvIGluZGV4ZWQgb2JqZWN0LCB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0JylcbiAgLCBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpdCl7XG4gIHJldHVybiBJT2JqZWN0KGRlZmluZWQoaXQpKTtcbn07IiwiLy8gNy4xLjE1IFRvTGVuZ3RoXG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpXG4gICwgbWluICAgICAgID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIGl0ID4gMCA/IG1pbih0b0ludGVnZXIoaXQpLCAweDFmZmZmZmZmZmZmZmZmKSA6IDA7IC8vIHBvdygyLCA1MykgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07IiwiLy8gNy4xLjEzIFRvT2JqZWN0KGFyZ3VtZW50KVxudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59OyIsIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQsIFMpe1xuICBpZighaXNPYmplY3QoaXQpKXJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmKFMgJiYgdHlwZW9mIChmbiA9IGl0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpcmV0dXJuIHZhbDtcbiAgaWYodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICBpZighUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSlyZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59OyIsInZhciBpZCA9IDBcbiAgLCBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSl7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59OyIsInZhciBzdG9yZSAgICAgID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpXG4gICwgdWlkICAgICAgICA9IHJlcXVpcmUoJy4vX3VpZCcpXG4gICwgU3ltYm9sICAgICA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbFxuICAsIFVTRV9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbic7XG5cbnZhciAkZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obmFtZSl7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlOyIsIid1c2Ugc3RyaWN0JztcbnZhciAkZXhwb3J0ICA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpXG4gICwgJGZvckVhY2ggPSByZXF1aXJlKCcuL19hcnJheS1tZXRob2RzJykoMClcbiAgLCBTVFJJQ1QgICA9IHJlcXVpcmUoJy4vX3N0cmljdC1tZXRob2QnKShbXS5mb3JFYWNoLCB0cnVlKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhU1RSSUNULCAnQXJyYXknLCB7XG4gIC8vIDIyLjEuMy4xMCAvIDE1LjQuNC4xOCBBcnJheS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuIFssIHRoaXNBcmddKVxuICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKXtcbiAgICByZXR1cm4gJGZvckVhY2godGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzWzFdKTtcbiAgfVxufSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKVxuICAsICRyZWR1Y2UgPSByZXF1aXJlKCcuL19hcnJheS1yZWR1Y2UnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fc3RyaWN0LW1ldGhvZCcpKFtdLnJlZHVjZSwgdHJ1ZSksICdBcnJheScsIHtcbiAgLy8gMjIuMS4zLjE4IC8gMTUuNC40LjIxIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UoY2FsbGJhY2tmbiBbLCBpbml0aWFsVmFsdWVdKVxuICByZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZShjYWxsYmFja2ZuIC8qICwgaW5pdGlhbFZhbHVlICovKXtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHNbMV0sIGZhbHNlKTtcbiAgfVxufSk7IiwiLy8gMTkuMi4zLjIgLyAxNS4zLjQuNSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCh0aGlzQXJnLCBhcmdzLi4uKVxudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcblxuJGV4cG9ydCgkZXhwb3J0LlAsICdGdW5jdGlvbicsIHtiaW5kOiByZXF1aXJlKCcuL19iaW5kJyl9KTsiLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsICAgICAgICAgICAgPSByZXF1aXJlKCcuL19nbG9iYWwnKVxuICAsIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9faGFzJylcbiAgLCBjb2YgICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX2NvZicpXG4gICwgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuL19pbmhlcml0LWlmLXJlcXVpcmVkJylcbiAgLCB0b1ByaW1pdGl2ZSAgICAgICA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpXG4gICwgZmFpbHMgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19mYWlscycpXG4gICwgZ09QTiAgICAgICAgICAgICAgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmZcbiAgLCBnT1BEICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZlxuICAsIGRQICAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZlxuICAsICR0cmltICAgICAgICAgICAgID0gcmVxdWlyZSgnLi9fc3RyaW5nLXRyaW0nKS50cmltXG4gICwgTlVNQkVSICAgICAgICAgICAgPSAnTnVtYmVyJ1xuICAsICROdW1iZXIgICAgICAgICAgID0gZ2xvYmFsW05VTUJFUl1cbiAgLCBCYXNlICAgICAgICAgICAgICA9ICROdW1iZXJcbiAgLCBwcm90byAgICAgICAgICAgICA9ICROdW1iZXIucHJvdG90eXBlXG4gIC8vIE9wZXJhIH4xMiBoYXMgYnJva2VuIE9iamVjdCN0b1N0cmluZ1xuICAsIEJST0tFTl9DT0YgICAgICAgID0gY29mKHJlcXVpcmUoJy4vX29iamVjdC1jcmVhdGUnKShwcm90bykpID09IE5VTUJFUlxuICAsIFRSSU0gICAgICAgICAgICAgID0gJ3RyaW0nIGluIFN0cmluZy5wcm90b3R5cGU7XG5cbi8vIDcuMS4zIFRvTnVtYmVyKGFyZ3VtZW50KVxudmFyIHRvTnVtYmVyID0gZnVuY3Rpb24oYXJndW1lbnQpe1xuICB2YXIgaXQgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgZmFsc2UpO1xuICBpZih0eXBlb2YgaXQgPT0gJ3N0cmluZycgJiYgaXQubGVuZ3RoID4gMil7XG4gICAgaXQgPSBUUklNID8gaXQudHJpbSgpIDogJHRyaW0oaXQsIDMpO1xuICAgIHZhciBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMClcbiAgICAgICwgdGhpcmQsIHJhZGl4LCBtYXhDb2RlO1xuICAgIGlmKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpe1xuICAgICAgdGhpcmQgPSBpdC5jaGFyQ29kZUF0KDIpO1xuICAgICAgaWYodGhpcmQgPT09IDg4IHx8IHRoaXJkID09PSAxMjApcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZihmaXJzdCA9PT0gNDgpe1xuICAgICAgc3dpdGNoKGl0LmNoYXJDb2RlQXQoMSkpe1xuICAgICAgICBjYXNlIDY2IDogY2FzZSA5OCAgOiByYWRpeCA9IDI7IG1heENvZGUgPSA0OTsgYnJlYWs7IC8vIGZhc3QgZXF1YWwgL14wYlswMV0rJC9pXG4gICAgICAgIGNhc2UgNzkgOiBjYXNlIDExMSA6IHJhZGl4ID0gODsgbWF4Q29kZSA9IDU1OyBicmVhazsgLy8gZmFzdCBlcXVhbCAvXjBvWzAtN10rJC9pXG4gICAgICAgIGRlZmF1bHQgOiByZXR1cm4gK2l0O1xuICAgICAgfVxuICAgICAgZm9yKHZhciBkaWdpdHMgPSBpdC5zbGljZSgyKSwgaSA9IDAsIGwgPSBkaWdpdHMubGVuZ3RoLCBjb2RlOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgY29kZSA9IGRpZ2l0cy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYoY29kZSA8IDQ4IHx8IGNvZGUgPiBtYXhDb2RlKXJldHVybiBOYU47XG4gICAgICB9IHJldHVybiBwYXJzZUludChkaWdpdHMsIHJhZGl4KTtcbiAgICB9XG4gIH0gcmV0dXJuICtpdDtcbn07XG5cbmlmKCEkTnVtYmVyKCcgMG8xJykgfHwgISROdW1iZXIoJzBiMScpIHx8ICROdW1iZXIoJysweDEnKSl7XG4gICROdW1iZXIgPSBmdW5jdGlvbiBOdW1iZXIodmFsdWUpe1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlXG4gICAgICAsIHRoYXQgPSB0aGlzO1xuICAgIHJldHVybiB0aGF0IGluc3RhbmNlb2YgJE51bWJlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NPRiA/IGZhaWxzKGZ1bmN0aW9uKCl7IHByb3RvLnZhbHVlT2YuY2FsbCh0aGF0KTsgfSkgOiBjb2YodGhhdCkgIT0gTlVNQkVSKVxuICAgICAgICA/IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBCYXNlKHRvTnVtYmVyKGl0KSksIHRoYXQsICROdW1iZXIpIDogdG9OdW1iZXIoaXQpO1xuICB9O1xuICBmb3IodmFyIGtleXMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZ09QTihCYXNlKSA6IChcbiAgICAvLyBFUzM6XG4gICAgJ01BWF9WQUxVRSxNSU5fVkFMVUUsTmFOLE5FR0FUSVZFX0lORklOSVRZLFBPU0lUSVZFX0lORklOSVRZLCcgK1xuICAgIC8vIEVTNiAoaW4gY2FzZSwgaWYgbW9kdWxlcyB3aXRoIEVTNiBOdW1iZXIgc3RhdGljcyByZXF1aXJlZCBiZWZvcmUpOlxuICAgICdFUFNJTE9OLGlzRmluaXRlLGlzSW50ZWdlcixpc05hTixpc1NhZmVJbnRlZ2VyLE1BWF9TQUZFX0lOVEVHRVIsJyArXG4gICAgJ01JTl9TQUZFX0lOVEVHRVIscGFyc2VGbG9hdCxwYXJzZUludCxpc0ludGVnZXInXG4gICkuc3BsaXQoJywnKSwgaiA9IDAsIGtleTsga2V5cy5sZW5ndGggPiBqOyBqKyspe1xuICAgIGlmKGhhcyhCYXNlLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKCROdW1iZXIsIGtleSkpe1xuICAgICAgZFAoJE51bWJlciwga2V5LCBnT1BEKEJhc2UsIGtleSkpO1xuICAgIH1cbiAgfVxuICAkTnVtYmVyLnByb3RvdHlwZSA9IHByb3RvO1xuICBwcm90by5jb25zdHJ1Y3RvciA9ICROdW1iZXI7XG4gIHJlcXVpcmUoJy4vX3JlZGVmaW5lJykoZ2xvYmFsLCBOVU1CRVIsICROdW1iZXIpO1xufSIsIi8vIDE5LjEuMy4xIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBzb3VyY2UpXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiwgJ09iamVjdCcsIHthc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKX0pOyIsInZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG4vLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSwgJ09iamVjdCcsIHtkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZn0pOyIsIi8vIDE5LjEuMi4xNCBPYmplY3Qua2V5cyhPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0JylcbiAgLCAka2V5cyAgICA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG5cbnJlcXVpcmUoJy4vX29iamVjdC1zYXAnKSgna2V5cycsIGZ1bmN0aW9uKCl7XG4gIHJldHVybiBmdW5jdGlvbiBrZXlzKGl0KXtcbiAgICByZXR1cm4gJGtleXModG9PYmplY3QoaXQpKTtcbiAgfTtcbn0pOyIsIi8qISBsb2FkQ1NTLiBbY10yMDE3IEZpbGFtZW50IEdyb3VwLCBJbmMuIE1JVCBMaWNlbnNlICovXG4oZnVuY3Rpb24odyl7XG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKiBleHBvcnRlZCBsb2FkQ1NTICovXG5cdHZhciBsb2FkQ1NTID0gZnVuY3Rpb24oIGhyZWYsIGJlZm9yZSwgbWVkaWEgKXtcblx0XHQvLyBBcmd1bWVudHMgZXhwbGFpbmVkOlxuXHRcdC8vIGBocmVmYCBbUkVRVUlSRURdIGlzIHRoZSBVUkwgZm9yIHlvdXIgQ1NTIGZpbGUuXG5cdFx0Ly8gYGJlZm9yZWAgW09QVElPTkFMXSBpcyB0aGUgZWxlbWVudCB0aGUgc2NyaXB0IHNob3VsZCB1c2UgYXMgYSByZWZlcmVuY2UgZm9yIGluamVjdGluZyBvdXIgc3R5bGVzaGVldCA8bGluaz4gYmVmb3JlXG5cdFx0XHQvLyBCeSBkZWZhdWx0LCBsb2FkQ1NTIGF0dGVtcHRzIHRvIGluamVjdCB0aGUgbGluayBhZnRlciB0aGUgbGFzdCBzdHlsZXNoZWV0IG9yIHNjcmlwdCBpbiB0aGUgRE9NLiBIb3dldmVyLCB5b3UgbWlnaHQgZGVzaXJlIGEgbW9yZSBzcGVjaWZpYyBsb2NhdGlvbiBpbiB5b3VyIGRvY3VtZW50LlxuXHRcdC8vIGBtZWRpYWAgW09QVElPTkFMXSBpcyB0aGUgbWVkaWEgdHlwZSBvciBxdWVyeSBvZiB0aGUgc3R5bGVzaGVldC4gQnkgZGVmYXVsdCBpdCB3aWxsIGJlICdhbGwnXG5cdFx0dmFyIGRvYyA9IHcuZG9jdW1lbnQ7XG5cdFx0dmFyIHNzID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwibGlua1wiICk7XG5cdFx0dmFyIHJlZjtcblx0XHRpZiggYmVmb3JlICl7XG5cdFx0XHRyZWYgPSBiZWZvcmU7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dmFyIHJlZnMgPSAoIGRvYy5ib2R5IHx8IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJoZWFkXCIgKVsgMCBdICkuY2hpbGROb2Rlcztcblx0XHRcdHJlZiA9IHJlZnNbIHJlZnMubGVuZ3RoIC0gMV07XG5cdFx0fVxuXG5cdFx0dmFyIHNoZWV0cyA9IGRvYy5zdHlsZVNoZWV0cztcblx0XHRzcy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblx0XHRzcy5ocmVmID0gaHJlZjtcblx0XHQvLyB0ZW1wb3JhcmlseSBzZXQgbWVkaWEgdG8gc29tZXRoaW5nIGluYXBwbGljYWJsZSB0byBlbnN1cmUgaXQnbGwgZmV0Y2ggd2l0aG91dCBibG9ja2luZyByZW5kZXJcblx0XHRzcy5tZWRpYSA9IFwib25seSB4XCI7XG5cblx0XHQvLyB3YWl0IHVudGlsIGJvZHkgaXMgZGVmaW5lZCBiZWZvcmUgaW5qZWN0aW5nIGxpbmsuIFRoaXMgZW5zdXJlcyBhIG5vbi1ibG9ja2luZyBsb2FkIGluIElFMTEuXG5cdFx0ZnVuY3Rpb24gcmVhZHkoIGNiICl7XG5cdFx0XHRpZiggZG9jLmJvZHkgKXtcblx0XHRcdFx0cmV0dXJuIGNiKCk7XG5cdFx0XHR9XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHJlYWR5KCBjYiApO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdC8vIEluamVjdCBsaW5rXG5cdFx0XHQvLyBOb3RlOiB0aGUgdGVybmFyeSBwcmVzZXJ2ZXMgdGhlIGV4aXN0aW5nIGJlaGF2aW9yIG9mIFwiYmVmb3JlXCIgYXJndW1lbnQsIGJ1dCB3ZSBjb3VsZCBjaG9vc2UgdG8gY2hhbmdlIHRoZSBhcmd1bWVudCB0byBcImFmdGVyXCIgaW4gYSBsYXRlciByZWxlYXNlIGFuZCBzdGFuZGFyZGl6ZSBvbiByZWYubmV4dFNpYmxpbmcgZm9yIGFsbCByZWZzXG5cdFx0XHQvLyBOb3RlOiBgaW5zZXJ0QmVmb3JlYCBpcyB1c2VkIGluc3RlYWQgb2YgYGFwcGVuZENoaWxkYCwgZm9yIHNhZmV0eSByZTogaHR0cDovL3d3dy5wYXVsaXJpc2guY29tLzIwMTEvc3VyZWZpcmUtZG9tLWVsZW1lbnQtaW5zZXJ0aW9uL1xuXHRcdHJlYWR5KCBmdW5jdGlvbigpe1xuXHRcdFx0cmVmLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBzcywgKCBiZWZvcmUgPyByZWYgOiByZWYubmV4dFNpYmxpbmcgKSApO1xuXHRcdH0pO1xuXHRcdC8vIEEgbWV0aG9kIChleHBvc2VkIG9uIHJldHVybiBvYmplY3QgZm9yIGV4dGVybmFsIHVzZSkgdGhhdCBtaW1pY3Mgb25sb2FkIGJ5IHBvbGxpbmcgZG9jdW1lbnQuc3R5bGVTaGVldHMgdW50aWwgaXQgaW5jbHVkZXMgdGhlIG5ldyBzaGVldC5cblx0XHR2YXIgb25sb2FkY3NzZGVmaW5lZCA9IGZ1bmN0aW9uKCBjYiApe1xuXHRcdFx0dmFyIHJlc29sdmVkSHJlZiA9IHNzLmhyZWY7XG5cdFx0XHR2YXIgaSA9IHNoZWV0cy5sZW5ndGg7XG5cdFx0XHR3aGlsZSggaS0tICl7XG5cdFx0XHRcdGlmKCBzaGVldHNbIGkgXS5ocmVmID09PSByZXNvbHZlZEhyZWYgKXtcblx0XHRcdFx0XHRyZXR1cm4gY2IoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0b25sb2FkY3NzZGVmaW5lZCggY2IgKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBsb2FkQ0IoKXtcblx0XHRcdGlmKCBzcy5hZGRFdmVudExpc3RlbmVyICl7XG5cdFx0XHRcdHNzLnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBsb2FkQ0IgKTtcblx0XHRcdH1cblx0XHRcdHNzLm1lZGlhID0gbWVkaWEgfHwgXCJhbGxcIjtcblx0XHR9XG5cblx0XHQvLyBvbmNlIGxvYWRlZCwgc2V0IGxpbmsncyBtZWRpYSBiYWNrIHRvIGBhbGxgIHNvIHRoYXQgdGhlIHN0eWxlc2hlZXQgYXBwbGllcyBvbmNlIGl0IGxvYWRzXG5cdFx0aWYoIHNzLmFkZEV2ZW50TGlzdGVuZXIgKXtcblx0XHRcdHNzLmFkZEV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBsb2FkQ0IpO1xuXHRcdH1cblx0XHRzcy5vbmxvYWRjc3NkZWZpbmVkID0gb25sb2FkY3NzZGVmaW5lZDtcblx0XHRvbmxvYWRjc3NkZWZpbmVkKCBsb2FkQ0IgKTtcblx0XHRyZXR1cm4gc3M7XG5cdH07XG5cdC8vIGNvbW1vbmpzXG5cdGlmKCB0eXBlb2YgZXhwb3J0cyAhPT0gXCJ1bmRlZmluZWRcIiApe1xuXHRcdGV4cG9ydHMubG9hZENTUyA9IGxvYWRDU1M7XG5cdH1cblx0ZWxzZSB7XG5cdFx0dy5sb2FkQ1NTID0gbG9hZENTUztcblx0fVxufSggdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHRoaXMgKSk7XG4iLCIvKiBlc2xpbnQgbm8tY29uc29sZTowICovXG4vKipcbiAqIFRoaXMgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIEthVGVYLiBIZXJlLCB3ZSBleHBvc2UgZnVuY3Rpb25zIGZvclxuICogcmVuZGVyaW5nIGV4cHJlc3Npb25zIGVpdGhlciB0byBET00gbm9kZXMgb3IgdG8gbWFya3VwIHN0cmluZ3MuXG4gKlxuICogV2UgYWxzbyBleHBvc2UgdGhlIFBhcnNlRXJyb3IgY2xhc3MgdG8gY2hlY2sgaWYgZXJyb3JzIHRocm93biBmcm9tIEthVGVYIGFyZVxuICogZXJyb3JzIGluIHRoZSBleHByZXNzaW9uLCBvciBlcnJvcnMgaW4gamF2YXNjcmlwdCBoYW5kbGluZy5cbiAqL1xuXG52YXIgUGFyc2VFcnJvciA9IHJlcXVpcmUoXCIuL3NyYy9QYXJzZUVycm9yXCIpO1xudmFyIFNldHRpbmdzID0gcmVxdWlyZShcIi4vc3JjL1NldHRpbmdzXCIpO1xuXG52YXIgYnVpbGRUcmVlID0gcmVxdWlyZShcIi4vc3JjL2J1aWxkVHJlZVwiKTtcbnZhciBwYXJzZVRyZWUgPSByZXF1aXJlKFwiLi9zcmMvcGFyc2VUcmVlXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vc3JjL3V0aWxzXCIpO1xuXG4vKipcbiAqIFBhcnNlIGFuZCBidWlsZCBhbiBleHByZXNzaW9uLCBhbmQgcGxhY2UgdGhhdCBleHByZXNzaW9uIGluIHRoZSBET00gbm9kZVxuICogZ2l2ZW4uXG4gKi9cbnZhciByZW5kZXIgPSBmdW5jdGlvbihleHByZXNzaW9uLCBiYXNlTm9kZSwgb3B0aW9ucykge1xuICAgIHV0aWxzLmNsZWFyTm9kZShiYXNlTm9kZSk7XG5cbiAgICB2YXIgc2V0dGluZ3MgPSBuZXcgU2V0dGluZ3Mob3B0aW9ucyk7XG5cbiAgICB2YXIgdHJlZSA9IHBhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7XG4gICAgdmFyIG5vZGUgPSBidWlsZFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpLnRvTm9kZSgpO1xuXG4gICAgYmFzZU5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG59O1xuXG4vLyBLYVRlWCdzIHN0eWxlcyBkb24ndCB3b3JrIHByb3Blcmx5IGluIHF1aXJrcyBtb2RlLiBQcmludCBvdXQgYW4gZXJyb3IsIGFuZFxuLy8gZGlzYWJsZSByZW5kZXJpbmcuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKGRvY3VtZW50LmNvbXBhdE1vZGUgIT09IFwiQ1NTMUNvbXBhdFwiKSB7XG4gICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiV2FybmluZzogS2FUZVggZG9lc24ndCB3b3JrIGluIHF1aXJrcyBtb2RlLiBNYWtlIHN1cmUgeW91ciBcIiArXG4gICAgICAgICAgICAgICAgXCJ3ZWJzaXRlIGhhcyBhIHN1aXRhYmxlIGRvY3R5cGUuXCIpO1xuXG4gICAgICAgIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJLYVRlWCBkb2Vzbid0IHdvcmsgaW4gcXVpcmtzIG1vZGUuXCIpO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbmQgYnVpbGQgYW4gZXhwcmVzc2lvbiwgYW5kIHJldHVybiB0aGUgbWFya3VwIGZvciB0aGF0LlxuICovXG52YXIgcmVuZGVyVG9TdHJpbmcgPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zKSB7XG4gICAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpO1xuXG4gICAgdmFyIHRyZWUgPSBwYXJzZVRyZWUoZXhwcmVzc2lvbiwgc2V0dGluZ3MpO1xuICAgIHJldHVybiBidWlsZFRyZWUodHJlZSwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpLnRvTWFya3VwKCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIGFuIGV4cHJlc3Npb24gYW5kIHJldHVybiB0aGUgcGFyc2UgdHJlZS5cbiAqL1xudmFyIGdlbmVyYXRlUGFyc2VUcmVlID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhvcHRpb25zKTtcbiAgICByZXR1cm4gcGFyc2VUcmVlKGV4cHJlc3Npb24sIHNldHRpbmdzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlbmRlcjogcmVuZGVyLFxuICAgIHJlbmRlclRvU3RyaW5nOiByZW5kZXJUb1N0cmluZyxcbiAgICAvKipcbiAgICAgKiBOT1RFOiBUaGlzIG1ldGhvZCBpcyBub3QgY3VycmVudGx5IHJlY29tbWVuZGVkIGZvciBwdWJsaWMgdXNlLlxuICAgICAqIFRoZSBpbnRlcm5hbCB0cmVlIHJlcHJlc2VudGF0aW9uIGlzIHVuc3RhYmxlIGFuZCBpcyB2ZXJ5IGxpa2VseVxuICAgICAqIHRvIGNoYW5nZS4gVXNlIGF0IHlvdXIgb3duIHJpc2suXG4gICAgICovXG4gICAgX19wYXJzZTogZ2VuZXJhdGVQYXJzZVRyZWUsXG4gICAgUGFyc2VFcnJvcjogUGFyc2VFcnJvclxufTtcbiIsIi8qKlxuICogVGhlIExleGVyIGNsYXNzIGhhbmRsZXMgdG9rZW5pemluZyB0aGUgaW5wdXQgaW4gdmFyaW91cyB3YXlzLiBTaW5jZSBvdXJcbiAqIHBhcnNlciBleHBlY3RzIHVzIHRvIGJlIGFibGUgdG8gYmFja3RyYWNrLCB0aGUgbGV4ZXIgYWxsb3dzIGxleGluZyBmcm9tIGFueVxuICogZ2l2ZW4gc3RhcnRpbmcgcG9pbnQuXG4gKlxuICogSXRzIG1haW4gZXhwb3NlZCBmdW5jdGlvbiBpcyB0aGUgYGxleGAgZnVuY3Rpb24sIHdoaWNoIHRha2VzIGEgcG9zaXRpb24gdG9cbiAqIGxleCBmcm9tIGFuZCBhIHR5cGUgb2YgdG9rZW4gdG8gbGV4LiBJdCBkZWZlcnMgdG8gdGhlIGFwcHJvcHJpYXRlIGBfaW5uZXJMZXhgXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgdmFyaW91cyBgX2lubmVyTGV4YCBmdW5jdGlvbnMgcGVyZm9ybSB0aGUgYWN0dWFsIGxleGluZyBvZiBkaWZmZXJlbnRcbiAqIGtpbmRzLlxuICovXG5cbnZhciBtYXRjaEF0ID0gcmVxdWlyZShcIm1hdGNoLWF0XCIpO1xuXG52YXIgUGFyc2VFcnJvciA9IHJlcXVpcmUoXCIuL1BhcnNlRXJyb3JcIik7XG5cbi8vIFRoZSBtYWluIGxleGVyIGNsYXNzXG5mdW5jdGlvbiBMZXhlcihpbnB1dCkge1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLnBvcyA9IDA7XG59XG5cbi8qKlxuICogVGhlIHJlc3VsdGluZyB0b2tlbiByZXR1cm5lZCBmcm9tIGBsZXhgLlxuICpcbiAqIEl0IGNvbnNpc3RzIG9mIHRoZSB0b2tlbiB0ZXh0IHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqIFRoZSBwb3NpdGlvbiBpbmZvcm1hdGlvbiBpcyBlc3NlbnRpYWxseSBhIHJhbmdlIGluIGFuIGlucHV0IHN0cmluZyxcbiAqIGJ1dCBpbnN0ZWFkIG9mIHJlZmVyZW5jaW5nIHRoZSBiYXJlIGlucHV0IHN0cmluZywgd2UgcmVmZXIgdG8gdGhlIGxleGVyLlxuICogVGhhdCB3YXkgaXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGV4dHJhIG1ldGFkYXRhIHRvIHRoZSBpbnB1dCBzdHJpbmcsXG4gKiBsaWtlIGZvciBleGFtcGxlIGEgZmlsZSBuYW1lIG9yIHNpbWlsYXIuXG4gKlxuICogVGhlIHBvc2l0aW9uIGluZm9ybWF0aW9uIChhbGwgdGhyZWUgcGFyYW1ldGVycykgaXMgb3B0aW9uYWwsXG4gKiBzbyBpdCBpcyBPSyB0byBjb25zdHJ1Y3Qgc3ludGhldGljIHRva2VucyBpZiBhcHByb3ByaWF0ZS5cbiAqIE5vdCBwcm92aWRpbmcgYXZhaWxhYmxlIHBvc2l0aW9uIGluZm9ybWF0aW9uIG1heSBsZWFkIHRvXG4gKiBkZWdyYWRlZCBlcnJvciByZXBvcnRpbmcsIHRob3VnaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gIHRleHQgICB0aGUgdGV4dCBvZiB0aGlzIHRva2VuXG4gKiBAcGFyYW0ge251bWJlcj19IHN0YXJ0ICB0aGUgc3RhcnQgb2Zmc2V0LCB6ZXJvLWJhc2VkIGluY2x1c2l2ZVxuICogQHBhcmFtIHtudW1iZXI9fSBlbmQgICAgdGhlIGVuZCBvZmZzZXQsIHplcm8tYmFzZWQgZXhjbHVzaXZlXG4gKiBAcGFyYW0ge0xleGVyPX0gIGxleGVyICB0aGUgbGV4ZXIgd2hpY2ggaW4gdHVybiBob2xkcyB0aGUgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIFRva2VuKHRleHQsIHN0YXJ0LCBlbmQsIGxleGVyKSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgdGhpcy5sZXhlciA9IGxleGVyO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgcGFpciBvZiB0b2tlbnMgKHRoaXMgYW5kIGVuZFRva2VuKSwgY29tcHV0ZSBhIOKAnFRva2Vu4oCdIGVuY29tcGFzc2luZ1xuICogdGhlIHdob2xlIGlucHV0IHJhbmdlIGVuY2xvc2VkIGJ5IHRoZXNlIHR3by5cbiAqXG4gKiBAcGFyYW0ge1Rva2VufSAgZW5kVG9rZW4gIGxhc3QgdG9rZW4gb2YgdGhlIHJhbmdlLCBpbmNsdXNpdmVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICAgICAgdGhlIHRleHQgb2YgdGhlIG5ld2x5IGNvbnN0cnVjdGVkIHRva2VuXG4gKi9cblRva2VuLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uKGVuZFRva2VuLCB0ZXh0KSB7XG4gICAgaWYgKGVuZFRva2VuLmxleGVyICE9PSB0aGlzLmxleGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW4odGV4dCk7IC8vIHNvcnJ5LCBubyBwb3NpdGlvbiBpbmZvcm1hdGlvbiBhdmFpbGFibGVcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUb2tlbih0ZXh0LCB0aGlzLnN0YXJ0LCBlbmRUb2tlbi5lbmQsIHRoaXMubGV4ZXIpO1xufTtcblxuLyogVGhlIGZvbGxvd2luZyB0b2tlblJlZ2V4XG4gKiAtIG1hdGNoZXMgdHlwaWNhbCB3aGl0ZXNwYWNlIChidXQgbm90IE5CU1AgZXRjLikgdXNpbmcgaXRzIGZpcnN0IGdyb3VwXG4gKiAtIGRvZXMgbm90IG1hdGNoIGFueSBjb250cm9sIGNoYXJhY3RlciBcXHgwMC1cXHgxZiBleGNlcHQgd2hpdGVzcGFjZVxuICogLSBkb2VzIG5vdCBtYXRjaCBhIGJhcmUgYmFja3NsYXNoXG4gKiAtIG1hdGNoZXMgYW55IEFTQ0lJIGNoYXJhY3RlciBleGNlcHQgdGhvc2UganVzdCBtZW50aW9uZWRcbiAqIC0gZG9lcyBub3QgbWF0Y2ggdGhlIEJNUCBwcml2YXRlIHVzZSBhcmVhIFxcdUUwMDAtXFx1RjhGRlxuICogLSBkb2VzIG5vdCBtYXRjaCBiYXJlIHN1cnJvZ2F0ZSBjb2RlIHVuaXRzXG4gKiAtIG1hdGNoZXMgYW55IEJNUCBjaGFyYWN0ZXIgZXhjZXB0IGZvciB0aG9zZSBqdXN0IGRlc2NyaWJlZFxuICogLSBtYXRjaGVzIGFueSB2YWxpZCBVbmljb2RlIHN1cnJvZ2F0ZSBwYWlyXG4gKiAtIG1hdGNoZXMgYSBiYWNrc2xhc2ggZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgbGV0dGVyc1xuICogLSBtYXRjaGVzIGEgYmFja3NsYXNoIGZvbGxvd2VkIGJ5IGFueSBCTVAgY2hhcmFjdGVyLCBpbmNsdWRpbmcgbmV3bGluZVxuICogSnVzdCBiZWNhdXNlIHRoZSBMZXhlciBtYXRjaGVzIHNvbWV0aGluZyBkb2Vzbid0IG1lYW4gaXQncyB2YWxpZCBpbnB1dDpcbiAqIElmIHRoZXJlIGlzIG5vIG1hdGNoaW5nIGZ1bmN0aW9uIG9yIHN5bWJvbCBkZWZpbml0aW9uLCB0aGUgUGFyc2VyIHdpbGxcbiAqIHN0aWxsIHJlamVjdCB0aGUgaW5wdXQuXG4gKi9cbnZhciB0b2tlblJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICBcIihbIFxcclxcblxcdF0rKXxcIiArICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpdGVzcGFjZVxuICAgIFwiKFshLVxcXFxbXFxcXF0tXFx1MjAyN1xcdTIwMkEtXFx1RDdGRlxcdUY5MDAtXFx1RkZGRl1cIiArICAvLyBzaW5nbGUgY29kZXBvaW50XG4gICAgXCJ8W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXVwiICsgICAgICAgICAgICAgICAvLyBzdXJyb2dhdGUgcGFpclxuICAgIFwifFxcXFxcXFxcKD86W2EtekEtWl0rfFteXFx1RDgwMC1cXHVERkZGXSlcIiArICAgICAgICAgICAvLyBmdW5jdGlvbiBuYW1lXG4gICAgXCIpXCJcbik7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBsZXhlcyBhIHNpbmdsZSB0b2tlbi5cbiAqL1xuTGV4ZXIucHJvdG90eXBlLmxleCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7XG4gICAgdmFyIHBvcyA9IHRoaXMucG9zO1xuICAgIGlmIChwb3MgPT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuKFwiRU9GXCIsIHBvcywgcG9zLCB0aGlzKTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gbWF0Y2hBdCh0b2tlblJlZ2V4LCBpbnB1dCwgcG9zKTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAnXCIgKyBpbnB1dFtwb3NdICsgXCInXCIsXG4gICAgICAgICAgICBuZXcgVG9rZW4oaW5wdXRbcG9zXSwgcG9zLCBwb3MgKyAxLCB0aGlzKSk7XG4gICAgfVxuICAgIHZhciB0ZXh0ID0gbWF0Y2hbMl0gfHwgXCIgXCI7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIHZhciBlbmQgPSB0aGlzLnBvcztcbiAgICByZXR1cm4gbmV3IFRva2VuKHRleHQsIHN0YXJ0LCBlbmQsIHRoaXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBMZXhlcjtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSDigJxndWxsZXTigJ0gd2hlcmUgbWFjcm9zIGFyZSBleHBhbmRlZFxuICogdW50aWwgb25seSBub24tbWFjcm8gdG9rZW5zIHJlbWFpbi5cbiAqL1xuXG52YXIgTGV4ZXIgPSByZXF1aXJlKFwiLi9MZXhlclwiKTtcblxuZnVuY3Rpb24gTWFjcm9FeHBhbmRlcihpbnB1dCwgbWFjcm9zKSB7XG4gICAgdGhpcy5sZXhlciA9IG5ldyBMZXhlcihpbnB1dCk7XG4gICAgdGhpcy5tYWNyb3MgPSBtYWNyb3M7XG4gICAgdGhpcy5zdGFjayA9IFtdOyAvLyBjb250YWlucyB0b2tlbnMgaW4gUkVWRVJTRSBvcmRlclxuICAgIHRoaXMuZGlzY2FyZGVkV2hpdGVTcGFjZSA9IFtdO1xufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGV4cGFuZCBmaXJzdCB0b2tlbiwgdGhlbiByZXR1cm4gZmlyc3Qgbm9uLWV4cGFuZGFibGUgdG9rZW4uXG4gKi9cbk1hY3JvRXhwYW5kZXIucHJvdG90eXBlLm5leHRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5sZXhlci5sZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvcFRva2VuID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIG5hbWUgPSB0b3BUb2tlbi50ZXh0O1xuICAgICAgICBpZiAoIShuYW1lLmNoYXJBdCgwKSA9PT0gXCJcXFxcXCIgJiYgdGhpcy5tYWNyb3MuaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9wVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IHRoaXMubWFjcm9zW25hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIGV4cGFuc2lvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdmFyIGJvZHlMZXhlciA9IG5ldyBMZXhlcihleHBhbnNpb24pO1xuICAgICAgICAgICAgZXhwYW5zaW9uID0gW107XG4gICAgICAgICAgICB2YXIgdG9rID0gYm9keUxleGVyLmxleCgpO1xuICAgICAgICAgICAgd2hpbGUgKHRvay50ZXh0ICE9PSBcIkVPRlwiKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5zaW9uLnB1c2godG9rKTtcbiAgICAgICAgICAgICAgICB0b2sgPSBib2R5TGV4ZXIubGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBhbnNpb24ucmV2ZXJzZSgpOyAvLyB0byBmaXQgaW4gd2l0aCBzdGFjayB1c2luZyBwdXNoIGFuZCBwb3BcbiAgICAgICAgICAgIHRoaXMubWFjcm9zW25hbWVdID0gZXhwYW5zaW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhY2sgPSB0aGlzLnN0YWNrLmNvbmNhdChleHBhbnNpb24pO1xuICAgIH1cbn07XG5cbk1hY3JvRXhwYW5kZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGlnbm9yZVNwYWNlKSB7XG4gICAgdGhpcy5kaXNjYXJkZWRXaGl0ZVNwYWNlID0gW107XG4gICAgdmFyIHRva2VuID0gdGhpcy5uZXh0VG9rZW4oKTtcbiAgICBpZiAoaWdub3JlU3BhY2UpIHtcbiAgICAgICAgd2hpbGUgKHRva2VuLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2NhcmRlZFdoaXRlU3BhY2UucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRva2VuO1xufTtcblxuLyoqXG4gKiBVbmRvIHRoZSBlZmZlY3Qgb2YgdGhlIHByZWNlZGluZyBjYWxsIHRvIHRoZSBnZXQgbWV0aG9kLlxuICogQSBjYWxsIHRvIHRoaXMgbWV0aG9kIE1VU1QgYmUgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYW5kIGltbWVkaWF0ZWx5IGZvbGxvd2VkXG4gKiBieSBhIGNhbGwgdG8gZ2V0LiAgT25seSB1c2VkIGR1cmluZyBtb2RlIHN3aXRjaGluZywgaS5lLiBhZnRlciBvbmUgdG9rZW5cbiAqIHdhcyBnb3QgaW4gdGhlIG9sZCBtb2RlIGJ1dCBzaG91bGQgZ2V0IGdvdCBhZ2FpbiBpbiBhIG5ldyBtb2RlXG4gKiB3aXRoIHBvc3NpYmx5IGRpZmZlcmVudCB3aGl0ZXNwYWNlIGhhbmRsaW5nLlxuICovXG5NYWNyb0V4cGFuZGVyLnByb3RvdHlwZS51bmdldCA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHRva2VuKTtcbiAgICB3aGlsZSAodGhpcy5kaXNjYXJkZWRXaGl0ZVNwYWNlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5kaXNjYXJkZWRXaGl0ZVNwYWNlLnBvcCgpKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hY3JvRXhwYW5kZXI7XG4iLCIvKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgb3B0aW9ucyB0aGF0IHRoZSBQYXJzZXIgY2Fycmllc1xuICogYXJvdW5kIHdpdGggaXQgd2hpbGUgcGFyc2luZy4gRGF0YSBpcyBoZWxkIGluIGFuIGBPcHRpb25zYCBvYmplY3QsIGFuZCB3aGVuXG4gKiByZWN1cnNpbmcsIGEgbmV3IGBPcHRpb25zYCBvYmplY3QgY2FuIGJlIGNyZWF0ZWQgd2l0aCB0aGUgYC53aXRoKmAgYW5kXG4gKiBgLnJlc2V0YCBmdW5jdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBtYWluIG9wdGlvbnMgY2xhc3MuIEl0IGNvbnRhaW5zIHRoZSBzdHlsZSwgc2l6ZSwgY29sb3IsIGFuZCBmb250XG4gKiBvZiB0aGUgY3VycmVudCBwYXJzZSBsZXZlbC4gSXQgYWxzbyBjb250YWlucyB0aGUgc3R5bGUgYW5kIHNpemUgb2YgdGhlIHBhcmVudFxuICogcGFyc2UgbGV2ZWwsIHNvIHNpemUgY2hhbmdlcyBjYW4gYmUgaGFuZGxlZCBlZmZpY2llbnRseS5cbiAqXG4gKiBFYWNoIG9mIHRoZSBgLndpdGgqYCBhbmQgYC5yZXNldGAgZnVuY3Rpb25zIHBhc3NlcyBpdHMgY3VycmVudCBzdHlsZSBhbmQgc2l6ZVxuICogYXMgdGhlIHBhcmVudFN0eWxlIGFuZCBwYXJlbnRTaXplIG9mIHRoZSBuZXcgb3B0aW9ucyBjbGFzcywgc28gcGFyZW50XG4gKiBoYW5kbGluZyBpcyB0YWtlbiBjYXJlIG9mIGF1dG9tYXRpY2FsbHkuXG4gKi9cbmZ1bmN0aW9uIE9wdGlvbnMoZGF0YSkge1xuICAgIHRoaXMuc3R5bGUgPSBkYXRhLnN0eWxlO1xuICAgIHRoaXMuY29sb3IgPSBkYXRhLmNvbG9yO1xuICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB0aGlzLnBoYW50b20gPSBkYXRhLnBoYW50b207XG4gICAgdGhpcy5mb250ID0gZGF0YS5mb250O1xuXG4gICAgaWYgKGRhdGEucGFyZW50U3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnBhcmVudFN0eWxlID0gZGF0YS5zdHlsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudFN0eWxlID0gZGF0YS5wYXJlbnRTdHlsZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5wYXJlbnRTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRTaXplID0gZGF0YS5zaXplO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyZW50U2l6ZSA9IGRhdGEucGFyZW50U2l6ZTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgYXMgXCJ0aGlzXCIuICBQcm9wZXJ0aWVzXG4gKiBmcm9tIFwiZXh0ZW5zaW9uXCIgd2lsbCBiZSBjb3BpZWQgdG8gdGhlIG5ldyBvcHRpb25zIG9iamVjdC5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24oZXh0ZW5zaW9uKSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLFxuICAgICAgICBzaXplOiB0aGlzLnNpemUsXG4gICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLFxuICAgICAgICBwYXJlbnRTdHlsZTogdGhpcy5zdHlsZSxcbiAgICAgICAgcGFyZW50U2l6ZTogdGhpcy5zaXplLFxuICAgICAgICBwaGFudG9tOiB0aGlzLnBoYW50b20sXG4gICAgICAgIGZvbnQ6IHRoaXMuZm9udFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZXh0ZW5zaW9uKSB7XG4gICAgICAgIGlmIChleHRlbnNpb24uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgZGF0YVtrZXldID0gZXh0ZW5zaW9uW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE9wdGlvbnMoZGF0YSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBzdHlsZS5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUud2l0aFN0eWxlID0gZnVuY3Rpb24oc3R5bGUpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBzdHlsZTogc3R5bGVcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIHNpemUuXG4gKi9cbk9wdGlvbnMucHJvdG90eXBlLndpdGhTaXplID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIHNpemU6IHNpemVcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvbG9yLlxuICovXG5PcHRpb25zLnByb3RvdHlwZS53aXRoQ29sb3IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7XG4gICAgICAgIGNvbG9yOiBjb2xvclxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCBcInBoYW50b21cIiBzZXQgdG8gdHJ1ZS5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUud2l0aFBoYW50b20gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBwaGFudG9tOiB0cnVlXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdHMgd2l0aCB0aGUgZ2l2ZSBmb250LlxuICovXG5PcHRpb25zLnByb3RvdHlwZS53aXRoRm9udCA9IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbmQoe1xuICAgICAgICBmb250OiBmb250IHx8IHRoaXMuZm9udFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzdHlsZSwgc2l6ZSwgYW5kIGNvbG9yLiBUaGlzIGlzXG4gKiB1c2VkIHNvIHRoYXQgcGFyZW50IHN0eWxlIGFuZCBzaXplIGNoYW5nZXMgYXJlIGhhbmRsZWQgY29ycmVjdGx5LlxuICovXG5PcHRpb25zLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmV4dGVuZCh7fSk7XG59O1xuXG4vKipcbiAqIEEgbWFwIG9mIGNvbG9yIG5hbWVzIHRvIENTUyBjb2xvcnMuXG4gKiBUT0RPKGVtaWx5KTogUmVtb3ZlIHRoaXMgd2hlbiB3ZSBoYXZlIHJlYWwgbWFjcm9zXG4gKi9cbnZhciBjb2xvck1hcCA9IHtcbiAgICBcImthdGV4LWJsdWVcIjogXCIjNjQ5NWVkXCIsXG4gICAgXCJrYXRleC1vcmFuZ2VcIjogXCIjZmZhNTAwXCIsXG4gICAgXCJrYXRleC1waW5rXCI6IFwiI2ZmMDBhZlwiLFxuICAgIFwia2F0ZXgtcmVkXCI6IFwiI2RmMDAzMFwiLFxuICAgIFwia2F0ZXgtZ3JlZW5cIjogXCIjMjhhZTdiXCIsXG4gICAgXCJrYXRleC1ncmF5XCI6IFwiZ3JheVwiLFxuICAgIFwia2F0ZXgtcHVycGxlXCI6IFwiIzlkMzhiZFwiLFxuICAgIFwia2F0ZXgtYmx1ZUFcIjogXCIjY2NmYWZmXCIsXG4gICAgXCJrYXRleC1ibHVlQlwiOiBcIiM4MGY2ZmZcIixcbiAgICBcImthdGV4LWJsdWVDXCI6IFwiIzYzZDllYVwiLFxuICAgIFwia2F0ZXgtYmx1ZURcIjogXCIjMTFhY2NkXCIsXG4gICAgXCJrYXRleC1ibHVlRVwiOiBcIiMwYzdmOTlcIixcbiAgICBcImthdGV4LXRlYWxBXCI6IFwiIzk0ZmZmNVwiLFxuICAgIFwia2F0ZXgtdGVhbEJcIjogXCIjMjZlZGQ1XCIsXG4gICAgXCJrYXRleC10ZWFsQ1wiOiBcIiMwMWQxYzFcIixcbiAgICBcImthdGV4LXRlYWxEXCI6IFwiIzAxYTk5NVwiLFxuICAgIFwia2F0ZXgtdGVhbEVcIjogXCIjMjA4MTcwXCIsXG4gICAgXCJrYXRleC1ncmVlbkFcIjogXCIjYjZmZmIwXCIsXG4gICAgXCJrYXRleC1ncmVlbkJcIjogXCIjOGFmMjgxXCIsXG4gICAgXCJrYXRleC1ncmVlbkNcIjogXCIjNzRjZjcwXCIsXG4gICAgXCJrYXRleC1ncmVlbkRcIjogXCIjMWZhYjU0XCIsXG4gICAgXCJrYXRleC1ncmVlbkVcIjogXCIjMGQ5MjNmXCIsXG4gICAgXCJrYXRleC1nb2xkQVwiOiBcIiNmZmQwYTlcIixcbiAgICBcImthdGV4LWdvbGRCXCI6IFwiI2ZmYmI3MVwiLFxuICAgIFwia2F0ZXgtZ29sZENcIjogXCIjZmY5YzM5XCIsXG4gICAgXCJrYXRleC1nb2xkRFwiOiBcIiNlMDdkMTBcIixcbiAgICBcImthdGV4LWdvbGRFXCI6IFwiI2E3NWEwNVwiLFxuICAgIFwia2F0ZXgtcmVkQVwiOiBcIiNmY2E5YTlcIixcbiAgICBcImthdGV4LXJlZEJcIjogXCIjZmY4NDgyXCIsXG4gICAgXCJrYXRleC1yZWRDXCI6IFwiI2Y5Njg1ZFwiLFxuICAgIFwia2F0ZXgtcmVkRFwiOiBcIiNlODRkMzlcIixcbiAgICBcImthdGV4LXJlZEVcIjogXCIjYmMyNjEyXCIsXG4gICAgXCJrYXRleC1tYXJvb25BXCI6IFwiI2ZmYmRlMFwiLFxuICAgIFwia2F0ZXgtbWFyb29uQlwiOiBcIiNmZjkyYzZcIixcbiAgICBcImthdGV4LW1hcm9vbkNcIjogXCIjZWQ1ZmE2XCIsXG4gICAgXCJrYXRleC1tYXJvb25EXCI6IFwiI2NhMzM3Y1wiLFxuICAgIFwia2F0ZXgtbWFyb29uRVwiOiBcIiM5ZTAzNGVcIixcbiAgICBcImthdGV4LXB1cnBsZUFcIjogXCIjZGRkN2ZmXCIsXG4gICAgXCJrYXRleC1wdXJwbGVCXCI6IFwiI2M2YjlmY1wiLFxuICAgIFwia2F0ZXgtcHVycGxlQ1wiOiBcIiNhYTg3ZmZcIixcbiAgICBcImthdGV4LXB1cnBsZURcIjogXCIjNzg1NGFiXCIsXG4gICAgXCJrYXRleC1wdXJwbGVFXCI6IFwiIzU0M2I3OFwiLFxuICAgIFwia2F0ZXgtbWludEFcIjogXCIjZjVmOWU4XCIsXG4gICAgXCJrYXRleC1taW50QlwiOiBcIiNlZGYyZGZcIixcbiAgICBcImthdGV4LW1pbnRDXCI6IFwiI2UwZTVjY1wiLFxuICAgIFwia2F0ZXgtZ3JheUFcIjogXCIjZjZmN2Y3XCIsXG4gICAgXCJrYXRleC1ncmF5QlwiOiBcIiNmMGYxZjJcIixcbiAgICBcImthdGV4LWdyYXlDXCI6IFwiI2UzZTVlNlwiLFxuICAgIFwia2F0ZXgtZ3JheURcIjogXCIjZDZkOGRhXCIsXG4gICAgXCJrYXRleC1ncmF5RVwiOiBcIiNiYWJlYzJcIixcbiAgICBcImthdGV4LWdyYXlGXCI6IFwiIzg4OGQ5M1wiLFxuICAgIFwia2F0ZXgtZ3JheUdcIjogXCIjNjI2NTY5XCIsXG4gICAgXCJrYXRleC1ncmF5SFwiOiBcIiMzYjNlNDBcIixcbiAgICBcImthdGV4LWdyYXlJXCI6IFwiIzIxMjQyY1wiLFxuICAgIFwia2F0ZXgta2FCbHVlXCI6IFwiIzMxNDQ1M1wiLFxuICAgIFwia2F0ZXgta2FHcmVlblwiOiBcIiM3MUIzMDdcIlxufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBDU1MgY29sb3Igb2YgdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QsIGFjY291bnRpbmcgZm9yIHRoZVxuICogYGNvbG9yTWFwYC5cbiAqL1xuT3B0aW9ucy5wcm90b3R5cGUuZ2V0Q29sb3IgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5waGFudG9tKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zcGFyZW50XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yTWFwW3RoaXMuY29sb3JdIHx8IHRoaXMuY29sb3I7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcHRpb25zO1xuIiwiLyoqXG4gKiBUaGlzIGlzIHRoZSBQYXJzZUVycm9yIGNsYXNzLCB3aGljaCBpcyB0aGUgbWFpbiBlcnJvciB0aHJvd24gYnkgS2FUZVhcbiAqIGZ1bmN0aW9ucyB3aGVuIHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZy4gVGhpcyBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIGludGVybmFsXG4gKiBlcnJvcnMgZnJvbSBlcnJvcnMgaW4gdGhlIGV4cHJlc3Npb24gdGhhdCB0aGUgdXNlciBwcm92aWRlZC5cbiAqXG4gKiBJZiBwb3NzaWJsZSwgYSBjYWxsZXIgc2hvdWxkIHByb3ZpZGUgYSBUb2tlbiBvciBQYXJzZU5vZGUgd2l0aCBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hlcmUgaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlIHByb2JsZW0gb2NjdXJyZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0geyhUb2tlbnxQYXJzZU5vZGUpPX0gdG9rZW4gIEFuIG9iamVjdCBwcm92aWRpbmcgcG9zaXRpb24gaW5mb3JtYXRpb25cbiAqL1xuZnVuY3Rpb24gUGFyc2VFcnJvcihtZXNzYWdlLCB0b2tlbikge1xuICAgIHZhciBlcnJvciA9IFwiS2FUZVggcGFyc2UgZXJyb3I6IFwiICsgbWVzc2FnZTtcbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIGVuZDtcblxuICAgIGlmICh0b2tlbiAmJiB0b2tlbi5sZXhlciAmJiB0b2tlbi5zdGFydCA8PSB0b2tlbi5lbmQpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSB0aGUgaW5wdXQgYW5kIGEgcG9zaXRpb24sIG1ha2UgdGhlIGVycm9yIGEgYml0IGZhbmNpZXJcblxuICAgICAgICAvLyBHZXQgdGhlIGlucHV0XG4gICAgICAgIHZhciBpbnB1dCA9IHRva2VuLmxleGVyLmlucHV0O1xuXG4gICAgICAgIC8vIFByZXBlbmQgc29tZSBpbmZvcm1hdGlvblxuICAgICAgICBzdGFydCA9IHRva2VuLnN0YXJ0O1xuICAgICAgICBlbmQgPSB0b2tlbi5lbmQ7XG4gICAgICAgIGlmIChzdGFydCA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICBlcnJvciArPSBcIiBhdCBlbmQgb2YgaW5wdXQ6IFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IgKz0gXCIgYXQgcG9zaXRpb24gXCIgKyAoc3RhcnQgKyAxKSArIFwiOiBcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuZGVybGluZSB0b2tlbiBpbiBxdWVzdGlvbiB1c2luZyBjb21iaW5pbmcgdW5kZXJzY29yZXNcbiAgICAgICAgdmFyIHVuZGVybGluZWQgPSBpbnB1dC5zbGljZShzdGFydCwgZW5kKS5yZXBsYWNlKC9bXl0vZywgXCIkJlxcdTAzMzJcIik7XG5cbiAgICAgICAgLy8gRXh0cmFjdCBzb21lIGNvbnRleHQgZnJvbSB0aGUgaW5wdXQgYW5kIGFkZCBpdCB0byB0aGUgZXJyb3JcbiAgICAgICAgdmFyIGxlZnQ7XG4gICAgICAgIGlmIChzdGFydCA+IDE1KSB7XG4gICAgICAgICAgICBsZWZ0ID0gXCLigKZcIiArIGlucHV0LnNsaWNlKHN0YXJ0IC0gMTUsIHN0YXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBpbnB1dC5zbGljZSgwLCBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJpZ2h0O1xuICAgICAgICBpZiAoZW5kICsgMTUgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJpZ2h0ID0gaW5wdXQuc2xpY2UoZW5kLCBlbmQgKyAxNSkgKyBcIuKAplwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmlnaHQgPSBpbnB1dC5zbGljZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yICs9IGxlZnQgKyB1bmRlcmxpbmVkICsgcmlnaHQ7XG4gICAgfVxuXG4gICAgLy8gU29tZSBoYWNrZXJ5IHRvIG1ha2UgUGFyc2VFcnJvciBhIHByb3RvdHlwZSBvZiBFcnJvclxuICAgIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84NDYwNzUzXG4gICAgdmFyIHNlbGYgPSBuZXcgRXJyb3IoZXJyb3IpO1xuICAgIHNlbGYubmFtZSA9IFwiUGFyc2VFcnJvclwiO1xuICAgIHNlbGYuX19wcm90b19fID0gUGFyc2VFcnJvci5wcm90b3R5cGU7XG5cbiAgICBzZWxmLnBvc2l0aW9uID0gc3RhcnQ7XG4gICAgcmV0dXJuIHNlbGY7XG59XG5cbi8vIE1vcmUgaGFja2VyeVxuUGFyc2VFcnJvci5wcm90b3R5cGUuX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlRXJyb3I7XG4iLCIvKiBlc2xpbnQgbm8tY29uc3RhbnQtY29uZGl0aW9uOjAgKi9cbnZhciBmdW5jdGlvbnMgPSByZXF1aXJlKFwiLi9mdW5jdGlvbnNcIik7XG52YXIgZW52aXJvbm1lbnRzID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRzXCIpO1xudmFyIE1hY3JvRXhwYW5kZXIgPSByZXF1aXJlKFwiLi9NYWNyb0V4cGFuZGVyXCIpO1xudmFyIHN5bWJvbHMgPSByZXF1aXJlKFwiLi9zeW1ib2xzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgY2prUmVnZXggPSByZXF1aXJlKFwiLi91bmljb2RlUmVnZXhlc1wiKS5jamtSZWdleDtcblxudmFyIHBhcnNlRGF0YSA9IHJlcXVpcmUoXCIuL3BhcnNlRGF0YVwiKTtcbnZhciBQYXJzZUVycm9yID0gcmVxdWlyZShcIi4vUGFyc2VFcnJvclwiKTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIHBhcnNlciB1c2VkIHRvIHBhcnNlIG91dCBhIFRlWCBleHByZXNzaW9uIGZyb20gdGhlXG4gKiBpbnB1dC4gU2luY2UgVGVYIGlzbid0IGNvbnRleHQtZnJlZSwgc3RhbmRhcmQgcGFyc2VycyBkb24ndCB3b3JrIHBhcnRpY3VsYXJseVxuICogd2VsbC5cbiAqXG4gKiBUaGUgc3RyYXRlZ3kgb2YgdGhpcyBwYXJzZXIgaXMgYXMgc3VjaDpcbiAqXG4gKiBUaGUgbWFpbiBmdW5jdGlvbnMgKHRoZSBgLnBhcnNlLi4uYCBvbmVzKSB0YWtlIGEgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcbiAqIHBhcnNlIHN0cmluZyB0byBwYXJzZSB0b2tlbnMgZnJvbS4gVGhlIGxleGVyIChmb3VuZCBpbiBMZXhlci5qcywgc3RvcmVkIGF0XG4gKiB0aGlzLmxleGVyKSBhbHNvIHN1cHBvcnRzIHB1bGxpbmcgb3V0IHRva2VucyBhdCBhcmJpdHJhcnkgcGxhY2VzLiBXaGVuXG4gKiBpbmRpdmlkdWFsIHRva2VucyBhcmUgbmVlZGVkIGF0IGEgcG9zaXRpb24sIHRoZSBsZXhlciBpcyBjYWxsZWQgdG8gcHVsbCBvdXQgYVxuICogdG9rZW4sIHdoaWNoIGlzIHRoZW4gdXNlZC5cbiAqXG4gKiBUaGUgcGFyc2VyIGhhcyBhIHByb3BlcnR5IGNhbGxlZCBcIm1vZGVcIiBpbmRpY2F0aW5nIHRoZSBtb2RlIHRoYXRcbiAqIHRoZSBwYXJzZXIgaXMgY3VycmVudGx5IGluLiBDdXJyZW50bHkgaXQgaGFzIHRvIGJlIG9uZSBvZiBcIm1hdGhcIiBvclxuICogXCJ0ZXh0XCIsIHdoaWNoIGRlbm90ZXMgd2hldGhlciB0aGUgY3VycmVudCBlbnZpcm9ubWVudCBpcyBhIG1hdGgteVxuICogb25lIG9yIGEgdGV4dC15IG9uZSAoZS5nLiBpbnNpZGUgXFx0ZXh0KS4gQ3VycmVudGx5LCB0aGlzIHNlcnZlcyB0b1xuICogbGltaXQgdGhlIGZ1bmN0aW9ucyB3aGljaCBjYW4gYmUgdXNlZCBpbiB0ZXh0IG1vZGUuXG4gKlxuICogVGhlIG1haW4gZnVuY3Rpb25zIHRoZW4gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgdXNlZnVsIGRhdGEgdGhhdFxuICogd2FzIHBhcnNlZCBhdCBpdHMgZ2l2ZW4gcG9pbnQsIGFuZCBhIG5ldyBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJzZWRcbiAqIGRhdGEuIFRoZSBtYWluIGZ1bmN0aW9ucyBjYW4gY2FsbCBlYWNoIG90aGVyIGFuZCBjb250aW51ZSB0aGUgcGFyc2luZyBieVxuICogdXNpbmcgdGhlIHJldHVybmVkIHBvc2l0aW9uIGFzIGEgbmV3IHN0YXJ0aW5nIHBvaW50LlxuICpcbiAqIFRoZXJlIGFyZSBhbHNvIGV4dHJhIGAuaGFuZGxlLi4uYCBmdW5jdGlvbnMsIHdoaWNoIHB1bGwgb3V0IHNvbWUgcmV1c2VkXG4gKiBmdW5jdGlvbmFsaXR5IGludG8gc2VsZi1jb250YWluZWQgZnVuY3Rpb25zLlxuICpcbiAqIFRoZSBlYXJsaWVyIGZ1bmN0aW9ucyByZXR1cm4gUGFyc2VOb2Rlcy5cbiAqIFRoZSBsYXRlciBmdW5jdGlvbnMgKHdoaWNoIGFyZSBjYWxsZWQgZGVlcGVyIGluIHRoZSBwYXJzZSkgc29tZXRpbWVzIHJldHVyblxuICogUGFyc2VGdW5jT3JBcmd1bWVudCwgd2hpY2ggY29udGFpbiBhIFBhcnNlTm9kZSBhcyB3ZWxsIGFzIHNvbWUgZGF0YSBhYm91dFxuICogd2hldGhlciB0aGUgcGFyc2VkIG9iamVjdCBpcyBhIGZ1bmN0aW9uIHdoaWNoIGlzIG1pc3Npbmcgc29tZSBhcmd1bWVudHMsIG9yIGFcbiAqIHN0YW5kYWxvbmUgb2JqZWN0IHdoaWNoIGNhbiBiZSB1c2VkIGFzIGFuIGFyZ3VtZW50IHRvIGFub3RoZXIgZnVuY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBNYWluIFBhcnNlciBjbGFzc1xuICovXG5mdW5jdGlvbiBQYXJzZXIoaW5wdXQsIHNldHRpbmdzKSB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IG1hY3JvIGV4cGFuZGVyIChndWxsZXQpIGFuZCAoaW5kaXJlY3RseSB2aWEgdGhhdCkgYWxzbyBhXG4gICAgLy8gbmV3IGxleGVyIChtb3V0aCkgZm9yIHRoaXMgcGFyc2VyIChzdG9tYWNoLCBpbiB0aGUgbGFuZ3VhZ2Ugb2YgVGVYKVxuICAgIHRoaXMuZ3VsbGV0ID0gbmV3IE1hY3JvRXhwYW5kZXIoaW5wdXQsIHNldHRpbmdzLm1hY3Jvcyk7XG4gICAgLy8gU3RvcmUgdGhlIHNldHRpbmdzIGZvciB1c2UgaW4gcGFyc2luZ1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAvLyBDb3VudCBsZWZ0cmlnaHQgZGVwdGggKGZvciBcXG1pZGRsZSBlcnJvcnMpXG4gICAgdGhpcy5sZWZ0cmlnaHREZXB0aCA9IDA7XG59XG5cbnZhciBQYXJzZU5vZGUgPSBwYXJzZURhdGEuUGFyc2VOb2RlO1xuXG4vKipcbiAqIEFuIGluaXRpYWwgZnVuY3Rpb24gKHdpdGhvdXQgaXRzIGFyZ3VtZW50cyksIG9yIGFuIGFyZ3VtZW50IHRvIGEgZnVuY3Rpb24uXG4gKiBUaGUgYHJlc3VsdGAgYXJndW1lbnQgc2hvdWxkIGJlIGEgUGFyc2VOb2RlLlxuICovXG5mdW5jdGlvbiBQYXJzZUZ1bmNPckFyZ3VtZW50KHJlc3VsdCwgaXNGdW5jdGlvbiwgdG9rZW4pIHtcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAvLyBJcyB0aGlzIGEgZnVuY3Rpb24gKGkuZS4gaXMgaXQgc29tZXRoaW5nIGRlZmluZWQgaW4gZnVuY3Rpb25zLmpzKT9cbiAgICB0aGlzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSByZXN1bHQgdG8gbWFrZSBzdXJlIGl0IGhhcyB0aGUgcmlnaHQgdHlwZSwgYW5kIHRocm93cyBhblxuICogYXBwcm9wcmlhdGUgZXJyb3Igb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGNvbnN1bWUgd2hldGhlciB0byBjb25zdW1lIHRoZSBleHBlY3RlZCB0b2tlbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHMgdG8gdHJ1ZVxuICovXG5QYXJzZXIucHJvdG90eXBlLmV4cGVjdCA9IGZ1bmN0aW9uKHRleHQsIGNvbnN1bWUpIHtcbiAgICBpZiAodGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gdGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgIFwiRXhwZWN0ZWQgJ1wiICsgdGV4dCArIFwiJywgZ290ICdcIiArIHRoaXMubmV4dFRva2VuLnRleHQgKyBcIidcIixcbiAgICAgICAgICAgIHRoaXMubmV4dFRva2VuXG4gICAgICAgICk7XG4gICAgfVxuICAgIGlmIChjb25zdW1lICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnNpZGVycyB0aGUgY3VycmVudCBsb29rIGFoZWFkIHRva2VuIGFzIGNvbnN1bWVkLFxuICogYW5kIGZldGNoZXMgdGhlIG9uZSBhZnRlciB0aGF0IGFzIHRoZSBuZXcgbG9vayBhaGVhZC5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5jb25zdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5uZXh0VG9rZW4gPSB0aGlzLmd1bGxldC5nZXQodGhpcy5tb2RlID09PSBcIm1hdGhcIik7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnN3aXRjaE1vZGUgPSBmdW5jdGlvbihuZXdNb2RlKSB7XG4gICAgdGhpcy5ndWxsZXQudW5nZXQodGhpcy5uZXh0VG9rZW4pO1xuICAgIHRoaXMubW9kZSA9IG5ld01vZGU7XG4gICAgdGhpcy5jb25zdW1lKCk7XG59O1xuXG4vKipcbiAqIE1haW4gcGFyc2luZyBmdW5jdGlvbiwgd2hpY2ggcGFyc2VzIGFuIGVudGlyZSBpbnB1dC5cbiAqXG4gKiBAcmV0dXJuIHs/QXJyYXkuPFBhcnNlTm9kZT59XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUcnkgdG8gcGFyc2UgdGhlIGlucHV0XG4gICAgdGhpcy5tb2RlID0gXCJtYXRoXCI7XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgdmFyIHBhcnNlID0gdGhpcy5wYXJzZUlucHV0KCk7XG4gICAgcmV0dXJuIHBhcnNlO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYW4gZW50aXJlIGlucHV0IHRyZWUuXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VJbnB1dCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFBhcnNlIGFuIGV4cHJlc3Npb25cbiAgICB2YXIgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcbiAgICAvLyBJZiB3ZSBzdWNjZWVkZWQsIG1ha2Ugc3VyZSB0aGVyZSdzIGFuIEVPRiBhdCB0aGUgZW5kXG4gICAgdGhpcy5leHBlY3QoXCJFT0ZcIiwgZmFsc2UpO1xuICAgIHJldHVybiBleHByZXNzaW9uO1xufTtcblxudmFyIGVuZE9mRXhwcmVzc2lvbiA9IFtcIn1cIiwgXCJcXFxcZW5kXCIsIFwiXFxcXHJpZ2h0XCIsIFwiJlwiLCBcIlxcXFxcXFxcXCIsIFwiXFxcXGNyXCJdO1xuXG4vKipcbiAqIFBhcnNlcyBhbiBcImV4cHJlc3Npb25cIiwgd2hpY2ggaXMgYSBsaXN0IG9mIGF0b21zLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYnJlYWtPbkluZml4ICBTaG91bGQgdGhlIHBhcnNpbmcgc3RvcCB3aGVuIHdlIGhpdCBpbmZpeFxuICogICAgICAgICAgICAgICAgICBub2Rlcz8gVGhpcyBoYXBwZW5zIHdoZW4gZnVuY3Rpb25zIGhhdmUgaGlnaGVyIHByZWNlbmRlbmNlXG4gKiAgICAgICAgICAgICAgICAgIHRoYW4gaW5maXggbm9kZXMgaW4gaW1wbGljaXQgcGFyc2VzLlxuICpcbiAqIEBwYXJhbSB7P3N0cmluZ30gYnJlYWtPblRva2VuVGV4dCAgVGhlIHRleHQgb2YgdGhlIHRva2VuIHRoYXQgdGhlIGV4cHJlc3Npb25cbiAqICAgICAgICAgICAgICAgICAgc2hvdWxkIGVuZCB3aXRoLCBvciBgbnVsbGAgaWYgc29tZXRoaW5nIGVsc2Ugc2hvdWxkIGVuZCB0aGVcbiAqICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcmV0dXJuIHtQYXJzZU5vZGV9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VFeHByZXNzaW9uID0gZnVuY3Rpb24oYnJlYWtPbkluZml4LCBicmVha09uVG9rZW5UZXh0KSB7XG4gICAgdmFyIGJvZHkgPSBbXTtcbiAgICAvLyBLZWVwIGFkZGluZyBhdG9tcyB0byB0aGUgYm9keSB1bnRpbCB3ZSBjYW4ndCBwYXJzZSBhbnkgbW9yZSBhdG9tcyAoZWl0aGVyXG4gICAgLy8gd2UgcmVhY2hlZCB0aGUgZW5kLCBhIH0sIG9yIGEgXFxyaWdodClcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgbGV4ID0gdGhpcy5uZXh0VG9rZW47XG4gICAgICAgIGlmIChlbmRPZkV4cHJlc3Npb24uaW5kZXhPZihsZXgudGV4dCkgIT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnJlYWtPblRva2VuVGV4dCAmJiBsZXgudGV4dCA9PT0gYnJlYWtPblRva2VuVGV4dCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJyZWFrT25JbmZpeCAmJiBmdW5jdGlvbnNbbGV4LnRleHRdICYmIGZ1bmN0aW9uc1tsZXgudGV4dF0uaW5maXgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdG9tID0gdGhpcy5wYXJzZUF0b20oKTtcbiAgICAgICAgaWYgKCFhdG9tKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0dGluZ3MudGhyb3dPbkVycm9yICYmIGxleC50ZXh0WzBdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIHZhciBlcnJvck5vZGUgPSB0aGlzLmhhbmRsZVVuc3VwcG9ydGVkQ21kKCk7XG4gICAgICAgICAgICAgICAgYm9keS5wdXNoKGVycm9yTm9kZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJvZHkucHVzaChhdG9tKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlSW5maXhOb2Rlcyhib2R5KTtcbn07XG5cbi8qKlxuICogUmV3cml0ZXMgaW5maXggb3BlcmF0b3JzIHN1Y2ggYXMgXFxvdmVyIHdpdGggY29ycmVzcG9uZGluZyBjb21tYW5kcyBzdWNoXG4gKiBhcyBcXGZyYWMuXG4gKlxuICogVGhlcmUgY2FuIG9ubHkgYmUgb25lIGluZml4IG9wZXJhdG9yIHBlciBncm91cC4gIElmIHRoZXJlJ3MgbW9yZSB0aGFuIG9uZVxuICogdGhlbiB0aGUgZXhwcmVzc2lvbiBpcyBhbWJpZ3VvdXMuICBUaGlzIGNhbiBiZSByZXNvbHZlZCBieSBhZGRpbmcge30uXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICovXG5QYXJzZXIucHJvdG90eXBlLmhhbmRsZUluZml4Tm9kZXMgPSBmdW5jdGlvbihib2R5KSB7XG4gICAgdmFyIG92ZXJJbmRleCA9IC0xO1xuICAgIHZhciBmdW5jTmFtZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGJvZHlbaV07XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiaW5maXhcIikge1xuICAgICAgICAgICAgaWYgKG92ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJvbmx5IG9uZSBpbmZpeCBvcGVyYXRvciBwZXIgZ3JvdXBcIixcbiAgICAgICAgICAgICAgICAgICAgbm9kZS52YWx1ZS50b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdmVySW5kZXggPSBpO1xuICAgICAgICAgICAgZnVuY05hbWUgPSBub2RlLnZhbHVlLnJlcGxhY2VXaXRoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG92ZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgdmFyIG51bWVyTm9kZTtcbiAgICAgICAgdmFyIGRlbm9tTm9kZTtcblxuICAgICAgICB2YXIgbnVtZXJCb2R5ID0gYm9keS5zbGljZSgwLCBvdmVySW5kZXgpO1xuICAgICAgICB2YXIgZGVub21Cb2R5ID0gYm9keS5zbGljZShvdmVySW5kZXggKyAxKTtcblxuICAgICAgICBpZiAobnVtZXJCb2R5Lmxlbmd0aCA9PT0gMSAmJiBudW1lckJvZHlbMF0udHlwZSA9PT0gXCJvcmRncm91cFwiKSB7XG4gICAgICAgICAgICBudW1lck5vZGUgPSBudW1lckJvZHlbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1lck5vZGUgPSBuZXcgUGFyc2VOb2RlKFwib3JkZ3JvdXBcIiwgbnVtZXJCb2R5LCB0aGlzLm1vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbm9tQm9keS5sZW5ndGggPT09IDEgJiYgZGVub21Cb2R5WzBdLnR5cGUgPT09IFwib3JkZ3JvdXBcIikge1xuICAgICAgICAgICAgZGVub21Ob2RlID0gZGVub21Cb2R5WzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVub21Ob2RlID0gbmV3IFBhcnNlTm9kZShcIm9yZGdyb3VwXCIsIGRlbm9tQm9keSwgdGhpcy5tb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuY2FsbEZ1bmN0aW9uKFxuICAgICAgICAgICAgZnVuY05hbWUsIFtudW1lck5vZGUsIGRlbm9tTm9kZV0sIG51bGwpO1xuICAgICAgICByZXR1cm4gW25ldyBQYXJzZU5vZGUodmFsdWUudHlwZSwgdmFsdWUsIHRoaXMubW9kZSldO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH1cbn07XG5cbi8vIFRoZSBncmVlZGluZXNzIG9mIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0XG52YXIgU1VQU1VCX0dSRUVESU5FU1MgPSAxO1xuXG4vKipcbiAqIEhhbmRsZSBhIHN1YnNjcmlwdCBvciBzdXBlcnNjcmlwdCB3aXRoIG5pY2UgZXJyb3JzLlxuICovXG5QYXJzZXIucHJvdG90eXBlLmhhbmRsZVN1cFN1YnNjcmlwdCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgc3ltYm9sVG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB2YXIgc3ltYm9sID0gc3ltYm9sVG9rZW4udGV4dDtcbiAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLnBhcnNlR3JvdXAoKTtcblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnRocm93T25FcnJvciAmJiB0aGlzLm5leHRUb2tlbi50ZXh0WzBdID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlVW5zdXBwb3J0ZWRDbWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiRXhwZWN0ZWQgZ3JvdXAgYWZ0ZXIgJ1wiICsgc3ltYm9sICsgXCInXCIsXG4gICAgICAgICAgICAgICAgc3ltYm9sVG9rZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLmlzRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gXiBhbmQgXyBoYXZlIGEgZ3JlZWRpbmVzcywgc28gaGFuZGxlIGludGVyYWN0aW9ucyB3aXRoIGZ1bmN0aW9ucydcbiAgICAgICAgLy8gZ3JlZWRpbmVzc1xuICAgICAgICB2YXIgZnVuY0dyZWVkaW5lc3MgPSBmdW5jdGlvbnNbZ3JvdXAucmVzdWx0XS5ncmVlZGluZXNzO1xuICAgICAgICBpZiAoZnVuY0dyZWVkaW5lc3MgPiBTVVBTVUJfR1JFRURJTkVTUykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihncm91cCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICBcIkdvdCBmdW5jdGlvbiAnXCIgKyBncm91cC5yZXN1bHQgKyBcIicgd2l0aCBubyBhcmd1bWVudHMgXCIgK1xuICAgICAgICAgICAgICAgICAgICBcImFzIFwiICsgbmFtZSwgc3ltYm9sVG9rZW4pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGdyb3VwLnJlc3VsdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSB0ZXh0dWFsIGlucHV0IG9mIGFuIHVuc3VwcG9ydGVkIGNvbW1hbmQgaW50byBhIHRleHQgbm9kZVxuICogY29udGFpbmVkIHdpdGhpbiBhIGNvbG9yIG5vZGUgd2hvc2UgY29sb3IgaXMgZGV0ZXJtaW5lZCBieSBlcnJvckNvbG9yXG4gKi9cblBhcnNlci5wcm90b3R5cGUuaGFuZGxlVW5zdXBwb3J0ZWRDbWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGV4dCA9IHRoaXMubmV4dFRva2VuLnRleHQ7XG4gICAgdmFyIHRleHRvcmRBcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRleHRvcmRBcnJheS5wdXNoKG5ldyBQYXJzZU5vZGUoXCJ0ZXh0b3JkXCIsIHRleHRbaV0sIFwidGV4dFwiKSk7XG4gICAgfVxuXG4gICAgdmFyIHRleHROb2RlID0gbmV3IFBhcnNlTm9kZShcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGJvZHk6IHRleHRvcmRBcnJheSxcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMubW9kZSk7XG5cbiAgICB2YXIgY29sb3JOb2RlID0gbmV3IFBhcnNlTm9kZShcbiAgICAgICAgXCJjb2xvclwiLFxuICAgICAgICB7XG4gICAgICAgICAgICBjb2xvcjogdGhpcy5zZXR0aW5ncy5lcnJvckNvbG9yLFxuICAgICAgICAgICAgdmFsdWU6IFt0ZXh0Tm9kZV0sXG4gICAgICAgICAgICB0eXBlOiBcImNvbG9yXCJcbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy5tb2RlKTtcblxuICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIHJldHVybiBjb2xvck5vZGU7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIGdyb3VwIHdpdGggb3B0aW9uYWwgc3VwZXIvc3Vic2NyaXB0cy5cbiAqXG4gKiBAcmV0dXJuIHs/UGFyc2VOb2RlfVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQXRvbSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRoZSBib2R5IG9mIGFuIGF0b20gaXMgYW4gaW1wbGljaXQgZ3JvdXAsIHNvIHRoYXQgdGhpbmdzIGxpa2VcbiAgICAvLyBcXGxlZnQoeFxccmlnaHQpXjIgd29yayBjb3JyZWN0bHkuXG4gICAgdmFyIGJhc2UgPSB0aGlzLnBhcnNlSW1wbGljaXRHcm91cCgpO1xuXG4gICAgLy8gSW4gdGV4dCBtb2RlLCB3ZSBkb24ndCBoYXZlIHN1cGVyc2NyaXB0cyBvciBzdWJzY3JpcHRzXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuXG4gICAgLy8gTm90ZSB0aGF0IGJhc2UgbWF5IGJlIGVtcHR5IChpLmUuIG51bGwpIGF0IHRoaXMgcG9pbnQuXG5cbiAgICB2YXIgc3VwZXJzY3JpcHQ7XG4gICAgdmFyIHN1YnNjcmlwdDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyBMZXggdGhlIGZpcnN0IHRva2VuXG4gICAgICAgIHZhciBsZXggPSB0aGlzLm5leHRUb2tlbjtcblxuICAgICAgICBpZiAobGV4LnRleHQgPT09IFwiXFxcXGxpbWl0c1wiIHx8IGxleC50ZXh0ID09PSBcIlxcXFxub2xpbWl0c1wiKSB7XG4gICAgICAgICAgICAvLyBXZSBnb3QgYSBsaW1pdCBjb250cm9sXG4gICAgICAgICAgICBpZiAoIWJhc2UgfHwgYmFzZS50eXBlICE9PSBcIm9wXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgXCJMaW1pdCBjb250cm9scyBtdXN0IGZvbGxvdyBhIG1hdGggb3BlcmF0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgbGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbWl0cyA9IGxleC50ZXh0ID09PSBcIlxcXFxsaW1pdHNcIjtcbiAgICAgICAgICAgICAgICBiYXNlLnZhbHVlLmxpbWl0cyA9IGxpbWl0cztcbiAgICAgICAgICAgICAgICBiYXNlLnZhbHVlLmFsd2F5c0hhbmRsZVN1cFN1YiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCJeXCIpIHtcbiAgICAgICAgICAgIC8vIFdlIGdvdCBhIHN1cGVyc2NyaXB0IHN0YXJ0XG4gICAgICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcIkRvdWJsZSBzdXBlcnNjcmlwdFwiLCBsZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VwZXJzY3JpcHQgPSB0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1cGVyc2NyaXB0XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSBcIl9cIikge1xuICAgICAgICAgICAgLy8gV2UgZ290IGEgc3Vic2NyaXB0IHN0YXJ0XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJEb3VibGUgc3Vic2NyaXB0XCIsIGxleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpcHQgPSB0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdChcInN1YnNjcmlwdFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgIC8vIFdlIGdvdCBhIHByaW1lXG4gICAgICAgICAgICB2YXIgcHJpbWUgPSBuZXcgUGFyc2VOb2RlKFwidGV4dG9yZFwiLCBcIlxcXFxwcmltZVwiLCB0aGlzLm1vZGUpO1xuXG4gICAgICAgICAgICAvLyBNYW55IHByaW1lcyBjYW4gYmUgZ3JvdXBlZCB0b2dldGhlciwgc28gd2UgaGFuZGxlIHRoaXMgaGVyZVxuICAgICAgICAgICAgdmFyIHByaW1lcyA9IFtwcmltZV07XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgIC8vIEtlZXAgbGV4aW5nIHRva2VucyB1bnRpbCB3ZSBnZXQgc29tZXRoaW5nIHRoYXQncyBub3QgYSBwcmltZVxuICAgICAgICAgICAgd2hpbGUgKHRoaXMubmV4dFRva2VuLnRleHQgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggb25lLCBhZGQgYW5vdGhlciBwcmltZSB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIHByaW1lcy5wdXNoKHByaW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFB1dCB0aGVtIGludG8gYW4gb3JkZ3JvdXAgYXMgdGhlIHN1cGVyc2NyaXB0XG4gICAgICAgICAgICBzdXBlcnNjcmlwdCA9IG5ldyBQYXJzZU5vZGUoXCJvcmRncm91cFwiLCBwcmltZXMsIHRoaXMubW9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBpdCB3YXNuJ3QgXiwgXywgb3IgJywgc3RvcCBwYXJzaW5nIHN1cGVyL3N1YnNjcmlwdHNcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN1cGVyc2NyaXB0IHx8IHN1YnNjcmlwdCkge1xuICAgICAgICAvLyBJZiB3ZSBnb3QgZWl0aGVyIGEgc3VwZXJzY3JpcHQgb3Igc3Vic2NyaXB0LCBjcmVhdGUgYSBzdXBzdWJcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZU5vZGUoXCJzdXBzdWJcIiwge1xuICAgICAgICAgICAgYmFzZTogYmFzZSxcbiAgICAgICAgICAgIHN1cDogc3VwZXJzY3JpcHQsXG4gICAgICAgICAgICBzdWI6IHN1YnNjcmlwdFxuICAgICAgICB9LCB0aGlzLm1vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSByZXR1cm4gdGhlIG9yaWdpbmFsIGJvZHlcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufTtcblxuLy8gQSBsaXN0IG9mIHRoZSBzaXplLWNoYW5naW5nIGZ1bmN0aW9ucywgZm9yIHVzZSBpbiBwYXJzZUltcGxpY2l0R3JvdXBcbnZhciBzaXplRnVuY3MgPSBbXG4gICAgXCJcXFxcdGlueVwiLCBcIlxcXFxzY3JpcHRzaXplXCIsIFwiXFxcXGZvb3Rub3Rlc2l6ZVwiLCBcIlxcXFxzbWFsbFwiLCBcIlxcXFxub3JtYWxzaXplXCIsXG4gICAgXCJcXFxcbGFyZ2VcIiwgXCJcXFxcTGFyZ2VcIiwgXCJcXFxcTEFSR0VcIiwgXCJcXFxcaHVnZVwiLCBcIlxcXFxIdWdlXCJcbl07XG5cbi8vIEEgbGlzdCBvZiB0aGUgc3R5bGUtY2hhbmdpbmcgZnVuY3Rpb25zLCBmb3IgdXNlIGluIHBhcnNlSW1wbGljaXRHcm91cFxudmFyIHN0eWxlRnVuY3MgPSBbXG4gICAgXCJcXFxcZGlzcGxheXN0eWxlXCIsIFwiXFxcXHRleHRzdHlsZVwiLCBcIlxcXFxzY3JpcHRzdHlsZVwiLCBcIlxcXFxzY3JpcHRzY3JpcHRzdHlsZVwiXG5dO1xuXG4vKipcbiAqIFBhcnNlcyBhbiBpbXBsaWNpdCBncm91cCwgd2hpY2ggaXMgYSBncm91cCB0aGF0IHN0YXJ0cyBhdCB0aGUgZW5kIG9mIGFcbiAqIHNwZWNpZmllZCwgYW5kIGVuZHMgcmlnaHQgYmVmb3JlIGEgaGlnaGVyIGV4cGxpY2l0IGdyb3VwIGVuZHMsIG9yIGF0IEVPTC4gSXRcbiAqIGlzIHVzZWQgZm9yIGZ1bmN0aW9ucyB0aGF0IGFwcGVhciB0byBhZmZlY3QgdGhlIGN1cnJlbnQgc3R5bGUsIGxpa2UgXFxMYXJnZSBvclxuICogXFx0ZXh0cm0sIHdoZXJlIGluc3RlYWQgb2Yga2VlcGluZyBhIHN0eWxlIHdlIGp1c3QgcHJldGVuZCB0aGF0IHRoZXJlIGlzIGFuXG4gKiBpbXBsaWNpdCBncm91cGluZyBhZnRlciBpdCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBncm91cC4gRS5nLlxuICogICBzbWFsbCB0ZXh0IHtcXExhcmdlIGxhcmdlIHRleHR9IHNtYWxsIHRleHQgYWdhaW5cbiAqIEl0IGlzIGFsc28gdXNlZCBmb3IgXFxsZWZ0IGFuZCBcXHJpZ2h0IHRvIGdldCB0aGUgY29ycmVjdCBncm91cGluZy5cbiAqXG4gKiBAcmV0dXJuIHs/UGFyc2VOb2RlfVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlSW1wbGljaXRHcm91cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMucGFyc2VTeW1ib2woKTtcblxuICAgIGlmIChzdGFydCA9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHdlIGRpZG4ndCBnZXQgYW55dGhpbmcgd2UgaGFuZGxlLCBmYWxsIGJhY2sgdG8gcGFyc2VGdW5jdGlvblxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKCk7XG4gICAgfVxuXG4gICAgdmFyIGZ1bmMgPSBzdGFydC5yZXN1bHQ7XG4gICAgdmFyIGJvZHk7XG5cbiAgICBpZiAoZnVuYyA9PT0gXCJcXFxcbGVmdFwiKSB7XG4gICAgICAgIC8vIElmIHdlIHNlZSBhIGxlZnQ6XG4gICAgICAgIC8vIFBhcnNlIHRoZSBlbnRpcmUgbGVmdCBmdW5jdGlvbiAoaW5jbHVkaW5nIHRoZSBkZWxpbWl0ZXIpXG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5wYXJzZUZ1bmN0aW9uKHN0YXJ0KTtcbiAgICAgICAgLy8gUGFyc2Ugb3V0IHRoZSBpbXBsaWNpdCBib2R5XG4gICAgICAgICsrdGhpcy5sZWZ0cmlnaHREZXB0aDtcbiAgICAgICAgYm9keSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGZhbHNlKTtcbiAgICAgICAgLS10aGlzLmxlZnRyaWdodERlcHRoO1xuICAgICAgICAvLyBDaGVjayB0aGUgbmV4dCB0b2tlblxuICAgICAgICB0aGlzLmV4cGVjdChcIlxcXFxyaWdodFwiLCBmYWxzZSk7XG4gICAgICAgIHZhciByaWdodCA9IHRoaXMucGFyc2VGdW5jdGlvbigpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlTm9kZShcImxlZnRyaWdodFwiLCB7XG4gICAgICAgICAgICBib2R5OiBib2R5LFxuICAgICAgICAgICAgbGVmdDogbGVmdC52YWx1ZS52YWx1ZSxcbiAgICAgICAgICAgIHJpZ2h0OiByaWdodC52YWx1ZS52YWx1ZVxuICAgICAgICB9LCB0aGlzLm1vZGUpO1xuICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gXCJcXFxcYmVnaW5cIikge1xuICAgICAgICAvLyBiZWdpbi4uLmVuZCBpcyBzaW1pbGFyIHRvIGxlZnQuLi5yaWdodFxuICAgICAgICB2YXIgYmVnaW4gPSB0aGlzLnBhcnNlRnVuY3Rpb24oc3RhcnQpO1xuICAgICAgICB2YXIgZW52TmFtZSA9IGJlZ2luLnZhbHVlLm5hbWU7XG4gICAgICAgIGlmICghZW52aXJvbm1lbnRzLmhhc093blByb3BlcnR5KGVudk5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgICAgICBcIk5vIHN1Y2ggZW52aXJvbm1lbnQ6IFwiICsgZW52TmFtZSwgYmVnaW4udmFsdWUubmFtZUdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBCdWlsZCB0aGUgZW52aXJvbm1lbnQgb2JqZWN0LiBBcmd1bWVudHMgYW5kIG90aGVyIGluZm9ybWF0aW9uIHdpbGxcbiAgICAgICAgLy8gYmUgbWFkZSBhdmFpbGFibGUgdG8gdGhlIGJlZ2luIGFuZCBlbmQgbWV0aG9kcyB1c2luZyBwcm9wZXJ0aWVzLlxuICAgICAgICB2YXIgZW52ID0gZW52aXJvbm1lbnRzW2Vudk5hbWVdO1xuICAgICAgICB2YXIgYXJncyA9IHRoaXMucGFyc2VBcmd1bWVudHMoXCJcXFxcYmVnaW57XCIgKyBlbnZOYW1lICsgXCJ9XCIsIGVudik7XG4gICAgICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgICAgICAgZW52TmFtZTogZW52TmFtZSxcbiAgICAgICAgICAgIHBhcnNlcjogdGhpcyxcbiAgICAgICAgICAgIHBvc2l0aW9uczogYXJncy5wb3AoKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzdWx0ID0gZW52LmhhbmRsZXIoY29udGV4dCwgYXJncyk7XG4gICAgICAgIHRoaXMuZXhwZWN0KFwiXFxcXGVuZFwiLCBmYWxzZSk7XG4gICAgICAgIHZhciBlbmROYW1lVG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMucGFyc2VGdW5jdGlvbigpO1xuICAgICAgICBpZiAoZW5kLnZhbHVlLm5hbWUgIT09IGVudk5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgIFwiTWlzbWF0Y2g6IFxcXFxiZWdpbntcIiArIGVudk5hbWUgKyBcIn0gbWF0Y2hlZCBcIiArXG4gICAgICAgICAgICAgICAgXCJieSBcXFxcZW5ke1wiICsgZW5kLnZhbHVlLm5hbWUgKyBcIn1cIixcbiAgICAgICAgICAgICAgICBlbmROYW1lVG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wb3NpdGlvbiA9IGVuZC5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmNvbnRhaW5zKHNpemVGdW5jcywgZnVuYykpIHtcbiAgICAgICAgLy8gSWYgd2Ugc2VlIGEgc2l6aW5nIGZ1bmN0aW9uLCBwYXJzZSBvdXQgdGhlIGltcGxpY3QgYm9keVxuICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UpO1xuICAgICAgICByZXR1cm4gbmV3IFBhcnNlTm9kZShcInNpemluZ1wiLCB7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc2l6ZSB0byB1c2UgYmFzZWQgb24gdGhlIGxpc3Qgb2YgZnVuY3Rpb25zIGFib3ZlXG4gICAgICAgICAgICBzaXplOiBcInNpemVcIiArICh1dGlscy5pbmRleE9mKHNpemVGdW5jcywgZnVuYykgKyAxKSxcbiAgICAgICAgICAgIHZhbHVlOiBib2R5XG4gICAgICAgIH0sIHRoaXMubW9kZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyhzdHlsZUZ1bmNzLCBmdW5jKSkge1xuICAgICAgICAvLyBJZiB3ZSBzZWUgYSBzdHlsaW5nIGZ1bmN0aW9uLCBwYXJzZSBvdXQgdGhlIGltcGxpY3QgYm9keVxuICAgICAgICBib2R5ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24odHJ1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VOb2RlKFwic3R5bGluZ1wiLCB7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc3R5bGUgdG8gdXNlIGJ5IHB1bGxpbmcgb3V0IHRoZSBzdHlsZSBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgZnVuY3Rpb24gbmFtZVxuICAgICAgICAgICAgc3R5bGU6IGZ1bmMuc2xpY2UoMSwgZnVuYy5sZW5ndGggLSA1KSxcbiAgICAgICAgICAgIHZhbHVlOiBib2R5XG4gICAgICAgIH0sIHRoaXMubW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGVmZXIgdG8gcGFyc2VGdW5jdGlvbiBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uIHdlIGhhbmRsZVxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKHN0YXJ0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhbiBlbnRpcmUgZnVuY3Rpb24sIGluY2x1ZGluZyBpdHMgYmFzZSBhbmQgYWxsIG9mIGl0cyBhcmd1bWVudHMuXG4gKiBUaGUgYmFzZSBtaWdodCBlaXRoZXIgaGF2ZSBiZWVuIHBhcnNlZCBhbHJlYWR5LCBpbiB3aGljaCBjYXNlXG4gKiBpdCBpcyBwcm92aWRlZCBhcyBhbiBhcmd1bWVudCwgb3IgaXQncyB0aGUgbmV4dCBncm91cCBpbiB0aGUgaW5wdXQuXG4gKlxuICogQHBhcmFtIHtQYXJzZUZ1bmNPckFyZ3VtZW50PX0gYmFzZUdyb3VwIG9wdGlvbmFsIGFzIGRlc2NyaWJlZCBhYm92ZVxuICogQHJldHVybiB7P1BhcnNlTm9kZX1cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZ1bmN0aW9uID0gZnVuY3Rpb24oYmFzZUdyb3VwKSB7XG4gICAgaWYgKCFiYXNlR3JvdXApIHtcbiAgICAgICAgYmFzZUdyb3VwID0gdGhpcy5wYXJzZUdyb3VwKCk7XG4gICAgfVxuXG4gICAgaWYgKGJhc2VHcm91cCkge1xuICAgICAgICBpZiAoYmFzZUdyb3VwLmlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBmdW5jID0gYmFzZUdyb3VwLnJlc3VsdDtcbiAgICAgICAgICAgIHZhciBmdW5jRGF0YSA9IGZ1bmN0aW9uc1tmdW5jXTtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGUgPT09IFwidGV4dFwiICYmICFmdW5jRGF0YS5hbGxvd2VkSW5UZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIFwiQ2FuJ3QgdXNlIGZ1bmN0aW9uICdcIiArIGZ1bmMgKyBcIicgaW4gdGV4dCBtb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIGJhc2VHcm91cC50b2tlbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhcmdzID0gdGhpcy5wYXJzZUFyZ3VtZW50cyhmdW5jLCBmdW5jRGF0YSk7XG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBiYXNlR3JvdXAudG9rZW47XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jYWxsRnVuY3Rpb24oZnVuYywgYXJncywgYXJncy5wb3AoKSwgdG9rZW4pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZU5vZGUocmVzdWx0LnR5cGUsIHJlc3VsdCwgdGhpcy5tb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlR3JvdXAucmVzdWx0O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gaGFuZGxlciB3aXRoIGEgc3VpdGFibGUgY29udGV4dCBhbmQgYXJndW1lbnRzLlxuICovXG5QYXJzZXIucHJvdG90eXBlLmNhbGxGdW5jdGlvbiA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3MsIHBvc2l0aW9ucywgdG9rZW4pIHtcbiAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgZnVuY05hbWU6IG5hbWUsXG4gICAgICAgIHBhcnNlcjogdGhpcyxcbiAgICAgICAgcG9zaXRpb25zOiBwb3NpdGlvbnMsXG4gICAgICAgIHRva2VuOiB0b2tlblxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uc1tuYW1lXS5oYW5kbGVyKGNvbnRleHQsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIG9yIGVudmlyb25tZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGZ1bmMgIFwiXFxuYW1lXCIgb3IgXCJcXGJlZ2lue25hbWV9XCJcbiAqIEBwYXJhbSB7e251bUFyZ3M6bnVtYmVyLG51bU9wdGlvbmFsQXJnczpudW1iZXJ8dW5kZWZpbmVkfX0gZnVuY0RhdGFcbiAqIEByZXR1cm4gdGhlIGFycmF5IG9mIGFyZ3VtZW50cywgd2l0aCB0aGUgbGlzdCBvZiBwb3NpdGlvbnMgYXMgbGFzdCBlbGVtZW50XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VBcmd1bWVudHMgPSBmdW5jdGlvbihmdW5jLCBmdW5jRGF0YSkge1xuICAgIHZhciB0b3RhbEFyZ3MgPSBmdW5jRGF0YS5udW1BcmdzICsgZnVuY0RhdGEubnVtT3B0aW9uYWxBcmdzO1xuICAgIGlmICh0b3RhbEFyZ3MgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtbdGhpcy5wb3NdXTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZUdyZWVkaW5lc3MgPSBmdW5jRGF0YS5ncmVlZGluZXNzO1xuICAgIHZhciBwb3NpdGlvbnMgPSBbdGhpcy5wb3NdO1xuICAgIHZhciBhcmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsQXJnczsgaSsrKSB7XG4gICAgICAgIHZhciBuZXh0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICAgICAgdmFyIGFyZ1R5cGUgPSBmdW5jRGF0YS5hcmdUeXBlcyAmJiBmdW5jRGF0YS5hcmdUeXBlc1tpXTtcbiAgICAgICAgdmFyIGFyZztcbiAgICAgICAgaWYgKGkgPCBmdW5jRGF0YS5udW1PcHRpb25hbEFyZ3MpIHtcbiAgICAgICAgICAgIGlmIChhcmdUeXBlKSB7XG4gICAgICAgICAgICAgICAgYXJnID0gdGhpcy5wYXJzZUdyb3VwT2ZUeXBlKGFyZ1R5cGUsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcmcgPSB0aGlzLnBhcnNlR3JvdXAodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMucHVzaCh0aGlzLnBvcyk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnVHlwZSkge1xuICAgICAgICAgICAgICAgIGFyZyA9IHRoaXMucGFyc2VHcm91cE9mVHlwZShhcmdUeXBlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJnID0gdGhpcy5wYXJzZUdyb3VwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXR0aW5ncy50aHJvd09uRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0VG9rZW4udGV4dFswXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gbmV3IFBhcnNlRnVuY09yQXJndW1lbnQoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVVuc3VwcG9ydGVkQ21kKHRoaXMubmV4dFRva2VuLnRleHQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJFeHBlY3RlZCBncm91cCBhZnRlciAnXCIgKyBmdW5jICsgXCInXCIsIG5leHRUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdOb2RlO1xuICAgICAgICBpZiAoYXJnLmlzRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBhcmdHcmVlZGluZXNzID1cbiAgICAgICAgICAgICAgICBmdW5jdGlvbnNbYXJnLnJlc3VsdF0uZ3JlZWRpbmVzcztcbiAgICAgICAgICAgIGlmIChhcmdHcmVlZGluZXNzID4gYmFzZUdyZWVkaW5lc3MpIHtcbiAgICAgICAgICAgICAgICBhcmdOb2RlID0gdGhpcy5wYXJzZUZ1bmN0aW9uKGFyZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkdvdCBmdW5jdGlvbiAnXCIgKyBhcmcucmVzdWx0ICsgXCInIGFzIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJhcmd1bWVudCB0byAnXCIgKyBmdW5jICsgXCInXCIsIG5leHRUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdOb2RlID0gYXJnLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLnB1c2goYXJnTm9kZSk7XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKHRoaXMucG9zKTtcbiAgICB9XG5cbiAgICBhcmdzLnB1c2gocG9zaXRpb25zKTtcblxuICAgIHJldHVybiBhcmdzO1xufTtcblxuXG4vKipcbiAqIFBhcnNlcyBhIGdyb3VwIHdoZW4gdGhlIG1vZGUgaXMgY2hhbmdpbmcuXG4gKlxuICogQHJldHVybiB7P1BhcnNlRnVuY09yQXJndW1lbnR9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VHcm91cE9mVHlwZSA9IGZ1bmN0aW9uKGlubmVyTW9kZSwgb3B0aW9uYWwpIHtcbiAgICB2YXIgb3V0ZXJNb2RlID0gdGhpcy5tb2RlO1xuICAgIC8vIEhhbmRsZSBgb3JpZ2luYWxgIGFyZ1R5cGVzXG4gICAgaWYgKGlubmVyTW9kZSA9PT0gXCJvcmlnaW5hbFwiKSB7XG4gICAgICAgIGlubmVyTW9kZSA9IG91dGVyTW9kZTtcbiAgICB9XG5cbiAgICBpZiAoaW5uZXJNb2RlID09PSBcImNvbG9yXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VDb2xvckdyb3VwKG9wdGlvbmFsKTtcbiAgICB9XG4gICAgaWYgKGlubmVyTW9kZSA9PT0gXCJzaXplXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTaXplR3JvdXAob3B0aW9uYWwpO1xuICAgIH1cblxuICAgIHRoaXMuc3dpdGNoTW9kZShpbm5lck1vZGUpO1xuICAgIGlmIChpbm5lck1vZGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgIC8vIHRleHQgbW9kZSBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgc2hvdWxkIGlnbm9yZSB0aGUgd2hpdGVzcGFjZSBiZWZvcmVcbiAgICAgICAgLy8gaXRcbiAgICAgICAgd2hpbGUgKHRoaXMubmV4dFRva2VuLnRleHQgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCeSB0aGUgdGltZSB3ZSBnZXQgaGVyZSwgaW5uZXJNb2RlIGlzIG9uZSBvZiBcInRleHRcIiBvciBcIm1hdGhcIi5cbiAgICAvLyBXZSBzd2l0Y2ggdGhlIG1vZGUgb2YgdGhlIHBhcnNlciwgcmVjdXJzZSwgdGhlbiByZXN0b3JlIHRoZSBvbGQgbW9kZS5cbiAgICB2YXIgcmVzID0gdGhpcy5wYXJzZUdyb3VwKG9wdGlvbmFsKTtcbiAgICB0aGlzLnN3aXRjaE1vZGUob3V0ZXJNb2RlKTtcbiAgICByZXR1cm4gcmVzO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBncm91cCwgZXNzZW50aWFsbHkgcmV0dXJuaW5nIHRoZSBzdHJpbmcgZm9ybWVkIGJ5IHRoZVxuICogYnJhY2UtZW5jbG9zZWQgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kZU5hbWUgIFVzZWQgdG8gZGVzY3JpYmUgdGhlIG1vZGUgaW4gZXJyb3IgbWVzc2FnZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wdGlvbmFsICBXaGV0aGVyIHRoZSBncm91cCBpcyBvcHRpb25hbCBvciByZXF1aXJlZFxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nR3JvdXAgPSBmdW5jdGlvbihtb2RlTmFtZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAob3B0aW9uYWwgJiYgdGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gXCJbXCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBvdXRlck1vZGUgPSB0aGlzLm1vZGU7XG4gICAgdGhpcy5tb2RlID0gXCJ0ZXh0XCI7XG4gICAgdGhpcy5leHBlY3Qob3B0aW9uYWwgPyBcIltcIiA6IFwie1wiKTtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgZmlyc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgIHZhciBsYXN0VG9rZW4gPSBmaXJzdFRva2VuO1xuICAgIHdoaWxlICh0aGlzLm5leHRUb2tlbi50ZXh0ICE9PSAob3B0aW9uYWwgPyBcIl1cIiA6IFwifVwiKSkge1xuICAgICAgICBpZiAodGhpcy5uZXh0VG9rZW4udGV4dCA9PT0gXCJFT0ZcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCBpbiBcIiArIG1vZGVOYW1lLFxuICAgICAgICAgICAgICAgIGZpcnN0VG9rZW4ucmFuZ2UodGhpcy5uZXh0VG9rZW4sIHN0cikpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgICAgICBzdHIgKz0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgICB0aGlzLm1vZGUgPSBvdXRlck1vZGU7XG4gICAgdGhpcy5leHBlY3Qob3B0aW9uYWwgPyBcIl1cIiA6IFwifVwiKTtcbiAgICByZXR1cm4gZmlyc3RUb2tlbi5yYW5nZShsYXN0VG9rZW4sIHN0cik7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHJlZ2V4LWRlbGltaXRlZCBncm91cDogdGhlIGxhcmdlc3Qgc2VxdWVuY2Ugb2YgdG9rZW5zXG4gKiB3aG9zZSBjb25jYXRlbmF0ZWQgc3RyaW5ncyBtYXRjaCBgcmVnZXhgLiBSZXR1cm5zIHRoZSBzdHJpbmdcbiAqIGZvcm1lZCBieSB0aGUgdG9rZW5zIHBsdXMgc29tZSBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlTmFtZSAgVXNlZCB0byBkZXNjcmliZSB0aGUgbW9kZSBpbiBlcnJvciBtZXNzYWdlc1xuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlUmVnZXhHcm91cCA9IGZ1bmN0aW9uKHJlZ2V4LCBtb2RlTmFtZSkge1xuICAgIHZhciBvdXRlck1vZGUgPSB0aGlzLm1vZGU7XG4gICAgdGhpcy5tb2RlID0gXCJ0ZXh0XCI7XG4gICAgdmFyIGZpcnN0VG9rZW4gPSB0aGlzLm5leHRUb2tlbjtcbiAgICB2YXIgbGFzdFRva2VuID0gZmlyc3RUb2tlbjtcbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB3aGlsZSAodGhpcy5uZXh0VG9rZW4udGV4dCAhPT0gXCJFT0ZcIlxuICAgICAgICAgICAmJiByZWdleC50ZXN0KHN0ciArIHRoaXMubmV4dFRva2VuLnRleHQpKSB7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgICAgICBzdHIgKz0gbGFzdFRva2VuLnRleHQ7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgIH1cbiAgICBpZiAoc3RyID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgXCJJbnZhbGlkIFwiICsgbW9kZU5hbWUgKyBcIjogJ1wiICsgZmlyc3RUb2tlbi50ZXh0ICsgXCInXCIsXG4gICAgICAgICAgICBmaXJzdFRva2VuKTtcbiAgICB9XG4gICAgdGhpcy5tb2RlID0gb3V0ZXJNb2RlO1xuICAgIHJldHVybiBmaXJzdFRva2VuLnJhbmdlKGxhc3RUb2tlbiwgc3RyKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgY29sb3IgZGVzY3JpcHRpb24uXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VDb2xvckdyb3VwID0gZnVuY3Rpb24ob3B0aW9uYWwpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5wYXJzZVN0cmluZ0dyb3VwKFwiY29sb3JcIiwgb3B0aW9uYWwpO1xuICAgIGlmICghcmVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbWF0Y2ggPSAoL14oI1thLXowLTldK3xbYS16XSspJC9pKS5leGVjKHJlcy50ZXh0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBjb2xvcjogJ1wiICsgcmVzLnRleHQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICBuZXcgUGFyc2VOb2RlKFwiY29sb3JcIiwgbWF0Y2hbMF0sIHRoaXMubW9kZSksXG4gICAgICAgIGZhbHNlKTtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2l6ZSBzcGVjaWZpY2F0aW9uLCBjb25zaXN0aW5nIG9mIG1hZ25pdHVkZSBhbmQgdW5pdC5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNpemVHcm91cCA9IGZ1bmN0aW9uKG9wdGlvbmFsKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAoIW9wdGlvbmFsICYmIHRoaXMubmV4dFRva2VuLnRleHQgIT09IFwie1wiKSB7XG4gICAgICAgIHJlcyA9IHRoaXMucGFyc2VSZWdleEdyb3VwKFxuICAgICAgICAgICAgL15bLStdPyAqKD86JHxcXGQrfFxcZCtcXC5cXGQqfFxcLlxcZCopICpbYS16XXswLDJ9JC8sIFwic2l6ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoXCJzaXplXCIsIG9wdGlvbmFsKTtcbiAgICB9XG4gICAgaWYgKCFyZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBtYXRjaCA9ICgvKFstK10/KSAqKFxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykgKihbYS16XXsyfSkvKS5leGVjKHJlcy50ZXh0KTtcbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCBzaXplOiAnXCIgKyByZXMudGV4dCArIFwiJ1wiLCByZXMpO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgbnVtYmVyOiArKG1hdGNoWzFdICsgbWF0Y2hbMl0pLCAvLyBzaWduICsgbWFnbml0dWRlLCBjYXN0IHRvIG51bWJlclxuICAgICAgICB1bml0OiBtYXRjaFszXVxuICAgIH07XG4gICAgaWYgKGRhdGEudW5pdCAhPT0gXCJlbVwiICYmIGRhdGEudW5pdCAhPT0gXCJleFwiICYmIGRhdGEudW5pdCAhPT0gXCJtdVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSW52YWxpZCB1bml0OiAnXCIgKyBkYXRhLnVuaXQgKyBcIidcIiwgcmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICBuZXcgUGFyc2VOb2RlKFwiY29sb3JcIiwgZGF0YSwgdGhpcy5tb2RlKSxcbiAgICAgICAgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgZmFsc2Ugb3IgYWJzZW50LCB0aGlzIHBhcnNlcyBhbiBvcmRpbmFyeSBncm91cCxcbiAqIHdoaWNoIGlzIGVpdGhlciBhIHNpbmdsZSBudWNsZXVzIChsaWtlIFwieFwiKSBvciBhbiBleHByZXNzaW9uXG4gKiBpbiBicmFjZXMgKGxpa2UgXCJ7eCt5fVwiKS5cbiAqIElmIHRoZSBhcmd1bWVudCBpcyB0cnVlLCBpdCBwYXJzZXMgZWl0aGVyIGEgYnJhY2tldC1kZWxpbWl0ZWQgZXhwcmVzc2lvblxuICogKGxpa2UgXCJbeCt5XVwiKSBvciByZXR1cm5zIG51bGwgdG8gaW5kaWNhdGUgdGhlIGFic2VuY2Ugb2YgYVxuICogYnJhY2tldC1lbmNsb3NlZCBncm91cC5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRpb25hbCAgV2hldGhlciB0aGUgZ3JvdXAgaXMgb3B0aW9uYWwgb3IgcmVxdWlyZWRcbiAqIEByZXR1cm4gez9QYXJzZUZ1bmNPckFyZ3VtZW50fVxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlR3JvdXAgPSBmdW5jdGlvbihvcHRpb25hbCkge1xuICAgIHZhciBmaXJzdFRva2VuID0gdGhpcy5uZXh0VG9rZW47XG4gICAgLy8gVHJ5IHRvIHBhcnNlIGFuIG9wZW4gYnJhY2VcbiAgICBpZiAodGhpcy5uZXh0VG9rZW4udGV4dCA9PT0gKG9wdGlvbmFsID8gXCJbXCIgOiBcIntcIikpIHtcbiAgICAgICAgLy8gSWYgd2UgZ2V0IGEgYnJhY2UsIHBhcnNlIGFuIGV4cHJlc3Npb25cbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIG9wdGlvbmFsID8gXCJdXCIgOiBudWxsKTtcbiAgICAgICAgdmFyIGxhc3RUb2tlbiA9IHRoaXMubmV4dFRva2VuO1xuICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZ2V0IGEgY2xvc2UgYnJhY2VcbiAgICAgICAgdGhpcy5leHBlY3Qob3B0aW9uYWwgPyBcIl1cIiA6IFwifVwiKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUxpZ2F0dXJlcyhleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlRnVuY09yQXJndW1lbnQoXG4gICAgICAgICAgICBuZXcgUGFyc2VOb2RlKFwib3JkZ3JvdXBcIiwgZXhwcmVzc2lvbiwgdGhpcy5tb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFRva2VuLCBsYXN0VG9rZW4pLFxuICAgICAgICAgICAgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwganVzdCByZXR1cm4gYSBudWNsZXVzLCBvciBub3RoaW5nIGZvciBhbiBvcHRpb25hbCBncm91cFxuICAgICAgICByZXR1cm4gb3B0aW9uYWwgPyBudWxsIDogdGhpcy5wYXJzZVN5bWJvbCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRm9ybSBsaWdhdHVyZS1saWtlIGNvbWJpbmF0aW9ucyBvZiBjaGFyYWN0ZXJzIGZvciB0ZXh0IG1vZGUuXG4gKiBUaGlzIGluY2x1ZGVzIGlucHV0cyBsaWtlIFwiLS1cIiwgXCItLS1cIiwgXCJgYFwiIGFuZCBcIicnXCIuXG4gKiBUaGUgcmVzdWx0IHdpbGwgc2ltcGx5IHJlcGxhY2UgbXVsdGlwbGUgdGV4dG9yZCBub2RlcyB3aXRoIGEgc2luZ2xlXG4gKiBjaGFyYWN0ZXIgaW4gZWFjaCB2YWx1ZSBieSBhIHNpbmdsZSB0ZXh0b3JkIG5vZGUgaGF2aW5nIG11bHRpcGxlXG4gKiBjaGFyYWN0ZXJzIGluIGl0cyB2YWx1ZS4gIFRoZSByZXByZXNlbnRhdGlvbiBpcyBzdGlsbCBBU0NJSSBzb3VyY2UuXG4gKlxuICogQHBhcmFtIHtBcnJheS48UGFyc2VOb2RlPn0gZ3JvdXAgIHRoZSBub2RlcyBvZiB0aGlzIGdyb3VwLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Qgd2lsbCBiZSBtb2lmaWVkIGluIHBsYWNlXG4gKi9cblBhcnNlci5wcm90b3R5cGUuZm9ybUxpZ2F0dXJlcyA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIG4gPSBncm91cC5sZW5ndGggLSAxO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdmFyIGEgPSBncm91cFtpXTtcbiAgICAgICAgdmFyIHYgPSBhLnZhbHVlO1xuICAgICAgICBpZiAodiA9PT0gXCItXCIgJiYgZ3JvdXBbaSArIDFdLnZhbHVlID09PSBcIi1cIikge1xuICAgICAgICAgICAgaWYgKGkgKyAxIDwgbiAmJiBncm91cFtpICsgMl0udmFsdWUgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDMsIG5ldyBQYXJzZU5vZGUoXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dG9yZFwiLCBcIi0tLVwiLCBcInRleHRcIiwgYSwgZ3JvdXBbaSArIDJdKSk7XG4gICAgICAgICAgICAgICAgbiAtPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBncm91cC5zcGxpY2UoaSwgMiwgbmV3IFBhcnNlTm9kZShcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0b3JkXCIsIFwiLS1cIiwgXCJ0ZXh0XCIsIGEsIGdyb3VwW2kgKyAxXSkpO1xuICAgICAgICAgICAgICAgIG4gLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoKHYgPT09IFwiJ1wiIHx8IHYgPT09IFwiYFwiKSAmJiBncm91cFtpICsgMV0udmFsdWUgPT09IHYpIHtcbiAgICAgICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCBuZXcgUGFyc2VOb2RlKFxuICAgICAgICAgICAgICAgIFwidGV4dG9yZFwiLCB2ICsgdiwgXCJ0ZXh0XCIsIGEsIGdyb3VwW2kgKyAxXSkpO1xuICAgICAgICAgICAgbiAtPSAxO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBQYXJzZSBhIHNpbmdsZSBzeW1ib2wgb3V0IG9mIHRoZSBzdHJpbmcuIEhlcmUsIHdlIGhhbmRsZSBib3RoIHRoZSBmdW5jdGlvbnNcbiAqIHdlIGhhdmUgZGVmaW5lZCwgYXMgd2VsbCBhcyB0aGUgc2luZ2xlIGNoYXJhY3RlciBzeW1ib2xzXG4gKlxuICogQHJldHVybiB7P1BhcnNlRnVuY09yQXJndW1lbnR9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VTeW1ib2wgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbnVjbGV1cyA9IHRoaXMubmV4dFRva2VuO1xuXG4gICAgaWYgKGZ1bmN0aW9uc1tudWNsZXVzLnRleHRdKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZSgpO1xuICAgICAgICAvLyBJZiB0aGVyZSBleGlzdHMgYSBmdW5jdGlvbiB3aXRoIHRoaXMgbmFtZSwgd2UgcmV0dXJuIHRoZSBmdW5jdGlvbiBhbmRcbiAgICAgICAgLy8gc2F5IHRoYXQgaXQgaXMgYSBmdW5jdGlvbi5cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICAgICAgbnVjbGV1cy50ZXh0LFxuICAgICAgICAgICAgdHJ1ZSwgbnVjbGV1cyk7XG4gICAgfSBlbHNlIGlmIChzeW1ib2xzW3RoaXMubW9kZV1bbnVjbGV1cy50ZXh0XSkge1xuICAgICAgICB0aGlzLmNvbnN1bWUoKTtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGlmIHRoaXMgaXMgYSBuby1hcmd1bWVudCBmdW5jdGlvbiwgZmluZCB0aGUgdHlwZSBpdFxuICAgICAgICAvLyBjb3JyZXNwb25kcyB0byBpbiB0aGUgc3ltYm9scyBtYXBcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUZ1bmNPckFyZ3VtZW50KFxuICAgICAgICAgICAgbmV3IFBhcnNlTm9kZShzeW1ib2xzW3RoaXMubW9kZV1bbnVjbGV1cy50ZXh0XS5ncm91cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbnVjbGV1cy50ZXh0LCB0aGlzLm1vZGUsIG51Y2xldXMpLFxuICAgICAgICAgICAgZmFsc2UsIG51Y2xldXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBcInRleHRcIiAmJiBjamtSZWdleC50ZXN0KG51Y2xldXMudGV4dCkpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lKCk7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VGdW5jT3JBcmd1bWVudChcbiAgICAgICAgICAgIG5ldyBQYXJzZU5vZGUoXCJ0ZXh0b3JkXCIsIG51Y2xldXMudGV4dCwgdGhpcy5tb2RlLCBudWNsZXVzKSxcbiAgICAgICAgICAgIGZhbHNlLCBudWNsZXVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLlBhcnNlTm9kZSA9IFBhcnNlTm9kZTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXI7XG4iLCIvKipcbiAqIFRoaXMgaXMgYSBtb2R1bGUgZm9yIHN0b3Jpbmcgc2V0dGluZ3MgcGFzc2VkIGludG8gS2FUZVguIEl0IGNvcnJlY3RseSBoYW5kbGVzXG4gKiBkZWZhdWx0IHNldHRpbmdzLlxuICovXG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciBnZXR0aW5nIGEgZGVmYXVsdCB2YWx1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGdldChvcHRpb24sIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBvcHRpb24gPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IG9wdGlvbjtcbn1cblxuLyoqXG4gKiBUaGUgbWFpbiBTZXR0aW5ncyBvYmplY3RcbiAqXG4gKiBUaGUgY3VycmVudCBvcHRpb25zIHN0b3JlZCBhcmU6XG4gKiAgLSBkaXNwbGF5TW9kZTogV2hldGhlciB0aGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgdHlwZXNldCBieSBkZWZhdWx0IGluXG4gKiAgICAgICAgICAgICAgICAgdGV4dHN0eWxlIG9yIGRpc3BsYXlzdHlsZSAoZGVmYXVsdCBmYWxzZSlcbiAqL1xuZnVuY3Rpb24gU2V0dGluZ3Mob3B0aW9ucykge1xuICAgIC8vIGFsbG93IG51bGwgb3B0aW9uc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuZGlzcGxheU1vZGUgPSBnZXQob3B0aW9ucy5kaXNwbGF5TW9kZSwgZmFsc2UpO1xuICAgIHRoaXMudGhyb3dPbkVycm9yID0gZ2V0KG9wdGlvbnMudGhyb3dPbkVycm9yLCB0cnVlKTtcbiAgICB0aGlzLmVycm9yQ29sb3IgPSBnZXQob3B0aW9ucy5lcnJvckNvbG9yLCBcIiNjYzAwMDBcIik7XG4gICAgdGhpcy5tYWNyb3MgPSBvcHRpb25zLm1hY3JvcyB8fCB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTZXR0aW5ncztcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFuZCBjbGFzc2VzIGZvciB0aGUgdmFyaW91cyBraW5kcyBvZiBzdHlsZXNcbiAqIHVzZWQgaW4gVGVYLiBJdCBwcm92aWRlcyBhIGdlbmVyaWMgYFN0eWxlYCBjbGFzcywgd2hpY2ggaG9sZHMgaW5mb3JtYXRpb25cbiAqIGFib3V0IGEgc3BlY2lmaWMgc3R5bGUuIEl0IHRoZW4gcHJvdmlkZXMgaW5zdGFuY2VzIG9mIGFsbCB0aGUgZGlmZmVyZW50IGtpbmRzXG4gKiBvZiBzdHlsZXMgcG9zc2libGUsIGFuZCBwcm92aWRlcyBmdW5jdGlvbnMgdG8gbW92ZSBiZXR3ZWVuIHRoZW0gYW5kIGdldFxuICogaW5mb3JtYXRpb24gYWJvdXQgdGhlbS5cbiAqL1xuXG52YXIgc2lnbWFzID0gcmVxdWlyZShcIi4vZm9udE1ldHJpY3MuanNcIikuc2lnbWFzO1xuXG52YXIgbWV0cmljcyA9IFt7fSwge30sIHt9XTtcbnZhciBpO1xuZm9yICh2YXIga2V5IGluIHNpZ21hcykge1xuICAgIGlmIChzaWdtYXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICBtZXRyaWNzW2ldW2tleV0gPSBzaWdtYXNba2V5XVtpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBtZXRyaWNzW2ldLmVtUGVyRXggPSBzaWdtYXMueEhlaWdodFtpXSAvIHNpZ21hcy5xdWFkW2ldO1xufVxuXG4vKipcbiAqIFRoZSBtYWluIHN0eWxlIGNsYXNzLiBDb250YWlucyBhIHVuaXF1ZSBpZCBmb3IgdGhlIHN0eWxlLCBhIHNpemUgKHdoaWNoIGlzXG4gKiB0aGUgc2FtZSBmb3IgY3JhbXBlZCBhbmQgdW5jcmFtcGVkIHZlcnNpb24gb2YgYSBzdHlsZSksIGEgY3JhbXBlZCBmbGFnLCBhbmQgYVxuICogc2l6ZSBtdWx0aXBsaWVyLCB3aGljaCBnaXZlcyB0aGUgc2l6ZSBkaWZmZXJlbmNlIGJldHdlZW4gYSBzdHlsZSBhbmRcbiAqIHRleHRzdHlsZS5cbiAqL1xuZnVuY3Rpb24gU3R5bGUoaWQsIHNpemUsIG11bHRpcGxpZXIsIGNyYW1wZWQpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICB0aGlzLmNyYW1wZWQgPSBjcmFtcGVkO1xuICAgIHRoaXMuc2l6ZU11bHRpcGxpZXIgPSBtdWx0aXBsaWVyO1xuICAgIHRoaXMubWV0cmljcyA9IG1ldHJpY3Nbc2l6ZSA+IDAgPyBzaXplIC0gMSA6IDBdO1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3R5bGUgb2YgYSBzdXBlcnNjcmlwdCBnaXZlbiBhIGJhc2UgaW4gdGhlIGN1cnJlbnQgc3R5bGUuXG4gKi9cblN0eWxlLnByb3RvdHlwZS5zdXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3R5bGVzW3N1cFt0aGlzLmlkXV07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3R5bGUgb2YgYSBzdWJzY3JpcHQgZ2l2ZW4gYSBiYXNlIGluIHRoZSBjdXJyZW50IHN0eWxlLlxuICovXG5TdHlsZS5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tzdWJbdGhpcy5pZF1dO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHN0eWxlIG9mIGEgZnJhY3Rpb24gbnVtZXJhdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudFxuICogc3R5bGUuXG4gKi9cblN0eWxlLnByb3RvdHlwZS5mcmFjTnVtID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tmcmFjTnVtW3RoaXMuaWRdXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBzdHlsZSBvZiBhIGZyYWN0aW9uIGRlbm9taW5hdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudFxuICogc3R5bGUuXG4gKi9cblN0eWxlLnByb3RvdHlwZS5mcmFjRGVuID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHN0eWxlc1tmcmFjRGVuW3RoaXMuaWRdXTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBjcmFtcGVkIHZlcnNpb24gb2YgYSBzdHlsZSAoaW4gcGFydGljdWxhciwgY3JhbXBpbmcgYSBjcmFtcGVkIHN0eWxlXG4gKiBkb2Vzbid0IGNoYW5nZSB0aGUgc3R5bGUpLlxuICovXG5TdHlsZS5wcm90b3R5cGUuY3JhbXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc3R5bGVzW2NyYW1wW3RoaXMuaWRdXTtcbn07XG5cbi8qKlxuICogSFRNTCBjbGFzcyBuYW1lLCBsaWtlIFwiZGlzcGxheXN0eWxlIGNyYW1wZWRcIlxuICovXG5TdHlsZS5wcm90b3R5cGUuY2xzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNpemVOYW1lc1t0aGlzLnNpemVdICsgKHRoaXMuY3JhbXBlZCA/IFwiIGNyYW1wZWRcIiA6IFwiIHVuY3JhbXBlZFwiKTtcbn07XG5cbi8qKlxuICogSFRNTCBSZXNldCBjbGFzcyBuYW1lLCBsaWtlIFwicmVzZXQtdGV4dHN0eWxlXCJcbiAqL1xuU3R5bGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHJlc2V0TmFtZXNbdGhpcy5zaXplXTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGlmIHRoaXMgc3R5bGUgaXMgdGlnaHRseSBzcGFjZWQgKHNjcmlwdHN0eWxlL3NjcmlwdHNjcmlwdHN0eWxlKVxuICovXG5TdHlsZS5wcm90b3R5cGUuaXNUaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUgPj0gMjtcbn07XG5cbi8vIElEcyBvZiB0aGUgZGlmZmVyZW50IHN0eWxlc1xudmFyIEQgPSAwO1xudmFyIERjID0gMTtcbnZhciBUID0gMjtcbnZhciBUYyA9IDM7XG52YXIgUyA9IDQ7XG52YXIgU2MgPSA1O1xudmFyIFNTID0gNjtcbnZhciBTU2MgPSA3O1xuXG4vLyBTdHJpbmcgbmFtZXMgZm9yIHRoZSBkaWZmZXJlbnQgc2l6ZXNcbnZhciBzaXplTmFtZXMgPSBbXG4gICAgXCJkaXNwbGF5c3R5bGUgdGV4dHN0eWxlXCIsXG4gICAgXCJ0ZXh0c3R5bGVcIixcbiAgICBcInNjcmlwdHN0eWxlXCIsXG4gICAgXCJzY3JpcHRzY3JpcHRzdHlsZVwiXG5dO1xuXG4vLyBSZXNldCBuYW1lcyBmb3IgdGhlIGRpZmZlcmVudCBzaXplc1xudmFyIHJlc2V0TmFtZXMgPSBbXG4gICAgXCJyZXNldC10ZXh0c3R5bGVcIixcbiAgICBcInJlc2V0LXRleHRzdHlsZVwiLFxuICAgIFwicmVzZXQtc2NyaXB0c3R5bGVcIixcbiAgICBcInJlc2V0LXNjcmlwdHNjcmlwdHN0eWxlXCJcbl07XG5cbi8vIEluc3RhbmNlcyBvZiB0aGUgZGlmZmVyZW50IHN0eWxlc1xudmFyIHN0eWxlcyA9IFtcbiAgICBuZXcgU3R5bGUoRCwgMCwgMS4wLCBmYWxzZSksXG4gICAgbmV3IFN0eWxlKERjLCAwLCAxLjAsIHRydWUpLFxuICAgIG5ldyBTdHlsZShULCAxLCAxLjAsIGZhbHNlKSxcbiAgICBuZXcgU3R5bGUoVGMsIDEsIDEuMCwgdHJ1ZSksXG4gICAgbmV3IFN0eWxlKFMsIDIsIDAuNywgZmFsc2UpLFxuICAgIG5ldyBTdHlsZShTYywgMiwgMC43LCB0cnVlKSxcbiAgICBuZXcgU3R5bGUoU1MsIDMsIDAuNSwgZmFsc2UpLFxuICAgIG5ldyBTdHlsZShTU2MsIDMsIDAuNSwgdHJ1ZSlcbl07XG5cbi8vIExvb2t1cCB0YWJsZXMgZm9yIHN3aXRjaGluZyBmcm9tIG9uZSBzdHlsZSB0byBhbm90aGVyXG52YXIgc3VwID0gW1MsIFNjLCBTLCBTYywgU1MsIFNTYywgU1MsIFNTY107XG52YXIgc3ViID0gW1NjLCBTYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xudmFyIGZyYWNOdW0gPSBbVCwgVGMsIFMsIFNjLCBTUywgU1NjLCBTUywgU1NjXTtcbnZhciBmcmFjRGVuID0gW1RjLCBUYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdO1xudmFyIGNyYW1wID0gW0RjLCBEYywgVGMsIFRjLCBTYywgU2MsIFNTYywgU1NjXTtcblxuLy8gV2Ugb25seSBleHBvcnQgc29tZSBvZiB0aGUgc3R5bGVzLiBBbHNvLCB3ZSBkb24ndCBleHBvcnQgdGhlIGBTdHlsZWAgY2xhc3Mgc29cbi8vIG5vIG1vcmUgc3R5bGVzIGNhbiBiZSBnZW5lcmF0ZWQuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBESVNQTEFZOiBzdHlsZXNbRF0sXG4gICAgVEVYVDogc3R5bGVzW1RdLFxuICAgIFNDUklQVDogc3R5bGVzW1NdLFxuICAgIFNDUklQVFNDUklQVDogc3R5bGVzW1NTXVxufTtcbiIsIi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbi8qKlxuICogVGhpcyBtb2R1bGUgY29udGFpbnMgZ2VuZXJhbCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgYnVpbGRpbmdcbiAqIGRpZmZlcmVudCBraW5kcyBvZiBkb21UcmVlIG5vZGVzIGluIGEgY29uc2lzdGVudCBtYW5uZXIuXG4gKi9cblxudmFyIGRvbVRyZWUgPSByZXF1aXJlKFwiLi9kb21UcmVlXCIpO1xudmFyIGZvbnRNZXRyaWNzID0gcmVxdWlyZShcIi4vZm9udE1ldHJpY3NcIik7XG52YXIgc3ltYm9scyA9IHJlcXVpcmUoXCIuL3N5bWJvbHNcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcblxudmFyIGdyZWVrQ2FwaXRhbHMgPSBbXG4gICAgXCJcXFxcR2FtbWFcIixcbiAgICBcIlxcXFxEZWx0YVwiLFxuICAgIFwiXFxcXFRoZXRhXCIsXG4gICAgXCJcXFxcTGFtYmRhXCIsXG4gICAgXCJcXFxcWGlcIixcbiAgICBcIlxcXFxQaVwiLFxuICAgIFwiXFxcXFNpZ21hXCIsXG4gICAgXCJcXFxcVXBzaWxvblwiLFxuICAgIFwiXFxcXFBoaVwiLFxuICAgIFwiXFxcXFBzaVwiLFxuICAgIFwiXFxcXE9tZWdhXCJcbl07XG5cbi8vIFRoZSBmb2xsb3dpbmcgaGF2ZSB0byBiZSBsb2FkZWQgZnJvbSBNYWluLUl0YWxpYyBmb250LCB1c2luZyBjbGFzcyBtYWluaXRcbnZhciBtYWluaXRMZXR0ZXJzID0gW1xuICAgIFwiXFx1MDEzMVwiLCAgIC8vIGRvdGxlc3MgaSwgXFxpbWF0aFxuICAgIFwiXFx1MDIzN1wiLCAgIC8vIGRvdGxlc3MgaiwgXFxqbWF0aFxuICAgIFwiXFx1MDBhM1wiICAgLy8gXFxwb3VuZHNcbl07XG5cbi8qKlxuICogTWFrZXMgYSBzeW1ib2xOb2RlIGFmdGVyIHRyYW5zbGF0aW9uIHZpYSB0aGUgbGlzdCBvZiBzeW1ib2xzIGluIHN5bWJvbHMuanMuXG4gKiBDb3JyZWN0bHkgcHVsbHMgb3V0IG1ldHJpY3MgZm9yIHRoZSBjaGFyYWN0ZXIsIGFuZCBvcHRpb25hbGx5IHRha2VzIGEgbGlzdCBvZlxuICogY2xhc3NlcyB0byBiZSBhdHRhY2hlZCB0byB0aGUgbm9kZS5cbiAqXG4gKiBUT0RPOiBtYWtlIGFyZ3VtZW50IG9yZGVyIGNsb3NlciB0byBtYWtlU3BhblxuICogVE9ETzogYWRkIGEgc2VwYXJhdGUgYXJndW1lbnQgZm9yIG1hdGggY2xhc3MgKGUuZy4gYG1vcGAsIGBtYmluYCksIHdoaWNoXG4gKiBzaG91bGQgaWYgcHJlc2VudCBjb21lIGZpcnN0IGluIGBjbGFzc2VzYC5cbiAqL1xudmFyIG1ha2VTeW1ib2wgPSBmdW5jdGlvbih2YWx1ZSwgZm9udEZhbWlseSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICAgIC8vIFJlcGxhY2UgdGhlIHZhbHVlIHdpdGggaXRzIHJlcGxhY2VkIHZhbHVlIGZyb20gc3ltYm9sLmpzXG4gICAgaWYgKHN5bWJvbHNbbW9kZV1bdmFsdWVdICYmIHN5bWJvbHNbbW9kZV1bdmFsdWVdLnJlcGxhY2UpIHtcbiAgICAgICAgdmFsdWUgPSBzeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlO1xuICAgIH1cblxuICAgIHZhciBtZXRyaWNzID0gZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljcyh2YWx1ZSwgZm9udEZhbWlseSk7XG5cbiAgICB2YXIgc3ltYm9sTm9kZTtcbiAgICBpZiAobWV0cmljcykge1xuICAgICAgICB2YXIgaXRhbGljID0gbWV0cmljcy5pdGFsaWM7XG4gICAgICAgIGlmIChtb2RlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgaXRhbGljID0gMDtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2xOb2RlID0gbmV3IGRvbVRyZWUuc3ltYm9sTm9kZShcbiAgICAgICAgICAgIHZhbHVlLCBtZXRyaWNzLmhlaWdodCwgbWV0cmljcy5kZXB0aCwgaXRhbGljLCBtZXRyaWNzLnNrZXcsXG4gICAgICAgICAgICBjbGFzc2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPKGVtaWx5KTogRmlndXJlIG91dCBhIGdvb2Qgd2F5IHRvIG9ubHkgcHJpbnQgdGhpcyBpbiBkZXZlbG9wbWVudFxuICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcIk5vIGNoYXJhY3RlciBtZXRyaWNzIGZvciAnXCIgKyB2YWx1ZSArIFwiJyBpbiBzdHlsZSAnXCIgK1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgKyBcIidcIik7XG4gICAgICAgIHN5bWJvbE5vZGUgPSBuZXcgZG9tVHJlZS5zeW1ib2xOb2RlKHZhbHVlLCAwLCAwLCAwLCAwLCBjbGFzc2VzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5zdHlsZS5pc1RpZ2h0KCkpIHtcbiAgICAgICAgICAgIHN5bWJvbE5vZGUuY2xhc3Nlcy5wdXNoKFwibXRpZ2h0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmdldENvbG9yKCkpIHtcbiAgICAgICAgICAgIHN5bWJvbE5vZGUuc3R5bGUuY29sb3IgPSBvcHRpb25zLmdldENvbG9yKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3ltYm9sTm9kZTtcbn07XG5cbi8qKlxuICogTWFrZXMgYSBzeW1ib2wgaW4gTWFpbi1SZWd1bGFyIG9yIEFNUy1SZWd1bGFyLlxuICogVXNlZCBmb3IgcmVsLCBiaW4sIG9wZW4sIGNsb3NlLCBpbm5lciwgYW5kIHB1bmN0LlxuICovXG52YXIgbWF0aHN5bSA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzKSB7XG4gICAgLy8gRGVjaWRlIHdoYXQgZm9udCB0byByZW5kZXIgdGhlIHN5bWJvbCBpbiBieSBpdHMgZW50cnkgaW4gdGhlIHN5bWJvbHNcbiAgICAvLyB0YWJsZS5cbiAgICAvLyBIYXZlIGEgc3BlY2lhbCBjYXNlIGZvciB3aGVuIHRoZSB2YWx1ZSA9IFxcIGJlY2F1c2UgdGhlIFxcIGlzIHVzZWQgYXMgYVxuICAgIC8vIHRleHRvcmQgaW4gdW5zdXBwb3J0ZWQgY29tbWFuZCBlcnJvcnMgYnV0IGNhbm5vdCBiZSBwYXJzZWQgYXMgYSByZWd1bGFyXG4gICAgLy8gdGV4dCBvcmRpbmFsIGFuZCBpcyB0aGVyZWZvcmUgbm90IHByZXNlbnQgYXMgYSBzeW1ib2wgaW4gdGhlIHN5bWJvbHNcbiAgICAvLyB0YWJsZSBmb3IgdGV4dFxuICAgIGlmICh2YWx1ZSA9PT0gXCJcXFxcXCIgfHwgc3ltYm9sc1ttb2RlXVt2YWx1ZV0uZm9udCA9PT0gXCJtYWluXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTeW1ib2wodmFsdWUsIFwiTWFpbi1SZWd1bGFyXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYWtlU3ltYm9sKFxuICAgICAgICAgICAgdmFsdWUsIFwiQU1TLVJlZ3VsYXJcIiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoW1wiYW1zcm1cIl0pKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2VzIGEgc3ltYm9sIGluIHRoZSBkZWZhdWx0IGZvbnQgZm9yIG1hdGhvcmRzIGFuZCB0ZXh0b3Jkcy5cbiAqL1xudmFyIG1hdGhEZWZhdWx0ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJtYXRob3JkXCIpIHtcbiAgICAgICAgcmV0dXJuIG1hdGhpdCh2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcInRleHRvcmRcIikge1xuICAgICAgICByZXR1cm4gbWFrZVN5bWJvbChcbiAgICAgICAgICAgIHZhbHVlLCBcIk1haW4tUmVndWxhclwiLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbXCJtYXRocm1cIl0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIHR5cGU6IFwiICsgdHlwZSArIFwiIGluIG1hdGhEZWZhdWx0XCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTWFrZXMgYSBzeW1ib2wgaW4gdGhlIGl0YWxpYyBtYXRoIGZvbnQuXG4gKi9cbnZhciBtYXRoaXQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICAgIGlmICgvWzAtOV0vLnRlc3QodmFsdWUuY2hhckF0KDApKSB8fFxuICAgICAgICAgICAgLy8gZ2x5cGhzIGZvciBcXGltYXRoIGFuZCBcXGptYXRoIGRvIG5vdCBleGlzdCBpbiBNYXRoLUl0YWxpYyBzbyB3ZVxuICAgICAgICAgICAgLy8gbmVlZCB0byB1c2UgTWFpbi1JdGFsaWMgaW5zdGVhZFxuICAgICAgICAgICAgdXRpbHMuY29udGFpbnMobWFpbml0TGV0dGVycywgdmFsdWUpIHx8XG4gICAgICAgICAgICB1dGlscy5jb250YWlucyhncmVla0NhcGl0YWxzLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTeW1ib2woXG4gICAgICAgICAgICB2YWx1ZSwgXCJNYWluLUl0YWxpY1wiLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbXCJtYWluaXRcIl0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWFrZVN5bWJvbChcbiAgICAgICAgICAgIHZhbHVlLCBcIk1hdGgtSXRhbGljXCIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFtcIm1hdGhpdFwiXSkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTWFrZXMgZWl0aGVyIGEgbWF0aG9yZCBvciB0ZXh0b3JkIGluIHRoZSBjb3JyZWN0IGZvbnQgYW5kIGNvbG9yLlxuICovXG52YXIgbWFrZU9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zLCB0eXBlKSB7XG4gICAgdmFyIG1vZGUgPSBncm91cC5tb2RlO1xuICAgIHZhciB2YWx1ZSA9IGdyb3VwLnZhbHVlO1xuICAgIGlmIChzeW1ib2xzW21vZGVdW3ZhbHVlXSAmJiBzeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlKSB7XG4gICAgICAgIHZhbHVlID0gc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZTtcbiAgICB9XG5cbiAgICB2YXIgY2xhc3NlcyA9IFtcIm1vcmRcIl07XG5cbiAgICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgICBpZiAoZm9udCkge1xuICAgICAgICBpZiAoZm9udCA9PT0gXCJtYXRoaXRcIiB8fCB1dGlscy5jb250YWlucyhtYWluaXRMZXR0ZXJzLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRoaXQodmFsdWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZvbnROYW1lID0gZm9udE1hcFtmb250XS5mb250TmFtZTtcbiAgICAgICAgICAgIGlmIChmb250TWV0cmljcy5nZXRDaGFyYWN0ZXJNZXRyaWNzKHZhbHVlLCBmb250TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFrZVN5bWJvbChcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsIGZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChbZm9udF0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGhEZWZhdWx0KHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYXRoRGVmYXVsdCh2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3NlcywgdHlwZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGhlaWdodCwgZGVwdGgsIGFuZCBtYXhGb250U2l6ZSBvZiBhbiBlbGVtZW50IGJhc2VkIG9uIGl0c1xuICogY2hpbGRyZW4uXG4gKi9cbnZhciBzaXplRWxlbWVudEZyb21DaGlsZHJlbiA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICB2YXIgaGVpZ2h0ID0gMDtcbiAgICB2YXIgZGVwdGggPSAwO1xuICAgIHZhciBtYXhGb250U2l6ZSA9IDA7XG5cbiAgICBpZiAoZWxlbS5jaGlsZHJlbikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW0uY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlbGVtLmNoaWxkcmVuW2ldLmhlaWdodCA+IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGVsZW0uY2hpbGRyZW5baV0uaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsZW0uY2hpbGRyZW5baV0uZGVwdGggPiBkZXB0aCkge1xuICAgICAgICAgICAgICAgIGRlcHRoID0gZWxlbS5jaGlsZHJlbltpXS5kZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtLmNoaWxkcmVuW2ldLm1heEZvbnRTaXplID4gbWF4Rm9udFNpemUpIHtcbiAgICAgICAgICAgICAgICBtYXhGb250U2l6ZSA9IGVsZW0uY2hpbGRyZW5baV0ubWF4Rm9udFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbGVtLmhlaWdodCA9IGhlaWdodDtcbiAgICBlbGVtLmRlcHRoID0gZGVwdGg7XG4gICAgZWxlbS5tYXhGb250U2l6ZSA9IG1heEZvbnRTaXplO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIHNwYW4gd2l0aCB0aGUgZ2l2ZW4gbGlzdCBvZiBjbGFzc2VzLCBsaXN0IG9mIGNoaWxkcmVuLCBhbmQgb3B0aW9ucy5cbiAqXG4gKiBUT0RPOiBFbnN1cmUgdGhhdCBgb3B0aW9uc2AgaXMgYWx3YXlzIHByb3ZpZGVkIChjdXJyZW50bHkgc29tZSBjYWxsIHNpdGVzXG4gKiBkb24ndCBwYXNzIGl0KS5cbiAqIFRPRE86IGFkZCBhIHNlcGFyYXRlIGFyZ3VtZW50IGZvciBtYXRoIGNsYXNzIChlLmcuIGBtb3BgLCBgbWJpbmApLCB3aGljaFxuICogc2hvdWxkIGlmIHByZXNlbnQgY29tZSBmaXJzdCBpbiBgY2xhc3Nlc2AuXG4gKi9cbnZhciBtYWtlU3BhbiA9IGZ1bmN0aW9uKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKSB7XG4gICAgdmFyIHNwYW4gPSBuZXcgZG9tVHJlZS5zcGFuKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKTtcblxuICAgIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKHNwYW4pO1xuXG4gICAgcmV0dXJuIHNwYW47XG59O1xuXG4vKipcbiAqIFByZXBlbmRzIHRoZSBnaXZlbiBjaGlsZHJlbiB0byB0aGUgZ2l2ZW4gc3BhbiwgdXBkYXRpbmcgaGVpZ2h0LCBkZXB0aCwgYW5kXG4gKiBtYXhGb250U2l6ZS5cbiAqL1xudmFyIHByZXBlbmRDaGlsZHJlbiA9IGZ1bmN0aW9uKHNwYW4sIGNoaWxkcmVuKSB7XG4gICAgc3Bhbi5jaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdChzcGFuLmNoaWxkcmVuKTtcblxuICAgIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKHNwYW4pO1xufTtcblxuLyoqXG4gKiBNYWtlcyBhIGRvY3VtZW50IGZyYWdtZW50IHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgY2hpbGRyZW4uXG4gKi9cbnZhciBtYWtlRnJhZ21lbnQgPSBmdW5jdGlvbihjaGlsZHJlbikge1xuICAgIHZhciBmcmFnbWVudCA9IG5ldyBkb21UcmVlLmRvY3VtZW50RnJhZ21lbnQoY2hpbGRyZW4pO1xuXG4gICAgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oZnJhZ21lbnQpO1xuXG4gICAgcmV0dXJuIGZyYWdtZW50O1xufTtcblxuLyoqXG4gKiBNYWtlcyBhbiBlbGVtZW50IHBsYWNlZCBpbiBlYWNoIG9mIHRoZSB2bGlzdCBlbGVtZW50cyB0byBlbnN1cmUgdGhhdCBlYWNoXG4gKiBlbGVtZW50IGhhcyB0aGUgc2FtZSBtYXggZm9udCBzaXplLiBUbyBkbyB0aGlzLCB3ZSBjcmVhdGUgYSB6ZXJvLXdpZHRoIHNwYWNlXG4gKiB3aXRoIHRoZSBjb3JyZWN0IGZvbnQgc2l6ZS5cbiAqL1xudmFyIG1ha2VGb250U2l6ZXIgPSBmdW5jdGlvbihvcHRpb25zLCBmb250U2l6ZSkge1xuICAgIHZhciBmb250U2l6ZUlubmVyID0gbWFrZVNwYW4oW10sIFtuZXcgZG9tVHJlZS5zeW1ib2xOb2RlKFwiXFx1MjAwYlwiKV0pO1xuICAgIGZvbnRTaXplSW5uZXIuc3R5bGUuZm9udFNpemUgPVxuICAgICAgICAoZm9udFNpemUgLyBvcHRpb25zLnN0eWxlLnNpemVNdWx0aXBsaWVyKSArIFwiZW1cIjtcblxuICAgIHZhciBmb250U2l6ZXIgPSBtYWtlU3BhbihcbiAgICAgICAgW1wiZm9udHNpemUtZW5zdXJlclwiLCBcInJlc2V0LVwiICsgb3B0aW9ucy5zaXplLCBcInNpemU1XCJdLFxuICAgICAgICBbZm9udFNpemVJbm5lcl0pO1xuXG4gICAgcmV0dXJuIGZvbnRTaXplcjtcbn07XG5cbi8qKlxuICogTWFrZXMgYSB2ZXJ0aWNhbCBsaXN0IGJ5IHN0YWNraW5nIGVsZW1lbnRzIGFuZCBrZXJucyBvbiB0b3Agb2YgZWFjaCBvdGhlci5cbiAqIEFsbG93cyBmb3IgbWFueSBkaWZmZXJlbnQgd2F5cyBvZiBzcGVjaWZ5aW5nIHRoZSBwb3NpdGlvbmluZyBtZXRob2QuXG4gKlxuICogQXJndW1lbnRzOlxuICogIC0gY2hpbGRyZW46IEEgbGlzdCBvZiBjaGlsZCBvciBrZXJuIG5vZGVzIHRvIGJlIHN0YWNrZWQgb24gdG9wIG9mIGVhY2ggb3RoZXJcbiAqICAgICAgICAgICAgICAoaS5lLiB0aGUgZmlyc3QgZWxlbWVudCB3aWxsIGJlIGF0IHRoZSBib3R0b20sIGFuZCB0aGUgbGFzdCBhdFxuICogICAgICAgICAgICAgIHRoZSB0b3ApLiBFbGVtZW50IG5vZGVzIGFyZSBzcGVjaWZpZWQgYXNcbiAqICAgICAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogbm9kZX1cbiAqICAgICAgICAgICAgICB3aGlsZSBrZXJuIG5vZGVzIGFyZSBzcGVjaWZpZWQgYXNcbiAqICAgICAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogc2l6ZX1cbiAqICAtIHBvc2l0aW9uVHlwZTogVGhlIG1ldGhvZCBieSB3aGljaCB0aGUgdmxpc3Qgc2hvdWxkIGJlIHBvc2l0aW9uZWQuIFZhbGlkXG4gKiAgICAgICAgICAgICAgICAgIHZhbHVlcyBhcmU6XG4gKiAgICAgICAgICAgICAgICAgICAtIFwiaW5kaXZpZHVhbFNoaWZ0XCI6IFRoZSBjaGlsZHJlbiBsaXN0IG9ubHkgY29udGFpbnMgZWxlbVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMsIGFuZCBlYWNoIG5vZGUgY29udGFpbnMgYW4gZXh0cmFcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2hpZnRcIiB2YWx1ZSBvZiBob3cgbXVjaCBpdCBzaG91bGQgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ZWQgKG5vdGUgdGhhdCBzaGlmdGluZyBpcyBhbHdheXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmluZyBkb3dud2FyZHMpLiBwb3NpdGlvbkRhdGEgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZWQuXG4gKiAgICAgICAgICAgICAgICAgICAtIFwidG9wXCI6IFRoZSBwb3NpdGlvbkRhdGEgc3BlY2lmaWVzIHRoZSB0b3Btb3N0IHBvaW50IG9mXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgdmxpc3QgKG5vdGUgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhIGhlaWdodCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvIHBvc2l0aXZlIHZhbHVlcyBtb3ZlIHVwKVxuICogICAgICAgICAgICAgICAgICAgLSBcImJvdHRvbVwiOiBUaGUgcG9zaXRpb25EYXRhIHNwZWNpZmllcyB0aGUgYm90dG9tbW9zdCBwb2ludFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIHZsaXN0IChub3RlIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGgsIHNvIHBvc2l0aXZlIHZhbHVlcyBtb3ZlIGRvd25cbiAqICAgICAgICAgICAgICAgICAgIC0gXCJzaGlmdFwiOiBUaGUgdmxpc3Qgd2lsbCBiZSBwb3NpdGlvbmVkIHN1Y2ggdGhhdCBpdHNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmUgaXMgcG9zaXRpb25EYXRhIGF3YXkgZnJvbSB0aGUgYmFzZWxpbmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2YgdGhlIGZpcnN0IGNoaWxkLiBQb3NpdGl2ZSB2YWx1ZXMgbW92ZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3dud2FyZHMuXG4gKiAgICAgICAgICAgICAgICAgICAtIFwiZmlyc3RCYXNlbGluZVwiOiBUaGUgdmxpc3Qgd2lsbCBiZSBwb3NpdGlvbmVkIHN1Y2ggdGhhdFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0cyBiYXNlbGluZSBpcyBhbGlnbmVkIHdpdGggdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZWxpbmUgb2YgdGhlIGZpcnN0IGNoaWxkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uRGF0YSBpcyBpZ25vcmVkLiAodGhpcyBpc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gXCJzaGlmdFwiIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbkRhdGE9MClcbiAqICAtIHBvc2l0aW9uRGF0YTogRGF0YSB1c2VkIGluIGRpZmZlcmVudCB3YXlzIGRlcGVuZGluZyBvbiBwb3NpdGlvblR5cGVcbiAqICAtIG9wdGlvbnM6IEFuIE9wdGlvbnMgb2JqZWN0XG4gKlxuICovXG52YXIgbWFrZVZMaXN0ID0gZnVuY3Rpb24oY2hpbGRyZW4sIHBvc2l0aW9uVHlwZSwgcG9zaXRpb25EYXRhLCBvcHRpb25zKSB7XG4gICAgdmFyIGRlcHRoO1xuICAgIHZhciBjdXJyUG9zO1xuICAgIHZhciBpO1xuICAgIGlmIChwb3NpdGlvblR5cGUgPT09IFwiaW5kaXZpZHVhbFNoaWZ0XCIpIHtcbiAgICAgICAgdmFyIG9sZENoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIGNoaWxkcmVuID0gW29sZENoaWxkcmVuWzBdXTtcblxuICAgICAgICAvLyBBZGQgaW4ga2VybnMgdG8gdGhlIGxpc3Qgb2YgY2hpbGRyZW4gdG8gZ2V0IGVhY2ggZWxlbWVudCB0byBiZVxuICAgICAgICAvLyBzaGlmdGVkIHRvIHRoZSBjb3JyZWN0IHNwZWNpZmllZCBzaGlmdFxuICAgICAgICBkZXB0aCA9IC1vbGRDaGlsZHJlblswXS5zaGlmdCAtIG9sZENoaWxkcmVuWzBdLmVsZW0uZGVwdGg7XG4gICAgICAgIGN1cnJQb3MgPSBkZXB0aDtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IC1vbGRDaGlsZHJlbltpXS5zaGlmdCAtIGN1cnJQb3MgLVxuICAgICAgICAgICAgICAgIG9sZENoaWxkcmVuW2ldLmVsZW0uZGVwdGg7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGRpZmYgLVxuICAgICAgICAgICAgICAgIChvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5oZWlnaHQgK1xuICAgICAgICAgICAgICAgICBvbGRDaGlsZHJlbltpIC0gMV0uZWxlbS5kZXB0aCk7XG5cbiAgICAgICAgICAgIGN1cnJQb3MgPSBjdXJyUG9zICsgZGlmZjtcblxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh7dHlwZTogXCJrZXJuXCIsIHNpemU6IHNpemV9KTtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gob2xkQ2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblR5cGUgPT09IFwidG9wXCIpIHtcbiAgICAgICAgLy8gV2UgYWx3YXlzIHN0YXJ0IGF0IHRoZSBib3R0b20sIHNvIGNhbGN1bGF0ZSB0aGUgYm90dG9tIGJ5IGFkZGluZyB1cFxuICAgICAgICAvLyBhbGwgdGhlIHNpemVzXG4gICAgICAgIHZhciBib3R0b20gPSBwb3NpdGlvbkRhdGE7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IFwia2VyblwiKSB7XG4gICAgICAgICAgICAgICAgYm90dG9tIC09IGNoaWxkcmVuW2ldLnNpemU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvdHRvbSAtPSBjaGlsZHJlbltpXS5lbGVtLmhlaWdodCArIGNoaWxkcmVuW2ldLmVsZW0uZGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVwdGggPSBib3R0b207XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvblR5cGUgPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgZGVwdGggPSAtcG9zaXRpb25EYXRhO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb25UeXBlID09PSBcInNoaWZ0XCIpIHtcbiAgICAgICAgZGVwdGggPSAtY2hpbGRyZW5bMF0uZWxlbS5kZXB0aCAtIHBvc2l0aW9uRGF0YTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uVHlwZSA9PT0gXCJmaXJzdEJhc2VsaW5lXCIpIHtcbiAgICAgICAgZGVwdGggPSAtY2hpbGRyZW5bMF0uZWxlbS5kZXB0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZXB0aCA9IDA7XG4gICAgfVxuXG4gICAgLy8gTWFrZSB0aGUgZm9udFNpemVyXG4gICAgdmFyIG1heEZvbnRTaXplID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnR5cGUgPT09IFwiZWxlbVwiKSB7XG4gICAgICAgICAgICBtYXhGb250U2l6ZSA9IE1hdGgubWF4KG1heEZvbnRTaXplLCBjaGlsZHJlbltpXS5lbGVtLm1heEZvbnRTaXplKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZm9udFNpemVyID0gbWFrZUZvbnRTaXplcihvcHRpb25zLCBtYXhGb250U2l6ZSk7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgbGlzdCBvZiBhY3R1YWwgY2hpbGRyZW4gYXQgdGhlIGNvcnJlY3Qgb2Zmc2V0c1xuICAgIHZhciByZWFsQ2hpbGRyZW4gPSBbXTtcbiAgICBjdXJyUG9zID0gZGVwdGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSBcImtlcm5cIikge1xuICAgICAgICAgICAgY3VyclBvcyArPSBjaGlsZHJlbltpXS5zaXplO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV0uZWxlbTtcblxuICAgICAgICAgICAgdmFyIHNoaWZ0ID0gLWNoaWxkLmRlcHRoIC0gY3VyclBvcztcbiAgICAgICAgICAgIGN1cnJQb3MgKz0gY2hpbGQuaGVpZ2h0ICsgY2hpbGQuZGVwdGg7XG5cbiAgICAgICAgICAgIHZhciBjaGlsZFdyYXAgPSBtYWtlU3BhbihbXSwgW2ZvbnRTaXplciwgY2hpbGRdKTtcbiAgICAgICAgICAgIGNoaWxkV3JhcC5oZWlnaHQgLT0gc2hpZnQ7XG4gICAgICAgICAgICBjaGlsZFdyYXAuZGVwdGggKz0gc2hpZnQ7XG4gICAgICAgICAgICBjaGlsZFdyYXAuc3R5bGUudG9wID0gc2hpZnQgKyBcImVtXCI7XG5cbiAgICAgICAgICAgIHJlYWxDaGlsZHJlbi5wdXNoKGNoaWxkV3JhcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaW4gYW4gZWxlbWVudCBhdCB0aGUgZW5kIHdpdGggbm8gb2Zmc2V0IHRvIGZpeCB0aGUgY2FsY3VsYXRpb24gb2ZcbiAgICAvLyBiYXNlbGluZXMgaW4gc29tZSBicm93c2VycyAobmFtZWx5IElFLCBzb21ldGltZXMgc2FmYXJpKVxuICAgIHZhciBiYXNlbGluZUZpeCA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJiYXNlbGluZS1maXhcIl0sIFtmb250U2l6ZXIsIG5ldyBkb21UcmVlLnN5bWJvbE5vZGUoXCJcXHUyMDBiXCIpXSk7XG4gICAgcmVhbENoaWxkcmVuLnB1c2goYmFzZWxpbmVGaXgpO1xuXG4gICAgdmFyIHZsaXN0ID0gbWFrZVNwYW4oW1widmxpc3RcIl0sIHJlYWxDaGlsZHJlbik7XG4gICAgLy8gRml4IHRoZSBmaW5hbCBoZWlnaHQgYW5kIGRlcHRoLCBpbiBjYXNlIHRoZXJlIHdlcmUga2VybnMgYXQgdGhlIGVuZHNcbiAgICAvLyBzaW5jZSB0aGUgbWFrZVNwYW4gY2FsY3VsYXRpb24gd29uJ3QgdGFrZSB0aGF0IGluIHRvIGFjY291bnQuXG4gICAgdmxpc3QuaGVpZ2h0ID0gTWF0aC5tYXgoY3VyclBvcywgdmxpc3QuaGVpZ2h0KTtcbiAgICB2bGlzdC5kZXB0aCA9IE1hdGgubWF4KC1kZXB0aCwgdmxpc3QuZGVwdGgpO1xuICAgIHJldHVybiB2bGlzdDtcbn07XG5cbi8vIEEgdGFibGUgb2Ygc2l6ZSAtPiBmb250IHNpemUgZm9yIHRoZSBkaWZmZXJlbnQgc2l6aW5nIGZ1bmN0aW9uc1xudmFyIHNpemluZ011bHRpcGxpZXIgPSB7XG4gICAgc2l6ZTE6IDAuNSxcbiAgICBzaXplMjogMC43LFxuICAgIHNpemUzOiAwLjgsXG4gICAgc2l6ZTQ6IDAuOSxcbiAgICBzaXplNTogMS4wLFxuICAgIHNpemU2OiAxLjIsXG4gICAgc2l6ZTc6IDEuNDQsXG4gICAgc2l6ZTg6IDEuNzMsXG4gICAgc2l6ZTk6IDIuMDcsXG4gICAgc2l6ZTEwOiAyLjQ5XG59O1xuXG4vLyBBIG1hcCBvZiBzcGFjaW5nIGZ1bmN0aW9ucyB0byB0aGVpciBhdHRyaWJ1dGVzLCBsaWtlIHNpemUgYW5kIGNvcnJlc3BvbmRpbmdcbi8vIENTUyBjbGFzc1xudmFyIHNwYWNpbmdGdW5jdGlvbnMgPSB7XG4gICAgXCJcXFxccXF1YWRcIjoge1xuICAgICAgICBzaXplOiBcIjJlbVwiLFxuICAgICAgICBjbGFzc05hbWU6IFwicXF1YWRcIlxuICAgIH0sXG4gICAgXCJcXFxccXVhZFwiOiB7XG4gICAgICAgIHNpemU6IFwiMWVtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJxdWFkXCJcbiAgICB9LFxuICAgIFwiXFxcXGVuc3BhY2VcIjoge1xuICAgICAgICBzaXplOiBcIjAuNWVtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJlbnNwYWNlXCJcbiAgICB9LFxuICAgIFwiXFxcXDtcIjoge1xuICAgICAgICBzaXplOiBcIjAuMjc3Nzc4ZW1cIixcbiAgICAgICAgY2xhc3NOYW1lOiBcInRoaWNrc3BhY2VcIlxuICAgIH0sXG4gICAgXCJcXFxcOlwiOiB7XG4gICAgICAgIHNpemU6IFwiMC4yMjIyMmVtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJtZWRpdW1zcGFjZVwiXG4gICAgfSxcbiAgICBcIlxcXFwsXCI6IHtcbiAgICAgICAgc2l6ZTogXCIwLjE2NjY3ZW1cIixcbiAgICAgICAgY2xhc3NOYW1lOiBcInRoaW5zcGFjZVwiXG4gICAgfSxcbiAgICBcIlxcXFwhXCI6IHtcbiAgICAgICAgc2l6ZTogXCItMC4xNjY2N2VtXCIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJuZWdhdGl2ZXRoaW5zcGFjZVwiXG4gICAgfVxufTtcblxuLyoqXG4gKiBNYXBzIFRlWCBmb250IGNvbW1hbmRzIHRvIG9iamVjdHMgY29udGFpbmluZzpcbiAqIC0gdmFyaWFudDogc3RyaW5nIHVzZWQgZm9yIFwibWF0aHZhcmlhbnRcIiBhdHRyaWJ1dGUgaW4gYnVpbGRNYXRoTUwuanNcbiAqIC0gZm9udE5hbWU6IHRoZSBcInN0eWxlXCIgcGFyYW1ldGVyIHRvIGZvbnRNZXRyaWNzLmdldENoYXJhY3Rlck1ldHJpY3NcbiAqL1xuLy8gQSBtYXAgYmV0d2VlbiB0ZXggZm9udCBjb21tYW5kcyBhbiBNYXRoTUwgbWF0aHZhcmlhbnQgYXR0cmlidXRlIHZhbHVlc1xudmFyIGZvbnRNYXAgPSB7XG4gICAgLy8gc3R5bGVzXG4gICAgXCJtYXRoYmZcIjoge1xuICAgICAgICB2YXJpYW50OiBcImJvbGRcIixcbiAgICAgICAgZm9udE5hbWU6IFwiTWFpbi1Cb2xkXCJcbiAgICB9LFxuICAgIFwibWF0aHJtXCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJub3JtYWxcIixcbiAgICAgICAgZm9udE5hbWU6IFwiTWFpbi1SZWd1bGFyXCJcbiAgICB9LFxuICAgIFwidGV4dGl0XCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJpdGFsaWNcIixcbiAgICAgICAgZm9udE5hbWU6IFwiTWFpbi1JdGFsaWNcIlxuICAgIH0sXG5cbiAgICAvLyBcIm1hdGhpdFwiIGlzIG1pc3NpbmcgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgdXNlIG9mIHR3byBmb250czogTWFpbi1JdGFsaWNcbiAgICAvLyBhbmQgTWF0aC1JdGFsaWMuICBUaGlzIGlzIGhhbmRsZWQgYnkgYSBzcGVjaWFsIGNhc2UgaW4gbWFrZU9yZCB3aGljaCBlbmRzXG4gICAgLy8gdXAgY2FsbGluZyBtYXRoaXQuXG5cbiAgICAvLyBmYW1pbGllc1xuICAgIFwibWF0aGJiXCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJkb3VibGUtc3RydWNrXCIsXG4gICAgICAgIGZvbnROYW1lOiBcIkFNUy1SZWd1bGFyXCJcbiAgICB9LFxuICAgIFwibWF0aGNhbFwiOiB7XG4gICAgICAgIHZhcmlhbnQ6IFwic2NyaXB0XCIsXG4gICAgICAgIGZvbnROYW1lOiBcIkNhbGlncmFwaGljLVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRoZnJha1wiOiB7XG4gICAgICAgIHZhcmlhbnQ6IFwiZnJha3R1clwiLFxuICAgICAgICBmb250TmFtZTogXCJGcmFrdHVyLVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRoc2NyXCI6IHtcbiAgICAgICAgdmFyaWFudDogXCJzY3JpcHRcIixcbiAgICAgICAgZm9udE5hbWU6IFwiU2NyaXB0LVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRoc2ZcIjoge1xuICAgICAgICB2YXJpYW50OiBcInNhbnMtc2VyaWZcIixcbiAgICAgICAgZm9udE5hbWU6IFwiU2Fuc1NlcmlmLVJlZ3VsYXJcIlxuICAgIH0sXG4gICAgXCJtYXRodHRcIjoge1xuICAgICAgICB2YXJpYW50OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICBmb250TmFtZTogXCJUeXBld3JpdGVyLVJlZ3VsYXJcIlxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvbnRNYXA6IGZvbnRNYXAsXG4gICAgbWFrZVN5bWJvbDogbWFrZVN5bWJvbCxcbiAgICBtYXRoc3ltOiBtYXRoc3ltLFxuICAgIG1ha2VTcGFuOiBtYWtlU3BhbixcbiAgICBtYWtlRnJhZ21lbnQ6IG1ha2VGcmFnbWVudCxcbiAgICBtYWtlVkxpc3Q6IG1ha2VWTGlzdCxcbiAgICBtYWtlT3JkOiBtYWtlT3JkLFxuICAgIHByZXBlbmRDaGlsZHJlbjogcHJlcGVuZENoaWxkcmVuLFxuICAgIHNpemluZ011bHRpcGxpZXI6IHNpemluZ011bHRpcGxpZXIsXG4gICAgc3BhY2luZ0Z1bmN0aW9uczogc3BhY2luZ0Z1bmN0aW9uc1xufTtcbiIsIi8qIGVzbGludCBuby1jb25zb2xlOjAgKi9cbi8qKlxuICogVGhpcyBmaWxlIGRvZXMgdGhlIG1haW4gd29yayBvZiBidWlsZGluZyBhIGRvbVRyZWUgc3RydWN0dXJlIGZyb20gYSBwYXJzZVxuICogdHJlZS4gVGhlIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRIVE1MYCBmdW5jdGlvbiwgd2hpY2ggdGFrZXMgYSBwYXJzZSB0cmVlLlxuICogVGhlbiwgdGhlIGJ1aWxkRXhwcmVzc2lvbiwgYnVpbGRHcm91cCwgYW5kIHZhcmlvdXMgZ3JvdXBUeXBlcyBmdW5jdGlvbnMgYXJlXG4gKiBjYWxsZWQsIHRvIHByb2R1Y2UgYSBmaW5hbCBIVE1MIHRyZWUuXG4gKi9cblxudmFyIFBhcnNlRXJyb3IgPSByZXF1aXJlKFwiLi9QYXJzZUVycm9yXCIpO1xudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vU3R5bGVcIik7XG5cbnZhciBidWlsZENvbW1vbiA9IHJlcXVpcmUoXCIuL2J1aWxkQ29tbW9uXCIpO1xudmFyIGRlbGltaXRlciA9IHJlcXVpcmUoXCIuL2RlbGltaXRlclwiKTtcbnZhciBkb21UcmVlID0gcmVxdWlyZShcIi4vZG9tVHJlZVwiKTtcbnZhciBmb250TWV0cmljcyA9IHJlcXVpcmUoXCIuL2ZvbnRNZXRyaWNzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbnZhciBtYWtlU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuO1xuXG52YXIgaXNTcGFjZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIGRvbVRyZWUuc3BhbiAmJiBub2RlLmNsYXNzZXNbMF0gPT09IFwibXNwYWNlXCI7XG59O1xuXG4vLyBCaW5hcnkgYXRvbXMgKGZpcnN0IGNsYXNzIGBtYmluYCkgY2hhbmdlIGludG8gb3JkaW5hcnkgYXRvbXMgKGBtb3JkYClcbi8vIGRlcGVuZGluZyBvbiB0aGVpciBzdXJyb3VuZGluZ3MuIFNlZSBUZVhib29rIHBnLiA0NDItNDQ2LCBSdWxlcyA1IGFuZCA2LFxuLy8gYW5kIHRoZSB0ZXh0IGJlZm9yZSBSdWxlIDE5LlxuXG52YXIgaXNCaW4gPSBmdW5jdGlvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5jbGFzc2VzWzBdID09PSBcIm1iaW5cIjtcbn07XG5cbnZhciBpc0JpbkxlZnRDYW5jZWxsZXIgPSBmdW5jdGlvbihub2RlLCBpc1JlYWxHcm91cCkge1xuICAgIC8vIFRPRE86IFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgYSBub2RlJ3MgbWF0aCBjbGFzcyBpcyB0aGUgZmlyc3QgZWxlbWVudFxuICAgIC8vIG9mIGl0cyBgY2xhc3Nlc2AgYXJyYXkuIEEgbGF0ZXIgY2xlYW51cCBzaG91bGQgZW5zdXJlIHRoaXMsIGZvclxuICAgIC8vIGluc3RhbmNlIGJ5IGNoYW5naW5nIHRoZSBzaWduYXR1cmUgb2YgYG1ha2VTcGFuYC5cbiAgICBpZiAobm9kZSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuY29udGFpbnMoW1wibWJpblwiLCBcIm1vcGVuXCIsIFwibXJlbFwiLCBcIm1vcFwiLCBcIm1wdW5jdFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3Nlc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGlzUmVhbEdyb3VwO1xuICAgIH1cbn07XG5cbnZhciBpc0JpblJpZ2h0Q2FuY2VsbGVyID0gZnVuY3Rpb24obm9kZSwgaXNSZWFsR3JvdXApIHtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICByZXR1cm4gdXRpbHMuY29udGFpbnMoW1wibXJlbFwiLCBcIm1jbG9zZVwiLCBcIm1wdW5jdFwiXSwgbm9kZS5jbGFzc2VzWzBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNSZWFsR3JvdXA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUYWtlIGEgbGlzdCBvZiBub2RlcywgYnVpbGQgdGhlbSBpbiBvcmRlciwgYW5kIHJldHVybiBhIGxpc3Qgb2YgdGhlIGJ1aWx0XG4gKiBub2Rlcy4gZG9jdW1lbnRGcmFnbWVudHMgYXJlIGZsYXR0ZW5lZCBpbnRvIHRoZWlyIGNvbnRlbnRzLCBzbyB0aGVcbiAqIHJldHVybmVkIGxpc3QgY29udGFpbnMgbm8gZnJhZ21lbnRzLiBgaXNSZWFsR3JvdXBgIGlzIHRydWUgaWYgYGV4cHJlc3Npb25gXG4gKiBpcyBhIHJlYWwgZ3JvdXAgKG5vIGF0b21zIHdpbGwgYmUgYWRkZWQgb24gZWl0aGVyIHNpZGUpLCBhcyBvcHBvc2VkIHRvXG4gKiBhIHBhcnRpYWwgZ3JvdXAgKGUuZy4gb25lIGNyZWF0ZWQgYnkgXFxjb2xvcikuXG4gKi9cbnZhciBidWlsZEV4cHJlc3Npb24gPSBmdW5jdGlvbihleHByZXNzaW9uLCBvcHRpb25zLCBpc1JlYWxHcm91cCkge1xuICAgIC8vIFBhcnNlIGV4cHJlc3Npb25zIGludG8gYGdyb3Vwc2AuXG4gICAgdmFyIGdyb3VwcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZ3JvdXAgPSBleHByZXNzaW9uW2ldO1xuICAgICAgICB2YXIgb3V0cHV0ID0gYnVpbGRHcm91cChncm91cCwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChvdXRwdXQgaW5zdGFuY2VvZiBkb21UcmVlLmRvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGdyb3Vwcywgb3V0cHV0LmNoaWxkcmVuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyb3Vwcy5wdXNoKG91dHB1dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXQgdGhpcyBwb2ludCBgZ3JvdXBzYCBjb25zaXN0cyBlbnRpcmVseSBvZiBgc3ltYm9sTm9kZWBzIGFuZCBgc3BhbmBzLlxuXG4gICAgLy8gRXhwbGljaXQgc3BhY2VzIChlLmcuLCBcXDssIFxcLCkgc2hvdWxkIGJlIGlnbm9yZWQgd2l0aCByZXNwZWN0IHRvIGF0b21cbiAgICAvLyBzcGFjaW5nIChlLmcuLCBcImFkZCB0aGljayBzcGFjZSBiZXR3ZWVuIG1vcmQgYW5kIG1yZWxcIikuIFNpbmNlIENTU1xuICAgIC8vIGFkamFjZW5jeSBydWxlcyBpbXBsZW1lbnQgYXRvbSBzcGFjaW5nLCBzcGFjZXMgc2hvdWxkIGJlIGludmlzaWJsZSB0b1xuICAgIC8vIENTUy4gU28gd2Ugc3BsaWNlIHRoZW0gb3V0IG9mIGBncm91cHNgIGFuZCBpbnRvIHRoZSBhdG9tcyB0aGVtc2VsdmVzLlxuICAgIHZhciBzcGFjZXMgPSBudWxsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzU3BhY2UoZ3JvdXBzW2ldKSkge1xuICAgICAgICAgICAgc3BhY2VzID0gc3BhY2VzIHx8IFtdO1xuICAgICAgICAgICAgc3BhY2VzLnB1c2goZ3JvdXBzW2ldKTtcbiAgICAgICAgICAgIGdyb3Vwcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgIH0gZWxzZSBpZiAoc3BhY2VzKSB7XG4gICAgICAgICAgICBpZiAoZ3JvdXBzW2ldIGluc3RhbmNlb2YgZG9tVHJlZS5zeW1ib2xOb2RlKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBzW2ldID0gbWFrZVNwYW4oW10uY29uY2F0KGdyb3Vwc1tpXS5jbGFzc2VzKSwgW2dyb3Vwc1tpXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVpbGRDb21tb24ucHJlcGVuZENoaWxkcmVuKGdyb3Vwc1tpXSwgc3BhY2VzKTtcbiAgICAgICAgICAgIHNwYWNlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNwYWNlcykge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShncm91cHMsIHNwYWNlcyk7XG4gICAgfVxuXG4gICAgLy8gQmluYXJ5IG9wZXJhdG9ycyBjaGFuZ2UgdG8gb3JkaW5hcnkgc3ltYm9scyBpbiBzb21lIGNvbnRleHRzLlxuICAgIGZvciAoaSA9IDA7IGkgPCBncm91cHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzQmluKGdyb3Vwc1tpXSlcbiAgICAgICAgICAgICYmIChpc0JpbkxlZnRDYW5jZWxsZXIoZ3JvdXBzW2kgLSAxXSwgaXNSZWFsR3JvdXApXG4gICAgICAgICAgICAgICAgfHwgaXNCaW5SaWdodENhbmNlbGxlcihncm91cHNbaSArIDFdLCBpc1JlYWxHcm91cCkpKSB7XG4gICAgICAgICAgICBncm91cHNbaV0uY2xhc3Nlc1swXSA9IFwibW9yZFwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3Vwcztcbn07XG5cbi8vIFJldHVybiBtYXRoIGF0b20gY2xhc3MgKG1jbGFzcykgb2YgYSBkb21UcmVlLlxudmFyIGdldFR5cGVPZkRvbVRyZWUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBkb21UcmVlLmRvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0VHlwZU9mRG9tVHJlZShcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuW25vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHV0aWxzLmNvbnRhaW5zKFtcIm1vcmRcIiwgXCJtb3BcIiwgXCJtYmluXCIsIFwibXJlbFwiLCBcIm1vcGVuXCIsIFwibWNsb3NlXCIsXG4gICAgICAgICAgICBcIm1wdW5jdFwiLCBcIm1pbm5lclwiXSwgbm9kZS5jbGFzc2VzWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY2xhc3Nlc1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogU29tZXRpbWVzLCBncm91cHMgcGVyZm9ybSBzcGVjaWFsIHJ1bGVzIHdoZW4gdGhleSBoYXZlIHN1cGVyc2NyaXB0cyBvclxuICogc3Vic2NyaXB0cyBhdHRhY2hlZCB0byB0aGVtLiBUaGlzIGZ1bmN0aW9uIGxldHMgdGhlIGBzdXBzdWJgIGdyb3VwIGtub3cgdGhhdFxuICogaXRzIGlubmVyIGVsZW1lbnQgc2hvdWxkIGhhbmRsZSB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGluc3RlYWQgb2ZcbiAqIGhhbmRsaW5nIHRoZW0gaXRzZWxmLlxuICovXG52YXIgc2hvdWxkSGFuZGxlU3VwU3ViID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBpZiAoIWdyb3VwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwib3BcIikge1xuICAgICAgICAvLyBPcGVyYXRvcnMgaGFuZGxlIHN1cHN1YnMgZGlmZmVyZW50bHkgd2hlbiB0aGV5IGhhdmUgbGltaXRzXG4gICAgICAgIC8vIChlLmcuIGBcXGRpc3BsYXlzdHlsZVxcc3VtXzJeM2ApXG4gICAgICAgIHJldHVybiBncm91cC52YWx1ZS5saW1pdHMgJiZcbiAgICAgICAgICAgIChvcHRpb25zLnN0eWxlLnNpemUgPT09IFN0eWxlLkRJU1BMQVkuc2l6ZSB8fFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUuYWx3YXlzSGFuZGxlU3VwU3ViKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiYWNjZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIGlzQ2hhcmFjdGVyQm94KGdyb3VwLnZhbHVlLmJhc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogU29tZXRpbWVzIHdlIHdhbnQgdG8gcHVsbCBvdXQgdGhlIGlubmVybW9zdCBlbGVtZW50IG9mIGEgZ3JvdXAuIEluIG1vc3RcbiAqIGNhc2VzLCB0aGlzIHdpbGwganVzdCBiZSB0aGUgZ3JvdXAgaXRzZWxmLCBidXQgd2hlbiBvcmRncm91cHMgYW5kIGNvbG9ycyBoYXZlXG4gKiBhIHNpbmdsZSBlbGVtZW50LCB3ZSB3YW50IHRvIHB1bGwgdGhhdCBvdXQuXG4gKi9cbnZhciBnZXRCYXNlRWxlbSA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgaWYgKGdyb3VwLnZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEJhc2VFbGVtKGdyb3VwLnZhbHVlWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cDtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJjb2xvclwiKSB7XG4gICAgICAgIGlmIChncm91cC52YWx1ZS52YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC52YWx1ZS52YWx1ZVswXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiZm9udFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRCYXNlRWxlbShncm91cC52YWx1ZS5ib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUZVhib29rIGFsZ29yaXRobXMgb2Z0ZW4gcmVmZXJlbmNlIFwiY2hhcmFjdGVyIGJveGVzXCIsIHdoaWNoIGFyZSBzaW1wbHkgZ3JvdXBzXG4gKiB3aXRoIGEgc2luZ2xlIGNoYXJhY3RlciBpbiB0aGVtLiBUbyBkZWNpZGUgaWYgc29tZXRoaW5nIGlzIGEgY2hhcmFjdGVyIGJveCxcbiAqIHdlIGZpbmQgaXRzIGlubmVybW9zdCBncm91cCwgYW5kIHNlZSBpZiBpdCBpcyBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gKi9cbnZhciBpc0NoYXJhY3RlckJveCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIGJhc2VFbGVtID0gZ2V0QmFzZUVsZW0oZ3JvdXApO1xuXG4gICAgLy8gVGhlc2UgYXJlIGFsbCB0aGV5IHR5cGVzIG9mIGdyb3VwcyB3aGljaCBob2xkIHNpbmdsZSBjaGFyYWN0ZXJzXG4gICAgcmV0dXJuIGJhc2VFbGVtLnR5cGUgPT09IFwibWF0aG9yZFwiIHx8XG4gICAgICAgIGJhc2VFbGVtLnR5cGUgPT09IFwidGV4dG9yZFwiIHx8XG4gICAgICAgIGJhc2VFbGVtLnR5cGUgPT09IFwiYmluXCIgfHxcbiAgICAgICAgYmFzZUVsZW0udHlwZSA9PT0gXCJyZWxcIiB8fFxuICAgICAgICBiYXNlRWxlbS50eXBlID09PSBcImlubmVyXCIgfHxcbiAgICAgICAgYmFzZUVsZW0udHlwZSA9PT0gXCJvcGVuXCIgfHxcbiAgICAgICAgYmFzZUVsZW0udHlwZSA9PT0gXCJjbG9zZVwiIHx8XG4gICAgICAgIGJhc2VFbGVtLnR5cGUgPT09IFwicHVuY3RcIjtcbn07XG5cbnZhciBtYWtlTnVsbERlbGltaXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNsYXNzZXMpIHtcbiAgICByZXR1cm4gbWFrZVNwYW4oY2xhc3Nlcy5jb25jYXQoW1xuICAgICAgICBcInNpemluZ1wiLCBcInJlc2V0LVwiICsgb3B0aW9ucy5zaXplLCBcInNpemU1XCIsXG4gICAgICAgIG9wdGlvbnMuc3R5bGUucmVzZXQoKSwgU3R5bGUuVEVYVC5jbHMoKSxcbiAgICAgICAgXCJudWxsZGVsaW1pdGVyXCJdKSk7XG59O1xuXG4vKipcbiAqIFRoaXMgaXMgYSBtYXAgb2YgZ3JvdXAgdHlwZXMgdG8gdGhlIGZ1bmN0aW9uIHVzZWQgdG8gaGFuZGxlIHRoYXQgdHlwZS5cbiAqIFNpbXBsZXIgdHlwZXMgY29tZSBhdCB0aGUgYmVnaW5uaW5nLCB3aGlsZSBjb21wbGljYXRlZCB0eXBlcyBjb21lIGFmdGVyd2FyZHMuXG4gKi9cbnZhciBncm91cFR5cGVzID0ge307XG5cbmdyb3VwVHlwZXMubWF0aG9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwibWF0aG9yZFwiKTtcbn07XG5cbmdyb3VwVHlwZXMudGV4dG9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwidGV4dG9yZFwiKTtcbn07XG5cbmdyb3VwVHlwZXMuYmluID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYnVpbGRDb21tb24ubWF0aHN5bShcbiAgICAgICAgZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUsIG9wdGlvbnMsIFtcIm1iaW5cIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5yZWwgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYXRoc3ltKFxuICAgICAgICBncm91cC52YWx1ZSwgZ3JvdXAubW9kZSwgb3B0aW9ucywgW1wibXJlbFwiXSk7XG59O1xuXG5ncm91cFR5cGVzLm9wZW4gPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYXRoc3ltKFxuICAgICAgICBncm91cC52YWx1ZSwgZ3JvdXAubW9kZSwgb3B0aW9ucywgW1wibW9wZW5cIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5jbG9zZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXG4gICAgICAgIGdyb3VwLnZhbHVlLCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtY2xvc2VcIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5pbm5lciA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXG4gICAgICAgIGdyb3VwLnZhbHVlLCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtaW5uZXJcIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5wdW5jdCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXG4gICAgICAgIGdyb3VwLnZhbHVlLCBncm91cC5tb2RlLCBvcHRpb25zLCBbXCJtcHVuY3RcIl0pO1xufTtcblxuZ3JvdXBUeXBlcy5vcmRncm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG1ha2VTcGFuKFxuICAgICAgICBbXCJtb3JkXCIsIG9wdGlvbnMuc3R5bGUuY2xzKCldLFxuICAgICAgICBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUsIG9wdGlvbnMucmVzZXQoKSwgdHJ1ZSksXG4gICAgICAgIG9wdGlvbnNcbiAgICApO1xufTtcblxuZ3JvdXBUeXBlcy50ZXh0ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aEZvbnQoZ3JvdXAudmFsdWUuc3R5bGUpO1xuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC52YWx1ZS5ib2R5LCBuZXdPcHRpb25zLCB0cnVlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoaW5uZXJbaV0udHJ5Q29tYmluZShpbm5lcltpICsgMV0pKSB7XG4gICAgICAgICAgICBpbm5lci5zcGxpY2UoaSArIDEsIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwidGV4dFwiLCBuZXdPcHRpb25zLnN0eWxlLmNscygpXSxcbiAgICAgICAgaW5uZXIsIG5ld09wdGlvbnMpO1xufTtcblxuZ3JvdXBUeXBlcy5jb2xvciA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKFxuICAgICAgICBncm91cC52YWx1ZS52YWx1ZSxcbiAgICAgICAgb3B0aW9ucy53aXRoQ29sb3IoZ3JvdXAudmFsdWUuY29sb3IpLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICAvLyBcXGNvbG9yIGlzbid0IHN1cHBvc2VkIHRvIGFmZmVjdCB0aGUgdHlwZSBvZiB0aGUgZWxlbWVudHMgaXQgY29udGFpbnMuXG4gICAgLy8gVG8gYWNjb21wbGlzaCB0aGlzLCB3ZSB3cmFwIHRoZSByZXN1bHRzIGluIGEgZnJhZ21lbnQsIHNvIHRoZSBpbm5lclxuICAgIC8vIGVsZW1lbnRzIHdpbGwgYmUgYWJsZSB0byBkaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZWlyIG5laWdoYm9ycy4gRm9yXG4gICAgLy8gZXhhbXBsZSwgYFxcY29sb3J7cmVkfXsyICt9IDNgIGhhcyB0aGUgc2FtZSBzcGFjaW5nIGFzIGAyICsgM2BcbiAgICByZXR1cm4gbmV3IGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7XG59O1xuXG5ncm91cFR5cGVzLnN1cHN1YiA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3VwZXJzY3JpcHQgYW5kIHN1YnNjcmlwdHMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGFnZVxuICAgIC8vIDQ0NS00NDYsIHJ1bGVzIDE4KGEtZikuXG5cbiAgICAvLyBIZXJlIGlzIHdoZXJlIHdlIGRlZmVyIHRvIHRoZSBpbm5lciBncm91cCBpZiBpdCBzaG91bGQgaGFuZGxlXG4gICAgLy8gc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIGl0c2VsZi5cbiAgICBpZiAoc2hvdWxkSGFuZGxlU3VwU3ViKGdyb3VwLnZhbHVlLmJhc2UsIG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBncm91cFR5cGVzW2dyb3VwLnZhbHVlLmJhc2UudHlwZV0oZ3JvdXAsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBiYXNlID0gYnVpbGRHcm91cChncm91cC52YWx1ZS5iYXNlLCBvcHRpb25zLnJlc2V0KCkpO1xuICAgIHZhciBzdXBtaWQ7XG4gICAgdmFyIHN1Ym1pZDtcbiAgICB2YXIgc3VwO1xuICAgIHZhciBzdWI7XG5cbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBuZXdPcHRpb25zO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnN1cCkge1xuICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuc3VwKCkpO1xuICAgICAgICBzdXAgPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLnN1cCwgbmV3T3B0aW9ucyk7XG4gICAgICAgIHN1cG1pZCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBzdHlsZS5zdXAoKS5jbHMoKV0sXG4gICAgICAgICAgICBbc3VwXSwgbmV3T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnN1Yikge1xuICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuc3ViKCkpO1xuICAgICAgICBzdWIgPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLnN1YiwgbmV3T3B0aW9ucyk7XG4gICAgICAgIHN1Ym1pZCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBzdHlsZS5zdWIoKS5jbHMoKV0sXG4gICAgICAgICAgICBbc3ViXSwgbmV3T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gUnVsZSAxOGFcbiAgICB2YXIgc3VwU2hpZnQ7XG4gICAgdmFyIHN1YlNoaWZ0O1xuICAgIGlmIChpc0NoYXJhY3RlckJveChncm91cC52YWx1ZS5iYXNlKSkge1xuICAgICAgICBzdXBTaGlmdCA9IDA7XG4gICAgICAgIHN1YlNoaWZ0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdXBTaGlmdCA9IGJhc2UuaGVpZ2h0IC0gc3R5bGUubWV0cmljcy5zdXBEcm9wO1xuICAgICAgICBzdWJTaGlmdCA9IGJhc2UuZGVwdGggKyBzdHlsZS5tZXRyaWNzLnN1YkRyb3A7XG4gICAgfVxuXG4gICAgLy8gUnVsZSAxOGNcbiAgICB2YXIgbWluU3VwU2hpZnQ7XG4gICAgaWYgKHN0eWxlID09PSBTdHlsZS5ESVNQTEFZKSB7XG4gICAgICAgIG1pblN1cFNoaWZ0ID0gc3R5bGUubWV0cmljcy5zdXAxO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuY3JhbXBlZCkge1xuICAgICAgICBtaW5TdXBTaGlmdCA9IHN0eWxlLm1ldHJpY3Muc3VwMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBtaW5TdXBTaGlmdCA9IHN0eWxlLm1ldHJpY3Muc3VwMjtcbiAgICB9XG5cbiAgICAvLyBzY3JpcHRzcGFjZSBpcyBhIGZvbnQtc2l6ZS1pbmRlcGVuZGVudCBzaXplLCBzbyBzY2FsZSBpdFxuICAgIC8vIGFwcHJvcHJpYXRlbHlcbiAgICB2YXIgbXVsdGlwbGllciA9IFN0eWxlLlRFWFQuc2l6ZU11bHRpcGxpZXIgKlxuICAgICAgICAgICAgc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIHNjcmlwdHNwYWNlID1cbiAgICAgICAgKDAuNSAvIGZvbnRNZXRyaWNzLm1ldHJpY3MucHRQZXJFbSkgLyBtdWx0aXBsaWVyICsgXCJlbVwiO1xuXG4gICAgdmFyIHN1cHN1YjtcbiAgICBpZiAoIWdyb3VwLnZhbHVlLnN1cCkge1xuICAgICAgICAvLyBSdWxlIDE4YlxuICAgICAgICBzdWJTaGlmdCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgc3ViU2hpZnQsIHN0eWxlLm1ldHJpY3Muc3ViMSxcbiAgICAgICAgICAgIHN1Yi5oZWlnaHQgLSAwLjggKiBzdHlsZS5tZXRyaWNzLnhIZWlnaHQpO1xuXG4gICAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IHN1Ym1pZH1cbiAgICAgICAgXSwgXCJzaGlmdFwiLCBzdWJTaGlmdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgc3Vwc3ViLmNoaWxkcmVuWzBdLnN0eWxlLm1hcmdpblJpZ2h0ID0gc2NyaXB0c3BhY2U7XG5cbiAgICAgICAgLy8gU3Vic2NyaXB0cyBzaG91bGRuJ3QgYmUgc2hpZnRlZCBieSB0aGUgYmFzZSdzIGl0YWxpYyBjb3JyZWN0aW9uLlxuICAgICAgICAvLyBBY2NvdW50IGZvciB0aGF0IGJ5IHNoaWZ0aW5nIHRoZSBzdWJzY3JpcHQgYmFjayB0aGUgYXBwcm9wcmlhdGVcbiAgICAgICAgLy8gYW1vdW50LiBOb3RlIHdlIG9ubHkgZG8gdGhpcyB3aGVuIHRoZSBiYXNlIGlzIGEgc2luZ2xlIHN5bWJvbC5cbiAgICAgICAgaWYgKGJhc2UgaW5zdGFuY2VvZiBkb21UcmVlLnN5bWJvbE5vZGUpIHtcbiAgICAgICAgICAgIHN1cHN1Yi5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5MZWZ0ID0gLWJhc2UuaXRhbGljICsgXCJlbVwiO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghZ3JvdXAudmFsdWUuc3ViKSB7XG4gICAgICAgIC8vIFJ1bGUgMThjLCBkXG4gICAgICAgIHN1cFNoaWZ0ID0gTWF0aC5tYXgoc3VwU2hpZnQsIG1pblN1cFNoaWZ0LFxuICAgICAgICAgICAgc3VwLmRlcHRoICsgMC4yNSAqIHN0eWxlLm1ldHJpY3MueEhlaWdodCk7XG5cbiAgICAgICAgc3Vwc3ViID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkfVxuICAgICAgICBdLCBcInNoaWZ0XCIsIC1zdXBTaGlmdCwgb3B0aW9ucyk7XG5cbiAgICAgICAgc3Vwc3ViLmNoaWxkcmVuWzBdLnN0eWxlLm1hcmdpblJpZ2h0ID0gc2NyaXB0c3BhY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3VwU2hpZnQgPSBNYXRoLm1heChcbiAgICAgICAgICAgIHN1cFNoaWZ0LCBtaW5TdXBTaGlmdCwgc3VwLmRlcHRoICsgMC4yNSAqIHN0eWxlLm1ldHJpY3MueEhlaWdodCk7XG4gICAgICAgIHN1YlNoaWZ0ID0gTWF0aC5tYXgoc3ViU2hpZnQsIHN0eWxlLm1ldHJpY3Muc3ViMik7XG5cbiAgICAgICAgdmFyIHJ1bGVXaWR0aCA9IGZvbnRNZXRyaWNzLm1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3M7XG5cbiAgICAgICAgLy8gUnVsZSAxOGVcbiAgICAgICAgaWYgKChzdXBTaGlmdCAtIHN1cC5kZXB0aCkgLSAoc3ViLmhlaWdodCAtIHN1YlNoaWZ0KSA8XG4gICAgICAgICAgICAgICAgNCAqIHJ1bGVXaWR0aCkge1xuICAgICAgICAgICAgc3ViU2hpZnQgPSA0ICogcnVsZVdpZHRoIC0gKHN1cFNoaWZ0IC0gc3VwLmRlcHRoKSArIHN1Yi5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgcHNpID0gMC44ICogc3R5bGUubWV0cmljcy54SGVpZ2h0IC0gKHN1cFNoaWZ0IC0gc3VwLmRlcHRoKTtcbiAgICAgICAgICAgIGlmIChwc2kgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3VwU2hpZnQgKz0gcHNpO1xuICAgICAgICAgICAgICAgIHN1YlNoaWZ0IC09IHBzaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IHN1Ym1pZCwgc2hpZnQ6IHN1YlNoaWZ0fSxcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkLCBzaGlmdDogLXN1cFNoaWZ0fVxuICAgICAgICBdLCBcImluZGl2aWR1YWxTaGlmdFwiLCBudWxsLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBTZWUgY29tbWVudCBhYm92ZSBhYm91dCBzdWJzY3JpcHRzIG5vdCBiZWluZyBzaGlmdGVkXG4gICAgICAgIGlmIChiYXNlIGluc3RhbmNlb2YgZG9tVHJlZS5zeW1ib2xOb2RlKSB7XG4gICAgICAgICAgICBzdXBzdWIuY2hpbGRyZW5bMF0uc3R5bGUubWFyZ2luTGVmdCA9IC1iYXNlLml0YWxpYyArIFwiZW1cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN1cHN1Yi5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5SaWdodCA9IHNjcmlwdHNwYWNlO1xuICAgICAgICBzdXBzdWIuY2hpbGRyZW5bMV0uc3R5bGUubWFyZ2luUmlnaHQgPSBzY3JpcHRzcGFjZTtcbiAgICB9XG5cbiAgICAvLyBXZSBlbnN1cmUgdG8gd3JhcCB0aGUgc3Vwc3ViIHZsaXN0IGluIGEgc3Bhbi5tc3Vwc3ViIHRvIHJlc2V0IHRleHQtYWxpZ25cbiAgICB2YXIgbWNsYXNzID0gZ2V0VHlwZU9mRG9tVHJlZShiYXNlKSB8fCBcIm1vcmRcIjtcbiAgICByZXR1cm4gbWFrZVNwYW4oW21jbGFzc10sXG4gICAgICAgIFtiYXNlLCBtYWtlU3BhbihbXCJtc3Vwc3ViXCJdLCBbc3Vwc3ViXSldLFxuICAgICAgICBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMuZ2VuZnJhYyA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gRnJhY3Rpb25zIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIG9uIHBhZ2VzIDQ0NC00NDUsIHJ1bGVzIDE1KGEtZSkuXG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHRoaXMgZnJhY3Rpb24gc2hvdWxkIGJlIGluIGJhc2VkIG9uIHRoZVxuICAgIC8vIGZ1bmN0aW9uIHVzZWRcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIGlmIChncm91cC52YWx1ZS5zaXplID09PSBcImRpc3BsYXlcIikge1xuICAgICAgICBzdHlsZSA9IFN0eWxlLkRJU1BMQVk7XG4gICAgfSBlbHNlIGlmIChncm91cC52YWx1ZS5zaXplID09PSBcInRleHRcIikge1xuICAgICAgICBzdHlsZSA9IFN0eWxlLlRFWFQ7XG4gICAgfVxuXG4gICAgdmFyIG5zdHlsZSA9IHN0eWxlLmZyYWNOdW0oKTtcbiAgICB2YXIgZHN0eWxlID0gc3R5bGUuZnJhY0RlbigpO1xuICAgIHZhciBuZXdPcHRpb25zO1xuXG4gICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aFN0eWxlKG5zdHlsZSk7XG4gICAgdmFyIG51bWVyID0gYnVpbGRHcm91cChncm91cC52YWx1ZS5udW1lciwgbmV3T3B0aW9ucyk7XG4gICAgdmFyIG51bWVycmVzZXQgPSBtYWtlU3Bhbihbc3R5bGUucmVzZXQoKSwgbnN0eWxlLmNscygpXSxcbiAgICAgICAgW251bWVyXSwgbmV3T3B0aW9ucyk7XG5cbiAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoZHN0eWxlKTtcbiAgICB2YXIgZGVub20gPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmRlbm9tLCBuZXdPcHRpb25zKTtcbiAgICB2YXIgZGVub21yZXNldCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBkc3R5bGUuY2xzKCldLFxuICAgICAgICBbZGVub21dLCBuZXdPcHRpb25zKTtcblxuICAgIHZhciBydWxlV2lkdGg7XG4gICAgaWYgKGdyb3VwLnZhbHVlLmhhc0JhckxpbmUpIHtcbiAgICAgICAgcnVsZVdpZHRoID0gZm9udE1ldHJpY3MubWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzcyAvXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlLnNpemVNdWx0aXBsaWVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJ1bGVXaWR0aCA9IDA7XG4gICAgfVxuXG4gICAgLy8gUnVsZSAxNWJcbiAgICB2YXIgbnVtU2hpZnQ7XG4gICAgdmFyIGNsZWFyYW5jZTtcbiAgICB2YXIgZGVub21TaGlmdDtcbiAgICBpZiAoc3R5bGUuc2l6ZSA9PT0gU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgICAgIG51bVNoaWZ0ID0gc3R5bGUubWV0cmljcy5udW0xO1xuICAgICAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgY2xlYXJhbmNlID0gMyAqIHJ1bGVXaWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyYW5jZSA9IDcgKiBmb250TWV0cmljcy5tZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGRlbm9tU2hpZnQgPSBzdHlsZS5tZXRyaWNzLmRlbm9tMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocnVsZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgbnVtU2hpZnQgPSBzdHlsZS5tZXRyaWNzLm51bTI7XG4gICAgICAgICAgICBjbGVhcmFuY2UgPSBydWxlV2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1TaGlmdCA9IHN0eWxlLm1ldHJpY3MubnVtMztcbiAgICAgICAgICAgIGNsZWFyYW5jZSA9IDMgKiBmb250TWV0cmljcy5tZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGRlbm9tU2hpZnQgPSBzdHlsZS5tZXRyaWNzLmRlbm9tMjtcbiAgICB9XG5cbiAgICB2YXIgZnJhYztcbiAgICBpZiAocnVsZVdpZHRoID09PSAwKSB7XG4gICAgICAgIC8vIFJ1bGUgMTVjXG4gICAgICAgIHZhciBjYW5kaWRhdGVDbGVhcmFuY2UgPVxuICAgICAgICAgICAgKG51bVNoaWZ0IC0gbnVtZXIuZGVwdGgpIC0gKGRlbm9tLmhlaWdodCAtIGRlbm9tU2hpZnQpO1xuICAgICAgICBpZiAoY2FuZGlkYXRlQ2xlYXJhbmNlIDwgY2xlYXJhbmNlKSB7XG4gICAgICAgICAgICBudW1TaGlmdCArPSAwLjUgKiAoY2xlYXJhbmNlIC0gY2FuZGlkYXRlQ2xlYXJhbmNlKTtcbiAgICAgICAgICAgIGRlbm9tU2hpZnQgKz0gMC41ICogKGNsZWFyYW5jZSAtIGNhbmRpZGF0ZUNsZWFyYW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFjID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogZGVub21yZXNldCwgc2hpZnQ6IGRlbm9tU2hpZnR9LFxuICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBudW1lcnJlc2V0LCBzaGlmdDogLW51bVNoaWZ0fVxuICAgICAgICBdLCBcImluZGl2aWR1YWxTaGlmdFwiLCBudWxsLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSdWxlIDE1ZFxuICAgICAgICB2YXIgYXhpc0hlaWdodCA9IHN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodDtcblxuICAgICAgICBpZiAoKG51bVNoaWZ0IC0gbnVtZXIuZGVwdGgpIC0gKGF4aXNIZWlnaHQgKyAwLjUgKiBydWxlV2lkdGgpIDxcbiAgICAgICAgICAgICAgICBjbGVhcmFuY2UpIHtcbiAgICAgICAgICAgIG51bVNoaWZ0ICs9XG4gICAgICAgICAgICAgICAgY2xlYXJhbmNlIC0gKChudW1TaGlmdCAtIG51bWVyLmRlcHRoKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChheGlzSGVpZ2h0ICsgMC41ICogcnVsZVdpZHRoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGgpIC0gKGRlbm9tLmhlaWdodCAtIGRlbm9tU2hpZnQpIDxcbiAgICAgICAgICAgICAgICBjbGVhcmFuY2UpIHtcbiAgICAgICAgICAgIGRlbm9tU2hpZnQgKz1cbiAgICAgICAgICAgICAgICBjbGVhcmFuY2UgLSAoKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGgpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRlbm9tLmhlaWdodCAtIGRlbm9tU2hpZnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaWQgPSBtYWtlU3BhbihcbiAgICAgICAgICAgIFtvcHRpb25zLnN0eWxlLnJlc2V0KCksIFN0eWxlLlRFWFQuY2xzKCksIFwiZnJhYy1saW5lXCJdKTtcbiAgICAgICAgLy8gTWFudWFsbHkgc2V0IHRoZSBoZWlnaHQgb2YgdGhlIGxpbmUgYmVjYXVzZSBpdHMgaGVpZ2h0IGlzXG4gICAgICAgIC8vIGNyZWF0ZWQgaW4gQ1NTXG4gICAgICAgIG1pZC5oZWlnaHQgPSBydWxlV2lkdGg7XG5cbiAgICAgICAgdmFyIG1pZFNoaWZ0ID0gLShheGlzSGVpZ2h0IC0gMC41ICogcnVsZVdpZHRoKTtcblxuICAgICAgICBmcmFjID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogZGVub21yZXNldCwgc2hpZnQ6IGRlbm9tU2hpZnR9LFxuICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBtaWQsICAgICAgICBzaGlmdDogbWlkU2hpZnR9LFxuICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBudW1lcnJlc2V0LCBzaGlmdDogLW51bVNoaWZ0fVxuICAgICAgICBdLCBcImluZGl2aWR1YWxTaGlmdFwiLCBudWxsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBTaW5jZSB3ZSBtYW51YWxseSBjaGFuZ2UgdGhlIHN0eWxlIHNvbWV0aW1lcyAod2l0aCBcXGRmcmFjIG9yIFxcdGZyYWMpLFxuICAgIC8vIGFjY291bnQgZm9yIHRoZSBwb3NzaWJsZSBzaXplIGNoYW5nZSBoZXJlLlxuICAgIGZyYWMuaGVpZ2h0ICo9IHN0eWxlLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICBmcmFjLmRlcHRoICo9IHN0eWxlLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIC8vIFJ1bGUgMTVlXG4gICAgdmFyIGRlbGltU2l6ZTtcbiAgICBpZiAoc3R5bGUuc2l6ZSA9PT0gU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgICAgIGRlbGltU2l6ZSA9IHN0eWxlLm1ldHJpY3MuZGVsaW0xO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGltU2l6ZSA9IHN0eWxlLm1ldHJpY3MuZGVsaW0yO1xuICAgIH1cblxuICAgIHZhciBsZWZ0RGVsaW07XG4gICAgdmFyIHJpZ2h0RGVsaW07XG4gICAgaWYgKGdyb3VwLnZhbHVlLmxlZnREZWxpbSA9PSBudWxsKSB7XG4gICAgICAgIGxlZnREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1vcGVuXCJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZWZ0RGVsaW0gPSBkZWxpbWl0ZXIuY3VzdG9tU2l6ZWREZWxpbShcbiAgICAgICAgICAgIGdyb3VwLnZhbHVlLmxlZnREZWxpbSwgZGVsaW1TaXplLCB0cnVlLFxuICAgICAgICAgICAgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUpLCBncm91cC5tb2RlLCBbXCJtb3BlblwiXSk7XG4gICAgfVxuICAgIGlmIChncm91cC52YWx1ZS5yaWdodERlbGltID09IG51bGwpIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1jbG9zZVwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IGRlbGltaXRlci5jdXN0b21TaXplZERlbGltKFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUucmlnaHREZWxpbSwgZGVsaW1TaXplLCB0cnVlLFxuICAgICAgICAgICAgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUpLCBncm91cC5tb2RlLCBbXCJtY2xvc2VcIl0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYWtlU3BhbihcbiAgICAgICAgW1wibW9yZFwiLCBvcHRpb25zLnN0eWxlLnJlc2V0KCksIHN0eWxlLmNscygpXSxcbiAgICAgICAgW2xlZnREZWxpbSwgbWFrZVNwYW4oW1wibWZyYWNcIl0sIFtmcmFjXSksIHJpZ2h0RGVsaW1dLFxuICAgICAgICBvcHRpb25zKTtcbn07XG5cbnZhciBjYWxjdWxhdGVTaXplID0gZnVuY3Rpb24oc2l6ZVZhbHVlLCBzdHlsZSkge1xuICAgIHZhciB4ID0gc2l6ZVZhbHVlLm51bWJlcjtcbiAgICBpZiAoc2l6ZVZhbHVlLnVuaXQgPT09IFwiZXhcIikge1xuICAgICAgICB4ICo9IHN0eWxlLm1ldHJpY3MuZW1QZXJFeDtcbiAgICB9IGVsc2UgaWYgKHNpemVWYWx1ZS51bml0ID09PSBcIm11XCIpIHtcbiAgICAgICAgeCAvPSAxODtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59O1xuXG5ncm91cFR5cGVzLmFycmF5ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgcjtcbiAgICB2YXIgYztcbiAgICB2YXIgbnIgPSBncm91cC52YWx1ZS5ib2R5Lmxlbmd0aDtcbiAgICB2YXIgbmMgPSAwO1xuICAgIHZhciBib2R5ID0gbmV3IEFycmF5KG5yKTtcblxuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgICAvLyBIb3Jpem9udGFsIHNwYWNpbmdcbiAgICB2YXIgcHQgPSAxIC8gZm9udE1ldHJpY3MubWV0cmljcy5wdFBlckVtO1xuICAgIHZhciBhcnJheWNvbHNlcCA9IDUgKiBwdDsgLy8gXFxhcnJheWNvbHNlcCBpbiBhcnRpY2xlLmNsc1xuXG4gICAgLy8gVmVydGljYWwgc3BhY2luZ1xuICAgIHZhciBiYXNlbGluZXNraXAgPSAxMiAqIHB0OyAvLyBzZWUgc2l6ZTEwLmNsb1xuICAgIC8vIERlZmF1bHQgXFxhcnJheXN0cmV0Y2ggZnJvbSBsdHRhYi5kdHhcbiAgICAvLyBUT0RPKGdhZ2Vybik6IG1heSBnZXQgcmVkZWZpbmVkIG9uY2Ugd2UgaGF2ZSB1c2VyLWRlZmluZWQgbWFjcm9zXG4gICAgdmFyIGFycmF5c3RyZXRjaCA9IHV0aWxzLmRlZmx0KGdyb3VwLnZhbHVlLmFycmF5c3RyZXRjaCwgMSk7XG4gICAgdmFyIGFycmF5c2tpcCA9IGFycmF5c3RyZXRjaCAqIGJhc2VsaW5lc2tpcDtcbiAgICB2YXIgYXJzdHJ1dEhlaWdodCA9IDAuNyAqIGFycmF5c2tpcDsgLy8gXFxzdHJ1dGJveCBpbiBsdGZzc3RyYy5kdHggYW5kXG4gICAgdmFyIGFyc3RydXREZXB0aCA9IDAuMyAqIGFycmF5c2tpcDsgIC8vIFxcQGFyc3RydXRib3ggaW4gbHR0YWIuZHR4XG5cbiAgICB2YXIgdG90YWxIZWlnaHQgPSAwO1xuICAgIGZvciAociA9IDA7IHIgPCBncm91cC52YWx1ZS5ib2R5Lmxlbmd0aDsgKytyKSB7XG4gICAgICAgIHZhciBpbnJvdyA9IGdyb3VwLnZhbHVlLmJvZHlbcl07XG4gICAgICAgIHZhciBoZWlnaHQgPSBhcnN0cnV0SGVpZ2h0OyAvLyBcXEBhcnJheSBhZGRzIGFuIFxcQGFyc3RydXRcbiAgICAgICAgdmFyIGRlcHRoID0gYXJzdHJ1dERlcHRoOyAgIC8vIHRvIGVhY2ggdG93ICh2aWEgdGhlIHRlbXBsYXRlKVxuXG4gICAgICAgIGlmIChuYyA8IGlucm93Lmxlbmd0aCkge1xuICAgICAgICAgICAgbmMgPSBpbnJvdy5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cm93ID0gbmV3IEFycmF5KGlucm93Lmxlbmd0aCk7XG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCBpbnJvdy5sZW5ndGg7ICsrYykge1xuICAgICAgICAgICAgdmFyIGVsdCA9IGJ1aWxkR3JvdXAoaW5yb3dbY10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKGRlcHRoIDwgZWx0LmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgZGVwdGggPSBlbHQuZGVwdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgZWx0LmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGVsdC5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRyb3dbY10gPSBlbHQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZ2FwID0gMDtcbiAgICAgICAgaWYgKGdyb3VwLnZhbHVlLnJvd0dhcHNbcl0pIHtcbiAgICAgICAgICAgIGdhcCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAudmFsdWUucm93R2Fwc1tyXS52YWx1ZSwgc3R5bGUpO1xuICAgICAgICAgICAgaWYgKGdhcCA+IDApIHsgLy8gXFxAYXJnYXJyYXljclxuICAgICAgICAgICAgICAgIGdhcCArPSBhcnN0cnV0RGVwdGg7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDwgZ2FwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZ2FwOyAvLyBcXEB4YXJnYXJyYXljclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnYXAgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cm93LmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgb3V0cm93LmRlcHRoID0gZGVwdGg7XG4gICAgICAgIHRvdGFsSGVpZ2h0ICs9IGhlaWdodDtcbiAgICAgICAgb3V0cm93LnBvcyA9IHRvdGFsSGVpZ2h0O1xuICAgICAgICB0b3RhbEhlaWdodCArPSBkZXB0aCArIGdhcDsgLy8gXFxAeWFyZ2FycmF5Y3JcbiAgICAgICAgYm9keVtyXSA9IG91dHJvdztcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0ID0gdG90YWxIZWlnaHQgLyAyICsgc3R5bGUubWV0cmljcy5heGlzSGVpZ2h0O1xuICAgIHZhciBjb2xEZXNjcmlwdGlvbnMgPSBncm91cC52YWx1ZS5jb2xzIHx8IFtdO1xuICAgIHZhciBjb2xzID0gW107XG4gICAgdmFyIGNvbFNlcDtcbiAgICB2YXIgY29sRGVzY3JOdW07XG4gICAgZm9yIChjID0gMCwgY29sRGVzY3JOdW0gPSAwO1xuICAgICAgICAgLy8gQ29udGludWUgd2hpbGUgZWl0aGVyIHRoZXJlIGFyZSBtb3JlIGNvbHVtbnMgb3IgbW9yZSBjb2x1bW5cbiAgICAgICAgIC8vIGRlc2NyaXB0aW9ucywgc28gdHJhaWxpbmcgc2VwYXJhdG9ycyBkb24ndCBnZXQgbG9zdC5cbiAgICAgICAgIGMgPCBuYyB8fCBjb2xEZXNjck51bSA8IGNvbERlc2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgICArK2MsICsrY29sRGVzY3JOdW0pIHtcblxuICAgICAgICB2YXIgY29sRGVzY3IgPSBjb2xEZXNjcmlwdGlvbnNbY29sRGVzY3JOdW1dIHx8IHt9O1xuXG4gICAgICAgIHZhciBmaXJzdFNlcGFyYXRvciA9IHRydWU7XG4gICAgICAgIHdoaWxlIChjb2xEZXNjci50eXBlID09PSBcInNlcGFyYXRvclwiKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHNlcGFyYXRvciBpbiBhIHJvdywgYWRkIGEgc3BhY2VcbiAgICAgICAgICAgIC8vIGJldHdlZW4gdGhlbS5cbiAgICAgICAgICAgIGlmICghZmlyc3RTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb2xTZXAgPSBtYWtlU3BhbihbXCJhcnJheWNvbHNlcFwiXSwgW10pO1xuICAgICAgICAgICAgICAgIGNvbFNlcC5zdHlsZS53aWR0aCA9XG4gICAgICAgICAgICAgICAgICAgIGZvbnRNZXRyaWNzLm1ldHJpY3MuZG91YmxlUnVsZVNlcCArIFwiZW1cIjtcbiAgICAgICAgICAgICAgICBjb2xzLnB1c2goY29sU2VwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbERlc2NyLnNlcGFyYXRvciA9PT0gXCJ8XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gbWFrZVNwYW4oXG4gICAgICAgICAgICAgICAgICAgIFtcInZlcnRpY2FsLXNlcGFyYXRvclwiXSxcbiAgICAgICAgICAgICAgICAgICAgW10pO1xuICAgICAgICAgICAgICAgIHNlcGFyYXRvci5zdHlsZS5oZWlnaHQgPSB0b3RhbEhlaWdodCArIFwiZW1cIjtcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3Iuc3R5bGUudmVydGljYWxBbGlnbiA9XG4gICAgICAgICAgICAgICAgICAgIC0odG90YWxIZWlnaHQgLSBvZmZzZXQpICsgXCJlbVwiO1xuXG4gICAgICAgICAgICAgICAgY29scy5wdXNoKHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgICBcIkludmFsaWQgc2VwYXJhdG9yIHR5cGU6IFwiICsgY29sRGVzY3Iuc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29sRGVzY3JOdW0rKztcbiAgICAgICAgICAgIGNvbERlc2NyID0gY29sRGVzY3JpcHRpb25zW2NvbERlc2NyTnVtXSB8fCB7fTtcbiAgICAgICAgICAgIGZpcnN0U2VwYXJhdG9yID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYyA+PSBuYykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2Vwd2lkdGg7XG4gICAgICAgIGlmIChjID4gMCB8fCBncm91cC52YWx1ZS5oc2tpcEJlZm9yZUFuZEFmdGVyKSB7XG4gICAgICAgICAgICBzZXB3aWR0aCA9IHV0aWxzLmRlZmx0KGNvbERlc2NyLnByZWdhcCwgYXJyYXljb2xzZXApO1xuICAgICAgICAgICAgaWYgKHNlcHdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29sU2VwID0gbWFrZVNwYW4oW1wiYXJyYXljb2xzZXBcIl0sIFtdKTtcbiAgICAgICAgICAgICAgICBjb2xTZXAuc3R5bGUud2lkdGggPSBzZXB3aWR0aCArIFwiZW1cIjtcbiAgICAgICAgICAgICAgICBjb2xzLnB1c2goY29sU2VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2wgPSBbXTtcbiAgICAgICAgZm9yIChyID0gMDsgciA8IG5yOyArK3IpIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBib2R5W3JdO1xuICAgICAgICAgICAgdmFyIGVsZW0gPSByb3dbY107XG4gICAgICAgICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzaGlmdCA9IHJvdy5wb3MgLSBvZmZzZXQ7XG4gICAgICAgICAgICBlbGVtLmRlcHRoID0gcm93LmRlcHRoO1xuICAgICAgICAgICAgZWxlbS5oZWlnaHQgPSByb3cuaGVpZ2h0O1xuICAgICAgICAgICAgY29sLnB1c2goe3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBlbGVtLCBzaGlmdDogc2hpZnR9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChjb2wsIFwiaW5kaXZpZHVhbFNoaWZ0XCIsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICBjb2wgPSBtYWtlU3BhbihcbiAgICAgICAgICAgIFtcImNvbC1hbGlnbi1cIiArIChjb2xEZXNjci5hbGlnbiB8fCBcImNcIildLFxuICAgICAgICAgICAgW2NvbF0pO1xuICAgICAgICBjb2xzLnB1c2goY29sKTtcblxuICAgICAgICBpZiAoYyA8IG5jIC0gMSB8fCBncm91cC52YWx1ZS5oc2tpcEJlZm9yZUFuZEFmdGVyKSB7XG4gICAgICAgICAgICBzZXB3aWR0aCA9IHV0aWxzLmRlZmx0KGNvbERlc2NyLnBvc3RnYXAsIGFycmF5Y29sc2VwKTtcbiAgICAgICAgICAgIGlmIChzZXB3aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbFNlcCA9IG1ha2VTcGFuKFtcImFycmF5Y29sc2VwXCJdLCBbXSk7XG4gICAgICAgICAgICAgICAgY29sU2VwLnN0eWxlLndpZHRoID0gc2Vwd2lkdGggKyBcImVtXCI7XG4gICAgICAgICAgICAgICAgY29scy5wdXNoKGNvbFNlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYm9keSA9IG1ha2VTcGFuKFtcIm10YWJsZVwiXSwgY29scyk7XG4gICAgcmV0dXJuIG1ha2VTcGFuKFtcIm1vcmRcIl0sIFtib2R5XSwgb3B0aW9ucyk7XG59O1xuXG5ncm91cFR5cGVzLnNwYWNpbmcgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIGlmIChncm91cC52YWx1ZSA9PT0gXCJcXFxcIFwiIHx8IGdyb3VwLnZhbHVlID09PSBcIlxcXFxzcGFjZVwiIHx8XG4gICAgICAgIGdyb3VwLnZhbHVlID09PSBcIiBcIiB8fCBncm91cC52YWx1ZSA9PT0gXCJ+XCIpIHtcbiAgICAgICAgLy8gU3BhY2VzIGFyZSBnZW5lcmF0ZWQgYnkgYWRkaW5nIGFuIGFjdHVhbCBzcGFjZS4gRWFjaCBvZiB0aGVzZVxuICAgICAgICAvLyB0aGluZ3MgaGFzIGFuIGVudHJ5IGluIHRoZSBzeW1ib2xzIHRhYmxlLCBzbyB0aGVzZSB3aWxsIGJlIHR1cm5lZFxuICAgICAgICAvLyBpbnRvIGFwcHJvcHJpYXRlIG91dHB1dHMuXG4gICAgICAgIGlmIChncm91cC5tb2RlID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsIFwidGV4dG9yZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlU3BhbihbXCJtc3BhY2VcIl0sXG4gICAgICAgICAgICAgICAgW2J1aWxkQ29tbW9uLm1hdGhzeW0oZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUsIG9wdGlvbnMpXSxcbiAgICAgICAgICAgICAgICBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyIGtpbmRzIG9mIHNwYWNlcyBhcmUgb2YgYXJiaXRyYXJ5IHdpZHRoLiBXZSB1c2UgQ1NTIHRvXG4gICAgICAgIC8vIGdlbmVyYXRlIHRoZXNlLlxuICAgICAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgICAgICBbXCJtc3BhY2VcIixcbiAgICAgICAgICAgICAgICBidWlsZENvbW1vbi5zcGFjaW5nRnVuY3Rpb25zW2dyb3VwLnZhbHVlXS5jbGFzc05hbWVdLFxuICAgICAgICAgICAgW10sIG9wdGlvbnMpO1xuICAgIH1cbn07XG5cbmdyb3VwVHlwZXMubGxhcCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImlubmVyXCJdLCBbYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zLnJlc2V0KCkpXSk7XG4gICAgdmFyIGZpeCA9IG1ha2VTcGFuKFtcImZpeFwiXSwgW10pO1xuICAgIHJldHVybiBtYWtlU3BhbihcbiAgICAgICAgW1wibW9yZFwiLCBcImxsYXBcIiwgb3B0aW9ucy5zdHlsZS5jbHMoKV0sIFtpbm5lciwgZml4XSwgb3B0aW9ucyk7XG59O1xuXG5ncm91cFR5cGVzLnJsYXAgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBpbm5lciA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJpbm5lclwiXSwgW2J1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy5yZXNldCgpKV0pO1xuICAgIHZhciBmaXggPSBtYWtlU3BhbihbXCJmaXhcIl0sIFtdKTtcbiAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgIFtcIm1vcmRcIiwgXCJybGFwXCIsIG9wdGlvbnMuc3R5bGUuY2xzKCldLCBbaW5uZXIsIGZpeF0sIG9wdGlvbnMpO1xufTtcblxuZ3JvdXBUeXBlcy5vcCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gT3BlcmF0b3JzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMtNDQ0LCBydWxlIDEzKGEpLlxuICAgIHZhciBzdXBHcm91cDtcbiAgICB2YXIgc3ViR3JvdXA7XG4gICAgdmFyIGhhc0xpbWl0cyA9IGZhbHNlO1xuICAgIGlmIChncm91cC50eXBlID09PSBcInN1cHN1YlwiKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbGltaXRzLCBzdXBzdWIgd2lsbCBwYXNzIHVzIGl0cyBncm91cCB0byBoYW5kbGUuIFB1bGxcbiAgICAgICAgLy8gb3V0IHRoZSBzdXBlcnNjcmlwdCBhbmQgc3Vic2NyaXB0IGFuZCBzZXQgdGhlIGdyb3VwIHRvIHRoZSBvcCBpblxuICAgICAgICAvLyBpdHMgYmFzZS5cbiAgICAgICAgc3VwR3JvdXAgPSBncm91cC52YWx1ZS5zdXA7XG4gICAgICAgIHN1Ykdyb3VwID0gZ3JvdXAudmFsdWUuc3ViO1xuICAgICAgICBncm91cCA9IGdyb3VwLnZhbHVlLmJhc2U7XG4gICAgICAgIGhhc0xpbWl0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIC8vIE1vc3Qgb3BlcmF0b3JzIGhhdmUgYSBsYXJnZSBzdWNjZXNzb3Igc3ltYm9sLCBidXQgdGhlc2UgZG9uJ3QuXG4gICAgdmFyIG5vU3VjY2Vzc29yID0gW1xuICAgICAgICBcIlxcXFxzbWFsbGludFwiXG4gICAgXTtcblxuICAgIHZhciBsYXJnZSA9IGZhbHNlO1xuICAgIGlmIChzdHlsZS5zaXplID09PSBTdHlsZS5ESVNQTEFZLnNpemUgJiZcbiAgICAgICAgZ3JvdXAudmFsdWUuc3ltYm9sICYmXG4gICAgICAgICF1dGlscy5jb250YWlucyhub1N1Y2Nlc3NvciwgZ3JvdXAudmFsdWUuYm9keSkpIHtcblxuICAgICAgICAvLyBNb3N0IHN5bWJvbCBvcGVyYXRvcnMgZ2V0IGxhcmdlciBpbiBkaXNwbGF5c3R5bGUgKHJ1bGUgMTMpXG4gICAgICAgIGxhcmdlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZTtcbiAgICB2YXIgYmFzZVNoaWZ0ID0gMDtcbiAgICB2YXIgc2xhbnQgPSAwO1xuICAgIGlmIChncm91cC52YWx1ZS5zeW1ib2wpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN5bWJvbCwgY3JlYXRlIHRoZSBzeW1ib2wuXG4gICAgICAgIHZhciBmb250TmFtZSA9IGxhcmdlID8gXCJTaXplMi1SZWd1bGFyXCIgOiBcIlNpemUxLVJlZ3VsYXJcIjtcbiAgICAgICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woXG4gICAgICAgICAgICBncm91cC52YWx1ZS5ib2R5LCBmb250TmFtZSwgXCJtYXRoXCIsIG9wdGlvbnMsXG4gICAgICAgICAgICBbXCJtb3BcIiwgXCJvcC1zeW1ib2xcIiwgbGFyZ2UgPyBcImxhcmdlLW9wXCIgOiBcInNtYWxsLW9wXCJdKTtcblxuICAgICAgICAvLyBTaGlmdCB0aGUgc3ltYm9sIHNvIGl0cyBjZW50ZXIgbGllcyBvbiB0aGUgYXhpcyAocnVsZSAxMykuIEl0XG4gICAgICAgIC8vIGFwcGVhcnMgdGhhdCBvdXIgZm9udHMgaGF2ZSB0aGUgY2VudGVycyBvZiB0aGUgc3ltYm9scyBhbHJlYWR5XG4gICAgICAgIC8vIGFsbW9zdCBvbiB0aGUgYXhpcywgc28gdGhlc2UgbnVtYmVycyBhcmUgdmVyeSBzbWFsbC4gTm90ZSB3ZVxuICAgICAgICAvLyBkb24ndCBhY3R1YWxseSBhcHBseSB0aGlzIGhlcmUsIGJ1dCBpbnN0ZWFkIGl0IGlzIHVzZWQgZWl0aGVyIGluXG4gICAgICAgIC8vIHRoZSB2bGlzdCBjcmVhdGlvbiBvciBzZXBhcmF0ZWx5IHdoZW4gdGhlcmUgYXJlIG5vIGxpbWl0cy5cbiAgICAgICAgYmFzZVNoaWZ0ID0gKGJhc2UuaGVpZ2h0IC0gYmFzZS5kZXB0aCkgLyAyIC1cbiAgICAgICAgICAgIHN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodCAqIHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgICAgIC8vIFRoZSBzbGFudCBvZiB0aGUgc3ltYm9sIGlzIGp1c3QgaXRzIGl0YWxpYyBjb3JyZWN0aW9uLlxuICAgICAgICBzbGFudCA9IGJhc2UuaXRhbGljO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudmFsdWUudmFsdWUpIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGxpc3QsIGNvbXBvc2UgdGhhdCBsaXN0LlxuICAgICAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgICAgIGJhc2UgPSBtYWtlU3BhbihbXCJtb3BcIl0sIGlubmVyLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgaXMgYSB0ZXh0IG9wZXJhdG9yLiBCdWlsZCB0aGUgdGV4dCBmcm9tIHRoZVxuICAgICAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgICAgIC8vIFRPRE8oZW1pbHkpOiBBZGQgYSBzcGFjZSBpbiB0aGUgbWlkZGxlIG9mIHNvbWUgb2YgdGhlc2VcbiAgICAgICAgLy8gb3BlcmF0b3JzLCBsaWtlIFxcbGltc3VwXG4gICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBncm91cC52YWx1ZS5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChidWlsZENvbW1vbi5tYXRoc3ltKGdyb3VwLnZhbHVlLmJvZHlbaV0sIGdyb3VwLm1vZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBiYXNlID0gbWFrZVNwYW4oW1wibW9wXCJdLCBvdXRwdXQsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGlmIChoYXNMaW1pdHMpIHtcbiAgICAgICAgLy8gSUUgOCBjbGlwcyBcXGludCBpZiBpdCBpcyBpbiBhIGRpc3BsYXk6IGlubGluZS1ibG9jay4gV2Ugd3JhcCBpdFxuICAgICAgICAvLyBpbiBhIG5ldyBzcGFuIHNvIGl0IGlzIGFuIGlubGluZSwgYW5kIHdvcmtzLlxuICAgICAgICBiYXNlID0gbWFrZVNwYW4oW10sIFtiYXNlXSk7XG5cbiAgICAgICAgdmFyIHN1cG1pZDtcbiAgICAgICAgdmFyIHN1cEtlcm47XG4gICAgICAgIHZhciBzdWJtaWQ7XG4gICAgICAgIHZhciBzdWJLZXJuO1xuICAgICAgICB2YXIgbmV3T3B0aW9ucztcbiAgICAgICAgLy8gV2UgbWFudWFsbHkgaGF2ZSB0byBoYW5kbGUgdGhlIHN1cGVyc2NyaXB0cyBhbmQgc3Vic2NyaXB0cy4gVGhpcyxcbiAgICAgICAgLy8gYXNpZGUgZnJvbSB0aGUga2VybiBjYWxjdWxhdGlvbnMsIGlzIGNvcGllZCBmcm9tIHN1cHN1Yi5cbiAgICAgICAgaWYgKHN1cEdyb3VwKSB7XG4gICAgICAgICAgICBuZXdPcHRpb25zID0gb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuc3VwKCkpO1xuICAgICAgICAgICAgdmFyIHN1cCA9IGJ1aWxkR3JvdXAoc3VwR3JvdXAsIG5ld09wdGlvbnMpO1xuICAgICAgICAgICAgc3VwbWlkID0gbWFrZVNwYW4oW3N0eWxlLnJlc2V0KCksIHN0eWxlLnN1cCgpLmNscygpXSxcbiAgICAgICAgICAgICAgICBbc3VwXSwgbmV3T3B0aW9ucyk7XG5cbiAgICAgICAgICAgIHN1cEtlcm4gPSBNYXRoLm1heChcbiAgICAgICAgICAgICAgICBmb250TWV0cmljcy5tZXRyaWNzLmJpZ09wU3BhY2luZzEsXG4gICAgICAgICAgICAgICAgZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmczIC0gc3VwLmRlcHRoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWJHcm91cCkge1xuICAgICAgICAgICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aFN0eWxlKHN0eWxlLnN1YigpKTtcbiAgICAgICAgICAgIHZhciBzdWIgPSBidWlsZEdyb3VwKHN1Ykdyb3VwLCBuZXdPcHRpb25zKTtcbiAgICAgICAgICAgIHN1Ym1pZCA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBzdHlsZS5zdWIoKS5jbHMoKV0sXG4gICAgICAgICAgICAgICAgW3N1Yl0sIG5ld09wdGlvbnMpO1xuXG4gICAgICAgICAgICBzdWJLZXJuID0gTWF0aC5tYXgoXG4gICAgICAgICAgICAgICAgZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmcyLFxuICAgICAgICAgICAgICAgIGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNCAtIHN1Yi5oZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgdGhlIGZpbmFsIGdyb3VwIGFzIGEgdmxpc3Qgb2YgdGhlIHBvc3NpYmxlIHN1YnNjcmlwdCwgYmFzZSxcbiAgICAgICAgLy8gYW5kIHBvc3NpYmxlIHN1cGVyc2NyaXB0LlxuICAgICAgICB2YXIgZmluYWxHcm91cDtcbiAgICAgICAgdmFyIHRvcDtcbiAgICAgICAgdmFyIGJvdHRvbTtcbiAgICAgICAgaWYgKCFzdXBHcm91cCkge1xuICAgICAgICAgICAgdG9wID0gYmFzZS5oZWlnaHQgLSBiYXNlU2hpZnQ7XG5cbiAgICAgICAgICAgIGZpbmFsR3JvdXAgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoW1xuICAgICAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmc1fSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IHN1Ym1pZH0sXG4gICAgICAgICAgICAgICAge3R5cGU6IFwia2VyblwiLCBzaXplOiBzdWJLZXJufSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGJhc2V9XG4gICAgICAgICAgICBdLCBcInRvcFwiLCB0b3AsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBIZXJlLCB3ZSBzaGlmdCB0aGUgbGltaXRzIGJ5IHRoZSBzbGFudCBvZiB0aGUgc3ltYm9sLiBOb3RlXG4gICAgICAgICAgICAvLyB0aGF0IHdlIGFyZSBzdXBwb3NlZCB0byBzaGlmdCB0aGUgbGltaXRzIGJ5IDEvMiBvZiB0aGUgc2xhbnQsXG4gICAgICAgICAgICAvLyBidXQgc2luY2Ugd2UgYXJlIGNlbnRlcmluZyB0aGUgbGltaXRzIGFkZGluZyBhIGZ1bGwgc2xhbnQgb2ZcbiAgICAgICAgICAgIC8vIG1hcmdpbiB3aWxsIHNoaWZ0IGJ5IDEvMiB0aGF0LlxuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5MZWZ0ID0gLXNsYW50ICsgXCJlbVwiO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdWJHcm91cCkge1xuICAgICAgICAgICAgYm90dG9tID0gYmFzZS5kZXB0aCArIGJhc2VTaGlmdDtcblxuICAgICAgICAgICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBiYXNlfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IHN1cEtlcm59LFxuICAgICAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNX1cbiAgICAgICAgICAgIF0sIFwiYm90dG9tXCIsIGJvdHRvbSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIGFib3V0IHNsYW50c1xuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblsxXS5zdHlsZS5tYXJnaW5MZWZ0ID0gc2xhbnQgKyBcImVtXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN1cEdyb3VwICYmICFzdWJHcm91cCkge1xuICAgICAgICAgICAgLy8gVGhpcyBjYXNlIHByb2JhYmx5IHNob3VsZG4ndCBvY2N1ciAodGhpcyB3b3VsZCBtZWFuIHRoZVxuICAgICAgICAgICAgLy8gc3Vwc3ViIHdhcyBzZW5kaW5nIHVzIGEgZ3JvdXAgd2l0aCBubyBzdXBlcnNjcmlwdCBvclxuICAgICAgICAgICAgLy8gc3Vic2NyaXB0KSBidXQgYmUgc2FmZS5cbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm90dG9tID0gZm9udE1ldHJpY3MubWV0cmljcy5iaWdPcFNwYWNpbmc1ICtcbiAgICAgICAgICAgICAgICBzdWJtaWQuaGVpZ2h0ICsgc3VibWlkLmRlcHRoICtcbiAgICAgICAgICAgICAgICBzdWJLZXJuICtcbiAgICAgICAgICAgICAgICBiYXNlLmRlcHRoICsgYmFzZVNoaWZ0O1xuXG4gICAgICAgICAgICBmaW5hbEdyb3VwID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFtcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNX0sXG4gICAgICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBzdWJtaWR9LFxuICAgICAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogc3ViS2Vybn0sXG4gICAgICAgICAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBiYXNlfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IHN1cEtlcm59LFxuICAgICAgICAgICAgICAgIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogc3VwbWlkfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IGZvbnRNZXRyaWNzLm1ldHJpY3MuYmlnT3BTcGFjaW5nNX1cbiAgICAgICAgICAgIF0sIFwiYm90dG9tXCIsIGJvdHRvbSwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IGFib3ZlIGFib3V0IHNsYW50c1xuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblswXS5zdHlsZS5tYXJnaW5MZWZ0ID0gLXNsYW50ICsgXCJlbVwiO1xuICAgICAgICAgICAgZmluYWxHcm91cC5jaGlsZHJlblsyXS5zdHlsZS5tYXJnaW5MZWZ0ID0gc2xhbnQgKyBcImVtXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFrZVNwYW4oW1wibW9wXCIsIFwib3AtbGltaXRzXCJdLCBbZmluYWxHcm91cF0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChncm91cC52YWx1ZS5zeW1ib2wpIHtcbiAgICAgICAgICAgIGJhc2Uuc3R5bGUudG9wID0gYmFzZVNoaWZ0ICsgXCJlbVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufTtcblxuZ3JvdXBUeXBlcy5tb2QgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBpbm5lciA9IFtdO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwiYm1vZFwiKSB7XG4gICAgICAgIC8vIOKAnFxcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcFxcbWtlcm41bXXigJ1cbiAgICAgICAgaWYgKCFvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihcbiAgICAgICAgICAgICAgICBbXCJtc3BhY2VcIiwgXCJuZWdhdGl2ZW1lZGl1bXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oW1wibXNwYWNlXCIsIFwidGhpY2tzcGFjZVwiXSwgW10sIG9wdGlvbnMpKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc3R5bGUuc2l6ZSA9PT0gU3R5bGUuRElTUExBWS5zaXplKSB7XG4gICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oW1wibXNwYWNlXCIsIFwicXVhZFwiXSwgW10sIG9wdGlvbnMpKTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwibW9kXCIpIHtcbiAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtc3BhY2VcIiwgXCJ0d2VsdmVtdXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oW1wibXNwYWNlXCIsIFwiZWlnaHRtdXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlID09PSBcInBvZFwiIHx8IGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwicG1vZFwiKSB7XG4gICAgICAgIGlubmVyLnB1c2goYnVpbGRDb21tb24ubWF0aHN5bShcIihcIiwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlICE9PSBcInBvZFwiKSB7XG4gICAgICAgIHZhciBtb2RJbm5lciA9IFtcbiAgICAgICAgICAgIGJ1aWxkQ29tbW9uLm1hdGhzeW0oXCJtXCIsIGdyb3VwLm1vZGUpLFxuICAgICAgICAgICAgYnVpbGRDb21tb24ubWF0aHN5bShcIm9cIiwgZ3JvdXAubW9kZSksXG4gICAgICAgICAgICBidWlsZENvbW1vbi5tYXRoc3ltKFwiZFwiLCBncm91cC5tb2RlKV07XG4gICAgICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlID09PSBcImJtb2RcIikge1xuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtYmluXCJdLCBtb2RJbm5lciwgb3B0aW9ucykpO1xuICAgICAgICAgICAgLy8g4oCcXFxta2VybjVtdVxcbm9uc2NyaXB0XFxtc2tpcC1cXG1lZG11c2tpcOKAnVxuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtc3BhY2VcIiwgXCJ0aGlja3NwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkge1xuICAgICAgICAgICAgICAgIGlubmVyLnB1c2gobWFrZVNwYW4oXG4gICAgICAgICAgICAgICAgICAgIFtcIm1zcGFjZVwiLCBcIm5lZ2F0aXZlbWVkaXVtc3BhY2VcIl0sIFtdLCBvcHRpb25zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpbm5lciwgbW9kSW5uZXIpO1xuICAgICAgICAgICAgaW5uZXIucHVzaChtYWtlU3BhbihbXCJtc3BhY2VcIiwgXCJzaXhtdXNwYWNlXCJdLCBbXSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnZhbHVlKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGlubmVyLFxuICAgICAgICAgICAgYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLnZhbHVlLCBvcHRpb25zLCBmYWxzZSkpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5tb2RUeXBlID09PSBcInBvZFwiIHx8IGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwicG1vZFwiKSB7XG4gICAgICAgIGlubmVyLnB1c2goYnVpbGRDb21tb24ubWF0aHN5bShcIilcIiwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoaW5uZXIpO1xufTtcblxuZ3JvdXBUeXBlcy5rYXRleCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gVGhlIEthVGVYIGxvZ28uIFRoZSBvZmZzZXRzIGZvciB0aGUgSyBhbmQgYSB3ZXJlIGNob3NlbiB0byBsb29rXG4gICAgLy8gZ29vZCwgYnV0IHRoZSBvZmZzZXRzIGZvciB0aGUgVCwgRSwgYW5kIFggd2VyZSB0YWtlbiBmcm9tIHRoZVxuICAgIC8vIGRlZmluaXRpb24gb2YgXFxUZVggaW4gVGVYIChzZWUgVGVYYm9vayBwZy4gMzU2KVxuICAgIHZhciBrID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImtcIl0sIFtidWlsZENvbW1vbi5tYXRoc3ltKFwiS1wiLCBncm91cC5tb2RlKV0sIG9wdGlvbnMpO1xuICAgIHZhciBhID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImFcIl0sIFtidWlsZENvbW1vbi5tYXRoc3ltKFwiQVwiLCBncm91cC5tb2RlKV0sIG9wdGlvbnMpO1xuXG4gICAgYS5oZWlnaHQgPSAoYS5oZWlnaHQgKyAwLjIpICogMC43NTtcbiAgICBhLmRlcHRoID0gKGEuaGVpZ2h0IC0gMC4yKSAqIDAuNzU7XG5cbiAgICB2YXIgdCA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJ0XCJdLCBbYnVpbGRDb21tb24ubWF0aHN5bShcIlRcIiwgZ3JvdXAubW9kZSldLCBvcHRpb25zKTtcbiAgICB2YXIgZSA9IG1ha2VTcGFuKFxuICAgICAgICBbXCJlXCJdLCBbYnVpbGRDb21tb24ubWF0aHN5bShcIkVcIiwgZ3JvdXAubW9kZSldLCBvcHRpb25zKTtcblxuICAgIGUuaGVpZ2h0ID0gKGUuaGVpZ2h0IC0gMC4yMTU1KTtcbiAgICBlLmRlcHRoID0gKGUuZGVwdGggKyAwLjIxNTUpO1xuXG4gICAgdmFyIHggPSBtYWtlU3BhbihcbiAgICAgICAgW1wieFwiXSwgW2J1aWxkQ29tbW9uLm1hdGhzeW0oXCJYXCIsIGdyb3VwLm1vZGUpXSwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgIFtcIm1vcmRcIiwgXCJrYXRleC1sb2dvXCJdLCBbaywgYSwgdCwgZSwgeF0sIG9wdGlvbnMpO1xufTtcblxuZ3JvdXBUeXBlcy5vdmVybGluZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gT3ZlcmxpbmVzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnIDQ0MywgUnVsZSA5LlxuICAgIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7XG5cbiAgICAvLyBCdWlsZCB0aGUgaW5uZXIgZ3JvdXAgaW4gdGhlIGNyYW1wZWQgc3R5bGUuXG4gICAgdmFyIGlubmVyR3JvdXAgPSBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksXG4gICAgICAgICAgICBvcHRpb25zLndpdGhTdHlsZShzdHlsZS5jcmFtcCgpKSk7XG5cbiAgICB2YXIgcnVsZVdpZHRoID0gZm9udE1ldHJpY3MubWV0cmljcy5kZWZhdWx0UnVsZVRoaWNrbmVzcyAvXG4gICAgICAgIHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSBsaW5lIGFib3ZlIHRoZSBib2R5XG4gICAgdmFyIGxpbmUgPSBtYWtlU3BhbihcbiAgICAgICAgW3N0eWxlLnJlc2V0KCksIFN0eWxlLlRFWFQuY2xzKCksIFwib3ZlcmxpbmUtbGluZVwiXSk7XG4gICAgbGluZS5oZWlnaHQgPSBydWxlV2lkdGg7XG4gICAgbGluZS5tYXhGb250U2l6ZSA9IDEuMDtcblxuICAgIC8vIEdlbmVyYXRlIHRoZSB2bGlzdCwgd2l0aCB0aGUgYXBwcm9wcmlhdGUga2VybnNcbiAgICB2YXIgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoW1xuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGlubmVyR3JvdXB9LFxuICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IDMgKiBydWxlV2lkdGh9LFxuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGxpbmV9LFxuICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IHJ1bGVXaWR0aH1cbiAgICBdLCBcImZpcnN0QmFzZWxpbmVcIiwgbnVsbCwgb3B0aW9ucyk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oW1wibW9yZFwiLCBcIm92ZXJsaW5lXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMudW5kZXJsaW5lID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBVbmRlcmxpbmVzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnIDQ0MywgUnVsZSAxMC5cbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgLy8gQnVpbGQgdGhlIGlubmVyIGdyb3VwLlxuICAgIHZhciBpbm5lckdyb3VwID0gYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zKTtcblxuICAgIHZhciBydWxlV2lkdGggPSBmb250TWV0cmljcy5tZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzIC9cbiAgICAgICAgc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICAvLyBDcmVhdGUgdGhlIGxpbmUgYWJvdmUgdGhlIGJvZHlcbiAgICB2YXIgbGluZSA9IG1ha2VTcGFuKFtzdHlsZS5yZXNldCgpLCBTdHlsZS5URVhULmNscygpLCBcInVuZGVybGluZS1saW5lXCJdKTtcbiAgICBsaW5lLmhlaWdodCA9IHJ1bGVXaWR0aDtcbiAgICBsaW5lLm1heEZvbnRTaXplID0gMS4wO1xuXG4gICAgLy8gR2VuZXJhdGUgdGhlIHZsaXN0LCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBrZXJuc1xuICAgIHZhciB2bGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogcnVsZVdpZHRofSxcbiAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBsaW5lfSxcbiAgICAgICAge3R5cGU6IFwia2VyblwiLCBzaXplOiAzICogcnVsZVdpZHRofSxcbiAgICAgICAge3R5cGU6IFwiZWxlbVwiLCBlbGVtOiBpbm5lckdyb3VwfVxuICAgIF0sIFwidG9wXCIsIGlubmVyR3JvdXAuaGVpZ2h0LCBvcHRpb25zKTtcblxuICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwidW5kZXJsaW5lXCJdLCBbdmxpc3RdLCBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMuc3FydCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gU3F1YXJlIHJvb3RzIGFyZSBoYW5kbGVkIGluIHRoZSBUZVhib29rIHBnLiA0NDMsIFJ1bGUgMTEuXG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIC8vIEZpcnN0LCB3ZSBkbyB0aGUgc2FtZSBzdGVwcyBhcyBpbiBvdmVybGluZSB0byBidWlsZCB0aGUgaW5uZXIgZ3JvdXBcbiAgICAvLyBhbmQgbGluZVxuICAgIHZhciBpbm5lciA9IGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuY3JhbXAoKSkpO1xuXG4gICAgdmFyIHJ1bGVXaWR0aCA9IGZvbnRNZXRyaWNzLm1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3MgL1xuICAgICAgICBzdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIHZhciBsaW5lID0gbWFrZVNwYW4oXG4gICAgICAgIFtzdHlsZS5yZXNldCgpLCBTdHlsZS5URVhULmNscygpLCBcInNxcnQtbGluZVwiXSwgW10sXG4gICAgICAgIG9wdGlvbnMpO1xuICAgIGxpbmUuaGVpZ2h0ID0gcnVsZVdpZHRoO1xuICAgIGxpbmUubWF4Rm9udFNpemUgPSAxLjA7XG5cbiAgICB2YXIgcGhpID0gcnVsZVdpZHRoO1xuICAgIGlmIChzdHlsZS5pZCA8IFN0eWxlLlRFWFQuaWQpIHtcbiAgICAgICAgcGhpID0gc3R5bGUubWV0cmljcy54SGVpZ2h0O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY2xlYXJhbmNlIGJldHdlZW4gdGhlIGJvZHkgYW5kIGxpbmVcbiAgICB2YXIgbGluZUNsZWFyYW5jZSA9IHJ1bGVXaWR0aCArIHBoaSAvIDQ7XG5cbiAgICB2YXIgaW5uZXJIZWlnaHQgPSAoaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGgpICogc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG4gICAgdmFyIG1pbkRlbGltaXRlckhlaWdodCA9IGlubmVySGVpZ2h0ICsgbGluZUNsZWFyYW5jZSArIHJ1bGVXaWR0aDtcblxuICAgIC8vIENyZWF0ZSBhIFxcc3VyZCBkZWxpbWl0ZXIgb2YgdGhlIHJlcXVpcmVkIG1pbmltdW0gc2l6ZVxuICAgIHZhciBkZWxpbSA9IG1ha2VTcGFuKFtcInNxcnQtc2lnblwiXSwgW1xuICAgICAgICBkZWxpbWl0ZXIuY3VzdG9tU2l6ZWREZWxpbShcIlxcXFxzdXJkXCIsIG1pbkRlbGltaXRlckhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsIG9wdGlvbnMsIGdyb3VwLm1vZGUpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zKTtcblxuICAgIHZhciBkZWxpbURlcHRoID0gKGRlbGltLmhlaWdodCArIGRlbGltLmRlcHRoKSAtIHJ1bGVXaWR0aDtcblxuICAgIC8vIEFkanVzdCB0aGUgY2xlYXJhbmNlIGJhc2VkIG9uIHRoZSBkZWxpbWl0ZXIgc2l6ZVxuICAgIGlmIChkZWxpbURlcHRoID4gaW5uZXIuaGVpZ2h0ICsgaW5uZXIuZGVwdGggKyBsaW5lQ2xlYXJhbmNlKSB7XG4gICAgICAgIGxpbmVDbGVhcmFuY2UgPVxuICAgICAgICAgICAgKGxpbmVDbGVhcmFuY2UgKyBkZWxpbURlcHRoIC0gaW5uZXIuaGVpZ2h0IC0gaW5uZXIuZGVwdGgpIC8gMjtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCB0aGUgZGVsaW1pdGVyIHNvIHRoYXQgaXRzIHRvcCBsaW5lcyB1cCB3aXRoIHRoZSB0b3Agb2YgdGhlIGxpbmVcbiAgICB2YXIgZGVsaW1TaGlmdCA9IC0oaW5uZXIuaGVpZ2h0ICsgbGluZUNsZWFyYW5jZSArIHJ1bGVXaWR0aCkgKyBkZWxpbS5oZWlnaHQ7XG4gICAgZGVsaW0uc3R5bGUudG9wID0gZGVsaW1TaGlmdCArIFwiZW1cIjtcbiAgICBkZWxpbS5oZWlnaHQgLT0gZGVsaW1TaGlmdDtcbiAgICBkZWxpbS5kZXB0aCArPSBkZWxpbVNoaWZ0O1xuXG4gICAgLy8gV2UgYWRkIGEgc3BlY2lhbCBjYXNlIGhlcmUsIGJlY2F1c2UgZXZlbiB3aGVuIGBpbm5lcmAgaXMgZW1wdHksIHdlXG4gICAgLy8gc3RpbGwgZ2V0IGEgbGluZS4gU28sIHdlIHVzZSBhIHNpbXBsZSBoZXVyaXN0aWMgdG8gZGVjaWRlIGlmIHdlXG4gICAgLy8gc2hvdWxkIG9taXQgdGhlIGJvZHkgZW50aXJlbHkuIChub3RlIHRoaXMgZG9lc24ndCB3b3JrIGZvciBzb21ldGhpbmdcbiAgICAvLyBsaWtlIGBcXHNxcnR7XFxybGFwe3h9fWAsIGJ1dCBpZiBzb21lb25lIGlzIGRvaW5nIHRoYXQgdGhleSBkZXNlcnZlIGZvclxuICAgIC8vIGl0IG5vdCB0byB3b3JrLlxuICAgIHZhciBib2R5O1xuICAgIGlmIChpbm5lci5oZWlnaHQgPT09IDAgJiYgaW5uZXIuZGVwdGggPT09IDApIHtcbiAgICAgICAgYm9keSA9IG1ha2VTcGFuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChbXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGlubmVyfSxcbiAgICAgICAgICAgIHt0eXBlOiBcImtlcm5cIiwgc2l6ZTogbGluZUNsZWFyYW5jZX0sXG4gICAgICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGxpbmV9LFxuICAgICAgICAgICAge3R5cGU6IFwia2VyblwiLCBzaXplOiBydWxlV2lkdGh9XG4gICAgICAgIF0sIFwiZmlyc3RCYXNlbGluZVwiLCBudWxsLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoIWdyb3VwLnZhbHVlLmluZGV4KSB7XG4gICAgICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwic3FydFwiXSwgW2RlbGltLCBib2R5XSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBvcHRpb25hbCByb290IGluZGV4XG5cbiAgICAgICAgLy8gVGhlIGluZGV4IGlzIGFsd2F5cyBpbiBzY3JpcHRzY3JpcHQgc3R5bGVcbiAgICAgICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLndpdGhTdHlsZShTdHlsZS5TQ1JJUFRTQ1JJUFQpO1xuICAgICAgICB2YXIgcm9vdCA9IGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuaW5kZXgsIG5ld09wdGlvbnMpO1xuICAgICAgICB2YXIgcm9vdFdyYXAgPSBtYWtlU3BhbihcbiAgICAgICAgICAgIFtzdHlsZS5yZXNldCgpLCBTdHlsZS5TQ1JJUFRTQ1JJUFQuY2xzKCldLFxuICAgICAgICAgICAgW3Jvb3RdLFxuICAgICAgICAgICAgbmV3T3B0aW9ucyk7XG5cbiAgICAgICAgLy8gRmlndXJlIG91dCB0aGUgaGVpZ2h0IGFuZCBkZXB0aCBvZiB0aGUgaW5uZXIgcGFydFxuICAgICAgICB2YXIgaW5uZXJSb290SGVpZ2h0ID0gTWF0aC5tYXgoZGVsaW0uaGVpZ2h0LCBib2R5LmhlaWdodCk7XG4gICAgICAgIHZhciBpbm5lclJvb3REZXB0aCA9IE1hdGgubWF4KGRlbGltLmRlcHRoLCBib2R5LmRlcHRoKTtcblxuICAgICAgICAvLyBUaGUgYW1vdW50IHRoZSBpbmRleCBpcyBzaGlmdGVkIGJ5LiBUaGlzIGlzIHRha2VuIGZyb20gdGhlIFRlWFxuICAgICAgICAvLyBzb3VyY2UsIGluIHRoZSBkZWZpbml0aW9uIG9mIGBcXHJAQHRgLlxuICAgICAgICB2YXIgdG9TaGlmdCA9IDAuNiAqIChpbm5lclJvb3RIZWlnaHQgLSBpbm5lclJvb3REZXB0aCk7XG5cbiAgICAgICAgLy8gQnVpbGQgYSBWTGlzdCB3aXRoIHRoZSBzdXBlcnNjcmlwdCBzaGlmdGVkIHVwIGNvcnJlY3RseVxuICAgICAgICB2YXIgcm9vdFZMaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KFxuICAgICAgICAgICAgW3t0eXBlOiBcImVsZW1cIiwgZWxlbTogcm9vdFdyYXB9XSxcbiAgICAgICAgICAgIFwic2hpZnRcIiwgLXRvU2hpZnQsIG9wdGlvbnMpO1xuICAgICAgICAvLyBBZGQgYSBjbGFzcyBzdXJyb3VuZGluZyBpdCBzbyB3ZSBjYW4gYWRkIG9uIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgICAvLyBrZXJuaW5nXG4gICAgICAgIHZhciByb290Vkxpc3RXcmFwID0gbWFrZVNwYW4oW1wicm9vdFwiXSwgW3Jvb3RWTGlzdF0pO1xuXG4gICAgICAgIHJldHVybiBtYWtlU3BhbihbXCJtb3JkXCIsIFwic3FydFwiXSxcbiAgICAgICAgICAgIFtyb290Vkxpc3RXcmFwLCBkZWxpbSwgYm9keV0sIG9wdGlvbnMpO1xuICAgIH1cbn07XG5cbmdyb3VwVHlwZXMuc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICAvLyBIYW5kbGUgc2l6aW5nIG9wZXJhdG9ycyBsaWtlIFxcSHVnZS4gUmVhbCBUZVggZG9lc24ndCBhY3R1YWxseSBhbGxvd1xuICAgIC8vIHRoZXNlIGZ1bmN0aW9ucyBpbnNpZGUgb2YgbWF0aCBleHByZXNzaW9ucywgc28gd2UgZG8gc29tZSBzcGVjaWFsXG4gICAgLy8gaGFuZGxpbmcuXG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLnZhbHVlLFxuICAgICAgICAgICAgb3B0aW9ucy53aXRoU2l6ZShncm91cC52YWx1ZS5zaXplKSwgZmFsc2UpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgY29ycmVjdCBtYXhGb250U2l6ZS5cbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuICAgIHZhciBmb250U2l6ZSA9IGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbZ3JvdXAudmFsdWUuc2l6ZV07XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAqIHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgLy8gQWRkIHNpemUtcmVzZXR0aW5nIGNsYXNzZXMgdG8gdGhlIGlubmVyIGxpc3QgYW5kIHNldCBtYXhGb250U2l6ZVxuICAgIC8vIG1hbnVhbGx5LiBIYW5kbGUgbmVzdGVkIHNpemUgY2hhbmdlcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwb3MgPSB1dGlscy5pbmRleE9mKGlubmVyW2ldLmNsYXNzZXMsIFwic2l6aW5nXCIpO1xuICAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgICAgaW5uZXJbaV0uY2xhc3Nlcy5wdXNoKFwic2l6aW5nXCIsIFwicmVzZXQtXCIgKyBvcHRpb25zLnNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAudmFsdWUuc2l6ZSwgc3R5bGUuY2xzKCkpO1xuICAgICAgICAgICAgaW5uZXJbaV0ubWF4Rm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbm5lcltpXS5jbGFzc2VzW3BvcyArIDFdID09PSBcInJlc2V0LVwiICsgZ3JvdXAudmFsdWUuc2l6ZSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5lc3RlZCBzaXplIGNoYW5nZTogZS5nLiwgaW5uZXJbaV0gaXMgdGhlIFwiYlwiIGluXG4gICAgICAgICAgICAvLyBgXFxIdWdlIGEgXFxzbWFsbCBiYC4gT3ZlcnJpZGUgdGhlIG9sZCBzaXplICh0aGUgYHJlc2V0LWAgY2xhc3MpXG4gICAgICAgICAgICAvLyBidXQgbm90IHRoZSBuZXcgc2l6ZS5cbiAgICAgICAgICAgIGlubmVyW2ldLmNsYXNzZXNbcG9zICsgMV0gPSBcInJlc2V0LVwiICsgb3B0aW9ucy5zaXplO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChpbm5lcik7XG59O1xuXG5ncm91cFR5cGVzLnN0eWxpbmcgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIFN0eWxlIGNoYW5nZXMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgb24gcGcuIDQ0MiwgUnVsZSAzLlxuXG4gICAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHdlJ3JlIGNoYW5naW5nIHRvLlxuICAgIHZhciBzdHlsZU1hcCA9IHtcbiAgICAgICAgXCJkaXNwbGF5XCI6IFN0eWxlLkRJU1BMQVksXG4gICAgICAgIFwidGV4dFwiOiBTdHlsZS5URVhULFxuICAgICAgICBcInNjcmlwdFwiOiBTdHlsZS5TQ1JJUFQsXG4gICAgICAgIFwic2NyaXB0c2NyaXB0XCI6IFN0eWxlLlNDUklQVFNDUklQVFxuICAgIH07XG5cbiAgICB2YXIgbmV3U3R5bGUgPSBzdHlsZU1hcFtncm91cC52YWx1ZS5zdHlsZV07XG4gICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLndpdGhTdHlsZShuZXdTdHlsZSk7XG5cbiAgICAvLyBCdWlsZCB0aGUgaW5uZXIgZXhwcmVzc2lvbiBpbiB0aGUgbmV3IHN0eWxlLlxuICAgIHZhciBpbm5lciA9IGJ1aWxkRXhwcmVzc2lvbihcbiAgICAgICAgZ3JvdXAudmFsdWUudmFsdWUsIG5ld09wdGlvbnMsIGZhbHNlKTtcblxuICAgIC8vIEFkZCBzdHlsZS1yZXNldHRpbmcgY2xhc3NlcyB0byB0aGUgaW5uZXIgbGlzdC4gSGFuZGxlIG5lc3RlZCBjaGFuZ2VzLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHBvcyA9IHV0aWxzLmluZGV4T2YoaW5uZXJbaV0uY2xhc3NlcywgbmV3U3R5bGUucmVzZXQoKSk7XG4gICAgICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgICAgICBpbm5lcltpXS5jbGFzc2VzLnB1c2gob3B0aW9ucy5zdHlsZS5yZXNldCgpLCBuZXdTdHlsZS5jbHMoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgbmVzdGVkIHN0eWxlIGNoYW5nZSwgYXMgYFxcdGV4dHN0eWxlIGFcXHNjcmlwdHN0eWxlIGJgLlxuICAgICAgICAgICAgLy8gT25seSBvdmVycmlkZSB0aGUgb2xkIHN0eWxlICh0aGUgcmVzZXQgY2xhc3MpLlxuICAgICAgICAgICAgaW5uZXJbaV0uY2xhc3Nlc1twb3NdID0gb3B0aW9ucy5zdHlsZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoaW5uZXIpO1xufTtcblxuZ3JvdXBUeXBlcy5mb250ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9udCA9IGdyb3VwLnZhbHVlLmZvbnQ7XG4gICAgcmV0dXJuIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy53aXRoRm9udChmb250KSk7XG59O1xuXG5ncm91cFR5cGVzLmRlbGltc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGVsaW0gPSBncm91cC52YWx1ZS52YWx1ZTtcblxuICAgIGlmIChkZWxpbSA9PT0gXCIuXCIpIHtcbiAgICAgICAgLy8gRW1wdHkgZGVsaW1pdGVycyBzdGlsbCBjb3VudCBhcyBlbGVtZW50cywgZXZlbiB0aG91Z2ggdGhleSBkb24ndFxuICAgICAgICAvLyBzaG93IGFueXRoaW5nLlxuICAgICAgICByZXR1cm4gbWFrZVNwYW4oW2dyb3VwLnZhbHVlLm1jbGFzc10pO1xuICAgIH1cblxuICAgIC8vIFVzZSBkZWxpbWl0ZXIuc2l6ZWREZWxpbSB0byBnZW5lcmF0ZSB0aGUgZGVsaW1pdGVyLlxuICAgIHJldHVybiBkZWxpbWl0ZXIuc2l6ZWREZWxpbShcbiAgICAgICAgICAgIGRlbGltLCBncm91cC52YWx1ZS5zaXplLCBvcHRpb25zLCBncm91cC5tb2RlLFxuICAgICAgICAgICAgW2dyb3VwLnZhbHVlLm1jbGFzc10pO1xufTtcblxuZ3JvdXBUeXBlcy5sZWZ0cmlnaHQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIEJ1aWxkIHRoZSBpbm5lciBleHByZXNzaW9uXG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMucmVzZXQoKSwgdHJ1ZSk7XG5cbiAgICB2YXIgaW5uZXJIZWlnaHQgPSAwO1xuICAgIHZhciBpbm5lckRlcHRoID0gMDtcbiAgICB2YXIgaGFkTWlkZGxlID0gZmFsc2U7XG5cbiAgICAvLyBDYWxjdWxhdGUgaXRzIGhlaWdodCBhbmQgZGVwdGhcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlubmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpbm5lcltpXS5pc01pZGRsZSkge1xuICAgICAgICAgICAgaGFkTWlkZGxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlubmVySGVpZ2h0ID0gTWF0aC5tYXgoaW5uZXJbaV0uaGVpZ2h0LCBpbm5lckhlaWdodCk7XG4gICAgICAgICAgICBpbm5lckRlcHRoID0gTWF0aC5tYXgoaW5uZXJbaV0uZGVwdGgsIGlubmVyRGVwdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIC8vIFRoZSBzaXplIG9mIGRlbGltaXRlcnMgaXMgdGhlIHNhbWUsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBzdHlsZSB3ZSBhcmVcbiAgICAvLyBpbi4gVGh1cywgdG8gY29ycmVjdGx5IGNhbGN1bGF0ZSB0aGUgc2l6ZSBvZiBkZWxpbWl0ZXIgd2UgbmVlZCBhcm91bmRcbiAgICAvLyBhIGdyb3VwLCB3ZSBzY2FsZSBkb3duIHRoZSBpbm5lciBzaXplIGJhc2VkIG9uIHRoZSBzaXplLlxuICAgIGlubmVySGVpZ2h0ICo9IHN0eWxlLnNpemVNdWx0aXBsaWVyO1xuICAgIGlubmVyRGVwdGggKj0gc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICB2YXIgbGVmdERlbGltO1xuICAgIGlmIChncm91cC52YWx1ZS5sZWZ0ID09PSBcIi5cIikge1xuICAgICAgICAvLyBFbXB0eSBkZWxpbWl0ZXJzIGluIFxcbGVmdCBhbmQgXFxyaWdodCBtYWtlIG51bGwgZGVsaW1pdGVyIHNwYWNlcy5cbiAgICAgICAgbGVmdERlbGltID0gbWFrZU51bGxEZWxpbWl0ZXIob3B0aW9ucywgW1wibW9wZW5cIl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE90aGVyd2lzZSwgdXNlIGxlZnRSaWdodERlbGltIHRvIGdlbmVyYXRlIHRoZSBjb3JyZWN0IHNpemVkXG4gICAgICAgIC8vIGRlbGltaXRlci5cbiAgICAgICAgbGVmdERlbGltID0gZGVsaW1pdGVyLmxlZnRSaWdodERlbGltKFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUubGVmdCwgaW5uZXJIZWlnaHQsIGlubmVyRGVwdGgsIG9wdGlvbnMsXG4gICAgICAgICAgICBncm91cC5tb2RlLCBbXCJtb3BlblwiXSk7XG4gICAgfVxuICAgIC8vIEFkZCBpdCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBleHByZXNzaW9uXG4gICAgaW5uZXIudW5zaGlmdChsZWZ0RGVsaW0pO1xuXG4gICAgLy8gSGFuZGxlIG1pZGRsZSBkZWxpbWl0ZXJzXG4gICAgaWYgKGhhZE1pZGRsZSkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpbm5lcltpXS5pc01pZGRsZSkge1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBvcHRpb25zIHRoYXQgd2VyZSBhY3RpdmUgd2hlbiBcXG1pZGRsZSB3YXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgaW5uZXJbaV0gPSBkZWxpbWl0ZXIubGVmdFJpZ2h0RGVsaW0oXG4gICAgICAgICAgICAgICAgICAgIGlubmVyW2ldLmlzTWlkZGxlLnZhbHVlLCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCxcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJbaV0uaXNNaWRkbGUub3B0aW9ucywgZ3JvdXAubW9kZSwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJpZ2h0RGVsaW07XG4gICAgLy8gU2FtZSBmb3IgdGhlIHJpZ2h0IGRlbGltaXRlclxuICAgIGlmIChncm91cC52YWx1ZS5yaWdodCA9PT0gXCIuXCIpIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtcIm1jbG9zZVwiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmlnaHREZWxpbSA9IGRlbGltaXRlci5sZWZ0UmlnaHREZWxpbShcbiAgICAgICAgICAgIGdyb3VwLnZhbHVlLnJpZ2h0LCBpbm5lckhlaWdodCwgaW5uZXJEZXB0aCwgb3B0aW9ucyxcbiAgICAgICAgICAgIGdyb3VwLm1vZGUsIFtcIm1jbG9zZVwiXSk7XG4gICAgfVxuICAgIC8vIEFkZCBpdCB0byB0aGUgZW5kIG9mIHRoZSBleHByZXNzaW9uLlxuICAgIGlubmVyLnB1c2gocmlnaHREZWxpbSk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oXG4gICAgICAgIFtcIm1pbm5lclwiLCBzdHlsZS5jbHMoKV0sIGlubmVyLCBvcHRpb25zKTtcbn07XG5cbmdyb3VwVHlwZXMubWlkZGxlID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbWlkZGxlRGVsaW07XG4gICAgaWYgKGdyb3VwLnZhbHVlLnZhbHVlID09PSBcIi5cIikge1xuICAgICAgICBtaWRkbGVEZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFtdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBtaWRkbGVEZWxpbSA9IGRlbGltaXRlci5zaXplZERlbGltKFxuICAgICAgICAgICAgZ3JvdXAudmFsdWUudmFsdWUsIDEsIG9wdGlvbnMsXG4gICAgICAgICAgICBncm91cC5tb2RlLCBbXSk7XG4gICAgICAgIG1pZGRsZURlbGltLmlzTWlkZGxlID0ge3ZhbHVlOiBncm91cC52YWx1ZS52YWx1ZSwgb3B0aW9uczogb3B0aW9uc307XG4gICAgfVxuICAgIHJldHVybiBtaWRkbGVEZWxpbTtcbn07XG5cbmdyb3VwVHlwZXMucnVsZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gTWFrZSBhbiBlbXB0eSBzcGFuIGZvciB0aGUgcnVsZVxuICAgIHZhciBydWxlID0gbWFrZVNwYW4oW1wibW9yZFwiLCBcInJ1bGVcIl0sIFtdLCBvcHRpb25zKTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzaGlmdCwgd2lkdGgsIGFuZCBoZWlnaHQgb2YgdGhlIHJ1bGUsIGFuZCBhY2NvdW50IGZvciB1bml0c1xuICAgIHZhciBzaGlmdCA9IDA7XG4gICAgaWYgKGdyb3VwLnZhbHVlLnNoaWZ0KSB7XG4gICAgICAgIHNoaWZ0ID0gY2FsY3VsYXRlU2l6ZShncm91cC52YWx1ZS5zaGlmdCwgc3R5bGUpO1xuICAgIH1cblxuICAgIHZhciB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAudmFsdWUud2lkdGgsIHN0eWxlKTtcbiAgICB2YXIgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC52YWx1ZS5oZWlnaHQsIHN0eWxlKTtcblxuICAgIC8vIFRoZSBzaXplcyBvZiBydWxlcyBhcmUgYWJzb2x1dGUsIHNvIG1ha2UgaXQgbGFyZ2VyIGlmIHdlIGFyZSBpbiBhXG4gICAgLy8gc21hbGxlciBzdHlsZS5cbiAgICBzaGlmdCAvPSBzdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICB3aWR0aCAvPSBzdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICBoZWlnaHQgLz0gc3R5bGUuc2l6ZU11bHRpcGxpZXI7XG5cbiAgICAvLyBTdHlsZSB0aGUgcnVsZSB0byB0aGUgcmlnaHQgc2l6ZVxuICAgIHJ1bGUuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IHdpZHRoICsgXCJlbVwiO1xuICAgIHJ1bGUuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBoZWlnaHQgKyBcImVtXCI7XG4gICAgcnVsZS5zdHlsZS5ib3R0b20gPSBzaGlmdCArIFwiZW1cIjtcblxuICAgIC8vIFJlY29yZCB0aGUgaGVpZ2h0IGFuZCB3aWR0aFxuICAgIHJ1bGUud2lkdGggPSB3aWR0aDtcbiAgICBydWxlLmhlaWdodCA9IGhlaWdodCArIHNoaWZ0O1xuICAgIHJ1bGUuZGVwdGggPSAtc2hpZnQ7XG5cbiAgICByZXR1cm4gcnVsZTtcbn07XG5cbmdyb3VwVHlwZXMua2VybiA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgLy8gTWFrZSBhbiBlbXB0eSBzcGFuIGZvciB0aGUgcnVsZVxuICAgIHZhciBydWxlID0gbWFrZVNwYW4oW1wibW9yZFwiLCBcInJ1bGVcIl0sIFtdLCBvcHRpb25zKTtcbiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlO1xuXG4gICAgdmFyIGRpbWVuc2lvbiA9IDA7XG4gICAgaWYgKGdyb3VwLnZhbHVlLmRpbWVuc2lvbikge1xuICAgICAgICBkaW1lbnNpb24gPSBjYWxjdWxhdGVTaXplKGdyb3VwLnZhbHVlLmRpbWVuc2lvbiwgc3R5bGUpO1xuICAgIH1cblxuICAgIGRpbWVuc2lvbiAvPSBzdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIHJ1bGUuc3R5bGUubWFyZ2luTGVmdCA9IGRpbWVuc2lvbiArIFwiZW1cIjtcblxuICAgIHJldHVybiBydWxlO1xufTtcblxuZ3JvdXBUeXBlcy5hY2NlbnQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIC8vIEFjY2VudHMgYXJlIGhhbmRsZWQgaW4gdGhlIFRlWGJvb2sgcGcuIDQ0MywgcnVsZSAxMi5cbiAgICB2YXIgYmFzZSA9IGdyb3VwLnZhbHVlLmJhc2U7XG4gICAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTtcblxuICAgIHZhciBzdXBzdWJHcm91cDtcbiAgICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJzdXBzdWJcIikge1xuICAgICAgICAvLyBJZiBvdXIgYmFzZSBpcyBhIGNoYXJhY3RlciBib3gsIGFuZCB3ZSBoYXZlIHN1cGVyc2NyaXB0cyBhbmRcbiAgICAgICAgLy8gc3Vic2NyaXB0cywgdGhlIHN1cHN1YiB3aWxsIGRlZmVyIHRvIHVzLiBJbiBwYXJ0aWN1bGFyLCB3ZSB3YW50XG4gICAgICAgIC8vIHRvIGF0dGFjaCB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIHRvIHRoZSBpbm5lciBib2R5IChzb1xuICAgICAgICAvLyB0aGF0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc3VwZXJzY3JpcHRzIGFuZCBzdWJzY3JpcHRzIHdvbid0IGJlXG4gICAgICAgIC8vIGFmZmVjdGVkIGJ5IHRoZSBoZWlnaHQgb2YgdGhlIGFjY2VudCkuIFdlIGFjY29tcGxpc2ggdGhpcyBieVxuICAgICAgICAvLyBzdGlja2luZyB0aGUgYmFzZSBvZiB0aGUgYWNjZW50IGludG8gdGhlIGJhc2Ugb2YgdGhlIHN1cHN1YiwgYW5kXG4gICAgICAgIC8vIHJlbmRlcmluZyB0aGF0LCB3aGlsZSBrZWVwaW5nIHRyYWNrIG9mIHdoZXJlIHRoZSBhY2NlbnQgaXMuXG5cbiAgICAgICAgLy8gVGhlIHN1cHN1YiBncm91cCBpcyB0aGUgZ3JvdXAgdGhhdCB3YXMgcGFzc2VkIGluXG4gICAgICAgIHZhciBzdXBzdWIgPSBncm91cDtcbiAgICAgICAgLy8gVGhlIHJlYWwgYWNjZW50IGdyb3VwIGlzIHRoZSBiYXNlIG9mIHRoZSBzdXBzdWIgZ3JvdXBcbiAgICAgICAgZ3JvdXAgPSBzdXBzdWIudmFsdWUuYmFzZTtcbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciBib3ggaXMgdGhlIGJhc2Ugb2YgdGhlIGFjY2VudCBncm91cFxuICAgICAgICBiYXNlID0gZ3JvdXAudmFsdWUuYmFzZTtcbiAgICAgICAgLy8gU3RpY2sgdGhlIGNoYXJhY3RlciBib3ggaW50byB0aGUgYmFzZSBvZiB0aGUgc3Vwc3ViIGdyb3VwXG4gICAgICAgIHN1cHN1Yi52YWx1ZS5iYXNlID0gYmFzZTtcblxuICAgICAgICAvLyBSZXJlbmRlciB0aGUgc3Vwc3ViIGdyb3VwIHdpdGggaXRzIG5ldyBiYXNlLCBhbmQgc3RvcmUgdGhhdFxuICAgICAgICAvLyByZXN1bHQuXG4gICAgICAgIHN1cHN1Ykdyb3VwID0gYnVpbGRHcm91cChcbiAgICAgICAgICAgIHN1cHN1Yiwgb3B0aW9ucy5yZXNldCgpKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmFzZSBncm91cFxuICAgIHZhciBib2R5ID0gYnVpbGRHcm91cChcbiAgICAgICAgYmFzZSwgb3B0aW9ucy53aXRoU3R5bGUoc3R5bGUuY3JhbXAoKSkpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBza2V3IG9mIHRoZSBhY2NlbnQuIFRoaXMgaXMgYmFzZWQgb24gdGhlIGxpbmUgXCJJZiB0aGVcbiAgICAvLyBudWNsZXVzIGlzIG5vdCBhIHNpbmdsZSBjaGFyYWN0ZXIsIGxldCBzID0gMDsgb3RoZXJ3aXNlIHNldCBzIHRvIHRoZVxuICAgIC8vIGtlcm4gYW1vdW50IGZvciB0aGUgbnVjbGV1cyBmb2xsb3dlZCBieSB0aGUgXFxza2V3Y2hhciBvZiBpdHMgZm9udC5cIlxuICAgIC8vIE5vdGUgdGhhdCBvdXIgc2tldyBtZXRyaWNzIGFyZSBqdXN0IHRoZSBrZXJuIGJldHdlZW4gZWFjaCBjaGFyYWN0ZXJcbiAgICAvLyBhbmQgdGhlIHNrZXdjaGFyLlxuICAgIHZhciBza2V3O1xuICAgIGlmIChpc0NoYXJhY3RlckJveChiYXNlKSkge1xuICAgICAgICAvLyBJZiB0aGUgYmFzZSBpcyBhIGNoYXJhY3RlciBib3gsIHRoZW4gd2Ugd2FudCB0aGUgc2tldyBvZiB0aGVcbiAgICAgICAgLy8gaW5uZXJtb3N0IGNoYXJhY3Rlci4gVG8gZG8gdGhhdCwgd2UgZmluZCB0aGUgaW5uZXJtb3N0IGNoYXJhY3RlcjpcbiAgICAgICAgdmFyIGJhc2VDaGFyID0gZ2V0QmFzZUVsZW0oYmFzZSk7XG4gICAgICAgIC8vIFRoZW4sIHdlIHJlbmRlciBpdHMgZ3JvdXAgdG8gZ2V0IHRoZSBzeW1ib2wgaW5zaWRlIGl0XG4gICAgICAgIHZhciBiYXNlR3JvdXAgPSBidWlsZEdyb3VwKFxuICAgICAgICAgICAgYmFzZUNoYXIsIG9wdGlvbnMud2l0aFN0eWxlKHN0eWxlLmNyYW1wKCkpKTtcbiAgICAgICAgLy8gRmluYWxseSwgd2UgcHVsbCB0aGUgc2tldyBvZmYgb2YgdGhlIHN5bWJvbC5cbiAgICAgICAgc2tldyA9IGJhc2VHcm91cC5za2V3O1xuICAgICAgICAvLyBOb3RlIHRoYXQgd2Ugbm93IHRocm93IGF3YXkgYmFzZUdyb3VwLCBiZWNhdXNlIHRoZSBsYXllcnMgd2VcbiAgICAgICAgLy8gcmVtb3ZlZCB3aXRoIGdldEJhc2VFbGVtIG1pZ2h0IGNvbnRhaW4gdGhpbmdzIGxpa2UgXFxjb2xvciB3aGljaFxuICAgICAgICAvLyB3ZSBjYW4ndCBnZXQgcmlkIG9mLlxuICAgICAgICAvLyBUT0RPKGVtaWx5KTogRmluZCBhIGJldHRlciB3YXkgdG8gZ2V0IHRoZSBza2V3XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2tldyA9IDA7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBhbW91bnQgb2Ygc3BhY2UgYmV0d2VlbiB0aGUgYm9keSBhbmQgdGhlIGFjY2VudFxuICAgIHZhciBjbGVhcmFuY2UgPSBNYXRoLm1pbihcbiAgICAgICAgYm9keS5oZWlnaHQsXG4gICAgICAgIHN0eWxlLm1ldHJpY3MueEhlaWdodCk7XG5cbiAgICAvLyBCdWlsZCB0aGUgYWNjZW50XG4gICAgdmFyIGFjY2VudCA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woXG4gICAgICAgIGdyb3VwLnZhbHVlLmFjY2VudCwgXCJNYWluLVJlZ3VsYXJcIiwgXCJtYXRoXCIsIG9wdGlvbnMpO1xuICAgIC8vIFJlbW92ZSB0aGUgaXRhbGljIGNvcnJlY3Rpb24gb2YgdGhlIGFjY2VudCwgYmVjYXVzZSBpdCBvbmx5IHNlcnZlcyB0b1xuICAgIC8vIHNoaWZ0IHRoZSBhY2NlbnQgb3ZlciB0byBhIHBsYWNlIHdlIGRvbid0IHdhbnQuXG4gICAgYWNjZW50Lml0YWxpYyA9IDA7XG5cbiAgICAvLyBUaGUgXFx2ZWMgY2hhcmFjdGVyIHRoYXQgdGhlIGZvbnRzIHVzZSBpcyBhIGNvbWJpbmluZyBjaGFyYWN0ZXIsIGFuZFxuICAgIC8vIHRodXMgc2hvd3MgdXAgbXVjaCB0b28gZmFyIHRvIHRoZSBsZWZ0LiBUbyBhY2NvdW50IGZvciB0aGlzLCB3ZSBhZGQgYVxuICAgIC8vIHNwZWNpZmljIGNsYXNzIHdoaWNoIHNoaWZ0cyB0aGUgYWNjZW50IG92ZXIgdG8gd2hlcmUgd2Ugd2FudCBpdC5cbiAgICAvLyBUT0RPKGVtaWx5KTogRml4IHRoaXMgaW4gYSBiZXR0ZXIgd2F5LCBsaWtlIGJ5IGNoYW5naW5nIHRoZSBmb250XG4gICAgdmFyIHZlY0NsYXNzID0gZ3JvdXAudmFsdWUuYWNjZW50ID09PSBcIlxcXFx2ZWNcIiA/IFwiYWNjZW50LXZlY1wiIDogbnVsbDtcblxuICAgIHZhciBhY2NlbnRCb2R5ID0gbWFrZVNwYW4oW1wiYWNjZW50LWJvZHlcIiwgdmVjQ2xhc3NdLCBbXG4gICAgICAgIG1ha2VTcGFuKFtdLCBbYWNjZW50XSldKTtcblxuICAgIGFjY2VudEJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoW1xuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGJvZHl9LFxuICAgICAgICB7dHlwZTogXCJrZXJuXCIsIHNpemU6IC1jbGVhcmFuY2V9LFxuICAgICAgICB7dHlwZTogXCJlbGVtXCIsIGVsZW06IGFjY2VudEJvZHl9XG4gICAgXSwgXCJmaXJzdEJhc2VsaW5lXCIsIG51bGwsIG9wdGlvbnMpO1xuXG4gICAgLy8gU2hpZnQgdGhlIGFjY2VudCBvdmVyIGJ5IHRoZSBza2V3LiBOb3RlIHdlIHNoaWZ0IGJ5IHR3aWNlIHRoZSBza2V3XG4gICAgLy8gYmVjYXVzZSB3ZSBhcmUgY2VudGVyaW5nIHRoZSBhY2NlbnQsIHNvIGJ5IGFkZGluZyAyKnNrZXcgdG8gdGhlIGxlZnQsXG4gICAgLy8gd2Ugc2hpZnQgaXQgdG8gdGhlIHJpZ2h0IGJ5IDEqc2tldy5cbiAgICBhY2NlbnRCb2R5LmNoaWxkcmVuWzFdLnN0eWxlLm1hcmdpbkxlZnQgPSAyICogc2tldyArIFwiZW1cIjtcblxuICAgIHZhciBhY2NlbnRXcmFwID0gbWFrZVNwYW4oW1wibW9yZFwiLCBcImFjY2VudFwiXSwgW2FjY2VudEJvZHldLCBvcHRpb25zKTtcblxuICAgIGlmIChzdXBzdWJHcm91cCkge1xuICAgICAgICAvLyBIZXJlLCB3ZSByZXBsYWNlIHRoZSBcImJhc2VcIiBjaGlsZCBvZiB0aGUgc3Vwc3ViIHdpdGggb3VyIG5ld2x5XG4gICAgICAgIC8vIGdlbmVyYXRlZCBhY2NlbnQuXG4gICAgICAgIHN1cHN1Ykdyb3VwLmNoaWxkcmVuWzBdID0gYWNjZW50V3JhcDtcblxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCByZXJ1biB0aGUgaGVpZ2h0IGNhbGN1bGF0aW9uIGFmdGVyIHJlcGxhY2luZyB0aGVcbiAgICAgICAgLy8gYWNjZW50LCB3ZSBtYW51YWxseSByZWNhbGN1bGF0ZSBoZWlnaHQuXG4gICAgICAgIHN1cHN1Ykdyb3VwLmhlaWdodCA9IE1hdGgubWF4KGFjY2VudFdyYXAuaGVpZ2h0LCBzdXBzdWJHcm91cC5oZWlnaHQpO1xuXG4gICAgICAgIC8vIEFjY2VudHMgc2hvdWxkIGFsd2F5cyBiZSBvcmRzLCBldmVuIHdoZW4gdGhlaXIgaW5uYXJkcyBhcmUgbm90LlxuICAgICAgICBzdXBzdWJHcm91cC5jbGFzc2VzWzBdID0gXCJtb3JkXCI7XG5cbiAgICAgICAgcmV0dXJuIHN1cHN1Ykdyb3VwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhY2NlbnRXcmFwO1xuICAgIH1cbn07XG5cbmdyb3VwVHlwZXMucGhhbnRvbSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uKFxuICAgICAgICBncm91cC52YWx1ZS52YWx1ZSxcbiAgICAgICAgb3B0aW9ucy53aXRoUGhhbnRvbSgpLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cbiAgICAvLyBcXHBoYW50b20gaXNuJ3Qgc3VwcG9zZWQgdG8gYWZmZWN0IHRoZSBlbGVtZW50cyBpdCBjb250YWlucy5cbiAgICAvLyBTZWUgXCJjb2xvclwiIGZvciBtb3JlIGRldGFpbHMuXG4gICAgcmV0dXJuIG5ldyBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpO1xufTtcblxuZ3JvdXBUeXBlcy5tY2xhc3MgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbihncm91cC52YWx1ZS52YWx1ZSwgb3B0aW9ucywgdHJ1ZSk7XG5cbiAgICByZXR1cm4gbWFrZVNwYW4oW2dyb3VwLnZhbHVlLm1jbGFzc10sIGVsZW1lbnRzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogYnVpbGRHcm91cCBpcyB0aGUgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGdyb3VwIGFuZCBjYWxscyB0aGUgY29ycmVjdCBncm91cFR5cGVcbiAqIGZ1bmN0aW9uIGZvciBpdC4gSXQgYWxzbyBoYW5kbGVzIHRoZSBpbnRlcmFjdGlvbiBvZiBzaXplIGFuZCBzdHlsZSBjaGFuZ2VzXG4gKiBiZXR3ZWVuIHBhcmVudHMgYW5kIGNoaWxkcmVuLlxuICovXG52YXIgYnVpbGRHcm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgaWYgKCFncm91cCkge1xuICAgICAgICByZXR1cm4gbWFrZVNwYW4oKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXBUeXBlc1tncm91cC50eXBlXSkge1xuICAgICAgICAvLyBDYWxsIHRoZSBncm91cFR5cGVzIGZ1bmN0aW9uXG4gICAgICAgIHZhciBncm91cE5vZGUgPSBncm91cFR5cGVzW2dyb3VwLnR5cGVdKGdyb3VwLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIG11bHRpcGxpZXI7XG5cbiAgICAgICAgLy8gSWYgdGhlIHN0eWxlIGNoYW5nZWQgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY3VycmVudCBncm91cCxcbiAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHNpemUgZGlmZmVyZW5jZVxuICAgICAgICBpZiAob3B0aW9ucy5zdHlsZSAhPT0gb3B0aW9ucy5wYXJlbnRTdHlsZSkge1xuICAgICAgICAgICAgbXVsdGlwbGllciA9IG9wdGlvbnMuc3R5bGUuc2l6ZU11bHRpcGxpZXIgL1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudFN0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgICAgICAgICBncm91cE5vZGUuaGVpZ2h0ICo9IG11bHRpcGxpZXI7XG4gICAgICAgICAgICBncm91cE5vZGUuZGVwdGggKj0gbXVsdGlwbGllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBzaXplIGNoYW5nZWQgYmV0d2VlbiB0aGUgcGFyZW50IGFuZCB0aGUgY3VycmVudCBncm91cCwgYWNjb3VudFxuICAgICAgICAvLyBmb3IgdGhhdCBzaXplIGRpZmZlcmVuY2UuXG4gICAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IG9wdGlvbnMucGFyZW50U2l6ZSkge1xuICAgICAgICAgICAgbXVsdGlwbGllciA9IGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbb3B0aW9ucy5zaXplXSAvXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbb3B0aW9ucy5wYXJlbnRTaXplXTtcblxuICAgICAgICAgICAgZ3JvdXBOb2RlLmhlaWdodCAqPSBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgZ3JvdXBOb2RlLmRlcHRoICo9IG11bHRpcGxpZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXBOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFxuICAgICAgICAgICAgXCJHb3QgZ3JvdXAgb2YgdW5rbm93biB0eXBlOiAnXCIgKyBncm91cC50eXBlICsgXCInXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGFrZSBhbiBlbnRpcmUgcGFyc2UgdHJlZSwgYW5kIGJ1aWxkIGl0IGludG8gYW4gYXBwcm9wcmlhdGUgc2V0IG9mIEhUTUxcbiAqIG5vZGVzLlxuICovXG52YXIgYnVpbGRIVE1MID0gZnVuY3Rpb24odHJlZSwgb3B0aW9ucykge1xuICAgIC8vIGJ1aWxkRXhwcmVzc2lvbiBpcyBkZXN0cnVjdGl2ZSwgc28gd2UgbmVlZCB0byBtYWtlIGEgY2xvbmVcbiAgICAvLyBvZiB0aGUgaW5jb21pbmcgdHJlZSBzbyB0aGF0IGl0IGlzbid0IGFjY2lkZW50YWxseSBjaGFuZ2VkXG4gICAgdHJlZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodHJlZSkpO1xuXG4gICAgLy8gQnVpbGQgdGhlIGV4cHJlc3Npb24gY29udGFpbmVkIGluIHRoZSB0cmVlXG4gICAgdmFyIGV4cHJlc3Npb24gPSBidWlsZEV4cHJlc3Npb24odHJlZSwgb3B0aW9ucywgdHJ1ZSk7XG4gICAgdmFyIGJvZHkgPSBtYWtlU3BhbihbXCJiYXNlXCIsIG9wdGlvbnMuc3R5bGUuY2xzKCldLCBleHByZXNzaW9uLCBvcHRpb25zKTtcblxuICAgIC8vIEFkZCBzdHJ1dHMsIHdoaWNoIGVuc3VyZSB0aGF0IHRoZSB0b3Agb2YgdGhlIEhUTUwgZWxlbWVudCBmYWxscyBhdCB0aGVcbiAgICAvLyBoZWlnaHQgb2YgdGhlIGV4cHJlc3Npb24sIGFuZCB0aGUgYm90dG9tIG9mIHRoZSBIVE1MIGVsZW1lbnQgZmFsbHMgYXQgdGhlXG4gICAgLy8gZGVwdGggb2YgdGhlIGV4cHJlc3Npb24uXG4gICAgdmFyIHRvcFN0cnV0ID0gbWFrZVNwYW4oW1wic3RydXRcIl0pO1xuICAgIHZhciBib3R0b21TdHJ1dCA9IG1ha2VTcGFuKFtcInN0cnV0XCIsIFwiYm90dG9tXCJdKTtcblxuICAgIHRvcFN0cnV0LnN0eWxlLmhlaWdodCA9IGJvZHkuaGVpZ2h0ICsgXCJlbVwiO1xuICAgIGJvdHRvbVN0cnV0LnN0eWxlLmhlaWdodCA9IChib2R5LmhlaWdodCArIGJvZHkuZGVwdGgpICsgXCJlbVwiO1xuICAgIC8vIFdlJ2QgbGlrZSB0byB1c2UgYHZlcnRpY2FsLWFsaWduOiB0b3BgIGJ1dCBpbiBJRSA5IHRoaXMgbG93ZXJzIHRoZVxuICAgIC8vIGJhc2VsaW5lIG9mIHRoZSBib3ggdG8gdGhlIGJvdHRvbSBvZiB0aGlzIHN0cnV0IChpbnN0ZWFkIHN0YXlpbmcgaW4gdGhlXG4gICAgLy8gbm9ybWFsIHBsYWNlKSBzbyB3ZSB1c2UgYW4gYWJzb2x1dGUgdmFsdWUgZm9yIHZlcnRpY2FsLWFsaWduIGluc3RlYWRcbiAgICBib3R0b21TdHJ1dC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gLWJvZHkuZGVwdGggKyBcImVtXCI7XG5cbiAgICAvLyBXcmFwIHRoZSBzdHJ1dHMgYW5kIGJvZHkgdG9nZXRoZXJcbiAgICB2YXIgaHRtbE5vZGUgPSBtYWtlU3BhbihbXCJrYXRleC1odG1sXCJdLCBbdG9wU3RydXQsIGJvdHRvbVN0cnV0LCBib2R5XSk7XG5cbiAgICBodG1sTm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIik7XG5cbiAgICByZXR1cm4gaHRtbE5vZGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkSFRNTDtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnZlcnRzIGEgcGFyc2UgdHJlZSBpbnRvIGEgY29vcmVzcG9uZGluZyBNYXRoTUwgdHJlZS4gVGhlIG1haW5cbiAqIGVudHJ5IHBvaW50IGlzIHRoZSBgYnVpbGRNYXRoTUxgIGZ1bmN0aW9uLCB3aGljaCB0YWtlcyBhIHBhcnNlIHRyZWUgZnJvbSB0aGVcbiAqIHBhcnNlci5cbiAqL1xuXG52YXIgYnVpbGRDb21tb24gPSByZXF1aXJlKFwiLi9idWlsZENvbW1vblwiKTtcbnZhciBmb250TWV0cmljcyA9IHJlcXVpcmUoXCIuL2ZvbnRNZXRyaWNzXCIpO1xudmFyIG1hdGhNTFRyZWUgPSByZXF1aXJlKFwiLi9tYXRoTUxUcmVlXCIpO1xudmFyIFBhcnNlRXJyb3IgPSByZXF1aXJlKFwiLi9QYXJzZUVycm9yXCIpO1xudmFyIHN5bWJvbHMgPSByZXF1aXJlKFwiLi9zeW1ib2xzXCIpO1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbnZhciBtYWtlU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuO1xudmFyIGZvbnRNYXAgPSBidWlsZENvbW1vbi5mb250TWFwO1xuXG4vKipcbiAqIFRha2VzIGEgc3ltYm9sIGFuZCBjb252ZXJ0cyBpdCBpbnRvIGEgTWF0aE1MIHRleHQgbm9kZSBhZnRlciBwZXJmb3JtaW5nXG4gKiBvcHRpb25hbCByZXBsYWNlbWVudCBmcm9tIHN5bWJvbHMuanMuXG4gKi9cbnZhciBtYWtlVGV4dCA9IGZ1bmN0aW9uKHRleHQsIG1vZGUpIHtcbiAgICBpZiAoc3ltYm9sc1ttb2RlXVt0ZXh0XSAmJiBzeW1ib2xzW21vZGVdW3RleHRdLnJlcGxhY2UpIHtcbiAgICAgICAgdGV4dCA9IHN5bWJvbHNbbW9kZV1bdGV4dF0ucmVwbGFjZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4dCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1hdGggdmFyaWFudCBhcyBhIHN0cmluZyBvciBudWxsIGlmIG5vbmUgaXMgcmVxdWlyZWQuXG4gKi9cbnZhciBnZXRWYXJpYW50ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgICBpZiAoIWZvbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSBncm91cC5tb2RlO1xuICAgIGlmIChmb250ID09PSBcIm1hdGhpdFwiKSB7XG4gICAgICAgIHJldHVybiBcIml0YWxpY1wiO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IGdyb3VwLnZhbHVlO1xuICAgIGlmICh1dGlscy5jb250YWlucyhbXCJcXFxcaW1hdGhcIiwgXCJcXFxcam1hdGhcIl0sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoc3ltYm9sc1ttb2RlXVt2YWx1ZV0gJiYgc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZSkge1xuICAgICAgICB2YWx1ZSA9IHN5bWJvbHNbbW9kZV1bdmFsdWVdLnJlcGxhY2U7XG4gICAgfVxuXG4gICAgdmFyIGZvbnROYW1lID0gZm9udE1hcFtmb250XS5mb250TmFtZTtcbiAgICBpZiAoZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljcyh2YWx1ZSwgZm9udE5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmb250TWFwW29wdGlvbnMuZm9udF0udmFyaWFudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogRnVuY3Rpb25zIGZvciBoYW5kbGluZyB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIGdyb3VwcyBmb3VuZCBpbiB0aGUgcGFyc2VcbiAqIHRyZWUuIEVhY2ggZnVuY3Rpb24gc2hvdWxkIHRha2UgYSBwYXJzZSBncm91cCBhbmQgcmV0dXJuIGEgTWF0aE1MIG5vZGUuXG4gKi9cbnZhciBncm91cFR5cGVzID0ge307XG5cbmdyb3VwVHlwZXMubWF0aG9yZCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtaVwiLFxuICAgICAgICBbbWFrZVRleHQoZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICB2YXIgdmFyaWFudCA9IGdldFZhcmlhbnQoZ3JvdXAsIG9wdGlvbnMpO1xuICAgIGlmICh2YXJpYW50KSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgdmFyaWFudCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy50ZXh0b3JkID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGV4dCA9IG1ha2VUZXh0KGdyb3VwLnZhbHVlLCBncm91cC5tb2RlKTtcblxuICAgIHZhciB2YXJpYW50ID0gZ2V0VmFyaWFudChncm91cCwgb3B0aW9ucykgfHwgXCJub3JtYWxcIjtcblxuICAgIHZhciBub2RlO1xuICAgIGlmICgvWzAtOV0vLnRlc3QoZ3JvdXAudmFsdWUpKSB7XG4gICAgICAgIC8vIFRPRE8oa2V2aW5iKSBtZXJnZSBhZGphY2VudCA8bW4+IG5vZGVzXG4gICAgICAgIC8vIGRvIGl0IGFzIGEgcG9zdCBwcm9jZXNzaW5nIHN0ZXBcbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibW5cIiwgW3RleHRdKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9udCkge1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJtYXRodmFyaWFudFwiLCB2YXJpYW50KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1pXCIsIFt0ZXh0XSk7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibWF0aHZhcmlhbnRcIiwgdmFyaWFudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLmJpbiA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMucmVsID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5vcGVuID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5jbG9zZSA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUsIGdyb3VwLm1vZGUpXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuaW5uZXIgPSBmdW5jdGlvbihncm91cCkge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnZhbHVlLCBncm91cC5tb2RlKV0pO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLnB1bmN0ID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZSwgZ3JvdXAubW9kZSldKTtcblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2VwYXJhdG9yXCIsIFwidHJ1ZVwiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5vcmRncm91cCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLCBvcHRpb25zKTtcblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGlubmVyKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy50ZXh0ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXRleHRcIiwgaW5uZXIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLmNvbG9yID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIm1hdGhjb2xvclwiLCBncm91cC52YWx1ZS5jb2xvcik7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuc3Vwc3ViID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbYnVpbGRHcm91cChncm91cC52YWx1ZS5iYXNlLCBvcHRpb25zKV07XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUuc3ViKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRHcm91cChncm91cC52YWx1ZS5zdWIsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUuc3VwKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRHcm91cChncm91cC52YWx1ZS5zdXAsIG9wdGlvbnMpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZVR5cGU7XG4gICAgaWYgKCFncm91cC52YWx1ZS5zdWIpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdXBcIjtcbiAgICB9IGVsc2UgaWYgKCFncm91cC52YWx1ZS5zdXApIHtcbiAgICAgICAgbm9kZVR5cGUgPSBcIm1zdWJcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlVHlwZSA9IFwibXN1YnN1cFwiO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUobm9kZVR5cGUsIGNoaWxkcmVuKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5nZW5mcmFjID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1mcmFjXCIsXG4gICAgICAgIFtidWlsZEdyb3VwKGdyb3VwLnZhbHVlLm51bWVyLCBvcHRpb25zKSxcbiAgICAgICAgICAgIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuZGVub20sIG9wdGlvbnMpXSk7XG5cbiAgICBpZiAoIWdyb3VwLnZhbHVlLmhhc0JhckxpbmUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJsaW5ldGhpY2tuZXNzXCIsIFwiMHB4XCIpO1xuICAgIH1cblxuICAgIGlmIChncm91cC52YWx1ZS5sZWZ0RGVsaW0gIT0gbnVsbCB8fCBncm91cC52YWx1ZS5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHdpdGhEZWxpbXMgPSBbXTtcblxuICAgICAgICBpZiAoZ3JvdXAudmFsdWUubGVmdERlbGltICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0T3AgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgICAgICBcIm1vXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC52YWx1ZS5sZWZ0RGVsaW0pXSk7XG5cbiAgICAgICAgICAgIGxlZnRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG5cbiAgICAgICAgICAgIHdpdGhEZWxpbXMucHVzaChsZWZ0T3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgd2l0aERlbGltcy5wdXNoKG5vZGUpO1xuXG4gICAgICAgIGlmIChncm91cC52YWx1ZS5yaWdodERlbGltICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciByaWdodE9wID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICAgICAgXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoZ3JvdXAudmFsdWUucmlnaHREZWxpbSldKTtcblxuICAgICAgICAgICAgcmlnaHRPcC5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG5cbiAgICAgICAgICAgIHdpdGhEZWxpbXMucHVzaChyaWdodE9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRlck5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1yb3dcIiwgd2l0aERlbGltcyk7XG5cbiAgICAgICAgcmV0dXJuIG91dGVyTm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuYXJyYXkgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtdGFibGVcIiwgZ3JvdXAudmFsdWUuYm9keS5tYXAoZnVuY3Rpb24ocm93KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICAgICAgXCJtdHJcIiwgcm93Lm1hcChmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibXRkXCIsIFtidWlsZEdyb3VwKGNlbGwsIG9wdGlvbnMpXSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSk7XG59O1xuXG5ncm91cFR5cGVzLnNxcnQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlO1xuICAgIGlmIChncm91cC52YWx1ZS5pbmRleCkge1xuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1yb290XCIsIFtcbiAgICAgICAgICAgICAgICBidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuaW5kZXgsIG9wdGlvbnMpXG4gICAgICAgICAgICBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1zcXJ0XCIsIFtidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLmxlZnRyaWdodCA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIGlubmVyID0gYnVpbGRFeHByZXNzaW9uKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLmxlZnQgIT09IFwiLlwiKSB7XG4gICAgICAgIHZhciBsZWZ0Tm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUubGVmdCwgZ3JvdXAubW9kZSldKTtcblxuICAgICAgICBsZWZ0Tm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcInRydWVcIik7XG5cbiAgICAgICAgaW5uZXIudW5zaGlmdChsZWZ0Tm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnJpZ2h0ICE9PSBcIi5cIikge1xuICAgICAgICB2YXIgcmlnaHROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZS5yaWdodCwgZ3JvdXAubW9kZSldKTtcblxuICAgICAgICByaWdodE5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuXG4gICAgICAgIGlubmVyLnB1c2gocmlnaHROb2RlKTtcbiAgICB9XG5cbiAgICB2YXIgb3V0ZXJOb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtcm93XCIsIGlubmVyKTtcblxuICAgIHJldHVybiBvdXRlck5vZGU7XG59O1xuXG5ncm91cFR5cGVzLm1pZGRsZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG1pZGRsZU5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoZ3JvdXAudmFsdWUubWlkZGxlLCBncm91cC5tb2RlKV0pO1xuICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIHJldHVybiBtaWRkbGVOb2RlO1xufTtcblxuZ3JvdXBUeXBlcy5hY2NlbnQgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBhY2NlbnROb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW9cIiwgW21ha2VUZXh0KGdyb3VwLnZhbHVlLmFjY2VudCwgZ3JvdXAubW9kZSldKTtcblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW92ZXJcIixcbiAgICAgICAgW2J1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYmFzZSwgb3B0aW9ucyksXG4gICAgICAgICAgICBhY2NlbnROb2RlXSk7XG5cbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudFwiLCBcInRydWVcIik7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuc3BhY2luZyA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgdmFyIG5vZGU7XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUgPT09IFwiXFxcXCBcIiB8fCBncm91cC52YWx1ZSA9PT0gXCJcXFxcc3BhY2VcIiB8fFxuICAgICAgICBncm91cC52YWx1ZSA9PT0gXCIgXCIgfHwgZ3JvdXAudmFsdWUgPT09IFwiflwiKSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgIFwibXRleHRcIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MDBhMFwiKV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zcGFjZVwiKTtcblxuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgIFwid2lkdGhcIiwgYnVpbGRDb21tb24uc3BhY2luZ0Z1bmN0aW9uc1tncm91cC52YWx1ZV0uc2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLm9wID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZTtcblxuICAgIC8vIFRPRE8oZW1pbHkpOiBoYW5kbGUgYmlnIG9wZXJhdG9ycyB1c2luZyB0aGUgYGxhcmdlb3BgIGF0dHJpYnV0ZVxuXG4gICAgaWYgKGdyb3VwLnZhbHVlLnN5bWJvbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3ltYm9sLiBKdXN0IGFkZCB0aGUgc3ltYm9sLlxuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1vXCIsIFttYWtlVGV4dChncm91cC52YWx1ZS5ib2R5LCBncm91cC5tb2RlKV0pO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudmFsdWUudmFsdWUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBvcGVyYXRvciB3aXRoIGNoaWxkcmVuLiBBZGQgdGhlbS5cbiAgICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICAgICAgXCJtb1wiLCBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgdGV4dCBvcGVyYXRvci4gQWRkIGFsbCBvZiB0aGUgY2hhcmFjdGVycyBmcm9tIHRoZVxuICAgICAgICAvLyBvcGVyYXRvcidzIG5hbWUuXG4gICAgICAgIC8vIFRPRE8oZW1pbHkpOiBBZGQgYSBzcGFjZSBpbiB0aGUgbWlkZGxlIG9mIHNvbWUgb2YgdGhlc2VcbiAgICAgICAgLy8gb3BlcmF0b3JzLCBsaWtlIFxcbGltc3VwLlxuICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgICAgICBcIm1pXCIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC52YWx1ZS5ib2R5LnNsaWNlKDEpKV0pO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5tb2QgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBpbm5lciA9IFtdO1xuXG4gICAgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgPT09IFwicG9kXCIgfHwgZ3JvdXAudmFsdWUubW9kVHlwZSA9PT0gXCJwbW9kXCIpIHtcbiAgICAgICAgaW5uZXIucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgIFwibW9cIiwgW21ha2VUZXh0KFwiKFwiLCBncm91cC5tb2RlKV0pKTtcbiAgICB9XG4gICAgaWYgKGdyb3VwLnZhbHVlLm1vZFR5cGUgIT09IFwicG9kXCIpIHtcbiAgICAgICAgaW5uZXIucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgICAgIFwibW9cIiwgW21ha2VUZXh0KFwibW9kXCIsIGdyb3VwLm1vZGUpXSkpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudmFsdWUudmFsdWUpIHtcbiAgICAgICAgdmFyIHNwYWNlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtc3BhY2VcIik7XG4gICAgICAgIHNwYWNlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMC4zMzMzMzNlbVwiKTtcbiAgICAgICAgaW5uZXIucHVzaChzcGFjZSk7XG4gICAgICAgIGlubmVyID0gaW5uZXIuY29uY2F0KGJ1aWxkRXhwcmVzc2lvbihncm91cC52YWx1ZS52YWx1ZSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXAudmFsdWUubW9kVHlwZSA9PT0gXCJwb2RcIiB8fCBncm91cC52YWx1ZS5tb2RUeXBlID09PSBcInBtb2RcIikge1xuICAgICAgICBpbm5lci5wdXNoKG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICAgICAgXCJtb1wiLCBbbWFrZVRleHQoXCIpXCIsIGdyb3VwLm1vZGUpXSkpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1vXCIsIGlubmVyKTtcbn07XG5cbmdyb3VwVHlwZXMua2F0ZXggPSBmdW5jdGlvbihncm91cCkge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXRleHRcIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiS2FUZVhcIildKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5mb250ID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9udCA9IGdyb3VwLnZhbHVlLmZvbnQ7XG4gICAgcmV0dXJuIGJ1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucy53aXRoRm9udChmb250KSk7XG59O1xuXG5ncm91cFR5cGVzLmRlbGltc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgIGlmIChncm91cC52YWx1ZS52YWx1ZSAhPT0gXCIuXCIpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChtYWtlVGV4dChncm91cC52YWx1ZS52YWx1ZSwgZ3JvdXAubW9kZSkpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtb1wiLCBjaGlsZHJlbik7XG5cbiAgICBpZiAoZ3JvdXAudmFsdWUubWNsYXNzID09PSBcIm1vcGVuXCIgfHxcbiAgICAgICAgZ3JvdXAudmFsdWUubWNsYXNzID09PSBcIm1jbG9zZVwiKSB7XG4gICAgICAgIC8vIE9ubHkgc29tZSBvZiB0aGUgZGVsaW1zaXppbmcgZnVuY3Rpb25zIGFjdCBhcyBmZW5jZXMsIGFuZCB0aGV5XG4gICAgICAgIC8vIHJldHVybiBcIm1vcGVuXCIgb3IgXCJtY2xvc2VcIiBtY2xhc3MuXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiZmVuY2VcIiwgXCJ0cnVlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgZGlzYWJsZSBmZW5jaW5nIGlmIGl0J3Mgbm90IGEgZmVuY2UsIHRvIG92ZXJyaWRlIHRoZVxuICAgICAgICAvLyBkZWZhdWx0cy5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJmZW5jZVwiLCBcImZhbHNlXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5zdHlsaW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG5cbiAgICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0ge1xuICAgICAgICBcImRpc3BsYXlcIjogW1wiMFwiLCBcInRydWVcIl0sXG4gICAgICAgIFwidGV4dFwiOiBbXCIwXCIsIFwiZmFsc2VcIl0sXG4gICAgICAgIFwic2NyaXB0XCI6IFtcIjFcIiwgXCJmYWxzZVwiXSxcbiAgICAgICAgXCJzY3JpcHRzY3JpcHRcIjogW1wiMlwiLCBcImZhbHNlXCJdXG4gICAgfTtcblxuICAgIHZhciBhdHRyID0gc3R5bGVBdHRyaWJ1dGVzW2dyb3VwLnZhbHVlLnN0eWxlXTtcblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwic2NyaXB0bGV2ZWxcIiwgYXR0clswXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJkaXNwbGF5c3R5bGVcIiwgYXR0clsxXSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbmdyb3VwVHlwZXMuc2l6aW5nID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG5cbiAgICAvLyBUT0RPKGVtaWx5KTogVGhpcyBkb2Vzbid0IHByb2R1Y2UgdGhlIGNvcnJlY3Qgc2l6ZSBmb3IgbmVzdGVkIHNpemVcbiAgICAvLyBjaGFuZ2VzLCBiZWNhdXNlIHdlIGRvbid0IGtlZXAgc3RhdGUgb2Ygd2hhdCBzdHlsZSB3ZSdyZSBjdXJyZW50bHlcbiAgICAvLyBpbiwgc28gd2UgY2FuJ3QgcmVzZXQgdGhlIHNpemUgdG8gbm9ybWFsIGJlZm9yZSBjaGFuZ2luZyBpdC4gIE5vd1xuICAgIC8vIHRoYXQgd2UncmUgcGFzc2luZyBhbiBvcHRpb25zIHBhcmFtZXRlciB3ZSBzaG91bGQgYmUgYWJsZSB0byBmaXhcbiAgICAvLyB0aGlzLlxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFxuICAgICAgICBcIm1hdGhzaXplXCIsIGJ1aWxkQ29tbW9uLnNpemluZ011bHRpcGxpZXJbZ3JvdXAudmFsdWUuc2l6ZV0gKyBcImVtXCIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLm92ZXJsaW5lID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb1wiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoXCJcXHUyMDNlXCIpXSk7XG4gICAgb3BlcmF0b3Iuc2V0QXR0cmlidXRlKFwic3RyZXRjaHlcIiwgXCJ0cnVlXCIpO1xuXG4gICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJtb3ZlclwiLFxuICAgICAgICBbYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zKSxcbiAgICAgICAgICAgIG9wZXJhdG9yXSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJhY2NlbnRcIiwgXCJ0cnVlXCIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLnVuZGVybGluZSA9IGZ1bmN0aW9uKGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdmFyIG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibW9cIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKFwiXFx1MjAzZVwiKV0pO1xuICAgIG9wZXJhdG9yLnNldEF0dHJpYnV0ZShcInN0cmV0Y2h5XCIsIFwidHJ1ZVwiKTtcblxuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXVuZGVyXCIsXG4gICAgICAgIFtidWlsZEdyb3VwKGdyb3VwLnZhbHVlLmJvZHksIG9wdGlvbnMpLFxuICAgICAgICAgICAgb3BlcmF0b3JdKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcImFjY2VudHVuZGVyXCIsIFwidHJ1ZVwiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5ydWxlID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAvLyBUT0RPKGVtaWx5KTogRmlndXJlIG91dCBpZiB0aGVyZSdzIGFuIGFjdHVhbCB3YXkgdG8gZHJhdyBibGFjayBib3hlc1xuICAgIC8vIGluIE1hdGhNTC5cbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5rZXJuID0gZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAvLyBUT0RPKGtldmluKTogRmlndXJlIG91dCBpZiB0aGVyZSdzIGEgd2F5IHRvIGFkZCBzcGFjZSBpbiBNYXRoTUxcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5sbGFwID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFxuICAgICAgICBcIm1wYWRkZWRcIiwgW2J1aWxkR3JvdXAoZ3JvdXAudmFsdWUuYm9keSwgb3B0aW9ucyldKTtcblxuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwibHNwYWNlXCIsIFwiLTF3aWR0aFwiKTtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMHB4XCIpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5ncm91cFR5cGVzLnJsYXAgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwibXBhZGRlZFwiLCBbYnVpbGRHcm91cChncm91cC52YWx1ZS5ib2R5LCBvcHRpb25zKV0pO1xuXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjBweFwiKTtcblxuICAgIHJldHVybiBub2RlO1xufTtcblxuZ3JvdXBUeXBlcy5waGFudG9tID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1waGFudG9tXCIsIGlubmVyKTtcbn07XG5cbmdyb3VwVHlwZXMubWNsYXNzID0gZnVuY3Rpb24oZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgaW5uZXIgPSBidWlsZEV4cHJlc3Npb24oZ3JvdXAudmFsdWUudmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcIm1zdHlsZVwiLCBpbm5lcik7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBub2RlcywgYnVpbGRzIHRoZW0sIGFuZCByZXR1cm5zIGEgbGlzdCBvZiB0aGUgZ2VuZXJhdGVkXG4gKiBNYXRoTUwgbm9kZXMuIEEgbGl0dGxlIHNpbXBsZXIgdGhhbiB0aGUgSFRNTCB2ZXJzaW9uIGJlY2F1c2Ugd2UgZG9uJ3QgZG8gYW55XG4gKiBwcmV2aW91cy1ub2RlIGhhbmRsaW5nLlxuICovXG52YXIgYnVpbGRFeHByZXNzaW9uID0gZnVuY3Rpb24oZXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBncm91cHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGdyb3VwID0gZXhwcmVzc2lvbltpXTtcbiAgICAgICAgZ3JvdXBzLnB1c2goYnVpbGRHcm91cChncm91cCwgb3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBzO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIGdyb3VwIGZyb20gdGhlIHBhcnNlciBhbmQgY2FsbHMgdGhlIGFwcHJvcHJpYXRlIGdyb3VwVHlwZXMgZnVuY3Rpb25cbiAqIG9uIGl0IHRvIHByb2R1Y2UgYSBNYXRoTUwgbm9kZS5cbiAqL1xudmFyIGJ1aWxkR3JvdXAgPSBmdW5jdGlvbihncm91cCwgb3B0aW9ucykge1xuICAgIGlmICghZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiKTtcbiAgICB9XG5cbiAgICBpZiAoZ3JvdXBUeXBlc1tncm91cC50eXBlXSkge1xuICAgICAgICAvLyBDYWxsIHRoZSBncm91cFR5cGVzIGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiBncm91cFR5cGVzW2dyb3VwLnR5cGVdKGdyb3VwLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgIFwiR290IGdyb3VwIG9mIHVua25vd24gdHlwZTogJ1wiICsgZ3JvdXAudHlwZSArIFwiJ1wiKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRha2VzIGEgZnVsbCBwYXJzZSB0cmVlIGFuZCBzZXR0aW5ncyBhbmQgYnVpbGRzIGEgTWF0aE1MIHJlcHJlc2VudGF0aW9uIG9mXG4gKiBpdC4gSW4gcGFydGljdWxhciwgd2UgcHV0IHRoZSBlbGVtZW50cyBmcm9tIGJ1aWxkaW5nIHRoZSBwYXJzZSB0cmVlIGludG8gYVxuICogPHNlbWFudGljcz4gdGFnIHNvIHdlIGNhbiBhbHNvIGluY2x1ZGUgdGhhdCBUZVggc291cmNlIGFzIGFuIGFubm90YXRpb24uXG4gKlxuICogTm90ZSB0aGF0IHdlIGFjdHVhbGx5IHJldHVybiBhIGRvbVRyZWUgZWxlbWVudCB3aXRoIGEgYDxtYXRoPmAgaW5zaWRlIGl0IHNvXG4gKiB3ZSBjYW4gZG8gYXBwcm9wcmlhdGUgc3R5bGluZy5cbiAqL1xudmFyIGJ1aWxkTWF0aE1MID0gZnVuY3Rpb24odHJlZSwgdGV4RXhwcmVzc2lvbiwgb3B0aW9ucykge1xuICAgIHZhciBleHByZXNzaW9uID0gYnVpbGRFeHByZXNzaW9uKHRyZWUsIG9wdGlvbnMpO1xuXG4gICAgLy8gV3JhcCB1cCB0aGUgZXhwcmVzc2lvbiBpbiBhbiBtcm93IHNvIGl0IGlzIHByZXNlbnRlZCBpbiB0aGUgc2VtYW50aWNzXG4gICAgLy8gdGFnIGNvcnJlY3RseS5cbiAgICB2YXIgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKFwibXJvd1wiLCBleHByZXNzaW9uKTtcblxuICAgIC8vIEJ1aWxkIGEgVGVYIGFubm90YXRpb24gb2YgdGhlIHNvdXJjZVxuICAgIHZhciBhbm5vdGF0aW9uID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXG4gICAgICAgIFwiYW5ub3RhdGlvblwiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4RXhwcmVzc2lvbildKTtcblxuICAgIGFubm90YXRpb24uc2V0QXR0cmlidXRlKFwiZW5jb2RpbmdcIiwgXCJhcHBsaWNhdGlvbi94LXRleFwiKTtcblxuICAgIHZhciBzZW1hbnRpY3MgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShcbiAgICAgICAgXCJzZW1hbnRpY3NcIiwgW3dyYXBwZXIsIGFubm90YXRpb25dKTtcblxuICAgIHZhciBtYXRoID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoXCJtYXRoXCIsIFtzZW1hbnRpY3NdKTtcblxuICAgIC8vIFlvdSBjYW4ndCBzdHlsZSA8bWF0aD4gbm9kZXMsIHNvIHdlIHdyYXAgdGhlIG5vZGUgaW4gYSBzcGFuLlxuICAgIHJldHVybiBtYWtlU3BhbihbXCJrYXRleC1tYXRobWxcIl0sIFttYXRoXSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJ1aWxkTWF0aE1MO1xuIiwidmFyIGJ1aWxkSFRNTCA9IHJlcXVpcmUoXCIuL2J1aWxkSFRNTFwiKTtcbnZhciBidWlsZE1hdGhNTCA9IHJlcXVpcmUoXCIuL2J1aWxkTWF0aE1MXCIpO1xudmFyIGJ1aWxkQ29tbW9uID0gcmVxdWlyZShcIi4vYnVpbGRDb21tb25cIik7XG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoXCIuL09wdGlvbnNcIik7XG52YXIgU2V0dGluZ3MgPSByZXF1aXJlKFwiLi9TZXR0aW5nc1wiKTtcbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL1N0eWxlXCIpO1xuXG52YXIgbWFrZVNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbjtcblxudmFyIGJ1aWxkVHJlZSA9IGZ1bmN0aW9uKHRyZWUsIGV4cHJlc3Npb24sIHNldHRpbmdzKSB7XG4gICAgc2V0dGluZ3MgPSBzZXR0aW5ncyB8fCBuZXcgU2V0dGluZ3Moe30pO1xuXG4gICAgdmFyIHN0YXJ0U3R5bGUgPSBTdHlsZS5URVhUO1xuICAgIGlmIChzZXR0aW5ncy5kaXNwbGF5TW9kZSkge1xuICAgICAgICBzdGFydFN0eWxlID0gU3R5bGUuRElTUExBWTtcbiAgICB9XG5cbiAgICAvLyBTZXR1cCB0aGUgZGVmYXVsdCBvcHRpb25zXG4gICAgdmFyIG9wdGlvbnMgPSBuZXcgT3B0aW9ucyh7XG4gICAgICAgIHN0eWxlOiBzdGFydFN0eWxlLFxuICAgICAgICBzaXplOiBcInNpemU1XCJcbiAgICB9KTtcblxuICAgIC8vIGBidWlsZEhUTUxgIHNvbWV0aW1lcyBtZXNzZXMgd2l0aCB0aGUgcGFyc2UgdHJlZSAobGlrZSB0dXJuaW5nIGJpbnMgLT5cbiAgICAvLyBvcmRzKSwgc28gd2UgYnVpbGQgdGhlIE1hdGhNTCB2ZXJzaW9uIGZpcnN0LlxuICAgIHZhciBtYXRoTUxOb2RlID0gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgb3B0aW9ucyk7XG4gICAgdmFyIGh0bWxOb2RlID0gYnVpbGRIVE1MKHRyZWUsIG9wdGlvbnMpO1xuXG4gICAgdmFyIGthdGV4Tm9kZSA9IG1ha2VTcGFuKFtcImthdGV4XCJdLCBbXG4gICAgICAgIG1hdGhNTE5vZGUsIGh0bWxOb2RlXG4gICAgXSk7XG5cbiAgICBpZiAoc2V0dGluZ3MuZGlzcGxheU1vZGUpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTcGFuKFtcImthdGV4LWRpc3BsYXlcIl0sIFtrYXRleE5vZGVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga2F0ZXhOb2RlO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRUcmVlO1xuIiwiLyoqXG4gKiBUaGlzIGZpbGUgZGVhbHMgd2l0aCBjcmVhdGluZyBkZWxpbWl0ZXJzIG9mIHZhcmlvdXMgc2l6ZXMuIFRoZSBUZVhib29rXG4gKiBkaXNjdXNzZXMgdGhlc2Ugcm91dGluZXMgb24gcGFnZSA0NDEtNDQyLCBpbiB0aGUgXCJBbm90aGVyIHN1YnJvdXRpbmUgc2V0cyBib3hcbiAqIHggdG8gYSBzcGVjaWZpZWQgdmFyaWFibGUgZGVsaW1pdGVyXCIgcGFyYWdyYXBoLlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBtYWluIHJvdXRpbmVzIGhlcmUuIGBtYWtlU21hbGxEZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgaW4gdGhlXG4gKiBub3JtYWwgZm9udCwgYnV0IGluIGVpdGhlciB0ZXh0LCBzY3JpcHQsIG9yIHNjcmlwdHNjcmlwdCBzdHlsZS5cbiAqIGBtYWtlTGFyZ2VEZWxpbWAgbWFrZXMgYSBkZWxpbWl0ZXIgaW4gdGV4dHN0eWxlLCBidXQgaW4gb25lIG9mIHRoZSBTaXplMSxcbiAqIFNpemUyLCBTaXplMywgb3IgU2l6ZTQgZm9udHMuIGBtYWtlU3RhY2tlZERlbGltYCBtYWtlcyBhIGRlbGltaXRlciBvdXQgb2ZcbiAqIHNtYWxsZXIgcGllY2VzIHRoYXQgYXJlIHN0YWNrZWQgb24gdG9wIG9mIG9uZSBhbm90aGVyLlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgdGFrZSBhIHBhcmFtZXRlciBgY2VudGVyYCwgd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgZGVsaW1pdGVyXG4gKiBzaG91bGQgYmUgY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzLlxuICpcbiAqIFRoZW4sIHRoZXJlIGFyZSB0aHJlZSBleHBvc2VkIGZ1bmN0aW9ucy4gYHNpemVkRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIGluXG4gKiBvbmUgb2YgdGhlIGdpdmVuIHNpemVzLiBUaGlzIGlzIHVzZWQgZm9yIHRoaW5ncyBsaWtlIGBcXGJpZ2xgLlxuICogYGN1c3RvbVNpemVkRGVsaW1gIG1ha2VzIGEgZGVsaW1pdGVyIHdpdGggYSBnaXZlbiB0b3RhbCBoZWlnaHQrZGVwdGguIEl0IGlzXG4gKiBjYWxsZWQgaW4gcGxhY2VzIGxpa2UgYFxcc3FydGAuIGBsZWZ0UmlnaHREZWxpbWAgbWFrZXMgYW4gYXBwcm9wcmlhdGVcbiAqIGRlbGltaXRlciB3aGljaCBzdXJyb3VuZHMgYW4gZXhwcmVzc2lvbiBvZiBhIGdpdmVuIGhlaWdodCBhbiBkZXB0aC4gSXQgaXNcbiAqIHVzZWQgaW4gYFxcbGVmdGAgYW5kIGBcXHJpZ2h0YC5cbiAqL1xuXG52YXIgUGFyc2VFcnJvciA9IHJlcXVpcmUoXCIuL1BhcnNlRXJyb3JcIik7XG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9TdHlsZVwiKTtcblxudmFyIGJ1aWxkQ29tbW9uID0gcmVxdWlyZShcIi4vYnVpbGRDb21tb25cIik7XG52YXIgZm9udE1ldHJpY3MgPSByZXF1aXJlKFwiLi9mb250TWV0cmljc1wiKTtcbnZhciBzeW1ib2xzID0gcmVxdWlyZShcIi4vc3ltYm9sc1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG52YXIgbWFrZVNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbjtcblxuLyoqXG4gKiBHZXQgdGhlIG1ldHJpY3MgZm9yIGEgZ2l2ZW4gc3ltYm9sIGFuZCBmb250LCBhZnRlciB0cmFuc2Zvcm1hdGlvbiAoaS5lLlxuICogYWZ0ZXIgZm9sbG93aW5nIHJlcGxhY2VtZW50IGZyb20gc3ltYm9scy5qcylcbiAqL1xudmFyIGdldE1ldHJpY3MgPSBmdW5jdGlvbihzeW1ib2wsIGZvbnQpIHtcbiAgICBpZiAoc3ltYm9scy5tYXRoW3N5bWJvbF0gJiYgc3ltYm9scy5tYXRoW3N5bWJvbF0ucmVwbGFjZSkge1xuICAgICAgICByZXR1cm4gZm9udE1ldHJpY3MuZ2V0Q2hhcmFjdGVyTWV0cmljcyhcbiAgICAgICAgICAgIHN5bWJvbHMubWF0aFtzeW1ib2xdLnJlcGxhY2UsIGZvbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmb250TWV0cmljcy5nZXRDaGFyYWN0ZXJNZXRyaWNzKFxuICAgICAgICAgICAgc3ltYm9sLCBmb250KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIHN5bWJvbCBpbiB0aGUgZ2l2ZW4gZm9udCBzaXplIChub3RlIHNpemUgaXMgYW4gaW50ZWdlcilcbiAqL1xudmFyIG1hdGhybVNpemUgPSBmdW5jdGlvbih2YWx1ZSwgc2l6ZSwgbW9kZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3ltYm9sKHZhbHVlLCBcIlNpemVcIiArIHNpemUgKyBcIi1SZWd1bGFyXCIsXG4gICAgICAgIG1vZGUsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBQdXRzIGEgZGVsaW1pdGVyIHNwYW4gaW4gYSBnaXZlbiBzdHlsZSwgYW5kIGFkZHMgYXBwcm9wcmlhdGUgaGVpZ2h0LCBkZXB0aCxcbiAqIGFuZCBtYXhGb250U2l6ZXMuXG4gKi9cbnZhciBzdHlsZVdyYXAgPSBmdW5jdGlvbihkZWxpbSwgdG9TdHlsZSwgb3B0aW9ucywgY2xhc3Nlcykge1xuICAgIGNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdO1xuICAgIHZhciBzcGFuID0gbWFrZVNwYW4oXG4gICAgICAgIGNsYXNzZXMuY29uY2F0KFtcInN0eWxlLXdyYXBcIiwgb3B0aW9ucy5zdHlsZS5yZXNldCgpLCB0b1N0eWxlLmNscygpXSksXG4gICAgICAgIFtkZWxpbV0sIG9wdGlvbnMpO1xuXG4gICAgdmFyIG11bHRpcGxpZXIgPSB0b1N0eWxlLnNpemVNdWx0aXBsaWVyIC8gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIHNwYW4uaGVpZ2h0ICo9IG11bHRpcGxpZXI7XG4gICAgc3Bhbi5kZXB0aCAqPSBtdWx0aXBsaWVyO1xuICAgIHNwYW4ubWF4Rm9udFNpemUgPSB0b1N0eWxlLnNpemVNdWx0aXBsaWVyO1xuXG4gICAgcmV0dXJuIHNwYW47XG59O1xuXG4vKipcbiAqIE1ha2VzIGEgc21hbGwgZGVsaW1pdGVyLiBUaGlzIGlzIGEgZGVsaW1pdGVyIHRoYXQgY29tZXMgaW4gdGhlIE1haW4tUmVndWxhclxuICogZm9udCwgYnV0IGlzIHJlc3R5bGVkIHRvIGVpdGhlciBiZSBpbiB0ZXh0c3R5bGUsIHNjcmlwdHN0eWxlLCBvclxuICogc2NyaXB0c2NyaXB0c3R5bGUuXG4gKi9cbnZhciBtYWtlU21hbGxEZWxpbSA9IGZ1bmN0aW9uKGRlbGltLCBzdHlsZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gICAgdmFyIHRleHQgPSBidWlsZENvbW1vbi5tYWtlU3ltYm9sKGRlbGltLCBcIk1haW4tUmVndWxhclwiLCBtb2RlLCBvcHRpb25zKTtcblxuICAgIHZhciBzcGFuID0gc3R5bGVXcmFwKHRleHQsIHN0eWxlLCBvcHRpb25zLCBjbGFzc2VzKTtcblxuICAgIGlmIChjZW50ZXIpIHtcbiAgICAgICAgdmFyIHNoaWZ0ID1cbiAgICAgICAgICAgICgxIC0gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllciAvIHN0eWxlLnNpemVNdWx0aXBsaWVyKSAqXG4gICAgICAgICAgICBvcHRpb25zLnN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodDtcblxuICAgICAgICBzcGFuLnN0eWxlLnRvcCA9IHNoaWZ0ICsgXCJlbVwiO1xuICAgICAgICBzcGFuLmhlaWdodCAtPSBzaGlmdDtcbiAgICAgICAgc3Bhbi5kZXB0aCArPSBzaGlmdDtcbiAgICB9XG5cbiAgICByZXR1cm4gc3Bhbjtcbn07XG5cbi8qKlxuICogTWFrZXMgYSBsYXJnZSBkZWxpbWl0ZXIuIFRoaXMgaXMgYSBkZWxpbWl0ZXIgdGhhdCBjb21lcyBpbiB0aGUgU2l6ZTEsIFNpemUyLFxuICogU2l6ZTMsIG9yIFNpemU0IGZvbnRzLiBJdCBpcyBhbHdheXMgcmVuZGVyZWQgaW4gdGV4dHN0eWxlLlxuICovXG52YXIgbWFrZUxhcmdlRGVsaW0gPSBmdW5jdGlvbihkZWxpbSwgc2l6ZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7XG4gICAgdmFyIGlubmVyID0gbWF0aHJtU2l6ZShkZWxpbSwgc2l6ZSwgbW9kZSwgb3B0aW9ucyk7XG5cbiAgICB2YXIgc3BhbiA9IHN0eWxlV3JhcChcbiAgICAgICAgbWFrZVNwYW4oW1wiZGVsaW1zaXppbmdcIiwgXCJzaXplXCIgKyBzaXplXSwgW2lubmVyXSwgb3B0aW9ucyksXG4gICAgICAgIFN0eWxlLlRFWFQsIG9wdGlvbnMsIGNsYXNzZXMpO1xuXG4gICAgaWYgKGNlbnRlcikge1xuICAgICAgICB2YXIgc2hpZnQgPSAoMSAtIG9wdGlvbnMuc3R5bGUuc2l6ZU11bHRpcGxpZXIpICpcbiAgICAgICAgICAgIG9wdGlvbnMuc3R5bGUubWV0cmljcy5heGlzSGVpZ2h0O1xuXG4gICAgICAgIHNwYW4uc3R5bGUudG9wID0gc2hpZnQgKyBcImVtXCI7XG4gICAgICAgIHNwYW4uaGVpZ2h0IC09IHNoaWZ0O1xuICAgICAgICBzcGFuLmRlcHRoICs9IHNoaWZ0O1xuICAgIH1cblxuICAgIHJldHVybiBzcGFuO1xufTtcblxuLyoqXG4gKiBNYWtlIGFuIGlubmVyIHNwYW4gd2l0aCB0aGUgZ2l2ZW4gb2Zmc2V0IGFuZCBpbiB0aGUgZ2l2ZW4gZm9udC4gVGhpcyBpcyB1c2VkXG4gKiBpbiBgbWFrZVN0YWNrZWREZWxpbWAgdG8gbWFrZSB0aGUgc3RhY2tpbmcgcGllY2VzIGZvciB0aGUgZGVsaW1pdGVyLlxuICovXG52YXIgbWFrZUlubmVyID0gZnVuY3Rpb24oc3ltYm9sLCBmb250LCBtb2RlKSB7XG4gICAgdmFyIHNpemVDbGFzcztcbiAgICAvLyBBcHBseSB0aGUgY29ycmVjdCBDU1MgY2xhc3MgdG8gY2hvb3NlIHRoZSByaWdodCBmb250LlxuICAgIGlmIChmb250ID09PSBcIlNpemUxLVJlZ3VsYXJcIikge1xuICAgICAgICBzaXplQ2xhc3MgPSBcImRlbGltLXNpemUxXCI7XG4gICAgfSBlbHNlIGlmIChmb250ID09PSBcIlNpemU0LVJlZ3VsYXJcIikge1xuICAgICAgICBzaXplQ2xhc3MgPSBcImRlbGltLXNpemU0XCI7XG4gICAgfVxuXG4gICAgdmFyIGlubmVyID0gbWFrZVNwYW4oXG4gICAgICAgIFtcImRlbGltc2l6aW5naW5uZXJcIiwgc2l6ZUNsYXNzXSxcbiAgICAgICAgW21ha2VTcGFuKFtdLCBbYnVpbGRDb21tb24ubWFrZVN5bWJvbChzeW1ib2wsIGZvbnQsIG1vZGUpXSldKTtcblxuICAgIC8vIFNpbmNlIHRoaXMgd2lsbCBiZSBwYXNzZWQgaW50byBgbWFrZVZMaXN0YCBpbiB0aGUgZW5kLCB3cmFwIHRoZSBlbGVtZW50XG4gICAgLy8gaW4gdGhlIGFwcHJvcHJpYXRlIHRhZyB0aGF0IFZMaXN0IHVzZXMuXG4gICAgcmV0dXJuIHt0eXBlOiBcImVsZW1cIiwgZWxlbTogaW5uZXJ9O1xufTtcblxuLyoqXG4gKiBNYWtlIGEgc3RhY2tlZCBkZWxpbWl0ZXIgb3V0IG9mIGEgZ2l2ZW4gZGVsaW1pdGVyLCB3aXRoIHRoZSB0b3RhbCBoZWlnaHQgYXRcbiAqIGxlYXN0IGBoZWlnaHRUb3RhbGAuIFRoaXMgcm91dGluZSBpcyBtZW50aW9uZWQgb24gcGFnZSA0NDIgb2YgdGhlIFRlWGJvb2suXG4gKi9cbnZhciBtYWtlU3RhY2tlZERlbGltID0gZnVuY3Rpb24oZGVsaW0sIGhlaWdodFRvdGFsLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpIHtcbiAgICAvLyBUaGVyZSBhcmUgZm91ciBwYXJ0cywgdGhlIHRvcCwgYW4gb3B0aW9uYWwgbWlkZGxlLCBhIHJlcGVhdGVkIHBhcnQsIGFuZCBhXG4gICAgLy8gYm90dG9tLlxuICAgIHZhciB0b3A7XG4gICAgdmFyIG1pZGRsZTtcbiAgICB2YXIgcmVwZWF0O1xuICAgIHZhciBib3R0b207XG4gICAgdG9wID0gcmVwZWF0ID0gYm90dG9tID0gZGVsaW07XG4gICAgbWlkZGxlID0gbnVsbDtcbiAgICAvLyBBbHNvIGtlZXAgdHJhY2sgb2Ygd2hhdCBmb250IHRoZSBkZWxpbWl0ZXJzIGFyZSBpblxuICAgIHZhciBmb250ID0gXCJTaXplMS1SZWd1bGFyXCI7XG5cbiAgICAvLyBXZSBzZXQgdGhlIHBhcnRzIGFuZCBmb250IGJhc2VkIG9uIHRoZSBzeW1ib2wuIE5vdGUgdGhhdCB3ZSB1c2VcbiAgICAvLyAnXFx1MjNkMCcgaW5zdGVhZCBvZiAnfCcgYW5kICdcXHUyMDE2JyBpbnN0ZWFkIG9mICdcXFxcfCcgZm9yIHRoZVxuICAgIC8vIHJlcGVhdHMgb2YgdGhlIGFycm93c1xuICAgIGlmIChkZWxpbSA9PT0gXCJcXFxcdXBhcnJvd1wiKSB7XG4gICAgICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNkMFwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXFVwYXJyb3dcIikge1xuICAgICAgICByZXBlYXQgPSBib3R0b20gPSBcIlxcdTIwMTZcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxkb3duYXJyb3dcIikge1xuICAgICAgICB0b3AgPSByZXBlYXQgPSBcIlxcdTIzZDBcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxEb3duYXJyb3dcIikge1xuICAgICAgICB0b3AgPSByZXBlYXQgPSBcIlxcdTIwMTZcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFx1cGRvd25hcnJvd1wiKSB7XG4gICAgICAgIHRvcCA9IFwiXFxcXHVwYXJyb3dcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyM2QwXCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFxcXGRvd25hcnJvd1wiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXFVwZG93bmFycm93XCIpIHtcbiAgICAgICAgdG9wID0gXCJcXFxcVXBhcnJvd1wiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIwMTZcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXFxcRG93bmFycm93XCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJbXCIgfHwgZGVsaW0gPT09IFwiXFxcXGxicmFja1wiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1MjNhMVwiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIzYTJcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXHUyM2EzXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIl1cIiB8fCBkZWxpbSA9PT0gXCJcXFxccmJyYWNrXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E0XCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjNhNVwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTZcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxmbG9vclwiKSB7XG4gICAgICAgIHJlcGVhdCA9IHRvcCA9IFwiXFx1MjNhMlwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTNcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXGxjZWlsXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2ExXCI7XG4gICAgICAgIHJlcGVhdCA9IGJvdHRvbSA9IFwiXFx1MjNhMlwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccmZsb29yXCIpIHtcbiAgICAgICAgcmVwZWF0ID0gdG9wID0gXCJcXHUyM2E1XCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjNhNlwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxccmNlaWxcIikge1xuICAgICAgICB0b3AgPSBcIlxcdTIzYTRcIjtcbiAgICAgICAgcmVwZWF0ID0gYm90dG9tID0gXCJcXHUyM2E1XCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIihcIikge1xuICAgICAgICB0b3AgPSBcIlxcdTIzOWJcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyMzljXCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjM5ZFwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCIpXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyMzllXCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjM5ZlwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTBcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHtcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbGJyYWNlXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgICAgIG1pZGRsZSA9IFwiXFx1MjNhOFwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYTlcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFx9XCIgfHwgZGVsaW0gPT09IFwiXFxcXHJicmFjZVwiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1MjNhYlwiO1xuICAgICAgICBtaWRkbGUgPSBcIlxcdTIzYWNcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXHUyM2FkXCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcbGdyb3VwXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjNhOVwiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJncm91cFwiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1MjNhYlwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYWRcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHUyM2FhXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9IGVsc2UgaWYgKGRlbGltID09PSBcIlxcXFxsbW91c3RhY2hlXCIpIHtcbiAgICAgICAgdG9wID0gXCJcXHUyM2E3XCI7XG4gICAgICAgIGJvdHRvbSA9IFwiXFx1MjNhZFwiO1xuICAgICAgICByZXBlYXQgPSBcIlxcdTIzYWFcIjtcbiAgICAgICAgZm9udCA9IFwiU2l6ZTQtUmVndWxhclwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiXFxcXHJtb3VzdGFjaGVcIikge1xuICAgICAgICB0b3AgPSBcIlxcdTIzYWJcIjtcbiAgICAgICAgYm90dG9tID0gXCJcXHUyM2E5XCI7XG4gICAgICAgIHJlcGVhdCA9IFwiXFx1MjNhYVwiO1xuICAgICAgICBmb250ID0gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCJcXFxcc3VyZFwiKSB7XG4gICAgICAgIHRvcCA9IFwiXFx1ZTAwMVwiO1xuICAgICAgICBib3R0b20gPSBcIlxcdTIzYjdcIjtcbiAgICAgICAgcmVwZWF0ID0gXCJcXHVlMDAwXCI7XG4gICAgICAgIGZvbnQgPSBcIlNpemU0LVJlZ3VsYXJcIjtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIG1ldHJpY3Mgb2YgdGhlIGZvdXIgc2VjdGlvbnNcbiAgICB2YXIgdG9wTWV0cmljcyA9IGdldE1ldHJpY3ModG9wLCBmb250KTtcbiAgICB2YXIgdG9wSGVpZ2h0VG90YWwgPSB0b3BNZXRyaWNzLmhlaWdodCArIHRvcE1ldHJpY3MuZGVwdGg7XG4gICAgdmFyIHJlcGVhdE1ldHJpY3MgPSBnZXRNZXRyaWNzKHJlcGVhdCwgZm9udCk7XG4gICAgdmFyIHJlcGVhdEhlaWdodFRvdGFsID0gcmVwZWF0TWV0cmljcy5oZWlnaHQgKyByZXBlYXRNZXRyaWNzLmRlcHRoO1xuICAgIHZhciBib3R0b21NZXRyaWNzID0gZ2V0TWV0cmljcyhib3R0b20sIGZvbnQpO1xuICAgIHZhciBib3R0b21IZWlnaHRUb3RhbCA9IGJvdHRvbU1ldHJpY3MuaGVpZ2h0ICsgYm90dG9tTWV0cmljcy5kZXB0aDtcbiAgICB2YXIgbWlkZGxlSGVpZ2h0VG90YWwgPSAwO1xuICAgIHZhciBtaWRkbGVGYWN0b3IgPSAxO1xuICAgIGlmIChtaWRkbGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIG1pZGRsZU1ldHJpY3MgPSBnZXRNZXRyaWNzKG1pZGRsZSwgZm9udCk7XG4gICAgICAgIG1pZGRsZUhlaWdodFRvdGFsID0gbWlkZGxlTWV0cmljcy5oZWlnaHQgKyBtaWRkbGVNZXRyaWNzLmRlcHRoO1xuICAgICAgICBtaWRkbGVGYWN0b3IgPSAyOyAvLyByZXBlYXQgc3ltbWV0cmljYWxseSBhYm92ZSBhbmQgYmVsb3cgbWlkZGxlXG4gICAgfVxuXG4gICAgLy8gQ2FsY3VhdGUgdGhlIG1pbmltYWwgaGVpZ2h0IHRoYXQgdGhlIGRlbGltaXRlciBjYW4gaGF2ZS5cbiAgICAvLyBJdCBpcyBhdCBsZWFzdCB0aGUgc2l6ZSBvZiB0aGUgdG9wLCBib3R0b20sIGFuZCBvcHRpb25hbCBtaWRkbGUgY29tYmluZWQuXG4gICAgdmFyIG1pbkhlaWdodCA9IHRvcEhlaWdodFRvdGFsICsgYm90dG9tSGVpZ2h0VG90YWwgKyBtaWRkbGVIZWlnaHRUb3RhbDtcblxuICAgIC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiBjb3BpZXMgb2YgdGhlIHJlcGVhdCBzeW1ib2wgd2Ugd2lsbCBuZWVkXG4gICAgdmFyIHJlcGVhdENvdW50ID0gTWF0aC5jZWlsKFxuICAgICAgICAoaGVpZ2h0VG90YWwgLSBtaW5IZWlnaHQpIC8gKG1pZGRsZUZhY3RvciAqIHJlcGVhdEhlaWdodFRvdGFsKSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGRlbGltaXRlciBpbmNsdWRpbmcgYWxsIHRoZSBzeW1ib2xzXG4gICAgdmFyIHJlYWxIZWlnaHRUb3RhbCA9XG4gICAgICAgIG1pbkhlaWdodCArIHJlcGVhdENvdW50ICogbWlkZGxlRmFjdG9yICogcmVwZWF0SGVpZ2h0VG90YWw7XG5cbiAgICAvLyBUaGUgY2VudGVyIG9mIHRoZSBkZWxpbWl0ZXIgaXMgcGxhY2VkIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGF4aXMuIE5vdGVcbiAgICAvLyB0aGF0IGluIHRoaXMgY29udGV4dCwgXCJjZW50ZXJcIiBtZWFucyB0aGF0IHRoZSBkZWxpbWl0ZXIgc2hvdWxkIGJlXG4gICAgLy8gY2VudGVyZWQgYXJvdW5kIHRoZSBheGlzIGluIHRoZSBjdXJyZW50IHN0eWxlLCB3aGlsZSBub3JtYWxseSBpdCBpc1xuICAgIC8vIGNlbnRlcmVkIGFyb3VuZCB0aGUgYXhpcyBpbiB0ZXh0c3R5bGUuXG4gICAgdmFyIGF4aXNIZWlnaHQgPSBvcHRpb25zLnN0eWxlLm1ldHJpY3MuYXhpc0hlaWdodDtcbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgIGF4aXNIZWlnaHQgKj0gb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcbiAgICB9XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXB0aFxuICAgIHZhciBkZXB0aCA9IHJlYWxIZWlnaHRUb3RhbCAvIDIgLSBheGlzSGVpZ2h0O1xuXG4gICAgLy8gTm93LCB3ZSBzdGFydCBidWlsZGluZyB0aGUgcGllY2VzIHRoYXQgd2lsbCBnbyBpbnRvIHRoZSB2bGlzdFxuXG4gICAgLy8gS2VlcCBhIGxpc3Qgb2YgdGhlIGlubmVyIHBpZWNlc1xuICAgIHZhciBpbm5lcnMgPSBbXTtcblxuICAgIC8vIEFkZCB0aGUgYm90dG9tIHN5bWJvbFxuICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcihib3R0b20sIGZvbnQsIG1vZGUpKTtcblxuICAgIHZhciBpO1xuICAgIGlmIChtaWRkbGUgPT09IG51bGwpIHtcbiAgICAgICAgLy8gQWRkIHRoYXQgbWFueSBzeW1ib2xzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXBlYXRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpbm5lcnMucHVzaChtYWtlSW5uZXIocmVwZWF0LCBmb250LCBtb2RlKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIGEgbWlkZGxlIGJpdCwgd2UgbmVlZCB0aGUgbWlkZGxlIHBhcnQgYW5kIHR3byByZXBlYXRlZFxuICAgICAgICAvLyBzZWN0aW9uc1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVwZWF0Q291bnQ7IGkrKykge1xuICAgICAgICAgICAgaW5uZXJzLnB1c2gobWFrZUlubmVyKHJlcGVhdCwgZm9udCwgbW9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcihtaWRkbGUsIGZvbnQsIG1vZGUpKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlcGVhdENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcihyZXBlYXQsIGZvbnQsIG1vZGUpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgdG9wIHN5bWJvbFxuICAgIGlubmVycy5wdXNoKG1ha2VJbm5lcih0b3AsIGZvbnQsIG1vZGUpKTtcblxuICAgIC8vIEZpbmFsbHksIGJ1aWxkIHRoZSB2bGlzdFxuICAgIHZhciBpbm5lciA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdChpbm5lcnMsIFwiYm90dG9tXCIsIGRlcHRoLCBvcHRpb25zKTtcblxuICAgIHJldHVybiBzdHlsZVdyYXAoXG4gICAgICAgIG1ha2VTcGFuKFtcImRlbGltc2l6aW5nXCIsIFwibXVsdFwiXSwgW2lubmVyXSwgb3B0aW9ucyksXG4gICAgICAgIFN0eWxlLlRFWFQsIG9wdGlvbnMsIGNsYXNzZXMpO1xufTtcblxuLy8gVGhlcmUgYXJlIHRocmVlIGtpbmRzIG9mIGRlbGltaXRlcnMsIGRlbGltaXRlcnMgdGhhdCBzdGFjayB3aGVuIHRoZXkgYmVjb21lXG4vLyB0b28gbGFyZ2VcbnZhciBzdGFja0xhcmdlRGVsaW1pdGVycyA9IFtcbiAgICBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIlxcXFxsYnJhY2tcIiwgXCJdXCIsIFwiXFxcXHJicmFja1wiLFxuICAgIFwiXFxcXHtcIiwgXCJcXFxcbGJyYWNlXCIsIFwiXFxcXH1cIiwgXCJcXFxccmJyYWNlXCIsXG4gICAgXCJcXFxcbGZsb29yXCIsIFwiXFxcXHJmbG9vclwiLCBcIlxcXFxsY2VpbFwiLCBcIlxcXFxyY2VpbFwiLFxuICAgIFwiXFxcXHN1cmRcIlxuXTtcblxuLy8gZGVsaW1pdGVycyB0aGF0IGFsd2F5cyBzdGFja1xudmFyIHN0YWNrQWx3YXlzRGVsaW1pdGVycyA9IFtcbiAgICBcIlxcXFx1cGFycm93XCIsIFwiXFxcXGRvd25hcnJvd1wiLCBcIlxcXFx1cGRvd25hcnJvd1wiLFxuICAgIFwiXFxcXFVwYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsIFwiXFxcXFVwZG93bmFycm93XCIsXG4gICAgXCJ8XCIsIFwiXFxcXHxcIiwgXCJcXFxcdmVydFwiLCBcIlxcXFxWZXJ0XCIsXG4gICAgXCJcXFxcbHZlcnRcIiwgXCJcXFxccnZlcnRcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIixcbiAgICBcIlxcXFxsZ3JvdXBcIiwgXCJcXFxccmdyb3VwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgXCJcXFxccm1vdXN0YWNoZVwiXG5dO1xuXG4vLyBhbmQgZGVsaW1pdGVycyB0aGF0IG5ldmVyIHN0YWNrXG52YXIgc3RhY2tOZXZlckRlbGltaXRlcnMgPSBbXG4gICAgXCI8XCIsIFwiPlwiLCBcIlxcXFxsYW5nbGVcIiwgXCJcXFxccmFuZ2xlXCIsIFwiL1wiLCBcIlxcXFxiYWNrc2xhc2hcIiwgXCJcXFxcbHRcIiwgXCJcXFxcZ3RcIlxuXTtcblxuLy8gTWV0cmljcyBvZiB0aGUgZGlmZmVyZW50IHNpemVzLiBGb3VuZCBieSBsb29raW5nIGF0IFRlWCdzIG91dHB1dCBvZlxuLy8gJFxcYmlnbHwgLy8gXFxCaWdsfCBcXGJpZ2dsfCBcXEJpZ2dsfCBcXHNob3dsaXN0cyRcbi8vIFVzZWQgdG8gY3JlYXRlIHN0YWNrZWQgZGVsaW1pdGVycyBvZiBhcHByb3ByaWF0ZSBzaXplcyBpbiBtYWtlU2l6ZWREZWxpbS5cbnZhciBzaXplVG9NYXhIZWlnaHQgPSBbMCwgMS4yLCAxLjgsIDIuNCwgMy4wXTtcblxuLyoqXG4gKiBVc2VkIHRvIGNyZWF0ZSBhIGRlbGltaXRlciBvZiBhIHNwZWNpZmljIHNpemUsIHdoZXJlIGBzaXplYCBpcyAxLCAyLCAzLCBvciA0LlxuICovXG52YXIgbWFrZVNpemVkRGVsaW0gPSBmdW5jdGlvbihkZWxpbSwgc2l6ZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcykge1xuICAgIC8vIDwgYW5kID4gdHVybiBpbnRvIFxcbGFuZ2xlIGFuZCBcXHJhbmdsZSBpbiBkZWxpbWl0ZXJzXG4gICAgaWYgKGRlbGltID09PSBcIjxcIiB8fCBkZWxpbSA9PT0gXCJcXFxcbHRcIikge1xuICAgICAgICBkZWxpbSA9IFwiXFxcXGxhbmdsZVwiO1xuICAgIH0gZWxzZSBpZiAoZGVsaW0gPT09IFwiPlwiIHx8IGRlbGltID09PSBcIlxcXFxndFwiKSB7XG4gICAgICAgIGRlbGltID0gXCJcXFxccmFuZ2xlXCI7XG4gICAgfVxuXG4gICAgLy8gU2l6ZWQgZGVsaW1pdGVycyBhcmUgbmV2ZXIgY2VudGVyZWQuXG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrTGFyZ2VEZWxpbWl0ZXJzLCBkZWxpbSkgfHxcbiAgICAgICAgdXRpbHMuY29udGFpbnMoc3RhY2tOZXZlckRlbGltaXRlcnMsIGRlbGltKSkge1xuICAgICAgICByZXR1cm4gbWFrZUxhcmdlRGVsaW0oZGVsaW0sIHNpemUsIGZhbHNlLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgICB9IGVsc2UgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrQWx3YXlzRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgICAgIHJldHVybiBtYWtlU3RhY2tlZERlbGltKFxuICAgICAgICAgICAgZGVsaW0sIHNpemVUb01heEhlaWdodFtzaXplXSwgZmFsc2UsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKFwiSWxsZWdhbCBkZWxpbWl0ZXI6ICdcIiArIGRlbGltICsgXCInXCIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhlcmUgYXJlIHRocmVlIGRpZmZlcmVudCBzZXF1ZW5jZXMgb2YgZGVsaW1pdGVyIHNpemVzIHRoYXQgdGhlIGRlbGltaXRlcnNcbiAqIGZvbGxvdyBkZXBlbmRpbmcgb24gdGhlIGtpbmQgb2YgZGVsaW1pdGVyLiBUaGlzIGlzIHVzZWQgd2hlbiBjcmVhdGluZyBjdXN0b21cbiAqIHNpemVkIGRlbGltaXRlcnMgdG8gZGVjaWRlIHdoZXRoZXIgdG8gY3JlYXRlIGEgc21hbGwsIGxhcmdlLCBvciBzdGFja2VkXG4gKiBkZWxpbWl0ZXIuXG4gKlxuICogSW4gcmVhbCBUZVgsIHRoZXNlIHNlcXVlbmNlcyBhcmVuJ3QgZXhwbGljaXRseSBkZWZpbmVkLCBidXQgYXJlIGluc3RlYWRcbiAqIGRlZmluZWQgaW5zaWRlIHRoZSBmb250IG1ldHJpY3MuIFNpbmNlIHRoZXJlIGFyZSBvbmx5IHRocmVlIHNlcXVlbmNlcyB0aGF0XG4gKiBhcmUgcG9zc2libGUgZm9yIHRoZSBkZWxpbWl0ZXJzIHRoYXQgVGVYIGRlZmluZXMsIGl0IGlzIGVhc2llciB0byBqdXN0IGVuY29kZVxuICogdGhlbSBleHBsaWNpdGx5IGhlcmUuXG4gKi9cblxuLy8gRGVsaW1pdGVycyB0aGF0IG5ldmVyIHN0YWNrIHRyeSBzbWFsbCBkZWxpbWl0ZXJzIGFuZCBsYXJnZSBkZWxpbWl0ZXJzIG9ubHlcbnZhciBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2UgPSBbXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVFNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlRFWFR9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDF9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDJ9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDN9LFxuICAgIHt0eXBlOiBcImxhcmdlXCIsIHNpemU6IDR9XG5dO1xuXG4vLyBEZWxpbWl0ZXJzIHRoYXQgYWx3YXlzIHN0YWNrIHRyeSB0aGUgc21hbGwgZGVsaW1pdGVycyBmaXJzdCwgdGhlbiBzdGFja1xudmFyIHN0YWNrQWx3YXlzRGVsaW1pdGVyU2VxdWVuY2UgPSBbXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVFNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlNDUklQVH0sXG4gICAge3R5cGU6IFwic21hbGxcIiwgc3R5bGU6IFN0eWxlLlRFWFR9LFxuICAgIHt0eXBlOiBcInN0YWNrXCJ9XG5dO1xuXG4vLyBEZWxpbWl0ZXJzIHRoYXQgc3RhY2sgd2hlbiBsYXJnZSB0cnkgdGhlIHNtYWxsIGFuZCB0aGVuIGxhcmdlIGRlbGltaXRlcnMsIGFuZFxuLy8gc3RhY2sgYWZ0ZXJ3YXJkc1xudmFyIHN0YWNrTGFyZ2VEZWxpbWl0ZXJTZXF1ZW5jZSA9IFtcbiAgICB7dHlwZTogXCJzbWFsbFwiLCBzdHlsZTogU3R5bGUuU0NSSVBUU0NSSVBUfSxcbiAgICB7dHlwZTogXCJzbWFsbFwiLCBzdHlsZTogU3R5bGUuU0NSSVBUfSxcbiAgICB7dHlwZTogXCJzbWFsbFwiLCBzdHlsZTogU3R5bGUuVEVYVH0sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogMX0sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogMn0sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogM30sXG4gICAge3R5cGU6IFwibGFyZ2VcIiwgc2l6ZTogNH0sXG4gICAge3R5cGU6IFwic3RhY2tcIn1cbl07XG5cbi8qKlxuICogR2V0IHRoZSBmb250IHVzZWQgaW4gYSBkZWxpbWl0ZXIgYmFzZWQgb24gd2hhdCBraW5kIG9mIGRlbGltaXRlciBpdCBpcy5cbiAqL1xudmFyIGRlbGltVHlwZVRvRm9udCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBpZiAodHlwZS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiTWFpbi1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgICAgICByZXR1cm4gXCJTaXplXCIgKyB0eXBlLnNpemUgKyBcIi1SZWd1bGFyXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlLnR5cGUgPT09IFwic3RhY2tcIikge1xuICAgICAgICByZXR1cm4gXCJTaXplNC1SZWd1bGFyXCI7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmF2ZXJzZSBhIHNlcXVlbmNlIG9mIHR5cGVzIG9mIGRlbGltaXRlcnMgdG8gZGVjaWRlIHdoYXQga2luZCBvZiBkZWxpbWl0ZXJcbiAqIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBhIGRlbGltaXRlciBvZiB0aGUgZ2l2ZW4gaGVpZ2h0K2RlcHRoLlxuICovXG52YXIgdHJhdmVyc2VTZXF1ZW5jZSA9IGZ1bmN0aW9uKGRlbGltLCBoZWlnaHQsIHNlcXVlbmNlLCBvcHRpb25zKSB7XG4gICAgLy8gSGVyZSwgd2UgY2hvb3NlIHRoZSBpbmRleCB3ZSBzaG91bGQgc3RhcnQgYXQgaW4gdGhlIHNlcXVlbmNlcy4gSW4gc21hbGxlclxuICAgIC8vIHNpemVzICh3aGljaCBjb3JyZXNwb25kIHRvIGxhcmdlciBudW1iZXJzIGluIHN0eWxlLnNpemUpIHdlIHN0YXJ0IGVhcmxpZXJcbiAgICAvLyBpbiB0aGUgc2VxdWVuY2UuIFRodXMsIHNjcmlwdHNjcmlwdCBzdGFydHMgYXQgaW5kZXggMy0zPTAsIHNjcmlwdCBzdGFydHNcbiAgICAvLyBhdCBpbmRleCAzLTI9MSwgdGV4dCBzdGFydHMgYXQgMy0xPTIsIGFuZCBkaXNwbGF5IHN0YXJ0cyBhdCBtaW4oMiwzLTApPTJcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1pbigyLCAzIC0gb3B0aW9ucy5zdHlsZS5zaXplKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc2VxdWVuY2VbaV0udHlwZSA9PT0gXCJzdGFja1wiKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGFsd2F5cyB0aGUgbGFzdCBkZWxpbWl0ZXIsIHNvIHdlIGp1c3QgYnJlYWsgdGhlIGxvb3Agbm93LlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWV0cmljcyA9IGdldE1ldHJpY3MoZGVsaW0sIGRlbGltVHlwZVRvRm9udChzZXF1ZW5jZVtpXSkpO1xuICAgICAgICB2YXIgaGVpZ2h0RGVwdGggPSBtZXRyaWNzLmhlaWdodCArIG1ldHJpY3MuZGVwdGg7XG5cbiAgICAgICAgLy8gU21hbGwgZGVsaW1pdGVycyBhcmUgc2NhbGVkIGRvd24gdmVyc2lvbnMgb2YgdGhlIHNhbWUgZm9udCwgc28gd2VcbiAgICAgICAgLy8gYWNjb3VudCBmb3IgdGhlIHN0eWxlIGNoYW5nZSBzaXplLlxuXG4gICAgICAgIGlmIChzZXF1ZW5jZVtpXS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgICAgICAgIGhlaWdodERlcHRoICo9IHNlcXVlbmNlW2ldLnN0eWxlLnNpemVNdWx0aXBsaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGRlbGltaXRlciBhdCB0aGlzIHNpemUgd29ya3MgZm9yIHRoZSBnaXZlbiBoZWlnaHQuXG4gICAgICAgIGlmIChoZWlnaHREZXB0aCA+IGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbmNlW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgcmV0dXJuIHRoZSBsYXN0IHNlcXVlbmNlIGVsZW1lbnQuXG4gICAgcmV0dXJuIHNlcXVlbmNlW3NlcXVlbmNlLmxlbmd0aCAtIDFdO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgZGVsaW1pdGVyIG9mIGEgZ2l2ZW4gaGVpZ2h0K2RlcHRoLCB3aXRoIG9wdGlvbmFsIGNlbnRlcmluZy4gSGVyZSwgd2VcbiAqIHRyYXZlcnNlIHRoZSBzZXF1ZW5jZXMsIGFuZCBjcmVhdGUgYSBkZWxpbWl0ZXIgdGhhdCB0aGUgc2VxdWVuY2UgdGVsbHMgdXMgdG8uXG4gKi9cbnZhciBtYWtlQ3VzdG9tU2l6ZWREZWxpbSA9IGZ1bmN0aW9uKGRlbGltLCBoZWlnaHQsIGNlbnRlciwgb3B0aW9ucywgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpIHtcbiAgICBpZiAoZGVsaW0gPT09IFwiPFwiIHx8IGRlbGltID09PSBcIlxcXFxsdFwiKSB7XG4gICAgICAgIGRlbGltID0gXCJcXFxcbGFuZ2xlXCI7XG4gICAgfSBlbHNlIGlmIChkZWxpbSA9PT0gXCI+XCIgfHwgZGVsaW0gPT09IFwiXFxcXGd0XCIpIHtcbiAgICAgICAgZGVsaW0gPSBcIlxcXFxyYW5nbGVcIjtcbiAgICB9XG5cbiAgICAvLyBEZWNpZGUgd2hhdCBzZXF1ZW5jZSB0byB1c2VcbiAgICB2YXIgc2VxdWVuY2U7XG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrTmV2ZXJEZWxpbWl0ZXJzLCBkZWxpbSkpIHtcbiAgICAgICAgc2VxdWVuY2UgPSBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2U7XG4gICAgfSBlbHNlIGlmICh1dGlscy5jb250YWlucyhzdGFja0xhcmdlRGVsaW1pdGVycywgZGVsaW0pKSB7XG4gICAgICAgIHNlcXVlbmNlID0gc3RhY2tMYXJnZURlbGltaXRlclNlcXVlbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcXVlbmNlID0gc3RhY2tBbHdheXNEZWxpbWl0ZXJTZXF1ZW5jZTtcbiAgICB9XG5cbiAgICAvLyBMb29rIHRocm91Z2ggdGhlIHNlcXVlbmNlXG4gICAgdmFyIGRlbGltVHlwZSA9IHRyYXZlcnNlU2VxdWVuY2UoZGVsaW0sIGhlaWdodCwgc2VxdWVuY2UsIG9wdGlvbnMpO1xuXG4gICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBzZXF1ZW5jZSBlbGVtZW50IHdlIGRlY2lkZWQgb24sIGNhbGwgdGhlIGFwcHJvcHJpYXRlXG4gICAgLy8gZnVuY3Rpb24uXG4gICAgaWYgKGRlbGltVHlwZS50eXBlID09PSBcInNtYWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTbWFsbERlbGltKGRlbGltLCBkZWxpbVR5cGUuc3R5bGUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpO1xuICAgIH0gZWxzZSBpZiAoZGVsaW1UeXBlLnR5cGUgPT09IFwibGFyZ2VcIikge1xuICAgICAgICByZXR1cm4gbWFrZUxhcmdlRGVsaW0oZGVsaW0sIGRlbGltVHlwZS5zaXplLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzKTtcbiAgICB9IGVsc2UgaWYgKGRlbGltVHlwZS50eXBlID09PSBcInN0YWNrXCIpIHtcbiAgICAgICAgcmV0dXJuIG1ha2VTdGFja2VkRGVsaW0oZGVsaW0sIGhlaWdodCwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIE1ha2UgYSBkZWxpbWl0ZXIgZm9yIHVzZSB3aXRoIGBcXGxlZnRgIGFuZCBgXFxyaWdodGAsIGdpdmVuIGEgaGVpZ2h0IGFuZCBkZXB0aFxuICogb2YgYW4gZXhwcmVzc2lvbiB0aGF0IHRoZSBkZWxpbWl0ZXJzIHN1cnJvdW5kLlxuICovXG52YXIgbWFrZUxlZnRSaWdodERlbGltID0gZnVuY3Rpb24oZGVsaW0sIGhlaWdodCwgZGVwdGgsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcykge1xuICAgIC8vIFdlIGFsd2F5cyBjZW50ZXIgXFxsZWZ0L1xccmlnaHQgZGVsaW1pdGVycywgc28gdGhlIGF4aXMgaXMgYWx3YXlzIHNoaWZ0ZWRcbiAgICB2YXIgYXhpc0hlaWdodCA9XG4gICAgICAgIG9wdGlvbnMuc3R5bGUubWV0cmljcy5heGlzSGVpZ2h0ICogb3B0aW9ucy5zdHlsZS5zaXplTXVsdGlwbGllcjtcblxuICAgIC8vIFRha2VuIGZyb20gVGVYIHNvdXJjZSwgdGV4LndlYiwgZnVuY3Rpb24gbWFrZV9sZWZ0X3JpZ2h0XG4gICAgdmFyIGRlbGltaXRlckZhY3RvciA9IDkwMTtcbiAgICB2YXIgZGVsaW1pdGVyRXh0ZW5kID0gNS4wIC8gZm9udE1ldHJpY3MubWV0cmljcy5wdFBlckVtO1xuXG4gICAgdmFyIG1heERpc3RGcm9tQXhpcyA9IE1hdGgubWF4KFxuICAgICAgICBoZWlnaHQgLSBheGlzSGVpZ2h0LCBkZXB0aCArIGF4aXNIZWlnaHQpO1xuXG4gICAgdmFyIHRvdGFsSGVpZ2h0ID0gTWF0aC5tYXgoXG4gICAgICAgIC8vIEluIHJlYWwgVGVYLCBjYWxjdWxhdGlvbnMgYXJlIGRvbmUgdXNpbmcgaW50ZWdyYWwgdmFsdWVzIHdoaWNoIGFyZVxuICAgICAgICAvLyA2NTUzNiBwZXIgcHQsIG9yIDY1NTM2MCBwZXIgZW0uIFNvLCB0aGUgZGl2aXNpb24gaGVyZSB0cnVuY2F0ZXMgaW5cbiAgICAgICAgLy8gVGVYIGJ1dCBkb2Vzbid0IGhlcmUsIHByb2R1Y2luZyBkaWZmZXJlbnQgcmVzdWx0cy4gSWYgd2Ugd2FudGVkIHRvXG4gICAgICAgIC8vIGV4YWN0bHkgbWF0Y2ggVGVYJ3MgY2FsY3VsYXRpb24sIHdlIGNvdWxkIGRvXG4gICAgICAgIC8vICAgTWF0aC5mbG9vcig2NTUzNjAgKiBtYXhEaXN0RnJvbUF4aXMgLyA1MDApICpcbiAgICAgICAgLy8gICAgZGVsaW1pdGVyRmFjdG9yIC8gNjU1MzYwXG4gICAgICAgIC8vIChUbyBzZWUgdGhlIGRpZmZlcmVuY2UsIGNvbXBhcmVcbiAgICAgICAgLy8gICAgeF57eF57XFxsZWZ0KFxccnVsZXswLjFlbX17MC42OGVtfVxccmlnaHQpfX1cbiAgICAgICAgLy8gaW4gVGVYIGFuZCBLYVRlWClcbiAgICAgICAgbWF4RGlzdEZyb21BeGlzIC8gNTAwICogZGVsaW1pdGVyRmFjdG9yLFxuICAgICAgICAyICogbWF4RGlzdEZyb21BeGlzIC0gZGVsaW1pdGVyRXh0ZW5kKTtcblxuICAgIC8vIEZpbmFsbHksIHdlIGRlZmVyIHRvIGBtYWtlQ3VzdG9tU2l6ZWREZWxpbWAgd2l0aCBvdXIgY2FsY3VsYXRlZCB0b3RhbFxuICAgIC8vIGhlaWdodFxuICAgIHJldHVybiBtYWtlQ3VzdG9tU2l6ZWREZWxpbShkZWxpbSwgdG90YWxIZWlnaHQsIHRydWUsIG9wdGlvbnMsIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2l6ZWREZWxpbTogbWFrZVNpemVkRGVsaW0sXG4gICAgY3VzdG9tU2l6ZWREZWxpbTogbWFrZUN1c3RvbVNpemVkRGVsaW0sXG4gICAgbGVmdFJpZ2h0RGVsaW06IG1ha2VMZWZ0UmlnaHREZWxpbVxufTtcbiIsIi8qKlxuICogVGhlc2Ugb2JqZWN0cyBzdG9yZSB0aGUgZGF0YSBhYm91dCB0aGUgRE9NIG5vZGVzIHdlIGNyZWF0ZSwgYXMgd2VsbCBhcyBzb21lXG4gKiBleHRyYSBkYXRhLiBUaGV5IGNhbiB0aGVuIGJlIHRyYW5zZm9ybWVkIGludG8gcmVhbCBET00gbm9kZXMgd2l0aCB0aGVcbiAqIGB0b05vZGVgIGZ1bmN0aW9uIG9yIEhUTUwgbWFya3VwIHVzaW5nIGB0b01hcmt1cGAuIFRoZXkgYXJlIHVzZWZ1bCBmb3IgYm90aFxuICogc3RvcmluZyBleHRyYSBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlcywgYXMgd2VsbCBhcyBwcm92aWRpbmcgYSB3YXkgdG8gZWFzaWx5XG4gKiB3b3JrIHdpdGggdGhlIERPTS5cbiAqXG4gKiBTaW1pbGFyIGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIE1hdGhNTCBub2RlcyBleGlzdCBpbiBtYXRoTUxUcmVlLmpzLlxuICovXG52YXIgdW5pY29kZVJlZ2V4ZXMgPSByZXF1aXJlKFwiLi91bmljb2RlUmVnZXhlc1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBIVE1MIGNsYXNzTmFtZSBiYXNlZCBvbiBhIGxpc3Qgb2YgY2xhc3Nlcy4gSW4gYWRkaXRpb24gdG8gam9pbmluZ1xuICogd2l0aCBzcGFjZXMsIHdlIGFsc28gcmVtb3ZlIG51bGwgb3IgZW1wdHkgY2xhc3Nlcy5cbiAqL1xudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24oY2xhc3Nlcykge1xuICAgIGNsYXNzZXMgPSBjbGFzc2VzLnNsaWNlKCk7XG4gICAgZm9yICh2YXIgaSA9IGNsYXNzZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKCFjbGFzc2VzW2ldKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbGFzc2VzLmpvaW4oXCIgXCIpO1xufTtcblxuLyoqXG4gKiBUaGlzIG5vZGUgcmVwcmVzZW50cyBhIHNwYW4gbm9kZSwgd2l0aCBhIGNsYXNzTmFtZSwgYSBsaXN0IG9mIGNoaWxkcmVuLCBhbmRcbiAqIGFuIGlubGluZSBzdHlsZS4gSXQgYWxzbyBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCBpdHMgaGVpZ2h0LCBkZXB0aCwgYW5kXG4gKiBtYXhGb250U2l6ZS5cbiAqL1xuZnVuY3Rpb24gc3BhbihjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmRlcHRoID0gMDtcbiAgICB0aGlzLm1heEZvbnRTaXplID0gMDtcbiAgICB0aGlzLnN0eWxlID0ge307XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3R5bGUuaXNUaWdodCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMucHVzaChcIm10aWdodFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5nZXRDb2xvcigpKSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLmNvbG9yID0gb3B0aW9ucy5nZXRDb2xvcigpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFNldHMgYW4gYXJiaXRyYXJ5IGF0dHJpYnV0ZSBvbiB0aGUgc3Bhbi4gV2FybmluZzogdXNlIHRoaXMgd2lzZWx5LiBOb3QgYWxsXG4gKiBicm93c2VycyBzdXBwb3J0IGF0dHJpYnV0ZXMgdGhlIHNhbWUsIGFuZCBoYXZpbmcgdG9vIG1hbnkgY3VzdG9tIGF0dHJpYnV0ZXNcbiAqIGlzIHByb2JhYmx5IGJhZC5cbiAqL1xuc3Bhbi5wcm90b3R5cGUuc2V0QXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWU7XG59O1xuXG5zcGFuLnByb3RvdHlwZS50cnlDb21iaW5lID0gZnVuY3Rpb24oc2libGluZykge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgc3BhbiBpbnRvIGFuIEhUTUwgbm9kZVxuICovXG5zcGFuLnByb3RvdHlwZS50b05vZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgLy8gQXBwbHkgdGhlIGNsYXNzXG4gICAgc3Bhbi5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpO1xuXG4gICAgLy8gQXBwbHkgaW5saW5lIHN0eWxlc1xuICAgIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnN0eWxlLCBzdHlsZSkpIHtcbiAgICAgICAgICAgIHNwYW4uc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBhdHRyaWJ1dGVzXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIHRoZSBjaGlsZHJlbiwgYWxzbyBhcyBIVE1MIG5vZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwYW47XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIHNwYW4gaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmdcbiAqL1xuc3Bhbi5wcm90b3R5cGUudG9NYXJrdXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWFya3VwID0gXCI8c3BhblwiO1xuXG4gICAgLy8gQWRkIHRoZSBjbGFzc1xuICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIiBjbGFzcz1cXFwiXCI7XG4gICAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUoY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSk7XG4gICAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGVzID0gXCJcIjtcblxuICAgIC8vIEFkZCB0aGUgc3R5bGVzLCBhZnRlciBoeXBoZW5hdGlvblxuICAgIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGUpKSB7XG4gICAgICAgICAgICBzdHlsZXMgKz0gdXRpbHMuaHlwaGVuYXRlKHN0eWxlKSArIFwiOlwiICsgdGhpcy5zdHlsZVtzdHlsZV0gKyBcIjtcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdHlsZXMpIHtcbiAgICAgICAgbWFya3VwICs9IFwiIHN0eWxlPVxcXCJcIiArIHV0aWxzLmVzY2FwZShzdHlsZXMpICsgXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBhdHRyaWJ1dGVzXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgICAgICBtYXJrdXAgKz0gXCIgXCIgKyBhdHRyICsgXCI9XFxcIlwiO1xuICAgICAgICAgICAgbWFya3VwICs9IHV0aWxzLmVzY2FwZSh0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICAgICAgbWFya3VwICs9IFwiXFxcIlwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbWFya3VwICs9IFwiPlwiO1xuXG4gICAgLy8gQWRkIHRoZSBtYXJrdXAgb2YgdGhlIGNoaWxkcmVuLCBhbHNvIGFzIG1hcmt1cFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIjwvc3Bhbj5cIjtcblxuICAgIHJldHVybiBtYXJrdXA7XG59O1xuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgZG9jdW1lbnQgZnJhZ21lbnQsIHdoaWNoIGNvbnRhaW5zIGVsZW1lbnRzLCBidXQgd2hlblxuICogcGxhY2VkIGludG8gdGhlIERPTSBkb2Vzbid0IGhhdmUgYW55IHJlcHJlc2VudGF0aW9uIGl0c2VsZi4gVGh1cywgaXQgb25seVxuICogY29udGFpbnMgY2hpbGRyZW4gYW5kIGRvZXNuJ3QgaGF2ZSBhbnkgSFRNTCBwcm9wZXJ0aWVzLiBJdCBhbHNvIGtlZXBzIHRyYWNrXG4gKiBvZiBhIGhlaWdodCwgZGVwdGgsIGFuZCBtYXhGb250U2l6ZS5cbiAqL1xuZnVuY3Rpb24gZG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbikge1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbiAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5kZXB0aCA9IDA7XG4gICAgdGhpcy5tYXhGb250U2l6ZSA9IDA7XG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBhIG5vZGVcbiAqL1xuZG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUudG9Ob2RlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gQ3JlYXRlIGEgZnJhZ21lbnRcbiAgICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIC8vIEFwcGVuZCB0aGUgY2hpbGRyZW5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZnJhZy5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJhZztcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZnJhZ21lbnQgaW50byBIVE1MIG1hcmt1cFxuICovXG5kb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS50b01hcmt1cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIlwiO1xuXG4gICAgLy8gU2ltcGx5IGNvbmNhdGVuYXRlIHRoZSBtYXJrdXAgZm9yIHRoZSBjaGlsZHJlbiB0b2dldGhlclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXJrdXA7XG59O1xuXG52YXIgaUNvbWJpbmF0aW9ucyA9IHtcbiAgICAnw64nOiAnXFx1MDEzMVxcdTAzMDInLFxuICAgICfDryc6ICdcXHUwMTMxXFx1MDMwOCcsXG4gICAgJ8OtJzogJ1xcdTAxMzFcXHUwMzAxJyxcbiAgICAvLyAnxKsnOiAnXFx1MDEzMVxcdTAzMDQnLCAvLyBlbmFibGUgd2hlbiB3ZSBhZGQgRXh0ZW5kZWQgTGF0aW5cbiAgICAnw6wnOiAnXFx1MDEzMVxcdTAzMDAnXG59O1xuXG4vKipcbiAqIEEgc3ltYm9sIG5vZGUgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgYSBzaW5nbGUgc3ltYm9sLiBJdCBlaXRoZXIgcmVuZGVyc1xuICogdG8gYSBzaW5nbGUgdGV4dCBub2RlLCBvciBhIHNwYW4gd2l0aCBhIHNpbmdsZSB0ZXh0IG5vZGUgaW4gaXQsIGRlcGVuZGluZyBvblxuICogd2hldGhlciBpdCBoYXMgQ1NTIGNsYXNzZXMsIHN0eWxlcywgb3IgbmVlZHMgaXRhbGljIGNvcnJlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHN5bWJvbE5vZGUodmFsdWUsIGhlaWdodCwgZGVwdGgsIGl0YWxpYywgc2tldywgY2xhc3Nlcywgc3R5bGUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWUgfHwgXCJcIjtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwO1xuICAgIHRoaXMuZGVwdGggPSBkZXB0aCB8fCAwO1xuICAgIHRoaXMuaXRhbGljID0gaXRhbGljIHx8IDA7XG4gICAgdGhpcy5za2V3ID0gc2tldyB8fCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IGNsYXNzZXMgfHwgW107XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9O1xuICAgIHRoaXMubWF4Rm9udFNpemUgPSAwO1xuXG4gICAgLy8gTWFyayBDSksgY2hhcmFjdGVycyB3aXRoIHNwZWNpZmljIGNsYXNzZXMgc28gdGhhdCB3ZSBjYW4gc3BlY2lmeSB3aGljaFxuICAgIC8vIGZvbnRzIHRvIHVzZS4gIFRoaXMgYWxsb3dzIHVzIHRvIHJlbmRlciB0aGVzZSBjaGFyYWN0ZXJzIHdpdGggYSBzZXJpZlxuICAgIC8vIGZvbnQgaW4gc2l0dWF0aW9ucyB3aGVyZSB0aGUgYnJvd3NlciB3b3VsZCBlaXRoZXIgZGVmYXVsdCB0byBhIHNhbnMgc2VyaWZcbiAgICAvLyBvciByZW5kZXIgYSBwbGFjZWhvbGRlciBjaGFyYWN0ZXIuXG4gICAgaWYgKHVuaWNvZGVSZWdleGVzLmNqa1JlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgIC8vIEkgY291bGRuJ3QgZmluZCBhbnkgZm9udHMgdGhhdCBjb250YWluZWQgSGFuZ3VsIGFzIHdlbGwgYXMgYWxsIG9mXG4gICAgICAgIC8vIHRoZSBvdGhlciBjaGFyYWN0ZXJzIHdlIHdhbnRlZCB0byB0ZXN0IHRoZXJlIGZvciBpdCBnZXRzIGl0cyBvd25cbiAgICAgICAgLy8gQ1NTIGNsYXNzLlxuICAgICAgICBpZiAodW5pY29kZVJlZ2V4ZXMuaGFuZ3VsUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKCdoYW5ndWxfZmFsbGJhY2snKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKCdjamtfZmFsbGJhY2snKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICgvW8Ouw6/DrcOsXS8udGVzdCh0aGlzLnZhbHVlKSkgeyAgICAvLyBhZGQgxKsgd2hlbiB3ZSBhZGQgRXh0ZW5kZWQgTGF0aW5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGlDb21iaW5hdGlvbnNbdGhpcy52YWx1ZV07XG4gICAgfVxufVxuXG5zeW1ib2xOb2RlLnByb3RvdHlwZS50cnlDb21iaW5lID0gZnVuY3Rpb24oc2libGluZykge1xuICAgIGlmICghc2libGluZ1xuICAgICAgICB8fCAhKHNpYmxpbmcgaW5zdGFuY2VvZiBzeW1ib2xOb2RlKVxuICAgICAgICB8fCB0aGlzLml0YWxpYyA+IDBcbiAgICAgICAgfHwgY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKSAhPT0gY3JlYXRlQ2xhc3Moc2libGluZy5jbGFzc2VzKVxuICAgICAgICB8fCB0aGlzLnNrZXcgIT09IHNpYmxpbmcuc2tld1xuICAgICAgICB8fCB0aGlzLm1heEZvbnRTaXplICE9PSBzaWJsaW5nLm1heEZvbnRTaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSlcbiAgICAgICAgICAgICYmIHRoaXMuc3R5bGVbc3R5bGVdICE9PSBzaWJsaW5nLnN0eWxlW3N0eWxlXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoc3R5bGUgaW4gc2libGluZy5zdHlsZSkge1xuICAgICAgICBpZiAoc2libGluZy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSlcbiAgICAgICAgICAgICYmIHRoaXMuc3R5bGVbc3R5bGVdICE9PSBzaWJsaW5nLnN0eWxlW3N0eWxlXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMudmFsdWUgKz0gc2libGluZy52YWx1ZTtcbiAgICB0aGlzLmhlaWdodCA9IE1hdGgubWF4KHRoaXMuaGVpZ2h0LCBzaWJsaW5nLmhlaWdodCk7XG4gICAgdGhpcy5kZXB0aCA9IE1hdGgubWF4KHRoaXMuZGVwdGgsIHNpYmxpbmcuZGVwdGgpO1xuICAgIHRoaXMuaXRhbGljID0gc2libGluZy5pdGFsaWM7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0ZXh0IG5vZGUgb3Igc3BhbiBmcm9tIGEgc3ltYm9sIG5vZGUuIE5vdGUgdGhhdCBhIHNwYW4gaXMgb25seVxuICogY3JlYXRlZCBpZiBpdCBpcyBuZWVkZWQuXG4gKi9cbnN5bWJvbE5vZGUucHJvdG90eXBlLnRvTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy52YWx1ZSk7XG4gICAgdmFyIHNwYW4gPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuaXRhbGljID4gMCkge1xuICAgICAgICBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4uc3R5bGUubWFyZ2luUmlnaHQgPSB0aGlzLml0YWxpYyArIFwiZW1cIjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIHNwYW4uY2xhc3NOYW1lID0gY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkge1xuICAgICAgICAgICAgc3BhbiA9IHNwYW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICBzcGFuLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNwYW4pIHtcbiAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChub2RlKTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBzeW1ib2wgbm9kZS5cbiAqL1xuc3ltYm9sTm9kZS5wcm90b3R5cGUudG9NYXJrdXAgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBUT0RPKGFscGVydCk6IE1vcmUgZHVwbGljYXRpb24gdGhhbiBJJ2QgbGlrZSBmcm9tXG4gICAgLy8gc3Bhbi5wcm90b3R5cGUudG9NYXJrdXAgYW5kIHN5bWJvbE5vZGUucHJvdG90eXBlLnRvTm9kZS4uLlxuICAgIHZhciBuZWVkc1NwYW4gPSBmYWxzZTtcblxuICAgIHZhciBtYXJrdXAgPSBcIjxzcGFuXCI7XG5cbiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICBuZWVkc1NwYW4gPSB0cnVlO1xuICAgICAgICBtYXJrdXAgKz0gXCIgY2xhc3M9XFxcIlwiO1xuICAgICAgICBtYXJrdXAgKz0gdXRpbHMuZXNjYXBlKGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3NlcykpO1xuICAgICAgICBtYXJrdXAgKz0gXCJcXFwiXCI7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlcyA9IFwiXCI7XG5cbiAgICBpZiAodGhpcy5pdGFsaWMgPiAwKSB7XG4gICAgICAgIHN0eWxlcyArPSBcIm1hcmdpbi1yaWdodDpcIiArIHRoaXMuaXRhbGljICsgXCJlbTtcIjtcbiAgICB9XG4gICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkge1xuICAgICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSB1dGlscy5oeXBoZW5hdGUoc3R5bGUpICsgXCI6XCIgKyB0aGlzLnN0eWxlW3N0eWxlXSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgICBuZWVkc1NwYW4gPSB0cnVlO1xuICAgICAgICBtYXJrdXAgKz0gXCIgc3R5bGU9XFxcIlwiICsgdXRpbHMuZXNjYXBlKHN0eWxlcykgKyBcIlxcXCJcIjtcbiAgICB9XG5cbiAgICB2YXIgZXNjYXBlZCA9IHV0aWxzLmVzY2FwZSh0aGlzLnZhbHVlKTtcbiAgICBpZiAobmVlZHNTcGFuKSB7XG4gICAgICAgIG1hcmt1cCArPSBcIj5cIjtcbiAgICAgICAgbWFya3VwICs9IGVzY2FwZWQ7XG4gICAgICAgIG1hcmt1cCArPSBcIjwvc3Bhbj5cIjtcbiAgICAgICAgcmV0dXJuIG1hcmt1cDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZXNjYXBlZDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzcGFuOiBzcGFuLFxuICAgIGRvY3VtZW50RnJhZ21lbnQ6IGRvY3VtZW50RnJhZ21lbnQsXG4gICAgc3ltYm9sTm9kZTogc3ltYm9sTm9kZVxufTtcbiIsIi8qIGVzbGludCBuby1jb25zdGFudC1jb25kaXRpb246MCAqL1xudmFyIHBhcnNlRGF0YSA9IHJlcXVpcmUoXCIuL3BhcnNlRGF0YVwiKTtcbnZhciBQYXJzZUVycm9yID0gcmVxdWlyZShcIi4vUGFyc2VFcnJvclwiKTtcbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuL1N0eWxlXCIpO1xuXG52YXIgUGFyc2VOb2RlID0gcGFyc2VEYXRhLlBhcnNlTm9kZTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgYm9keSBvZiB0aGUgZW52aXJvbm1lbnQsIHdpdGggcm93cyBkZWxpbWl0ZWQgYnkgXFxcXCBhbmRcbiAqIGNvbHVtbnMgZGVsaW1pdGVkIGJ5ICYsIGFuZCBjcmVhdGUgYSBuZXN0ZWQgbGlzdCBpbiByb3ctbWFqb3Igb3JkZXJcbiAqIHdpdGggb25lIGdyb3VwIHBlciBjZWxsLlxuICovXG5mdW5jdGlvbiBwYXJzZUFycmF5KHBhcnNlciwgcmVzdWx0KSB7XG4gICAgdmFyIHJvdyA9IFtdO1xuICAgIHZhciBib2R5ID0gW3Jvd107XG4gICAgdmFyIHJvd0dhcHMgPSBbXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgY2VsbCA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIG51bGwpO1xuICAgICAgICByb3cucHVzaChuZXcgUGFyc2VOb2RlKFwib3JkZ3JvdXBcIiwgY2VsbCwgcGFyc2VyLm1vZGUpKTtcbiAgICAgICAgdmFyIG5leHQgPSBwYXJzZXIubmV4dFRva2VuLnRleHQ7XG4gICAgICAgIGlmIChuZXh0ID09PSBcIiZcIikge1xuICAgICAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0ID09PSBcIlxcXFxlbmRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gXCJcXFxcXFxcXFwiIHx8IG5leHQgPT09IFwiXFxcXGNyXCIpIHtcbiAgICAgICAgICAgIHZhciBjciA9IHBhcnNlci5wYXJzZUZ1bmN0aW9uKCk7XG4gICAgICAgICAgICByb3dHYXBzLnB1c2goY3IudmFsdWUuc2l6ZSk7XG4gICAgICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgICAgIGJvZHkucHVzaChyb3cpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJFeHBlY3RlZCAmIG9yIFxcXFxcXFxcIG9yIFxcXFxlbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5uZXh0VG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5ib2R5ID0gYm9keTtcbiAgICByZXN1bHQucm93R2FwcyA9IHJvd0dhcHM7XG4gICAgcmV0dXJuIG5ldyBQYXJzZU5vZGUocmVzdWx0LnR5cGUsIHJlc3VsdCwgcGFyc2VyLm1vZGUpO1xufVxuXG4vKlxuICogQW4gZW52aXJvbm1lbnQgZGVmaW5pdGlvbiBpcyB2ZXJ5IHNpbWlsYXIgdG8gYSBmdW5jdGlvbiBkZWZpbml0aW9uOlxuICogaXQgaXMgZGVjbGFyZWQgd2l0aCBhIG5hbWUgb3IgYSBsaXN0IG9mIG5hbWVzLCBhIHNldCBvZiBwcm9wZXJ0aWVzXG4gKiBhbmQgYSBoYW5kbGVyIGNvbnRhaW5pbmcgdGhlIGFjdHVhbCBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBUaGUgcHJvcGVydGllcyBpbmNsdWRlOlxuICogIC0gbnVtQXJnczogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgYWZ0ZXIgdGhlIFxcYmVnaW57bmFtZX0gZnVuY3Rpb24uXG4gKiAgLSBhcmdUeXBlczogKG9wdGlvbmFsKSBKdXN0IGxpa2UgZm9yIGEgZnVuY3Rpb25cbiAqICAtIGFsbG93ZWRJblRleHQ6IChvcHRpb25hbCkgV2hldGhlciBvciBub3QgdGhlIGVudmlyb25tZW50IGlzIGFsbG93ZWQgaW5zaWRlXG4gKiAgICAgICAgICAgICAgICAgICB0ZXh0IG1vZGUgKGRlZmF1bHQgZmFsc2UpIChub3QgZW5mb3JjZWQgeWV0KVxuICogIC0gbnVtT3B0aW9uYWxBcmdzOiAob3B0aW9uYWwpIEp1c3QgbGlrZSBmb3IgYSBmdW5jdGlvblxuICogQSBiYXJlIG51bWJlciBpbnN0ZWFkIG9mIHRoYXQgb2JqZWN0IGluZGljYXRlcyB0aGUgbnVtQXJncyB2YWx1ZS5cbiAqXG4gKiBUaGUgaGFuZGxlciBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdHdvIGFyZ3VtZW50c1xuICogIC0gY29udGV4dDogaW5mb3JtYXRpb24gYW5kIHJlZmVyZW5jZXMgcHJvdmlkZWQgYnkgdGhlIHBhcnNlclxuICogIC0gYXJnczogYW4gYXJyYXkgb2YgYXJndW1lbnRzIHBhc3NlZCB0byBcXGJlZ2lue25hbWV9XG4gKiBUaGUgY29udGV4dCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgLSBlbnZOYW1lOiB0aGUgbmFtZSBvZiB0aGUgZW52aXJvbm1lbnQsIG9uZSBvZiB0aGUgbGlzdGVkIG5hbWVzLlxuICogIC0gcGFyc2VyOiB0aGUgcGFyc2VyIG9iamVjdFxuICogIC0gbGV4ZXI6IHRoZSBsZXhlciBvYmplY3RcbiAqICAtIHBvc2l0aW9uczogdGhlIHBvc2l0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlc2UgYXJndW1lbnRzIGZyb20gYXJncy5cbiAqIFRoZSBoYW5kbGVyIG11c3QgcmV0dXJuIGEgUGFyc2VSZXN1bHQuXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lRW52aXJvbm1lbnQobmFtZXMsIHByb3BzLCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBuYW1lcyA9IFtuYW1lc107XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcHMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcHJvcHMgPSB7IG51bUFyZ3M6IHByb3BzIH07XG4gICAgfVxuICAgIC8vIFNldCBkZWZhdWx0IHZhbHVlcyBvZiBlbnZpcm9ubWVudHNcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgbnVtQXJnczogcHJvcHMubnVtQXJncyB8fCAwLFxuICAgICAgICBhcmdUeXBlczogcHJvcHMuYXJnVHlwZXMsXG4gICAgICAgIGdyZWVkaW5lc3M6IDEsXG4gICAgICAgIGFsbG93ZWRJblRleHQ6ICEhcHJvcHMuYWxsb3dlZEluVGV4dCxcbiAgICAgICAgbnVtT3B0aW9uYWxBcmdzOiBwcm9wcy5udW1PcHRpb25hbEFyZ3MgfHwgMCxcbiAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0c1tuYW1lc1tpXV0gPSBkYXRhO1xuICAgIH1cbn1cblxuLy8gQXJyYXlzIGFyZSBwYXJ0IG9mIExhVGVYLCBkZWZpbmVkIGluIGx0dGFiLmR0eCBzbyBpdHMgZG9jdW1lbnRhdGlvblxuLy8gaXMgcGFydCBvZiB0aGUgc291cmNlMmUucGRmIGZpbGUgb2YgTGFUZVgyZSBzb3VyY2UgZG9jdW1lbnRhdGlvbi5cbmRlZmluZUVudmlyb25tZW50KFwiYXJyYXlcIiwge1xuICAgIG51bUFyZ3M6IDFcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgY29sYWxpZ24gPSBhcmdzWzBdO1xuICAgIGNvbGFsaWduID0gY29sYWxpZ24udmFsdWUubWFwID8gY29sYWxpZ24udmFsdWUgOiBbY29sYWxpZ25dO1xuICAgIHZhciBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGNhID0gbm9kZS52YWx1ZTtcbiAgICAgICAgaWYgKFwibGNyXCIuaW5kZXhPZihjYSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICAgICAgICBhbGlnbjogY2FcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoY2EgPT09IFwifFwiKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic2VwYXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yOiBcInxcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihcbiAgICAgICAgICAgIFwiVW5rbm93biBjb2x1bW4gYWxpZ25tZW50OiBcIiArIG5vZGUudmFsdWUsXG4gICAgICAgICAgICBub2RlKTtcbiAgICB9KTtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGNvbHM6IGNvbHMsXG4gICAgICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXI6IHRydWUgLy8gXFxAcHJlYW1ibGUgaW4gbHR0YWIuZHR4XG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIHJldHVybiByZXM7XG59KTtcblxuLy8gVGhlIG1hdHJpeCBlbnZpcm9ubWVudHMgb2YgYW1zbWF0aCBidWlsZHMgb24gdGhlIGFycmF5IGVudmlyb25tZW50XG4vLyBvZiBMYVRlWCwgd2hpY2ggaXMgZGlzY3Vzc2VkIGFib3ZlLlxuZGVmaW5lRW52aXJvbm1lbnQoW1xuICAgIFwibWF0cml4XCIsXG4gICAgXCJwbWF0cml4XCIsXG4gICAgXCJibWF0cml4XCIsXG4gICAgXCJCbWF0cml4XCIsXG4gICAgXCJ2bWF0cml4XCIsXG4gICAgXCJWbWF0cml4XCJcbl0sIHtcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgZGVsaW1pdGVycyA9IHtcbiAgICAgICAgXCJtYXRyaXhcIjogbnVsbCxcbiAgICAgICAgXCJwbWF0cml4XCI6IFtcIihcIiwgXCIpXCJdLFxuICAgICAgICBcImJtYXRyaXhcIjogW1wiW1wiLCBcIl1cIl0sXG4gICAgICAgIFwiQm1hdHJpeFwiOiBbXCJcXFxce1wiLCBcIlxcXFx9XCJdLFxuICAgICAgICBcInZtYXRyaXhcIjogW1wifFwiLCBcInxcIl0sXG4gICAgICAgIFwiVm1hdHJpeFwiOiBbXCJcXFxcVmVydFwiLCBcIlxcXFxWZXJ0XCJdXG4gICAgfVtjb250ZXh0LmVudk5hbWVdO1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgaHNraXBCZWZvcmVBbmRBZnRlcjogZmFsc2UgLy8gXFxoc2tpcCAtXFxhcnJheWNvbHNlcCBpbiBhbXNtYXRoXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIGlmIChkZWxpbWl0ZXJzKSB7XG4gICAgICAgIHJlcyA9IG5ldyBQYXJzZU5vZGUoXCJsZWZ0cmlnaHRcIiwge1xuICAgICAgICAgICAgYm9keTogW3Jlc10sXG4gICAgICAgICAgICBsZWZ0OiBkZWxpbWl0ZXJzWzBdLFxuICAgICAgICAgICAgcmlnaHQ6IGRlbGltaXRlcnNbMV1cbiAgICAgICAgfSwgY29udGV4dC5tb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn0pO1xuXG4vLyBBIGNhc2VzIGVudmlyb25tZW50IChpbiBhbXNtYXRoLnN0eSkgaXMgYWxtb3N0IGVxdWl2YWxlbnQgdG9cbi8vIFxcZGVmXFxhcnJheXN0cmV0Y2h7MS4yfSVcbi8vIFxcbGVmdFxce1xcYmVnaW57YXJyYXl9e0B7fWxAe1xccXVhZH1sQHt9fSDigKYgXFxlbmR7YXJyYXl9XFxyaWdodC5cbmRlZmluZUVudmlyb25tZW50KFwiY2FzZXNcIiwge1xufSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgYXJyYXlzdHJldGNoOiAxLjIsXG4gICAgICAgIGNvbHM6IFt7XG4gICAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgICBhbGlnbjogXCJsXCIsXG4gICAgICAgICAgICBwcmVnYXA6IDAsXG4gICAgICAgICAgICAvLyBUT0RPKGtldmluYikgZ2V0IHRoZSBjdXJyZW50IHN0eWxlLlxuICAgICAgICAgICAgLy8gRm9yIG5vdyB3ZSB1c2UgdGhlIG1ldHJpY3MgZm9yIFRFWFQgc3R5bGUgd2hpY2ggaXMgd2hhdCB3ZSB3ZXJlXG4gICAgICAgICAgICAvLyBkb2luZyBiZWZvcmUuICBCZWZvcmUgYXR0ZW1wdGluZyB0byBnZXQgdGhlIGN1cnJlbnQgc3R5bGUgd2VcbiAgICAgICAgICAgIC8vIHNob3VsZCBsb29rIGF0IFRlWCdzIGJlaGF2aW9yIGVzcGVjaWFsbHkgZm9yIFxcb3ZlciBhbmQgbWF0cmljZXMuXG4gICAgICAgICAgICBwb3N0Z2FwOiBTdHlsZS5URVhULm1ldHJpY3MucXVhZFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0eXBlOiBcImFsaWduXCIsXG4gICAgICAgICAgICBhbGlnbjogXCJsXCIsXG4gICAgICAgICAgICBwcmVnYXA6IDAsXG4gICAgICAgICAgICBwb3N0Z2FwOiAwXG4gICAgICAgIH1dXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIHJlcyA9IG5ldyBQYXJzZU5vZGUoXCJsZWZ0cmlnaHRcIiwge1xuICAgICAgICBib2R5OiBbcmVzXSxcbiAgICAgICAgbGVmdDogXCJcXFxce1wiLFxuICAgICAgICByaWdodDogXCIuXCJcbiAgICB9LCBjb250ZXh0Lm1vZGUpO1xuICAgIHJldHVybiByZXM7XG59KTtcblxuLy8gQW4gYWxpZ25lZCBlbnZpcm9ubWVudCBpcyBsaWtlIHRoZSBhbGlnbiogZW52aXJvbm1lbnRcbi8vIGV4Y2VwdCBpdCBvcGVyYXRlcyB3aXRoaW4gbWF0aCBtb2RlLlxuLy8gTm90ZSB0aGF0IHdlIGFzc3VtZSBcXG5vbWFsbGluZXNraXBsaW1pdCB0byBiZSB6ZXJvLFxuLy8gc28gdGhhdCBcXHN0cnV0QCBpcyB0aGUgc2FtZSBhcyBcXHN0cnV0LlxuZGVmaW5lRW52aXJvbm1lbnQoXCJhbGlnbmVkXCIsIHtcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgcmVzID0ge1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGNvbHM6IFtdXG4gICAgfTtcbiAgICByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMpO1xuICAgIHZhciBlbXB0eUdyb3VwID0gbmV3IFBhcnNlTm9kZShcIm9yZGdyb3VwXCIsIFtdLCBjb250ZXh0Lm1vZGUpO1xuICAgIHZhciBudW1Db2xzID0gMDtcbiAgICByZXMudmFsdWUuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IHJvdy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgcm93W2ldLnZhbHVlLnVuc2hpZnQoZW1wdHlHcm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bUNvbHMgPCByb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICBudW1Db2xzID0gcm93Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQ29sczsgKytpKSB7XG4gICAgICAgIHZhciBhbGlnbiA9IFwiclwiO1xuICAgICAgICB2YXIgcHJlZ2FwID0gMDtcbiAgICAgICAgaWYgKGkgJSAyID09PSAxKSB7XG4gICAgICAgICAgICBhbGlnbiA9IFwibFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBwcmVnYXAgPSAyOyAvLyBvbmUgXFxxcXVhZCBiZXR3ZWVuIGNvbHVtbnNcbiAgICAgICAgfVxuICAgICAgICByZXMudmFsdWUuY29sc1tpXSA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiYWxpZ25cIixcbiAgICAgICAgICAgIGFsaWduOiBhbGlnbixcbiAgICAgICAgICAgIHByZWdhcDogcHJlZ2FwLFxuICAgICAgICAgICAgcG9zdGdhcDogMFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufSk7XG4iLCIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6MCAqL1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9TdHlsZVwiKTtcbnZhciBjamtSZWdleCA9IHJlcXVpcmUoXCIuL3VuaWNvZGVSZWdleGVzXCIpLmNqa1JlZ2V4O1xuXG4vKipcbiAqIFRoaXMgZmlsZSBjb250YWlucyBtZXRyaWNzIHJlZ2FyZGluZyBmb250cyBhbmQgaW5kaXZpZHVhbCBzeW1ib2xzLiBUaGUgc2lnbWFcbiAqIGFuZCB4aSB2YXJpYWJsZXMsIGFzIHdlbGwgYXMgdGhlIG1ldHJpY01hcCBtYXAgY29udGFpbiBkYXRhIGV4dHJhY3RlZCBmcm9tXG4gKiBUZVgsIFRlWCBmb250IG1ldHJpY3MsIGFuZCB0aGUgVFRGIGZpbGVzLiBUaGVzZSBkYXRhIGFyZSB0aGVuIGV4cG9zZWQgdmlhIHRoZVxuICogYG1ldHJpY3NgIHZhcmlhYmxlIGFuZCB0aGUgZ2V0Q2hhcmFjdGVyTWV0cmljcyBmdW5jdGlvbi5cbiAqL1xuXG4vLyBJbiBUZVgsIHRoZXJlIGFyZSBhY3R1YWxseSB0aHJlZSBzZXRzIG9mIGRpbWVuc2lvbnMsIG9uZSBmb3IgZWFjaCBvZlxuLy8gdGV4dHN0eWxlLCBzY3JpcHRzdHlsZSwgYW5kIHNjcmlwdHNjcmlwdHN0eWxlLiAgVGhlc2UgYXJlIHByb3ZpZGVkIGluIHRoZVxuLy8gdGhlIGFycmF5cyBiZWxvdywgaW4gdGhhdCBvcmRlci5cbi8vXG4vLyBUaGUgZm9udCBtZXRyaWNzIGFyZSBzdG9yZWQgaW4gZm9udHMgY21zeTEwLCBjbXN5NywgYW5kIGNtc3k1IHJlc3BzZWN0aXZlbHkuXG4vLyBUaGlzIHdhcyBkZXRlcm1pbmVkIGJ5IHJ1bm5pbmcgdGhlIGZvbGxsb3dpbmcgc2NyaXB0OlxuLy9cbi8vICAgICBsYXRleCAtaW50ZXJhY3Rpb249bm9uc3RvcG1vZGUgXFxcbi8vICAgICAnXFxkb2N1bWVudGNsYXNze2FydGljbGV9XFx1c2VwYWNrYWdle2Ftc21hdGh9XFxiZWdpbntkb2N1bWVudH0nIFxcXG4vLyAgICAgJyRhJCBcXGV4cGFuZGFmdGVyXFxzaG93XFx0aGVcXHRleHRmb250MicgXFxcbi8vICAgICAnXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFxzY3JpcHRmb250MicgXFxcbi8vICAgICAnXFxleHBhbmRhZnRlclxcc2hvd1xcdGhlXFxzY3JpcHRzY3JpcHRmb250MicgXFxcbi8vICAgICAnXFxzdG9wJ1xuLy9cbi8vIFRoZSBtZXRyaWNzIHRoZW1zZWx2ZXMgd2VyZSByZXRyZWl2ZWQgdXNpbmcgdGhlIGZvbGxvd2luZyBjb21tYW5kczpcbi8vXG4vLyAgICAgdGZ0b3BsIGNtc3kxMFxuLy8gICAgIHRmdG9wbCBjbXN5N1xuLy8gICAgIHRmdG9wbCBjbXN5NVxuLy9cbi8vIFRoZSBvdXRwdXQgb2YgZWFjaCBvZiB0aGVzZSBjb21tYW5kcyBpcyBxdWl0ZSBsZW5ndGh5LiAgVGhlIG9ubHkgcGFydCB3ZVxuLy8gY2FyZSBhYm91dCBpcyB0aGUgRk9OVERJTUVOIHNlY3Rpb24uIEVhY2ggdmFsdWUgaXMgbWVhc3VyZWQgaW4gRU1zLlxudmFyIHNpZ21hcyA9IHtcbiAgICBzbGFudDogWzAuMjUwLCAwLjI1MCwgMC4yNTBdLCAgICAgICAvLyBzaWdtYTFcbiAgICBzcGFjZTogWzAuMDAwLCAwLjAwMCwgMC4wMDBdLCAgICAgICAvLyBzaWdtYTJcbiAgICBzdHJldGNoOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sICAgICAvLyBzaWdtYTNcbiAgICBzaHJpbms6IFswLjAwMCwgMC4wMDAsIDAuMDAwXSwgICAgICAvLyBzaWdtYTRcbiAgICB4SGVpZ2h0OiBbMC40MzEsIDAuNDMxLCAwLjQzMV0sICAgICAvLyBzaWdtYTVcbiAgICBxdWFkOiBbMS4wMDAsIDEuMTcxLCAxLjQ3Ml0sICAgICAgICAvLyBzaWdtYTZcbiAgICBleHRyYVNwYWNlOiBbMC4wMDAsIDAuMDAwLCAwLjAwMF0sICAvLyBzaWdtYTdcbiAgICBudW0xOiBbMC42NzcsIDAuNzMyLCAwLjkyNV0sICAgICAgICAvLyBzaWdtYThcbiAgICBudW0yOiBbMC4zOTQsIDAuMzg0LCAwLjM4N10sICAgICAgICAvLyBzaWdtYTlcbiAgICBudW0zOiBbMC40NDQsIDAuNDcxLCAwLjUwNF0sICAgICAgICAvLyBzaWdtYTEwXG4gICAgZGVub20xOiBbMC42ODYsIDAuNzUyLCAxLjAyNV0sICAgICAgLy8gc2lnbWExMVxuICAgIGRlbm9tMjogWzAuMzQ1LCAwLjM0NCwgMC41MzJdLCAgICAgIC8vIHNpZ21hMTJcbiAgICBzdXAxOiBbMC40MTMsIDAuNTAzLCAwLjUwNF0sICAgICAgICAvLyBzaWdtYTEzXG4gICAgc3VwMjogWzAuMzYzLCAwLjQzMSwgMC40MDRdLCAgICAgICAgLy8gc2lnbWExNFxuICAgIHN1cDM6IFswLjI4OSwgMC4yODYsIDAuMjk0XSwgICAgICAgIC8vIHNpZ21hMTVcbiAgICBzdWIxOiBbMC4xNTAsIDAuMTQzLCAwLjIwMF0sICAgICAgICAvLyBzaWdtYTE2XG4gICAgc3ViMjogWzAuMjQ3LCAwLjI4NiwgMC40MDBdLCAgICAgICAgLy8gc2lnbWExN1xuICAgIHN1cERyb3A6IFswLjM4NiwgMC4zNTMsIDAuNDk0XSwgICAgIC8vIHNpZ21hMThcbiAgICBzdWJEcm9wOiBbMC4wNTAsIDAuMDcxLCAwLjEwMF0sICAgICAvLyBzaWdtYTE5XG4gICAgZGVsaW0xOiBbMi4zOTAsIDEuNzAwLCAxLjk4MF0sICAgICAgLy8gc2lnbWEyMFxuICAgIGRlbGltMjogWzEuMDEwLCAxLjE1NywgMS40MjBdLCAgICAgIC8vIHNpZ21hMjFcbiAgICBheGlzSGVpZ2h0OiBbMC4yNTAsIDAuMjUwLCAwLjI1MF0gIC8vIHNpZ21hMjJcbn07XG5cbi8vIFRoZXNlIGZvbnQgbWV0cmljcyBhcmUgZXh0cmFjdGVkIGZyb20gVGVYIGJ5IHVzaW5nXG4vLyBcXGZvbnRcXGE9Y21leDEwXG4vLyBcXHNob3d0aGVcXGZvbnRkaW1lblhcXGFcbi8vIHdoZXJlIFggaXMgdGhlIGNvcnJlc3BvbmRpbmcgdmFyaWFibGUgbnVtYmVyLiBUaGVzZSBjb3JyZXNwb25kIHRvIHRoZSBmb250XG4vLyBwYXJhbWV0ZXJzIG9mIHRoZSBleHRlbnNpb24gZm9udHMgKGZhbWlseSAzKS4gU2VlIHRoZSBUZVhib29rLCBwYWdlIDQ0MS5cbnZhciB4aTEgPSAwO1xudmFyIHhpMiA9IDA7XG52YXIgeGkzID0gMDtcbnZhciB4aTQgPSAwO1xudmFyIHhpNSA9IDAuNDMxO1xudmFyIHhpNiA9IDE7XG52YXIgeGk3ID0gMDtcbnZhciB4aTggPSAwLjA0O1xudmFyIHhpOSA9IDAuMTExO1xudmFyIHhpMTAgPSAwLjE2NjtcbnZhciB4aTExID0gMC4yO1xudmFyIHhpMTIgPSAwLjY7XG52YXIgeGkxMyA9IDAuMTtcblxuLy8gVGhpcyB2YWx1ZSBkZXRlcm1pbmVzIGhvdyBsYXJnZSBhIHB0IGlzLCBmb3IgbWV0cmljcyB3aGljaCBhcmUgZGVmaW5lZCBpblxuLy8gdGVybXMgb2YgcHRzLlxuLy8gVGhpcyB2YWx1ZSBpcyBhbHNvIHVzZWQgaW4ga2F0ZXgubGVzczsgaWYgeW91IGNoYW5nZSBpdCBtYWtlIHN1cmUgdGhlIHZhbHVlc1xuLy8gbWF0Y2guXG52YXIgcHRQZXJFbSA9IDEwLjA7XG5cbi8vIFRoZSBzcGFjZSBiZXR3ZWVuIGFkamFjZW50IGB8YCBjb2x1bW5zIGluIGFuIGFycmF5IGRlZmluaXRpb24uIEZyb21cbi8vIGBcXHNob3d0aGVcXGRvdWJsZXJ1bGVzZXBgIGluIExhVGVYLlxudmFyIGRvdWJsZVJ1bGVTZXAgPSAyLjAgLyBwdFBlckVtO1xuXG4vKipcbiAqIFRoaXMgaXMganVzdCBhIG1hcHBpbmcgZnJvbSBjb21tb24gbmFtZXMgdG8gcmVhbCBtZXRyaWNzXG4gKi9cbnZhciBtZXRyaWNzID0ge1xuICAgIGRlZmF1bHRSdWxlVGhpY2tuZXNzOiB4aTgsXG4gICAgYmlnT3BTcGFjaW5nMTogeGk5LFxuICAgIGJpZ09wU3BhY2luZzI6IHhpMTAsXG4gICAgYmlnT3BTcGFjaW5nMzogeGkxMSxcbiAgICBiaWdPcFNwYWNpbmc0OiB4aTEyLFxuICAgIGJpZ09wU3BhY2luZzU6IHhpMTMsXG4gICAgcHRQZXJFbTogcHRQZXJFbSxcbiAgICBkb3VibGVSdWxlU2VwOiBkb3VibGVSdWxlU2VwXG59O1xuXG4vLyBUaGlzIG1hcCBjb250YWlucyBhIG1hcHBpbmcgZnJvbSBmb250IG5hbWUgYW5kIGNoYXJhY3RlciBjb2RlIHRvIGNoYXJhY3RlclxuLy8gbWV0cmljcywgaW5jbHVkaW5nIGhlaWdodCwgZGVwdGgsIGl0YWxpYyBjb3JyZWN0aW9uLCBhbmQgc2tldyAoa2VybiBmcm9tIHRoZVxuLy8gY2hhcmFjdGVyIHRvIHRoZSBjb3JyZXNwb25kaW5nIFxcc2tld2NoYXIpXG4vLyBUaGlzIG1hcCBpcyBnZW5lcmF0ZWQgdmlhIGBtYWtlIG1ldHJpY3NgLiBJdCBzaG91bGQgbm90IGJlIGNoYW5nZWQgbWFudWFsbHkuXG52YXIgbWV0cmljTWFwID0gcmVxdWlyZShcIi4vZm9udE1ldHJpY3NEYXRhXCIpO1xuXG4vLyBUaGVzZSBhcmUgdmVyeSByb3VnaCBhcHByb3hpbWF0aW9ucy4gIFdlIGRlZmF1bHQgdG8gVGltZXMgTmV3IFJvbWFuIHdoaWNoXG4vLyBzaG91bGQgaGF2ZSBMYXRpbi0xIGFuZCBDeXJpbGxpYyBjaGFyYWN0ZXJzLCBidXQgbWF5IG5vdCBkZXBlbmRpbmcgb24gdGhlXG4vLyBvcGVyYXRpbmcgc3lzdGVtLiAgVGhlIG1ldHJpY3MgZG8gbm90IGFjY291bnQgZm9yIGV4dHJhIGhlaWdodCBmcm9tIHRoZVxuLy8gYWNjZW50cy4gIEluIHRoZSBjYXNlIG9mIEN5cmlsbGljIGNoYXJhY3RlcnMgd2hpY2ggaGF2ZSBib3RoIGFzY2VuZGVycyBhbmRcbi8vIGRlc2NlbmRlcnMgd2UgcHJlZmVyIGFwcHJveGltYXRpb25zIHdpdGggYXNjZW5kZXJzLCBwcmltYXJpbHkgdG8gcHJldmVudFxuLy8gdGhlIGZyYWN0aW9uIGJhciBvciByb290IGxpbmUgZnJvbSBpbnRlcnNlY3RpbmcgdGhlIGdseXBoLlxuLy8gVE9ETyhrZXZpbmIpIGFsbG93IHVuaW9uIG9mIG11bHRpcGxlIGdseXBoIG1ldHJpY3MgZm9yIGJldHRlciBhY2N1cmFjeS5cbnZhciBleHRyYUNoYXJhY3Rlck1hcCA9IHtcbiAgICAvLyBMYXRpbi0xXG4gICAgJ8OAJzogJ0EnLFxuICAgICfDgSc6ICdBJyxcbiAgICAnw4InOiAnQScsXG4gICAgJ8ODJzogJ0EnLFxuICAgICfDhCc6ICdBJyxcbiAgICAnw4UnOiAnQScsXG4gICAgJ8OGJzogJ0EnLFxuICAgICfDhyc6ICdDJyxcbiAgICAnw4gnOiAnRScsXG4gICAgJ8OJJzogJ0UnLFxuICAgICfDiic6ICdFJyxcbiAgICAnw4snOiAnRScsXG4gICAgJ8OMJzogJ0knLFxuICAgICfDjSc6ICdJJyxcbiAgICAnw44nOiAnSScsXG4gICAgJ8OPJzogJ0knLFxuICAgICfDkCc6ICdEJyxcbiAgICAnw5EnOiAnTicsXG4gICAgJ8OSJzogJ08nLFxuICAgICfDkyc6ICdPJyxcbiAgICAnw5QnOiAnTycsXG4gICAgJ8OVJzogJ08nLFxuICAgICfDlic6ICdPJyxcbiAgICAnw5gnOiAnTycsXG4gICAgJ8OZJzogJ1UnLFxuICAgICfDmic6ICdVJyxcbiAgICAnw5snOiAnVScsXG4gICAgJ8OcJzogJ1UnLFxuICAgICfDnSc6ICdZJyxcbiAgICAnw54nOiAnbycsXG4gICAgJ8OfJzogJ0InLFxuICAgICfDoCc6ICdhJyxcbiAgICAnw6EnOiAnYScsXG4gICAgJ8OiJzogJ2EnLFxuICAgICfDoyc6ICdhJyxcbiAgICAnw6QnOiAnYScsXG4gICAgJ8OlJzogJ2EnLFxuICAgICfDpic6ICdhJyxcbiAgICAnw6cnOiAnYycsXG4gICAgJ8OoJzogJ2UnLFxuICAgICfDqSc6ICdlJyxcbiAgICAnw6onOiAnZScsXG4gICAgJ8OrJzogJ2UnLFxuICAgICfDrCc6ICdpJyxcbiAgICAnw60nOiAnaScsXG4gICAgJ8OuJzogJ2knLFxuICAgICfDryc6ICdpJyxcbiAgICAnw7AnOiAnZCcsXG4gICAgJ8OxJzogJ24nLFxuICAgICfDsic6ICdvJyxcbiAgICAnw7MnOiAnbycsXG4gICAgJ8O0JzogJ28nLFxuICAgICfDtSc6ICdvJyxcbiAgICAnw7YnOiAnbycsXG4gICAgJ8O4JzogJ28nLFxuICAgICfDuSc6ICd1JyxcbiAgICAnw7onOiAndScsXG4gICAgJ8O7JzogJ3UnLFxuICAgICfDvCc6ICd1JyxcbiAgICAnw70nOiAneScsXG4gICAgJ8O+JzogJ28nLFxuICAgICfDvyc6ICd5JyxcblxuICAgIC8vIEN5cmlsbGljXG4gICAgJ9CQJzogJ0EnLFxuICAgICfQkSc6ICdCJyxcbiAgICAn0JInOiAnQicsXG4gICAgJ9CTJzogJ0YnLFxuICAgICfQlCc6ICdBJyxcbiAgICAn0JUnOiAnRScsXG4gICAgJ9CWJzogJ0snLFxuICAgICfQlyc6ICczJyxcbiAgICAn0JgnOiAnTicsXG4gICAgJ9CZJzogJ04nLFxuICAgICfQmic6ICdLJyxcbiAgICAn0JsnOiAnTicsXG4gICAgJ9CcJzogJ00nLFxuICAgICfQnSc6ICdIJyxcbiAgICAn0J4nOiAnTycsXG4gICAgJ9CfJzogJ04nLFxuICAgICfQoCc6ICdQJyxcbiAgICAn0KEnOiAnQycsXG4gICAgJ9CiJzogJ1QnLFxuICAgICfQoyc6ICd5JyxcbiAgICAn0KQnOiAnTycsXG4gICAgJ9ClJzogJ1gnLFxuICAgICfQpic6ICdVJyxcbiAgICAn0KcnOiAnaCcsXG4gICAgJ9CoJzogJ1cnLFxuICAgICfQqSc6ICdXJyxcbiAgICAn0KonOiAnQicsXG4gICAgJ9CrJzogJ1gnLFxuICAgICfQrCc6ICdCJyxcbiAgICAn0K0nOiAnMycsXG4gICAgJ9CuJzogJ1gnLFxuICAgICfQryc6ICdSJyxcbiAgICAn0LAnOiAnYScsXG4gICAgJ9CxJzogJ2InLFxuICAgICfQsic6ICdhJyxcbiAgICAn0LMnOiAncicsXG4gICAgJ9C0JzogJ3knLFxuICAgICfQtSc6ICdlJyxcbiAgICAn0LYnOiAnbScsXG4gICAgJ9C3JzogJ2UnLFxuICAgICfQuCc6ICduJyxcbiAgICAn0LknOiAnbicsXG4gICAgJ9C6JzogJ24nLFxuICAgICfQuyc6ICduJyxcbiAgICAn0LwnOiAnbScsXG4gICAgJ9C9JzogJ24nLFxuICAgICfQvic6ICdvJyxcbiAgICAn0L8nOiAnbicsXG4gICAgJ9GAJzogJ3AnLFxuICAgICfRgSc6ICdjJyxcbiAgICAn0YInOiAnbycsXG4gICAgJ9GDJzogJ3knLFxuICAgICfRhCc6ICdiJyxcbiAgICAn0YUnOiAneCcsXG4gICAgJ9GGJzogJ24nLFxuICAgICfRhyc6ICduJyxcbiAgICAn0YgnOiAndycsXG4gICAgJ9GJJzogJ3cnLFxuICAgICfRiic6ICdhJyxcbiAgICAn0YsnOiAnbScsXG4gICAgJ9GMJzogJ2EnLFxuICAgICfRjSc6ICdlJyxcbiAgICAn0Y4nOiAnbScsXG4gICAgJ9GPJzogJ3InXG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgbG9va2luZyB1cCBpbmZvcm1hdGlvbiBpbiB0aGVcbiAqIG1ldHJpY01hcCB0YWJsZS4gSXQgdGFrZXMgYSBjaGFyYWN0ZXIgYXMgYSBzdHJpbmcsIGFuZCBhIHN0eWxlLlxuICpcbiAqIE5vdGU6IHRoZSBgd2lkdGhgIHByb3BlcnR5IG1heSBiZSB1bmRlZmluZWQgaWYgZm9udE1ldHJpY3NEYXRhLmpzIHdhc24ndFxuICogYnVpbHQgdXNpbmcgYE1ha2UgZXh0ZW5kZWRfbWV0cmljc2AuXG4gKi9cbnZhciBnZXRDaGFyYWN0ZXJNZXRyaWNzID0gZnVuY3Rpb24oY2hhcmFjdGVyLCBzdHlsZSkge1xuICAgIHZhciBjaCA9IGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuICAgIGlmIChjaGFyYWN0ZXJbMF0gaW4gZXh0cmFDaGFyYWN0ZXJNYXApIHtcbiAgICAgICAgY2ggPSBleHRyYUNoYXJhY3Rlck1hcFtjaGFyYWN0ZXJbMF1dLmNoYXJDb2RlQXQoMCk7XG4gICAgfSBlbHNlIGlmIChjamtSZWdleC50ZXN0KGNoYXJhY3RlclswXSkpIHtcbiAgICAgICAgY2ggPSAnTScuY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgdmFyIG1ldHJpY3MgPSBtZXRyaWNNYXBbc3R5bGVdW2NoXTtcbiAgICBpZiAobWV0cmljcykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVwdGg6IG1ldHJpY3NbMF0sXG4gICAgICAgICAgICBoZWlnaHQ6IG1ldHJpY3NbMV0sXG4gICAgICAgICAgICBpdGFsaWM6IG1ldHJpY3NbMl0sXG4gICAgICAgICAgICBza2V3OiBtZXRyaWNzWzNdLFxuICAgICAgICAgICAgd2lkdGg6IG1ldHJpY3NbNF1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtZXRyaWNzOiBtZXRyaWNzLFxuICAgIHNpZ21hczogc2lnbWFzLFxuICAgIGdldENoYXJhY3Rlck1ldHJpY3M6IGdldENoYXJhY3Rlck1ldHJpY3Ncbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBcIkFNUy1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI2NVwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNjZcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjY3XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI2OFwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNjlcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI3MVwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzJcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjczXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI3NFwiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzVcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjc2XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI3N1wiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzhcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjc5XCI6IFswLjE2NjY3LCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4MFwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiODFcIjogWzAuMTY2NjcsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjgyXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4M1wiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiODRcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjg1XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NlwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiODdcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjg4XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4OVwiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiOTBcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42ODg4OSwgMCwgMF0sXG4gICAgICAgIFwiMTY1XCI6IFswLCAwLjY3NSwgMC4wMjUsIDBdLFxuICAgICAgICBcIjE3NFwiOiBbMC4xNTU1OSwgMC42OTIyNCwgMCwgMF0sXG4gICAgICAgIFwiMjQwXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCIyOTVcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjcxMFwiOiBbMCwgMC44MjUsIDAsIDBdLFxuICAgICAgICBcIjczMlwiOiBbMCwgMC45LCAwLCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuOSwgMCwgMF0sXG4gICAgICAgIFwiOTg5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCIxMDA4XCI6IFswLCAwLjQzMDU2LCAwLjA0MDI4LCAwXSxcbiAgICAgICAgXCI4MjQ1XCI6IFswLCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4NDYzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NDg3XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NDk4XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTAyXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTAzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTA0XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTEzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NTkyXCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMF0sXG4gICAgICAgIFwiODU5NFwiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDBdLFxuICAgICAgICBcIjg2MDJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjAzXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODYwNlwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYwOFwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYxMFwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYxMVwiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMF0sXG4gICAgICAgIFwiODYxOVwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODYyMFwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODYyMVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDBdLFxuICAgICAgICBcIjg2MjJcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjI0XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjI1XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjMwXCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NjMxXCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NjM0XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwXSxcbiAgICAgICAgXCI4NjM1XCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwXSxcbiAgICAgICAgXCI4NjM4XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjM5XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQyXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQzXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ0XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ2XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ3XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ4XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjQ5XCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NjUwXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NjUxXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwXSxcbiAgICAgICAgXCI4NjUyXCI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwXSxcbiAgICAgICAgXCI4NjUzXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODY1NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg2NTVcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjY2XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4NjY3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4NjY5XCI6IFstMC4xMzMxMywgMC4zNzc4OCwgMCwgMF0sXG4gICAgICAgIFwiODY3MlwiOiBbLTAuMDY0LCAwLjQzNywgMCwgMF0sXG4gICAgICAgIFwiODY3NFwiOiBbLTAuMDY0LCAwLjQzNywgMCwgMF0sXG4gICAgICAgIFwiODcwNVwiOiBbMCwgMC44MjUsIDAsIDBdLFxuICAgICAgICBcIjg3MDhcIjogWzAsIDAuNjg4ODksIDAsIDBdLFxuICAgICAgICBcIjg3MDlcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDBdLFxuICAgICAgICBcIjg3MTdcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjg3MjJcIjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwXSxcbiAgICAgICAgXCI4NzI0XCI6IFswLjA4MTk4LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzI2XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4NzMzXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM3XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM4XCI6IFswLjAzNTE3LCAwLjUyMjM5LCAwLCAwXSxcbiAgICAgICAgXCI4NzM5XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4NzQwXCI6IFswLjI1MTQyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NzQxXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4NzQyXCI6IFswLjI1MTQyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NzU2XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzU3XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzY0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODc2NVwiOiBbLTAuMTMzMTMsIDAuMzc3ODgsIDAsIDBdLFxuICAgICAgICBcIjg3NjlcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NzcwXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMF0sXG4gICAgICAgIFwiODc3NFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMF0sXG4gICAgICAgIFwiODc3NlwiOiBbLTAuMDE2ODgsIDAuNDgzMTIsIDAsIDBdLFxuICAgICAgICBcIjg3NzhcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDBdLFxuICAgICAgICBcIjg3ODJcIjogWzAuMDYwNjIsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg3ODNcIjogWzAuMDYwNjIsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg3ODVcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg3ODZcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg3ODdcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg3OTBcIjogWzAsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjg3OTFcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg3OTZcIjogWzAuMDgxOTgsIDAuOTE2NjcsIDAsIDBdLFxuICAgICAgICBcIjg4MDZcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjg4MDdcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjg4MDhcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjg4MDlcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjg4MTJcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjg4MTRcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4MTVcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4MTZcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4MTdcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4MThcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MTlcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MjJcIjogWzAuMTgwOCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjg4MjNcIjogWzAuMTgwOCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjg4MjhcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjg4MjlcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjg4MzBcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MzFcIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDBdLFxuICAgICAgICBcIjg4MzJcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4MzNcIjogWzAuMjA1NzYsIDAuNzA1NzYsIDAsIDBdLFxuICAgICAgICBcIjg4NDBcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4NDFcIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDBdLFxuICAgICAgICBcIjg4NDJcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdLFxuICAgICAgICBcIjg4NDNcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdLFxuICAgICAgICBcIjg4NDdcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg4NDhcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjg4NThcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg4NTlcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg4NjFcIjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDBdLFxuICAgICAgICBcIjg4NjJcIjogWzAsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODYzXCI6IFswLCAwLjY3NSwgMCwgMF0sXG4gICAgICAgIFwiODg2NFwiOiBbMCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjg4NjVcIjogWzAsIDAuNjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODcyXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODczXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODc0XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODc2XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODc3XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODc4XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODc5XCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4ODgyXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4ODgzXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4ODg0XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODg1XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODg4XCI6IFswLCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4ODkwXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODkxXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4ODkyXCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTAxXCI6IFswLCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4OTAzXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTA1XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTA2XCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTA3XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTA4XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTA5XCI6IFstMC4wMzU5OCwgMC40NjQwMiwgMCwgMF0sXG4gICAgICAgIFwiODkxMFwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxMVwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxMlwiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxM1wiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxNFwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxNVwiOiBbMCwgMC41NDk4NiwgMCwgMF0sXG4gICAgICAgIFwiODkxNlwiOiBbMCwgMC42OTIyNCwgMCwgMF0sXG4gICAgICAgIFwiODkxOFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg5MTlcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwXSxcbiAgICAgICAgXCI4OTIwXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4OTIxXCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwXSxcbiAgICAgICAgXCI4OTIyXCI6IFswLjM4NTY5LCAwLjg4NTY5LCAwLCAwXSxcbiAgICAgICAgXCI4OTIzXCI6IFswLjM4NTY5LCAwLjg4NTY5LCAwLCAwXSxcbiAgICAgICAgXCI4OTI2XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTI3XCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCI4OTI4XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTI5XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTM0XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM1XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM2XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM3XCI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI4OTM4XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwXSxcbiAgICAgICAgXCI4OTM5XCI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwXSxcbiAgICAgICAgXCI4OTQwXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTQxXCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI4OTk0XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4OTk1XCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDE2XCI6IFswLjE1NTU5LCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDg0XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDg4XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI5NDkyXCI6IFswLCAwLjM3Nzg4LCAwLCAwXSxcbiAgICAgICAgXCI5NDk2XCI6IFswLCAwLjM3Nzg4LCAwLCAwXSxcbiAgICAgICAgXCI5NTg1XCI6IFswLjE5NDQ0LCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI5NTg2XCI6IFswLjE5NDQ0LCAwLjc0MTExLCAwLCAwXSxcbiAgICAgICAgXCI5NjMyXCI6IFswLCAwLjY3NSwgMCwgMF0sXG4gICAgICAgIFwiOTYzM1wiOiBbMCwgMC42NzUsIDAsIDBdLFxuICAgICAgICBcIjk2NTBcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NTFcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NTRcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NjBcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NjFcIjogWzAsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NjRcIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDBdLFxuICAgICAgICBcIjk2NzRcIjogWzAuMTExMTEsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjk3MzNcIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjEwMDAzXCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCIxMDAxNlwiOiBbMCwgMC42OTIyNCwgMCwgMF0sXG4gICAgICAgIFwiMTA3MzFcIjogWzAuMTExMTEsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjEwODQ2XCI6IFswLjE5NDQ0LCAwLjc1NTgzLCAwLCAwXSxcbiAgICAgICAgXCIxMDg3N1wiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMF0sXG4gICAgICAgIFwiMTA4NzhcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjEwODg1XCI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwXSxcbiAgICAgICAgXCIxMDg4NlwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMF0sXG4gICAgICAgIFwiMTA4ODdcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdLFxuICAgICAgICBcIjEwODg4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCIxMDg4OVwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiMTA4OTBcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjEwODkxXCI6IFswLjQ4MjU2LCAwLjk4MjU2LCAwLCAwXSxcbiAgICAgICAgXCIxMDg5MlwiOiBbMC40ODI1NiwgMC45ODI1NiwgMCwgMF0sXG4gICAgICAgIFwiMTA5MDFcIjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDBdLFxuICAgICAgICBcIjEwOTAyXCI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwXSxcbiAgICAgICAgXCIxMDkzM1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiMTA5MzRcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjEwOTM1XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCIxMDkzNlwiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiMTA5MzdcIjogWzAuMjYxNjcsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjEwOTM4XCI6IFswLjI2MTY3LCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCIxMDk0OVwiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMF0sXG4gICAgICAgIFwiMTA5NTBcIjogWzAuMjU1ODMsIDAuNzU1ODMsIDAsIDBdLFxuICAgICAgICBcIjEwOTU1XCI6IFswLjI4NDgxLCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCIxMDk1NlwiOiBbMC4yODQ4MSwgMC43OTM4MywgMCwgMF0sXG4gICAgICAgIFwiNTczNTBcIjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDBdLFxuICAgICAgICBcIjU3MzUxXCI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwXSxcbiAgICAgICAgXCI1NzM1MlwiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMF0sXG4gICAgICAgIFwiNTczNTNcIjogWzAsIDAuNDMwNTYsIDAuMDQwMjgsIDBdLFxuICAgICAgICBcIjU3MzU2XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCI1NzM1N1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiNTczNThcIjogWzAuNDE5NTEsIDAuOTE5NTEsIDAsIDBdLFxuICAgICAgICBcIjU3MzU5XCI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwXSxcbiAgICAgICAgXCI1NzM2MFwiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMF0sXG4gICAgICAgIFwiNTczNjFcIjogWzAuNDE5NTEsIDAuOTE5NTEsIDAsIDBdLFxuICAgICAgICBcIjU3MzY2XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCI1NzM2N1wiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMF0sXG4gICAgICAgIFwiNTczNjhcIjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDBdLFxuICAgICAgICBcIjU3MzY5XCI6IFswLjI1MTQyLCAwLjc1NzI2LCAwLCAwXSxcbiAgICAgICAgXCI1NzM3MFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMF0sXG4gICAgICAgIFwiNTczNzFcIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDBdXG4gICAgfSxcbiAgICBcIkNhbGlncmFwaGljLVJlZ3VsYXJcIjoge1xuICAgICAgICBcIjQ4XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI0OVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTBcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI1MlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1NVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU3XCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI2NVwiOiBbMCwgMC42ODMzMywgMCwgMC4xOTQ0NV0sXG4gICAgICAgIFwiNjZcIjogWzAsIDAuNjgzMzMsIDAuMDMwNDEsIDAuMTM4ODldLFxuICAgICAgICBcIjY3XCI6IFswLCAwLjY4MzMzLCAwLjA1ODM0LCAwLjEzODg5XSxcbiAgICAgICAgXCI2OFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiNjlcIjogWzAsIDAuNjgzMzMsIDAuMDg5NDQsIDAuMTExMTFdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjY4MzMzLCAwLjA5OTMxLCAwLjExMTExXSxcbiAgICAgICAgXCI3MVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4wNTkzLCAwLjExMTExXSxcbiAgICAgICAgXCI3MlwiOiBbMCwgMC42ODMzMywgMC4wMDk2NSwgMC4xMTExMV0sXG4gICAgICAgIFwiNzNcIjogWzAsIDAuNjgzMzMsIDAuMDczODIsIDBdLFxuICAgICAgICBcIjc0XCI6IFswLjA5NzIyLCAwLjY4MzMzLCAwLjE4NDcyLCAwLjE2NjY3XSxcbiAgICAgICAgXCI3NVwiOiBbMCwgMC42ODMzMywgMC4wMTQ0NSwgMC4wNTU1Nl0sXG4gICAgICAgIFwiNzZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODldLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjY4MzMzLCAwLCAwLjEzODg5XSxcbiAgICAgICAgXCI3OFwiOiBbMCwgMC42ODMzMywgMC4xNDczNiwgMC4wODMzNF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMTExMTFdLFxuICAgICAgICBcIjgwXCI6IFswLCAwLjY4MzMzLCAwLjA4MjIyLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4MVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMCwgMC4xMTExMV0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjgzXCI6IFswLCAwLjY4MzMzLCAwLjA3NSwgMC4xMzg4OV0sXG4gICAgICAgIFwiODRcIjogWzAsIDAuNjgzMzMsIDAuMjU0MTcsIDBdLFxuICAgICAgICBcIjg1XCI6IFswLCAwLjY4MzMzLCAwLjA5OTMxLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NlwiOiBbMCwgMC42ODMzMywgMC4wODIyMiwgMF0sXG4gICAgICAgIFwiODdcIjogWzAsIDAuNjgzMzMsIDAuMDgyMjIsIDAuMDgzMzRdLFxuICAgICAgICBcIjg4XCI6IFswLCAwLjY4MzMzLCAwLjE0NjQzLCAwLjEzODg5XSxcbiAgICAgICAgXCI4OVwiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4wODIyMiwgMC4wODMzNF0sXG4gICAgICAgIFwiOTBcIjogWzAsIDAuNjgzMzMsIDAuMDc5NDQsIDAuMTM4ODldXG4gICAgfSxcbiAgICBcIkZyYWt0dXItUmVndWxhclwiOiB7XG4gICAgICAgIFwiMzNcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjM0XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIzOFwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiMzlcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjQwXCI6IFswLjI0OTgyLCAwLjc0OTQ3LCAwLCAwXSxcbiAgICAgICAgXCI0MVwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMF0sXG4gICAgICAgIFwiNDJcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjQzXCI6IFswLjA4MzE5LCAwLjU4MjgzLCAwLCAwXSxcbiAgICAgICAgXCI0NFwiOiBbMCwgMC4xMDgwMywgMCwgMF0sXG4gICAgICAgIFwiNDVcIjogWzAuMDgzMTksIDAuNTgyODMsIDAsIDBdLFxuICAgICAgICBcIjQ2XCI6IFswLCAwLjEwODAzLCAwLCAwXSxcbiAgICAgICAgXCI0N1wiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMF0sXG4gICAgICAgIFwiNDhcIjogWzAsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjQ5XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1MFwiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiNTFcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjUyXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1M1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiNTRcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjU1XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1NlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTdcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjU4XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1OVwiOiBbMC4xMjYwNCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiNjFcIjogWy0wLjEzMDk5LCAwLjM2ODY2LCAwLCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMC4xMjYwNCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLjA2MzAyLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAuMTI2MDQsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjAzNzgxLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLjEyNjA0LCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMF0sXG4gICAgICAgIFwiOTNcIjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDBdLFxuICAgICAgICBcIjk0XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE4OTA2LCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjEwNFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiMTA4XCI6IFswLCAwLjY5MTQxLCAwLCAwXSxcbiAgICAgICAgXCIxMDlcIjogWzAsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjExMFwiOiBbMCwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiMTExXCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMTJcIjogWzAuMTg5MDYsIDAuNTIzOTYsIDAsIDBdLFxuICAgICAgICBcIjExM1wiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiMTE0XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMTVcIjogWzAsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjExNlwiOiBbMCwgMC42MjExOSwgMCwgMF0sXG4gICAgICAgIFwiMTE3XCI6IFswLCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMThcIjogWzAsIDAuNTIzOTYsIDAsIDBdLFxuICAgICAgICBcIjExOVwiOiBbMCwgMC41MjM5NiwgMCwgMF0sXG4gICAgICAgIFwiMTIwXCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCIxMjFcIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDBdLFxuICAgICAgICBcIjEyMlwiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMF0sXG4gICAgICAgIFwiODIxNlwiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiODIxN1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTgxMTJcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjU4MTEzXCI6IFswLCAwLjYyMTE5LCAwLCAwXSxcbiAgICAgICAgXCI1ODExNFwiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTgxMTVcIjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDBdLFxuICAgICAgICBcIjU4MTE2XCI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwXSxcbiAgICAgICAgXCI1ODExN1wiOiBbMCwgMC42OTE0MSwgMCwgMF0sXG4gICAgICAgIFwiNTgxMThcIjogWzAsIDAuNjIxMTksIDAsIDBdLFxuICAgICAgICBcIjU4MTE5XCI6IFswLCAwLjQ3NTM0LCAwLCAwXVxuICAgIH0sXG4gICAgXCJNYWluLUJvbGRcIjoge1xuICAgICAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0M1wiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMF0sXG4gICAgICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0NlwiOiBbMCwgMC4xNTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1MlwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1NVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1OFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjYwXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI2MVwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjYyXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjY1XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI2NlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNjdcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjY4XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI2OVwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzBcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjcxXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI3MlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzNcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjc0XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI3NVwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzZcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI3OFwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjgwXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI4MVwiOiBbMC4xOTQ0NCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjgzXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI4NFwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiODVcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjg2XCI6IFswLCAwLjY4NjExLCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCI4N1wiOiBbMCwgMC42ODYxMSwgMC4wMTU5NywgMF0sXG4gICAgICAgIFwiODhcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjg5XCI6IFswLCAwLjY4NjExLCAwLjAyODc1LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjkyXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjMxLCAwLjEzNDQ0LCAwLjAzMTk0LCAwXSxcbiAgICAgICAgXCI5NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTdcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5OVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDFcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4xMDkwMywgMF0sXG4gICAgICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwNVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDE1OTcsIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxNTk3LCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTI0XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEyNlwiOiBbMC4zNSwgMC4zNDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxNzJcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjE3NVwiOiBbMCwgMC41OTYxMSwgMCwgMF0sXG4gICAgICAgIFwiMTc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxNzdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjE4MFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMjE1XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCIyNDdcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MTBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcxMVwiOiBbMCwgMC42MzE5NCwgMCwgMF0sXG4gICAgICAgIFwiNzEzXCI6IFswLCAwLjU5NjExLCAwLCAwXSxcbiAgICAgICAgXCI3MTRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcxNVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzI4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MjlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjczMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzMyXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NjhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3MlwiOiBbMCwgMC41OTYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzc0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzc4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc4MFwiOiBbMCwgMC42MzE5NCwgMCwgMF0sXG4gICAgICAgIFwiODI0XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MTVcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkxNlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTIwXCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MjNcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkyNlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTI4XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MzFcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkzM1wiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTM0XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MzZcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkzN1wiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiODIxMVwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiODIxMlwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiODIxNlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIxN1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyMVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyNFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODIyNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODI0MlwiOiBbMCwgMC41NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiODQwN1wiOiBbMCwgMC43MjQ0NCwgMC4xNTQ4NiwgMF0sXG4gICAgICAgIFwiODQ2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ2N1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ3MlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODQ3NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODUwMVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODU5MlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg1OTNcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg1OTRcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NTk1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTk2XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMF0sXG4gICAgICAgIFwiODU5N1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiODU5OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODU5OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODYwMFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODYwMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODYzNlwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg2MzdcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NjQwXCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMF0sXG4gICAgICAgIFwiODY0MVwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg2NTZcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NjU3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjU4XCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMF0sXG4gICAgICAgIFwiODY1OVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODY2MFwiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDBdLFxuICAgICAgICBcIjg2NjFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MDRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MDZcIjogWzAsIDAuNjk0NDQsIDAuMDYzODksIDBdLFxuICAgICAgICBcIjg3MDdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MDlcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MTFcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjg3MTJcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3MTVcIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3MjJcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjNcIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjZcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjdcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwXSxcbiAgICAgICAgXCI4NzI4XCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMF0sXG4gICAgICAgIFwiODcyOVwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDBdLFxuICAgICAgICBcIjg3MzBcIjogWzAuMTgsIDAuODIsIDAsIDBdLFxuICAgICAgICBcIjg3MzNcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MzRcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjg3MzZcIjogWzAsIDAuNjkyMjQsIDAsIDBdLFxuICAgICAgICBcIjg3MzlcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3NDFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3NDNcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDRcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDVcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDZcIjogWzAsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjg3NDdcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMTI3NzgsIDBdLFxuICAgICAgICBcIjg3NjRcIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwXSxcbiAgICAgICAgXCI4NzY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzcxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4Nzc2XCI6IFswLjAyNDQ0LCAwLjUyNDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzgxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4ODAxXCI6IFswLjAwMjIyLCAwLjUwMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4ODA0XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODA1XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODEwXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODExXCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODI2XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODI3XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODM0XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODM1XCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODM4XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODM5XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ5XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUwXCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUxXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUyXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUzXCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU0XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU1XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU2XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU3XCI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4OTAwXCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMF0sXG4gICAgICAgIFwiODkwMVwiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDBdLFxuICAgICAgICBcIjg5MDJcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTk0XCI6IFstMC4xMzg4OSwgMC4zNjExMSwgMCwgMF0sXG4gICAgICAgIFwiODk5NVwiOiBbLTAuMTM4ODksIDAuMzYxMTEsIDAsIDBdLFxuICAgICAgICBcIjk2NTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk2NTdcIjogWy0wLjAyNzc4LCAwLjQ3MjIyLCAwLCAwXSxcbiAgICAgICAgXCI5NjYxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjY3XCI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMF0sXG4gICAgICAgIFwiOTcxMVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyNFwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyNVwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyNlwiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgyN1wiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgzN1wiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiOTgzOFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgzOVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyMTZcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEwMjE3XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMDgxNVwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiMTA5MjdcIjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDBdLFxuICAgICAgICBcIjEwOTI4XCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwXVxuICAgIH0sXG4gICAgXCJNYWluLUl0YWxpY1wiOiB7XG4gICAgICAgIFwiMzNcIjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDBdLFxuICAgICAgICBcIjM0XCI6IFswLCAwLjY5NDQ0LCAwLjA2OTYxLCAwXSxcbiAgICAgICAgXCIzNVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNjYxNiwgMF0sXG4gICAgICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAuMTM2MzksIDBdLFxuICAgICAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwXSxcbiAgICAgICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMC4xMjQxNywgMF0sXG4gICAgICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAuMTYxOTQsIDBdLFxuICAgICAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLjAzNjk0LCAwXSxcbiAgICAgICAgXCI0MlwiOiBbMCwgMC43NSwgMC4xNDkxNywgMF0sXG4gICAgICAgIFwiNDNcIjogWzAuMDU2NjcsIDAuNTYxNjcsIDAuMDM2OTQsIDBdLFxuICAgICAgICBcIjQ0XCI6IFswLjE5NDQ0LCAwLjEwNTU2LCAwLCAwXSxcbiAgICAgICAgXCI0NVwiOiBbMCwgMC40MzA1NiwgMC4wMjgyNiwgMF0sXG4gICAgICAgIFwiNDZcIjogWzAsIDAuMTA1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjI1LCAwLjc1LCAwLjE2MTk0LCAwXSxcbiAgICAgICAgXCI0OFwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNDlcIjogWzAsIDAuNjQ0NDQsIDAuMTM1NTYsIDBdLFxuICAgICAgICBcIjUwXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwXSxcbiAgICAgICAgXCI1MVwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNTJcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDBdLFxuICAgICAgICBcIjUzXCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwXSxcbiAgICAgICAgXCI1NFwiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNTVcIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTM1NTYsIDBdLFxuICAgICAgICBcIjU2XCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwXSxcbiAgICAgICAgXCI1N1wiOiBbMCwgMC42NDQ0NCwgMC4xMzU1NiwgMF0sXG4gICAgICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAuMDU4MiwgMF0sXG4gICAgICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDU4MiwgMF0sXG4gICAgICAgIFwiNjFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLjA2NjE2LCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42OTQ0NCwgMC4xMjI1LCAwXSxcbiAgICAgICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMC4wOTU5NywgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4xNDUyOCwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjEyMDI4LCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAuMDg3MjIsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4xNTgwNiwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMTQwMjgsIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wOTQwMywgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTAyNTcsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLjA5NDAzLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMzg2OCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMTE5NzIsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzMzA1LCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xNjM4OSwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMTgzNjEsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjE4MzYxLCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4xNTgwNiwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMTkzODMsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC4yNSwgMC43NSwgMC4xODc1LCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMC4xMDUyOCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAuMDY2NDYsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjMxLCAwLjEyMDU2LCAwLjA5MjA4LCAwXSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAuMDYzMTIsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLjA1NjUzLCAwXSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDBdLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMC4wNzUxNCwgMF0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjIxMTk0LCAwXSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDg4NDcsIDBdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMC4wNzY3MSwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY1NTM2LCAwLjEwMTksIDBdLFxuICAgICAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NTUzNiwgMC4xNDQ2NywgMF0sXG4gICAgICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjEwNzY0LCAwXSxcbiAgICAgICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMTAzMzMsIDBdLFxuICAgICAgICBcIjEwOVwiOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMF0sXG4gICAgICAgIFwiMTEwXCI6IFswLCAwLjQzMDU2LCAwLjA3NjcxLCAwXSxcbiAgICAgICAgXCIxMTFcIjogWzAsIDAuNDMwNTYsIDAuMDYzMTIsIDBdLFxuICAgICAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNjMxMiwgMF0sXG4gICAgICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA4ODQ3LCAwXSxcbiAgICAgICAgXCIxMTRcIjogWzAsIDAuNDMwNTYsIDAuMTA3NjQsIDBdLFxuICAgICAgICBcIjExNVwiOiBbMCwgMC40MzA1NiwgMC4wODIwOCwgMF0sXG4gICAgICAgIFwiMTE2XCI6IFswLCAwLjYxNTA4LCAwLjA5NDg2LCAwXSxcbiAgICAgICAgXCIxMTdcIjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDBdLFxuICAgICAgICBcIjExOFwiOiBbMCwgMC40MzA1NiwgMC4xMDc2NCwgMF0sXG4gICAgICAgIFwiMTE5XCI6IFswLCAwLjQzMDU2LCAwLjEwNzY0LCAwXSxcbiAgICAgICAgXCIxMjBcIjogWzAsIDAuNDMwNTYsIDAuMTIwNDIsIDBdLFxuICAgICAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wODg0NywgMF0sXG4gICAgICAgIFwiMTIyXCI6IFswLCAwLjQzMDU2LCAwLjEyMjkyLCAwXSxcbiAgICAgICAgXCIxMjZcIjogWzAuMzUsIDAuMzE3ODYsIDAuMTE1ODUsIDBdLFxuICAgICAgICBcIjE2M1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzA1XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjc2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzY5XCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuNjk0NDQsIDAuMDY2NDYsIDBdLFxuICAgICAgICBcIjc3MVwiOiBbMCwgMC42Njc4NiwgMC4xMTU4NSwgMF0sXG4gICAgICAgIFwiNzcyXCI6IFswLCAwLjU2MTY3LCAwLjEwMzMzLCAwXSxcbiAgICAgICAgXCI3NzRcIjogWzAsIDAuNjk0NDQsIDAuMTA4MDYsIDBdLFxuICAgICAgICBcIjc3NVwiOiBbMCwgMC42Njc4NiwgMC4xMTc1MiwgMF0sXG4gICAgICAgIFwiNzc2XCI6IFswLCAwLjY2Nzg2LCAwLjEwNDc0LCAwXSxcbiAgICAgICAgXCI3NzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3OVwiOiBbMCwgMC42OTQ0NCwgMC4xMjI1LCAwXSxcbiAgICAgICAgXCI3ODBcIjogWzAsIDAuNjI4NDcsIDAuMDgyOTUsIDBdLFxuICAgICAgICBcIjkxNVwiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMF0sXG4gICAgICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAuMDk0MDMsIDBdLFxuICAgICAgICBcIjkyM1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLjE1Mjk0LCAwXSxcbiAgICAgICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDBdLFxuICAgICAgICBcIjkzMVwiOiBbMCwgMC42ODMzMywgMC4xMjAyOCwgMF0sXG4gICAgICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLjExMTExLCAwXSxcbiAgICAgICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAuMDU5ODYsIDBdLFxuICAgICAgICBcIjkzNlwiOiBbMCwgMC42ODMzMywgMC4xMTExMSwgMF0sXG4gICAgICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwXSxcbiAgICAgICAgXCI4MjExXCI6IFswLCAwLjQzMDU2LCAwLjA5MjA4LCAwXSxcbiAgICAgICAgXCI4MjEyXCI6IFswLCAwLjQzMDU2LCAwLjA5MjA4LCAwXSxcbiAgICAgICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwXSxcbiAgICAgICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwXSxcbiAgICAgICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLjE2ODUsIDBdLFxuICAgICAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAuMDY5NjEsIDBdLFxuICAgICAgICBcIjg0NjNcIjogWzAsIDAuNjg4ODksIDAsIDBdXG4gICAgfSxcbiAgICBcIk1haW4tUmVndWxhclwiOiB7XG4gICAgICAgIFwiMzJcIjogWzAsIDAsIDAsIDBdLFxuICAgICAgICBcIjMzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM2XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIzN1wiOiBbMC4wNTU1NiwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0MFwiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQyXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0M1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNDRcIjogWzAuMTk0NDQsIDAuMTA1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI0NlwiOiBbMCwgMC4xMDU1NiwgMCwgMF0sXG4gICAgICAgIFwiNDdcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQ4XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0OVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTBcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjUxXCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1MlwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTNcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU0XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1NVwiOiBbMCwgMC42NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTZcIjogWzAsIDAuNjQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjU3XCI6IFswLCAwLjY0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1OFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNTlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjYwXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiNjFcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI2MlwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjYzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI2NFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMDI1LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjkyXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjMxLCAwLjEyMDU2LCAwLjAyNzc4LCAwXSxcbiAgICAgICAgXCI5NlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjk4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTAwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEwMlwiOiBbMCwgMC42OTQ0NCwgMC4wNzc3OCwgMF0sXG4gICAgICAgIFwiMTAzXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMDRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwNVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiMTA2XCI6IFswLjE5NDQ0LCAwLjY2Nzg2LCAwLCAwXSxcbiAgICAgICAgXCIxMDdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwOFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNjE1MDgsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTI0XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEyNlwiOiBbMC4zNSwgMC4zMTc4NiwgMCwgMF0sXG4gICAgICAgIFwiMTYwXCI6IFswLCAwLCAwLCAwXSxcbiAgICAgICAgXCIxNjhcIjogWzAsIDAuNjY3ODYsIDAsIDBdLFxuICAgICAgICBcIjE3MlwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTc1XCI6IFswLCAwLjU2Nzc4LCAwLCAwXSxcbiAgICAgICAgXCIxNzZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjE3N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMF0sXG4gICAgICAgIFwiMTgwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIyMTVcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjI0N1wiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMF0sXG4gICAgICAgIFwiMzA1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI1NjdcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjcxMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzExXCI6IFswLCAwLjYyODQ3LCAwLCAwXSxcbiAgICAgICAgXCI3MTNcIjogWzAsIDAuNTY3NzgsIDAsIDBdLFxuICAgICAgICBcIjcxNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MjhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcyOVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiNzMwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNjY3ODYsIDAsIDBdLFxuICAgICAgICBcIjc2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3MVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiNzcyXCI6IFswLCAwLjU2Nzc4LCAwLCAwXSxcbiAgICAgICAgXCI3NzRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3NVwiOiBbMCwgMC42Njc4NiwgMCwgMF0sXG4gICAgICAgIFwiNzc2XCI6IFswLCAwLjY2Nzg2LCAwLCAwXSxcbiAgICAgICAgXCI3NzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc3OVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzgwXCI6IFswLCAwLjYyODQ3LCAwLCAwXSxcbiAgICAgICAgXCI4MjRcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkxNVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTE2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MjBcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjkyM1wiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTI2XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MjhcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjkzMVwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTMzXCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI5MzRcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjkzNlwiOiBbMCwgMC42ODMzMywgMCwgMF0sXG4gICAgICAgIFwiOTM3XCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4MjExXCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwXSxcbiAgICAgICAgXCI4MjEyXCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwXSxcbiAgICAgICAgXCI4MjE2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjE3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjIwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjIxXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjI0XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjI1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MjMwXCI6IFswLCAwLjEyLCAwLCAwXSxcbiAgICAgICAgXCI4MjQyXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NDA3XCI6IFswLCAwLjcxNDQ0LCAwLjE1MzgyLCAwXSxcbiAgICAgICAgXCI4NDYzXCI6IFswLCAwLjY4ODg5LCAwLCAwXSxcbiAgICAgICAgXCI4NDY1XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NDY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwLjExMTExXSxcbiAgICAgICAgXCI4NDcyXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjExMTExXSxcbiAgICAgICAgXCI4NDc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTAxXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTkyXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODU5M1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODU5NFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg1OTVcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg1OTZcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NTk3XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NTk4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NTk5XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjAwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjAxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NjE0XCI6IFswLjAxMSwgMC41MTEsIDAsIDBdLFxuICAgICAgICBcIjg2MTdcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiODYxOFwiOiBbMC4wMTEsIDAuNTExLCAwLCAwXSxcbiAgICAgICAgXCI4NjM2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODYzN1wiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg2NDBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjQxXCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODY1MlwiOiBbMC4wMTEsIDAuNjcxLCAwLCAwXSxcbiAgICAgICAgXCI4NjU2XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODY1N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODY1OFwiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDBdLFxuICAgICAgICBcIjg2NTlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg2NjBcIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwXSxcbiAgICAgICAgXCI4NjYxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzA2XCI6IFswLCAwLjY5NDQ0LCAwLjA1NTU2LCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NzA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NzA5XCI6IFswLjA1NTU2LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzExXCI6IFswLCAwLjY4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4NzEyXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiODcxNVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg3MjJcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjg3MjVcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjZcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjdcIjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwXSxcbiAgICAgICAgXCI4NzI4XCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMF0sXG4gICAgICAgIFwiODcyOVwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDBdLFxuICAgICAgICBcIjg3MzBcIjogWzAuMiwgMC44LCAwLCAwXSxcbiAgICAgICAgXCI4NzMzXCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzM0XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzM2XCI6IFswLCAwLjY5MjI0LCAwLCAwXSxcbiAgICAgICAgXCI4NzM5XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzQxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzQzXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ0XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ1XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ3XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMTExLCAwXSxcbiAgICAgICAgXCI4NzY0XCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMF0sXG4gICAgICAgIFwiODc2OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODc3MVwiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDBdLFxuICAgICAgICBcIjg3NzNcIjogWy0wLjAyMiwgMC41ODksIDAsIDBdLFxuICAgICAgICBcIjg3NzZcIjogWy0wLjAxNjg4LCAwLjQ4MzEyLCAwLCAwXSxcbiAgICAgICAgXCI4NzgxXCI6IFstMC4wMzYyNSwgMC40NjM3NSwgMCwgMF0sXG4gICAgICAgIFwiODc4NFwiOiBbLTAuMTMzLCAwLjY3LCAwLCAwXSxcbiAgICAgICAgXCI4ODAwXCI6IFswLjIxNSwgMC43MTYsIDAsIDBdLFxuICAgICAgICBcIjg4MDFcIjogWy0wLjAzNjI1LCAwLjQ2Mzc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODA0XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODA1XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODEwXCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiODgxMVwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg4MjZcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwXSxcbiAgICAgICAgXCI4ODI3XCI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMF0sXG4gICAgICAgIFwiODgzNFwiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDBdLFxuICAgICAgICBcIjg4MzVcIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwXSxcbiAgICAgICAgXCI4ODM4XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODM5XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ2XCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODQ5XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUwXCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCI4ODUxXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUyXCI6IFswLCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI4ODUzXCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU0XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU1XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU2XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODU3XCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI4ODY2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODY5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4ODcyXCI6IFswLjI0OSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiODkwMFwiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDBdLFxuICAgICAgICBcIjg5MDFcIjogWy0wLjA1NTU1LCAwLjQ0NDQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTAyXCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMF0sXG4gICAgICAgIFwiODkwNFwiOiBbMC4wMDUsIDAuNTA1LCAwLCAwXSxcbiAgICAgICAgXCI4OTQyXCI6IFswLjAzLCAwLjksIDAsIDBdLFxuICAgICAgICBcIjg5NDNcIjogWy0wLjE5LCAwLjMxLCAwLCAwXSxcbiAgICAgICAgXCI4OTQ1XCI6IFstMC4xLCAwLjgyLCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTk0XCI6IFstMC4xNDIzNiwgMC4zNTc2NCwgMCwgMF0sXG4gICAgICAgIFwiODk5NVwiOiBbLTAuMTQyMzYsIDAuMzU3NjQsIDAsIDBdLFxuICAgICAgICBcIjkxMzZcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMF0sXG4gICAgICAgIFwiOTEzN1wiOiBbMC4yNDQsIDAuNzQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjUxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjU3XCI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMF0sXG4gICAgICAgIFwiOTY2MVwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTY2N1wiOiBbLTAuMDM0NzIsIDAuNDY1MjgsIDAsIDBdLFxuICAgICAgICBcIjk3MTFcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjRcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjVcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjZcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MjdcIjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MzdcIjogWzAsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjk4MzhcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk4MzlcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMjE2XCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxN1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMjJcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyMjNcIjogWzAuMjQ0LCAwLjc0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyMjlcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzBcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzFcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzJcIjogWzAuMDI0LCAwLjUyNSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzNcIjogWzAuMDI0LCAwLjUyNSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzRcIjogWzAuMDI0LCAwLjUyNSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMzZcIjogWzAuMDExLCAwLjUxMSwgMCwgMF0sXG4gICAgICAgIFwiMTA4MTVcIjogWzAsIDAuNjgzMzMsIDAsIDBdLFxuICAgICAgICBcIjEwOTI3XCI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwXSxcbiAgICAgICAgXCIxMDkyOFwiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMF1cbiAgICB9LFxuICAgIFwiTWF0aC1Cb2xkSXRhbGljXCI6IHtcbiAgICAgICAgXCI0N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4NjExLCAwLjA0ODM1LCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODYxMSwgMC4wNjk3OSwgMF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjg2MTEsIDAuMDMxOTQsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4NjExLCAwLjA1NDUxLCAwXSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4NjExLCAwLjA4MjI5LCAwXSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODYxMSwgMC4wNzc3OCwgMF0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjg2MTEsIDAuMTAwNjksIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwXSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjg2MTEsIDAuMTE0MjQsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4NjExLCAwLjExNDI0LCAwXSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODYxMSwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDBdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODYxMSwgMC4wMDQyMSwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjg2MTEsIDAuMDUzODIsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODYxMSwgMC4xMTQyNCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjg2MTEsIDAuMjU1NTUsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODYxMSwgMC4wNzc3OCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjg2MTEsIDAuMjU1NTUsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwXSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMDQyLCAwXSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY5MzI2LCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjkzMjYsIDAuMDYyMiwgMF0sXG4gICAgICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLjAxODUyLCAwXSxcbiAgICAgICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAuMDA4OCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40NDQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNjM0OTIsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDQ0NDQsIDAuMDQyMTMsIDBdLFxuICAgICAgICBcIjkxNVwiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMF0sXG4gICAgICAgIFwiOTE2XCI6IFswLCAwLjY4NjExLCAwLCAwXSxcbiAgICAgICAgXCI5MjBcIjogWzAsIDAuNjg2MTEsIDAuMDMxOTQsIDBdLFxuICAgICAgICBcIjkyM1wiOiBbMCwgMC42ODYxMSwgMCwgMF0sXG4gICAgICAgIFwiOTI2XCI6IFswLCAwLjY4NjExLCAwLjA3NDU4LCAwXSxcbiAgICAgICAgXCI5MjhcIjogWzAsIDAuNjg2MTEsIDAuMDgyMjksIDBdLFxuICAgICAgICBcIjkzMVwiOiBbMCwgMC42ODYxMSwgMC4wNTQ1MSwgMF0sXG4gICAgICAgIFwiOTMzXCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwXSxcbiAgICAgICAgXCI5MzRcIjogWzAsIDAuNjg2MTEsIDAsIDBdLFxuICAgICAgICBcIjkzNlwiOiBbMCwgMC42ODYxMSwgMC4xMTY1MywgMF0sXG4gICAgICAgIFwiOTM3XCI6IFswLCAwLjY4NjExLCAwLjA0ODM1LCAwXSxcbiAgICAgICAgXCI5NDVcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk0NlwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzQwMywgMF0sXG4gICAgICAgIFwiOTQ3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA2Mzg5LCAwXSxcbiAgICAgICAgXCI5NDhcIjogWzAsIDAuNjk0NDQsIDAuMDM4MTksIDBdLFxuICAgICAgICBcIjk0OVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTUwXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA2MjE1LCAwXSxcbiAgICAgICAgXCI5NTFcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk1MlwiOiBbMCwgMC42OTQ0NCwgMC4wMzE5NCwgMF0sXG4gICAgICAgIFwiOTUzXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NTRcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTU2XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NTdcIjogWzAsIDAuNDQ0NDQsIDAuMDY4OTgsIDBdLFxuICAgICAgICBcIjk1OFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzAyMSwgMF0sXG4gICAgICAgIFwiOTU5XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5NjBcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk2MVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTYyXCI6IFswLjA5NzIyLCAwLjQ0NDQ0LCAwLjA3OTE3LCAwXSxcbiAgICAgICAgXCI5NjNcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk2NFwiOiBbMCwgMC40NDQ0NCwgMC4xMzQ3MiwgMF0sXG4gICAgICAgIFwiOTY1XCI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNzA0LCAwXSxcbiAgICAgICAgXCI5NjlcIjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDBdLFxuICAgICAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5ODJcIjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDBdLFxuICAgICAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMTNcIjogWzAsIDAuNDQ0NDQsIDAsIDBdXG4gICAgfSxcbiAgICBcIk1hdGgtSXRhbGljXCI6IHtcbiAgICAgICAgXCI0N1wiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODldLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0XSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDU1NTZdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjA4MTI1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4xMTExMV0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMDk2MTgsIDAuMTY2NjddLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA1NTU2XSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzRdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzRdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMDc3MywgMC4wODMzNF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzRdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wMjc3OF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4wODMzNF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEwNzY0LCAwLjE2NjY3XSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY1OTUyLCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjU5NTIsIDAuMDU3MjQsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wMzE0OCwgMF0sXG4gICAgICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjAxOTY4LCAwLjA4MzM0XSxcbiAgICAgICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdLFxuICAgICAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4wMjY5MSwgMC4wODMzNF0sXG4gICAgICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDU1NTZdLFxuICAgICAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMC4wNDM5OCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3XSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjgzMzMsIDAuMDc1NjksIDAuMDgzMzRdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDU1NTZdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExLCAwLjA1NTU2XSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjgzMzMsIDAuMDUwMTcsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0NVwiOiBbMCwgMC40MzA1NiwgMC4wMDM3LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUyNzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTU1NiwgMF0sXG4gICAgICAgIFwiOTQ4XCI6IFswLCAwLjY5NDQ0LCAwLjAzNzg1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NDlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNzM3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDI3NzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1M1wiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTU0XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI5NTVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1NlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTU3XCI6IFswLCAwLjQzMDU2LCAwLjA2MzY2LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDQ2MDEsIDAuMTExMTFdLFxuICAgICAgICBcIjk1OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTYwXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40MzA1NiwgMC4wNzk4NiwgMC4wODMzNF0sXG4gICAgICAgIFwiOTYzXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjRcIjogWzAsIDAuNDMwNTYsIDAuMTEzMiwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTY1XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNTg4LCAwLjExMTExXSxcbiAgICAgICAgXCI5NjlcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDBdLFxuICAgICAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5ODJcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjEwMTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdXG4gICAgfSxcbiAgICBcIk1hdGgtUmVndWxhclwiOiB7XG4gICAgICAgIFwiNjVcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTM4ODldLFxuICAgICAgICBcIjY2XCI6IFswLCAwLjY4MzMzLCAwLjA1MDE3LCAwLjA4MzM0XSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNF0sXG4gICAgICAgIFwiNjhcIjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDU1NTZdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI3MFwiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNF0sXG4gICAgICAgIFwiNzFcIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjY4MzMzLCAwLjA4MTI1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI3M1wiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4xMTExMV0sXG4gICAgICAgIFwiNzRcIjogWzAsIDAuNjgzMzMsIDAuMDk2MTgsIDAuMTY2NjddLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA1NTU2XSxcbiAgICAgICAgXCI3NlwiOiBbMCwgMC42ODMzMywgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiNzdcIjogWzAsIDAuNjgzMzMsIDAuMTA5MDMsIDAuMDgzMzRdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI3OVwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDgzMzRdLFxuICAgICAgICBcIjgxXCI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42ODMzMywgMC4wMDc3MywgMC4wODMzNF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzRdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wMjc3OF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4wODMzNF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjgzMzMsIDAuMjIyMjIsIDBdLFxuICAgICAgICBcIjkwXCI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5N1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiOThcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk5XCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMDBcIjogWzAsIDAuNjk0NDQsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjEwMVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiMTAyXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjEwNzY0LCAwLjE2NjY3XSxcbiAgICAgICAgXCIxMDNcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjEwNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTA1XCI6IFswLCAwLjY1OTUyLCAwLCAwXSxcbiAgICAgICAgXCIxMDZcIjogWzAuMTk0NDQsIDAuNjU5NTIsIDAuMDU3MjQsIDBdLFxuICAgICAgICBcIjEwN1wiOiBbMCwgMC42OTQ0NCwgMC4wMzE0OCwgMF0sXG4gICAgICAgIFwiMTA4XCI6IFswLCAwLjY5NDQ0LCAwLjAxOTY4LCAwLjA4MzM0XSxcbiAgICAgICAgXCIxMDlcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTExXCI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTJcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjExM1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE0XCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLjA1NTU2XSxcbiAgICAgICAgXCIxMTVcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdLFxuICAgICAgICBcIjExNlwiOiBbMCwgMC42MTUwOCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiMTE3XCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMThcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzhdLFxuICAgICAgICBcIjExOVwiOiBbMCwgMC40MzA1NiwgMC4wMjY5MSwgMC4wODMzNF0sXG4gICAgICAgIFwiMTIwXCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4XSxcbiAgICAgICAgXCIxMjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDU1NTZdLFxuICAgICAgICBcIjEyMlwiOiBbMCwgMC40MzA1NiwgMC4wNDM5OCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjddLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjY4MzMzLCAwLCAwLjE2NjY3XSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjgzMzMsIDAuMDc1NjksIDAuMDgzMzRdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42ODMzMywgMC4wODEyNSwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjY4MzMzLCAwLjA1NzY0LCAwLjA4MzM0XSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDU1NTZdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42ODMzMywgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjY4MzMzLCAwLjExLCAwLjA1NTU2XSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjgzMzMsIDAuMDUwMTcsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0NVwiOiBbMCwgMC40MzA1NiwgMC4wMDM3LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NDZcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDUyNzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk0N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTU1NiwgMF0sXG4gICAgICAgIFwiOTQ4XCI6IFswLCAwLjY5NDQ0LCAwLjAzNzg1LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NDlcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1MFwiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNzM3OCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTUxXCI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAzNTg4LCAwLjA1NTU2XSxcbiAgICAgICAgXCI5NTJcIjogWzAsIDAuNjk0NDQsIDAuMDI3NzgsIDAuMDgzMzRdLFxuICAgICAgICBcIjk1M1wiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTU0XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI5NTVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjk1NlwiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTU3XCI6IFswLCAwLjQzMDU2LCAwLjA2MzY2LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NThcIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDQ2MDEsIDAuMTExMTFdLFxuICAgICAgICBcIjk1OVwiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTYwXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjFcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2MlwiOiBbMC4wOTcyMiwgMC40MzA1NiwgMC4wNzk4NiwgMC4wODMzNF0sXG4gICAgICAgIFwiOTYzXCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwXSxcbiAgICAgICAgXCI5NjRcIjogWzAsIDAuNDMwNTYsIDAuMTEzMiwgMC4wMjc3OF0sXG4gICAgICAgIFwiOTY1XCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLjAyNzc4XSxcbiAgICAgICAgXCI5NjZcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjk2N1wiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wNTU1Nl0sXG4gICAgICAgIFwiOTY4XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjAzNTg4LCAwLjExMTExXSxcbiAgICAgICAgXCI5NjlcIjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDBdLFxuICAgICAgICBcIjk3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMC4wODMzNF0sXG4gICAgICAgIFwiOTgxXCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLjA4MzM0XSxcbiAgICAgICAgXCI5ODJcIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjEwMDlcIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzRdLFxuICAgICAgICBcIjEwMTNcIjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTZdXG4gICAgfSxcbiAgICBcIlNhbnNTZXJpZi1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCIzM1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzRcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjM1XCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzNlwiOiBbMC4wNTU1NiwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMzdcIjogWzAuMDU1NTYsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjM4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzOVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNDBcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjQxXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0MlwiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDNcIjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDBdLFxuICAgICAgICBcIjQ0XCI6IFswLjEyNSwgMC4wODMzMywgMCwgMF0sXG4gICAgICAgIFwiNDVcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjQ2XCI6IFswLCAwLjA4MzMzLCAwLCAwXSxcbiAgICAgICAgXCI0N1wiOiBbMC4yNSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNDhcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjQ5XCI6IFswLCAwLjY1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI1MFwiOiBbMCwgMC42NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNTFcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjUyXCI6IFswLCAwLjY1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI1M1wiOiBbMCwgMC42NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNTRcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjU1XCI6IFswLCAwLjY1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI1NlwiOiBbMCwgMC42NTU1NiwgMCwgMF0sXG4gICAgICAgIFwiNTdcIjogWzAsIDAuNjU1NTYsIDAsIDBdLFxuICAgICAgICBcIjU4XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI1OVwiOiBbMC4xMjUsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjYxXCI6IFstMC4xMywgMC4zNywgMCwgMF0sXG4gICAgICAgIFwiNjNcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjY0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI2NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjY3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI2OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNjlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3MVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzJcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjczXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzVcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3N1wiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc5XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODFcIjogWzAuMTI1LCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4MlwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjg0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI4NVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNjk0NDQsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjg3XCI6IFswLCAwLjY5NDQ0LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCI4OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNjk0NDQsIDAuMDI1LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMjUsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjI1LCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5NFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTVcIjogWzAuMzUsIDAuMDk0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjk3XCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5OFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTlcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTAxXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDJcIjogWzAsIDAuNjk0NDQsIDAuMDY5NDQsIDBdLFxuICAgICAgICBcIjEwM1wiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTM4OSwgMF0sXG4gICAgICAgIFwiMTA0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDVcIjogWzAsIDAuNjc5MzcsIDAsIDBdLFxuICAgICAgICBcIjEwNlwiOiBbMC4xOTQ0NCwgMC42NzkzNywgMCwgMF0sXG4gICAgICAgIFwiMTA3XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMDhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEwOVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEwXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTFcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExMlwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTEzXCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMTRcIjogWzAsIDAuNDQ0NDQsIDAuMDEzODksIDBdLFxuICAgICAgICBcIjExNVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTE2XCI6IFswLCAwLjU3MTQzLCAwLCAwXSxcbiAgICAgICAgXCIxMTdcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjExOFwiOiBbMCwgMC40NDQ0NCwgMC4wMTM4OSwgMF0sXG4gICAgICAgIFwiMTE5XCI6IFswLCAwLjQ0NDQ0LCAwLjAxMzg5LCAwXSxcbiAgICAgICAgXCIxMjBcIjogWzAsIDAuNDQ0NDQsIDAsIDBdLFxuICAgICAgICBcIjEyMVwiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTM4OSwgMF0sXG4gICAgICAgIFwiMTIyXCI6IFswLCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMjZcIjogWzAuMzUsIDAuMzI2NTksIDAsIDBdLFxuICAgICAgICBcIjMwNVwiOiBbMCwgMC40NDQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNTY3XCI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NjhcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc2OVwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNzcwXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuNjc2NTksIDAsIDBdLFxuICAgICAgICBcIjc3MlwiOiBbMCwgMC42MDg4OSwgMCwgMF0sXG4gICAgICAgIFwiNzc0XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzVcIjogWzAsIDAuNjc5MzcsIDAsIDBdLFxuICAgICAgICBcIjc3NlwiOiBbMCwgMC42NzkzNywgMCwgMF0sXG4gICAgICAgIFwiNzc4XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI3NzlcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjc4MFwiOiBbMCwgMC42MzE5NCwgMCwgMF0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMTFcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjgyMTJcIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDBdLFxuICAgICAgICBcIjgyMTZcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMTdcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMjBcIjogWzAsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjgyMjFcIjogWzAsIDAuNjk0NDQsIDAsIDBdXG4gICAgfSxcbiAgICBcIlNjcmlwdC1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI2NVwiOiBbMCwgMC43LCAwLjIyOTI1LCAwXSxcbiAgICAgICAgXCI2NlwiOiBbMCwgMC43LCAwLjA0MDg3LCAwXSxcbiAgICAgICAgXCI2N1wiOiBbMCwgMC43LCAwLjE2ODksIDBdLFxuICAgICAgICBcIjY4XCI6IFswLCAwLjcsIDAuMDkzNzEsIDBdLFxuICAgICAgICBcIjY5XCI6IFswLCAwLjcsIDAuMTg1ODMsIDBdLFxuICAgICAgICBcIjcwXCI6IFswLCAwLjcsIDAuMTM2MzQsIDBdLFxuICAgICAgICBcIjcxXCI6IFswLCAwLjcsIDAuMTczMjIsIDBdLFxuICAgICAgICBcIjcyXCI6IFswLCAwLjcsIDAuMjk2OTQsIDBdLFxuICAgICAgICBcIjczXCI6IFswLCAwLjcsIDAuMTkxODksIDBdLFxuICAgICAgICBcIjc0XCI6IFswLjI3Nzc4LCAwLjcsIDAuMTkxODksIDBdLFxuICAgICAgICBcIjc1XCI6IFswLCAwLjcsIDAuMzEyNTksIDBdLFxuICAgICAgICBcIjc2XCI6IFswLCAwLjcsIDAuMTkxODksIDBdLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjcsIDAuMTU5ODEsIDBdLFxuICAgICAgICBcIjc4XCI6IFswLCAwLjcsIDAuMzUyNSwgMF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNywgMC4wODA3OCwgMF0sXG4gICAgICAgIFwiODBcIjogWzAsIDAuNywgMC4wODA3OCwgMF0sXG4gICAgICAgIFwiODFcIjogWzAsIDAuNywgMC4wMzMwNSwgMF0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNywgMC4wNjI1OSwgMF0sXG4gICAgICAgIFwiODNcIjogWzAsIDAuNywgMC4xOTE4OSwgMF0sXG4gICAgICAgIFwiODRcIjogWzAsIDAuNywgMC4yOTA4NywgMF0sXG4gICAgICAgIFwiODVcIjogWzAsIDAuNywgMC4yNTgxNSwgMF0sXG4gICAgICAgIFwiODZcIjogWzAsIDAuNywgMC4yNzUyMywgMF0sXG4gICAgICAgIFwiODdcIjogWzAsIDAuNywgMC4yNzUyMywgMF0sXG4gICAgICAgIFwiODhcIjogWzAsIDAuNywgMC4yNjAwNiwgMF0sXG4gICAgICAgIFwiODlcIjogWzAsIDAuNywgMC4yOTM5LCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC43LCAwLjI0MDM3LCAwXVxuICAgIH0sXG4gICAgXCJTaXplMS1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI0MFwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiOTJcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCIxMjNcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjEyNVwiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiNzEwXCI6IFswLCAwLjcyMjIyLCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNzIyMjIsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC43MjIyMiwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjcyMjIyLCAwLCAwXSxcbiAgICAgICAgXCI4MjE0XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDBdLFxuICAgICAgICBcIjg1OTNcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg1OTVcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg2NTdcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg2NTlcIjogWzFlLTA1LCAwLjYsIDAsIDBdLFxuICAgICAgICBcIjg3MTlcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjBcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MjFcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjg3MzBcIjogWzAuMzUwMDEsIDAuODUsIDAsIDBdLFxuICAgICAgICBcIjg3MzlcIjogWy0wLjAwNTk5LCAwLjYwNiwgMCwgMF0sXG4gICAgICAgIFwiODc0MVwiOiBbLTAuMDA1OTksIDAuNjA2LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ3XCI6IFswLjMwNjEyLCAwLjgwNSwgMC4xOTQ0NSwgMF0sXG4gICAgICAgIFwiODc0OFwiOiBbMC4zMDYsIDAuODA1LCAwLjE5NDQ1LCAwXSxcbiAgICAgICAgXCI4NzQ5XCI6IFswLjMwNiwgMC44MDUsIDAuMTk0NDUsIDBdLFxuICAgICAgICBcIjg3NTBcIjogWzAuMzA2MTIsIDAuODA1LCAwLjE5NDQ1LCAwXSxcbiAgICAgICAgXCI4ODk2XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODk3XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODk4XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4ODk5XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCI5MTY4XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDBdLFxuICAgICAgICBcIjEwMjE2XCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxN1wiOiBbMC4zNTAwMSwgMC44NSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTJcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEwNzUzXCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCIxMDc1NFwiOiBbMC4yNTAwMSwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTZcIjogWzAuMjUwMDEsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjEwNzU4XCI6IFswLjI1MDAxLCAwLjc1LCAwLCAwXVxuICAgIH0sXG4gICAgXCJTaXplMi1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI0MFwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiOTJcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCIxMjNcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjEyNVwiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiNzEwXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzE5XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCI4NzIwXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCI4NzIxXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCI4NzMwXCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCI4NzQ3XCI6IFswLjg2MjI1LCAxLjM2LCAwLjQ0NDQ1LCAwXSxcbiAgICAgICAgXCI4NzQ4XCI6IFswLjg2MiwgMS4zNiwgMC40NDQ0NSwgMF0sXG4gICAgICAgIFwiODc0OVwiOiBbMC44NjIsIDEuMzYsIDAuNDQ0NDUsIDBdLFxuICAgICAgICBcIjg3NTBcIjogWzAuODYyMjUsIDEuMzYsIDAuNDQ0NDUsIDBdLFxuICAgICAgICBcIjg4OTZcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg4OTdcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg4OThcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg4OTlcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjg5NjhcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjg5NjlcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjg5NzBcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjg5NzFcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjEwMjE2XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxN1wiOiBbMC42NTAwMiwgMS4xNSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTJcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjEwNzUzXCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXSxcbiAgICAgICAgXCIxMDc1NFwiOiBbMC41NTAwMSwgMS4wNSwgMCwgMF0sXG4gICAgICAgIFwiMTA3NTZcIjogWzAuNTUwMDEsIDEuMDUsIDAsIDBdLFxuICAgICAgICBcIjEwNzU4XCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwXVxuICAgIH0sXG4gICAgXCJTaXplMy1SZWd1bGFyXCI6IHtcbiAgICAgICAgXCI0MFwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI5MVwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiOTJcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdLFxuICAgICAgICBcIjkzXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCIxMjNcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdLFxuICAgICAgICBcIjEyNVwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiNzEwXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuNzUsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC43NSwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4NzMwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxNlwiOiBbMC45NTAwMywgMS40NSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMTdcIjogWzAuOTUwMDMsIDEuNDUsIDAsIDBdXG4gICAgfSxcbiAgICBcIlNpemU0LVJlZ3VsYXJcIjoge1xuICAgICAgICBcIjQwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI0MVwiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiNDdcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDBdLFxuICAgICAgICBcIjkxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5MlwiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiOTNcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiMTI1XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI3MTBcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3MzJcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3NzBcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI3NzFcIjogWzAsIDAuODI1LCAwLCAwXSxcbiAgICAgICAgXCI4NzMwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY4XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTY5XCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcwXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI4OTcxXCI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwXSxcbiAgICAgICAgXCI5MTE1XCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMF0sXG4gICAgICAgIFwiOTExNlwiOiBbMWUtMDUsIDAuNiwgMCwgMF0sXG4gICAgICAgIFwiOTExN1wiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDBdLFxuICAgICAgICBcIjkxMThcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwXSxcbiAgICAgICAgXCI5MTE5XCI6IFsxZS0wNSwgMC42LCAwLCAwXSxcbiAgICAgICAgXCI5MTIwXCI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMF0sXG4gICAgICAgIFwiOTEyMVwiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDBdLFxuICAgICAgICBcIjkxMjJcIjogWy0wLjAwMDk5LCAwLjYwMSwgMCwgMF0sXG4gICAgICAgIFwiOTEyM1wiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDBdLFxuICAgICAgICBcIjkxMjRcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwXSxcbiAgICAgICAgXCI5MTI1XCI6IFstMC4wMDA5OSwgMC42MDEsIDAsIDBdLFxuICAgICAgICBcIjkxMjZcIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwXSxcbiAgICAgICAgXCI5MTI3XCI6IFsxZS0wNSwgMC45LCAwLCAwXSxcbiAgICAgICAgXCI5MTI4XCI6IFswLjY1MDAyLCAxLjE1LCAwLCAwXSxcbiAgICAgICAgXCI5MTI5XCI6IFswLjkwMDAxLCAwLCAwLCAwXSxcbiAgICAgICAgXCI5MTMwXCI6IFswLCAwLjMsIDAsIDBdLFxuICAgICAgICBcIjkxMzFcIjogWzFlLTA1LCAwLjksIDAsIDBdLFxuICAgICAgICBcIjkxMzJcIjogWzAuNjUwMDIsIDEuMTUsIDAsIDBdLFxuICAgICAgICBcIjkxMzNcIjogWzAuOTAwMDEsIDAsIDAsIDBdLFxuICAgICAgICBcIjkxNDNcIjogWzAuODg1MDIsIDAuOTE1LCAwLCAwXSxcbiAgICAgICAgXCIxMDIxNlwiOiBbMS4yNTAwMywgMS43NSwgMCwgMF0sXG4gICAgICAgIFwiMTAyMTdcIjogWzEuMjUwMDMsIDEuNzUsIDAsIDBdLFxuICAgICAgICBcIjU3MzQ0XCI6IFstMC4wMDQ5OSwgMC42MDUsIDAsIDBdLFxuICAgICAgICBcIjU3MzQ1XCI6IFstMC4wMDQ5OSwgMC42MDUsIDAsIDBdLFxuICAgICAgICBcIjU3NjgwXCI6IFswLCAwLjEyLCAwLCAwXSxcbiAgICAgICAgXCI1NzY4MVwiOiBbMCwgMC4xMiwgMCwgMF0sXG4gICAgICAgIFwiNTc2ODJcIjogWzAsIDAuMTIsIDAsIDBdLFxuICAgICAgICBcIjU3NjgzXCI6IFswLCAwLjEyLCAwLCAwXVxuICAgIH0sXG4gICAgXCJUeXBld3JpdGVyLVJlZ3VsYXJcIjoge1xuICAgICAgICBcIjMzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIzNFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMzVcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjM2XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIzN1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMzhcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjM5XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI0MFwiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiNDFcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjQyXCI6IFswLCAwLjUyMDgzLCAwLCAwXSxcbiAgICAgICAgXCI0M1wiOiBbLTAuMDgwNTYsIDAuNTMwNTUsIDAsIDBdLFxuICAgICAgICBcIjQ0XCI6IFswLjEzODg5LCAwLjEyNSwgMCwgMF0sXG4gICAgICAgIFwiNDVcIjogWy0wLjA4MDU2LCAwLjUzMDU1LCAwLCAwXSxcbiAgICAgICAgXCI0NlwiOiBbMCwgMC4xMjUsIDAsIDBdLFxuICAgICAgICBcIjQ3XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI0OFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNDlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjUwXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI1MVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNTJcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjUzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI1NFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNTVcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjU2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI1N1wiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNThcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjU5XCI6IFswLjEzODg5LCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCI2MFwiOiBbLTAuMDU1NTYsIDAuNTU1NTYsIDAsIDBdLFxuICAgICAgICBcIjYxXCI6IFstMC4xOTU0OSwgMC40MTU2MiwgMCwgMF0sXG4gICAgICAgIFwiNjJcIjogWy0wLjA1NTU2LCAwLjU1NTU2LCAwLCAwXSxcbiAgICAgICAgXCI2M1wiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNjRcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjY1XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI2NlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNjdcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjY4XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI2OVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzBcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjcxXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3MlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzNcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc0XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzZcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc3XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3OFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjgwXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI4MVwiOiBbMC4xMzg4OSwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiODJcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjgzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI4NFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiODVcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjg2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI4N1wiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiODhcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjg5XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTFcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjkyXCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCI5M1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiOTRcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjk1XCI6IFswLjA5NTE0LCAwLCAwLCAwXSxcbiAgICAgICAgXCI5NlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTdcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjk4XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5OVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTAwXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIxMDFcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEwMlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTAzXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMDRcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjEwNVwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTA2XCI6IFswLjIyMjIyLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIxMDdcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjEwOFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTA5XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTBcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExMVwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTEyXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTNcIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjExNFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE1XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTZcIjogWzAsIDAuNTUzNTgsIDAsIDBdLFxuICAgICAgICBcIjExN1wiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTE4XCI6IFswLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMTlcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEyMFwiOiBbMCwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiMTIxXCI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwXSxcbiAgICAgICAgXCIxMjJcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjEyM1wiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMF0sXG4gICAgICAgIFwiMTI0XCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwXSxcbiAgICAgICAgXCIxMjVcIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDBdLFxuICAgICAgICBcIjEyNlwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiMTI3XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCIzMDVcIjogWzAsIDAuNDMwNTYsIDAsIDBdLFxuICAgICAgICBcIjU2N1wiOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMF0sXG4gICAgICAgIFwiNzY4XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NjlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc3MFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzcxXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NzJcIjogWzAsIDAuNTY1NTUsIDAsIDBdLFxuICAgICAgICBcIjc3NFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiNzc2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI3NzhcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjc4MFwiOiBbMCwgMC41NjU5NywgMCwgMF0sXG4gICAgICAgIFwiOTE1XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MTZcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjkyMFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTIzXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MjZcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjkyOFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTMxXCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MzNcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjkzNFwiOiBbMCwgMC42MTExMSwgMCwgMF0sXG4gICAgICAgIFwiOTM2XCI6IFswLCAwLjYxMTExLCAwLCAwXSxcbiAgICAgICAgXCI5MzdcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjIwMThcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjIwMTlcIjogWzAsIDAuNjExMTEsIDAsIDBdLFxuICAgICAgICBcIjgyNDJcIjogWzAsIDAuNjExMTEsIDAsIDBdXG4gICAgfVxufTtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIFBhcnNlRXJyb3IgPSByZXF1aXJlKFwiLi9QYXJzZUVycm9yXCIpO1xudmFyIHBhcnNlRGF0YSA9IHJlcXVpcmUoXCIuL3BhcnNlRGF0YVwiKTtcbnZhciBQYXJzZU5vZGUgPSBwYXJzZURhdGEuUGFyc2VOb2RlO1xuXG4vKiBUaGlzIGZpbGUgY29udGFpbnMgYSBsaXN0IG9mIGZ1bmN0aW9ucyB0aGF0IHdlIHBhcnNlLCBpZGVudGlmaWVkIGJ5XG4gKiB0aGUgY2FsbHMgdG8gZGVmaW5lRnVuY3Rpb24uXG4gKlxuICogVGhlIGZpcnN0IGFyZ3VtZW50IHRvIGRlZmluZUZ1bmN0aW9uIGlzIGEgc2luZ2xlIG5hbWUgb3IgYSBsaXN0IG9mIG5hbWVzLlxuICogQWxsIGZ1bmN0aW9ucyBuYW1lZCBpbiBzdWNoIGEgbGlzdCB3aWxsIHNoYXJlIGEgc2luZ2xlIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEVhY2ggZGVjbGFyZWQgZnVuY3Rpb24gY2FuIGhhdmUgYXNzb2NpYXRlZCBwcm9wZXJ0aWVzLCB3aGljaFxuICogaW5jbHVkZSB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIG51bUFyZ3M6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoZSBmdW5jdGlvbiB0YWtlcy5cbiAqICAgICAgICAgICAgIElmIHRoaXMgaXMgdGhlIG9ubHkgcHJvcGVydHksIGl0IGNhbiBiZSBwYXNzZWQgYXMgYSBudW1iZXJcbiAqICAgICAgICAgICAgIGluc3RlYWQgb2YgYW4gZWxlbWVudCBvZiBhIHByb3BlcnRpZXMgb2JqZWN0LlxuICogIC0gYXJnVHlwZXM6IChvcHRpb25hbCkgQW4gYXJyYXkgY29ycmVzcG9uZGluZyB0byBlYWNoIGFyZ3VtZW50IG9mIHRoZVxuICogICAgICAgICAgICAgIGZ1bmN0aW9uLCBnaXZpbmcgdGhlIHR5cGUgb2YgYXJndW1lbnQgdGhhdCBzaG91bGQgYmUgcGFyc2VkLiBJdHNcbiAqICAgICAgICAgICAgICBsZW5ndGggc2hvdWxkIGJlIGVxdWFsIHRvIGBudW1BcmdzICsgbnVtT3B0aW9uYWxBcmdzYC4gVmFsaWRcbiAqICAgICAgICAgICAgICB0eXBlczpcbiAqICAgICAgICAgICAgICAgLSBcInNpemVcIjogQSBzaXplLWxpa2UgdGhpbmcsIHN1Y2ggYXMgXCIxZW1cIiBvciBcIjVleFwiXG4gKiAgICAgICAgICAgICAgIC0gXCJjb2xvclwiOiBBbiBodG1sIGNvbG9yLCBsaWtlIFwiI2FiY1wiIG9yIFwiYmx1ZVwiXG4gKiAgICAgICAgICAgICAgIC0gXCJvcmlnaW5hbFwiOiBUaGUgc2FtZSB0eXBlIGFzIHRoZSBlbnZpcm9ubWVudCB0aGF0IHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJlaW5nIHBhcnNlZCBpcyBpbiAoZS5nLiB1c2VkIGZvciB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2RpZXMgb2YgZnVuY3Rpb25zIGxpa2UgXFxjb2xvciB3aGVyZSB0aGUgZmlyc3RcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudCBpcyBzcGVjaWFsIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkIG5vcm1hbGx5KVxuICogICAgICAgICAgICAgIE90aGVyIHBvc3NpYmxlIHR5cGVzIChwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZClcbiAqICAgICAgICAgICAgICAgLSBcInRleHRcIjogVGV4dC1saWtlIChlLmcuIFxcdGV4dClcbiAqICAgICAgICAgICAgICAgLSBcIm1hdGhcIjogTm9ybWFsIG1hdGhcbiAqICAgICAgICAgICAgICBJZiB1bmRlZmluZWQsIHRoaXMgd2lsbCBiZSB0cmVhdGVkIGFzIGFuIGFwcHJvcHJpYXRlIGxlbmd0aFxuICogICAgICAgICAgICAgIGFycmF5IG9mIFwib3JpZ2luYWxcIiBzdHJpbmdzXG4gKiAgLSBncmVlZGluZXNzOiAob3B0aW9uYWwpIFRoZSBncmVlZGluZXNzIG9mIHRoZSBmdW5jdGlvbiB0byB1c2UgdW5ncm91cGVkXG4gKiAgICAgICAgICAgICAgICBhcmd1bWVudHMuXG4gKlxuICogICAgICAgICAgICAgICAgRS5nLiBpZiB5b3UgaGF2ZSBhbiBleHByZXNzaW9uXG4gKiAgICAgICAgICAgICAgICAgIFxcc3FydCBcXGZyYWMgMSAyXG4gKiAgICAgICAgICAgICAgICBzaW5jZSBcXGZyYWMgaGFzIGdyZWVkaW5lc3M9MiB2cyBcXHNxcnQncyBncmVlZGluZXNzPTEsIFxcZnJhY1xuICogICAgICAgICAgICAgICAgd2lsbCB1c2UgdGhlIHR3byBhcmd1bWVudHMgJzEnIGFuZCAnMicgYXMgaXRzIHR3byBhcmd1bWVudHMsXG4gKiAgICAgICAgICAgICAgICB0aGVuIHRoYXQgd2hvbGUgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIGFzIHRoZSBhcmd1bWVudCB0b1xuICogICAgICAgICAgICAgICAgXFxzcXJ0LiBPbiB0aGUgb3RoZXIgaGFuZCwgdGhlIGV4cHJlc3Npb25zXG4gKiAgICAgICAgICAgICAgICAgIFxcZnJhYyBcXGZyYWMgMSAyIDNcbiAqICAgICAgICAgICAgICAgIGFuZFxuICogICAgICAgICAgICAgICAgICBcXGZyYWMgXFxzcXJ0IDEgMlxuICogICAgICAgICAgICAgICAgd2lsbCBmYWlsIGJlY2F1c2UgXFxmcmFjIGFuZCBcXGZyYWMgaGF2ZSBlcXVhbCBncmVlZGluZXNzXG4gKiAgICAgICAgICAgICAgICBhbmQgXFxzcXJ0IGhhcyBhIGxvd2VyIGdyZWVkaW5lc3MgdGhhbiBcXGZyYWMgcmVzcGVjdGl2ZWx5LiBUb1xuICogICAgICAgICAgICAgICAgbWFrZSB0aGVzZSBwYXJzZSwgd2Ugd291bGQgaGF2ZSB0byBjaGFuZ2UgdGhlbSB0bzpcbiAqICAgICAgICAgICAgICAgICAgXFxmcmFjIHtcXGZyYWMgMSAyfSAzXG4gKiAgICAgICAgICAgICAgICBhbmRcbiAqICAgICAgICAgICAgICAgICAgXFxmcmFjIHtcXHNxcnQgMX0gMlxuICpcbiAqICAgICAgICAgICAgICAgIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAxYFxuICogIC0gYWxsb3dlZEluVGV4dDogKG9wdGlvbmFsKSBXaGV0aGVyIG9yIG5vdCB0aGUgZnVuY3Rpb24gaXMgYWxsb3dlZCBpbnNpZGVcbiAqICAgICAgICAgICAgICAgICAgIHRleHQgbW9kZSAoZGVmYXVsdCBmYWxzZSlcbiAqICAtIG51bU9wdGlvbmFsQXJnczogKG9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIG9wdGlvbmFsIGFyZ3VtZW50cyB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIHBhcnNlLiBJZiB0aGUgb3B0aW9uYWwgYXJndW1lbnRzIGFyZW4ndCBmb3VuZCxcbiAqICAgICAgICAgICAgICAgICAgICAgYG51bGxgIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBoYW5kbGVyIGluIHRoZWlyIHBsYWNlLlxuICogICAgICAgICAgICAgICAgICAgICAoZGVmYXVsdCAwKVxuICogIC0gaW5maXg6IChvcHRpb25hbCkgTXVzdCBiZSB0cnVlIGlmIHRoZSBmdW5jdGlvbiBpcyBhbiBpbmZpeCBvcGVyYXRvci5cbiAqXG4gKiBUaGUgbGFzdCBhcmd1bWVudCBpcyB0aGF0IGltcGxlbWVudGF0aW9uLCB0aGUgaGFuZGxlciBmb3IgdGhlIGZ1bmN0aW9uKHMpLlxuICogSXQgaXMgY2FsbGVkIHRvIGhhbmRsZSB0aGVzZSBmdW5jdGlvbnMgYW5kIHRoZWlyIGFyZ3VtZW50cy5cbiAqIEl0IHJlY2VpdmVzIHR3byBhcmd1bWVudHM6XG4gKiAgLSBjb250ZXh0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFuZCByZWZlcmVuY2VzIHByb3ZpZGVkIGJ5IHRoZSBwYXJzZXJcbiAqICAtIGFyZ3MgaXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIG9idGFpbmVkIGZyb20gVGVYIGlucHV0XG4gKiBUaGUgY29udGV4dCBjb250YWlucyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgLSBmdW5jTmFtZTogdGhlIHRleHQgKGkuZS4gbmFtZSkgb2YgdGhlIGZ1bmN0aW9uLCBpbmNsdWRpbmcgXFxcbiAqICAtIHBhcnNlcjogdGhlIHBhcnNlciBvYmplY3RcbiAqICAtIGxleGVyOiB0aGUgbGV4ZXIgb2JqZWN0XG4gKiAgLSBwb3NpdGlvbnM6IHRoZSBwb3NpdGlvbnMgaW4gdGhlIG92ZXJhbGwgc3RyaW5nIG9mIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICBhbmQgdGhlIGFyZ3VtZW50cy5cbiAqIFRoZSBsYXR0ZXIgdGhyZWUgc2hvdWxkIG9ubHkgYmUgdXNlZCB0byBwcm9kdWNlIGVycm9yIG1lc3NhZ2VzLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBzaG91bGQgcmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcga2V5czpcbiAqICAtIHR5cGU6IFRoZSB0eXBlIG9mIGVsZW1lbnQgdGhhdCB0aGlzIGlzLiBUaGlzIGlzIHRoZW4gdXNlZCBpblxuICogICAgICAgICAgYnVpbGRIVE1ML2J1aWxkTWF0aE1MIHRvIGRldGVybWluZSB3aGljaCBmdW5jdGlvblxuICogICAgICAgICAgc2hvdWxkIGJlIGNhbGxlZCB0byBidWlsZCB0aGlzIG5vZGUgaW50byBhIERPTSBub2RlXG4gKiBBbnkgb3RoZXIgZGF0YSBjYW4gYmUgYWRkZWQgdG8gdGhlIG9iamVjdCwgd2hpY2ggd2lsbCBiZSBwYXNzZWRcbiAqIGluIHRvIHRoZSBmdW5jdGlvbiBpbiBidWlsZEhUTUwvYnVpbGRNYXRoTUwgYXMgYGdyb3VwLnZhbHVlYC5cbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmVGdW5jdGlvbihuYW1lcywgcHJvcHMsIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIG5hbWVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5hbWVzID0gW25hbWVzXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9wcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBwcm9wcyA9IHsgbnVtQXJnczogcHJvcHMgfTtcbiAgICB9XG4gICAgLy8gU2V0IGRlZmF1bHQgdmFsdWVzIG9mIGZ1bmN0aW9uc1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgICBudW1BcmdzOiBwcm9wcy5udW1BcmdzLFxuICAgICAgICBhcmdUeXBlczogcHJvcHMuYXJnVHlwZXMsXG4gICAgICAgIGdyZWVkaW5lc3M6IChwcm9wcy5ncmVlZGluZXNzID09PSB1bmRlZmluZWQpID8gMSA6IHByb3BzLmdyZWVkaW5lc3MsXG4gICAgICAgIGFsbG93ZWRJblRleHQ6ICEhcHJvcHMuYWxsb3dlZEluVGV4dCxcbiAgICAgICAgbnVtT3B0aW9uYWxBcmdzOiBwcm9wcy5udW1PcHRpb25hbEFyZ3MgfHwgMCxcbiAgICAgICAgaW5maXg6ICEhcHJvcHMuaW5maXgsXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHNbbmFtZXNbaV1dID0gZGF0YTtcbiAgICB9XG59XG5cbi8vIFNpbmNlIHRoZSBjb3JyZXNwb25kaW5nIGJ1aWxkSFRNTC9idWlsZE1hdGhNTCBmdW5jdGlvbiBleHBlY3RzIGFcbi8vIGxpc3Qgb2YgZWxlbWVudHMsIHdlIG5vcm1hbGl6ZSBmb3IgZGlmZmVyZW50IGtpbmRzIG9mIGFyZ3VtZW50c1xudmFyIG9yZGFyZ3VtZW50ID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKGFyZy50eXBlID09PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgcmV0dXJuIGFyZy52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW2FyZ107XG4gICAgfVxufTtcblxuLy8gQSBub3JtYWwgc3F1YXJlIHJvb3RcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXHNxcnRcIiwge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgbnVtT3B0aW9uYWxBcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGluZGV4ID0gYXJnc1swXTtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMV07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzcXJ0XCIsXG4gICAgICAgIGJvZHk6IGJvZHksXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgIH07XG59KTtcblxuLy8gTm9uLW1hdGh5IHRleHQsIHBvc3NpYmx5IGluIGEgZm9udFxudmFyIHRleHRGdW5jdGlvblN0eWxlcyA9IHtcbiAgICBcIlxcXFx0ZXh0XCI6IHVuZGVmaW5lZCwgXCJcXFxcdGV4dHJtXCI6IFwibWF0aHJtXCIsIFwiXFxcXHRleHRzZlwiOiBcIm1hdGhzZlwiLFxuICAgIFwiXFxcXHRleHR0dFwiOiBcIm1hdGh0dFwiLCBcIlxcXFx0ZXh0bm9ybWFsXCI6IFwibWF0aHJtXCIsIFwiXFxcXHRleHRiZlwiOiBcIm1hdGhiZlwiLFxuICAgIFwiXFxcXHRleHRpdFwiOiBcInRleHRpdFwiXG59O1xuXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcdGV4dFwiLCBcIlxcXFx0ZXh0cm1cIiwgXCJcXFxcdGV4dHNmXCIsIFwiXFxcXHRleHR0dFwiLCBcIlxcXFx0ZXh0bm9ybWFsXCIsXG4gICAgXCJcXFxcdGV4dGJmXCIsIFwiXFxcXHRleHRpdFwiXG5dLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1widGV4dFwiXSxcbiAgICBncmVlZGluZXNzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWVcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpLFxuICAgICAgICBzdHlsZTogdGV4dEZ1bmN0aW9uU3R5bGVzW2NvbnRleHQuZnVuY05hbWVdXG4gICAgfTtcbn0pO1xuXG4vLyBBIHR3by1hcmd1bWVudCBjdXN0b20gY29sb3JcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXGNvbG9yXCIsIHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGFsbG93ZWRJblRleHQ6IHRydWUsXG4gICAgZ3JlZWRpbmVzczogMyxcbiAgICBhcmdUeXBlczogW1wiY29sb3JcIiwgXCJvcmlnaW5hbFwiXVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBjb2xvciA9IGFyZ3NbMF07XG4gICAgdmFyIGJvZHkgPSBhcmdzWzFdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgY29sb3I6IGNvbG9yLnZhbHVlLFxuICAgICAgICB2YWx1ZTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xufSk7XG5cbi8vIEFuIG92ZXJsaW5lXG5kZWZpbmVGdW5jdGlvbihcIlxcXFxvdmVybGluZVwiLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm92ZXJsaW5lXCIsXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xufSk7XG5cbi8vIEFuIHVuZGVybGluZVxuZGVmaW5lRnVuY3Rpb24oXCJcXFxcdW5kZXJsaW5lXCIsIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidW5kZXJsaW5lXCIsXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xufSk7XG5cbi8vIEEgYm94IG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0XG5kZWZpbmVGdW5jdGlvbihcIlxcXFxydWxlXCIsIHtcbiAgICBudW1BcmdzOiAyLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiLCBcInNpemVcIiwgXCJzaXplXCJdXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIHNoaWZ0ID0gYXJnc1swXTtcbiAgICB2YXIgd2lkdGggPSBhcmdzWzFdO1xuICAgIHZhciBoZWlnaHQgPSBhcmdzWzJdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwicnVsZVwiLFxuICAgICAgICBzaGlmdDogc2hpZnQgJiYgc2hpZnQudmFsdWUsXG4gICAgICAgIHdpZHRoOiB3aWR0aC52YWx1ZSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQudmFsdWVcbiAgICB9O1xufSk7XG5cbi8vIFRPRE86IEluIFRlWCwgXFxta2VybiBvbmx5IGFjY2VwdHMgbXUtdW5pdHMsIGFuZCBcXGtlcm4gZG9lcyBub3QgYWNjZXB0XG4vLyBtdS11bml0cy4gSW4gY3VycmVudCBLYVRlWCB3ZSByZWxheCB0aGlzOyBib3RoIGNvbW1hbmRzIGFjY2VwdCBhbnkgdW5pdC5cbmRlZmluZUZ1bmN0aW9uKFtcIlxcXFxrZXJuXCIsIFwiXFxcXG1rZXJuXCJdLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwia2VyblwiLFxuICAgICAgICBkaW1lbnNpb246IGFyZ3NbMF0udmFsdWVcbiAgICB9O1xufSk7XG5cbi8vIEEgS2FUZVggbG9nb1xuZGVmaW5lRnVuY3Rpb24oXCJcXFxcS2FUZVhcIiwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImthdGV4XCJcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFwiXFxcXHBoYW50b21cIiwge1xuICAgIG51bUFyZ3M6IDFcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgYm9keSA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJwaGFudG9tXCIsXG4gICAgICAgIHZhbHVlOiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG59KTtcblxuLy8gTWF0aCBjbGFzcyBjb21tYW5kcyBleGNlcHQgXFxtYXRob3BcbmRlZmluZUZ1bmN0aW9uKFtcbiAgICBcIlxcXFxtYXRob3JkXCIsIFwiXFxcXG1hdGhiaW5cIiwgXCJcXFxcbWF0aHJlbFwiLCBcIlxcXFxtYXRob3BlblwiLFxuICAgIFwiXFxcXG1hdGhjbG9zZVwiLCBcIlxcXFxtYXRocHVuY3RcIiwgXCJcXFxcbWF0aGlubmVyXCJcbl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICAgIG1jbGFzczogXCJtXCIgKyBjb250ZXh0LmZ1bmNOYW1lLnN1YnN0cig1KSxcbiAgICAgICAgdmFsdWU6IG9yZGFyZ3VtZW50KGJvZHkpXG4gICAgfTtcbn0pO1xuXG4vLyBCdWlsZCBhIHJlbGF0aW9uIGJ5IHBsYWNpbmcgb25lIHN5bWJvbCBvbiB0b3Agb2YgYW5vdGhlclxuZGVmaW5lRnVuY3Rpb24oXCJcXFxcc3RhY2tyZWxcIiwge1xuICAgIG51bUFyZ3M6IDJcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgdG9wID0gYXJnc1swXTtcbiAgICB2YXIgYm90dG9tID0gYXJnc1sxXTtcblxuICAgIHZhciBib3R0b21vcCA9IG5ldyBQYXJzZU5vZGUoXCJvcFwiLCB7XG4gICAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgICBhbHdheXNIYW5kbGVTdXBTdWI6IHRydWUsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvcmRhcmd1bWVudChib3R0b20pXG4gICAgfSwgYm90dG9tLm1vZGUpO1xuXG4gICAgdmFyIHN1cHN1YiA9IG5ldyBQYXJzZU5vZGUoXCJzdXBzdWJcIiwge1xuICAgICAgICBiYXNlOiBib3R0b21vcCxcbiAgICAgICAgc3VwOiB0b3AsXG4gICAgICAgIHN1YjogbnVsbFxuICAgIH0sIHRvcC5tb2RlKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibWNsYXNzXCIsXG4gICAgICAgIG1jbGFzczogXCJtcmVsXCIsXG4gICAgICAgIHZhbHVlOiBbc3Vwc3ViXVxuICAgIH07XG59KTtcblxuLy8gXFxtb2QtdHlwZSBmdW5jdGlvbnNcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXGJtb2RcIiwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm1vZFwiLFxuICAgICAgICBtb2RUeXBlOiBcImJtb2RcIixcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFtcIlxcXFxwb2RcIiwgXCJcXFxccG1vZFwiLCBcIlxcXFxtb2RcIl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibW9kXCIsXG4gICAgICAgIG1vZFR5cGU6IGNvbnRleHQuZnVuY05hbWUuc3Vic3RyKDEpLFxuICAgICAgICB2YWx1ZTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xufSk7XG5cbi8vIEV4dHJhIGRhdGEgbmVlZGVkIGZvciB0aGUgZGVsaW1pdGVyIGhhbmRsZXIgZG93biBiZWxvd1xudmFyIGRlbGltaXRlclNpemVzID0ge1xuICAgIFwiXFxcXGJpZ2xcIiA6IHttY2xhc3M6IFwibW9wZW5cIiwgICAgc2l6ZTogMX0sXG4gICAgXCJcXFxcQmlnbFwiIDoge21jbGFzczogXCJtb3BlblwiLCAgICBzaXplOiAyfSxcbiAgICBcIlxcXFxiaWdnbFwiOiB7bWNsYXNzOiBcIm1vcGVuXCIsICAgIHNpemU6IDN9LFxuICAgIFwiXFxcXEJpZ2dsXCI6IHttY2xhc3M6IFwibW9wZW5cIiwgICAgc2l6ZTogNH0sXG4gICAgXCJcXFxcYmlnclwiIDoge21jbGFzczogXCJtY2xvc2VcIiwgICBzaXplOiAxfSxcbiAgICBcIlxcXFxCaWdyXCIgOiB7bWNsYXNzOiBcIm1jbG9zZVwiLCAgIHNpemU6IDJ9LFxuICAgIFwiXFxcXGJpZ2dyXCI6IHttY2xhc3M6IFwibWNsb3NlXCIsICAgc2l6ZTogM30sXG4gICAgXCJcXFxcQmlnZ3JcIjoge21jbGFzczogXCJtY2xvc2VcIiwgICBzaXplOiA0fSxcbiAgICBcIlxcXFxiaWdtXCIgOiB7bWNsYXNzOiBcIm1yZWxcIiwgICAgIHNpemU6IDF9LFxuICAgIFwiXFxcXEJpZ21cIiA6IHttY2xhc3M6IFwibXJlbFwiLCAgICAgc2l6ZTogMn0sXG4gICAgXCJcXFxcYmlnZ21cIjoge21jbGFzczogXCJtcmVsXCIsICAgICBzaXplOiAzfSxcbiAgICBcIlxcXFxCaWdnbVwiOiB7bWNsYXNzOiBcIm1yZWxcIiwgICAgIHNpemU6IDR9LFxuICAgIFwiXFxcXGJpZ1wiICA6IHttY2xhc3M6IFwibW9yZFwiLCAgICAgc2l6ZTogMX0sXG4gICAgXCJcXFxcQmlnXCIgIDoge21jbGFzczogXCJtb3JkXCIsICAgICBzaXplOiAyfSxcbiAgICBcIlxcXFxiaWdnXCIgOiB7bWNsYXNzOiBcIm1vcmRcIiwgICAgIHNpemU6IDN9LFxuICAgIFwiXFxcXEJpZ2dcIiA6IHttY2xhc3M6IFwibW9yZFwiLCAgICAgc2l6ZTogNH1cbn07XG5cbnZhciBkZWxpbWl0ZXJzID0gW1xuICAgIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXFxcXGxicmFja1wiLCBcIl1cIiwgXCJcXFxccmJyYWNrXCIsXG4gICAgXCJcXFxce1wiLCBcIlxcXFxsYnJhY2VcIiwgXCJcXFxcfVwiLCBcIlxcXFxyYnJhY2VcIixcbiAgICBcIlxcXFxsZmxvb3JcIiwgXCJcXFxccmZsb29yXCIsIFwiXFxcXGxjZWlsXCIsIFwiXFxcXHJjZWlsXCIsXG4gICAgXCI8XCIsIFwiPlwiLCBcIlxcXFxsYW5nbGVcIiwgXCJcXFxccmFuZ2xlXCIsIFwiXFxcXGx0XCIsIFwiXFxcXGd0XCIsXG4gICAgXCJcXFxcbHZlcnRcIiwgXCJcXFxccnZlcnRcIiwgXCJcXFxcbFZlcnRcIiwgXCJcXFxcclZlcnRcIixcbiAgICBcIlxcXFxsZ3JvdXBcIiwgXCJcXFxccmdyb3VwXCIsIFwiXFxcXGxtb3VzdGFjaGVcIiwgXCJcXFxccm1vdXN0YWNoZVwiLFxuICAgIFwiL1wiLCBcIlxcXFxiYWNrc2xhc2hcIixcbiAgICBcInxcIiwgXCJcXFxcdmVydFwiLCBcIlxcXFx8XCIsIFwiXFxcXFZlcnRcIixcbiAgICBcIlxcXFx1cGFycm93XCIsIFwiXFxcXFVwYXJyb3dcIixcbiAgICBcIlxcXFxkb3duYXJyb3dcIiwgXCJcXFxcRG93bmFycm93XCIsXG4gICAgXCJcXFxcdXBkb3duYXJyb3dcIiwgXCJcXFxcVXBkb3duYXJyb3dcIixcbiAgICBcIi5cIlxuXTtcblxudmFyIGZvbnRBbGlhc2VzID0ge1xuICAgIFwiXFxcXEJiYlwiOiBcIlxcXFxtYXRoYmJcIixcbiAgICBcIlxcXFxib2xkXCI6IFwiXFxcXG1hdGhiZlwiLFxuICAgIFwiXFxcXGZyYWtcIjogXCJcXFxcbWF0aGZyYWtcIlxufTtcblxuLy8gU2luZ2xlLWFyZ3VtZW50IGNvbG9yIGZ1bmN0aW9uc1xuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGJsdWVcIiwgXCJcXFxcb3JhbmdlXCIsIFwiXFxcXHBpbmtcIiwgXCJcXFxccmVkXCIsXG4gICAgXCJcXFxcZ3JlZW5cIiwgXCJcXFxcZ3JheVwiLCBcIlxcXFxwdXJwbGVcIixcbiAgICBcIlxcXFxibHVlQVwiLCBcIlxcXFxibHVlQlwiLCBcIlxcXFxibHVlQ1wiLCBcIlxcXFxibHVlRFwiLCBcIlxcXFxibHVlRVwiLFxuICAgIFwiXFxcXHRlYWxBXCIsIFwiXFxcXHRlYWxCXCIsIFwiXFxcXHRlYWxDXCIsIFwiXFxcXHRlYWxEXCIsIFwiXFxcXHRlYWxFXCIsXG4gICAgXCJcXFxcZ3JlZW5BXCIsIFwiXFxcXGdyZWVuQlwiLCBcIlxcXFxncmVlbkNcIiwgXCJcXFxcZ3JlZW5EXCIsIFwiXFxcXGdyZWVuRVwiLFxuICAgIFwiXFxcXGdvbGRBXCIsIFwiXFxcXGdvbGRCXCIsIFwiXFxcXGdvbGRDXCIsIFwiXFxcXGdvbGREXCIsIFwiXFxcXGdvbGRFXCIsXG4gICAgXCJcXFxccmVkQVwiLCBcIlxcXFxyZWRCXCIsIFwiXFxcXHJlZENcIiwgXCJcXFxccmVkRFwiLCBcIlxcXFxyZWRFXCIsXG4gICAgXCJcXFxcbWFyb29uQVwiLCBcIlxcXFxtYXJvb25CXCIsIFwiXFxcXG1hcm9vbkNcIiwgXCJcXFxcbWFyb29uRFwiLCBcIlxcXFxtYXJvb25FXCIsXG4gICAgXCJcXFxccHVycGxlQVwiLCBcIlxcXFxwdXJwbGVCXCIsIFwiXFxcXHB1cnBsZUNcIiwgXCJcXFxccHVycGxlRFwiLCBcIlxcXFxwdXJwbGVFXCIsXG4gICAgXCJcXFxcbWludEFcIiwgXCJcXFxcbWludEJcIiwgXCJcXFxcbWludENcIixcbiAgICBcIlxcXFxncmF5QVwiLCBcIlxcXFxncmF5QlwiLCBcIlxcXFxncmF5Q1wiLCBcIlxcXFxncmF5RFwiLCBcIlxcXFxncmF5RVwiLFxuICAgIFwiXFxcXGdyYXlGXCIsIFwiXFxcXGdyYXlHXCIsIFwiXFxcXGdyYXlIXCIsIFwiXFxcXGdyYXlJXCIsXG4gICAgXCJcXFxca2FCbHVlXCIsIFwiXFxcXGthR3JlZW5cIlxuXSwge1xuICAgIG51bUFyZ3M6IDEsXG4gICAgYWxsb3dlZEluVGV4dDogdHJ1ZSxcbiAgICBncmVlZGluZXNzOiAzXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY29sb3JcIixcbiAgICAgICAgY29sb3I6IFwia2F0ZXgtXCIgKyBjb250ZXh0LmZ1bmNOYW1lLnNsaWNlKDEpLFxuICAgICAgICB2YWx1ZTogb3JkYXJndW1lbnQoYm9keSlcbiAgICB9O1xufSk7XG5cbi8vIFRoZXJlIGFyZSAyIGZsYWdzIGZvciBvcGVyYXRvcnM7IHdoZXRoZXIgdGhleSBwcm9kdWNlIGxpbWl0cyBpblxuLy8gZGlzcGxheXN0eWxlLCBhbmQgd2hldGhlciB0aGV5IGFyZSBzeW1ib2xzIGFuZCBzaG91bGQgZ3JvdyBpblxuLy8gZGlzcGxheXN0eWxlLiBUaGVzZSBmb3VyIGdyb3VwcyBjb3ZlciB0aGUgZm91ciBwb3NzaWJsZSBjaG9pY2VzLlxuXG4vLyBObyBsaW1pdHMsIG5vdCBzeW1ib2xzXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcYXJjc2luXCIsIFwiXFxcXGFyY2Nvc1wiLCBcIlxcXFxhcmN0YW5cIiwgXCJcXFxcYXJnXCIsIFwiXFxcXGNvc1wiLCBcIlxcXFxjb3NoXCIsXG4gICAgXCJcXFxcY290XCIsIFwiXFxcXGNvdGhcIiwgXCJcXFxcY3NjXCIsIFwiXFxcXGRlZ1wiLCBcIlxcXFxkaW1cIiwgXCJcXFxcZXhwXCIsIFwiXFxcXGhvbVwiLFxuICAgIFwiXFxcXGtlclwiLCBcIlxcXFxsZ1wiLCBcIlxcXFxsblwiLCBcIlxcXFxsb2dcIiwgXCJcXFxcc2VjXCIsIFwiXFxcXHNpblwiLCBcIlxcXFxzaW5oXCIsXG4gICAgXCJcXFxcdGFuXCIsIFwiXFxcXHRhbmhcIlxuXSwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIGJvZHk6IGNvbnRleHQuZnVuY05hbWVcbiAgICB9O1xufSk7XG5cbi8vIExpbWl0cywgbm90IHN5bWJvbHNcbmRlZmluZUZ1bmN0aW9uKFtcbiAgICBcIlxcXFxkZXRcIiwgXCJcXFxcZ2NkXCIsIFwiXFxcXGluZlwiLCBcIlxcXFxsaW1cIiwgXCJcXFxcbGltaW5mXCIsIFwiXFxcXGxpbXN1cFwiLCBcIlxcXFxtYXhcIixcbiAgICBcIlxcXFxtaW5cIiwgXCJcXFxcUHJcIiwgXCJcXFxcc3VwXCJcbl0sIHtcbiAgICBudW1BcmdzOiAwXG59LCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJvcFwiLFxuICAgICAgICBsaW1pdHM6IHRydWUsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIGJvZHk6IGNvbnRleHQuZnVuY05hbWVcbiAgICB9O1xufSk7XG5cbi8vIE5vIGxpbWl0cywgc3ltYm9sc1xuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGludFwiLCBcIlxcXFxpaW50XCIsIFwiXFxcXGlpaW50XCIsIFwiXFxcXG9pbnRcIlxuXSwge1xuICAgIG51bUFyZ3M6IDBcbn0sIGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICAgIHN5bWJvbDogdHJ1ZSxcbiAgICAgICAgYm9keTogY29udGV4dC5mdW5jTmFtZVxuICAgIH07XG59KTtcblxuLy8gTGltaXRzLCBzeW1ib2xzXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcY29wcm9kXCIsIFwiXFxcXGJpZ3ZlZVwiLCBcIlxcXFxiaWd3ZWRnZVwiLCBcIlxcXFxiaWd1cGx1c1wiLCBcIlxcXFxiaWdjYXBcIixcbiAgICBcIlxcXFxiaWdjdXBcIiwgXCJcXFxcaW50b3BcIiwgXCJcXFxccHJvZFwiLCBcIlxcXFxzdW1cIiwgXCJcXFxcYmlnb3RpbWVzXCIsXG4gICAgXCJcXFxcYmlnb3BsdXNcIiwgXCJcXFxcYmlnb2RvdFwiLCBcIlxcXFxiaWdzcWN1cFwiLCBcIlxcXFxzbWFsbGludFwiXG5dLCB7XG4gICAgbnVtQXJnczogMFxufSwgZnVuY3Rpb24oY29udGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwib3BcIixcbiAgICAgICAgbGltaXRzOiB0cnVlLFxuICAgICAgICBzeW1ib2w6IHRydWUsXG4gICAgICAgIGJvZHk6IGNvbnRleHQuZnVuY05hbWVcbiAgICB9O1xufSk7XG5cbi8vIFxcbWF0aG9wIGNsYXNzIGNvbW1hbmRcbmRlZmluZUZ1bmN0aW9uKFwiXFxcXG1hdGhvcFwiLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBib2R5ID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm9wXCIsXG4gICAgICAgIGxpbWl0czogZmFsc2UsXG4gICAgICAgIHN5bWJvbDogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvcmRhcmd1bWVudChib2R5KVxuICAgIH07XG59KTtcblxuLy8gRnJhY3Rpb25zXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcZGZyYWNcIiwgXCJcXFxcZnJhY1wiLCBcIlxcXFx0ZnJhY1wiLFxuICAgIFwiXFxcXGRiaW5vbVwiLCBcIlxcXFxiaW5vbVwiLCBcIlxcXFx0Ymlub21cIixcbiAgICBcIlxcXFxcXFxcYXRvcGZyYWNcIiAvLyBjYW7igJl0IGJlIGVudGVyZWQgZGlyZWN0bHlcbl0sIHtcbiAgICBudW1BcmdzOiAyLFxuICAgIGdyZWVkaW5lc3M6IDJcbn0sIGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcbiAgICB2YXIgbnVtZXIgPSBhcmdzWzBdO1xuICAgIHZhciBkZW5vbSA9IGFyZ3NbMV07XG4gICAgdmFyIGhhc0JhckxpbmU7XG4gICAgdmFyIGxlZnREZWxpbSA9IG51bGw7XG4gICAgdmFyIHJpZ2h0RGVsaW0gPSBudWxsO1xuICAgIHZhciBzaXplID0gXCJhdXRvXCI7XG5cbiAgICBzd2l0Y2ggKGNvbnRleHQuZnVuY05hbWUpIHtcbiAgICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgICBjYXNlIFwiXFxcXGZyYWNcIjpcbiAgICAgICAgY2FzZSBcIlxcXFx0ZnJhY1wiOlxuICAgICAgICAgICAgaGFzQmFyTGluZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlxcXFxcXFxcYXRvcGZyYWNcIjpcbiAgICAgICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgICBjYXNlIFwiXFxcXGJpbm9tXCI6XG4gICAgICAgIGNhc2UgXCJcXFxcdGJpbm9tXCI6XG4gICAgICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBsZWZ0RGVsaW0gPSBcIihcIjtcbiAgICAgICAgICAgIHJpZ2h0RGVsaW0gPSBcIilcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIGdlbmZyYWMgY29tbWFuZFwiKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNvbnRleHQuZnVuY05hbWUpIHtcbiAgICAgICAgY2FzZSBcIlxcXFxkZnJhY1wiOlxuICAgICAgICBjYXNlIFwiXFxcXGRiaW5vbVwiOlxuICAgICAgICAgICAgc2l6ZSA9IFwiZGlzcGxheVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJcXFxcdGZyYWNcIjpcbiAgICAgICAgY2FzZSBcIlxcXFx0Ymlub21cIjpcbiAgICAgICAgICAgIHNpemUgPSBcInRleHRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZ2VuZnJhY1wiLFxuICAgICAgICBudW1lcjogbnVtZXIsXG4gICAgICAgIGRlbm9tOiBkZW5vbSxcbiAgICAgICAgaGFzQmFyTGluZTogaGFzQmFyTGluZSxcbiAgICAgICAgbGVmdERlbGltOiBsZWZ0RGVsaW0sXG4gICAgICAgIHJpZ2h0RGVsaW06IHJpZ2h0RGVsaW0sXG4gICAgICAgIHNpemU6IHNpemVcbiAgICB9O1xufSk7XG5cbi8vIExlZnQgYW5kIHJpZ2h0IG92ZXJsYXAgZnVuY3Rpb25zXG5kZWZpbmVGdW5jdGlvbihbXCJcXFxcbGxhcFwiLCBcIlxcXFxybGFwXCJdLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IGNvbnRleHQuZnVuY05hbWUuc2xpY2UoMSksXG4gICAgICAgIGJvZHk6IGJvZHlcbiAgICB9O1xufSk7XG5cbi8vIERlbGltaXRlciBmdW5jdGlvbnNcbnZhciBjaGVja0RlbGltaXRlciA9IGZ1bmN0aW9uKGRlbGltLCBjb250ZXh0KSB7XG4gICAgaWYgKHV0aWxzLmNvbnRhaW5zKGRlbGltaXRlcnMsIGRlbGltLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZGVsaW07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXG4gICAgICAgICAgICBcIkludmFsaWQgZGVsaW1pdGVyOiAnXCIgKyBkZWxpbS52YWx1ZSArIFwiJyBhZnRlciAnXCIgK1xuICAgICAgICAgICAgY29udGV4dC5mdW5jTmFtZSArIFwiJ1wiLCBkZWxpbSk7XG4gICAgfVxufTtcblxuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGJpZ2xcIiwgXCJcXFxcQmlnbFwiLCBcIlxcXFxiaWdnbFwiLCBcIlxcXFxCaWdnbFwiLFxuICAgIFwiXFxcXGJpZ3JcIiwgXCJcXFxcQmlnclwiLCBcIlxcXFxiaWdnclwiLCBcIlxcXFxCaWdnclwiLFxuICAgIFwiXFxcXGJpZ21cIiwgXCJcXFxcQmlnbVwiLCBcIlxcXFxiaWdnbVwiLCBcIlxcXFxCaWdnbVwiLFxuICAgIFwiXFxcXGJpZ1wiLCAgXCJcXFxcQmlnXCIsICBcIlxcXFxiaWdnXCIsICBcIlxcXFxCaWdnXCJcbl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImRlbGltc2l6aW5nXCIsXG4gICAgICAgIHNpemU6IGRlbGltaXRlclNpemVzW2NvbnRleHQuZnVuY05hbWVdLnNpemUsXG4gICAgICAgIG1jbGFzczogZGVsaW1pdGVyU2l6ZXNbY29udGV4dC5mdW5jTmFtZV0ubWNsYXNzLFxuICAgICAgICB2YWx1ZTogZGVsaW0udmFsdWVcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFtcbiAgICBcIlxcXFxsZWZ0XCIsIFwiXFxcXHJpZ2h0XCJcbl0sIHtcbiAgICBudW1BcmdzOiAxXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGRlbGltID0gY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCk7XG5cbiAgICAvLyBcXGxlZnQgYW5kIFxccmlnaHQgYXJlIGNhdWdodCBzb21ld2hlcmUgaW4gUGFyc2VyLmpzLCB3aGljaCBpc1xuICAgIC8vIHdoeSB0aGlzIGRhdGEgZG9lc24ndCBtYXRjaCB3aGF0IGlzIGluIGJ1aWxkSFRNTC5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImxlZnRyaWdodFwiLFxuICAgICAgICB2YWx1ZTogZGVsaW0udmFsdWVcbiAgICB9O1xufSk7XG5cbmRlZmluZUZ1bmN0aW9uKFwiXFxcXG1pZGRsZVwiLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpO1xuICAgIGlmICghY29udGV4dC5wYXJzZXIubGVmdHJpZ2h0RGVwdGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJcXFxcbWlkZGxlIHdpdGhvdXQgcHJlY2VkaW5nIFxcXFxsZWZ0XCIsIGRlbGltKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm1pZGRsZVwiLFxuICAgICAgICB2YWx1ZTogZGVsaW0udmFsdWVcbiAgICB9O1xufSk7XG5cbi8vIFNpemluZyBmdW5jdGlvbnMgKGhhbmRsZWQgaW4gUGFyc2VyLmpzIGV4cGxpY2l0bHksIGhlbmNlIG5vIGhhbmRsZXIpXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcdGlueVwiLCBcIlxcXFxzY3JpcHRzaXplXCIsIFwiXFxcXGZvb3Rub3Rlc2l6ZVwiLCBcIlxcXFxzbWFsbFwiLFxuICAgIFwiXFxcXG5vcm1hbHNpemVcIiwgXCJcXFxcbGFyZ2VcIiwgXCJcXFxcTGFyZ2VcIiwgXCJcXFxcTEFSR0VcIiwgXCJcXFxcaHVnZVwiLCBcIlxcXFxIdWdlXCJcbl0sIDAsIG51bGwpO1xuXG4vLyBTdHlsZSBjaGFuZ2luZyBmdW5jdGlvbnMgKGhhbmRsZWQgaW4gUGFyc2VyLmpzIGV4cGxpY2l0bHksIGhlbmNlIG5vXG4vLyBoYW5kbGVyKVxuZGVmaW5lRnVuY3Rpb24oW1xuICAgIFwiXFxcXGRpc3BsYXlzdHlsZVwiLCBcIlxcXFx0ZXh0c3R5bGVcIiwgXCJcXFxcc2NyaXB0c3R5bGVcIixcbiAgICBcIlxcXFxzY3JpcHRzY3JpcHRzdHlsZVwiXG5dLCAwLCBudWxsKTtcblxuZGVmaW5lRnVuY3Rpb24oW1xuICAgIC8vIHN0eWxlc1xuICAgIFwiXFxcXG1hdGhybVwiLCBcIlxcXFxtYXRoaXRcIiwgXCJcXFxcbWF0aGJmXCIsXG5cbiAgICAvLyBmYW1pbGllc1xuICAgIFwiXFxcXG1hdGhiYlwiLCBcIlxcXFxtYXRoY2FsXCIsIFwiXFxcXG1hdGhmcmFrXCIsIFwiXFxcXG1hdGhzY3JcIiwgXCJcXFxcbWF0aHNmXCIsXG4gICAgXCJcXFxcbWF0aHR0XCIsXG5cbiAgICAvLyBhbGlhc2VzXG4gICAgXCJcXFxcQmJiXCIsIFwiXFxcXGJvbGRcIiwgXCJcXFxcZnJha1wiXG5dLCB7XG4gICAgbnVtQXJnczogMSxcbiAgICBncmVlZGluZXNzOiAyXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIGJvZHkgPSBhcmdzWzBdO1xuICAgIHZhciBmdW5jID0gY29udGV4dC5mdW5jTmFtZTtcbiAgICBpZiAoZnVuYyBpbiBmb250QWxpYXNlcykge1xuICAgICAgICBmdW5jID0gZm9udEFsaWFzZXNbZnVuY107XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZm9udFwiLFxuICAgICAgICBmb250OiBmdW5jLnNsaWNlKDEpLFxuICAgICAgICBib2R5OiBib2R5XG4gICAgfTtcbn0pO1xuXG4vLyBBY2NlbnRzXG5kZWZpbmVGdW5jdGlvbihbXG4gICAgXCJcXFxcYWN1dGVcIiwgXCJcXFxcZ3JhdmVcIiwgXCJcXFxcZGRvdFwiLCBcIlxcXFx0aWxkZVwiLCBcIlxcXFxiYXJcIiwgXCJcXFxcYnJldmVcIixcbiAgICBcIlxcXFxjaGVja1wiLCBcIlxcXFxoYXRcIiwgXCJcXFxcdmVjXCIsIFwiXFxcXGRvdFwiXG4gICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBleHBhbmRpbmcgYWNjZW50cyB5ZXRcbiAgICAvLyBcIlxcXFx3aWRldGlsZGVcIiwgXCJcXFxcd2lkZWhhdFwiXG5dLCB7XG4gICAgbnVtQXJnczogMVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBiYXNlID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImFjY2VudFwiLFxuICAgICAgICBhY2NlbnQ6IGNvbnRleHQuZnVuY05hbWUsXG4gICAgICAgIGJhc2U6IGJhc2VcbiAgICB9O1xufSk7XG5cbi8vIEluZml4IGdlbmVyYWxpemVkIGZyYWN0aW9uc1xuZGVmaW5lRnVuY3Rpb24oW1wiXFxcXG92ZXJcIiwgXCJcXFxcY2hvb3NlXCIsIFwiXFxcXGF0b3BcIl0sIHtcbiAgICBudW1BcmdzOiAwLFxuICAgIGluZml4OiB0cnVlXG59LCBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIHJlcGxhY2VXaXRoO1xuICAgIHN3aXRjaCAoY29udGV4dC5mdW5jTmFtZSkge1xuICAgICAgICBjYXNlIFwiXFxcXG92ZXJcIjpcbiAgICAgICAgICAgIHJlcGxhY2VXaXRoID0gXCJcXFxcZnJhY1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJcXFxcY2hvb3NlXCI6XG4gICAgICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXGJpbm9tXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlxcXFxhdG9wXCI6XG4gICAgICAgICAgICByZXBsYWNlV2l0aCA9IFwiXFxcXFxcXFxhdG9wZnJhY1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgaW5maXggZ2VuZnJhYyBjb21tYW5kXCIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImluZml4XCIsXG4gICAgICAgIHJlcGxhY2VXaXRoOiByZXBsYWNlV2l0aCxcbiAgICAgICAgdG9rZW46IGNvbnRleHQudG9rZW5cbiAgICB9O1xufSk7XG5cbi8vIFJvdyBicmVha3MgZm9yIGFsaWduZWQgZGF0YVxuZGVmaW5lRnVuY3Rpb24oW1wiXFxcXFxcXFxcIiwgXCJcXFxcY3JcIl0sIHtcbiAgICBudW1BcmdzOiAwLFxuICAgIG51bU9wdGlvbmFsQXJnczogMSxcbiAgICBhcmdUeXBlczogW1wic2l6ZVwiXVxufSwgZnVuY3Rpb24oY29udGV4dCwgYXJncykge1xuICAgIHZhciBzaXplID0gYXJnc1swXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImNyXCIsXG4gICAgICAgIHNpemU6IHNpemVcbiAgICB9O1xufSk7XG5cbi8vIEVudmlyb25tZW50IGRlbGltaXRlcnNcbmRlZmluZUZ1bmN0aW9uKFtcIlxcXFxiZWdpblwiLCBcIlxcXFxlbmRcIl0sIHtcbiAgICBudW1BcmdzOiAxLFxuICAgIGFyZ1R5cGVzOiBbXCJ0ZXh0XCJdXG59LCBmdW5jdGlvbihjb250ZXh0LCBhcmdzKSB7XG4gICAgdmFyIG5hbWVHcm91cCA9IGFyZ3NbMF07XG4gICAgaWYgKG5hbWVHcm91cC50eXBlICE9PSBcIm9yZGdyb3VwXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoXCJJbnZhbGlkIGVudmlyb25tZW50IG5hbWVcIiwgbmFtZUdyb3VwKTtcbiAgICB9XG4gICAgdmFyIG5hbWUgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZUdyb3VwLnZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG5hbWUgKz0gbmFtZUdyb3VwLnZhbHVlW2ldLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImVudmlyb25tZW50XCIsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIG5hbWVHcm91cDogbmFtZUdyb3VwXG4gICAgfTtcbn0pO1xuIiwiLyoqXG4gKiBUaGVzZSBvYmplY3RzIHN0b3JlIGRhdGEgYWJvdXQgTWF0aE1MIG5vZGVzLiBUaGlzIGlzIHRoZSBNYXRoTUwgZXF1aXZhbGVudFxuICogb2YgdGhlIHR5cGVzIGluIGRvbVRyZWUuanMuIFNpbmNlIE1hdGhNTCBoYW5kbGVzIGl0cyBvd24gcmVuZGVyaW5nLCBhbmRcbiAqIHNpbmNlIHdlJ3JlIG1haW5seSB1c2luZyBNYXRoTUwgdG8gaW1wcm92ZSBhY2Nlc3NpYmlsaXR5LCB3ZSBkb24ndCBtYW5hZ2VcbiAqIGFueSBvZiB0aGUgc3R5bGluZyBzdGF0ZSB0aGF0IHRoZSBwbGFpbiBET00gbm9kZXMgZG8uXG4gKlxuICogVGhlIGB0b05vZGVgIGFuZCBgdG9NYXJrdXBgIGZ1bmN0aW9ucyB3b3JrIHNpbWxhcmx5IHRvIGhvdyB0aGV5IGRvIGluXG4gKiBkb21UcmVlLmpzLCBjcmVhdGluZyBuYW1lc3BhY2VkIERPTSBub2RlcyBhbmQgSFRNTCB0ZXh0IG1hcmt1cCByZXNwZWN0aXZlbHkuXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbi8qKlxuICogVGhpcyBub2RlIHJlcHJlc2VudHMgYSBnZW5lcmFsIHB1cnBvc2UgTWF0aE1MIG5vZGUgb2YgYW55IHR5cGUuIFRoZVxuICogY29uc3RydWN0b3IgcmVxdWlyZXMgdGhlIHR5cGUgb2Ygbm9kZSB0byBjcmVhdGUgKGZvciBleGFtcGxlLCBgXCJtb1wiYCBvclxuICogYFwibXNwYWNlXCJgLCBjb3JyZXNwb25kaW5nIHRvIGA8bW8+YCBhbmQgYDxtc3BhY2U+YCB0YWdzKS5cbiAqL1xuZnVuY3Rpb24gTWF0aE5vZGUodHlwZSwgY2hpbGRyZW4pIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbiB8fCBbXTtcbn1cblxuLyoqXG4gKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiBhIE1hdGhNTCBub2RlLiBNYXRoTUwgZGVwZW5kcyBvbiBhdHRyaWJ1dGVzIHRvIGNvbnZleSBhXG4gKiBzZW1hbnRpYyBjb250ZW50LCBzbyB0aGlzIGlzIHVzZWQgaGVhdmlseS5cbiAqL1xuTWF0aE5vZGUucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIE1hdGhNTC1uYW1lc3BhY2VkIERPTSBlbGVtZW50LlxuICovXG5NYXRoTm9kZS5wcm90b3R5cGUudG9Ob2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLCB0aGlzLnR5cGUpO1xuXG4gICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7XG4gICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuXG4gKi9cbk1hdGhOb2RlLnByb3RvdHlwZS50b01hcmt1cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtYXJrdXAgPSBcIjxcIiArIHRoaXMudHlwZTtcblxuICAgIC8vIEFkZCB0aGUgYXR0cmlidXRlc1xuICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkge1xuICAgICAgICAgICAgbWFya3VwICs9IFwiIFwiICsgYXR0ciArIFwiPVxcXCJcIjtcbiAgICAgICAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgICAgICAgIG1hcmt1cCArPSBcIlxcXCJcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIj5cIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpO1xuICAgIH1cblxuICAgIG1hcmt1cCArPSBcIjwvXCIgKyB0aGlzLnR5cGUgKyBcIj5cIjtcblxuICAgIHJldHVybiBtYXJrdXA7XG59O1xuXG4vKipcbiAqIFRoaXMgbm9kZSByZXByZXNlbnRzIGEgcGllY2Ugb2YgdGV4dC5cbiAqL1xuZnVuY3Rpb24gVGV4dE5vZGUodGV4dCkge1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgdGhlIHRleHQgbm9kZSBpbnRvIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuVGV4dE5vZGUucHJvdG90eXBlLnRvTm9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gSFRNTCBtYXJrdXAgKHdoaWNoIGlzIGp1c3QgdGhlIHRleHQgaXRzZWxmKS5cbiAqL1xuVGV4dE5vZGUucHJvdG90eXBlLnRvTWFya3VwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHV0aWxzLmVzY2FwZSh0aGlzLnRleHQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTWF0aE5vZGU6IE1hdGhOb2RlLFxuICAgIFRleHROb2RlOiBUZXh0Tm9kZVxufTtcbiIsIi8qKlxuICogVGhlIHJlc3VsdGluZyBwYXJzZSB0cmVlIG5vZGVzIG9mIHRoZSBwYXJzZSB0cmVlLlxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHByb3ZpZGUgcG9zaXRpb24gaW5mb3JtYXRpb24sIHNvIHRoYXQgYSBQYXJzZU5vZGUgY2FuXG4gKiBmdWxmaWwgYSByb2xlIHNpbWlsYXIgdG8gYSBUb2tlbiBpbiBlcnJvciByZXBvcnRpbmcuXG4gKiBGb3IgZGV0YWlscyBvbiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIHNlZSBUb2tlbiBjb25zdHJ1Y3Rvci5cbiAqIFByb3ZpZGluZyBzdWNoIGluZm9ybWF0aW9uIGNhbiBsZWFkIHRvIGJldHRlciBlcnJvciByZXBvcnRpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9ICB0eXBlICAgICAgIHR5cGUgb2Ygbm9kZSwgbGlrZSBlLmcuIFwib3JkZ3JvdXBcIlxuICogQHBhcmFtIHs/b2JqZWN0fSB2YWx1ZSAgICAgIHR5cGUtc3BlY2lmaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSAgbW9kZSAgICAgICBwYXJzZSBtb2RlIGluIGFjdGlvbiBmb3IgdGhpcyBub2RlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibWF0aFwiIG9yIFwidGV4dFwiXG4gKiBAcGFyYW0ge1Rva2VuPX0gZmlyc3RUb2tlbiAgZmlyc3QgdG9rZW4gb2YgdGhlIGlucHV0IGZvciB0aGlzIG5vZGUsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lsbCBvbWl0IHBvc2l0aW9uIGluZm9ybWF0aW9uIGlmIHVuc2V0XG4gKiBAcGFyYW0ge1Rva2VuPX0gbGFzdFRva2VuICAgbGFzdCB0b2tlbiBvZiB0aGUgaW5wdXQgZm9yIHRoaXMgbm9kZSxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGRlZmF1bHQgdG8gZmlyc3RUb2tlbiBpZiB1bnNldFxuICovXG5mdW5jdGlvbiBQYXJzZU5vZGUodHlwZSwgdmFsdWUsIG1vZGUsIGZpcnN0VG9rZW4sIGxhc3RUb2tlbikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgaWYgKGZpcnN0VG9rZW4gJiYgKCFsYXN0VG9rZW4gfHwgbGFzdFRva2VuLmxleGVyID09PSBmaXJzdFRva2VuLmxleGVyKSkge1xuICAgICAgICB0aGlzLmxleGVyID0gZmlyc3RUb2tlbi5sZXhlcjtcbiAgICAgICAgdGhpcy5zdGFydCA9IGZpcnN0VG9rZW4uc3RhcnQ7XG4gICAgICAgIHRoaXMuZW5kID0gKGxhc3RUb2tlbiB8fCBmaXJzdFRva2VuKS5lbmQ7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQYXJzZU5vZGU6IFBhcnNlTm9kZVxufTtcblxuIiwiLyoqXG4gKiBQcm92aWRlcyBhIHNpbmdsZSBmdW5jdGlvbiBmb3IgcGFyc2luZyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyXG4gKiBUT0RPKGVtaWx5KTogUmVtb3ZlIHRoaXNcbiAqL1xuXG52YXIgUGFyc2VyID0gcmVxdWlyZShcIi4vUGFyc2VyXCIpO1xuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHVzaW5nIGEgUGFyc2VyLCB0aGVuIHJldHVybnMgdGhlIHBhcnNlZCByZXN1bHQuXG4gKi9cbnZhciBwYXJzZVRyZWUgPSBmdW5jdGlvbih0b1BhcnNlLCBzZXR0aW5ncykge1xuICAgIGlmICghKHR5cGVvZiB0b1BhcnNlID09PSAnc3RyaW5nJyB8fCB0b1BhcnNlIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdLYVRlWCBjYW4gb25seSBwYXJzZSBzdHJpbmcgdHlwZWQgZXhwcmVzc2lvbicpO1xuICAgIH1cbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcih0b1BhcnNlLCBzZXR0aW5ncyk7XG5cbiAgICByZXR1cm4gcGFyc2VyLnBhcnNlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlVHJlZTtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGhvbGRzIGEgbGlzdCBvZiBhbGwgbm8tYXJndW1lbnQgZnVuY3Rpb25zIGFuZCBzaW5nbGUtY2hhcmFjdGVyXG4gKiBzeW1ib2xzIChsaWtlICdhJyBvciAnOycpLlxuICpcbiAqIEZvciBlYWNoIG9mIHRoZSBzeW1ib2xzLCB0aGVyZSBhcmUgdGhyZWUgcHJvcGVydGllcyB0aGV5IGNhbiBoYXZlOlxuICogLSBmb250IChyZXF1aXJlZCk6IHRoZSBmb250IHRvIGJlIHVzZWQgZm9yIHRoaXMgc3ltYm9sLiBFaXRoZXIgXCJtYWluXCIgKHRoZVxuICAgICBub3JtYWwgZm9udCksIG9yIFwiYW1zXCIgKHRoZSBhbXMgZm9udHMpLlxuICogLSBncm91cCAocmVxdWlyZWQpOiB0aGUgUGFyc2VOb2RlIGdyb3VwIHR5cGUgdGhlIHN5bWJvbCBzaG91bGQgaGF2ZSAoaS5lLlxuICAgICBcInRleHRvcmRcIiwgXCJtYXRob3JkXCIsIGV0YykuXG4gICAgIFNlZSBodHRwczovL2dpdGh1Yi5jb20vS2hhbi9LYVRlWC93aWtpL0V4YW1pbmluZy1UZVgjZ3JvdXAtdHlwZXNcbiAqIC0gcmVwbGFjZTogdGhlIGNoYXJhY3RlciB0aGF0IHRoaXMgc3ltYm9sIG9yIGZ1bmN0aW9uIHNob3VsZCBiZVxuICogICByZXBsYWNlZCB3aXRoIChpLmUuIFwiXFxwaGlcIiBoYXMgYSByZXBsYWNlIHZhbHVlIG9mIFwiXFx1MDNkNVwiLCB0aGUgcGhpXG4gKiAgIGNoYXJhY3RlciBpbiB0aGUgbWFpbiBmb250KS5cbiAqXG4gKiBUaGUgb3V0ZXJtb3N0IG1hcCBpbiB0aGUgdGFibGUgaW5kaWNhdGVzIHdoYXQgbW9kZSB0aGUgc3ltYm9scyBzaG91bGQgYmVcbiAqIGFjY2VwdGVkIGluIChlLmcuIFwibWF0aFwiIG9yIFwidGV4dFwiKS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYXRoOiB7fSxcbiAgICB0ZXh0OiB7fVxufTtcblxuZnVuY3Rpb24gZGVmaW5lU3ltYm9sKG1vZGUsIGZvbnQsIGdyb3VwLCByZXBsYWNlLCBuYW1lKSB7XG4gICAgbW9kdWxlLmV4cG9ydHNbbW9kZV1bbmFtZV0gPSB7XG4gICAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICAgIGdyb3VwOiBncm91cCxcbiAgICAgICAgcmVwbGFjZTogcmVwbGFjZVxuICAgIH07XG59XG5cbi8vIFNvbWUgYWJicmV2aWF0aW9ucyBmb3IgY29tbW9ubHkgdXNlZCBzdHJpbmdzLlxuLy8gVGhpcyBoZWxwcyBtaW5pZnkgdGhlIGNvZGUsIGFuZCBhbHNvIHNwb3R0aW5nIHR5cG9zIHVzaW5nIGpzaGludC5cblxuLy8gbW9kZXM6XG52YXIgbWF0aCA9IFwibWF0aFwiO1xudmFyIHRleHQgPSBcInRleHRcIjtcblxuLy8gZm9udHM6XG52YXIgbWFpbiA9IFwibWFpblwiO1xudmFyIGFtcyA9IFwiYW1zXCI7XG5cbi8vIGdyb3VwczpcbnZhciBhY2NlbnQgPSBcImFjY2VudFwiO1xudmFyIGJpbiA9IFwiYmluXCI7XG52YXIgY2xvc2UgPSBcImNsb3NlXCI7XG52YXIgaW5uZXIgPSBcImlubmVyXCI7XG52YXIgbWF0aG9yZCA9IFwibWF0aG9yZFwiO1xudmFyIG9wID0gXCJvcFwiO1xudmFyIG9wZW4gPSBcIm9wZW5cIjtcbnZhciBwdW5jdCA9IFwicHVuY3RcIjtcbnZhciByZWwgPSBcInJlbFwiO1xudmFyIHNwYWNpbmcgPSBcInNwYWNpbmdcIjtcbnZhciB0ZXh0b3JkID0gXCJ0ZXh0b3JkXCI7XG5cbi8vIE5vdyBjb21lcyB0aGUgc3ltYm9sIHRhYmxlXG5cbi8vIFJlbGF0aW9uIFN5bWJvbHNcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2MVwiLCBcIlxcXFxlcXVpdlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI3YVwiLCBcIlxcXFxwcmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjdiXCIsIFwiXFxcXHN1Y2NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyM2NcIiwgXCJcXFxcc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmE1XCIsIFwiXFxcXHBlcnBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTJhYWZcIiwgXCJcXFxccHJlY2VxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyYWIwXCIsIFwiXFxcXHN1Y2NlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0M1wiLCBcIlxcXFxzaW1lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNmFcIiwgXCJcXFxcbGxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNmJcIiwgXCJcXFxcZ2dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNGRcIiwgXCJcXFxcYXN5bXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMjVcIiwgXCJcXFxccGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYzhcIiwgXCJcXFxcYm93dGllXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMzIzXCIsIFwiXFxcXHNtaWxlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjkxXCIsIFwiXFxcXHNxc3Vic2V0ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyOTJcIiwgXCJcXFxcc3FzdXBzZXRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI1MFwiLCBcIlxcXFxkb3RlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjMyMlwiLCBcIlxcXFxmcm93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwYlwiLCBcIlxcXFxuaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIxZFwiLCBcIlxcXFxwcm9wdG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYTJcIiwgXCJcXFxcdmRhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyYTNcIiwgXCJcXFxcZGFzaHZcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyMGJcIiwgXCJcXFxcb3duc1wiKTtcblxuLy8gUHVuY3R1YXRpb25cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBwdW5jdCwgXCJcXHUwMDJlXCIsIFwiXFxcXGxkb3RwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHB1bmN0LCBcIlxcdTIyYzVcIiwgXCJcXFxcY2RvdHBcIik7XG5cbi8vIE1pc2MgU3ltYm9sc1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyM1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyM1wiLCBcIlxcXFwjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDAyNlwiLCBcIlxcXFwmXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEzNVwiLCBcIlxcXFxhbGVwaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMDBcIiwgXCJcXFxcZm9yYWxsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjEwZlwiLCBcIlxcXFxoYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwM1wiLCBcIlxcXFxleGlzdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjA3XCIsIFwiXFxcXG5hYmxhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjY2ZFwiLCBcIlxcXFxmbGF0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExM1wiLCBcIlxcXFxlbGxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjZlXCIsIFwiXFxcXG5hdHVyYWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYzXCIsIFwiXFxcXGNsdWJzdWl0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExOFwiLCBcIlxcXFx3cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NmZcIiwgXCJcXFxcc2hhcnBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyNjYyXCIsIFwiXFxcXGRpYW1vbmRzdWl0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExY1wiLCBcIlxcXFxSZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjFcIiwgXCJcXFxcaGVhcnRzdWl0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjExMVwiLCBcIlxcXFxJbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTI2NjBcIiwgXCJcXFxcc3BhZGVzdWl0XCIpO1xuXG4vLyBNYXRoIGFuZCBUZXh0XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMjFcIiwgXCJcXFxcZGRhZ1wiKTtcblxuLy8gTGFyZ2UgRGVsaW1pdGVyc1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTIzYjFcIiwgXCJcXFxccm1vdXN0YWNoZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIzYjBcIiwgXCJcXFxcbG1vdXN0YWNoZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyN2VmXCIsIFwiXFxcXHJncm91cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTI3ZWVcIiwgXCJcXFxcbGdyb3VwXCIpO1xuXG4vLyBCaW5hcnkgT3BlcmF0b3JzXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTNcIiwgXCJcXFxcbXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTZcIiwgXCJcXFxcb21pbnVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjhlXCIsIFwiXFxcXHVwbHVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjkzXCIsIFwiXFxcXHNxY2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE3XCIsIFwiXFxcXGFzdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjI5NFwiLCBcIlxcXFxzcWN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjVlZlwiLCBcIlxcXFxiaWdjaXJjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE5XCIsIFwiXFxcXGJ1bGxldFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjAyMVwiLCBcIlxcXFxkZGFnZ2VyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjQwXCIsIFwiXFxcXHdyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyYTNmXCIsIFwiXFxcXGFtYWxnXCIpO1xuXG4vLyBBcnJvdyBTeW1ib2xzXG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjVcIiwgXCJcXFxcbG9uZ2xlZnRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMFwiLCBcIlxcXFxMZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTI3ZjhcIiwgXCJcXFxcTG9uZ2xlZnRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmNlwiLCBcIlxcXFxsb25ncmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkMlwiLCBcIlxcXFxSaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y5XCIsIFwiXFxcXExvbmdyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk0XCIsIFwiXFxcXGxlZnRyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2Y3XCIsIFwiXFxcXGxvbmdsZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkNFwiLCBcIlxcXFxMZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjdmYVwiLCBcIlxcXFxMb25nbGVmdHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYTZcIiwgXCJcXFxcbWFwc3RvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyN2ZjXCIsIFwiXFxcXGxvbmdtYXBzdG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTdcIiwgXCJcXFxcbmVhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFhOVwiLCBcIlxcXFxob29rbGVmdGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWFhXCIsIFwiXFxcXGhvb2tyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk4XCIsIFwiXFxcXHNlYXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxYmNcIiwgXCJcXFxcbGVmdGhhcnBvb251cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFjMFwiLCBcIlxcXFxyaWdodGhhcnBvb251cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5OVwiLCBcIlxcXFxzd2Fycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWJkXCIsIFwiXFxcXGxlZnRoYXJwb29uZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFjMVwiLCBcIlxcXFxyaWdodGhhcnBvb25kb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTk2XCIsIFwiXFxcXG53YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxY2NcIiwgXCJcXFxccmlnaHRsZWZ0aGFycG9vbnNcIik7XG5cbi8vIEFNUyBOZWdhdGVkIEJpbmFyeSBSZWxhdGlvbnNcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjZlXCIsIFwiXFxcXG5sZXNzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTBcIiwgXCJcXFxcbmxlcXNsYW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMTFcIiwgXCJcXFxcbmxlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4N1wiLCBcIlxcXFxsbmVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNjhcIiwgXCJcXFxcbG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAwY1wiLCBcIlxcXFxsdmVydG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlNlwiLCBcIlxcXFxsbnNpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYTg5XCIsIFwiXFxcXGxuYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODBcIiwgXCJcXFxcbnByZWNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlMFwiLCBcIlxcXFxucHJlY2VxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZThcIiwgXCJcXFxccHJlY25zaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiOVwiLCBcIlxcXFxwcmVjbmFwcHJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQxXCIsIFwiXFxcXG5zaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAwNlwiLCBcIlxcXFxuc2hvcnRtaWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyNFwiLCBcIlxcXFxubWlkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWNcIiwgXCJcXFxcbnZkYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWRcIiwgXCJcXFxcbnZEYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWFcIiwgXCJcXFxcbnRyaWFuZ2xlbGVmdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmVjXCIsIFwiXFxcXG50cmlhbmdsZWxlZnRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhhXCIsIFwiXFxcXHN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDFhXCIsIFwiXFxcXHZhcnN1YnNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNiXCIsIFwiXFxcXHN1YnNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxN1wiLCBcIlxcXFx2YXJzdWJzZXRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNmZcIiwgXCJcXFxcbmd0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDBmXCIsIFwiXFxcXG5nZXFzbGFudFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDBlXCIsIFwiXFxcXG5nZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODhcIiwgXCJcXFxcZ25lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjY5XCIsIFwiXFxcXGduZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMGRcIiwgXCJcXFxcZ3ZlcnRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTdcIiwgXCJcXFxcZ25zaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4YVwiLCBcIlxcXFxnbmFwcHJveFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjgxXCIsIFwiXFxcXG5zdWNjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZTFcIiwgXCJcXFxcbnN1Y2NlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmU5XCIsIFwiXFxcXHN1Y2Nuc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYmFcIiwgXCJcXFxcc3VjY25hcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0NlwiLCBcIlxcXFxuY29uZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDA3XCIsIFwiXFxcXG5zaG9ydHBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMjZcIiwgXCJcXFxcbnBhcmFsbGVsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWZcIiwgXCJcXFxcblZEYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZWJcIiwgXCJcXFxcbnRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJlZFwiLCBcIlxcXFxudHJpYW5nbGVyaWdodGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdWUwMThcIiwgXCJcXFxcbnN1cHNldGVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjhiXCIsIFwiXFxcXHN1cHNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDFiXCIsIFwiXFxcXHZhcnN1cHNldG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWNjXCIsIFwiXFxcXHN1cHNldG5lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1ZTAxOVwiLCBcIlxcXFx2YXJzdXBzZXRuZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWVcIiwgXCJcXFxcblZkYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYjVcIiwgXCJcXFxccHJlY25lcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmFiNlwiLCBcIlxcXFxzdWNjbmVxcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHVlMDE2XCIsIFwiXFxcXG5zdWJzZXRlcXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiNFwiLCBcIlxcXFx1bmxoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmI1XCIsIFwiXFxcXHVucmhkXCIpO1xuXG4vLyBBTVMgTmVnYXRlZCBBcnJvd3NcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMTlhXCIsIFwiXFxcXG5sZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5YlwiLCBcIlxcXFxucmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWNkXCIsIFwiXFxcXG5MZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjZlwiLCBcIlxcXFxuUmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFlXCIsIFwiXFxcXG5sZWZ0cmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWNlXCIsIFwiXFxcXG5MZWZ0cmlnaHRhcnJvd1wiKTtcblxuLy8gQU1TIE1pc2NcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWIzXCIsIFwiXFxcXHZhcnRyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTBmXCIsIFwiXFxcXGhzbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViZFwiLCBcIlxcXFx0cmlhbmdsZWRvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1Y2FcIiwgXCJcXFxcbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjRjOFwiLCBcIlxcXFxjaXJjbGVkU1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDBhZVwiLCBcIlxcXFxjaXJjbGVkUlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjIyMVwiLCBcIlxcXFxtZWFzdXJlZGFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjA0XCIsIFwiXFxcXG5leGlzdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMjdcIiwgXCJcXFxcbWhvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTMyXCIsIFwiXFxcXEZpbnZcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxNDFcIiwgXCJcXFxcR2FtZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDA2YlwiLCBcIlxcXFxCYmJrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMDM1XCIsIFwiXFxcXGJhY2twcmltZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjViMlwiLCBcIlxcXFxibGFja3RyaWFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWJjXCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWEwXCIsIFwiXFxcXGJsYWNrc3F1YXJlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyOWViXCIsIFwiXFxcXGJsYWNrbG96ZW5nZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjYwNVwiLCBcIlxcXFxiaWdzdGFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjIyXCIsIFwiXFxcXHNwaGVyaWNhbGFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjAxXCIsIFwiXFxcXGNvbXBsZW1lbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAwZjBcIiwgXCJcXFxcZXRoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNTcxXCIsIFwiXFxcXGRpYWd1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjU3MlwiLCBcIlxcXFxkaWFnZG93blwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjVhMVwiLCBcIlxcXFxzcXVhcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTI1YTFcIiwgXCJcXFxcQm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNWNhXCIsIFwiXFxcXERpYW1vbmRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTAwYTVcIiwgXCJcXFxceWVuXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyNzEzXCIsIFwiXFxcXGNoZWNrbWFya1wiKTtcblxuLy8gQU1TIEhlYnJld1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTM2XCIsIFwiXFxcXGJldGhcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCBcIlxcdTIxMzhcIiwgXCJcXFxcZGFsZXRoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMTM3XCIsIFwiXFxcXGdpbWVsXCIpO1xuXG4vLyBBTVMgR3JlZWtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MDNkZFwiLCBcIlxcXFxkaWdhbW1hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUwM2YwXCIsIFwiXFxcXHZhcmthcHBhXCIpO1xuXG4vLyBBTVMgRGVsaW1pdGVyc1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgb3BlbiwgXCJcXHUyNTBjXCIsIFwiXFxcXHVsY29ybmVyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgY2xvc2UsIFwiXFx1MjUxMFwiLCBcIlxcXFx1cmNvcm5lclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIG9wZW4sIFwiXFx1MjUxNFwiLCBcIlxcXFxsbGNvcm5lclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGNsb3NlLCBcIlxcdTI1MThcIiwgXCJcXFxcbHJjb3JuZXJcIik7XG5cbi8vIEFNUyBCaW5hcnkgUmVsYXRpb25zXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2NlwiLCBcIlxcXFxsZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhN2RcIiwgXCJcXFxcbGVxc2xhbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE5NVwiLCBcIlxcXFxlcXNsYW50bGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcyXCIsIFwiXFxcXGxlc3NzaW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE4NVwiLCBcIlxcXFxsZXNzYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNGFcIiwgXCJcXFxcYXBwcm94ZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJkNlwiLCBcIlxcXFxsZXNzZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDhcIiwgXCJcXFxcbGxsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzZcIiwgXCJcXFxcbGVzc2d0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRhXCIsIFwiXFxcXGxlc3NlcWd0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYThiXCIsIFwiXFxcXGxlc3NlcXFndHJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1MVwiLCBcIlxcXFxkb3RlcWRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUzXCIsIFwiXFxcXHJpc2luZ2RvdHNlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjUyXCIsIFwiXFxcXGZhbGxpbmdkb3RzZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzZFwiLCBcIlxcXFxiYWNrc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyY2RcIiwgXCJcXFxcYmFja3NpbWVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYzVcIiwgXCJcXFxcc3Vic2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDBcIiwgXCJcXFxcU3Vic2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOGZcIiwgXCJcXFxcc3FzdWJzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3Y1wiLCBcIlxcXFxwcmVjY3VybHllcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRlXCIsIFwiXFxcXGN1cmx5ZXFwcmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2VcIiwgXCJcXFxccHJlY3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI3XCIsIFwiXFxcXHByZWNhcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiMlwiLCBcIlxcXFx2YXJ0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiNFwiLCBcIlxcXFx0cmlhbmdsZWxlZnRlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmE4XCIsIFwiXFxcXHZEYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYWFcIiwgXCJcXFxcVnZkYXNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIzMjNcIiwgXCJcXFxcc21hbGxzbWlsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMzIyXCIsIFwiXFxcXHNtYWxsZnJvd25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0ZlwiLCBcIlxcXFxidW1wZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI0ZVwiLCBcIlxcXFxCdW1wZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2N1wiLCBcIlxcXFxnZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhN2VcIiwgXCJcXFxcZ2Vxc2xhbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MmE5NlwiLCBcIlxcXFxlcXNsYW50Z3RyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzNcIiwgXCJcXFxcZ3Ryc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhODZcIiwgXCJcXFxcZ3RyYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDdcIiwgXCJcXFxcZ3RyZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDlcIiwgXCJcXFxcZ2dnXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzdcIiwgXCJcXFxcZ3RybGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRiXCIsIFwiXFxcXGd0cmVxbGVzc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYThjXCIsIFwiXFxcXGd0cmVxcWxlc3NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1NlwiLCBcIlxcXFxlcWNpcmNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1N1wiLCBcIlxcXFxjaXJjZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1Y1wiLCBcIlxcXFx0cmlhbmdsZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzY1wiLCBcIlxcXFx0aGlja3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQ4XCIsIFwiXFxcXHRoaWNrYXBwcm94XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTJhYzZcIiwgXCJcXFxcc3Vwc2V0ZXFxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDFcIiwgXCJcXFxcU3Vwc2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyOTBcIiwgXCJcXFxcc3FzdXBzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI3ZFwiLCBcIlxcXFxzdWNjY3VybHllcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMmRmXCIsIFwiXFxcXGN1cmx5ZXFzdWNjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyN2ZcIiwgXCJcXFxcc3VjY3NpbVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyYWI4XCIsIFwiXFxcXHN1Y2NhcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiM1wiLCBcIlxcXFx2YXJ0cmlhbmdsZXJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYjVcIiwgXCJcXFxcdHJpYW5nbGVyaWdodGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyYTlcIiwgXCJcXFxcVmRhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIyM1wiLCBcIlxcXFxzaG9ydG1pZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjI1XCIsIFwiXFxcXHNob3J0cGFyYWxsZWxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI2Y1wiLCBcIlxcXFxiZXR3ZWVuXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyZDRcIiwgXCJcXFxccGl0Y2hmb3JrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyMWRcIiwgXCJcXFxcdmFycHJvcHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTI1YzBcIiwgXCJcXFxcYmxhY2t0cmlhbmdsZWxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIzNFwiLCBcIlxcXFx0aGVyZWZvcmVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjIwZFwiLCBcIlxcXFxiYWNrZXBzaWxvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyNWI2XCIsIFwiXFxcXGJsYWNrdHJpYW5nbGVyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjM1XCIsIFwiXFxcXGJlY2F1c2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkOFwiLCBcIlxcXFxsbGxlc3NcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJkOVwiLCBcIlxcXFxnZ2d0clwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmIyXCIsIFwiXFxcXGxoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmIzXCIsIFwiXFxcXHJoZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjQyXCIsIFwiXFxcXGVxc2ltXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmM4XCIsIFwiXFxcXEpvaW5cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjI1MVwiLCBcIlxcXFxEb3RlcVwiKTtcblxuLy8gQU1TIEJpbmFyeSBPcGVyYXRvcnNcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjE0XCIsIFwiXFxcXGRvdHBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjIxNlwiLCBcIlxcXFxzbWFsbHNldG1pbnVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDJcIiwgXCJcXFxcQ2FwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyZDNcIiwgXCJcXFxcQ3VwXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTJhNWVcIiwgXCJcXFxcZG91YmxlYmFyd2VkZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5ZlwiLCBcIlxcXFxib3htaW51c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjllXCIsIFwiXFxcXGJveHBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjN1wiLCBcIlxcXFxkaXZpZGVvbnRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYzlcIiwgXCJcXFxcbHRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2FcIiwgXCJcXFxccnRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2JcIiwgXCJcXFxcbGVmdHRocmVldGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjY1wiLCBcIlxcXFxyaWdodHRocmVldGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjZlwiLCBcIlxcXFxjdXJseXdlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyY2VcIiwgXCJcXFxcY3VybHl2ZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjI5ZFwiLCBcIlxcXFxjaXJjbGVkZGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjliXCIsIFwiXFxcXGNpcmNsZWRhc3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJjNVwiLCBcIlxcXFxjZW50ZXJkb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sIFwiXFx1MjJiYVwiLCBcIlxcXFxpbnRlcmNhbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQyXCIsIFwiXFxcXGRvdWJsZWNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmQzXCIsIFwiXFxcXGRvdWJsZWN1cFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmEwXCIsIFwiXFxcXGJveHRpbWVzXCIpO1xuXG4vLyBBTVMgQXJyb3dzXG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFlMlwiLCBcIlxcXFxkYXNocmlnaHRhcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWUwXCIsIFwiXFxcXGRhc2hsZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjN1wiLCBcIlxcXFxsZWZ0bGVmdGFycm93c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWM2XCIsIFwiXFxcXGxlZnRyaWdodGFycm93c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWRhXCIsIFwiXFxcXExsZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjE5ZVwiLCBcIlxcXFx0d29oZWFkbGVmdGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYTJcIiwgXCJcXFxcbGVmdGFycm93dGFpbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFiXCIsIFwiXFxcXGxvb3BhcnJvd2xlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjYlwiLCBcIlxcXFxsZWZ0cmlnaHRoYXJwb29uc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWI2XCIsIFwiXFxcXGN1cnZlYXJyb3dsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmFcIiwgXCJcXFxcY2lyY2xlYXJyb3dsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjBcIiwgXCJcXFxcTHNoXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzhcIiwgXCJcXFxcdXB1cGFycm93c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWJmXCIsIFwiXFxcXHVwaGFycG9vbmxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjM1wiLCBcIlxcXFxkb3duaGFycG9vbmxlZnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjJiOFwiLCBcIlxcXFxtdWx0aW1hcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFkXCIsIFwiXFxcXGxlZnRyaWdodHNxdWlnYXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjOVwiLCBcIlxcXFxyaWdodHJpZ2h0YXJyb3dzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYzRcIiwgXCJcXFxccmlnaHRsZWZ0YXJyb3dzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYTBcIiwgXCJcXFxcdHdvaGVhZHJpZ2h0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFhM1wiLCBcIlxcXFxyaWdodGFycm93dGFpbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWFjXCIsIFwiXFxcXGxvb3BhcnJvd3JpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYjdcIiwgXCJcXFxcY3VydmVhcnJvd3JpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmJcIiwgXCJcXFxcY2lyY2xlYXJyb3dyaWdodFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWIxXCIsIFwiXFxcXFJzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWNhXCIsIFwiXFxcXGRvd25kb3duYXJyb3dzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmVcIiwgXCJcXFxcdXBoYXJwb29ucmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsIFwiXFx1MjFjMlwiLCBcIlxcXFxkb3duaGFycG9vbnJpZ2h0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZGRcIiwgXCJcXFxccmlnaHRzcXVpZ2Fycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxZGRcIiwgXCJcXFxcbGVhZHN0b1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMWRiXCIsIFwiXFxcXFJyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIxYmVcIiwgXCJcXFxccmVzdHJpY3Rpb25cIik7XG5cbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCJgXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiJFwiLCBcIlxcXFwkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiJVwiLCBcIlxcXFwlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiX1wiLCBcIlxcXFxfXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIyMFwiLCBcIlxcXFxhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMWVcIiwgXCJcXFxcaW5mdHlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDMyXCIsIFwiXFxcXHByaW1lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjViM1wiLCBcIlxcXFx0cmlhbmdsZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOTNcIiwgXCJcXFxcR2FtbWFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMzk0XCIsIFwiXFxcXERlbHRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5OFwiLCBcIlxcXFxUaGV0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzOWJcIiwgXCJcXFxcTGFtYmRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDM5ZVwiLCBcIlxcXFxYaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTBcIiwgXCJcXFxcUGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2EzXCIsIFwiXFxcXFNpZ21hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhNVwiLCBcIlxcXFxVcHNpbG9uXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MDNhNlwiLCBcIlxcXFxQaGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwM2E4XCIsIFwiXFxcXFBzaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAzYTlcIiwgXCJcXFxcT21lZ2FcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUwMGFjXCIsIFwiXFxcXG5lZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYWNcIiwgXCJcXFxcbG5vdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyYTRcIiwgXCJcXFxcdG9wXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjJhNVwiLCBcIlxcXFxib3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjA1XCIsIFwiXFxcXGVtcHR5c2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgXCJcXHUyMjA1XCIsIFwiXFxcXHZhcm5vdGhpbmdcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2IxXCIsIFwiXFxcXGFscGhhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiMlwiLCBcIlxcXFxiZXRhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiM1wiLCBcIlxcXFxnYW1tYVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjRcIiwgXCJcXFxcZGVsdGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2Y1XCIsIFwiXFxcXGVwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I2XCIsIFwiXFxcXHpldGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I3XCIsIFwiXFxcXGV0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYjhcIiwgXCJcXFxcdGhldGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2I5XCIsIFwiXFxcXGlvdGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JhXCIsIFwiXFxcXGthcHBhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiYlwiLCBcIlxcXFxsYW1iZGFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2JjXCIsIFwiXFxcXG11XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiZFwiLCBcIlxcXFxudVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYmVcIiwgXCJcXFxceGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJvXCIsIFwiXFxcXG9taWNyb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2MwXCIsIFwiXFxcXHBpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjMVwiLCBcIlxcXFxyaG9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2MzXCIsIFwiXFxcXHNpZ21hXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjNFwiLCBcIlxcXFx0YXVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M1XCIsIFwiXFxcXHVwc2lsb25cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2Q1XCIsIFwiXFxcXHBoaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzdcIiwgXCJcXFxcY2hpXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNjOFwiLCBcIlxcXFxwc2lcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M5XCIsIFwiXFxcXG9tZWdhXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNiNVwiLCBcIlxcXFx2YXJlcHNpbG9uXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIFwiXFx1MDNkMVwiLCBcIlxcXFx2YXJ0aGV0YVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzZDZcIiwgXCJcXFxcdmFycGlcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2YxXCIsIFwiXFxcXHZhcnJob1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAzYzJcIiwgXCJcXFxcdmFyc2lnbWFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwM2M2XCIsIFwiXFxcXHZhcnBoaVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIxN1wiLCBcIipcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIitcIiwgXCIrXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjEyXCIsIFwiLVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjJjNVwiLCBcIlxcXFxjZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjE4XCIsIFwiXFxcXGNpcmNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTAwZjdcIiwgXCJcXFxcZGl2XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUwMGIxXCIsIFwiXFxcXHBtXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUwMGQ3XCIsIFwiXFxcXHRpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjI5XCIsIFwiXFxcXGNhcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyYVwiLCBcIlxcXFxjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMTZcIiwgXCJcXFxcc2V0bWludXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcbGFuZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjIyOFwiLCBcIlxcXFxsb3JcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjdcIiwgXCJcXFxcd2VkZ2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyMjhcIiwgXCJcXFxcdmVlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIxYVwiLCBcIlxcXFxzdXJkXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiKFwiLCBcIihcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJbXCIsIFwiW1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTI3ZThcIiwgXCJcXFxcbGFuZ2xlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiXFx1MjIyM1wiLCBcIlxcXFxsdmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIyMjVcIiwgXCJcXFxcbFZlcnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiKVwiLCBcIilcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXVwiLCBcIl1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiP1wiLCBcIj9cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiIVwiLCBcIiFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXFx1MjdlOVwiLCBcIlxcXFxyYW5nbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwiXFx1MjIyM1wiLCBcIlxcXFxydmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyMjI1XCIsIFwiXFxcXHJWZXJ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI9XCIsIFwiPVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPFwiLCBcIjxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIj5cIiwgXCI+XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI6XCIsIFwiOlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI0OFwiLCBcIlxcXFxhcHByb3hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNDVcIiwgXCJcXFxcY29uZ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI2NVwiLCBcIlxcXFxnZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTBcIiwgXCJcXFxcZ2V0c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiPlwiLCBcIlxcXFxndFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwOFwiLCBcIlxcXFxpblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjIwOVwiLCBcIlxcXFxub3RpblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjI4MlwiLCBcIlxcXFxzdWJzZXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyODNcIiwgXCJcXFxcc3Vwc2V0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjg2XCIsIFwiXFxcXHN1YnNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjg3XCIsIFwiXFxcXHN1cHNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODhcIiwgXCJcXFxcbnN1YnNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyODlcIiwgXCJcXFxcbnN1cHNldGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMmE4XCIsIFwiXFxcXG1vZGVsc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MFwiLCBcIlxcXFxsZWZ0YXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNjRcIiwgXCJcXFxcbGVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIyNjRcIiwgXCJcXFxcbGVxXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCI8XCIsIFwiXFxcXGx0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjYwXCIsIFwiXFxcXG5lXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMjYwXCIsIFwiXFxcXG5lcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MlwiLCBcIlxcXFxyaWdodGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMTkyXCIsIFwiXFxcXHRvXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCBcIlxcdTIyNzFcIiwgXCJcXFxcbmdlcVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgXCJcXHUyMjcwXCIsIFwiXFxcXG5sZXFcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxcIVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJ+XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHNwYWNpbmcsIG51bGwsIFwiXFxcXCxcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxcOlwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBudWxsLCBcIlxcXFw7XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHNwYWNpbmcsIG51bGwsIFwiXFxcXGVuc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxccXF1YWRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgXCJcXFxccXVhZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcc3BhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiLFwiLCBcIixcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiO1wiLCBcIjtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsIFwiOlwiLCBcIlxcXFxjb2xvblwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMmJjXCIsIFwiXFxcXGJhcndlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYmJcIiwgXCJcXFxcdmVlYmFyXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk5XCIsIFwiXFxcXG9kb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTVcIiwgXCJcXFxcb3BsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTIyOTdcIiwgXCJcXFxcb3RpbWVzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjIwMlwiLCBcIlxcXFxwYXJ0aWFsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMjk4XCIsIFwiXFxcXG9zbGFzaFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgXCJcXHUyMjlhXCIsIFwiXFxcXGNpcmNsZWRjaXJjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCBcIlxcdTIyYTFcIiwgXCJcXFxcYm94ZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyNWIzXCIsIFwiXFxcXGJpZ3RyaWFuZ2xldXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YmRcIiwgXCJcXFxcYmlndHJpYW5nbGVkb3duXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMDIwXCIsIFwiXFxcXGRhZ2dlclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sIFwiXFx1MjJjNFwiLCBcIlxcXFxkaWFtb25kXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyMmM2XCIsIFwiXFxcXHN0YXJcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCBcIlxcdTI1YzNcIiwgXCJcXFxcdHJpYW5nbGVsZWZ0XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgXCJcXHUyNWI5XCIsIFwiXFxcXHRyaWFuZ2xlcmlnaHRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJ7XCIsIFwiXFxcXHtcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwifVwiLCBcIlxcXFx9XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwie1wiLCBcIlxcXFxsYnJhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsIFwifVwiLCBcIlxcXFxyYnJhY2VcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgXCJbXCIsIFwiXFxcXGxicmFja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJdXCIsIFwiXFxcXHJicmFja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCBcIlxcdTIzMGFcIiwgXCJcXFxcbGZsb29yXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCBcIlxcdTIzMGJcIiwgXCJcXFxccmZsb29yXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sIFwiXFx1MjMwOFwiLCBcIlxcXFxsY2VpbFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgXCJcXHUyMzA5XCIsIFwiXFxcXHJjZWlsXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFxcXFwiLCBcIlxcXFxiYWNrc2xhc2hcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMjIzXCIsIFwifFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjNcIiwgXCJcXFxcdmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjVcIiwgXCJcXFxcfFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIyMjVcIiwgXCJcXFxcVmVydFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5MVwiLCBcIlxcXFx1cGFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWQxXCIsIFwiXFxcXFVwYXJyb3dcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCBcIlxcdTIxOTNcIiwgXCJcXFxcZG93bmFycm93XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgXCJcXHUyMWQzXCIsIFwiXFxcXERvd25hcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjE5NVwiLCBcIlxcXFx1cGRvd25hcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsIFwiXFx1MjFkNVwiLCBcIlxcXFxVcGRvd25hcnJvd1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMjEwXCIsIFwiXFxcXGNvcHJvZFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMmMxXCIsIFwiXFxcXGJpZ3ZlZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMmMwXCIsIFwiXFxcXGJpZ3dlZGdlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGgsIG9wLCBcIlxcdTJhMDRcIiwgXCJcXFxcYmlndXBsdXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjJjMlwiLCBcIlxcXFxiaWdjYXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjJjM1wiLCBcIlxcXFxiaWdjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxpbnRvcFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMjJjXCIsIFwiXFxcXGlpbnRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyZFwiLCBcIlxcXFxpaWludFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyMjBmXCIsIFwiXFxcXHByb2RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIxMVwiLCBcIlxcXFxzdW1cIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MmEwMlwiLCBcIlxcXFxiaWdvdGltZXNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MmEwMVwiLCBcIlxcXFxiaWdvcGx1c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYXRoLCBvcCwgXCJcXHUyYTAwXCIsIFwiXFxcXGJpZ29kb3RcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyZVwiLCBcIlxcXFxvaW50XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1hdGgsIG9wLCBcIlxcdTJhMDZcIiwgXCJcXFxcYmlnc3FjdXBcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWF0aCwgb3AsIFwiXFx1MjIyYlwiLCBcIlxcXFxzbWFsbGludFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXHRleHRlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXG1hdGhlbGxpcHNpc1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBpbm5lciwgXCJcXHUyMDI2XCIsIFwiXFxcXGxkb3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCBcIlxcdTIwMjZcIiwgXCJcXFxcbGRvdHNcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgaW5uZXIsIFwiXFx1MjJlZlwiLCBcIlxcXFxjZG90c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgXCJcXHUyMmYxXCIsIFwiXFxcXGRkb3RzXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsIFwiXFx1MjJlZVwiLCBcIlxcXFx2ZG90c1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDBiNFwiLCBcIlxcXFxhY3V0ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDA2MFwiLCBcIlxcXFxncmF2ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDBhOFwiLCBcIlxcXFxkZG90XCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMDdlXCIsIFwiXFxcXHRpbGRlXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMGFmXCIsIFwiXFxcXGJhclwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDJkOFwiLCBcIlxcXFxicmV2ZVwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDJjN1wiLCBcIlxcXFxjaGVja1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsIFwiXFx1MDA1ZVwiLCBcIlxcXFxoYXRcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCBcIlxcdTIwZDdcIiwgXCJcXFxcdmVjXCIpO1xuZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgXCJcXHUwMmQ5XCIsIFwiXFxcXGRvdFwiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBcIlxcdTAxMzFcIiwgXCJcXFxcaW1hdGhcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwMjM3XCIsIFwiXFxcXGptYXRoXCIpO1xuXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwiLS1cIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE0XCIsIFwiLS0tXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxOFwiLCBcImBcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwiJ1wiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWNcIiwgXCJgYFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWRcIiwgXCInJ1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCBcIlxcdTAwYjBcIiwgXCJcXFxcZGVncmVlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MDBiMFwiLCBcIlxcXFxkZWdyZWVcIik7XG5kZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgXCJcXHUwMGEzXCIsIFwiXFxcXHBvdW5kc1wiKTtcbmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsIFwiXFx1MjcyMFwiLCBcIlxcXFxtYWx0ZXNlXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIGFtcywgdGV4dG9yZCwgXCJcXHUyNzIwXCIsIFwiXFxcXG1hbHRlc2VcIik7XG5cbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCJcXFxcIFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCBcIlxcdTAwYTBcIiwgXCIgXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHNwYWNpbmcsIFwiXFx1MDBhMFwiLCBcIn5cIik7XG5cbi8vIFRoZXJlIGFyZSBsb3RzIG9mIHN5bWJvbHMgd2hpY2ggYXJlIHRoZSBzYW1lLCBzbyB3ZSBhZGQgdGhlbSBpbiBhZnRlcndhcmRzLlxudmFyIGk7XG52YXIgY2g7XG5cbi8vIEFsbCBvZiB0aGVzZSBhcmUgdGV4dG9yZHMgaW4gbWF0aCBtb2RlXG52YXIgbWF0aFRleHRTeW1ib2xzID0gXCIwMTIzNDU2Nzg5L0AuXFxcIlwiO1xuZm9yIChpID0gMDsgaSA8IG1hdGhUZXh0U3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gbWF0aFRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGVcbnZhciB0ZXh0U3ltYm9scyA9IFwiMDEyMzQ1Njc4OSFAKigpLT0rW11cXFwiOzo/Ly4sXCI7XG5mb3IgKGkgPSAwOyBpIDwgdGV4dFN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICBjaCA9IHRleHRTeW1ib2xzLmNoYXJBdChpKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQWxsIG9mIHRoZXNlIGFyZSB0ZXh0b3JkcyBpbiB0ZXh0IG1vZGUsIGFuZCBtYXRob3JkcyBpbiBtYXRoIG1vZGVcbnZhciBsZXR0ZXJzID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XG5mb3IgKGkgPSAwOyBpIDwgbGV0dGVycy5sZW5ndGg7IGkrKykge1xuICAgIGNoID0gbGV0dGVycy5jaGFyQXQoaSk7XG4gICAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIGNoLCBjaCk7XG4gICAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbi8vIExhdGluLTEgbGV0dGVyc1xuZm9yIChpID0gMHgwMEMwOyBpIDw9IDB4MDBENjsgaSsrKSB7XG4gICAgY2ggPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpO1xuICAgIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBjaCwgY2gpO1xufVxuXG5mb3IgKGkgPSAweDAwRDg7IGkgPD0gMHgwMEY2OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG4gICAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIGNoLCBjaCk7XG59XG5cbmZvciAoaSA9IDB4MDBGODsgaSA8PSAweDAwRkY7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gQ3lyaWxsaWNcbmZvciAoaSA9IDB4MDQxMDsgaSA8PSAweDA0NEY7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTtcbn1cblxuLy8gVW5pY29kZSB2ZXJzaW9ucyBvZiBleGlzdGluZyBjaGFyYWN0ZXJzXG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDEzXCIsIFwi4oCTXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxNFwiLCBcIuKAlFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMThcIiwgXCLigJhcIik7XG5kZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgXCJcXHUyMDE5XCIsIFwi4oCZXCIpO1xuZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIFwiXFx1MjAxY1wiLCBcIuKAnFwiKTtcbmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBcIlxcdTIwMWRcIiwgXCLigJ1cIik7XG4iLCJ2YXIgaGFuZ3VsUmVnZXggPSAvW1xcdUFDMDAtXFx1RDdBRl0vO1xuXG4vLyBUaGlzIHJlZ2V4IGNvbWJpbmVzXG4vLyAtIEhpcmFnYW5hOiBbXFx1MzA0MC1cXHUzMDlGXVxuLy8gLSBLYXRha2FuYTogW1xcdTMwQTAtXFx1MzBGRl1cbi8vIC0gQ0pLIGlkZW9ncmFtczogW1xcdTRFMDAtXFx1OUZBRl1cbi8vIC0gSGFuZ3VsIHN5bGxhYmxlczogW1xcdUFDMDAtXFx1RDdBRl1cbi8vIE5vdGFibHkgbWlzc2luZyBhcmUgaGFsZndpZHRoIEthdGFrYW5hIGFuZCBSb21hbmppIGdseXBocy5cbnZhciBjamtSZWdleCA9XG4gICAgL1tcXHUzMDQwLVxcdTMwOUZdfFtcXHUzMEEwLVxcdTMwRkZdfFtcXHU0RTAwLVxcdTlGQUZdfFtcXHVBQzAwLVxcdUQ3QUZdLztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY2prUmVnZXg6IGNqa1JlZ2V4LFxuICAgIGhhbmd1bFJlZ2V4OiBoYW5ndWxSZWdleFxufTtcbiIsIi8qKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGEgbGlzdCBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB3aGljaCBhcmUgdXNlZnVsIGluIG90aGVyXG4gKiBmaWxlcy5cbiAqL1xuXG4vKipcbiAqIFByb3ZpZGUgYW4gYGluZGV4T2ZgIGZ1bmN0aW9uIHdoaWNoIHdvcmtzIGluIElFOCwgYnV0IGRlZmVycyB0byBuYXRpdmUgaWZcbiAqIHBvc3NpYmxlLlxuICovXG52YXIgbmF0aXZlSW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xudmFyIGluZGV4T2YgPSBmdW5jdGlvbihsaXN0LCBlbGVtKSB7XG4gICAgaWYgKGxpc3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGxpc3QuaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikge1xuICAgICAgICByZXR1cm4gbGlzdC5pbmRleE9mKGVsZW0pO1xuICAgIH1cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGwgPSBsaXN0Lmxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAobGlzdFtpXSA9PT0gZWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhbiBlbGVtZW50IGlzIGNvbnRhaW5lZCBpbiBhIGxpc3RcbiAqL1xudmFyIGNvbnRhaW5zID0gZnVuY3Rpb24obGlzdCwgZWxlbSkge1xuICAgIHJldHVybiBpbmRleE9mKGxpc3QsIGVsZW0pICE9PSAtMTtcbn07XG5cbi8qKlxuICogUHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUgaWYgYSBzZXR0aW5nIGlzIHVuZGVmaW5lZFxuICovXG52YXIgZGVmbHQgPSBmdW5jdGlvbihzZXR0aW5nLCBkZWZhdWx0SWZVbmRlZmluZWQpIHtcbiAgICByZXR1cm4gc2V0dGluZyA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdElmVW5kZWZpbmVkIDogc2V0dGluZztcbn07XG5cbi8vIGh5cGhlbmF0ZSBhbmQgZXNjYXBlIGFkYXB0ZWQgZnJvbSBGYWNlYm9vaydzIFJlYWN0IHVuZGVyIEFwYWNoZSAyIGxpY2Vuc2VcblxudmFyIHVwcGVyY2FzZSA9IC8oW0EtWl0pL2c7XG52YXIgaHlwaGVuYXRlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKHVwcGVyY2FzZSwgXCItJDFcIikudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBFU0NBUEVfTE9PS1VQID0ge1xuICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgXCI+XCI6IFwiJmd0O1wiLFxuICAgIFwiPFwiOiBcIiZsdDtcIixcbiAgICBcIlxcXCJcIjogXCImcXVvdDtcIixcbiAgICBcIidcIjogXCImI3gyNztcIlxufTtcblxudmFyIEVTQ0FQRV9SRUdFWCA9IC9bJj48XCInXS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVyKG1hdGNoKSB7XG4gICAgcmV0dXJuIEVTQ0FQRV9MT09LVVBbbWF0Y2hdO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZSh0ZXh0KSB7XG4gICAgcmV0dXJuIChcIlwiICsgdGV4dCkucmVwbGFjZShFU0NBUEVfUkVHRVgsIGVzY2FwZXIpO1xufVxuXG4vKipcbiAqIEEgZnVuY3Rpb24gdG8gc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgYSBET00gZWxlbWVudCBpbiBhbGwgc3VwcG9ydGVkXG4gKiBicm93c2Vycy4gTm90ZSB0aGF0IHdlIGRvbid0IGRlZmluZSB0aGlzIGlmIHRoZXJlIGlzIG5vIGRvY3VtZW50LlxuICovXG52YXIgc2V0VGV4dENvbnRlbnQ7XG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFyIHRlc3ROb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgaWYgKFwidGV4dENvbnRlbnRcIiBpbiB0ZXN0Tm9kZSkge1xuICAgICAgICBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uKG5vZGUsIHRleHQpIHtcbiAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24obm9kZSwgdGV4dCkge1xuICAgICAgICAgICAgbm9kZS5pbm5lclRleHQgPSB0ZXh0O1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHRvIGNsZWFyIGEgbm9kZS5cbiAqL1xuZnVuY3Rpb24gY2xlYXJOb2RlKG5vZGUpIHtcbiAgICBzZXRUZXh0Q29udGVudChub2RlLCBcIlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29udGFpbnM6IGNvbnRhaW5zLFxuICAgIGRlZmx0OiBkZWZsdCxcbiAgICBlc2NhcGU6IGVzY2FwZSxcbiAgICBoeXBoZW5hdGU6IGh5cGhlbmF0ZSxcbiAgICBpbmRleE9mOiBpbmRleE9mLFxuICAgIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgICBjbGVhck5vZGU6IGNsZWFyTm9kZVxufTtcbiIsIi8qKiBAZmxvdyAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gZ2V0UmVsb2NhdGFibGUocmUpIHtcbiAgLy8gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb3VsZCB1c2UgYSBXZWFrTWFwIGluc3RlYWQgb2YgYW4gZXhwYW5kby5cbiAgaWYgKCFyZS5fX21hdGNoQXRSZWxvY2F0YWJsZSkge1xuICAgIC8vIERpc2p1bmN0aW9ucyBhcmUgdGhlIGxvd2VzdC1wcmVjZWRlbmNlIG9wZXJhdG9yLCBzbyB3ZSBjYW4gbWFrZSBhbnlcbiAgICAvLyBwYXR0ZXJuIG1hdGNoIHRoZSBlbXB0eSBzdHJpbmcgYnkgYXBwZW5kaW5nIGB8KClgIHRvIGl0OlxuICAgIC8vIGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1wYXR0ZXJuc1xuICAgIHZhciBzb3VyY2UgPSByZS5zb3VyY2UgKyBcInwoKVwiO1xuXG4gICAgLy8gV2UgYWx3YXlzIG1ha2UgdGhlIG5ldyByZWdleCBnbG9iYWwuXG4gICAgdmFyIGZsYWdzID0gXCJnXCIgKyAocmUuaWdub3JlQ2FzZSA/IFwiaVwiIDogXCJcIikgKyAocmUubXVsdGlsaW5lID8gXCJtXCIgOiBcIlwiKSArIChyZS51bmljb2RlID8gXCJ1XCIgOiBcIlwiKVxuICAgIC8vIHN0aWNreSAoLy4uLi95KSBkb2Vzbid0IG1ha2Ugc2Vuc2UgaW4gY29uanVuY3Rpb24gd2l0aCBvdXIgcmVsb2NhdGlvblxuICAgIC8vIGxvZ2ljLCBzbyB3ZSBpZ25vcmUgaXQgaGVyZS5cbiAgICA7XG5cbiAgICByZS5fX21hdGNoQXRSZWxvY2F0YWJsZSA9IG5ldyBSZWdFeHAoc291cmNlLCBmbGFncyk7XG4gIH1cbiAgcmV0dXJuIHJlLl9fbWF0Y2hBdFJlbG9jYXRhYmxlO1xufVxuXG5mdW5jdGlvbiBtYXRjaEF0KHJlLCBzdHIsIHBvcykge1xuICBpZiAocmUuZ2xvYmFsIHx8IHJlLnN0aWNreSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1hdGNoQXQoLi4uKTogT25seSBub24tZ2xvYmFsIHJlZ2V4ZXMgYXJlIHN1cHBvcnRlZFwiKTtcbiAgfVxuICB2YXIgcmVsb2MgPSBnZXRSZWxvY2F0YWJsZShyZSk7XG4gIHJlbG9jLmxhc3RJbmRleCA9IHBvcztcbiAgdmFyIG1hdGNoID0gcmVsb2MuZXhlYyhzdHIpO1xuICAvLyBMYXN0IGNhcHR1cmluZyBncm91cCBpcyBvdXIgc2VudGluZWwgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcmVnZXhcbiAgLy8gbWF0Y2hlZCBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24uXG4gIGlmIChtYXRjaFttYXRjaC5sZW5ndGggLSAxXSA9PSBudWxsKSB7XG4gICAgLy8gT3JpZ2luYWwgcmVnZXggbWF0Y2hlZC5cbiAgICBtYXRjaC5sZW5ndGggPSBtYXRjaC5sZW5ndGggLSAxO1xuICAgIHJldHVybiBtYXRjaDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoQXQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgSW5uZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5uZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIElubmVyU3Vic2NyaWJlcihwYXJlbnQsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLm91dGVyVmFsdWUgPSBvdXRlclZhbHVlO1xuICAgICAgICB0aGlzLm91dGVySW5kZXggPSBvdXRlckluZGV4O1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICB9XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnBhcmVudC5ub3RpZnlOZXh0KHRoaXMub3V0ZXJWYWx1ZSwgdmFsdWUsIHRoaXMub3V0ZXJJbmRleCwgdGhpcy5pbmRleCsrLCB0aGlzKTtcbiAgICB9O1xuICAgIElubmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeUVycm9yKGVycm9yLCB0aGlzKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeUNvbXBsZXRlKHRoaXMpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5uZXJTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5Jbm5lclN1YnNjcmliZXIgPSBJbm5lclN1YnNjcmliZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5lclN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi91dGlsL3Jvb3QnKTtcbnZhciB0b1N1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vdXRpbC90b1N1YnNjcmliZXInKTtcbnZhciBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9vYnNlcnZhYmxlJyk7XG4vKipcbiAqIEEgcmVwcmVzZW50YXRpb24gb2YgYW55IHNldCBvZiB2YWx1ZXMgb3ZlciBhbnkgYW1vdW50IG9mIHRpbWUuIFRoaXMgdGhlIG1vc3QgYmFzaWMgYnVpbGRpbmcgYmxvY2tcbiAqIG9mIFJ4SlMuXG4gKlxuICogQGNsYXNzIE9ic2VydmFibGU8VD5cbiAqL1xudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZSB0aGUgZnVuY3Rpb24gdGhhdCBpcyAgY2FsbGVkIHdoZW4gdGhlIE9ic2VydmFibGUgaXNcbiAgICAgKiBpbml0aWFsbHkgc3Vic2NyaWJlZCB0by4gVGhpcyBmdW5jdGlvbiBpcyBnaXZlbiBhIFN1YnNjcmliZXIsIHRvIHdoaWNoIG5ldyB2YWx1ZXNcbiAgICAgKiBjYW4gYmUgYG5leHRgZWQsIG9yIGFuIGBlcnJvcmAgbWV0aG9kIGNhbiBiZSBjYWxsZWQgdG8gcmFpc2UgYW4gZXJyb3IsIG9yXG4gICAgICogYGNvbXBsZXRlYCBjYW4gYmUgY2FsbGVkIHRvIG5vdGlmeSBvZiBhIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPYnNlcnZhYmxlLCB3aXRoIHRoaXMgT2JzZXJ2YWJsZSBhcyB0aGUgc291cmNlLCBhbmQgdGhlIHBhc3NlZFxuICAgICAqIG9wZXJhdG9yIGRlZmluZWQgYXMgdGhlIG5ldyBvYnNlcnZhYmxlJ3Mgb3BlcmF0b3IuXG4gICAgICogQG1ldGhvZCBsaWZ0XG4gICAgICogQHBhcmFtIHtPcGVyYXRvcn0gb3BlcmF0b3IgdGhlIG9wZXJhdG9yIGRlZmluaW5nIHRoZSBvcGVyYXRpb24gdG8gdGFrZSBvbiB0aGUgb2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IGEgbmV3IG9ic2VydmFibGUgd2l0aCB0aGUgT3BlcmF0b3IgYXBwbGllZFxuICAgICAqL1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAgICAgdmFyIG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIG9ic2VydmFibGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSB0aGlzLm9wZXJhdG9yO1xuICAgICAgICB2YXIgc2luayA9IHRvU3Vic2NyaWJlcl8xLnRvU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgaWYgKG9wZXJhdG9yKSB7XG4gICAgICAgICAgICBvcGVyYXRvci5jYWxsKHNpbmssIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpbmsuYWRkKHRoaXMuX3RyeVN1YnNjcmliZShzaW5rKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc2luay5zeW5jRXJyb3JWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2luaztcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShzaW5rKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICBzaW5rLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgc2luay5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGZvckVhY2hcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXh0IGEgaGFuZGxlciBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBvYnNlcnZhYmxlXG4gICAgICogQHBhcmFtIHtQcm9taXNlQ29uc3RydWN0b3J9IFtQcm9taXNlQ3Rvcl0gYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBQcm9taXNlXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgZWl0aGVyIHJlc29sdmVzIG9uIG9ic2VydmFibGUgY29tcGxldGlvbiBvclxuICAgICAqICByZWplY3RzIHdpdGggdGhlIGhhbmRsZWQgZXJyb3JcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKG5leHQsIFByb21pc2VDdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgICAgICAgIGlmIChyb290XzEucm9vdC5SeCAmJiByb290XzEucm9vdC5SeC5jb25maWcgJiYgcm9vdF8xLnJvb3QuUnguY29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBQcm9taXNlQ3RvciA9IHJvb3RfMS5yb290LlJ4LmNvbmZpZy5Qcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocm9vdF8xLnJvb3QuUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIFByb21pc2VDdG9yID0gcm9vdF8xLnJvb3QuUHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIVByb21pc2VDdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFByb21pc2UgaW1wbCBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgc3Vic2NyaXB0aW9uLCB0aGVuIHdlIGNhbiBzdXJtaXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuZXh0IGhhbmRsaW5nIGlzIGFzeW5jaHJvbm91cy4gQW55IGVycm9ycyB0aHJvd25cbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBiZSByZWplY3RlZCBleHBsaWNpdGx5IGFuZCB1bnN1YnNjcmliZSBtdXN0IGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxlZCBtYW51YWxseVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgTk8gc3Vic2NyaXB0aW9uLCB0aGVuIHdlJ3JlIGdldHRpbmcgYSBuZXh0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWUgc3luY2hyb25vdXNseSBkdXJpbmcgc3Vic2NyaXB0aW9uLiBXZSBjYW4ganVzdCBjYWxsIGl0LlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCBlcnJvcnMsIE9ic2VydmFibGUncyBgc3Vic2NyaWJlYCB3aWxsIGVuc3VyZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5zdWJzY3JpcHRpb24gbG9naWMgaXMgY2FsbGVkLCB0aGVuIHN5bmNocm9ub3VzbHkgcmV0aHJvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIHRoYXQsIFByb21pc2Ugd2lsbCB0cmFwIHRoZSBlcnJvciBhbmQgc2VuZCBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBkb3duIHRoZSByZWplY3Rpb24gcGF0aC5cbiAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcmVqZWN0LCByZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFuIGludGVyb3AgcG9pbnQgZGVmaW5lZCBieSB0aGUgZXM3LW9ic2VydmFibGUgc3BlYyBodHRwczovL2dpdGh1Yi5jb20vemVucGFyc2luZy9lcy1vYnNlcnZhYmxlXG4gICAgICogQG1ldGhvZCBTeW1ib2wub2JzZXJ2YWJsZVxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IHRoaXMgaW5zdGFuY2Ugb2YgdGhlIG9ic2VydmFibGVcbiAgICAgKi9cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZVtvYnNlcnZhYmxlXzEuJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBIQUNLOiBTaW5jZSBUeXBlU2NyaXB0IGluaGVyaXRzIHN0YXRpYyBwcm9wZXJ0aWVzIHRvbywgd2UgaGF2ZSB0b1xuICAgIC8vIGZpZ2h0IGFnYWluc3QgVHlwZVNjcmlwdCBoZXJlIHNvIFN1YmplY3QgY2FuIGhhdmUgYSBkaWZmZXJlbnQgc3RhdGljIGNyZWF0ZSBzaWduYXR1cmVcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNvbGQgT2JzZXJ2YWJsZSBieSBjYWxsaW5nIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN1YnNjcmliZT8gdGhlIHN1YnNjcmliZXIgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIHRoZSBPYnNlcnZhYmxlIGNvbnN0cnVjdG9yXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYSBuZXcgY29sZCBvYnNlcnZhYmxlXG4gICAgICovXG4gICAgT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZShzdWJzY3JpYmUpO1xuICAgIH07XG4gICAgcmV0dXJuIE9ic2VydmFibGU7XG59KCkpO1xuZXhwb3J0cy5PYnNlcnZhYmxlID0gT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLmVtcHR5ID0ge1xuICAgIGNsb3NlZDogdHJ1ZSxcbiAgICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHsgfSxcbiAgICBlcnJvcjogZnVuY3Rpb24gKGVycikgeyB0aHJvdyBlcnI7IH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uICgpIHsgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE91dGVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE91dGVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPdXRlclN1YnNjcmliZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgIH07XG4gICAgT3V0ZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnJvciwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIHJldHVybiBPdXRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLk91dGVyU3Vic2NyaWJlciA9IE91dGVyU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU91dGVyU3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQW4gZXhlY3V0aW9uIGNvbnRleHQgYW5kIGEgZGF0YSBzdHJ1Y3R1cmUgdG8gb3JkZXIgdGFza3MgYW5kIHNjaGVkdWxlIHRoZWlyXG4gKiBleGVjdXRpb24uIFByb3ZpZGVzIGEgbm90aW9uIG9mIChwb3RlbnRpYWxseSB2aXJ0dWFsKSB0aW1lLCB0aHJvdWdoIHRoZVxuICogYG5vdygpYCBnZXR0ZXIgbWV0aG9kLlxuICpcbiAqIEVhY2ggdW5pdCBvZiB3b3JrIGluIGEgU2NoZWR1bGVyIGlzIGNhbGxlZCBhbiB7QGxpbmsgQWN0aW9ufS5cbiAqXG4gKiBgYGB0c1xuICogY2xhc3MgU2NoZWR1bGVyIHtcbiAqICAgbm93KCk6IG51bWJlcjtcbiAqICAgc2NoZWR1bGUod29yaywgZGVsYXk/LCBzdGF0ZT8pOiBTdWJzY3JpcHRpb247XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAY2xhc3MgU2NoZWR1bGVyXG4gKi9cbnZhciBTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjaGVkdWxlcihTY2hlZHVsZXJBY3Rpb24sIG5vdykge1xuICAgICAgICBpZiAobm93ID09PSB2b2lkIDApIHsgbm93ID0gU2NoZWR1bGVyLm5vdzsgfVxuICAgICAgICB0aGlzLlNjaGVkdWxlckFjdGlvbiA9IFNjaGVkdWxlckFjdGlvbjtcbiAgICAgICAgdGhpcy5ub3cgPSBub3c7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhIGZ1bmN0aW9uLCBgd29ya2AsIGZvciBleGVjdXRpb24uIE1heSBoYXBwZW4gYXQgc29tZSBwb2ludCBpblxuICAgICAqIHRoZSBmdXR1cmUsIGFjY29yZGluZyB0byB0aGUgYGRlbGF5YCBwYXJhbWV0ZXIsIGlmIHNwZWNpZmllZC4gTWF5IGJlIHBhc3NlZFxuICAgICAqIHNvbWUgY29udGV4dCBvYmplY3QsIGBzdGF0ZWAsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBgd29ya2AgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGUgZ2l2ZW4gYXJndW1lbnRzIHdpbGwgYmUgcHJvY2Vzc2VkIGFuIHN0b3JlZCBhcyBhbiBBY3Rpb24gb2JqZWN0IGluIGFcbiAgICAgKiBxdWV1ZSBvZiBhY3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihzdGF0ZTogP1QpOiA/U3Vic2NyaXB0aW9ufSB3b3JrIEEgZnVuY3Rpb24gcmVwcmVzZW50aW5nIGFcbiAgICAgKiB0YXNrLCBvciBzb21lIHVuaXQgb2Ygd29yayB0byBiZSBleGVjdXRlZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXldIFRpbWUgdG8gd2FpdCBiZWZvcmUgZXhlY3V0aW5nIHRoZSB3b3JrLCB3aGVyZSB0aGVcbiAgICAgKiB0aW1lIHVuaXQgaXMgaW1wbGljaXQgYW5kIGRlZmluZWQgYnkgdGhlIFNjaGVkdWxlciBpdHNlbGYuXG4gICAgICogQHBhcmFtIHtUfSBbc3RhdGVdIFNvbWUgY29udGV4dHVhbCBkYXRhIHRoYXQgdGhlIGB3b3JrYCBmdW5jdGlvbiB1c2VzIHdoZW5cbiAgICAgKiBjYWxsZWQgYnkgdGhlIFNjaGVkdWxlci5cbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb259IEEgc3Vic2NyaXB0aW9uIGluIG9yZGVyIHRvIGJlIGFibGUgdG8gdW5zdWJzY3JpYmVcbiAgICAgKiB0aGUgc2NoZWR1bGVkIHdvcmsuXG4gICAgICovXG4gICAgU2NoZWR1bGVyLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uICh3b3JrLCBkZWxheSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5TY2hlZHVsZXJBY3Rpb24odGhpcywgd29yaykuc2NoZWR1bGUoc3RhdGUsIGRlbGF5KTtcbiAgICB9O1xuICAgIFNjaGVkdWxlci5ub3cgPSBEYXRlLm5vdyA/IERhdGUubm93IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gK25ldyBEYXRlKCk7IH07XG4gICAgcmV0dXJuIFNjaGVkdWxlcjtcbn0oKSk7XG5leHBvcnRzLlNjaGVkdWxlciA9IFNjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjaGVkdWxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaWJlcicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xID0gcmVxdWlyZSgnLi91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yJyk7XG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJqZWN0U3Vic2NyaXB0aW9uJyk7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL3N5bWJvbC9yeFN1YnNjcmliZXInKTtcbi8qKlxuICogQGNsYXNzIFN1YmplY3RTdWJzY3JpYmVyPFQ+XG4gKi9cbnZhciBTdWJqZWN0U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gU3ViamVjdFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlN1YmplY3RTdWJzY3JpYmVyID0gU3ViamVjdFN1YnNjcmliZXI7XG4vKipcbiAqIEBjbGFzcyBTdWJqZWN0PFQ+XG4gKi9cbnZhciBTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0KCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRocm93bkVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgU3ViamVjdC5wcm90b3R5cGVbcnhTdWJzY3JpYmVyXzEuJCRyeFN1YnNjcmliZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpYmVyKHRoaXMpO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgICAgICB2YXIgc3ViamVjdCA9IG5ldyBBbm9ueW1vdXNTdWJqZWN0KHRoaXMsIHRoaXMpO1xuICAgICAgICBzdWJqZWN0Lm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICAgICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvcHlbaV0ubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRydWU7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBlcnI7XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JfMS5PYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHRoaXMub2JzZXJ2ZXJzO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29weVtpXS5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gbnVsbDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5fdHJ5U3Vic2NyaWJlLmNhbGwodGhpcywgc3Vic2NyaWJlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdWJqZWN0U3Vic2NyaXB0aW9uXzEuU3ViamVjdFN1YnNjcmlwdGlvbih0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuYXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb2JzZXJ2YWJsZSA9IG5ldyBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSgpO1xuICAgICAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgU3ViamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gbmV3IEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3ViamVjdDtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuU3ViamVjdCA9IFN1YmplY3Q7XG4vKipcbiAqIEBjbGFzcyBBbm9ueW1vdXNTdWJqZWN0PFQ+XG4gKi9cbnZhciBBbm9ueW1vdXNTdWJqZWN0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQW5vbnltb3VzU3ViamVjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBbm9ueW1vdXNTdWJqZWN0KGRlc3RpbmF0aW9uLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbjtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLm5leHQpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uY29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBbm9ueW1vdXNTdWJqZWN0O1xufShTdWJqZWN0KSk7XG5leHBvcnRzLkFub255bW91c1N1YmplY3QgPSBBbm9ueW1vdXNTdWJqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3ViamVjdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YmplY3RTdWJzY3JpcHRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmlwdGlvbihzdWJqZWN0LCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBzdWJzY3JpYmVyO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBTdWJqZWN0U3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcbiAgICAgICAgdmFyIG9ic2VydmVycyA9IHN1YmplY3Qub2JzZXJ2ZXJzO1xuICAgICAgICB0aGlzLnN1YmplY3QgPSBudWxsO1xuICAgICAgICBpZiAoIW9ic2VydmVycyB8fCBvYnNlcnZlcnMubGVuZ3RoID09PSAwIHx8IHN1YmplY3QuaXNTdG9wcGVkIHx8IHN1YmplY3QuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmliZXJJbmRleCA9IG9ic2VydmVycy5pbmRleE9mKHRoaXMuc3Vic2NyaWJlcik7XG4gICAgICAgIGlmIChzdWJzY3JpYmVySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBvYnNlcnZlcnMuc3BsaWNlKHN1YnNjcmliZXJJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaXB0aW9uO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmlwdGlvbiA9IFN1YmplY3RTdWJzY3JpcHRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0U3Vic2NyaXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4vU3Vic2NyaXB0aW9uJyk7XG52YXIgT2JzZXJ2ZXJfMSA9IHJlcXVpcmUoJy4vT2JzZXJ2ZXInKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGludGVyZmFjZSBhbmQgZXh0ZW5kcyB0aGVcbiAqIHtAbGluayBTdWJzY3JpcHRpb259IGNsYXNzLiBXaGlsZSB0aGUge0BsaW5rIE9ic2VydmVyfSBpcyB0aGUgcHVibGljIEFQSSBmb3JcbiAqIGNvbnN1bWluZyB0aGUgdmFsdWVzIG9mIGFuIHtAbGluayBPYnNlcnZhYmxlfSwgYWxsIE9ic2VydmVycyBnZXQgY29udmVydGVkIHRvXG4gKiBhIFN1YnNjcmliZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgU3Vic2NyaXB0aW9uLWxpa2UgY2FwYWJpbGl0aWVzIHN1Y2ggYXNcbiAqIGB1bnN1YnNjcmliZWAuIFN1YnNjcmliZXIgaXMgYSBjb21tb24gdHlwZSBpbiBSeEpTLCBhbmQgY3J1Y2lhbCBmb3JcbiAqIGltcGxlbWVudGluZyBvcGVyYXRvcnMsIGJ1dCBpdCBpcyByYXJlbHkgdXNlZCBhcyBhIHB1YmxpYyBBUEkuXG4gKlxuICogQGNsYXNzIFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBbZGVzdGluYXRpb25Pck5leHRdIEEgcGFydGlhbGx5XG4gICAgICogZGVmaW5lZCBPYnNlcnZlciBvciBhIGBuZXh0YCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlcihkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IE9ic2VydmVyXzEuZW1wdHk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbk9yTmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb25Pck5leHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbk9yTmV4dCBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBkZXN0aW5hdGlvbk9yTmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uYWRkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcih0aGlzLCBkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuICAgIC8qKlxuICAgICAqIEEgc3RhdGljIGZhY3RvcnkgZm9yIGEgU3Vic2NyaWJlciwgZ2l2ZW4gYSAocG90ZW50aWFsbHkgcGFydGlhbCkgZGVmaW5pdGlvblxuICAgICAqIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oeDogP1QpOiB2b2lkfSBbbmV4dF0gVGhlIGBuZXh0YCBjYWxsYmFjayBvZiBhbiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIFRoZSBgY29tcGxldGVgIGNhbGxiYWNrIG9mIGFuXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICogQHJldHVybiB7U3Vic2NyaWJlcjxUPn0gQSBTdWJzY3JpYmVyIHdyYXBwaW5nIHRoZSAocGFydGlhbGx5IGRlZmluZWQpXG4gICAgICogT2JzZXJ2ZXIgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcihuZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICBzdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBuZXh0YCBmcm9tXG4gICAgICogdGhlIE9ic2VydmFibGUsIHdpdGggYSB2YWx1ZS4gVGhlIE9ic2VydmFibGUgbWF5IGNhbGwgdGhpcyBtZXRob2QgMCBvciBtb3JlXG4gICAgICogdGltZXMuXG4gICAgICogQHBhcmFtIHtUfSBbdmFsdWVdIFRoZSBgbmV4dGAgdmFsdWUuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2YgdHlwZSBgZXJyb3JgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhbiBhdHRhY2hlZCB7QGxpbmsgRXJyb3J9LiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdFxuICAgICAqIHRoZSBPYnNlcnZhYmxlIGhhcyBleHBlcmllbmNlZCBhbiBlcnJvciBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIHthbnl9IFtlcnJdIFRoZSBgZXJyb3JgIGV4Y2VwdGlvbi5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIGEgdmFsdWVsZXNzIG5vdGlmaWNhdGlvbiBvZiB0eXBlXG4gICAgICogYGNvbXBsZXRlYCBmcm9tIHRoZSBPYnNlcnZhYmxlLiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdCB0aGUgT2JzZXJ2YWJsZVxuICAgICAqIGhhcyBmaW5pc2hlZCBzZW5kaW5nIHB1c2gtYmFzZWQgbm90aWZpY2F0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cztcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IF9wYXJlbnRzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVyO1xufShTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24pKTtcbmV4cG9ydHMuU3Vic2NyaWJlciA9IFN1YnNjcmliZXI7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFNhZmVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FmZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIoX3BhcmVudFN1YnNjcmliZXIsIG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBfcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9ic2VydmVyT3JOZXh0KSkge1xuICAgICAgICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9ic2VydmVyT3JOZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQubmV4dDtcbiAgICAgICAgICAgIGVycm9yID0gb2JzZXJ2ZXJPck5leHQuZXJyb3I7XG4gICAgICAgICAgICBjb21wbGV0ZSA9IG9ic2VydmVyT3JOZXh0LmNvbXBsZXRlO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKGNvbnRleHQudW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoY29udGV4dC51bnN1YnNjcmliZS5iaW5kKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSB0aGlzLnVuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIH1cbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMuX25leHQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX25leHQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9uZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgdGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5fY29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9jb21wbGV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yVW5zdWIgPSBmdW5jdGlvbiAoZm4sIHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMuX2NvbnRleHQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fX3RyeU9yU2V0RXJyb3IgPSBmdW5jdGlvbiAocGFyZW50LCBmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgICAgICAgIHBhcmVudC5zeW5jRXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICBfcGFyZW50U3Vic2NyaWJlci51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0FycmF5Jyk7XG52YXIgaXNPYmplY3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9pc09iamVjdCcpO1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4vdXRpbC9pc0Z1bmN0aW9uJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvcicpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgZGlzcG9zYWJsZSByZXNvdXJjZSwgc3VjaCBhcyB0aGUgZXhlY3V0aW9uIG9mIGFuIE9ic2VydmFibGUuIEFcbiAqIFN1YnNjcmlwdGlvbiBoYXMgb25lIGltcG9ydGFudCBtZXRob2QsIGB1bnN1YnNjcmliZWAsIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRcbiAqIGFuZCBqdXN0IGRpc3Bvc2VzIHRoZSByZXNvdXJjZSBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uXG4gKlxuICogQWRkaXRpb25hbGx5LCBzdWJzY3JpcHRpb25zIG1heSBiZSBncm91cGVkIHRvZ2V0aGVyIHRocm91Z2ggdGhlIGBhZGQoKWBcbiAqIG1ldGhvZCwgd2hpY2ggd2lsbCBhdHRhY2ggYSBjaGlsZCBTdWJzY3JpcHRpb24gdG8gdGhlIGN1cnJlbnQgU3Vic2NyaXB0aW9uLlxuICogV2hlbiBhIFN1YnNjcmlwdGlvbiBpcyB1bnN1YnNjcmliZWQsIGFsbCBpdHMgY2hpbGRyZW4gKGFuZCBpdHMgZ3JhbmRjaGlsZHJlbilcbiAqIHdpbGwgYmUgdW5zdWJzY3JpYmVkIGFzIHdlbGwuXG4gKlxuICogQGNsYXNzIFN1YnNjcmlwdGlvblxuICovXG52YXIgU3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFt1bnN1YnNjcmliZV0gQSBmdW5jdGlvbiBkZXNjcmliaW5nIGhvdyB0b1xuICAgICAqIHBlcmZvcm0gdGhlIGRpc3Bvc2FsIG9mIHJlc291cmNlcyB3aGVuIHRoZSBgdW5zdWJzY3JpYmVgIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIFN1YnNjcmlwdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHVuc3Vic2NyaWJlZC5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi4gTWF5LCBmb3IgaW5zdGFuY2UsIGNhbmNlbFxuICAgICAqIGFuIG9uZ29pbmcgT2JzZXJ2YWJsZSBleGVjdXRpb24gb3IgY2FuY2VsIGFueSBvdGhlciB0eXBlIG9mIHdvcmsgdGhhdFxuICAgICAqIHN0YXJ0ZWQgd2hlbiB0aGUgU3Vic2NyaXB0aW9uIHdhcyBjcmVhdGVkLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhhc0Vycm9ycyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3JzO1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cywgX3Vuc3Vic2NyaWJlID0gX2EuX3Vuc3Vic2NyaWJlLCBfc3Vic2NyaXB0aW9ucyA9IF9hLl9zdWJzY3JpcHRpb25zO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBudWxsO1xuICAgICAgICAvLyBudWxsIG91dCBfc3Vic2NyaXB0aW9ucyBmaXJzdCBzbyBhbnkgY2hpbGQgc3Vic2NyaXB0aW9ucyB0aGF0IGF0dGVtcHRcbiAgICAgICAgLy8gdG8gcmVtb3ZlIHRoZW1zZWx2ZXMgZnJvbSB0aGlzIHN1YnNjcmlwdGlvbiB3aWxsIG5vb3BcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IG51bGw7XG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICB2YXIgbGVuID0gX3BhcmVudHMgPyBfcGFyZW50cy5sZW5ndGggOiAwO1xuICAgICAgICAvLyBpZiB0aGlzLl9wYXJlbnQgaXMgbnVsbCwgdGhlbiBzbyBpcyB0aGlzLl9wYXJlbnRzLCBhbmQgd2VcbiAgICAgICAgLy8gZG9uJ3QgaGF2ZSB0byByZW1vdmUgb3Vyc2VsdmVzIGZyb20gYW55IHBhcmVudCBzdWJzY3JpcHRpb25zLlxuICAgICAgICB3aGlsZSAoX3BhcmVudCkge1xuICAgICAgICAgICAgX3BhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAvLyBpZiB0aGlzLl9wYXJlbnRzIGlzIG51bGwgb3IgaW5kZXggPj0gbGVuLFxuICAgICAgICAgICAgLy8gdGhlbiBfcGFyZW50IGlzIHNldCB0byBudWxsLCBhbmQgdGhlIGxvb3AgZXhpdHNcbiAgICAgICAgICAgIF9wYXJlbnQgPSArK2luZGV4IDwgbGVuICYmIF9wYXJlbnRzW2luZGV4XSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uXzEuaXNGdW5jdGlvbihfdW5zdWJzY3JpYmUpKSB7XG4gICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKF91bnN1YnNjcmliZSkuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IChlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvciA/XG4gICAgICAgICAgICAgICAgICAgIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUuZXJyb3JzKSA6IFtlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkoX3N1YnNjcmlwdGlvbnMpKSB7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgbGVuID0gX3N1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViID0gX3N1YnNjcmlwdGlvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdF8xLmlzT2JqZWN0KHN1YikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWFsID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChzdWIudW5zdWJzY3JpYmUpLmNhbGwoc3ViKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyaWFsID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVyci5lcnJvcnMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Vycm9ycykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0ZWFyIGRvd24gdG8gYmUgY2FsbGVkIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUoKSBvZiB0aGlzXG4gICAgICogU3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRlYXIgZG93biBiZWluZyBhZGRlZCBpcyBhIHN1YnNjcmlwdGlvbiB0aGF0IGlzIGFscmVhZHlcbiAgICAgKiB1bnN1YnNjcmliZWQsIGlzIHRoZSBzYW1lIHJlZmVyZW5jZSBgYWRkYCBpcyBiZWluZyBjYWxsZWQgb24sIG9yIGlzXG4gICAgICogYFN1YnNjcmlwdGlvbi5FTVBUWWAsIGl0IHdpbGwgbm90IGJlIGFkZGVkLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBzdWJzY3JpcHRpb24gaXMgYWxyZWFkeSBpbiBhbiBgY2xvc2VkYCBzdGF0ZSwgdGhlIHBhc3NlZFxuICAgICAqIHRlYXIgZG93biBsb2dpYyB3aWxsIGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUZWFyZG93bkxvZ2ljfSB0ZWFyZG93biBUaGUgYWRkaXRpb25hbCBsb2dpYyB0byBleGVjdXRlIG9uXG4gICAgICogdGVhcmRvd24uXG4gICAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufSBSZXR1cm5zIHRoZSBTdWJzY3JpcHRpb24gdXNlZCBvciBjcmVhdGVkIHRvIGJlXG4gICAgICogYWRkZWQgdG8gdGhlIGlubmVyIHN1YnNjcmlwdGlvbnMgbGlzdC4gVGhpcyBTdWJzY3JpcHRpb24gY2FuIGJlIHVzZWQgd2l0aFxuICAgICAqIGByZW1vdmUoKWAgdG8gcmVtb3ZlIHRoZSBwYXNzZWQgdGVhcmRvd24gbG9naWMgZnJvbSB0aGUgaW5uZXIgc3Vic2NyaXB0aW9uc1xuICAgICAqIGxpc3QuXG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGVhcmRvd24pIHtcbiAgICAgICAgaWYgKCF0ZWFyZG93biB8fCAodGVhcmRvd24gPT09IFN1YnNjcmlwdGlvbi5FTVBUWSkpIHtcbiAgICAgICAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRlYXJkb3duID09PSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gdGVhcmRvd247XG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHRlYXJkb3duKSB7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbih0ZWFyZG93bik7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2xvc2VkIHx8IHR5cGVvZiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdWJzY3JpcHRpb24uX2FkZFBhcmVudCAhPT0gJ2Z1bmN0aW9uJyAvKiBxdWFjayBxdWFjayAqLykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5fc3Vic2NyaXB0aW9ucyA9IFt0bXBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgdGVhcmRvd24gJyArIHRlYXJkb3duICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zIHx8ICh0aGlzLl9zdWJzY3JpcHRpb25zID0gW10pO1xuICAgICAgICBzdWJzY3JpcHRpb25zLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLl9hZGRQYXJlbnQodGhpcyk7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgU3Vic2NyaXB0aW9uIGZyb20gdGhlIGludGVybmFsIGxpc3Qgb2Ygc3Vic2NyaXB0aW9ucyB0aGF0IHdpbGxcbiAgICAgKiB1bnN1YnNjcmliZSBkdXJpbmcgdGhlIHVuc3Vic2NyaWJlIHByb2Nlc3Mgb2YgdGhpcyBTdWJzY3JpcHRpb24uXG4gICAgICogQHBhcmFtIHtTdWJzY3JpcHRpb259IHN1YnNjcmlwdGlvbiBUaGUgc3Vic2NyaXB0aW9uIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbikge1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX2FkZFBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgX3BhcmVudCA9IF9hLl9wYXJlbnQsIF9wYXJlbnRzID0gX2EuX3BhcmVudHM7XG4gICAgICAgIGlmICghX3BhcmVudCB8fCBfcGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwYXJlbnQsIG9yIHRoZSBuZXcgcGFyZW50IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBwYXJlbnQsIHRoZW4gc2V0IHRoaXMuX3BhcmVudCB0byB0aGUgbmV3IHBhcmVudC5cbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghX3BhcmVudHMpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3MgYWxyZWFkeSBvbmUgcGFyZW50LCBidXQgbm90IG11bHRpcGxlLCBhbGxvY2F0ZSBhbiBBcnJheSB0b1xuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIHJlc3Qgb2YgdGhlIHBhcmVudCBTdWJzY3JpcHRpb25zLlxuICAgICAgICAgICAgdGhpcy5fcGFyZW50cyA9IFtwYXJlbnRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKF9wYXJlbnRzLmluZGV4T2YocGFyZW50KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoZSBuZXcgcGFyZW50IHRvIHRoZSBfcGFyZW50cyBsaXN0IGlmIGl0J3Mgbm90IGFscmVhZHkgdGhlcmUuXG4gICAgICAgICAgICBfcGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5FTVBUWSA9IChmdW5jdGlvbiAoZW1wdHkpIHtcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0obmV3IFN1YnNjcmlwdGlvbigpKSk7XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLlN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbjtcbmZ1bmN0aW9uIGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnJvcnMpIHtcbiAgICByZXR1cm4gZXJyb3JzLnJlZHVjZShmdW5jdGlvbiAoZXJycywgZXJyKSB7IHJldHVybiBlcnJzLmNvbmNhdCgoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IpID8gZXJyLmVycm9ycyA6IGVycik7IH0sIFtdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmlwdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBTY2FsYXJPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL1NjYWxhck9ic2VydmFibGUnKTtcbnZhciBFbXB0eU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRW1wdHlPYnNlcnZhYmxlJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgQXJyYXlPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJyYXlPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICBpZiAoIXNjaGVkdWxlciAmJiBhcnJheS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBhcnJheVswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBBcnJheU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKGFycmF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBzb21lIHZhbHVlcyB5b3Ugc3BlY2lmeSBhcyBhcmd1bWVudHMsXG4gICAgICogaW1tZWRpYXRlbHkgb25lIGFmdGVyIHRoZSBvdGhlciwgYW5kIHRoZW4gZW1pdHMgYSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgdGhlIGFyZ3VtZW50cyB5b3UgcHJvdmlkZSwgdGhlbiBjb21wbGV0ZXMuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9vZi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgYXJndW1lbnRzIGdpdmVuLCBhbmQgdGhlIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiB0aGVyZWFmdGVyLiBJdCBjYW5cbiAgICAgKiBiZSB1c2VkIGZvciBjb21wb3Npbmcgd2l0aCBvdGhlciBPYnNlcnZhYmxlcywgc3VjaCBhcyB3aXRoIHtAbGluayBjb25jYXR9LlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgYSBgbnVsbGAgSVNjaGVkdWxlciwgd2hpY2ggbWVhbnMgdGhlIGBuZXh0YFxuICAgICAqIG5vdGlmaWNhdGlvbnMgYXJlIHNlbnQgc3luY2hyb25vdXNseSwgYWx0aG91Z2ggd2l0aCBhIGRpZmZlcmVudCBJU2NoZWR1bGVyXG4gICAgICogaXQgaXMgcG9zc2libGUgdG8gZGV0ZXJtaW5lIHdoZW4gdGhvc2Ugbm90aWZpY2F0aW9ucyB3aWxsIGJlIGRlbGl2ZXJlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgMTAsIDIwLCAzMCwgdGhlbiAnYScsICdiJywgJ2MnLCB0aGVuIHN0YXJ0IHRpY2tpbmcgZXZlcnkgc2Vjb25kLjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUub2YoMTAsIDIwLCAzMCk7XG4gICAgICogdmFyIGxldHRlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpO1xuICAgICAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogdmFyIHJlc3VsdCA9IG51bWJlcnMuY29uY2F0KGxldHRlcnMpLmNvbmNhdChpbnRlcnZhbCk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICAgKiBAc2VlIHtAbGluayBlbXB0eX1cbiAgICAgKiBAc2VlIHtAbGluayBuZXZlcn1cbiAgICAgKiBAc2VlIHtAbGluayB0aHJvd31cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uVH0gdmFsdWVzIEFyZ3VtZW50cyB0aGF0IHJlcHJlc2VudCBgbmV4dGAgdmFsdWVzIHRvIGJlIGVtaXR0ZWQuXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEEge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBlYWNoIGdpdmVuIGlucHV0IHZhbHVlLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIG9mXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBBcnJheU9ic2VydmFibGUub2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJyYXlbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgICAgICBhcnJheS5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXJPYnNlcnZhYmxlXzEuU2NhbGFyT2JzZXJ2YWJsZShhcnJheVswXSwgc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFycmF5T2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBzdGF0ZS5hcnJheSwgaW5kZXggPSBzdGF0ZS5pbmRleCwgY291bnQgPSBzdGF0ZS5jb3VudCwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChpbmRleCA+PSBjb3VudCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheVtpbmRleF0pO1xuICAgICAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSk7XG4gICAgfTtcbiAgICBBcnJheU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICB2YXIgY291bnQgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShBcnJheU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgICAgICAgICBhcnJheTogYXJyYXksIGluZGV4OiBpbmRleCwgY291bnQ6IGNvdW50LCBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQgJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXJyYXlPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5BcnJheU9ic2VydmFibGUgPSBBcnJheU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBAY2xhc3MgQ29ubmVjdGFibGVPYnNlcnZhYmxlPFQ+XG4gKi9cbnZhciBDb25uZWN0YWJsZU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25uZWN0YWJsZU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGFibGVPYnNlcnZhYmxlKHNvdXJjZSwgc3ViamVjdEZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLnN1YmplY3RGYWN0b3J5ID0gc3ViamVjdEZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX3JlZkNvdW50ID0gMDtcbiAgICB9XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3ViamVjdCgpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuZ2V0U3ViamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1YmplY3QgPSB0aGlzLl9zdWJqZWN0O1xuICAgICAgICBpZiAoIXN1YmplY3QgfHwgc3ViamVjdC5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YmplY3QgPSB0aGlzLnN1YmplY3RGYWN0b3J5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YmplY3Q7XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5fY29ubmVjdGlvbjtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25uZWN0aW9uID0gdGhpcy5fY29ubmVjdGlvbiA9IG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uYWRkKHRoaXMuc291cmNlXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZShuZXcgQ29ubmVjdGFibGVTdWJzY3JpYmVyKHRoaXMuZ2V0U3ViamVjdCgpLCB0aGlzKSkpO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbiA9IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5yZWZDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlmdChuZXcgUmVmQ291bnRPcGVyYXRvcih0aGlzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGFibGVPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Db25uZWN0YWJsZU9ic2VydmFibGUgPSBDb25uZWN0YWJsZU9ic2VydmFibGU7XG5leHBvcnRzLmNvbm5lY3RhYmxlT2JzZXJ2YWJsZURlc2NyaXB0b3IgPSB7XG4gICAgb3BlcmF0b3I6IHsgdmFsdWU6IG51bGwgfSxcbiAgICBfcmVmQ291bnQ6IHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0sXG4gICAgX3N1YnNjcmliZTogeyB2YWx1ZTogQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlIH0sXG4gICAgZ2V0U3ViamVjdDogeyB2YWx1ZTogQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5nZXRTdWJqZWN0IH0sXG4gICAgY29ubmVjdDogeyB2YWx1ZTogQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5jb25uZWN0IH0sXG4gICAgcmVmQ291bnQ6IHsgdmFsdWU6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVmQ291bnQgfVxufTtcbnZhciBDb25uZWN0YWJsZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25uZWN0YWJsZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGFibGVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25uZWN0YWJsZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2Vycm9yLmNhbGwodGhpcywgZXJyKTtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLl9jb21wbGV0ZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGlmIChjb25uZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY29ubmVjdGlvbiA9IGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uO1xuICAgICAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50ID0gMDtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29ubmVjdGFibGVTdWJzY3JpYmVyO1xufShTdWJqZWN0XzEuU3ViamVjdFN1YnNjcmliZXIpKTtcbnZhciBSZWZDb3VudE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZWZDb3VudE9wZXJhdG9yKGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgUmVmQ291bnRPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gdGhpcy5jb25uZWN0YWJsZTtcbiAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50Kys7XG4gICAgICAgIHZhciByZWZDb3VudGVyID0gbmV3IFJlZkNvdW50U3Vic2NyaWJlcihzdWJzY3JpYmVyLCBjb25uZWN0YWJsZSk7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHJlZkNvdW50ZXIpO1xuICAgICAgICBpZiAoIXJlZkNvdW50ZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZWZDb3VudGVyLmNvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudE9wZXJhdG9yO1xufSgpKTtcbnZhciBSZWZDb3VudFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWZDb3VudFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmQ291bnRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25uZWN0YWJsZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBjb25uZWN0YWJsZTtcbiAgICB9XG4gICAgUmVmQ291bnRTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb25uZWN0YWJsZSA9IHRoaXMuY29ubmVjdGFibGU7XG4gICAgICAgIGlmICghY29ubmVjdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IG51bGw7XG4gICAgICAgIHZhciByZWZDb3VudCA9IGNvbm5lY3RhYmxlLl9yZWZDb3VudDtcbiAgICAgICAgaWYgKHJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGFibGUuX3JlZkNvdW50ID0gcmVmQ291bnQgLSAxO1xuICAgICAgICBpZiAocmVmQ291bnQgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vL1xuICAgICAgICAvLyBDb21wYXJlIHRoZSBsb2NhbCBSZWZDb3VudFN1YnNjcmliZXIncyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiB0byB0aGVcbiAgICAgICAgLy8gY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gb24gdGhlIHNoYXJlZCBDb25uZWN0YWJsZU9ic2VydmFibGUuIEluIGNhc2VzXG4gICAgICAgIC8vIHdoZXJlIHRoZSBDb25uZWN0YWJsZU9ic2VydmFibGUgc291cmNlIHN5bmNocm9ub3VzbHkgZW1pdHMgdmFsdWVzLCBhbmRcbiAgICAgICAgLy8gdGhlIFJlZkNvdW50U3Vic2NyaWJlcidzIGRvd25zdHJlYW0gT2JzZXJ2ZXJzIHN5bmNocm9ub3VzbHkgdW5zdWJzY3JpYmUsXG4gICAgICAgIC8vIGV4ZWN1dGlvbiBjb250aW51ZXMgdG8gaGVyZSBiZWZvcmUgdGhlIFJlZkNvdW50T3BlcmF0b3IgaGFzIGEgY2hhbmNlIHRvXG4gICAgICAgIC8vIHN1cHBseSB0aGUgUmVmQ291bnRTdWJzY3JpYmVyIHdpdGggdGhlIHNoYXJlZCBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbi5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGU6XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyBPYnNlcnZhYmxlLnJhbmdlKDAsIDEwKVxuICAgICAgICAvLyAgIC5wdWJsaXNoKClcbiAgICAgICAgLy8gICAucmVmQ291bnQoKVxuICAgICAgICAvLyAgIC50YWtlKDUpXG4gICAgICAgIC8vICAgLnN1YnNjcmliZSgpO1xuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8gSW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhpcyBjYXNlLCBSZWZDb3VudFN1YnNjcmliZXIgc2hvdWxkIG9ubHkgZGlzcG9zZVxuICAgICAgICAvLyB0aGUgQ29ubmVjdGFibGVPYnNlcnZhYmxlJ3Mgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIGlmIHRoZVxuICAgICAgICAvLyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiBleGlzdHMsICphbmQqIGVpdGhlcjpcbiAgICAgICAgLy8gICBhLiBSZWZDb3VudFN1YnNjcmliZXIgZG9lc24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBzaGFyZWQgY29ubmVjdGlvblxuICAgICAgICAvLyAgICAgIFN1YnNjcmlwdGlvbiB5ZXQsIG9yLFxuICAgICAgICAvLyAgIGIuIFJlZkNvdW50U3Vic2NyaWJlcidzIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIHJlZmVyZW5jZSBpcyBpZGVudGljYWxcbiAgICAgICAgLy8gICAgICB0byB0aGUgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uXG4gICAgICAgIC8vL1xuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgdmFyIHNoYXJlZENvbm5lY3Rpb24gPSBjb25uZWN0YWJsZS5fY29ubmVjdGlvbjtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKHNoYXJlZENvbm5lY3Rpb24gJiYgKCFjb25uZWN0aW9uIHx8IHNoYXJlZENvbm5lY3Rpb24gPT09IGNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICBzaGFyZWRDb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZWZDb3VudFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25uZWN0YWJsZU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEVtcHR5T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVtcHR5T2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbm8gaXRlbXMgdG8gdGhlIE9ic2VydmVyIGFuZCBpbW1lZGlhdGVseVxuICAgICAqIGVtaXRzIGEgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkp1c3QgZW1pdHMgJ2NvbXBsZXRlJywgYW5kIG5vdGhpbmcgZWxzZS5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2VtcHR5LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogVGhpcyBzdGF0aWMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQgb25seVxuICAgICAqIGVtaXRzIHRoZSBjb21wbGV0ZSBub3RpZmljYXRpb24uIEl0IGNhbiBiZSB1c2VkIGZvciBjb21wb3Npbmcgd2l0aCBvdGhlclxuICAgICAqIE9ic2VydmFibGVzLCBzdWNoIGFzIGluIGEge0BsaW5rIG1lcmdlTWFwfS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG51bWJlciA3LCB0aGVuIGNvbXBsZXRlLjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5lbXB0eSgpLnN0YXJ0V2l0aCg3KTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGFuZCBmbGF0dGVuIG9ubHkgb2RkIG51bWJlcnMgdG8gdGhlIHNlcXVlbmNlICdhJywgJ2InLCAnYyc8L2NhcHRpb24+XG4gICAgICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gaW50ZXJ2YWwubWVyZ2VNYXAoeCA9PlxuICAgICAqICAgeCAlIDIgPT09IDEgPyBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gICAgICogKTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIHRvIHRoZSBjb25zb2xlOlxuICAgICAqIC8vIHggaXMgZXF1YWwgdG8gdGhlIGNvdW50IG9uIHRoZSBpbnRlcnZhbCBlZygwLDEsMiwzLC4uLilcbiAgICAgKiAvLyB4IHdpbGwgb2NjdXIgZXZlcnkgMTAwMG1zXG4gICAgICogLy8gaWYgeCAlIDIgaXMgZXF1YWwgdG8gMSBwcmludCBhYmNcbiAgICAgKiAvLyBpZiB4ICUgMiBpcyBub3QgZXF1YWwgdG8gMSBub3RoaW5nIHdpbGwgYmUgb3V0cHV0XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGV9XG4gICAgICogQHNlZSB7QGxpbmsgbmV2ZXJ9XG4gICAgICogQHNlZSB7QGxpbmsgb2Z9XG4gICAgICogQHNlZSB7QGxpbmsgdGhyb3d9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHRoZSBjb21wbGV0ZSBub3RpZmljYXRpb24uXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gXCJlbXB0eVwiIE9ic2VydmFibGU6IGVtaXRzIG9ubHkgdGhlIGNvbXBsZXRlXG4gICAgICogbm90aWZpY2F0aW9uLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGVtcHR5XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBFbXB0eU9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZShzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgRW1wdHlPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBFbXB0eU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoRW1wdHlPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7IHN1YnNjcmliZXI6IHN1YnNjcmliZXIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFbXB0eU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkVtcHR5T2JzZXJ2YWJsZSA9IEVtcHR5T2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtcHR5T2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi4vdXRpbC90cnlDYXRjaCcpO1xudmFyIGlzRnVuY3Rpb25fMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuLi91dGlsL2Vycm9yT2JqZWN0Jyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpcHRpb24nKTtcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5mdW5jdGlvbiBpc05vZGVTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5hZGRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5vbiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLm9mZiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGlzTm9kZUxpc3Qoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHRvU3RyaW5nLmNhbGwoc291cmNlT2JqKSA9PT0gJ1tvYmplY3QgTm9kZUxpc3RdJztcbn1cbmZ1bmN0aW9uIGlzSFRNTENvbGxlY3Rpb24oc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHRvU3RyaW5nLmNhbGwoc291cmNlT2JqKSA9PT0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJztcbn1cbmZ1bmN0aW9uIGlzRXZlbnRUYXJnZXQoc291cmNlT2JqKSB7XG4gICAgcmV0dXJuICEhc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmouYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEZyb21FdmVudE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGcm9tRXZlbnRPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZyb21FdmVudE9ic2VydmFibGUoc291cmNlT2JqLCBldmVudE5hbWUsIHNlbGVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNvdXJjZU9iaiA9IHNvdXJjZU9iajtcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBldmVudHMgb2YgYSBzcGVjaWZpYyB0eXBlIGNvbWluZyBmcm9tIHRoZVxuICAgICAqIGdpdmVuIGV2ZW50IHRhcmdldC5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5DcmVhdGVzIGFuIE9ic2VydmFibGUgZnJvbSBET00gZXZlbnRzLCBvciBOb2RlXG4gICAgICogRXZlbnRFbWl0dGVyIGV2ZW50cyBvciBvdGhlcnMuPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9mcm9tRXZlbnQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgYnkgYXR0YWNoaW5nIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGFuIFwiZXZlbnQgdGFyZ2V0XCIsXG4gICAgICogd2hpY2ggbWF5IGJlIGFuIG9iamVjdCB3aXRoIGBhZGRFdmVudExpc3RlbmVyYCBhbmQgYHJlbW92ZUV2ZW50TGlzdGVuZXJgLFxuICAgICAqIGEgTm9kZS5qcyBFdmVudEVtaXR0ZXIsIGEgalF1ZXJ5IHN0eWxlIEV2ZW50RW1pdHRlciwgYSBOb2RlTGlzdCBmcm9tIHRoZVxuICAgICAqIERPTSwgb3IgYW4gSFRNTENvbGxlY3Rpb24gZnJvbSB0aGUgRE9NLiBUaGUgZXZlbnQgaGFuZGxlciBpcyBhdHRhY2hlZCB3aGVuXG4gICAgICogdGhlIG91dHB1dCBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQsIGFuZCByZW1vdmVkIHdoZW4gdGhlIFN1YnNjcmlwdGlvbiBpc1xuICAgICAqIHVuc3Vic2NyaWJlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGNsaWNrcyBoYXBwZW5pbmcgb24gdGhlIERPTSBkb2N1bWVudDwvY2FwdGlvbj5cbiAgICAgKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICAgICAqIGNsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXN1bHRzIGluOlxuICAgICAqIC8vIE1vdXNlRXZlbnQgb2JqZWN0IGxvZ2dlZCB0byBjb25zb2xlIGV2ZXJ5dGltZSBhIGNsaWNrXG4gICAgICogLy8gb2NjdXJzIG9uIHRoZSBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGZyb219XG4gICAgICogQHNlZSB7QGxpbmsgZnJvbUV2ZW50UGF0dGVybn1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgVGhlIERPTUVsZW1lbnQsIGV2ZW50IHRhcmdldCwgTm9kZS5qc1xuICAgICAqIEV2ZW50RW1pdHRlciwgTm9kZUxpc3Qgb3IgSFRNTENvbGxlY3Rpb24gdG8gYXR0YWNoIHRoZSBldmVudCBoYW5kbGVyIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIGV2ZW50IG5hbWUgb2YgaW50ZXJlc3QsIGJlaW5nIGVtaXR0ZWQgYnkgdGhlXG4gICAgICogYHRhcmdldGAuXG4gICAgICogQHBhcmFtIHtFdmVudExpc3RlbmVyT3B0aW9uc30gW29wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0aHJvdWdoIHRvIGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgKiBAcGFyYW0ge1NlbGVjdG9yTWV0aG9kU2lnbmF0dXJlPFQ+fSBbc2VsZWN0b3JdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvXG4gICAgICogcG9zdC1wcm9jZXNzIHJlc3VsdHMuIEl0IHRha2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgZXZlbnQgaGFuZGxlciBhbmRcbiAgICAgKiBzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59XG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgZnJvbUV2ZW50XG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50TmFtZSwgb3B0aW9ucywgc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBzZWxlY3RvciA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJvbUV2ZW50T2JzZXJ2YWJsZSh0YXJnZXQsIGV2ZW50TmFtZSwgc2VsZWN0b3IsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5zZXR1cFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzb3VyY2VPYmosIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmU7XG4gICAgICAgIGlmIChpc05vZGVMaXN0KHNvdXJjZU9iaikgfHwgaXNIVE1MQ29sbGVjdGlvbihzb3VyY2VPYmopKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlT2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5zZXR1cFN1YnNjcmlwdGlvbihzb3VyY2VPYmpbaV0sIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFdmVudFRhcmdldChzb3VyY2VPYmopKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlXzEgPSBzb3VyY2VPYmo7XG4gICAgICAgICAgICBzb3VyY2VPYmouYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2VfMS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNKUXVlcnlTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlXzIgPSBzb3VyY2VPYmo7XG4gICAgICAgICAgICBzb3VyY2VPYmoub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlXzIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOb2RlU3R5bGVFdmVudEVtaXR0ZXIoc291cmNlT2JqKSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZV8zID0gc291cmNlT2JqO1xuICAgICAgICAgICAgc291cmNlT2JqLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZV8zLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGV2ZW50IHRhcmdldCcpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIuYWRkKG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24odW5zdWJzY3JpYmUpKTtcbiAgICB9O1xuICAgIEZyb21FdmVudE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgc291cmNlT2JqID0gdGhpcy5zb3VyY2VPYmo7XG4gICAgICAgIHZhciBldmVudE5hbWUgPSB0aGlzLmV2ZW50TmFtZTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3I7XG4gICAgICAgIHZhciBoYW5kbGVyID0gc2VsZWN0b3IgPyBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goc2VsZWN0b3IpLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gc3Vic2NyaWJlci5uZXh0KGUpOyB9O1xuICAgICAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnNldHVwU3Vic2NyaXB0aW9uKHNvdXJjZU9iaiwgZXZlbnROYW1lLCBoYW5kbGVyLCBzdWJzY3JpYmVyLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBGcm9tRXZlbnRPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5Gcm9tRXZlbnRPYnNlcnZhYmxlID0gRnJvbUV2ZW50T2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZyb21FdmVudE9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIFNjYWxhck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTY2FsYXJPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNjYWxhck9ic2VydmFibGUodmFsdWUsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5faXNTY2FsYXIgPSB0cnVlO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1NjYWxhciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFNjYWxhck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTY2FsYXJPYnNlcnZhYmxlKHZhbHVlLCBzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgU2NhbGFyT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgZG9uZSA9IHN0YXRlLmRvbmUsIHZhbHVlID0gc3RhdGUudmFsdWUsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbiAgICB9O1xuICAgIFNjYWxhck9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoU2NhbGFyT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLCB2YWx1ZTogdmFsdWUsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTY2FsYXJPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5TY2FsYXJPYnNlcnZhYmxlID0gU2NhbGFyT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjYWxhck9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc051bWVyaWNfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNOdW1lcmljJyk7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xudmFyIGlzRGF0ZV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0RhdGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgVGltZXJPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGltZXJPYnNlcnZhYmxlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWVyT2JzZXJ2YWJsZShkdWVUaW1lLCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoZHVlVGltZSA9PT0gdm9pZCAwKSB7IGR1ZVRpbWUgPSAwOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnBlcmlvZCA9IC0xO1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSAwO1xuICAgICAgICBpZiAoaXNOdW1lcmljXzEuaXNOdW1lcmljKHBlcmlvZCkpIHtcbiAgICAgICAgICAgIHRoaXMucGVyaW9kID0gTnVtYmVyKHBlcmlvZCkgPCAxICYmIDEgfHwgTnVtYmVyKHBlcmlvZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihwZXJpb2QpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZXIgPSBwZXJpb2Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGlzRGF0ZV8xLmlzRGF0ZShkdWVUaW1lKSA/XG4gICAgICAgICAgICAoK2R1ZVRpbWUgLSB0aGlzLnNjaGVkdWxlci5ub3coKSkgOlxuICAgICAgICAgICAgZHVlVGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgc3RhcnRzIGVtaXR0aW5nIGFmdGVyIGFuIGBpbml0aWFsRGVsYXlgIGFuZFxuICAgICAqIGVtaXRzIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZSB0aGVyZWFmdGVyLlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0cyBsaWtlIHtAbGluayBpbnRlcnZhbH0sIGJ1dCB5b3UgY2FuIHNwZWNpZnkgd2hlblxuICAgICAqIHNob3VsZCB0aGUgZW1pc3Npb25zIHN0YXJ0Ljwvc3Bhbj5cbiAgICAgKlxuICAgICAqIDxpbWcgc3JjPVwiLi9pbWcvdGltZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAgICpcbiAgICAgKiBgdGltZXJgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGFuIGluZmluaXRlIHNlcXVlbmNlIG9mIGFzY2VuZGluZ1xuICAgICAqIGludGVnZXJzLCB3aXRoIGEgY29uc3RhbnQgaW50ZXJ2YWwgb2YgdGltZSwgYHBlcmlvZGAgb2YgeW91ciBjaG9vc2luZ1xuICAgICAqIGJldHdlZW4gdGhvc2UgZW1pc3Npb25zLiBUaGUgZmlyc3QgZW1pc3Npb24gaGFwcGVucyBhZnRlciB0aGUgc3BlY2lmaWVkXG4gICAgICogYGluaXRpYWxEZWxheWAuIFRoZSBpbml0aWFsIGRlbGF5IG1heSBiZSBhIHtAbGluayBEYXRlfS4gQnkgZGVmYXVsdCwgdGhpc1xuICAgICAqIG9wZXJhdG9yIHVzZXMgdGhlIGBhc3luY2AgSVNjaGVkdWxlciB0byBwcm92aWRlIGEgbm90aW9uIG9mIHRpbWUsIGJ1dCB5b3VcbiAgICAgKiBtYXkgcGFzcyBhbnkgSVNjaGVkdWxlciB0byBpdC4gSWYgYHBlcmlvZGAgaXMgbm90IHNwZWNpZmllZCwgdGhlIG91dHB1dFxuICAgICAqIE9ic2VydmFibGUgZW1pdHMgb25seSBvbmUgdmFsdWUsIGAwYC4gT3RoZXJ3aXNlLCBpdCBlbWl0cyBhbiBpbmZpbml0ZVxuICAgICAqIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgYXNjZW5kaW5nIG51bWJlcnMsIG9uZSBldmVyeSBzZWNvbmQgKDEwMDBtcyksIHN0YXJ0aW5nIGFmdGVyIDMgc2Vjb25kczwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUudGltZXIoMzAwMCwgMTAwMCk7XG4gICAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyBvbmUgbnVtYmVyIGFmdGVyIGZpdmUgc2Vjb25kczwvY2FwdGlvbj5cbiAgICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUudGltZXIoNTAwMCk7XG4gICAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBpbnRlcnZhbH1cbiAgICAgKiBAc2VlIHtAbGluayBkZWxheX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGluaXRpYWxEZWxheSBUaGUgaW5pdGlhbCBkZWxheSB0aW1lIHRvIHdhaXQgYmVmb3JlXG4gICAgICogZW1pdHRpbmcgdGhlIGZpcnN0IHZhbHVlIG9mIGAwYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3BlcmlvZF0gVGhlIHBlcmlvZCBvZiB0aW1lIGJldHdlZW4gZW1pc3Npb25zIG9mIHRoZVxuICAgICAqIHN1YnNlcXVlbnQgbnVtYmVycy5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9uIG9mIHZhbHVlcywgYW5kIHByb3ZpZGluZyBhIG5vdGlvbiBvZiBcInRpbWVcIi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBgMGAgYWZ0ZXIgdGhlXG4gICAgICogYGluaXRpYWxEZWxheWAgYW5kIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZVxuICAgICAqIHRoZXJlYWZ0ZXIuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgdGltZXJcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbERlbGF5LCBwZXJpb2QsIHNjaGVkdWxlcikge1xuICAgICAgICBpZiAoaW5pdGlhbERlbGF5ID09PSB2b2lkIDApIHsgaW5pdGlhbERlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IFRpbWVyT2JzZXJ2YWJsZShpbml0aWFsRGVsYXksIHBlcmlvZCwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSBzdGF0ZS5pbmRleCwgcGVyaW9kID0gc3RhdGUucGVyaW9kLCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXM7XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChpbmRleCk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBlcmlvZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIGFjdGlvbi5zY2hlZHVsZShzdGF0ZSwgcGVyaW9kKTtcbiAgICB9O1xuICAgIFRpbWVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHBlcmlvZCA9IF9hLnBlcmlvZCwgZHVlVGltZSA9IF9hLmR1ZVRpbWUsIHNjaGVkdWxlciA9IF9hLnNjaGVkdWxlcjtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShUaW1lck9ic2VydmFibGUuZGlzcGF0Y2gsIGR1ZVRpbWUsIHtcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCwgcGVyaW9kOiBwZXJpb2QsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZXJPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5UaW1lck9ic2VydmFibGUgPSBUaW1lck9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW1lck9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0VtcHR5T2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5lbXB0eSA9IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZS5jcmVhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbXB0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBGcm9tRXZlbnRPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0Zyb21FdmVudE9ic2VydmFibGUnKTtcbmV4cG9ydHMuZnJvbUV2ZW50ID0gRnJvbUV2ZW50T2JzZXJ2YWJsZV8xLkZyb21FdmVudE9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJvbUV2ZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9BcnJheU9ic2VydmFibGUnKTtcbmV4cG9ydHMub2YgPSBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUub2Y7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBUaW1lck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vVGltZXJPYnNlcnZhYmxlJyk7XG5leHBvcnRzLnRpbWVyID0gVGltZXJPYnNlcnZhYmxlXzEuVGltZXJPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpbWVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBDYXRjaGVzIGVycm9ycyBvbiB0aGUgb2JzZXJ2YWJsZSB0byBiZSBoYW5kbGVkIGJ5IHJldHVybmluZyBhIG5ldyBvYnNlcnZhYmxlIG9yIHRocm93aW5nIGFuIGVycm9yLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY2F0Y2gucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29udGludWVzIHdpdGggYSBkaWZmZXJlbnQgT2JzZXJ2YWJsZSB3aGVuIHRoZXJlJ3MgYW4gZXJyb3I8L2NhcHRpb24+XG4gKlxuICogT2JzZXJ2YWJsZS5vZigxLCAyLCAzLCA0LCA1KVxuICogICAubWFwKG4gPT4ge1xuICogXHQgICBpZiAobiA9PSA0KSB7XG4gKiBcdCAgICAgdGhyb3cgJ2ZvdXIhJztcbiAqICAgICB9XG4gKlx0ICAgcmV0dXJuIG47XG4gKiAgIH0pXG4gKiAgIC5jYXRjaChlcnIgPT4gT2JzZXJ2YWJsZS5vZignSScsICdJSScsICdJSUknLCAnSVYnLCAnVicpKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogICAvLyAxLCAyLCAzLCBJLCBJSSwgSUlJLCBJViwgVlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJldHJpZXMgdGhlIGNhdWdodCBzb3VyY2UgT2JzZXJ2YWJsZSBhZ2FpbiBpbiBjYXNlIG9mIGVycm9yLCBzaW1pbGFyIHRvIHJldHJ5KCkgb3BlcmF0b3I8L2NhcHRpb24+XG4gKlxuICogT2JzZXJ2YWJsZS5vZigxLCAyLCAzLCA0LCA1KVxuICogICAubWFwKG4gPT4ge1xuICogXHQgICBpZiAobiA9PT0gNCkge1xuICogXHQgICAgIHRocm93ICdmb3VyISc7XG4gKiAgICAgfVxuICogXHQgICByZXR1cm4gbjtcbiAqICAgfSlcbiAqICAgLmNhdGNoKChlcnIsIGNhdWdodCkgPT4gY2F1Z2h0KVxuICogICAudGFrZSgzMClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqICAgLy8gMSwgMiwgMywgMSwgMiwgMywgLi4uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VGhyb3dzIGEgbmV3IGVycm9yIHdoZW4gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRocm93cyBhbiBlcnJvcjwvY2FwdGlvbj5cbiAqXG4gKiBPYnNlcnZhYmxlLm9mKDEsIDIsIDMsIDQsIDUpXG4gKiAgIC5tYXAobiA9PiB7XG4gKiAgICAgaWYgKG4gPT0gNCkge1xuICogICAgICAgdGhyb3cgJ2ZvdXIhJztcbiAqICAgICB9XG4gKiAgICAgcmV0dXJuIG47XG4gKiAgIH0pXG4gKiAgIC5jYXRjaChlcnIgPT4ge1xuICogICAgIHRocm93ICdlcnJvciBpbiBzb3VyY2UuIERldGFpbHM6ICcgKyBlcnI7XG4gKiAgIH0pXG4gKiAgIC5zdWJzY3JpYmUoXG4gKiAgICAgeCA9PiBjb25zb2xlLmxvZyh4KSxcbiAqICAgICBlcnIgPT4gY29uc29sZS5sb2coZXJyKVxuICogICApO1xuICogICAvLyAxLCAyLCAzLCBlcnJvciBpbiBzb3VyY2UuIERldGFpbHM6IGZvdXIhXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc2VsZWN0b3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGFzIGFyZ3VtZW50cyBgZXJyYCwgd2hpY2ggaXMgdGhlIGVycm9yLCBhbmQgYGNhdWdodGAsIHdoaWNoXG4gKiAgaXMgdGhlIHNvdXJjZSBvYnNlcnZhYmxlLCBpbiBjYXNlIHlvdSdkIGxpa2UgdG8gXCJyZXRyeVwiIHRoYXQgb2JzZXJ2YWJsZSBieSByZXR1cm5pbmcgaXQgYWdhaW4uIFdoYXRldmVyIG9ic2VydmFibGVcbiAqICBpcyByZXR1cm5lZCBieSB0aGUgYHNlbGVjdG9yYCB3aWxsIGJlIHVzZWQgdG8gY29udGludWUgdGhlIG9ic2VydmFibGUgY2hhaW4uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHRoYXQgb3JpZ2luYXRlcyBmcm9tIGVpdGhlciB0aGUgc291cmNlIG9yIHRoZSBvYnNlcnZhYmxlIHJldHVybmVkIGJ5IHRoZVxuICogIGNhdGNoIGBzZWxlY3RvcmAgZnVuY3Rpb24uXG4gKiBAbWV0aG9kIGNhdGNoXG4gKiBAbmFtZSBjYXRjaFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gX2NhdGNoKHNlbGVjdG9yKSB7XG4gICAgdmFyIG9wZXJhdG9yID0gbmV3IENhdGNoT3BlcmF0b3Ioc2VsZWN0b3IpO1xuICAgIHZhciBjYXVnaHQgPSB0aGlzLmxpZnQob3BlcmF0b3IpO1xuICAgIHJldHVybiAob3BlcmF0b3IuY2F1Z2h0ID0gY2F1Z2h0KTtcbn1cbmV4cG9ydHMuX2NhdGNoID0gX2NhdGNoO1xudmFyIENhdGNoT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhdGNoT3BlcmF0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgIH1cbiAgICBDYXRjaE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQ2F0Y2hTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuc2VsZWN0b3IsIHRoaXMuY2F1Z2h0KSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0Y2hPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIENhdGNoU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENhdGNoU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYXRjaFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHNlbGVjdG9yLCBjYXVnaHQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY2F1Z2h0ID0gY2F1Z2h0O1xuICAgIH1cbiAgICAvLyBOT1RFOiBvdmVycmlkaW5nIGBlcnJvcmAgaW5zdGVhZCBvZiBgX2Vycm9yYCBiZWNhdXNlIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBoYXZlIHRoaXMgZmxhZyB0aGlzIHN1YnNjcmliZXIgYXMgYGlzU3RvcHBlZGAuIFdlIGNhbiBtaW1pYyB0aGVcbiAgICAvLyBiZWhhdmlvciBvZiB0aGUgUmV0cnlTdWJzY3JpYmVyIChmcm9tIHRoZSBgcmV0cnlgIG9wZXJhdG9yKSwgd2hlcmVcbiAgICAvLyB3ZSB1bnN1YnNjcmliZSBmcm9tIG91ciBzb3VyY2UgY2hhaW4sIHJlc2V0IG91ciBTdWJzY3JpYmVyIGZsYWdzLFxuICAgIC8vIHRoZW4gc3Vic2NyaWJlIHRvIHRoZSBzZWxlY3RvciByZXN1bHQuXG4gICAgQ2F0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5zZWxlY3RvcihlcnIsIHRoaXMuY2F1Z2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIyKSB7XG4gICAgICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGVycjIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSgpO1xuICAgICAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXN1bHQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhdGNoU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VBbGxfMSA9IHJlcXVpcmUoJy4vbWVyZ2VBbGwnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENyZWF0ZXMgYW4gb3V0cHV0IE9ic2VydmFibGUgd2hpY2ggc2VxdWVudGlhbGx5IGVtaXRzIGFsbCB2YWx1ZXMgZnJvbSBldmVyeVxuICogZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZSBhZnRlciB0aGUgY3VycmVudCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db25jYXRlbmF0ZXMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG9nZXRoZXIgYnlcbiAqIHNlcXVlbnRpYWxseSBlbWl0dGluZyB0aGVpciB2YWx1ZXMsIG9uZSBPYnNlcnZhYmxlIGFmdGVyIHRoZSBvdGhlci48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jb25jYXQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogSm9pbnMgdGhpcyBPYnNlcnZhYmxlIHdpdGggbXVsdGlwbGUgb3RoZXIgT2JzZXJ2YWJsZXMgYnkgc3Vic2NyaWJpbmcgdG8gdGhlbVxuICogb25lIGF0IGEgdGltZSwgc3RhcnRpbmcgd2l0aCB0aGUgc291cmNlLCBhbmQgbWVyZ2luZyB0aGVpciByZXN1bHRzIGludG8gdGhlXG4gKiBvdXRwdXQgT2JzZXJ2YWJsZS4gV2lsbCB3YWl0IGZvciBlYWNoIE9ic2VydmFibGUgdG8gY29tcGxldGUgYmVmb3JlIG1vdmluZ1xuICogb24gdG8gdGhlIG5leHQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgYSB0aW1lciBjb3VudGluZyBmcm9tIDAgdG8gMyB3aXRoIGEgc3luY2hyb25vdXMgc2VxdWVuY2UgZnJvbSAxIHRvIDEwPC9jYXB0aW9uPlxuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDQpO1xuICogdmFyIHNlcXVlbmNlID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMCk7XG4gKiB2YXIgcmVzdWx0ID0gdGltZXIuY29uY2F0KHNlcXVlbmNlKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gcmVzdWx0cyBpbjpcbiAqIC8vIDEwMDBtcy0+IDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IDIgLTEwMDBtcy0+IDMgLWltbWVkaWF0ZS0+IDEgLi4uIDEwXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgMyBPYnNlcnZhYmxlczwvY2FwdGlvbj5cbiAqIHZhciB0aW1lcjEgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApO1xuICogdmFyIHRpbWVyMiA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkudGFrZSg2KTtcbiAqIHZhciB0aW1lcjMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkudGFrZSgxMCk7XG4gKiB2YXIgcmVzdWx0ID0gdGltZXIxLmNvbmNhdCh0aW1lcjIsIHRpbWVyMyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIHJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIChQcmludHMgdG8gY29uc29sZSBzZXF1ZW50aWFsbHkpXG4gKiAvLyAtMTAwMG1zLT4gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gLi4uIDlcbiAqIC8vIC0yMDAwbXMtPiAwIC0yMDAwbXMtPiAxIC0yMDAwbXMtPiAuLi4gNVxuICogLy8gLTUwMG1zLT4gMCAtNTAwbXMtPiAxIC01MDBtcy0+IC4uLiA5XG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwVG99XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IG90aGVyIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29uY2F0ZW5hdGUgYWZ0ZXIgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBBbiBvcHRpb25hbCBJU2NoZWR1bGVyIHRvIHNjaGVkdWxlIGVhY2hcbiAqIE9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQWxsIHZhbHVlcyBvZiBlYWNoIHBhc3NlZCBPYnNlcnZhYmxlIG1lcmdlZCBpbnRvIGFcbiAqIHNpbmdsZSBPYnNlcnZhYmxlLCBpbiBvcmRlciwgaW4gc2VyaWFsIGZhc2hpb24uXG4gKiBAbWV0aG9kIGNvbmNhdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gY29uY2F0KCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0LmNhbGwoY29uY2F0U3RhdGljLmFwcGx5KHZvaWQgMCwgW3RoaXNdLmNvbmNhdChvYnNlcnZhYmxlcykpKTtcbn1cbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBzZXF1ZW50aWFsbHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGdpdmVuXG4gKiBPYnNlcnZhYmxlIGFuZCB0aGVuIG1vdmVzIG9uIHRvIHRoZSBuZXh0LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db25jYXRlbmF0ZXMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG9nZXRoZXIgYnlcbiAqIHNlcXVlbnRpYWxseSBlbWl0dGluZyB0aGVpciB2YWx1ZXMsIG9uZSBPYnNlcnZhYmxlIGFmdGVyIHRoZSBvdGhlci48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jb25jYXQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGNvbmNhdGAgam9pbnMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG9nZXRoZXIsIGJ5IHN1YnNjcmliaW5nIHRvIHRoZW0gb25lIGF0IGEgdGltZSBhbmRcbiAqIG1lcmdpbmcgdGhlaXIgcmVzdWx0cyBpbnRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gWW91IGNhbiBwYXNzIGVpdGhlciBhbiBhcnJheSBvZlxuICogT2JzZXJ2YWJsZXMsIG9yIHB1dCB0aGVtIGRpcmVjdGx5IGFzIGFyZ3VtZW50cy4gUGFzc2luZyBhbiBlbXB0eSBhcnJheSB3aWxsIHJlc3VsdFxuICogaW4gT2JzZXJ2YWJsZSB0aGF0IGNvbXBsZXRlcyBpbW1lZGlhdGVseS5cbiAqXG4gKiBgY29uY2F0YCB3aWxsIHN1YnNjcmliZSB0byBmaXJzdCBpbnB1dCBPYnNlcnZhYmxlIGFuZCBlbWl0IGFsbCBpdHMgdmFsdWVzLCB3aXRob3V0XG4gKiBjaGFuZ2luZyBvciBhZmZlY3RpbmcgdGhlbSBpbiBhbnkgd2F5LiBXaGVuIHRoYXQgT2JzZXJ2YWJsZSBjb21wbGV0ZXMsIGl0IHdpbGxcbiAqIHN1YnNjcmliZSB0byB0aGVuIG5leHQgT2JzZXJ2YWJsZSBwYXNzZWQgYW5kLCBhZ2FpbiwgZW1pdCBpdHMgdmFsdWVzLiBUaGlzIHdpbGwgYmVcbiAqIHJlcGVhdGVkLCB1bnRpbCB0aGUgb3BlcmF0b3IgcnVucyBvdXQgb2YgT2JzZXJ2YWJsZXMuIFdoZW4gbGFzdCBpbnB1dCBPYnNlcnZhYmxlIGNvbXBsZXRlcyxcbiAqIGBjb25jYXRgIHdpbGwgY29tcGxldGUgYXMgd2VsbC4gQXQgYW55IGdpdmVuIG1vbWVudCBvbmx5IG9uZSBPYnNlcnZhYmxlIHBhc3NlZCB0byBvcGVyYXRvclxuICogZW1pdHMgdmFsdWVzLiBJZiB5b3Ugd291bGQgbGlrZSB0byBlbWl0IHZhbHVlcyBmcm9tIHBhc3NlZCBPYnNlcnZhYmxlcyBjb25jdXJyZW50bHksIGNoZWNrIG91dFxuICoge0BsaW5rIG1lcmdlfSBpbnN0ZWFkLCBlc3BlY2lhbGx5IHdpdGggb3B0aW9uYWwgYGNvbmN1cnJlbnRgIHBhcmFtZXRlci4gQXMgYSBtYXR0ZXIgb2YgZmFjdCxcbiAqIGBjb25jYXRgIGlzIGFuIGVxdWl2YWxlbnQgb2YgYG1lcmdlYCBvcGVyYXRvciB3aXRoIGBjb25jdXJyZW50YCBwYXJhbWV0ZXIgc2V0IHRvIGAxYC5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgc29tZSBpbnB1dCBPYnNlcnZhYmxlIG5ldmVyIGNvbXBsZXRlcywgYGNvbmNhdGAgd2lsbCBhbHNvIG5ldmVyIGNvbXBsZXRlXG4gKiBhbmQgT2JzZXJ2YWJsZXMgZm9sbG93aW5nIHRoZSBvbmUgdGhhdCBkaWQgbm90IGNvbXBsZXRlIHdpbGwgbmV2ZXIgYmUgc3Vic2NyaWJlZC4gT24gdGhlIG90aGVyXG4gKiBoYW5kLCBpZiBzb21lIE9ic2VydmFibGUgc2ltcGx5IGNvbXBsZXRlcyBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyBzdWJzY3JpYmVkLCBpdCB3aWxsIGJlXG4gKiBpbnZpc2libGUgZm9yIGBjb25jYXRgLCB3aGljaCB3aWxsIGp1c3QgbW92ZSBvbiB0byB0aGUgbmV4dCBPYnNlcnZhYmxlLlxuICpcbiAqIElmIGFueSBPYnNlcnZhYmxlIGluIGNoYWluIGVycm9ycywgaW5zdGVhZCBvZiBwYXNzaW5nIGNvbnRyb2wgdG8gdGhlIG5leHQgT2JzZXJ2YWJsZSxcbiAqIGBjb25jYXRgIHdpbGwgZXJyb3IgaW1tZWRpYXRlbHkgYXMgd2VsbC4gT2JzZXJ2YWJsZXMgdGhhdCB3b3VsZCBiZSBzdWJzY3JpYmVkIGFmdGVyXG4gKiB0aGUgb25lIHRoYXQgZW1pdHRlZCBlcnJvciwgbmV2ZXIgd2lsbC5cbiAqXG4gKiBJZiB5b3UgcGFzcyB0byBgY29uY2F0YCB0aGUgc2FtZSBPYnNlcnZhYmxlIG1hbnkgdGltZXMsIGl0cyBzdHJlYW0gb2YgdmFsdWVzXG4gKiB3aWxsIGJlIFwicmVwbGF5ZWRcIiBvbiBldmVyeSBzdWJzY3JpcHRpb24sIHdoaWNoIG1lYW5zIHlvdSBjYW4gcmVwZWF0IGdpdmVuIE9ic2VydmFibGVcbiAqIGFzIG1hbnkgdGltZXMgYXMgeW91IGxpa2UuIElmIHBhc3NpbmcgdGhlIHNhbWUgT2JzZXJ2YWJsZSB0byBgY29uY2F0YCAxMDAwIHRpbWVzIGJlY29tZXMgdGVkaW91cyxcbiAqIHlvdSBjYW4gYWx3YXlzIHVzZSB7QGxpbmsgcmVwZWF0fS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSBhIHRpbWVyIGNvdW50aW5nIGZyb20gMCB0byAzIHdpdGggYSBzeW5jaHJvbm91cyBzZXF1ZW5jZSBmcm9tIDEgdG8gMTA8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoNCk7XG4gKiB2YXIgc2VxdWVuY2UgPSBSeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwKTtcbiAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLmNvbmNhdCh0aW1lciwgc2VxdWVuY2UpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyByZXN1bHRzIGluOlxuICogLy8gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gMiAtMTAwMG1zLT4gMyAtaW1tZWRpYXRlLT4gMSAuLi4gMTBcbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgYW4gYXJyYXkgb2YgMyBPYnNlcnZhYmxlczwvY2FwdGlvbj5cbiAqIHZhciB0aW1lcjEgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApO1xuICogdmFyIHRpbWVyMiA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkudGFrZSg2KTtcbiAqIHZhciB0aW1lcjMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkudGFrZSgxMCk7XG4gKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5jb25jYXQoW3RpbWVyMSwgdGltZXIyLCB0aW1lcjNdKTsgLy8gbm90ZSB0aGF0IGFycmF5IGlzIHBhc3NlZFxuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyByZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAoUHJpbnRzIHRvIGNvbnNvbGUgc2VxdWVudGlhbGx5KVxuICogLy8gLTEwMDBtcy0+IDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IC4uLiA5XG4gKiAvLyAtMjAwMG1zLT4gMCAtMjAwMG1zLT4gMSAtMjAwMG1zLT4gLi4uIDVcbiAqIC8vIC01MDBtcy0+IDAgLTUwMG1zLT4gMSAtNTAwbXMtPiAuLi4gOVxuICpcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSB0aGUgc2FtZSBPYnNlcnZhYmxlIHRvIHJlcGVhdCBpdDwvY2FwdGlvbj5cbiAqIGNvbnN0IHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDIpO1xuICpcbiAqIFJ4Lk9ic2VydmFibGUuY29uY2F0KHRpbWVyLCB0aW1lcikgLy8gY29uY2F0aW5nIHRoZSBzYW1lIE9ic2VydmFibGUhXG4gKiAuc3Vic2NyaWJlKFxuICogICB2YWx1ZSA9PiBjb25zb2xlLmxvZyh2YWx1ZSksXG4gKiAgIGVyciA9PiB7fSxcbiAqICAgKCkgPT4gY29uc29sZS5sb2coJy4uLmFuZCBpdCBpcyBkb25lIScpXG4gKiApO1xuICpcbiAqIC8vIExvZ3M6XG4gKiAvLyAwIGFmdGVyIDFzXG4gKiAvLyAxIGFmdGVyIDJzXG4gKiAvLyAwIGFmdGVyIDNzXG4gKiAvLyAxIGFmdGVyIDRzXG4gKiAvLyBcIi4uLmFuZCBpdCBpcyBkb25lIVwiIGFsc28gYWZ0ZXIgNHNcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gaW5wdXQxIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29uY2F0ZW5hdGUgd2l0aCBvdGhlcnMuXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gaW5wdXQyIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29uY2F0ZW5hdGUgd2l0aCBvdGhlcnMuXG4gKiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPW51bGxdIEFuIG9wdGlvbmFsIElTY2hlZHVsZXIgdG8gc2NoZWR1bGUgZWFjaFxuICogT2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbGwgdmFsdWVzIG9mIGVhY2ggcGFzc2VkIE9ic2VydmFibGUgbWVyZ2VkIGludG8gYVxuICogc2luZ2xlIE9ic2VydmFibGUsIGluIG9yZGVyLCBpbiBzZXJpYWwgZmFzaGlvbi5cbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgY29uY2F0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBjb25jYXRTdGF0aWMoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBzY2hlZHVsZXIgPSBudWxsO1xuICAgIHZhciBhcmdzID0gb2JzZXJ2YWJsZXM7XG4gICAgaWYgKGlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoYXJnc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgc2NoZWR1bGVyID0gYXJncy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gbnVsbCAmJiBvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEgJiYgb2JzZXJ2YWJsZXNbMF0gaW5zdGFuY2VvZiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZXNbMF07XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKG9ic2VydmFibGVzLCBzY2hlZHVsZXIpLmxpZnQobmV3IG1lcmdlQWxsXzEuTWVyZ2VBbGxPcGVyYXRvcigxKSk7XG59XG5leHBvcnRzLmNvbmNhdFN0YXRpYyA9IGNvbmNhdFN0YXRpYztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmNhdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBhc3luY18xID0gcmVxdWlyZSgnLi4vc2NoZWR1bGVyL2FzeW5jJyk7XG4vKipcbiAqIEVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb25seSBhZnRlciBhIHBhcnRpY3VsYXIgdGltZSBzcGFuXG4gKiBoYXMgcGFzc2VkIHdpdGhvdXQgYW5vdGhlciBzb3VyY2UgZW1pc3Npb24uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZGVsYXl9LCBidXQgcGFzc2VzIG9ubHkgdGhlIG1vc3RcbiAqIHJlY2VudCB2YWx1ZSBmcm9tIGVhY2ggYnVyc3Qgb2YgZW1pc3Npb25zLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlYm91bmNlVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZGVib3VuY2VUaW1lYCBkZWxheXMgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgZHJvcHNcbiAqIHByZXZpb3VzIHBlbmRpbmcgZGVsYXllZCBlbWlzc2lvbnMgaWYgYSBuZXcgdmFsdWUgYXJyaXZlcyBvbiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGlzIG9wZXJhdG9yIGtlZXBzIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCB2YWx1ZSBmcm9tIHRoZVxuICogc291cmNlIE9ic2VydmFibGUsIGFuZCBlbWl0cyB0aGF0IG9ubHkgd2hlbiBgZHVlVGltZWAgZW5vdWdoIHRpbWUgaGFzIHBhc3NlZFxuICogd2l0aG91dCBhbnkgb3RoZXIgdmFsdWUgYXBwZWFyaW5nIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgYSBuZXcgdmFsdWVcbiAqIGFwcGVhcnMgYmVmb3JlIGBkdWVUaW1lYCBzaWxlbmNlIG9jY3VycywgdGhlIHByZXZpb3VzIHZhbHVlIHdpbGwgYmUgZHJvcHBlZFxuICogYW5kIHdpbGwgbm90IGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIFRoaXMgaXMgYSByYXRlLWxpbWl0aW5nIG9wZXJhdG9yLCBiZWNhdXNlIGl0IGlzIGltcG9zc2libGUgZm9yIG1vcmUgdGhhbiBvbmVcbiAqIHZhbHVlIHRvIGJlIGVtaXR0ZWQgaW4gYW55IHRpbWUgd2luZG93IG9mIGR1cmF0aW9uIGBkdWVUaW1lYCwgYnV0IGl0IGlzIGFsc29cbiAqIGEgZGVsYXktbGlrZSBvcGVyYXRvciBzaW5jZSBvdXRwdXQgZW1pc3Npb25zIGRvIG5vdCBvY2N1ciBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gKiB0aGV5IGRpZCBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuIE9wdGlvbmFsbHkgdGFrZXMgYSB7QGxpbmsgSVNjaGVkdWxlcn0gZm9yXG4gKiBtYW5hZ2luZyB0aW1lcnMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbW9zdCByZWNlbnQgY2xpY2sgYWZ0ZXIgYSBidXJzdCBvZiBjbGlja3M8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5kZWJvdW5jZVRpbWUoMTAwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0VGltZX1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlfVxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGVUaW1lfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdWVUaW1lIFRoZSB0aW1lb3V0IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGhlIHRpbWVcbiAqIHVuaXQgZGV0ZXJtaW5lZCBpbnRlcm5hbGx5IGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCkgZm9yIHRoZSB3aW5kb3cgb2ZcbiAqIHRpbWUgcmVxdWlyZWQgdG8gd2FpdCBmb3IgZW1pc3Npb24gc2lsZW5jZSBiZWZvcmUgZW1pdHRpbmcgdGhlIG1vc3QgcmVjZW50XG4gKiBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSB0aW1lb3V0IGZvciBlYWNoIHZhbHVlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhlIHNwZWNpZmllZCBgZHVlVGltZWAsIGFuZCBtYXkgZHJvcCBzb21lIHZhbHVlcyBpZiB0aGV5IG9jY3VyXG4gKiB0b28gZnJlcXVlbnRseS5cbiAqIEBtZXRob2QgZGVib3VuY2VUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWJvdW5jZVRpbWUoZHVlVGltZSwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEZWJvdW5jZVRpbWVPcGVyYXRvcihkdWVUaW1lLCBzY2hlZHVsZXIpKTtcbn1cbmV4cG9ydHMuZGVib3VuY2VUaW1lID0gZGVib3VuY2VUaW1lO1xudmFyIERlYm91bmNlVGltZU9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZVRpbWVPcGVyYXRvcihkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5kdWVUaW1lID0gZHVlVGltZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIERlYm91bmNlVGltZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVib3VuY2VUaW1lU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1ZVRpbWUsIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVib3VuY2VUaW1lT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVib3VuY2VUaW1lU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSBkdWVUaW1lO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jbGVhckRlYm91bmNlKCk7XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLmFkZCh0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgdGhpcy5kdWVUaW1lLCB0aGlzKSk7XG4gICAgfTtcbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVib3VuY2VkTmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5kZWJvdW5jZWROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyRGVib3VuY2UoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmxhc3RWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmNsZWFyRGVib3VuY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZWJvdW5jZWRTdWJzY3JpcHRpb24gPSB0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKGRlYm91bmNlZFN1YnNjcmlwdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZGVib3VuY2VkU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgIGRlYm91bmNlZFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5kZWJvdW5jZWRTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRGVib3VuY2VUaW1lU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChzdWJzY3JpYmVyKSB7XG4gICAgc3Vic2NyaWJlci5kZWJvdW5jZWROZXh0KCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWJvdW5jZVRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQZXJmb3JtIGEgc2lkZSBlZmZlY3QgZm9yIGV2ZXJ5IGVtaXNzaW9uIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IHJldHVyblxuICogYW4gT2JzZXJ2YWJsZSB0aGF0IGlzIGlkZW50aWNhbCB0byB0aGUgc291cmNlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JbnRlcmNlcHRzIGVhY2ggZW1pc3Npb24gb24gdGhlIHNvdXJjZSBhbmQgcnVucyBhXG4gKiBmdW5jdGlvbiwgYnV0IHJldHVybnMgYW4gb3V0cHV0IHdoaWNoIGlzIGlkZW50aWNhbCB0byB0aGUgc291cmNlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYSBtaXJyb3JlZCBPYnNlcnZhYmxlIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IG1vZGlmaWVkIHNvIHRoYXRcbiAqIHRoZSBwcm92aWRlZCBPYnNlcnZlciBpcyBjYWxsZWQgdG8gcGVyZm9ybSBhIHNpZGUgZWZmZWN0IGZvciBldmVyeSB2YWx1ZSxcbiAqIGVycm9yLCBhbmQgY29tcGxldGlvbiBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UuIEFueSBlcnJvcnMgdGhhdCBhcmUgdGhyb3duIGluXG4gKiB0aGUgYWZvcmVtZW50aW9uZWQgT2JzZXJ2ZXIgb3IgaGFuZGxlcnMgYXJlIHNhZmVseSBzZW50IGRvd24gdGhlIGVycm9yIHBhdGhcbiAqIG9mIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBUaGlzIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nIHlvdXIgT2JzZXJ2YWJsZXMgZm9yIHRoZSBjb3JyZWN0IHZhbHVlc1xuICogb3IgcGVyZm9ybWluZyBvdGhlciBzaWRlIGVmZmVjdHMuXG4gKlxuICogTm90ZTogdGhpcyBpcyBkaWZmZXJlbnQgdG8gYSBgc3Vic2NyaWJlYCBvbiB0aGUgT2JzZXJ2YWJsZS4gSWYgdGhlIE9ic2VydmFibGVcbiAqIHJldHVybmVkIGJ5IGBkb2AgaXMgbm90IHN1YnNjcmliZWQsIHRoZSBzaWRlIGVmZmVjdHMgc3BlY2lmaWVkIGJ5IHRoZVxuICogT2JzZXJ2ZXIgd2lsbCBuZXZlciBoYXBwZW4uIGBkb2AgdGhlcmVmb3JlIHNpbXBseSBzcGllcyBvbiBleGlzdGluZ1xuICogZXhlY3V0aW9uLCBpdCBkb2VzIG5vdCB0cmlnZ2VyIGFuIGV4ZWN1dGlvbiB0byBoYXBwZW4gbGlrZSBgc3Vic2NyaWJlYCBkb2VzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBldmVyeSBldmVyeSBjbGljayB0byB0aGUgY2xpZW50WCBwb3NpdGlvbiBvZiB0aGF0IGNsaWNrLCB3aGlsZSBhbHNvIGxvZ2dpbmcgdGhlIGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwb3NpdGlvbnMgPSBjbGlja3NcbiAqICAgLmRvKGV2ID0+IGNvbnNvbGUubG9nKGV2KSlcbiAqICAgLm1hcChldiA9PiBldi5jbGllbnRYKTtcbiAqIHBvc2l0aW9ucy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwfVxuICogQHNlZSB7QGxpbmsgc3Vic2NyaWJlfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2ZXJ8ZnVuY3Rpb259IFtuZXh0T3JPYnNlcnZlcl0gQSBub3JtYWwgT2JzZXJ2ZXIgb2JqZWN0IG9yIGFcbiAqIGNhbGxiYWNrIGZvciBgbmV4dGAuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbZXJyb3JdIENhbGxiYWNrIGZvciBlcnJvcnMgaW4gdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjb21wbGV0ZV0gQ2FsbGJhY2sgZm9yIHRoZSBjb21wbGV0aW9uIG9mIHRoZSBzb3VyY2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIGlkZW50aWNhbCB0byB0aGUgc291cmNlLCBidXQgcnVucyB0aGVcbiAqIHNwZWNpZmllZCBPYnNlcnZlciBvciBjYWxsYmFjayhzKSBmb3IgZWFjaCBpdGVtLlxuICogQG1ldGhvZCBkb1xuICogQG5hbWUgZG9cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9kbyhuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRG9PcGVyYXRvcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSk7XG59XG5leHBvcnRzLl9kbyA9IF9kbztcbnZhciBEb09wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEb09wZXJhdG9yKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5uZXh0T3JPYnNlcnZlciA9IG5leHRPck9ic2VydmVyO1xuICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgICB9XG4gICAgRG9PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERvU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5leHRPck9ic2VydmVyLCB0aGlzLmVycm9yLCB0aGlzLmNvbXBsZXRlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRG9PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERvU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb1N1YnNjcmliZXIoZGVzdGluYXRpb24sIG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKHNhZmVTdWJzY3JpYmVyKTtcbiAgICAgICAgdGhpcy5zYWZlU3Vic2NyaWJlciA9IHNhZmVTdWJzY3JpYmVyO1xuICAgIH1cbiAgICBEb1N1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IHRoaXMuc2FmZVN1YnNjcmliZXI7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERvU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgc2FmZVN1YnNjcmliZXIgPSB0aGlzLnNhZmVTdWJzY3JpYmVyO1xuICAgICAgICBzYWZlU3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IHRoaXMuc2FmZVN1YnNjcmliZXI7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIGlmIChzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3Ioc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRG9TdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlIG9ubHkgaWYgdGhlIHByZXZpb3VzIHByb2plY3RlZCBPYnNlcnZhYmxlIGhhcyBjb21wbGV0ZWQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPk1hcHMgZWFjaCB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlLCB0aGVuIGZsYXR0ZW5zIGFsbCBvZlxuICogdGhlc2UgaW5uZXIgT2JzZXJ2YWJsZXMgdXNpbmcge0BsaW5rIGV4aGF1c3R9Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2V4aGF1c3RNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiAoc28tY2FsbGVkIFwiaW5uZXJcIikgT2JzZXJ2YWJsZS4gV2hlbiBpdCBwcm9qZWN0cyBhIHNvdXJjZSB2YWx1ZSB0b1xuICogYW4gT2JzZXJ2YWJsZSwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJlZ2lucyBlbWl0dGluZyB0aGUgaXRlbXMgZW1pdHRlZCBieVxuICogdGhhdCBwcm9qZWN0ZWQgT2JzZXJ2YWJsZS4gSG93ZXZlciwgYGV4aGF1c3RNYXBgIGlnbm9yZXMgZXZlcnkgbmV3IHByb2plY3RlZFxuICogT2JzZXJ2YWJsZSBpZiB0aGUgcHJldmlvdXMgcHJvamVjdGVkIE9ic2VydmFibGUgaGFzIG5vdCB5ZXQgY29tcGxldGVkLiBPbmNlXG4gKiB0aGF0IG9uZSBjb21wbGV0ZXMsIGl0IHdpbGwgYWNjZXB0IGFuZCBmbGF0dGVuIHRoZSBuZXh0IHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBhbmQgcmVwZWF0IHRoaXMgcHJvY2Vzcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5SdW4gYSBmaW5pdGUgdGltZXIgZm9yIGVhY2ggY2xpY2ssIG9ubHkgaWYgdGhlcmUgaXMgbm8gY3VycmVudGx5IGFjdGl2ZSB0aW1lcjwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmV4aGF1c3RNYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsID9pbmRleDogbnVtYmVyKTogT2JzZXJ2YWJsZUlucHV0fSBwcm9qZWN0IEEgZnVuY3Rpb25cbiAqIHRoYXQsIHdoZW4gYXBwbGllZCB0byBhbiBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCByZXR1cm5zIGFuXG4gKiBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgY29udGFpbmluZyBwcm9qZWN0ZWQgT2JzZXJ2YWJsZXNcbiAqIG9mIGVhY2ggaXRlbSBvZiB0aGUgc291cmNlLCBpZ25vcmluZyBwcm9qZWN0ZWQgT2JzZXJ2YWJsZXMgdGhhdCBzdGFydCBiZWZvcmVcbiAqIHRoZWlyIHByZWNlZGluZyBPYnNlcnZhYmxlIGhhcyBjb21wbGV0ZWQuXG4gKiBAbWV0aG9kIGV4aGF1c3RNYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGV4aGF1c3RNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSk7XG59XG5leHBvcnRzLmV4aGF1c3RNYXAgPSBleGhhdXN0TWFwO1xudmFyIFN3aXRjaEZpcnN0TWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaEZpcnN0TWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgIH1cbiAgICBTd2l0Y2hGaXJzdE1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy5yZXN1bHRTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaEZpcnN0TWFwT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCByZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5oYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgfVxuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy50cnlOZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlOZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgICAgdmFyIGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0LCB2YWx1ZSwgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hGaXJzdE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXRoaXMuaGFzU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAocmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudHJ5U2VsZWN0UmVzdWx0KG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS50cnlTZWxlY3RSZXN1bHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByZXN1bHRTZWxlY3RvciA9IF9hLnJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9O1xuICAgIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgICB0aGlzLmhhc1N1YnNjcmlwdGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGhhdXN0TWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogRmlsdGVyIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IG9ubHkgZW1pdHRpbmcgdGhvc2UgdGhhdFxuICogc2F0aXNmeSBhIHNwZWNpZmllZCBwcmVkaWNhdGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxpa2VcbiAqIFtBcnJheS5wcm90b3R5cGUuZmlsdGVyKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbHRlciksXG4gKiBpdCBvbmx5IGVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIGlmIGl0IHBhc3NlcyBhIGNyaXRlcmlvbiBmdW5jdGlvbi48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9maWx0ZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogU2ltaWxhciB0byB0aGUgd2VsbC1rbm93biBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kLCB0aGlzIG9wZXJhdG9yXG4gKiB0YWtlcyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHBhc3NlcyB0aGVtIHRocm91Z2ggYSBgcHJlZGljYXRlYFxuICogZnVuY3Rpb24gYW5kIG9ubHkgZW1pdHMgdGhvc2UgdmFsdWVzIHRoYXQgeWllbGRlZCBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBvbmx5IGNsaWNrIGV2ZW50cyB3aG9zZSB0YXJnZXQgd2FzIGEgRElWIGVsZW1lbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGNsaWNrc09uRGl2cyA9IGNsaWNrcy5maWx0ZXIoZXYgPT4gZXYudGFyZ2V0LnRhZ05hbWUgPT09ICdESVYnKTtcbiAqIGNsaWNrc09uRGl2cy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZGlzdGluY3R9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsQ2hhbmdlZH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkfVxuICogQHNlZSB7QGxpbmsgaWdub3JlRWxlbWVudHN9XG4gKiBAc2VlIHtAbGluayBwYXJ0aXRpb259XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBib29sZWFufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0aGF0XG4gKiBldmFsdWF0ZXMgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgaXQgcmV0dXJucyBgdHJ1ZWAsXG4gKiB0aGUgdmFsdWUgaXMgZW1pdHRlZCwgaWYgYGZhbHNlYCB0aGUgdmFsdWUgaXMgbm90IHBhc3NlZCB0byB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLiBUaGUgYGluZGV4YCBwYXJhbWV0ZXIgaXMgdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIHNvdXJjZVxuICogZW1pc3Npb24gdGhhdCBoYXMgaGFwcGVuZWQgc2luY2UgdGhlIHN1YnNjcmlwdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgbnVtYmVyXG4gKiBgMGAuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgYHRoaXNgXG4gKiBpbiB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgdGhhdCB3ZXJlXG4gKiBhbGxvd2VkIGJ5IHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgZmlsdGVyXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRmlsdGVyT3BlcmF0b3IocHJlZGljYXRlLCB0aGlzQXJnKSk7XG59XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbnZhciBGaWx0ZXJPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmlsdGVyT3BlcmF0b3IocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgIH1cbiAgICBGaWx0ZXJPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpbHRlclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMudGhpc0FyZykpO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlck9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRmlsdGVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbHRlclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmlsdGVyU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB9XG4gICAgLy8gdGhlIHRyeSBjYXRjaCBibG9jayBiZWxvdyBpcyBsZWZ0IHNwZWNpZmljYWxseSBmb3JcbiAgICAvLyBvcHRpbWl6YXRpb24gYW5kIHBlcmYgcmVhc29ucy4gYSB0cnlDYXRjaGVyIGlzIG5vdCBuZWNlc3NhcnkgaGVyZS5cbiAgICBGaWx0ZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmNvdW50KyspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRmlsdGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgYnV0IHdpbGwgY2FsbCBhIHNwZWNpZmllZCBmdW5jdGlvbiB3aGVuXG4gKiB0aGUgc291cmNlIHRlcm1pbmF0ZXMgb24gY29tcGxldGUgb3IgZXJyb3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBzb3VyY2UgdGVybWluYXRlcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBzb3VyY2UsIGJ1dCB3aWxsIGNhbGwgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiBvbiB0ZXJtaW5hdGlvbi5cbiAqIEBtZXRob2QgZmluYWxseVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gX2ZpbmFsbHkoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBGaW5hbGx5T3BlcmF0b3IoY2FsbGJhY2spKTtcbn1cbmV4cG9ydHMuX2ZpbmFsbHkgPSBfZmluYWxseTtcbnZhciBGaW5hbGx5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbmFsbHlPcGVyYXRvcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIEZpbmFsbHlPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpbmFsbHlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2FsbGJhY2spKTtcbiAgICB9O1xuICAgIHJldHVybiBGaW5hbGx5T3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBGaW5hbGx5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbmFsbHlTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpbmFsbHlTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuYWRkKG5ldyBTdWJzY3JpcHRpb25fMS5TdWJzY3JpcHRpb24oY2FsbGJhY2spKTtcbiAgICB9XG4gICAgcmV0dXJuIEZpbmFsbHlTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmluYWxseS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qKlxuICogQXBwbGllcyBhIGdpdmVuIGBwcm9qZWN0YCBmdW5jdGlvbiB0byBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSwgYW5kIGVtaXRzIHRoZSByZXN1bHRpbmcgdmFsdWVzIGFzIGFuIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxpa2UgW0FycmF5LnByb3RvdHlwZS5tYXAoKV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvbWFwKSxcbiAqIGl0IHBhc3NlcyBlYWNoIHNvdXJjZSB2YWx1ZSB0aHJvdWdoIGEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24gdG8gZ2V0XG4gKiBjb3JyZXNwb25kaW5nIG91dHB1dCB2YWx1ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFNpbWlsYXIgdG8gdGhlIHdlbGwga25vd24gYEFycmF5LnByb3RvdHlwZS5tYXBgIGZ1bmN0aW9uLCB0aGlzIG9wZXJhdG9yXG4gKiBhcHBsaWVzIGEgcHJvamVjdGlvbiB0byBlYWNoIHZhbHVlIGFuZCBlbWl0cyB0aGF0IHByb2plY3Rpb24gaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgZXZlcnkgZXZlcnkgY2xpY2sgdG8gdGhlIGNsaWVudFggcG9zaXRpb24gb2YgdGhhdCBjbGljazwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcG9zaXRpb25zID0gY2xpY2tzLm1hcChldiA9PiBldi5jbGllbnRYKTtcbiAqIHBvc2l0aW9ucy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwVG99XG4gKiBAc2VlIHtAbGluayBwbHVja31cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogUn0gcHJvamVjdCBUaGUgZnVuY3Rpb24gdG8gYXBwbHlcbiAqIHRvIGVhY2ggYHZhbHVlYCBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gVGhlIGBpbmRleGAgcGFyYW1ldGVyIGlzXG4gKiB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggZW1pc3Npb24gdGhhdCBoYXMgaGFwcGVuZWQgc2luY2UgdGhlXG4gKiBzdWJzY3JpcHRpb24sIHN0YXJ0aW5nIGZyb20gdGhlIG51bWJlciBgMGAuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRlZmluZSB3aGF0IGB0aGlzYCBpcyBpbiB0aGVcbiAqIGBwcm9qZWN0YCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSB0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gYHByb2plY3RgIGZ1bmN0aW9uLlxuICogQG1ldGhvZCBtYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1hcChwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9qZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IGlzIG5vdCBhIGZ1bmN0aW9uLiBBcmUgeW91IGxvb2tpbmcgZm9yIGBtYXBUbygpYD8nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgTWFwT3BlcmF0b3IocHJvamVjdCwgdGhpc0FyZykpO1xufVxuZXhwb3J0cy5tYXAgPSBtYXA7XG52YXIgTWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hcE9wZXJhdG9yKHByb2plY3QsIHRoaXNBcmcpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICB9XG4gICAgTWFwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy50aGlzQXJnKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NYXBPcGVyYXRvciA9IE1hcE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNYXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWFwU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmcgfHwgdGhpcztcbiAgICB9XG4gICAgLy8gTk9URTogVGhpcyBsb29rcyB1bm9wdGltaXplZCwgYnV0IGl0J3MgYWN0dWFsbHkgcHVycG9zZWZ1bGx5IE5PVFxuICAgIC8vIHVzaW5nIHRyeS9jYXRjaCBvcHRpbWl6YXRpb25zLlxuICAgIE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmNvdW50KyspO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIHJldHVybiBNYXBTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlIGludG8gYSBmaXJzdC1vcmRlciBPYnNlcnZhYmxlIHdoaWNoXG4gKiBjb25jdXJyZW50bHkgZGVsaXZlcnMgYWxsIHZhbHVlcyB0aGF0IGFyZSBlbWl0dGVkIG9uIHRoZSBpbm5lciBPYnNlcnZhYmxlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgYW4gT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tZXJnZUFsbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgbWVyZ2VBbGxgIHN1YnNjcmliZXMgdG8gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIE9ic2VydmFibGVzLCBhbHNvIGtub3duIGFzXG4gKiBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlLiBFYWNoIHRpbWUgaXQgb2JzZXJ2ZXMgb25lIG9mIHRoZXNlIGVtaXR0ZWQgaW5uZXJcbiAqIE9ic2VydmFibGVzLCBpdCBzdWJzY3JpYmVzIHRvIHRoYXQgYW5kIGRlbGl2ZXJzIGFsbCB0aGUgdmFsdWVzIGZyb20gdGhlXG4gKiBpbm5lciBPYnNlcnZhYmxlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIG9ubHlcbiAqIGNvbXBsZXRlcyBvbmNlIGFsbCBpbm5lciBPYnNlcnZhYmxlcyBoYXZlIGNvbXBsZXRlZC4gQW55IGVycm9yIGRlbGl2ZXJlZCBieVxuICogYSBpbm5lciBPYnNlcnZhYmxlIHdpbGwgYmUgaW1tZWRpYXRlbHkgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+U3Bhd24gYSBuZXcgaW50ZXJ2YWwgT2JzZXJ2YWJsZSBmb3IgZWFjaCBjbGljayBldmVudCwgYW5kIGJsZW5kIHRoZWlyIG91dHB1dHMgYXMgb25lIE9ic2VydmFibGU8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGhpZ2hlck9yZGVyID0gY2xpY2tzLm1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogdmFyIGZpcnN0T3JkZXIgPSBoaWdoZXJPcmRlci5tZXJnZUFsbCgpO1xuICogZmlyc3RPcmRlci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q291bnQgZnJvbSAwIHRvIDkgZXZlcnkgc2Vjb25kIGZvciBlYWNoIGNsaWNrLCBidXQgb25seSBhbGxvdyAyIGNvbmN1cnJlbnQgdGltZXJzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApKTtcbiAqIHZhciBmaXJzdE9yZGVyID0gaGlnaGVyT3JkZXIubWVyZ2VBbGwoMik7XG4gKiBmaXJzdE9yZGVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lQWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgZXhoYXVzdH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcFRvfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICogQHNlZSB7QGxpbmsgc3dpdGNofVxuICogQHNlZSB7QGxpbmsgemlwQWxsfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlubmVyXG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB2YWx1ZXMgY29taW5nIGZyb20gYWxsIHRoZVxuICogaW5uZXIgT2JzZXJ2YWJsZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIG1lcmdlQWxsXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtZXJnZUFsbChjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgTWVyZ2VBbGxPcGVyYXRvcihjb25jdXJyZW50KSk7XG59XG5leHBvcnRzLm1lcmdlQWxsID0gbWVyZ2VBbGw7XG52YXIgTWVyZ2VBbGxPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVyZ2VBbGxPcGVyYXRvcihjb25jdXJyZW50KSB7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgfVxuICAgIE1lcmdlQWxsT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VBbGxTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLmNvbmN1cnJlbnQpKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXJnZUFsbE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWVyZ2VBbGxPcGVyYXRvciA9IE1lcmdlQWxsT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIE1lcmdlQWxsU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lcmdlQWxsU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXJnZUFsbFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbmN1cnJlbnQpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgfVxuICAgIE1lcmdlQWxsU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPCB0aGlzLmNvbmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG9ic2VydmFibGUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2gob2JzZXJ2YWJsZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlQWxsU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VBbGxTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0KGJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VBbGxTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbmV4cG9ydHMuTWVyZ2VBbGxTdWJzY3JpYmVyID0gTWVyZ2VBbGxTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VBbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBQcm9qZWN0cyBlYWNoIHNvdXJjZSB2YWx1ZSB0byBhbiBPYnNlcnZhYmxlIHdoaWNoIGlzIG1lcmdlZCBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5NYXBzIGVhY2ggdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSwgdGhlbiBmbGF0dGVucyBhbGwgb2ZcbiAqIHRoZXNlIGlubmVyIE9ic2VydmFibGVzIHVzaW5nIHtAbGluayBtZXJnZUFsbH0uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2VNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiBPYnNlcnZhYmxlLCBhbmQgdGhlbiBtZXJnaW5nIHRob3NlIHJlc3VsdGluZyBPYnNlcnZhYmxlcyBhbmRcbiAqIGVtaXR0aW5nIHRoZSByZXN1bHRzIG9mIHRoaXMgbWVyZ2VyLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBhbmQgZmxhdHRlbiBlYWNoIGxldHRlciB0byBhbiBPYnNlcnZhYmxlIHRpY2tpbmcgZXZlcnkgMSBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgbGV0dGVycyA9IFJ4Lk9ic2VydmFibGUub2YoJ2EnLCAnYicsICdjJyk7XG4gKiB2YXIgcmVzdWx0ID0gbGV0dGVycy5tZXJnZU1hcCh4ID0+XG4gKiAgIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkubWFwKGkgPT4geCtpKVxuICogKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gYTBcbiAqIC8vIGIwXG4gKiAvLyBjMFxuICogLy8gYTFcbiAqIC8vIGIxXG4gKiAvLyBjMVxuICogLy8gY29udGludWVzIHRvIGxpc3QgYSxiLGMgd2l0aCByZXNwZWN0aXZlIGFzY2VuZGluZyBpbnRlZ2Vyc1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3RNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZX1cbiAqIEBzZWUge0BsaW5rIG1lcmdlQWxsfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbnB1dFxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgbWVyZ2luZyB0aGUgcmVzdWx0cyBvZiB0aGUgT2JzZXJ2YWJsZXMgb2J0YWluZWRcbiAqIGZyb20gdGhpcyB0cmFuc2Zvcm1hdGlvbi5cbiAqIEBtZXRob2QgbWVyZ2VNYXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTWFwKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHRTZWxlY3RvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uY3VycmVudCA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICByZXN1bHRTZWxlY3RvciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1lcmdlTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpKTtcbn1cbmV4cG9ydHMubWVyZ2VNYXAgPSBtZXJnZU1hcDtcbnZhciBNZXJnZU1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXJnZU1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSB7XG4gICAgICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuY29uY3VycmVudCA9IGNvbmN1cnJlbnQ7XG4gICAgfVxuICAgIE1lcmdlTWFwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAob2JzZXJ2ZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VNYXBTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnByb2plY3QsIHRoaXMucmVzdWx0U2VsZWN0b3IsIHRoaXMuY29uY3VycmVudCkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlTWFwT3BlcmF0b3I7XG59KCkpO1xuZXhwb3J0cy5NZXJnZU1hcE9wZXJhdG9yID0gTWVyZ2VNYXBPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWVyZ2VNYXBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVyZ2VNYXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lcmdlTWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgcmVzdWx0U2VsZWN0b3IsIGNvbmN1cnJlbnQpIHtcbiAgICAgICAgaWYgKGNvbmN1cnJlbnQgPT09IHZvaWQgMCkgeyBjb25jdXJyZW50ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICAgICAgdGhpcy5yZXN1bHRTZWxlY3RvciA9IHJlc3VsdFNlbGVjdG9yO1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA8IHRoaXMuY29uY3VycmVudCkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5TmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5TmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgICAgdGhpcy5faW5uZXJTdWIocmVzdWx0LCB2YWx1ZSwgaW5kZXgpO1xuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5faW5uZXJTdWIgPSBmdW5jdGlvbiAoaXNoLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBpc2gsIHZhbHVlLCBpbmRleCkpO1xuICAgIH07XG4gICAgTWVyZ2VNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeVJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZU1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9ub3RpZnlSZXN1bHRTZWxlY3RvciA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgICB9O1xuICAgIE1lcmdlTWFwU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlTWFwU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnRzLk1lcmdlTWFwU3Vic2NyaWJlciA9IE1lcmdlTWFwU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlTWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIENvbm5lY3RhYmxlT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9Db25uZWN0YWJsZU9ic2VydmFibGUnKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHRzIG9mIGludm9raW5nIGEgc3BlY2lmaWVkIHNlbGVjdG9yIG9uIGl0ZW1zXG4gKiBlbWl0dGVkIGJ5IGEgQ29ubmVjdGFibGVPYnNlcnZhYmxlIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0byB0aGUgdW5kZXJseWluZyBzdHJlYW0uXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tdWx0aWNhc3QucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxTdWJqZWN0fSBzdWJqZWN0T3JTdWJqZWN0RmFjdG9yeSAtIEZhY3RvcnkgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIGludGVybWVkaWF0ZSBzdWJqZWN0IHRocm91Z2hcbiAqIHdoaWNoIHRoZSBzb3VyY2Ugc2VxdWVuY2UncyBlbGVtZW50cyB3aWxsIGJlIG11bHRpY2FzdCB0byB0aGUgc2VsZWN0b3IgZnVuY3Rpb25cbiAqIG9yIFN1YmplY3QgdG8gcHVzaCBzb3VyY2UgZWxlbWVudHMgaW50by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gLSBPcHRpb25hbCBzZWxlY3RvciBmdW5jdGlvbiB0aGF0IGNhbiB1c2UgdGhlIG11bHRpY2FzdGVkIHNvdXJjZSBzdHJlYW1cbiAqIGFzIG1hbnkgdGltZXMgYXMgbmVlZGVkLCB3aXRob3V0IGNhdXNpbmcgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHN0cmVhbS5cbiAqIFN1YnNjcmliZXJzIHRvIHRoZSBnaXZlbiBzb3VyY2Ugd2lsbCByZWNlaXZlIGFsbCBub3RpZmljYXRpb25zIG9mIHRoZSBzb3VyY2UgZnJvbSB0aGVcbiAqIHRpbWUgb2YgdGhlIHN1YnNjcmlwdGlvbiBmb3J3YXJkLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHRzIG9mIGludm9raW5nIHRoZSBzZWxlY3RvclxuICogb24gdGhlIGl0ZW1zIGVtaXR0ZWQgYnkgYSBgQ29ubmVjdGFibGVPYnNlcnZhYmxlYCB0aGF0IHNoYXJlcyBhIHNpbmdsZSBzdWJzY3JpcHRpb24gdG9cbiAqIHRoZSB1bmRlcmx5aW5nIHN0cmVhbS5cbiAqIEBtZXRob2QgbXVsdGljYXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtdWx0aWNhc3Qoc3ViamVjdE9yU3ViamVjdEZhY3RvcnksIHNlbGVjdG9yKSB7XG4gICAgdmFyIHN1YmplY3RGYWN0b3J5O1xuICAgIGlmICh0eXBlb2Ygc3ViamVjdE9yU3ViamVjdEZhY3RvcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3ViamVjdEZhY3RvcnkgPSBzdWJqZWN0T3JTdWJqZWN0RmFjdG9yeTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN1YmplY3RGYWN0b3J5ID0gZnVuY3Rpb24gc3ViamVjdEZhY3RvcnkoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ViamVjdE9yU3ViamVjdEZhY3Rvcnk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlmdChuZXcgTXVsdGljYXN0T3BlcmF0b3Ioc3ViamVjdEZhY3RvcnksIHNlbGVjdG9yKSk7XG4gICAgfVxuICAgIHZhciBjb25uZWN0YWJsZSA9IE9iamVjdC5jcmVhdGUodGhpcywgQ29ubmVjdGFibGVPYnNlcnZhYmxlXzEuY29ubmVjdGFibGVPYnNlcnZhYmxlRGVzY3JpcHRvcik7XG4gICAgY29ubmVjdGFibGUuc291cmNlID0gdGhpcztcbiAgICBjb25uZWN0YWJsZS5zdWJqZWN0RmFjdG9yeSA9IHN1YmplY3RGYWN0b3J5O1xuICAgIHJldHVybiBjb25uZWN0YWJsZTtcbn1cbmV4cG9ydHMubXVsdGljYXN0ID0gbXVsdGljYXN0O1xudmFyIE11bHRpY2FzdE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNdWx0aWNhc3RPcGVyYXRvcihzdWJqZWN0RmFjdG9yeSwgc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5zdWJqZWN0RmFjdG9yeSA9IHN1YmplY3RGYWN0b3J5O1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgfVxuICAgIE11bHRpY2FzdE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuc3ViamVjdEZhY3RvcnkoKTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNlbGVjdG9yKHN1YmplY3QpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChzb3VyY2Uuc3Vic2NyaWJlKHN1YmplY3QpKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBNdWx0aWNhc3RPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk11bHRpY2FzdE9wZXJhdG9yID0gTXVsdGljYXN0T3BlcmF0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tdWx0aWNhc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEdyb3VwcyBwYWlycyBvZiBjb25zZWN1dGl2ZSBlbWlzc2lvbnMgdG9nZXRoZXIgYW5kIGVtaXRzIHRoZW0gYXMgYW4gYXJyYXkgb2ZcbiAqIHR3byB2YWx1ZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlB1dHMgdGhlIGN1cnJlbnQgdmFsdWUgYW5kIHByZXZpb3VzIHZhbHVlIHRvZ2V0aGVyIGFzXG4gKiBhbiBhcnJheSwgYW5kIGVtaXRzIHRoYXQuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcGFpcndpc2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogVGhlIE50aCBlbWlzc2lvbiBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aWxsIGNhdXNlIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZVxuICogdG8gZW1pdCBhbiBhcnJheSBbKE4tMSl0aCwgTnRoXSBvZiB0aGUgcHJldmlvdXMgYW5kIHRoZSBjdXJyZW50IHZhbHVlLCBhcyBhXG4gKiBwYWlyLiBGb3IgdGhpcyByZWFzb24sIGBwYWlyd2lzZWAgZW1pdHMgb24gdGhlIHNlY29uZCBhbmQgc3Vic2VxdWVudFxuICogZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgbm90IG9uIHRoZSBmaXJzdCBlbWlzc2lvbiwgYmVjYXVzZVxuICogdGhlcmUgaXMgbm8gcHJldmlvdXMgdmFsdWUgaW4gdGhhdCBjYXNlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk9uIGV2ZXJ5IGNsaWNrIChzdGFydGluZyBmcm9tIHRoZSBzZWNvbmQpLCBlbWl0IHRoZSByZWxhdGl2ZSBkaXN0YW5jZSB0byB0aGUgcHJldmlvdXMgY2xpY2s8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHBhaXJzID0gY2xpY2tzLnBhaXJ3aXNlKCk7XG4gKiB2YXIgZGlzdGFuY2UgPSBwYWlycy5tYXAocGFpciA9PiB7XG4gKiAgIHZhciB4MCA9IHBhaXJbMF0uY2xpZW50WDtcbiAqICAgdmFyIHkwID0gcGFpclswXS5jbGllbnRZO1xuICogICB2YXIgeDEgPSBwYWlyWzFdLmNsaWVudFg7XG4gKiAgIHZhciB5MSA9IHBhaXJbMV0uY2xpZW50WTtcbiAqICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4MCAtIHgxLCAyKSArIE1hdGgucG93KHkwIC0geTEsIDIpKTtcbiAqIH0pO1xuICogZGlzdGFuY2Uuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGU8QXJyYXk8VD4+fSBBbiBPYnNlcnZhYmxlIG9mIHBhaXJzIChhcyBhcnJheXMpIG9mXG4gKiBjb25zZWN1dGl2ZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHBhaXJ3aXNlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBwYWlyd2lzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBQYWlyd2lzZU9wZXJhdG9yKCkpO1xufVxuZXhwb3J0cy5wYWlyd2lzZSA9IHBhaXJ3aXNlO1xudmFyIFBhaXJ3aXNlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhaXJ3aXNlT3BlcmF0b3IoKSB7XG4gICAgfVxuICAgIFBhaXJ3aXNlT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBQYWlyd2lzZVN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhaXJ3aXNlT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBQYWlyd2lzZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYWlyd2lzZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFpcndpc2VTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5oYXNQcmV2ID0gZmFsc2U7XG4gICAgfVxuICAgIFBhaXJ3aXNlU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUHJldikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KFt0aGlzLnByZXYsIHZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc1ByZXYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldiA9IHZhbHVlO1xuICAgIH07XG4gICAgcmV0dXJuIFBhaXJ3aXNlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhaXJ3aXNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIG11bHRpY2FzdF8xID0gcmVxdWlyZSgnLi9tdWx0aWNhc3QnKTtcbnZhciBTdWJqZWN0XzEgPSByZXF1aXJlKCcuLi9TdWJqZWN0Jyk7XG5mdW5jdGlvbiBzaGFyZVN1YmplY3RGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgU3ViamVjdF8xLlN1YmplY3QoKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIG5ldyBPYnNlcnZhYmxlIHRoYXQgbXVsdGljYXN0cyAoc2hhcmVzKSB0aGUgb3JpZ2luYWwgT2JzZXJ2YWJsZS4gQXMgbG9uZyBhcyB0aGVyZSBpcyBhdCBsZWFzdCBvbmVcbiAqIFN1YnNjcmliZXIgdGhpcyBPYnNlcnZhYmxlIHdpbGwgYmUgc3Vic2NyaWJlZCBhbmQgZW1pdHRpbmcgZGF0YS4gV2hlbiBhbGwgc3Vic2NyaWJlcnMgaGF2ZSB1bnN1YnNjcmliZWQgaXQgd2lsbFxuICogdW5zdWJzY3JpYmUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuIEJlY2F1c2UgdGhlIE9ic2VydmFibGUgaXMgbXVsdGljYXN0aW5nIGl0IG1ha2VzIHRoZSBzdHJlYW0gYGhvdGAuXG4gKiBUaGlzIGlzIGFuIGFsaWFzIGZvciAucHVibGlzaCgpLnJlZkNvdW50KCkuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zaGFyZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgdXBvbiBjb25uZWN0aW9uIGNhdXNlcyB0aGUgc291cmNlIE9ic2VydmFibGUgdG8gZW1pdCBpdGVtcyB0byBpdHMgT2JzZXJ2ZXJzLlxuICogQG1ldGhvZCBzaGFyZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gc2hhcmUoKSB7XG4gICAgcmV0dXJuIG11bHRpY2FzdF8xLm11bHRpY2FzdC5jYWxsKHRoaXMsIHNoYXJlU3ViamVjdEZhY3RvcnkpLnJlZkNvdW50KCk7XG59XG5leHBvcnRzLnNoYXJlID0gc2hhcmU7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBBcnJheU9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJyk7XG52YXIgU2NhbGFyT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9TY2FsYXJPYnNlcnZhYmxlJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZScpO1xudmFyIGNvbmNhdF8xID0gcmVxdWlyZSgnLi9jb25jYXQnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGl0ZW1zIHlvdSBzcGVjaWZ5IGFzIGFyZ3VtZW50cyBiZWZvcmUgaXQgYmVnaW5zIHRvIGVtaXRcbiAqIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc3RhcnRXaXRoLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7Li4uVH0gdmFsdWVzIC0gSXRlbXMgeW91IHdhbnQgdGhlIG1vZGlmaWVkIE9ic2VydmFibGUgdG8gZW1pdCBmaXJzdC5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSAtIEEge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICogdGhlIGVtaXNzaW9ucyBvZiB0aGUgYG5leHRgIG5vdGlmaWNhdGlvbnMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGl0ZW1zIGluIHRoZSBzcGVjaWZpZWQgSXRlcmFibGUgYW5kIHRoZW4gZW1pdHMgdGhlIGl0ZW1zXG4gKiBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3RhcnRXaXRoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzdGFydFdpdGgoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJyYXlbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBzY2hlZHVsZXIgPSBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICBpZiAoaXNTY2hlZHVsZXJfMS5pc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICAgIGFycmF5LnBvcCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2NoZWR1bGVyID0gbnVsbDtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjb25jYXRfMS5jb25jYXRTdGF0aWMobmV3IFNjYWxhck9ic2VydmFibGVfMS5TY2FsYXJPYnNlcnZhYmxlKGFycmF5WzBdLCBzY2hlZHVsZXIpLCB0aGlzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobGVuID4gMSkge1xuICAgICAgICByZXR1cm4gY29uY2F0XzEuY29uY2F0U3RhdGljKG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlciksIHRoaXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdF8xLmNvbmNhdFN0YXRpYyhuZXcgRW1wdHlPYnNlcnZhYmxlXzEuRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlciksIHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuc3RhcnRXaXRoID0gc3RhcnRXaXRoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhcnRXaXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSwgZW1pdHRpbmcgdmFsdWVzIG9ubHkgZnJvbSB0aGUgbW9zdCByZWNlbnRseSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgc3dpdGNofS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zd2l0Y2hNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiAoc28tY2FsbGVkIFwiaW5uZXJcIikgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZVxuICogaW5uZXIgT2JzZXJ2YWJsZXMsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnlcbiAqIHRoYXQgaW5uZXIgT2JzZXJ2YWJsZS4gV2hlbiBhIG5ldyBpbm5lciBPYnNlcnZhYmxlIGlzIGVtaXR0ZWQsIGBzd2l0Y2hNYXBgXG4gKiBzdG9wcyBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBlYXJsaWVyLWVtaXR0ZWQgaW5uZXIgT2JzZXJ2YWJsZSBhbmQgYmVnaW5zXG4gKiBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBuZXcgb25lLiBJdCBjb250aW51ZXMgdG8gYmVoYXZlIGxpa2UgdGhpcyBmb3JcbiAqIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnN3aXRjaE1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgdGFraW5nIG9ubHkgdGhlIHZhbHVlcyBmcm9tIHRoZSBtb3N0IHJlY2VudGx5XG4gKiBwcm9qZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoTWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzd2l0Y2hNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTd2l0Y2hNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvcikpO1xufVxuZXhwb3J0cy5zd2l0Y2hNYXAgPSBzd2l0Y2hNYXA7XG52YXIgU3dpdGNoTWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9XG4gICAgU3dpdGNoTWFwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hNYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy5yZXN1bHRTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaE1hcE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3dpdGNoTWFwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN3aXRjaE1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoTWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lubmVyU3ViKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9pbm5lclN1YiA9IGZ1bmN0aW9uIChyZXN1bHQsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSB0aGlzLmlubmVyU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoaW5uZXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGlubmVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGQodGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0LCB2YWx1ZSwgaW5kZXgpKTtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKCFpbm5lclN1YnNjcmlwdGlvbiB8fCBpbm5lclN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeU5vdGlmeU5leHQob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOb3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaE1hcFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoTWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyoqXG4gKiBFbWl0cyB0aGUgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHVudGlsIGEgYG5vdGlmaWVyYFxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MZXRzIHZhbHVlcyBwYXNzIHVudGlsIGEgc2Vjb25kIE9ic2VydmFibGUsXG4gKiBgbm90aWZpZXJgLCBlbWl0cyBzb21ldGhpbmcuIFRoZW4sIGl0IGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlVW50aWwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRha2VVbnRpbGAgc3Vic2NyaWJlcyBhbmQgYmVnaW5zIG1pcnJvcmluZyB0aGUgc291cmNlIE9ic2VydmFibGUuIEl0IGFsc29cbiAqIG1vbml0b3JzIGEgc2Vjb25kIE9ic2VydmFibGUsIGBub3RpZmllcmAgdGhhdCB5b3UgcHJvdmlkZS4gSWYgdGhlIGBub3RpZmllcmBcbiAqIGVtaXRzIGEgdmFsdWUgb3IgYSBjb21wbGV0ZSBub3RpZmljYXRpb24sIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBzdG9wc1xuICogbWlycm9yaW5nIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgY29tcGxldGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRpY2sgZXZlcnkgc2Vjb25kIHVudGlsIHRoZSBmaXJzdCBjbGljayBoYXBwZW5zPC9jYXB0aW9uPlxuICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gaW50ZXJ2YWwudGFrZVVudGlsKGNsaWNrcyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqIEBzZWUge0BsaW5rIHRha2VXaGlsZX1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBub3RpZmllciBUaGUgT2JzZXJ2YWJsZSB3aG9zZSBmaXJzdCBlbWl0dGVkIHZhbHVlIHdpbGxcbiAqIGNhdXNlIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvZiBgdGFrZVVudGlsYCB0byBzdG9wIGVtaXR0aW5nIHZhbHVlcyBmcm9tIHRoZVxuICogc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgdW50aWwgc3VjaCB0aW1lIGFzIGBub3RpZmllcmAgZW1pdHMgaXRzIGZpcnN0IHZhbHVlLlxuICogQG1ldGhvZCB0YWtlVW50aWxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRha2VVbnRpbChub3RpZmllcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFRha2VVbnRpbE9wZXJhdG9yKG5vdGlmaWVyKSk7XG59XG5leHBvcnRzLnRha2VVbnRpbCA9IHRha2VVbnRpbDtcbnZhciBUYWtlVW50aWxPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGFrZVVudGlsT3BlcmF0b3Iobm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5vdGlmaWVyO1xuICAgIH1cbiAgICBUYWtlVW50aWxPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRha2VVbnRpbFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5ub3RpZmllcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VVbnRpbE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgVGFrZVVudGlsU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRha2VVbnRpbFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFrZVVudGlsU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgbm90aWZpZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgbm90aWZpZXIpKTtcbiAgICB9XG4gICAgVGFrZVVudGlsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgfTtcbiAgICBUYWtlVW50aWxTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH07XG4gICAgcmV0dXJuIFRha2VVbnRpbFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFrZVVudGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIGlzQXJyYXlfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNBcnJheScpO1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoJy4uL3N5bWJvbC9pdGVyYXRvcicpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQHBhcmFtIG9ic2VydmFibGVzXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fVxuICogQG1ldGhvZCB6aXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHppcFByb3RvKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5saWZ0LmNhbGwoemlwU3RhdGljLmFwcGx5KHZvaWQgMCwgW3RoaXNdLmNvbmNhdChvYnNlcnZhYmxlcykpKTtcbn1cbmV4cG9ydHMuemlwUHJvdG8gPSB6aXBQcm90bztcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvIGNyZWF0ZSBhbiBPYnNlcnZhYmxlIHdob3NlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiBlYWNoXG4gKiBvZiBpdHMgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKlxuICogSWYgdGhlIGxhdGVzdCBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiwgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlIGNyZWF0ZWQgdmFsdWUgZnJvbSB0aGUgaW5wdXQgdmFsdWVzLlxuICogT3RoZXJ3aXNlLCBhbiBhcnJheSBvZiB0aGUgaW5wdXQgdmFsdWVzIGlzIHJldHVybmVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbWJpbmUgYWdlIGFuZCBuYW1lIGZyb20gZGlmZmVyZW50IHNvdXJjZXM8L2NhcHRpb24+XG4gKlxuICogbGV0IGFnZSQgPSBPYnNlcnZhYmxlLm9mPG51bWJlcj4oMjcsIDI1LCAyOSk7XG4gKiBsZXQgbmFtZSQgPSBPYnNlcnZhYmxlLm9mPHN0cmluZz4oJ0ZvbycsICdCYXInLCAnQmVlcicpO1xuICogbGV0IGlzRGV2JCA9IE9ic2VydmFibGUub2Y8Ym9vbGVhbj4odHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICpcbiAqIE9ic2VydmFibGVcbiAqICAgICAuemlwKGFnZSQsXG4gKiAgICAgICAgICBuYW1lJCxcbiAqICAgICAgICAgIGlzRGV2JCxcbiAqICAgICAgICAgIChhZ2U6IG51bWJlciwgbmFtZTogc3RyaW5nLCBpc0RldjogYm9vbGVhbikgPT4gKHsgYWdlLCBuYW1lLCBpc0RldiB9KSlcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIG91dHB1dHNcbiAqIC8vIHsgYWdlOiAyNywgbmFtZTogJ0ZvbycsIGlzRGV2OiB0cnVlIH1cbiAqIC8vIHsgYWdlOiAyNSwgbmFtZTogJ0JhcicsIGlzRGV2OiB0cnVlIH1cbiAqIC8vIHsgYWdlOiAyOSwgbmFtZTogJ0JlZXInLCBpc0RldjogZmFsc2UgfVxuICpcbiAqIEBwYXJhbSBvYnNlcnZhYmxlc1xuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn1cbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgemlwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB6aXBTdGF0aWMoKSB7XG4gICAgdmFyIG9ic2VydmFibGVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgb2JzZXJ2YWJsZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBwcm9qZWN0ID0gb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHR5cGVvZiBwcm9qZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9ic2VydmFibGVzLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZShvYnNlcnZhYmxlcykubGlmdChuZXcgWmlwT3BlcmF0b3IocHJvamVjdCkpO1xufVxuZXhwb3J0cy56aXBTdGF0aWMgPSB6aXBTdGF0aWM7XG52YXIgWmlwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFppcE9wZXJhdG9yKHByb2plY3QpIHtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgICB9XG4gICAgWmlwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBaaXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuWmlwT3BlcmF0b3IgPSBaaXBPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgWmlwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFppcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWmlwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkgeyB2YWx1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5pdGVyYXRvcnMgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgICAgICB0aGlzLnByb2plY3QgPSAodHlwZW9mIHByb2plY3QgPT09ICdmdW5jdGlvbicpID8gcHJvamVjdCA6IG51bGw7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgICAgIGlmIChpc0FycmF5XzEuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9ycy5wdXNoKG5ldyBTdGF0aWNBcnJheUl0ZXJhdG9yKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlW2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9ycy5wdXNoKG5ldyBTdGF0aWNJdGVyYXRvcih2YWx1ZVtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdKCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXJhdG9ycy5wdXNoKG5ldyBaaXBCdWZmZXJJdGVyYXRvcih0aGlzLmRlc3RpbmF0aW9uLCB0aGlzLCB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICAgICAgdmFyIGxlbiA9IGl0ZXJhdG9ycy5sZW5ndGg7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gbGVuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvcnNbaV07XG4gICAgICAgICAgICBpZiAoaXRlcmF0b3Iuc3RpbGxVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChpdGVyYXRvci5zdWJzY3JpYmUoaXRlcmF0b3IsIGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlLS07IC8vIG5vdCBhbiBvYnNlcnZhYmxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUluYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZS0tO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuY2hlY2tJdGVyYXRvcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICAgICAgdmFyIGxlbiA9IGl0ZXJhdG9ycy5sZW5ndGg7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIC8vIGFib3J0IGlmIG5vdCBhbGwgb2YgdGhlbSBoYXZlIHZhbHVlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvcnNbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yLmhhc1ZhbHVlID09PSAnZnVuY3Rpb24nICYmICFpdGVyYXRvci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvcnNbaV07XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIGl0J3MgY29tcGxldGVkIG5vdyB0aGF0IHlvdSd2ZSBnb3R0ZW5cbiAgICAgICAgICAgIC8vIHRoZSBuZXh0IHZhbHVlLlxuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmhhc0NvbXBsZXRlZCgpKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLnB1c2gocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9qZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl90cnlQcm9qZWN0KGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkQ29tcGxldGUpIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlQcm9qZWN0ID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvamVjdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gWmlwU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuWmlwU3Vic2NyaWJlciA9IFppcFN1YnNjcmliZXI7XG52YXIgU3RhdGljSXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRpY0l0ZXJhdG9yKGl0ZXJhdG9yKSB7XG4gICAgICAgIHRoaXMuaXRlcmF0b3IgPSBpdGVyYXRvcjtcbiAgICAgICAgdGhpcy5uZXh0UmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgIH1cbiAgICBTdGF0aWNJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgU3RhdGljSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLm5leHRSZXN1bHQ7XG4gICAgICAgIHRoaXMubmV4dFJlc3VsdCA9IHRoaXMuaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgU3RhdGljSXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSZXN1bHQgPSB0aGlzLm5leHRSZXN1bHQ7XG4gICAgICAgIHJldHVybiBuZXh0UmVzdWx0ICYmIG5leHRSZXN1bHQuZG9uZTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0aWNJdGVyYXRvcjtcbn0oKSk7XG52YXIgU3RhdGljQXJyYXlJdGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RhdGljQXJyYXlJdGVyYXRvcihhcnJheSkge1xuICAgICAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIH1cbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZVtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIFN0YXRpY0FycmF5SXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICAgIHJldHVybiBpIDwgdGhpcy5sZW5ndGggPyB7IHZhbHVlOiBhcnJheVtpXSwgZG9uZTogZmFsc2UgfSA6IHsgdmFsdWU6IG51bGwsIGRvbmU6IHRydWUgfTtcbiAgICB9O1xuICAgIFN0YXRpY0FycmF5SXRlcmF0b3IucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggPiB0aGlzLmluZGV4O1xuICAgIH07XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGUuaGFzQ29tcGxldGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggPT09IHRoaXMuaW5kZXg7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljQXJyYXlJdGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFppcEJ1ZmZlckl0ZXJhdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWmlwQnVmZmVySXRlcmF0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWmlwQnVmZmVySXRlcmF0b3IoZGVzdGluYXRpb24sIHBhcmVudCwgb2JzZXJ2YWJsZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLm9ic2VydmFibGUgPSBvYnNlcnZhYmxlO1xuICAgICAgICB0aGlzLnN0aWxsVW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5pc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgfVxuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZVtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIE5PVEU6IHRoZXJlIGlzIGFjdHVhbGx5IGEgbmFtZSBjb2xsaXNpb24gaGVyZSB3aXRoIFN1YnNjcmliZXIubmV4dCBhbmQgSXRlcmF0b3IubmV4dFxuICAgIC8vICAgIHRoaXMgaXMgbGVnaXQgYmVjYXVzZSBgbmV4dCgpYCB3aWxsIG5ldmVyIGJlIGNhbGxlZCBieSBhIHN1YnNjcmlwdGlvbiBpbiB0aGlzIGNhc2UuXG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDAgJiYgdGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGJ1ZmZlci5zaGlmdCgpLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUuaGFzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQ29tcGxldGU7XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5SW5hY3RpdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaChpbm5lclZhbHVlKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hlY2tJdGVyYXRvcnMoKTtcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiAodmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHRoaXMub2JzZXJ2YWJsZSwgdGhpcywgaW5kZXgpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcEJ1ZmZlckl0ZXJhdG9yO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXppcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIEEgdW5pdCBvZiB3b3JrIHRvIGJlIGV4ZWN1dGVkIGluIGEge0BsaW5rIFNjaGVkdWxlcn0uIEFuIGFjdGlvbiBpcyB0eXBpY2FsbHlcbiAqIGNyZWF0ZWQgZnJvbSB3aXRoaW4gYSBTY2hlZHVsZXIgYW5kIGFuIFJ4SlMgdXNlciBkb2VzIG5vdCBuZWVkIHRvIGNvbmNlcm5cbiAqIHRoZW1zZWx2ZXMgYWJvdXQgY3JlYXRpbmcgYW5kIG1hbmlwdWxhdGluZyBhbiBBY3Rpb24uXG4gKlxuICogYGBgdHNcbiAqIGNsYXNzIEFjdGlvbjxUPiBleHRlbmRzIFN1YnNjcmlwdGlvbiB7XG4gKiAgIG5ldyAoc2NoZWR1bGVyOiBTY2hlZHVsZXIsIHdvcms6IChzdGF0ZT86IFQpID0+IHZvaWQpO1xuICogICBzY2hlZHVsZShzdGF0ZT86IFQsIGRlbGF5OiBudW1iZXIgPSAwKTogU3Vic2NyaXB0aW9uO1xuICogfVxuICogYGBgXG4gKlxuICogQGNsYXNzIEFjdGlvbjxUPlxuICovXG52YXIgQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWN0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyB0aGlzIGFjdGlvbiBvbiBpdHMgcGFyZW50IFNjaGVkdWxlciBmb3IgZXhlY3V0aW9uLiBNYXkgYmUgcGFzc2VkXG4gICAgICogc29tZSBjb250ZXh0IG9iamVjdCwgYHN0YXRlYC4gTWF5IGhhcHBlbiBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUsXG4gICAgICogYWNjb3JkaW5nIHRvIHRoZSBgZGVsYXlgIHBhcmFtZXRlciwgaWYgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7VH0gW3N0YXRlXSBTb21lIGNvbnRleHR1YWwgZGF0YSB0aGF0IHRoZSBgd29ya2AgZnVuY3Rpb24gdXNlcyB3aGVuXG4gICAgICogY2FsbGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gVGltZSB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHdvcmssIHdoZXJlIHRoZVxuICAgICAqIHRpbWUgdW5pdCBpcyBpbXBsaWNpdCBhbmQgZGVmaW5lZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIEFjdGlvbjtcbn0oU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uKSk7XG5leHBvcnRzLkFjdGlvbiA9IEFjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIEFjdGlvbl8xID0gcmVxdWlyZSgnLi9BY3Rpb24nKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQXN5bmNBY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc3luY0FjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3luY0FjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgc2NoZWR1bGVyLCB3b3JrKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIHRoaXMud29yayA9IHdvcms7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyByZXBsYWNlIHRoZSBjdXJyZW50IHN0YXRlIHdpdGggdGhlIG5ldyBzdGF0ZS5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAvLyBTZXQgdGhlIHBlbmRpbmcgZmxhZyBpbmRpY2F0aW5nIHRoYXQgdGhpcyBhY3Rpb24gaGFzIGJlZW4gc2NoZWR1bGVkLCBvclxuICAgICAgICAvLyBoYXMgcmVjdXJzaXZlbHkgcmVzY2hlZHVsZWQgaXRzZWxmLlxuICAgICAgICB0aGlzLnBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIEltcG9ydGFudCBpbXBsZW1lbnRhdGlvbiBub3RlOlxuICAgICAgICAvL1xuICAgICAgICAvLyBBY3Rpb25zIG9ubHkgZXhlY3V0ZSBvbmNlIGJ5IGRlZmF1bHQsIHVubGVzcyByZXNjaGVkdWxlZCBmcm9tIHdpdGhpbiB0aGVcbiAgICAgICAgLy8gc2NoZWR1bGVkIGNhbGxiYWNrLiBUaGlzIGFsbG93cyB1cyB0byBpbXBsZW1lbnQgc2luZ2xlIGFuZCByZXBlYXRcbiAgICAgICAgLy8gYWN0aW9ucyB2aWEgdGhlIHNhbWUgY29kZSBwYXRoLCB3aXRob3V0IGFkZGluZyBBUEkgc3VyZmFjZSBhcmVhLCBhcyB3ZWxsXG4gICAgICAgIC8vIGFzIG1pbWljIHRyYWRpdGlvbmFsIHJlY3Vyc2lvbiBidXQgYWNyb3NzIGFzeW5jaHJvbm91cyBib3VuZGFyaWVzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBIb3dldmVyLCBKUyBydW50aW1lcyBhbmQgdGltZXJzIGRpc3Rpbmd1aXNoIGJldHdlZW4gaW50ZXJ2YWxzIGFjaGlldmVkIGJ5XG4gICAgICAgIC8vIHNlcmlhbCBgc2V0VGltZW91dGAgY2FsbHMgdnMuIGEgc2luZ2xlIGBzZXRJbnRlcnZhbGAgY2FsbC4gQW4gaW50ZXJ2YWwgb2ZcbiAgICAgICAgLy8gc2VyaWFsIGBzZXRUaW1lb3V0YCBjYWxscyBjYW4gYmUgaW5kaXZpZHVhbGx5IGRlbGF5ZWQsIHdoaWNoIGRlbGF5c1xuICAgICAgICAvLyBzY2hlZHVsaW5nIHRoZSBuZXh0IGBzZXRUaW1lb3V0YCwgYW5kIHNvIG9uLiBgc2V0SW50ZXJ2YWxgIGF0dGVtcHRzIHRvXG4gICAgICAgIC8vIGd1YXJhbnRlZSB0aGUgaW50ZXJ2YWwgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIG1vcmUgcHJlY2lzZWx5IHRvIHRoZVxuICAgICAgICAvLyBpbnRlcnZhbCBwZXJpb2QsIHJlZ2FyZGxlc3Mgb2YgbG9hZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlcmVmb3JlLCB3ZSB1c2UgYHNldEludGVydmFsYCB0byBzY2hlZHVsZSBzaW5nbGUgYW5kIHJlcGVhdCBhY3Rpb25zLlxuICAgICAgICAvLyBJZiB0aGUgYWN0aW9uIHJlc2NoZWR1bGVzIGl0c2VsZiB3aXRoIHRoZSBzYW1lIGRlbGF5LCB0aGUgaW50ZXJ2YWwgaXMgbm90XG4gICAgICAgIC8vIGNhbmNlbGVkLiBJZiB0aGUgYWN0aW9uIGRvZXNuJ3QgcmVzY2hlZHVsZSwgb3IgcmVzY2hlZHVsZXMgd2l0aCBhXG4gICAgICAgIC8vIGRpZmZlcmVudCBkZWxheSwgdGhlIGludGVydmFsIHdpbGwgYmUgY2FuY2VsZWQgYWZ0ZXIgc2NoZWR1bGVkIGNhbGxiYWNrXG4gICAgICAgIC8vIGV4ZWN1dGlvbi5cbiAgICAgICAgLy9cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIC8vIElmIHRoaXMgYWN0aW9uIGhhcyBhbHJlYWR5IGFuIGFzeW5jIElkLCBkb24ndCByZXF1ZXN0IGEgbmV3IG9uZS5cbiAgICAgICAgdGhpcy5pZCA9IHRoaXMuaWQgfHwgdGhpcy5yZXF1ZXN0QXN5bmNJZChzY2hlZHVsZXIsIHRoaXMuaWQsIGRlbGF5KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVxdWVzdEFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIHJldHVybiByb290XzEucm9vdC5zZXRJbnRlcnZhbChzY2hlZHVsZXIuZmx1c2guYmluZChzY2hlZHVsZXIsIHRoaXMpLCBkZWxheSk7XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICAgICAgaWYgKGRlbGF5ID09PSB2b2lkIDApIHsgZGVsYXkgPSAwOyB9XG4gICAgICAgIC8vIElmIHRoaXMgYWN0aW9uIGlzIHJlc2NoZWR1bGVkIHdpdGggdGhlIHNhbWUgZGVsYXkgdGltZSwgZG9uJ3QgY2xlYXIgdGhlIGludGVydmFsIGlkLlxuICAgICAgICBpZiAoZGVsYXkgIT09IG51bGwgJiYgdGhpcy5kZWxheSA9PT0gZGVsYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIGlmIHRoZSBhY3Rpb24ncyBkZWxheSB0aW1lIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IGRlbGF5LFxuICAgICAgICAvLyBjbGVhciB0aGUgaW50ZXJ2YWwgaWRcbiAgICAgICAgcmV0dXJuIHJvb3RfMS5yb290LmNsZWFySW50ZXJ2YWwoaWQpICYmIHVuZGVmaW5lZCB8fCB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbW1lZGlhdGVseSBleGVjdXRlcyB0aGlzIGFjdGlvbiBhbmQgdGhlIGB3b3JrYCBpdCBjb250YWlucy5cbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignZXhlY3V0aW5nIGEgY2FuY2VsbGVkIGFjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLl9leGVjdXRlKHN0YXRlLCBkZWxheSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucGVuZGluZyA9PT0gZmFsc2UgJiYgdGhpcy5pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBEZXF1ZXVlIGlmIHRoZSBhY3Rpb24gZGlkbid0IHJlc2NoZWR1bGUgaXRzZWxmLiBEb24ndCBjYWxsXG4gICAgICAgICAgICAvLyB1bnN1YnNjcmliZSgpLCBiZWNhdXNlIHRoZSBhY3Rpb24gY291bGQgcmVzY2hlZHVsZSBsYXRlci5cbiAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOlxuICAgICAgICAgICAgLy8gYGBgXG4gICAgICAgICAgICAvLyBzY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24gZG9Xb3JrKGNvdW50ZXIpIHtcbiAgICAgICAgICAgIC8vICAgLyogLi4uIEknbSBhIGJ1c3kgd29ya2VyIGJlZSAuLi4gKi9cbiAgICAgICAgICAgIC8vICAgdmFyIG9yaWdpbmFsQWN0aW9uID0gdGhpcztcbiAgICAgICAgICAgIC8vICAgLyogd2FpdCAxMDBtcyBiZWZvcmUgcmVzY2hlZHVsaW5nIHRoZSBhY3Rpb24gKi9cbiAgICAgICAgICAgIC8vICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyAgICAgb3JpZ2luYWxBY3Rpb24uc2NoZWR1bGUoY291bnRlciArIDEpO1xuICAgICAgICAgICAgLy8gICB9LCAxMDApO1xuICAgICAgICAgICAgLy8gfSwgMTAwMCk7XG4gICAgICAgICAgICAvLyBgYGBcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHRoaXMuc2NoZWR1bGVyLCB0aGlzLmlkLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICB2YXIgZXJyb3JlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZXJyb3JWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMud29yayhzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yZWQgPSB0cnVlO1xuICAgICAgICAgICAgZXJyb3JWYWx1ZSA9ICEhZSAmJiBlIHx8IG5ldyBFcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JlZCkge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yVmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBzY2hlZHVsZXIuYWN0aW9ucztcbiAgICAgICAgdmFyIGluZGV4ID0gYWN0aW9ucy5pbmRleE9mKHRoaXMpO1xuICAgICAgICB0aGlzLndvcmsgPSBudWxsO1xuICAgICAgICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IG51bGw7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGFjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQoc2NoZWR1bGVyLCBpZCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBc3luY0FjdGlvbjtcbn0oQWN0aW9uXzEuQWN0aW9uKSk7XG5leHBvcnRzLkFzeW5jQWN0aW9uID0gQXN5bmNBY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY0FjdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFNjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vU2NoZWR1bGVyJyk7XG52YXIgQXN5bmNTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc3luY1NjaGVkdWxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3luY1NjaGVkdWxlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgdGhlIFNjaGVkdWxlciBpcyBjdXJyZW50bHkgZXhlY3V0aW5nIGEgYmF0Y2ggb2ZcbiAgICAgICAgICogcXVldWVkIGFjdGlvbnMuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGludGVybmFsIElEIHVzZWQgdG8gdHJhY2sgdGhlIGxhdGVzdCBhc3luY2hyb25vdXMgdGFzayBzdWNoIGFzIHRob3NlXG4gICAgICAgICAqIGNvbWluZyBmcm9tIGBzZXRUaW1lb3V0YCwgYHNldEludGVydmFsYCwgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAsIGFuZFxuICAgICAgICAgKiBvdGhlcnMuXG4gICAgICAgICAqIEB0eXBlIHthbnl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaGVkdWxlZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgQXN5bmNTY2hlZHVsZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICB2YXIgYWN0aW9ucyA9IHRoaXMuYWN0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSk7IC8vIGV4aGF1c3QgdGhlIHNjaGVkdWxlciBxdWV1ZVxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdoaWxlIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNTY2hlZHVsZXI7XG59KFNjaGVkdWxlcl8xLlNjaGVkdWxlcikpO1xuZXhwb3J0cy5Bc3luY1NjaGVkdWxlciA9IEFzeW5jU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXN5bmNTY2hlZHVsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQXN5bmNBY3Rpb25fMSA9IHJlcXVpcmUoJy4vQXN5bmNBY3Rpb24nKTtcbnZhciBBc3luY1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi9Bc3luY1NjaGVkdWxlcicpO1xuLyoqXG4gKlxuICogQXN5bmMgU2NoZWR1bGVyXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlNjaGVkdWxlIHRhc2sgYXMgaWYgeW91IHVzZWQgc2V0VGltZW91dCh0YXNrLCBkdXJhdGlvbik8L3NwYW4+XG4gKlxuICogYGFzeW5jYCBzY2hlZHVsZXIgc2NoZWR1bGVzIHRhc2tzIGFzeW5jaHJvbm91c2x5LCBieSBwdXR0aW5nIHRoZW0gb24gdGhlIEphdmFTY3JpcHRcbiAqIGV2ZW50IGxvb3AgcXVldWUuIEl0IGlzIGJlc3QgdXNlZCB0byBkZWxheSB0YXNrcyBpbiB0aW1lIG9yIHRvIHNjaGVkdWxlIHRhc2tzIHJlcGVhdGluZ1xuICogaW4gaW50ZXJ2YWxzLlxuICpcbiAqIElmIHlvdSBqdXN0IHdhbnQgdG8gXCJkZWZlclwiIHRhc2ssIHRoYXQgaXMgdG8gcGVyZm9ybSBpdCByaWdodCBhZnRlciBjdXJyZW50bHlcbiAqIGV4ZWN1dGluZyBzeW5jaHJvbm91cyBjb2RlIGVuZHMgKGNvbW1vbmx5IGFjaGlldmVkIGJ5IGBzZXRUaW1lb3V0KGRlZmVycmVkVGFzaywgMClgKSxcbiAqIGJldHRlciBjaG9pY2Ugd2lsbCBiZSB0aGUge0BsaW5rIGFzYXB9IHNjaGVkdWxlci5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2UgYXN5bmMgc2NoZWR1bGVyIHRvIGRlbGF5IHRhc2s8L2NhcHRpb24+XG4gKiBjb25zdCB0YXNrID0gKCkgPT4gY29uc29sZS5sb2coJ2l0IHdvcmtzIScpO1xuICpcbiAqIFJ4LlNjaGVkdWxlci5hc3luYy5zY2hlZHVsZSh0YXNrLCAyMDAwKTtcbiAqXG4gKiAvLyBBZnRlciAyIHNlY29uZHMgbG9nczpcbiAqIC8vIFwiaXQgd29ya3MhXCJcbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VXNlIGFzeW5jIHNjaGVkdWxlciB0byByZXBlYXQgdGFzayBpbiBpbnRlcnZhbHM8L2NhcHRpb24+XG4gKiBmdW5jdGlvbiB0YXNrKHN0YXRlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHN0YXRlKTtcbiAqICAgdGhpcy5zY2hlZHVsZShzdGF0ZSArIDEsIDEwMDApOyAvLyBgdGhpc2AgcmVmZXJlbmNlcyBjdXJyZW50bHkgZXhlY3V0aW5nIEFjdGlvbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3ZSByZXNjaGVkdWxlIHdpdGggbmV3IHN0YXRlIGFuZCBkZWxheVxuICogfVxuICpcbiAqIFJ4LlNjaGVkdWxlci5hc3luYy5zY2hlZHVsZSh0YXNrLCAzMDAwLCAwKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gMCBhZnRlciAzc1xuICogLy8gMSBhZnRlciA0c1xuICogLy8gMiBhZnRlciA1c1xuICogLy8gMyBhZnRlciA2c1xuICpcbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgYXN5bmNcbiAqIEBvd25lciBTY2hlZHVsZXJcbiAqL1xuZXhwb3J0cy5hc3luYyA9IG5ldyBBc3luY1NjaGVkdWxlcl8xLkFzeW5jU2NoZWR1bGVyKEFzeW5jQWN0aW9uXzEuQXN5bmNBY3Rpb24pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG5mdW5jdGlvbiBzeW1ib2xJdGVyYXRvclBvbnlmaWxsKHJvb3QpIHtcbiAgICB2YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCFTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIFN5bWJvbC5pdGVyYXRvciA9IFN5bWJvbCgnaXRlcmF0b3IgcG9seWZpbGwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3ltYm9sLml0ZXJhdG9yO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gW2ZvciBNb3ppbGxhIEdlY2tvIDI3LTM1Ol0oaHR0cHM6Ly9temwubGEvMmV3RTF6QylcbiAgICAgICAgdmFyIFNldF8xID0gcm9vdC5TZXQ7XG4gICAgICAgIGlmIChTZXRfMSAmJiB0eXBlb2YgbmV3IFNldF8xKClbJ0BAaXRlcmF0b3InXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuICdAQGl0ZXJhdG9yJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgTWFwXzEgPSByb290Lk1hcDtcbiAgICAgICAgLy8gcmVxdWlyZWQgZm9yIGNvbXBhdGFiaWxpdHkgd2l0aCBlczYtc2hpbVxuICAgICAgICBpZiAoTWFwXzEpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTWFwXzEucHJvdG90eXBlKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIC8vIGFjY29yZGluZyB0byBzcGVjLCBNYXAucHJvdG90eXBlW0BAaXRlcmF0b3JdIGFuZCBNYXAub3JvdG90eXBlLmVudHJpZXMgbXVzdCBiZSBlcXVhbC5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnZW50cmllcycgJiYga2V5ICE9PSAnc2l6ZScgJiYgTWFwXzEucHJvdG90eXBlW2tleV0gPT09IE1hcF8xLnByb3RvdHlwZVsnZW50cmllcyddKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnQEBpdGVyYXRvcic7XG4gICAgfVxufVxuZXhwb3J0cy5zeW1ib2xJdGVyYXRvclBvbnlmaWxsID0gc3ltYm9sSXRlcmF0b3JQb255ZmlsbDtcbmV4cG9ydHMuJCRpdGVyYXRvciA9IHN5bWJvbEl0ZXJhdG9yUG9ueWZpbGwocm9vdF8xLnJvb3QpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXRlcmF0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG5mdW5jdGlvbiBnZXRTeW1ib2xPYnNlcnZhYmxlKGNvbnRleHQpIHtcbiAgICB2YXIgJCRvYnNlcnZhYmxlO1xuICAgIHZhciBTeW1ib2wgPSBjb250ZXh0LlN5bWJvbDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAoU3ltYm9sLm9ic2VydmFibGUpIHtcbiAgICAgICAgICAgICQkb2JzZXJ2YWJsZSA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgJCRvYnNlcnZhYmxlID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG4gICAgICAgICAgICBTeW1ib2wub2JzZXJ2YWJsZSA9ICQkb2JzZXJ2YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgJCRvYnNlcnZhYmxlID0gJ0BAb2JzZXJ2YWJsZSc7XG4gICAgfVxuICAgIHJldHVybiAkJG9ic2VydmFibGU7XG59XG5leHBvcnRzLmdldFN5bWJvbE9ic2VydmFibGUgPSBnZXRTeW1ib2xPYnNlcnZhYmxlO1xuZXhwb3J0cy4kJG9ic2VydmFibGUgPSBnZXRTeW1ib2xPYnNlcnZhYmxlKHJvb3RfMS5yb290KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9yb290Jyk7XG52YXIgU3ltYm9sID0gcm9vdF8xLnJvb3QuU3ltYm9sO1xuZXhwb3J0cy4kJHJ4U3Vic2NyaWJlciA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKSA/XG4gICAgU3ltYm9sLmZvcigncnhTdWJzY3JpYmVyJykgOiAnQEByeFN1YnNjcmliZXInO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnhTdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGFuIGFjdGlvbiBpcyBpbnZhbGlkIGJlY2F1c2UgdGhlIG9iamVjdCBoYXMgYmVlblxuICogdW5zdWJzY3JpYmVkLlxuICpcbiAqIEBzZWUge0BsaW5rIFN1YmplY3R9XG4gKiBAc2VlIHtAbGluayBCZWhhdmlvclN1YmplY3R9XG4gKlxuICogQGNsYXNzIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXG4gKi9cbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9iamVjdFVuc3Vic2NyaWJlZEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCkge1xuICAgICAgICB2YXIgZXJyID0gX3N1cGVyLmNhbGwodGhpcywgJ29iamVjdCB1bnN1YnNjcmliZWQnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5PYmplY3RVbnN1YnNjcmliZWRFcnJvciA9IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gb25lIG9yIG1vcmUgZXJyb3JzIGhhdmUgb2NjdXJyZWQgZHVyaW5nIHRoZVxuICogYHVuc3Vic2NyaWJlYCBvZiBhIHtAbGluayBTdWJzY3JpcHRpb259LlxuICovXG52YXIgVW5zdWJzY3JpcHRpb25FcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFVuc3Vic2NyaXB0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVW5zdWJzY3JpcHRpb25FcnJvcihlcnJvcnMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB2YXIgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBlcnJvcnMgP1xuICAgICAgICAgICAgZXJyb3JzLmxlbmd0aCArIFwiIGVycm9ycyBvY2N1cnJlZCBkdXJpbmcgdW5zdWJzY3JpcHRpb246XFxuICBcIiArIGVycm9ycy5tYXAoZnVuY3Rpb24gKGVyciwgaSkgeyByZXR1cm4gKChpICsgMSkgKyBcIikgXCIgKyBlcnIudG9TdHJpbmcoKSk7IH0pLmpvaW4oJ1xcbiAgJykgOiAnJyk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVyci5uYW1lID0gJ1Vuc3Vic2NyaXB0aW9uRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIFVuc3Vic2NyaXB0aW9uRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlVuc3Vic2NyaXB0aW9uRXJyb3IgPSBVbnN1YnNjcmlwdGlvbkVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VW5zdWJzY3JpcHRpb25FcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIHR5cGVvZiBhbnkgc28gdGhhdCBpdCB3ZSBkb24ndCBoYXZlIHRvIGNhc3Qgd2hlbiBjb21wYXJpbmcgYSByZXN1bHQgdG8gdGhlIGVycm9yIG9iamVjdFxuZXhwb3J0cy5lcnJvck9iamVjdCA9IHsgZToge30gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggJiYgdHlwZW9mIHgubGVuZ3RoID09PSAnbnVtYmVyJzsgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0FycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5pc0FycmF5TGlrZSA9IChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAmJiB0eXBlb2YgeC5sZW5ndGggPT09ICdudW1iZXInOyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzQXJyYXlMaWtlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4oK3ZhbHVlKTtcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNEYXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzRnVuY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0FycmF5Jyk7XG5mdW5jdGlvbiBpc051bWVyaWModmFsKSB7XG4gICAgLy8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKG51bGx8dHJ1ZXxmYWxzZXxcIlwiKVxuICAgIC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcbiAgICAvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cbiAgICAvLyBhZGRpbmcgMSBjb3JyZWN0cyBsb3NzIG9mIHByZWNpc2lvbiBmcm9tIHBhcnNlRmxvYXQgKCMxNTEwMClcbiAgICByZXR1cm4gIWlzQXJyYXlfMS5pc0FycmF5KHZhbCkgJiYgKHZhbCAtIHBhcnNlRmxvYXQodmFsKSArIDEpID49IDA7XG59XG5leHBvcnRzLmlzTnVtZXJpYyA9IGlzTnVtZXJpYztcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzTnVtZXJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzT2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzUHJvbWlzZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIGlzU2NoZWR1bGVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zY2hlZHVsZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNTY2hlZHVsZXIgPSBpc1NjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzU2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiB3aW5kb3c6IGJyb3dzZXIgaW4gRE9NIG1haW4gdGhyZWFkXG4gKiBzZWxmOiBicm93c2VyIGluIFdlYldvcmtlclxuICogZ2xvYmFsOiBOb2RlLmpzL290aGVyXG4gKi9cbmV4cG9ydHMucm9vdCA9ICh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdy53aW5kb3cgPT09IHdpbmRvdyAmJiB3aW5kb3dcbiAgICB8fCB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmLnNlbGYgPT09IHNlbGYgJiYgc2VsZlxuICAgIHx8IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbCk7XG5pZiAoIWV4cG9ydHMucm9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUnhKUyBjb3VsZCBub3QgZmluZCBhbnkgZ2xvYmFsIGNvbnRleHQgKHdpbmRvdywgc2VsZiwgZ2xvYmFsKScpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm9vdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciByb290XzEgPSByZXF1aXJlKCcuL3Jvb3QnKTtcbnZhciBpc0FycmF5TGlrZV8xID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xudmFyIGlzUHJvbWlzZV8xID0gcmVxdWlyZSgnLi9pc1Byb21pc2UnKTtcbnZhciBpc09iamVjdF8xID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBpdGVyYXRvcl8xID0gcmVxdWlyZSgnLi4vc3ltYm9sL2l0ZXJhdG9yJyk7XG52YXIgSW5uZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9Jbm5lclN1YnNjcmliZXInKTtcbnZhciBvYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvb2JzZXJ2YWJsZScpO1xuZnVuY3Rpb24gc3Vic2NyaWJlVG9SZXN1bHQob3V0ZXJTdWJzY3JpYmVyLCByZXN1bHQsIG91dGVyVmFsdWUsIG91dGVySW5kZXgpIHtcbiAgICB2YXIgZGVzdGluYXRpb24gPSBuZXcgSW5uZXJTdWJzY3JpYmVyXzEuSW5uZXJTdWJzY3JpYmVyKG91dGVyU3Vic2NyaWJlciwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCk7XG4gICAgaWYgKGRlc3RpbmF0aW9uLmNsb3NlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSB7XG4gICAgICAgIGlmIChyZXN1bHQuX2lzU2NhbGFyKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnN1YnNjcmliZShkZXN0aW5hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheUxpa2VfMS5pc0FycmF5TGlrZShyZXN1bHQpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuICYmICFkZXN0aW5hdGlvbi5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUHJvbWlzZV8xLmlzUHJvbWlzZShyZXN1bHQpKSB7XG4gICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBkZXN0aW5hdGlvbi5lcnJvcihlcnIpOyB9KVxuICAgICAgICAgICAgLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgLy8gRXNjYXBpbmcgdGhlIFByb21pc2UgdHJhcDogZ2xvYmFsbHkgdGhyb3cgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICAgICAgcm9vdF8xLnJvb3Quc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHRocm93IGVycjsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gcmVzdWx0W2l0ZXJhdG9yXzEuJCRpdGVyYXRvcl0oKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoaXRlbS5kb25lKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdFtvYnNlcnZhYmxlXzEuJCRvYnNlcnZhYmxlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgb2JzID0gcmVzdWx0W29ic2VydmFibGVfMS4kJG9ic2VydmFibGVdKCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IobmV3IFR5cGVFcnJvcignUHJvdmlkZWQgb2JqZWN0IGRvZXMgbm90IGNvcnJlY3RseSBpbXBsZW1lbnQgU3ltYm9sLm9ic2VydmFibGUnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzLnN1YnNjcmliZShuZXcgSW5uZXJTdWJzY3JpYmVyXzEuSW5uZXJTdWJzY3JpYmVyKG91dGVyU3Vic2NyaWJlciwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUgPSBpc09iamVjdF8xLmlzT2JqZWN0KHJlc3VsdCkgPyAnYW4gaW52YWxpZCBvYmplY3QnIDogXCInXCIgKyByZXN1bHQgKyBcIidcIjtcbiAgICAgICAgdmFyIG1zZyA9IChcIllvdSBwcm92aWRlZCBcIiArIHZhbHVlICsgXCIgd2hlcmUgYSBzdHJlYW0gd2FzIGV4cGVjdGVkLlwiKVxuICAgICAgICAgICAgKyAnIFlvdSBjYW4gcHJvdmlkZSBhbiBPYnNlcnZhYmxlLCBQcm9taXNlLCBBcnJheSwgb3IgSXRlcmFibGUuJztcbiAgICAgICAgZGVzdGluYXRpb24uZXJyb3IobmV3IFR5cGVFcnJvcihtc2cpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLnN1YnNjcmliZVRvUmVzdWx0ID0gc3Vic2NyaWJlVG9SZXN1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJzY3JpYmVUb1Jlc3VsdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgcnhTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG52YXIgT2JzZXJ2ZXJfMSA9IHJlcXVpcmUoJy4uL09ic2VydmVyJyk7XG5mdW5jdGlvbiB0b1N1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIGlmIChuZXh0T3JPYnNlcnZlcikge1xuICAgICAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgaW5zdGFuY2VvZiBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIW5leHRPck9ic2VydmVyICYmICFlcnJvciAmJiAhY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihPYnNlcnZlcl8xLmVtcHR5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbn1cbmV4cG9ydHMudG9TdWJzY3JpYmVyID0gdG9TdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9TdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGVycm9yT2JqZWN0XzEgPSByZXF1aXJlKCcuL2Vycm9yT2JqZWN0Jyk7XG52YXIgdHJ5Q2F0Y2hUYXJnZXQ7XG5mdW5jdGlvbiB0cnlDYXRjaGVyKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnlDYXRjaFRhcmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUgPSBlO1xuICAgICAgICByZXR1cm4gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cnlDYXRjaChmbikge1xuICAgIHRyeUNhdGNoVGFyZ2V0ID0gZm47XG4gICAgcmV0dXJuIHRyeUNhdGNoZXI7XG59XG5leHBvcnRzLnRyeUNhdGNoID0gdHJ5Q2F0Y2g7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cnlDYXRjaC5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgMjAxNCBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyAgICAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyAgICAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbiFmdW5jdGlvbihhLGIpe3ZhciBjPXt9LGQ9e30sZT17fSxmPW51bGw7IWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXtpZihcIm51bWJlclwiPT10eXBlb2YgYSlyZXR1cm4gYTt2YXIgYj17fTtmb3IodmFyIGMgaW4gYSliW2NdPWFbY107cmV0dXJuIGJ9ZnVuY3Rpb24gZCgpe3RoaXMuX2RlbGF5PTAsdGhpcy5fZW5kRGVsYXk9MCx0aGlzLl9maWxsPVwibm9uZVwiLHRoaXMuX2l0ZXJhdGlvblN0YXJ0PTAsdGhpcy5faXRlcmF0aW9ucz0xLHRoaXMuX2R1cmF0aW9uPTAsdGhpcy5fcGxheWJhY2tSYXRlPTEsdGhpcy5fZGlyZWN0aW9uPVwibm9ybWFsXCIsdGhpcy5fZWFzaW5nPVwibGluZWFyXCIsdGhpcy5fZWFzaW5nRnVuY3Rpb249eH1mdW5jdGlvbiBlKCl7cmV0dXJuIGEuaXNEZXByZWNhdGVkKFwiSW52YWxpZCB0aW1pbmcgaW5wdXRzXCIsXCIyMDE2LTAzLTAyXCIsXCJUeXBlRXJyb3IgZXhjZXB0aW9ucyB3aWxsIGJlIHRocm93biBpbnN0ZWFkLlwiLCEwKX1mdW5jdGlvbiBmKGIsYyxlKXt2YXIgZj1uZXcgZDtyZXR1cm4gYyYmKGYuZmlsbD1cImJvdGhcIixmLmR1cmF0aW9uPVwiYXV0b1wiKSxcIm51bWJlclwiIT10eXBlb2YgYnx8aXNOYU4oYik/dm9pZCAwIT09YiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYikuZm9yRWFjaChmdW5jdGlvbihjKXtpZihcImF1dG9cIiE9YltjXSl7aWYoKFwibnVtYmVyXCI9PXR5cGVvZiBmW2NdfHxcImR1cmF0aW9uXCI9PWMpJiYoXCJudW1iZXJcIiE9dHlwZW9mIGJbY118fGlzTmFOKGJbY10pKSlyZXR1cm47aWYoXCJmaWxsXCI9PWMmJnYuaW5kZXhPZihiW2NdKT09LTEpcmV0dXJuO2lmKFwiZGlyZWN0aW9uXCI9PWMmJncuaW5kZXhPZihiW2NdKT09LTEpcmV0dXJuO2lmKFwicGxheWJhY2tSYXRlXCI9PWMmJjEhPT1iW2NdJiZhLmlzRGVwcmVjYXRlZChcIkFuaW1hdGlvbkVmZmVjdFRpbWluZy5wbGF5YmFja1JhdGVcIixcIjIwMTQtMTEtMjhcIixcIlVzZSBBbmltYXRpb24ucGxheWJhY2tSYXRlIGluc3RlYWQuXCIpKXJldHVybjtmW2NdPWJbY119fSk6Zi5kdXJhdGlvbj1iLGZ9ZnVuY3Rpb24gZyhhKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgYSYmKGE9aXNOYU4oYSk/e2R1cmF0aW9uOjB9OntkdXJhdGlvbjphfSksYX1mdW5jdGlvbiBoKGIsYyl7cmV0dXJuIGI9YS5udW1lcmljVGltaW5nVG9PYmplY3QoYiksZihiLGMpfWZ1bmN0aW9uIGkoYSxiLGMsZCl7cmV0dXJuIGE8MHx8YT4xfHxjPDB8fGM+MT94OmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGYoYSxiLGMpe3JldHVybiAzKmEqKDEtYykqKDEtYykqYyszKmIqKDEtYykqYypjK2MqYypjfWlmKGU8PTApe3ZhciBnPTA7cmV0dXJuIGE+MD9nPWIvYTohYiYmYz4wJiYoZz1kL2MpLGcqZX1pZihlPj0xKXt2YXIgaD0wO3JldHVybiBjPDE/aD0oZC0xKS8oYy0xKToxPT1jJiZhPDEmJihoPShiLTEpLyhhLTEpKSwxK2gqKGUtMSl9Zm9yKHZhciBpPTAsaj0xO2k8ajspe3ZhciBrPShpK2opLzIsbD1mKGEsYyxrKTtpZihNYXRoLmFicyhlLWwpPDFlLTUpcmV0dXJuIGYoYixkLGspO2w8ZT9pPWs6aj1rfXJldHVybiBmKGIsZCxrKX19ZnVuY3Rpb24gaihhLGIpe3JldHVybiBmdW5jdGlvbihjKXtpZihjPj0xKXJldHVybiAxO3ZhciBkPTEvYTtyZXR1cm4gYys9YipkLGMtYyVkfX1mdW5jdGlvbiBrKGEpe0N8fChDPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUpLEMuYW5pbWF0aW9uVGltaW5nRnVuY3Rpb249XCJcIixDLmFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uPWE7dmFyIGI9Qy5hbmltYXRpb25UaW1pbmdGdW5jdGlvbjtpZihcIlwiPT1iJiZlKCkpdGhyb3cgbmV3IFR5cGVFcnJvcihhK1wiIGlzIG5vdCBhIHZhbGlkIHZhbHVlIGZvciBlYXNpbmdcIik7cmV0dXJuIGJ9ZnVuY3Rpb24gbChhKXtpZihcImxpbmVhclwiPT1hKXJldHVybiB4O3ZhciBiPUUuZXhlYyhhKTtpZihiKXJldHVybiBpLmFwcGx5KHRoaXMsYi5zbGljZSgxKS5tYXAoTnVtYmVyKSk7dmFyIGM9Ri5leGVjKGEpO2lmKGMpcmV0dXJuIGooTnVtYmVyKGNbMV0pLHtzdGFydDp5LG1pZGRsZTp6LGVuZDpBfVtjWzJdXSk7dmFyIGQ9QlthXTtyZXR1cm4gZD9kOnh9ZnVuY3Rpb24gbShhKXtyZXR1cm4gTWF0aC5hYnMobihhKS9hLnBsYXliYWNrUmF0ZSl9ZnVuY3Rpb24gbihhKXtyZXR1cm4gMD09PWEuZHVyYXRpb258fDA9PT1hLml0ZXJhdGlvbnM/MDphLmR1cmF0aW9uKmEuaXRlcmF0aW9uc31mdW5jdGlvbiBvKGEsYixjKXtpZihudWxsPT1iKXJldHVybiBHO3ZhciBkPWMuZGVsYXkrYStjLmVuZERlbGF5O3JldHVybiBiPE1hdGgubWluKGMuZGVsYXksZCk/SDpiPj1NYXRoLm1pbihjLmRlbGF5K2EsZCk/STpKfWZ1bmN0aW9uIHAoYSxiLGMsZCxlKXtzd2l0Y2goZCl7Y2FzZSBIOnJldHVyblwiYmFja3dhcmRzXCI9PWJ8fFwiYm90aFwiPT1iPzA6bnVsbDtjYXNlIEo6cmV0dXJuIGMtZTtjYXNlIEk6cmV0dXJuXCJmb3J3YXJkc1wiPT1ifHxcImJvdGhcIj09Yj9hOm51bGw7Y2FzZSBHOnJldHVybiBudWxsfX1mdW5jdGlvbiBxKGEsYixjLGQsZSl7dmFyIGY9ZTtyZXR1cm4gMD09PWE/YiE9PUgmJihmKz1jKTpmKz1kL2EsZn1mdW5jdGlvbiByKGEsYixjLGQsZSxmKXt2YXIgZz1hPT09MS8wP2IlMTphJTE7cmV0dXJuIDAhPT1nfHxjIT09SXx8MD09PWR8fDA9PT1lJiYwIT09Znx8KGc9MSksZ31mdW5jdGlvbiBzKGEsYixjLGQpe3JldHVybiBhPT09SSYmYj09PTEvMD8xLzA6MT09PWM/TWF0aC5mbG9vcihkKS0xOk1hdGguZmxvb3IoZCl9ZnVuY3Rpb24gdChhLGIsYyl7dmFyIGQ9YTtpZihcIm5vcm1hbFwiIT09YSYmXCJyZXZlcnNlXCIhPT1hKXt2YXIgZT1iO1wiYWx0ZXJuYXRlLXJldmVyc2VcIj09PWEmJihlKz0xKSxkPVwibm9ybWFsXCIsZSE9PTEvMCYmZSUyIT09MCYmKGQ9XCJyZXZlcnNlXCIpfXJldHVyblwibm9ybWFsXCI9PT1kP2M6MS1jfWZ1bmN0aW9uIHUoYSxiLGMpe3ZhciBkPW8oYSxiLGMpLGU9cChhLGMuZmlsbCxiLGQsYy5kZWxheSk7aWYobnVsbD09PWUpcmV0dXJuIG51bGw7dmFyIGY9cShjLmR1cmF0aW9uLGQsYy5pdGVyYXRpb25zLGUsYy5pdGVyYXRpb25TdGFydCksZz1yKGYsYy5pdGVyYXRpb25TdGFydCxkLGMuaXRlcmF0aW9ucyxlLGMuZHVyYXRpb24pLGg9cyhkLGMuaXRlcmF0aW9ucyxnLGYpLGk9dChjLmRpcmVjdGlvbixoLGcpO3JldHVybiBjLl9lYXNpbmdGdW5jdGlvbihpKX12YXIgdj1cImJhY2t3YXJkc3xmb3J3YXJkc3xib3RofG5vbmVcIi5zcGxpdChcInxcIiksdz1cInJldmVyc2V8YWx0ZXJuYXRlfGFsdGVybmF0ZS1yZXZlcnNlXCIuc3BsaXQoXCJ8XCIpLHg9ZnVuY3Rpb24oYSl7cmV0dXJuIGF9O2QucHJvdG90eXBlPXtfc2V0TWVtYmVyOmZ1bmN0aW9uKGIsYyl7dGhpc1tcIl9cIitiXT1jLHRoaXMuX2VmZmVjdCYmKHRoaXMuX2VmZmVjdC5fdGltaW5nSW5wdXRbYl09Yyx0aGlzLl9lZmZlY3QuX3RpbWluZz1hLm5vcm1hbGl6ZVRpbWluZ0lucHV0KHRoaXMuX2VmZmVjdC5fdGltaW5nSW5wdXQpLHRoaXMuX2VmZmVjdC5hY3RpdmVEdXJhdGlvbj1hLmNhbGN1bGF0ZUFjdGl2ZUR1cmF0aW9uKHRoaXMuX2VmZmVjdC5fdGltaW5nKSx0aGlzLl9lZmZlY3QuX2FuaW1hdGlvbiYmdGhpcy5fZWZmZWN0Ll9hbmltYXRpb24uX3JlYnVpbGRVbmRlcmx5aW5nQW5pbWF0aW9uKCkpfSxnZXQgcGxheWJhY2tSYXRlKCl7cmV0dXJuIHRoaXMuX3BsYXliYWNrUmF0ZX0sc2V0IGRlbGF5KGEpe3RoaXMuX3NldE1lbWJlcihcImRlbGF5XCIsYSl9LGdldCBkZWxheSgpe3JldHVybiB0aGlzLl9kZWxheX0sc2V0IGVuZERlbGF5KGEpe3RoaXMuX3NldE1lbWJlcihcImVuZERlbGF5XCIsYSl9LGdldCBlbmREZWxheSgpe3JldHVybiB0aGlzLl9lbmREZWxheX0sc2V0IGZpbGwoYSl7dGhpcy5fc2V0TWVtYmVyKFwiZmlsbFwiLGEpfSxnZXQgZmlsbCgpe3JldHVybiB0aGlzLl9maWxsfSxzZXQgaXRlcmF0aW9uU3RhcnQoYSl7aWYoKGlzTmFOKGEpfHxhPDApJiZlKCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIml0ZXJhdGlvblN0YXJ0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLCByZWNlaXZlZDogXCIrdGltaW5nLml0ZXJhdGlvblN0YXJ0KTt0aGlzLl9zZXRNZW1iZXIoXCJpdGVyYXRpb25TdGFydFwiLGEpfSxnZXQgaXRlcmF0aW9uU3RhcnQoKXtyZXR1cm4gdGhpcy5faXRlcmF0aW9uU3RhcnR9LHNldCBkdXJhdGlvbihhKXtpZihcImF1dG9cIiE9YSYmKGlzTmFOKGEpfHxhPDApJiZlKCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImR1cmF0aW9uIG11c3QgYmUgbm9uLW5lZ2F0aXZlIG9yIGF1dG8sIHJlY2VpdmVkOiBcIithKTt0aGlzLl9zZXRNZW1iZXIoXCJkdXJhdGlvblwiLGEpfSxnZXQgZHVyYXRpb24oKXtyZXR1cm4gdGhpcy5fZHVyYXRpb259LHNldCBkaXJlY3Rpb24oYSl7dGhpcy5fc2V0TWVtYmVyKFwiZGlyZWN0aW9uXCIsYSl9LGdldCBkaXJlY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGlyZWN0aW9ufSxzZXQgZWFzaW5nKGEpe3RoaXMuX2Vhc2luZ0Z1bmN0aW9uPWwoayhhKSksdGhpcy5fc2V0TWVtYmVyKFwiZWFzaW5nXCIsYSl9LGdldCBlYXNpbmcoKXtyZXR1cm4gdGhpcy5fZWFzaW5nfSxzZXQgaXRlcmF0aW9ucyhhKXtpZigoaXNOYU4oYSl8fGE8MCkmJmUoKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0aW9ucyBtdXN0IGJlIG5vbi1uZWdhdGl2ZSwgcmVjZWl2ZWQ6IFwiK2EpO3RoaXMuX3NldE1lbWJlcihcIml0ZXJhdGlvbnNcIixhKX0sZ2V0IGl0ZXJhdGlvbnMoKXtyZXR1cm4gdGhpcy5faXRlcmF0aW9uc319O3ZhciB5PTEsej0uNSxBPTAsQj17ZWFzZTppKC4yNSwuMSwuMjUsMSksXCJlYXNlLWluXCI6aSguNDIsMCwxLDEpLFwiZWFzZS1vdXRcIjppKDAsMCwuNTgsMSksXCJlYXNlLWluLW91dFwiOmkoLjQyLDAsLjU4LDEpLFwic3RlcC1zdGFydFwiOmooMSx5KSxcInN0ZXAtbWlkZGxlXCI6aigxLHopLFwic3RlcC1lbmRcIjpqKDEsQSl9LEM9bnVsbCxEPVwiXFxcXHMqKC0/XFxcXGQrXFxcXC4/XFxcXGQqfC0/XFxcXC5cXFxcZCspXFxcXHMqXCIsRT1uZXcgUmVnRXhwKFwiY3ViaWMtYmV6aWVyXFxcXChcIitEK1wiLFwiK0QrXCIsXCIrRCtcIixcIitEK1wiXFxcXClcIiksRj0vc3RlcHNcXChcXHMqKFxcZCspXFxzKixcXHMqKHN0YXJ0fG1pZGRsZXxlbmQpXFxzKlxcKS8sRz0wLEg9MSxJPTIsSj0zO2EuY2xvbmVUaW1pbmdJbnB1dD1jLGEubWFrZVRpbWluZz1mLGEubnVtZXJpY1RpbWluZ1RvT2JqZWN0PWcsYS5ub3JtYWxpemVUaW1pbmdJbnB1dD1oLGEuY2FsY3VsYXRlQWN0aXZlRHVyYXRpb249bSxhLmNhbGN1bGF0ZUl0ZXJhdGlvblByb2dyZXNzPXUsYS5jYWxjdWxhdGVQaGFzZT1vLGEubm9ybWFsaXplRWFzaW5nPWssYS5wYXJzZUVhc2luZ0Z1bmN0aW9uPWx9KGMsZiksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYil7cmV0dXJuIGEgaW4gaz9rW2FdW2JdfHxiOmJ9ZnVuY3Rpb24gZChhKXtyZXR1cm5cImRpc3BsYXlcIj09PWF8fDA9PT1hLmxhc3RJbmRleE9mKFwiYW5pbWF0aW9uXCIsMCl8fDA9PT1hLmxhc3RJbmRleE9mKFwidHJhbnNpdGlvblwiLDApfWZ1bmN0aW9uIGUoYSxiLGUpe2lmKCFkKGEpKXt2YXIgZj1oW2FdO2lmKGYpe2kuc3R5bGVbYV09Yjtmb3IodmFyIGcgaW4gZil7dmFyIGo9ZltnXSxrPWkuc3R5bGVbal07ZVtqXT1jKGosayl9fWVsc2UgZVthXT1jKGEsYil9fWZ1bmN0aW9uIGYoYSl7dmFyIGI9W107Zm9yKHZhciBjIGluIGEpaWYoIShjIGluW1wiZWFzaW5nXCIsXCJvZmZzZXRcIixcImNvbXBvc2l0ZVwiXSkpe3ZhciBkPWFbY107QXJyYXkuaXNBcnJheShkKXx8KGQ9W2RdKTtmb3IodmFyIGUsZj1kLmxlbmd0aCxnPTA7ZzxmO2crKyllPXt9LFwib2Zmc2V0XCJpbiBhP2Uub2Zmc2V0PWEub2Zmc2V0OjE9PWY/ZS5vZmZzZXQ9MTplLm9mZnNldD1nLyhmLTEpLFwiZWFzaW5nXCJpbiBhJiYoZS5lYXNpbmc9YS5lYXNpbmcpLFwiY29tcG9zaXRlXCJpbiBhJiYoZS5jb21wb3NpdGU9YS5jb21wb3NpdGUpLGVbY109ZFtnXSxiLnB1c2goZSl9cmV0dXJuIGIuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLm9mZnNldC1iLm9mZnNldH0pLGJ9ZnVuY3Rpb24gZyhiKXtmdW5jdGlvbiBjKCl7dmFyIGE9ZC5sZW5ndGg7bnVsbD09ZFthLTFdLm9mZnNldCYmKGRbYS0xXS5vZmZzZXQ9MSksYT4xJiZudWxsPT1kWzBdLm9mZnNldCYmKGRbMF0ub2Zmc2V0PTApO2Zvcih2YXIgYj0wLGM9ZFswXS5vZmZzZXQsZT0xO2U8YTtlKyspe3ZhciBmPWRbZV0ub2Zmc2V0O2lmKG51bGwhPWYpe2Zvcih2YXIgZz0xO2c8ZS1iO2crKylkW2IrZ10ub2Zmc2V0PWMrKGYtYykqZy8oZS1iKTtiPWUsYz1mfX19aWYobnVsbD09YilyZXR1cm5bXTt3aW5kb3cuU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3ImJkFycmF5LnByb3RvdHlwZS5mcm9tJiZiW1N5bWJvbC5pdGVyYXRvcl0mJihiPUFycmF5LmZyb20oYikpLEFycmF5LmlzQXJyYXkoYil8fChiPWYoYikpO2Zvcih2YXIgZD1iLm1hcChmdW5jdGlvbihiKXt2YXIgYz17fTtmb3IodmFyIGQgaW4gYil7dmFyIGY9YltkXTtpZihcIm9mZnNldFwiPT1kKXtpZihudWxsIT1mKXtpZihmPU51bWJlcihmKSwhaXNGaW5pdGUoZikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIktleWZyYW1lIG9mZnNldHMgbXVzdCBiZSBudW1iZXJzLlwiKTtpZihmPDB8fGY+MSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiS2V5ZnJhbWUgb2Zmc2V0cyBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS5cIil9fWVsc2UgaWYoXCJjb21wb3NpdGVcIj09ZCl7aWYoXCJhZGRcIj09Znx8XCJhY2N1bXVsYXRlXCI9PWYpdGhyb3d7dHlwZTpET01FeGNlcHRpb24uTk9UX1NVUFBPUlRFRF9FUlIsbmFtZTpcIk5vdFN1cHBvcnRlZEVycm9yXCIsbWVzc2FnZTpcImFkZCBjb21wb3NpdGluZyBpcyBub3Qgc3VwcG9ydGVkXCJ9O2lmKFwicmVwbGFjZVwiIT1mKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGNvbXBvc2l0ZSBtb2RlIFwiK2YrXCIuXCIpfWVsc2UgZj1cImVhc2luZ1wiPT1kP2Eubm9ybWFsaXplRWFzaW5nKGYpOlwiXCIrZjtlKGQsZixjKX1yZXR1cm4gdm9pZCAwPT1jLm9mZnNldCYmKGMub2Zmc2V0PW51bGwpLHZvaWQgMD09Yy5lYXNpbmcmJihjLmVhc2luZz1cImxpbmVhclwiKSxjfSksZz0hMCxoPS0oMS8wKSxpPTA7aTxkLmxlbmd0aDtpKyspe3ZhciBqPWRbaV0ub2Zmc2V0O2lmKG51bGwhPWope2lmKGo8aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiS2V5ZnJhbWVzIGFyZSBub3QgbG9vc2VseSBzb3J0ZWQgYnkgb2Zmc2V0LiBTb3J0IG9yIHNwZWNpZnkgb2Zmc2V0cy5cIik7aD1qfWVsc2UgZz0hMX1yZXR1cm4gZD1kLmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gYS5vZmZzZXQ+PTAmJmEub2Zmc2V0PD0xfSksZ3x8YygpLGR9dmFyIGg9e2JhY2tncm91bmQ6W1wiYmFja2dyb3VuZEltYWdlXCIsXCJiYWNrZ3JvdW5kUG9zaXRpb25cIixcImJhY2tncm91bmRTaXplXCIsXCJiYWNrZ3JvdW5kUmVwZWF0XCIsXCJiYWNrZ3JvdW5kQXR0YWNobWVudFwiLFwiYmFja2dyb3VuZE9yaWdpblwiLFwiYmFja2dyb3VuZENsaXBcIixcImJhY2tncm91bmRDb2xvclwiXSxib3JkZXI6W1wiYm9yZGVyVG9wQ29sb3JcIixcImJvcmRlclRvcFN0eWxlXCIsXCJib3JkZXJUb3BXaWR0aFwiLFwiYm9yZGVyUmlnaHRDb2xvclwiLFwiYm9yZGVyUmlnaHRTdHlsZVwiLFwiYm9yZGVyUmlnaHRXaWR0aFwiLFwiYm9yZGVyQm90dG9tQ29sb3JcIixcImJvcmRlckJvdHRvbVN0eWxlXCIsXCJib3JkZXJCb3R0b21XaWR0aFwiLFwiYm9yZGVyTGVmdENvbG9yXCIsXCJib3JkZXJMZWZ0U3R5bGVcIixcImJvcmRlckxlZnRXaWR0aFwiXSxib3JkZXJCb3R0b206W1wiYm9yZGVyQm90dG9tV2lkdGhcIixcImJvcmRlckJvdHRvbVN0eWxlXCIsXCJib3JkZXJCb3R0b21Db2xvclwiXSxib3JkZXJDb2xvcjpbXCJib3JkZXJUb3BDb2xvclwiLFwiYm9yZGVyUmlnaHRDb2xvclwiLFwiYm9yZGVyQm90dG9tQ29sb3JcIixcImJvcmRlckxlZnRDb2xvclwiXSxib3JkZXJMZWZ0OltcImJvcmRlckxlZnRXaWR0aFwiLFwiYm9yZGVyTGVmdFN0eWxlXCIsXCJib3JkZXJMZWZ0Q29sb3JcIl0sYm9yZGVyUmFkaXVzOltcImJvcmRlclRvcExlZnRSYWRpdXNcIixcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXCJib3JkZXJCb3R0b21SaWdodFJhZGl1c1wiLFwiYm9yZGVyQm90dG9tTGVmdFJhZGl1c1wiXSxib3JkZXJSaWdodDpbXCJib3JkZXJSaWdodFdpZHRoXCIsXCJib3JkZXJSaWdodFN0eWxlXCIsXCJib3JkZXJSaWdodENvbG9yXCJdLGJvcmRlclRvcDpbXCJib3JkZXJUb3BXaWR0aFwiLFwiYm9yZGVyVG9wU3R5bGVcIixcImJvcmRlclRvcENvbG9yXCJdLGJvcmRlcldpZHRoOltcImJvcmRlclRvcFdpZHRoXCIsXCJib3JkZXJSaWdodFdpZHRoXCIsXCJib3JkZXJCb3R0b21XaWR0aFwiLFwiYm9yZGVyTGVmdFdpZHRoXCJdLGZsZXg6W1wiZmxleEdyb3dcIixcImZsZXhTaHJpbmtcIixcImZsZXhCYXNpc1wiXSxmb250OltcImZvbnRGYW1pbHlcIixcImZvbnRTaXplXCIsXCJmb250U3R5bGVcIixcImZvbnRWYXJpYW50XCIsXCJmb250V2VpZ2h0XCIsXCJsaW5lSGVpZ2h0XCJdLG1hcmdpbjpbXCJtYXJnaW5Ub3BcIixcIm1hcmdpblJpZ2h0XCIsXCJtYXJnaW5Cb3R0b21cIixcIm1hcmdpbkxlZnRcIl0sb3V0bGluZTpbXCJvdXRsaW5lQ29sb3JcIixcIm91dGxpbmVTdHlsZVwiLFwib3V0bGluZVdpZHRoXCJdLHBhZGRpbmc6W1wicGFkZGluZ1RvcFwiLFwicGFkZGluZ1JpZ2h0XCIsXCJwYWRkaW5nQm90dG9tXCIsXCJwYWRkaW5nTGVmdFwiXX0saT1kb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsXCJkaXZcIiksaj17dGhpbjpcIjFweFwiLG1lZGl1bTpcIjNweFwiLHRoaWNrOlwiNXB4XCJ9LGs9e2JvcmRlckJvdHRvbVdpZHRoOmosYm9yZGVyTGVmdFdpZHRoOmosYm9yZGVyUmlnaHRXaWR0aDpqLGJvcmRlclRvcFdpZHRoOmosZm9udFNpemU6e1wieHgtc21hbGxcIjpcIjYwJVwiLFwieC1zbWFsbFwiOlwiNzUlXCIsc21hbGw6XCI4OSVcIixtZWRpdW06XCIxMDAlXCIsbGFyZ2U6XCIxMjAlXCIsXCJ4LWxhcmdlXCI6XCIxNTAlXCIsXCJ4eC1sYXJnZVwiOlwiMjAwJVwifSxmb250V2VpZ2h0Ontub3JtYWw6XCI0MDBcIixib2xkOlwiNzAwXCJ9LG91dGxpbmVXaWR0aDpqLHRleHRTaGFkb3c6e25vbmU6XCIwcHggMHB4IDBweCB0cmFuc3BhcmVudFwifSxib3hTaGFkb3c6e25vbmU6XCIwcHggMHB4IDBweCAwcHggdHJhbnNwYXJlbnRcIn19O2EuY29udmVydFRvQXJyYXlGb3JtPWYsYS5ub3JtYWxpemVLZXlmcmFtZXM9Z30oYyxmKSxmdW5jdGlvbihhKXt2YXIgYj17fTthLmlzRGVwcmVjYXRlZD1mdW5jdGlvbihhLGMsZCxlKXt2YXIgZj1lP1wiYXJlXCI6XCJpc1wiLGc9bmV3IERhdGUsaD1uZXcgRGF0ZShjKTtyZXR1cm4gaC5zZXRNb250aChoLmdldE1vbnRoKCkrMyksIShnPGgmJihhIGluIGJ8fGNvbnNvbGUud2FybihcIldlYiBBbmltYXRpb25zOiBcIithK1wiIFwiK2YrXCIgZGVwcmVjYXRlZCBhbmQgd2lsbCBzdG9wIHdvcmtpbmcgb24gXCIraC50b0RhdGVTdHJpbmcoKStcIi4gXCIrZCksYlthXT0hMCwxKSl9LGEuZGVwcmVjYXRlZD1mdW5jdGlvbihiLGMsZCxlKXt2YXIgZj1lP1wiYXJlXCI6XCJpc1wiO2lmKGEuaXNEZXByZWNhdGVkKGIsYyxkLGUpKXRocm93IG5ldyBFcnJvcihiK1wiIFwiK2YrXCIgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gXCIrZCl9fShjKSxmdW5jdGlvbigpe2lmKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hbmltYXRlKXt2YXIgYT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYW5pbWF0ZShbXSwwKSxiPSEwO2lmKGEmJihiPSExLFwicGxheXxjdXJyZW50VGltZXxwYXVzZXxyZXZlcnNlfHBsYXliYWNrUmF0ZXxjYW5jZWx8ZmluaXNofHN0YXJ0VGltZXxwbGF5U3RhdGVcIi5zcGxpdChcInxcIikuZm9yRWFjaChmdW5jdGlvbihjKXt2b2lkIDA9PT1hW2NdJiYoYj0hMCl9KSksIWIpcmV0dXJufSFmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXtmb3IodmFyIGI9e30sYz0wO2M8YS5sZW5ndGg7YysrKWZvcih2YXIgZCBpbiBhW2NdKWlmKFwib2Zmc2V0XCIhPWQmJlwiZWFzaW5nXCIhPWQmJlwiY29tcG9zaXRlXCIhPWQpe3ZhciBlPXtvZmZzZXQ6YVtjXS5vZmZzZXQsZWFzaW5nOmFbY10uZWFzaW5nLHZhbHVlOmFbY11bZF19O2JbZF09YltkXXx8W10sYltkXS5wdXNoKGUpfWZvcih2YXIgZiBpbiBiKXt2YXIgZz1iW2ZdO2lmKDAhPWdbMF0ub2Zmc2V0fHwxIT1nW2cubGVuZ3RoLTFdLm9mZnNldCl0aHJvd3t0eXBlOkRPTUV4Y2VwdGlvbi5OT1RfU1VQUE9SVEVEX0VSUixuYW1lOlwiTm90U3VwcG9ydGVkRXJyb3JcIixtZXNzYWdlOlwiUGFydGlhbCBrZXlmcmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWRcIn19cmV0dXJuIGJ9ZnVuY3Rpb24gZShjKXt2YXIgZD1bXTtmb3IodmFyIGUgaW4gYylmb3IodmFyIGY9Y1tlXSxnPTA7ZzxmLmxlbmd0aC0xO2crKyl7dmFyIGg9ZyxpPWcrMSxqPWZbaF0ub2Zmc2V0LGs9ZltpXS5vZmZzZXQsbD1qLG09azswPT1nJiYobD0tKDEvMCksMD09ayYmKGk9aCkpLGc9PWYubGVuZ3RoLTImJihtPTEvMCwxPT1qJiYoaD1pKSksZC5wdXNoKHthcHBseUZyb206bCxhcHBseVRvOm0sc3RhcnRPZmZzZXQ6ZltoXS5vZmZzZXQsZW5kT2Zmc2V0OmZbaV0ub2Zmc2V0LGVhc2luZ0Z1bmN0aW9uOmEucGFyc2VFYXNpbmdGdW5jdGlvbihmW2hdLmVhc2luZykscHJvcGVydHk6ZSxpbnRlcnBvbGF0aW9uOmIucHJvcGVydHlJbnRlcnBvbGF0aW9uKGUsZltoXS52YWx1ZSxmW2ldLnZhbHVlKX0pfXJldHVybiBkLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5zdGFydE9mZnNldC1iLnN0YXJ0T2Zmc2V0fSksZH1iLmNvbnZlcnRFZmZlY3RJbnB1dD1mdW5jdGlvbihjKXt2YXIgZj1hLm5vcm1hbGl6ZUtleWZyYW1lcyhjKSxnPWQoZiksaD1lKGcpO3JldHVybiBmdW5jdGlvbihhLGMpe2lmKG51bGwhPWMpaC5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGM+PWEuYXBwbHlGcm9tJiZjPGEuYXBwbHlUb30pLmZvckVhY2goZnVuY3Rpb24oZCl7dmFyIGU9Yy1kLnN0YXJ0T2Zmc2V0LGY9ZC5lbmRPZmZzZXQtZC5zdGFydE9mZnNldCxnPTA9PWY/MDpkLmVhc2luZ0Z1bmN0aW9uKGUvZik7Yi5hcHBseShhLGQucHJvcGVydHksZC5pbnRlcnBvbGF0aW9uKGcpKX0pO2Vsc2UgZm9yKHZhciBkIGluIGcpXCJvZmZzZXRcIiE9ZCYmXCJlYXNpbmdcIiE9ZCYmXCJjb21wb3NpdGVcIiE9ZCYmYi5jbGVhcihhLGQpfX19KGMsZCxmKSxmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXtyZXR1cm4gYS5yZXBsYWNlKC8tKC4pL2csZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50b1VwcGVyQ2FzZSgpfSl9ZnVuY3Rpb24gZShhLGIsYyl7aFtjXT1oW2NdfHxbXSxoW2NdLnB1c2goW2EsYl0pfWZ1bmN0aW9uIGYoYSxiLGMpe2Zvcih2YXIgZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgZz1jW2ZdO2UoYSxiLGQoZykpfX1mdW5jdGlvbiBnKGMsZSxmKXt2YXIgZz1jOy8tLy50ZXN0KGMpJiYhYS5pc0RlcHJlY2F0ZWQoXCJIeXBoZW5hdGVkIHByb3BlcnR5IG5hbWVzXCIsXCIyMDE2LTAzLTIyXCIsXCJVc2UgY2FtZWxDYXNlIGluc3RlYWQuXCIsITApJiYoZz1kKGMpKSxcImluaXRpYWxcIiE9ZSYmXCJpbml0aWFsXCIhPWZ8fChcImluaXRpYWxcIj09ZSYmKGU9aVtnXSksXCJpbml0aWFsXCI9PWYmJihmPWlbZ10pKTtmb3IodmFyIGo9ZT09Zj9bXTpoW2ddLGs9MDtqJiZrPGoubGVuZ3RoO2srKyl7dmFyIGw9altrXVswXShlKSxtPWpba11bMF0oZik7aWYodm9pZCAwIT09bCYmdm9pZCAwIT09bSl7dmFyIG49altrXVsxXShsLG0pO2lmKG4pe3ZhciBvPWIuSW50ZXJwb2xhdGlvbi5hcHBseShudWxsLG4pO3JldHVybiBmdW5jdGlvbihhKXtyZXR1cm4gMD09YT9lOjE9PWE/ZjpvKGEpfX19fXJldHVybiBiLkludGVycG9sYXRpb24oITEsITAsZnVuY3Rpb24oYSl7cmV0dXJuIGE/ZjplfSl9dmFyIGg9e307Yi5hZGRQcm9wZXJ0aWVzSGFuZGxlcj1mO3ZhciBpPXtiYWNrZ3JvdW5kQ29sb3I6XCJ0cmFuc3BhcmVudFwiLGJhY2tncm91bmRQb3NpdGlvbjpcIjAlIDAlXCIsYm9yZGVyQm90dG9tQ29sb3I6XCJjdXJyZW50Q29sb3JcIixib3JkZXJCb3R0b21MZWZ0UmFkaXVzOlwiMHB4XCIsYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6XCIwcHhcIixib3JkZXJCb3R0b21XaWR0aDpcIjNweFwiLGJvcmRlckxlZnRDb2xvcjpcImN1cnJlbnRDb2xvclwiLGJvcmRlckxlZnRXaWR0aDpcIjNweFwiLGJvcmRlclJpZ2h0Q29sb3I6XCJjdXJyZW50Q29sb3JcIixib3JkZXJSaWdodFdpZHRoOlwiM3B4XCIsYm9yZGVyU3BhY2luZzpcIjJweFwiLGJvcmRlclRvcENvbG9yOlwiY3VycmVudENvbG9yXCIsYm9yZGVyVG9wTGVmdFJhZGl1czpcIjBweFwiLGJvcmRlclRvcFJpZ2h0UmFkaXVzOlwiMHB4XCIsYm9yZGVyVG9wV2lkdGg6XCIzcHhcIixib3R0b206XCJhdXRvXCIsY2xpcDpcInJlY3QoMHB4LCAwcHgsIDBweCwgMHB4KVwiLGNvbG9yOlwiYmxhY2tcIixmb250U2l6ZTpcIjEwMCVcIixmb250V2VpZ2h0OlwiNDAwXCIsaGVpZ2h0OlwiYXV0b1wiLGxlZnQ6XCJhdXRvXCIsbGV0dGVyU3BhY2luZzpcIm5vcm1hbFwiLGxpbmVIZWlnaHQ6XCIxMjAlXCIsbWFyZ2luQm90dG9tOlwiMHB4XCIsbWFyZ2luTGVmdDpcIjBweFwiLG1hcmdpblJpZ2h0OlwiMHB4XCIsbWFyZ2luVG9wOlwiMHB4XCIsbWF4SGVpZ2h0Olwibm9uZVwiLG1heFdpZHRoOlwibm9uZVwiLG1pbkhlaWdodDpcIjBweFwiLG1pbldpZHRoOlwiMHB4XCIsb3BhY2l0eTpcIjEuMFwiLG91dGxpbmVDb2xvcjpcImludmVydFwiLG91dGxpbmVPZmZzZXQ6XCIwcHhcIixvdXRsaW5lV2lkdGg6XCIzcHhcIixwYWRkaW5nQm90dG9tOlwiMHB4XCIscGFkZGluZ0xlZnQ6XCIwcHhcIixwYWRkaW5nUmlnaHQ6XCIwcHhcIixwYWRkaW5nVG9wOlwiMHB4XCIscmlnaHQ6XCJhdXRvXCIsdGV4dEluZGVudDpcIjBweFwiLHRleHRTaGFkb3c6XCIwcHggMHB4IDBweCB0cmFuc3BhcmVudFwiLHRvcDpcImF1dG9cIix0cmFuc2Zvcm06XCJcIix2ZXJ0aWNhbEFsaWduOlwiMHB4XCIsdmlzaWJpbGl0eTpcInZpc2libGVcIix3aWR0aDpcImF1dG9cIix3b3JkU3BhY2luZzpcIm5vcm1hbFwiLHpJbmRleDpcImF1dG9cIn07Yi5wcm9wZXJ0eUludGVycG9sYXRpb249Z30oYyxkLGYpLGZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGIpe3ZhciBjPWEuY2FsY3VsYXRlQWN0aXZlRHVyYXRpb24oYiksZD1mdW5jdGlvbihkKXtyZXR1cm4gYS5jYWxjdWxhdGVJdGVyYXRpb25Qcm9ncmVzcyhjLGQsYil9O3JldHVybiBkLl90b3RhbER1cmF0aW9uPWIuZGVsYXkrYytiLmVuZERlbGF5LGR9Yi5LZXlmcmFtZUVmZmVjdD1mdW5jdGlvbihjLGUsZixnKXt2YXIgaCxpPWQoYS5ub3JtYWxpemVUaW1pbmdJbnB1dChmKSksaj1iLmNvbnZlcnRFZmZlY3RJbnB1dChlKSxrPWZ1bmN0aW9uKCl7aihjLGgpfTtyZXR1cm4gay5fdXBkYXRlPWZ1bmN0aW9uKGEpe3JldHVybiBoPWkoYSksbnVsbCE9PWh9LGsuX2NsZWFyPWZ1bmN0aW9uKCl7aihjLG51bGwpfSxrLl9oYXNTYW1lVGFyZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiBjPT09YX0say5fdGFyZ2V0PWMsay5fdG90YWxEdXJhdGlvbj1pLl90b3RhbER1cmF0aW9uLGsuX2lkPWcsa30sYi5OdWxsRWZmZWN0PWZ1bmN0aW9uKGEpe3ZhciBiPWZ1bmN0aW9uKCl7YSYmKGEoKSxhPW51bGwpfTtyZXR1cm4gYi5fdXBkYXRlPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9LGIuX3RvdGFsRHVyYXRpb249MCxiLl9oYXNTYW1lVGFyZ2V0PWZ1bmN0aW9uKCl7cmV0dXJuITF9LGJ9fShjLGQsZiksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYixjKXtjLmVudW1lcmFibGU9ITAsYy5jb25maWd1cmFibGU9ITAsT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYixjKX1mdW5jdGlvbiBkKGEpe3RoaXMuX3N1cnJvZ2F0ZVN0eWxlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcImRpdlwiKS5zdHlsZSx0aGlzLl9zdHlsZT1hLnN0eWxlLHRoaXMuX2xlbmd0aD0wLHRoaXMuX2lzQW5pbWF0ZWRQcm9wZXJ0eT17fTtmb3IodmFyIGI9MDtiPHRoaXMuX3N0eWxlLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuX3N0eWxlW2JdO3RoaXMuX3N1cnJvZ2F0ZVN0eWxlW2NdPXRoaXMuX3N0eWxlW2NdfXRoaXMuX3VwZGF0ZUluZGljZXMoKX1mdW5jdGlvbiBlKGEpe2lmKCFhLl93ZWJBbmltYXRpb25zUGF0Y2hlZFN0eWxlKXt2YXIgYj1uZXcgZChhKTt0cnl7YyhhLFwic3R5bGVcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGJ9fSl9Y2F0Y2goYil7YS5zdHlsZS5fc2V0PWZ1bmN0aW9uKGIsYyl7YS5zdHlsZVtiXT1jfSxhLnN0eWxlLl9jbGVhcj1mdW5jdGlvbihiKXthLnN0eWxlW2JdPVwiXCJ9fWEuX3dlYkFuaW1hdGlvbnNQYXRjaGVkU3R5bGU9YS5zdHlsZX19dmFyIGY9e2Nzc1RleHQ6MSxsZW5ndGg6MSxwYXJlbnRSdWxlOjF9LGc9e2dldFByb3BlcnR5Q1NTVmFsdWU6MSxnZXRQcm9wZXJ0eVByaW9yaXR5OjEsZ2V0UHJvcGVydHlWYWx1ZToxLGl0ZW06MSxyZW1vdmVQcm9wZXJ0eToxLHNldFByb3BlcnR5OjF9LGg9e3JlbW92ZVByb3BlcnR5OjEsc2V0UHJvcGVydHk6MX07ZC5wcm90b3R5cGU9e2dldCBjc3NUZXh0KCl7cmV0dXJuIHRoaXMuX3N1cnJvZ2F0ZVN0eWxlLmNzc1RleHR9LHNldCBjc3NUZXh0KGEpe2Zvcih2YXIgYj17fSxjPTA7Yzx0aGlzLl9zdXJyb2dhdGVTdHlsZS5sZW5ndGg7YysrKWJbdGhpcy5fc3Vycm9nYXRlU3R5bGVbY11dPSEwO3RoaXMuX3N1cnJvZ2F0ZVN0eWxlLmNzc1RleHQ9YSx0aGlzLl91cGRhdGVJbmRpY2VzKCk7Zm9yKHZhciBjPTA7Yzx0aGlzLl9zdXJyb2dhdGVTdHlsZS5sZW5ndGg7YysrKWJbdGhpcy5fc3Vycm9nYXRlU3R5bGVbY11dPSEwO2Zvcih2YXIgZCBpbiBiKXRoaXMuX2lzQW5pbWF0ZWRQcm9wZXJ0eVtkXXx8dGhpcy5fc3R5bGUuc2V0UHJvcGVydHkoZCx0aGlzLl9zdXJyb2dhdGVTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGQpKX0sZ2V0IGxlbmd0aCgpe3JldHVybiB0aGlzLl9zdXJyb2dhdGVTdHlsZS5sZW5ndGh9LGdldCBwYXJlbnRSdWxlKCl7cmV0dXJuIHRoaXMuX3N0eWxlLnBhcmVudFJ1bGV9LF91cGRhdGVJbmRpY2VzOmZ1bmN0aW9uKCl7Zm9yKDt0aGlzLl9sZW5ndGg8dGhpcy5fc3Vycm9nYXRlU3R5bGUubGVuZ3RoOylPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyx0aGlzLl9sZW5ndGgse2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3Vycm9nYXRlU3R5bGVbYV19fSh0aGlzLl9sZW5ndGgpfSksdGhpcy5fbGVuZ3RoKys7Zm9yKDt0aGlzLl9sZW5ndGg+dGhpcy5fc3Vycm9nYXRlU3R5bGUubGVuZ3RoOyl0aGlzLl9sZW5ndGgtLSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyx0aGlzLl9sZW5ndGgse2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiExLHZhbHVlOnZvaWQgMH0pfSxfc2V0OmZ1bmN0aW9uKGEsYil7dGhpcy5fc3R5bGVbYV09Yix0aGlzLl9pc0FuaW1hdGVkUHJvcGVydHlbYV09ITB9LF9jbGVhcjpmdW5jdGlvbihhKXt0aGlzLl9zdHlsZVthXT10aGlzLl9zdXJyb2dhdGVTdHlsZVthXSxkZWxldGUgdGhpcy5faXNBbmltYXRlZFByb3BlcnR5W2FdfX07Zm9yKHZhciBpIGluIGcpZC5wcm90b3R5cGVbaV09ZnVuY3Rpb24oYSxiKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYz10aGlzLl9zdXJyb2dhdGVTdHlsZVthXS5hcHBseSh0aGlzLl9zdXJyb2dhdGVTdHlsZSxhcmd1bWVudHMpO3JldHVybiBiJiYodGhpcy5faXNBbmltYXRlZFByb3BlcnR5W2FyZ3VtZW50c1swXV18fHRoaXMuX3N0eWxlW2FdLmFwcGx5KHRoaXMuX3N0eWxlLGFyZ3VtZW50cyksdGhpcy5fdXBkYXRlSW5kaWNlcygpKSxjfX0oaSxpIGluIGgpO2Zvcih2YXIgaiBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpaiBpbiBmfHxqIGluIGd8fCFmdW5jdGlvbihhKXtjKGQucHJvdG90eXBlLGEse2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdXJyb2dhdGVTdHlsZVthXX0sc2V0OmZ1bmN0aW9uKGIpe3RoaXMuX3N1cnJvZ2F0ZVN0eWxlW2FdPWIsdGhpcy5fdXBkYXRlSW5kaWNlcygpLHRoaXMuX2lzQW5pbWF0ZWRQcm9wZXJ0eVthXXx8KHRoaXMuX3N0eWxlW2FdPWIpfX0pfShqKTthLmFwcGx5PWZ1bmN0aW9uKGIsYyxkKXtlKGIpLGIuc3R5bGUuX3NldChhLnByb3BlcnR5TmFtZShjKSxkKX0sYS5jbGVhcj1mdW5jdGlvbihiLGMpe2IuX3dlYkFuaW1hdGlvbnNQYXRjaGVkU3R5bGUmJmIuc3R5bGUuX2NsZWFyKGEucHJvcGVydHlOYW1lKGMpKX19KGQsZiksZnVuY3Rpb24oYSl7d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmFuaW1hdGU9ZnVuY3Rpb24oYixjKXt2YXIgZD1cIlwiO3JldHVybiBjJiZjLmlkJiYoZD1jLmlkKSxhLnRpbWVsaW5lLl9wbGF5KGEuS2V5ZnJhbWVFZmZlY3QodGhpcyxiLGMsZCkpfX0oZCksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYixkKXtpZihcIm51bWJlclwiPT10eXBlb2YgYSYmXCJudW1iZXJcIj09dHlwZW9mIGIpcmV0dXJuIGEqKDEtZCkrYipkO2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYSYmXCJib29sZWFuXCI9PXR5cGVvZiBiKXJldHVybiBkPC41P2E6YjtpZihhLmxlbmd0aD09Yi5sZW5ndGgpe2Zvcih2YXIgZT1bXSxmPTA7ZjxhLmxlbmd0aDtmKyspZS5wdXNoKGMoYVtmXSxiW2ZdLGQpKTtyZXR1cm4gZX10aHJvd1wiTWlzbWF0Y2hlZCBpbnRlcnBvbGF0aW9uIGFyZ3VtZW50cyBcIithK1wiOlwiK2J9YS5JbnRlcnBvbGF0aW9uPWZ1bmN0aW9uKGEsYixkKXtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIGQoYyhhLGIsZSkpfX19KGQsZiksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYixjKXtyZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4oYSxjKSxiKX1mdW5jdGlvbiBkKGIsZCxlKXt2YXIgZj1hLmRvdChiLGQpO2Y9YyhmLC0xLDEpO3ZhciBnPVtdO2lmKDE9PT1mKWc9YjtlbHNlIGZvcih2YXIgaD1NYXRoLmFjb3MoZiksaT0xKk1hdGguc2luKGUqaCkvTWF0aC5zcXJ0KDEtZipmKSxqPTA7ajw0O2orKylnLnB1c2goYltqXSooTWF0aC5jb3MoZSpoKS1mKmkpK2Rbal0qaSk7cmV0dXJuIGd9dmFyIGU9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYil7Zm9yKHZhciBjPVtbMCwwLDAsMF0sWzAsMCwwLDBdLFswLDAsMCwwXSxbMCwwLDAsMF1dLGQ9MDtkPDQ7ZCsrKWZvcih2YXIgZT0wO2U8NDtlKyspZm9yKHZhciBmPTA7Zjw0O2YrKyljW2RdW2VdKz1iW2RdW2ZdKmFbZl1bZV07cmV0dXJuIGN9ZnVuY3Rpb24gYihhKXtyZXR1cm4gMD09YVswXVsyXSYmMD09YVswXVszXSYmMD09YVsxXVsyXSYmMD09YVsxXVszXSYmMD09YVsyXVswXSYmMD09YVsyXVsxXSYmMT09YVsyXVsyXSYmMD09YVsyXVszXSYmMD09YVszXVsyXSYmMT09YVszXVszXX1mdW5jdGlvbiBjKGMsZCxlLGYsZyl7Zm9yKHZhciBoPVtbMSwwLDAsMF0sWzAsMSwwLDBdLFswLDAsMSwwXSxbMCwwLDAsMV1dLGk9MDtpPDQ7aSsrKWhbaV1bM109Z1tpXTtmb3IodmFyIGk9MDtpPDM7aSsrKWZvcih2YXIgaj0wO2o8MztqKyspaFszXVtpXSs9Y1tqXSpoW2pdW2ldO3ZhciBrPWZbMF0sbD1mWzFdLG09ZlsyXSxuPWZbM10sbz1bWzEsMCwwLDBdLFswLDEsMCwwXSxbMCwwLDEsMF0sWzAsMCwwLDFdXTtvWzBdWzBdPTEtMioobCpsK20qbSksb1swXVsxXT0yKihrKmwtbSpuKSxvWzBdWzJdPTIqKGsqbStsKm4pLG9bMV1bMF09MiooaypsK20qbiksb1sxXVsxXT0xLTIqKGsqayttKm0pLG9bMV1bMl09MioobCptLWsqbiksb1syXVswXT0yKihrKm0tbCpuKSxvWzJdWzFdPTIqKGwqbStrKm4pLG9bMl1bMl09MS0yKihrKmsrbCpsKSxoPWEoaCxvKTt2YXIgcD1bWzEsMCwwLDBdLFswLDEsMCwwXSxbMCwwLDEsMF0sWzAsMCwwLDFdXTtlWzJdJiYocFsyXVsxXT1lWzJdLGg9YShoLHApKSxlWzFdJiYocFsyXVsxXT0wLHBbMl1bMF09ZVswXSxoPWEoaCxwKSksZVswXSYmKHBbMl1bMF09MCxwWzFdWzBdPWVbMF0saD1hKGgscCkpO2Zvcih2YXIgaT0wO2k8MztpKyspZm9yKHZhciBqPTA7ajwzO2orKyloW2ldW2pdKj1kW2ldO3JldHVybiBiKGgpP1toWzBdWzBdLGhbMF1bMV0saFsxXVswXSxoWzFdWzFdLGhbM11bMF0saFszXVsxXV06aFswXS5jb25jYXQoaFsxXSxoWzJdLGhbM10pfXJldHVybiBjfSgpO2EuY29tcG9zZU1hdHJpeD1lLGEucXVhdD1kfShkLGYpLGZ1bmN0aW9uKGEsYixjKXthLnNlcXVlbmNlTnVtYmVyPTA7dmFyIGQ9ZnVuY3Rpb24oYSxiLGMpe3RoaXMudGFyZ2V0PWEsdGhpcy5jdXJyZW50VGltZT1iLHRoaXMudGltZWxpbmVUaW1lPWMsdGhpcy50eXBlPVwiZmluaXNoXCIsdGhpcy5idWJibGVzPSExLHRoaXMuY2FuY2VsYWJsZT0hMSx0aGlzLmN1cnJlbnRUYXJnZXQ9YSx0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITEsdGhpcy5ldmVudFBoYXNlPUV2ZW50LkFUX1RBUkdFVCx0aGlzLnRpbWVTdGFtcD1EYXRlLm5vdygpfTtiLkFuaW1hdGlvbj1mdW5jdGlvbihiKXt0aGlzLmlkPVwiXCIsYiYmYi5faWQmJih0aGlzLmlkPWIuX2lkKSx0aGlzLl9zZXF1ZW5jZU51bWJlcj1hLnNlcXVlbmNlTnVtYmVyKyssdGhpcy5fY3VycmVudFRpbWU9MCx0aGlzLl9zdGFydFRpbWU9bnVsbCx0aGlzLl9wYXVzZWQ9ITEsdGhpcy5fcGxheWJhY2tSYXRlPTEsdGhpcy5faW5UaW1lbGluZT0hMCx0aGlzLl9maW5pc2hlZEZsYWc9ITAsdGhpcy5vbmZpbmlzaD1udWxsLHRoaXMuX2ZpbmlzaEhhbmRsZXJzPVtdLHRoaXMuX2VmZmVjdD1iLHRoaXMuX2luRWZmZWN0PXRoaXMuX2VmZmVjdC5fdXBkYXRlKDApLHRoaXMuX2lkbGU9ITAsdGhpcy5fY3VycmVudFRpbWVQZW5kaW5nPSExfSxiLkFuaW1hdGlvbi5wcm90b3R5cGU9e19lbnN1cmVBbGl2ZTpmdW5jdGlvbigpe3RoaXMucGxheWJhY2tSYXRlPDAmJjA9PT10aGlzLmN1cnJlbnRUaW1lP3RoaXMuX2luRWZmZWN0PXRoaXMuX2VmZmVjdC5fdXBkYXRlKC0xKTp0aGlzLl9pbkVmZmVjdD10aGlzLl9lZmZlY3QuX3VwZGF0ZSh0aGlzLmN1cnJlbnRUaW1lKSx0aGlzLl9pblRpbWVsaW5lfHwhdGhpcy5faW5FZmZlY3QmJnRoaXMuX2ZpbmlzaGVkRmxhZ3x8KHRoaXMuX2luVGltZWxpbmU9ITAsYi50aW1lbGluZS5fYW5pbWF0aW9ucy5wdXNoKHRoaXMpKX0sX3RpY2tDdXJyZW50VGltZTpmdW5jdGlvbihhLGIpe2EhPXRoaXMuX2N1cnJlbnRUaW1lJiYodGhpcy5fY3VycmVudFRpbWU9YSx0aGlzLl9pc0ZpbmlzaGVkJiYhYiYmKHRoaXMuX2N1cnJlbnRUaW1lPXRoaXMuX3BsYXliYWNrUmF0ZT4wP3RoaXMuX3RvdGFsRHVyYXRpb246MCksdGhpcy5fZW5zdXJlQWxpdmUoKSl9LGdldCBjdXJyZW50VGltZSgpe3JldHVybiB0aGlzLl9pZGxlfHx0aGlzLl9jdXJyZW50VGltZVBlbmRpbmc/bnVsbDp0aGlzLl9jdXJyZW50VGltZX0sc2V0IGN1cnJlbnRUaW1lKGEpe2E9K2EsaXNOYU4oYSl8fChiLnJlc3RhcnQoKSx0aGlzLl9wYXVzZWR8fG51bGw9PXRoaXMuX3N0YXJ0VGltZXx8KHRoaXMuX3N0YXJ0VGltZT10aGlzLl90aW1lbGluZS5jdXJyZW50VGltZS1hL3RoaXMuX3BsYXliYWNrUmF0ZSksdGhpcy5fY3VycmVudFRpbWVQZW5kaW5nPSExLHRoaXMuX2N1cnJlbnRUaW1lIT1hJiYodGhpcy5faWRsZSYmKHRoaXMuX2lkbGU9ITEsdGhpcy5fcGF1c2VkPSEwKSx0aGlzLl90aWNrQ3VycmVudFRpbWUoYSwhMCksYi5hcHBseURpcnRpZWRBbmltYXRpb24odGhpcykpKX0sZ2V0IHN0YXJ0VGltZSgpe3JldHVybiB0aGlzLl9zdGFydFRpbWV9LHNldCBzdGFydFRpbWUoYSl7YT0rYSxpc05hTihhKXx8dGhpcy5fcGF1c2VkfHx0aGlzLl9pZGxlfHwodGhpcy5fc3RhcnRUaW1lPWEsdGhpcy5fdGlja0N1cnJlbnRUaW1lKCh0aGlzLl90aW1lbGluZS5jdXJyZW50VGltZS10aGlzLl9zdGFydFRpbWUpKnRoaXMucGxheWJhY2tSYXRlKSxiLmFwcGx5RGlydGllZEFuaW1hdGlvbih0aGlzKSl9LGdldCBwbGF5YmFja1JhdGUoKXtyZXR1cm4gdGhpcy5fcGxheWJhY2tSYXRlfSxzZXQgcGxheWJhY2tSYXRlKGEpe2lmKGEhPXRoaXMuX3BsYXliYWNrUmF0ZSl7dmFyIGM9dGhpcy5jdXJyZW50VGltZTt0aGlzLl9wbGF5YmFja1JhdGU9YSx0aGlzLl9zdGFydFRpbWU9bnVsbCxcInBhdXNlZFwiIT10aGlzLnBsYXlTdGF0ZSYmXCJpZGxlXCIhPXRoaXMucGxheVN0YXRlJiYodGhpcy5fZmluaXNoZWRGbGFnPSExLHRoaXMuX2lkbGU9ITEsdGhpcy5fZW5zdXJlQWxpdmUoKSxiLmFwcGx5RGlydGllZEFuaW1hdGlvbih0aGlzKSksbnVsbCE9YyYmKHRoaXMuY3VycmVudFRpbWU9Yyl9fSxnZXQgX2lzRmluaXNoZWQoKXtyZXR1cm4hdGhpcy5faWRsZSYmKHRoaXMuX3BsYXliYWNrUmF0ZT4wJiZ0aGlzLl9jdXJyZW50VGltZT49dGhpcy5fdG90YWxEdXJhdGlvbnx8dGhpcy5fcGxheWJhY2tSYXRlPDAmJnRoaXMuX2N1cnJlbnRUaW1lPD0wKX0sZ2V0IF90b3RhbER1cmF0aW9uKCl7cmV0dXJuIHRoaXMuX2VmZmVjdC5fdG90YWxEdXJhdGlvbn0sZ2V0IHBsYXlTdGF0ZSgpe3JldHVybiB0aGlzLl9pZGxlP1wiaWRsZVwiOm51bGw9PXRoaXMuX3N0YXJ0VGltZSYmIXRoaXMuX3BhdXNlZCYmMCE9dGhpcy5wbGF5YmFja1JhdGV8fHRoaXMuX2N1cnJlbnRUaW1lUGVuZGluZz9cInBlbmRpbmdcIjp0aGlzLl9wYXVzZWQ/XCJwYXVzZWRcIjp0aGlzLl9pc0ZpbmlzaGVkP1wiZmluaXNoZWRcIjpcInJ1bm5pbmdcIn0sX3Jld2luZDpmdW5jdGlvbigpe2lmKHRoaXMuX3BsYXliYWNrUmF0ZT49MCl0aGlzLl9jdXJyZW50VGltZT0wO2Vsc2V7aWYoISh0aGlzLl90b3RhbER1cmF0aW9uPDEvMCkpdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIlVuYWJsZSB0byByZXdpbmQgbmVnYXRpdmUgcGxheWJhY2sgcmF0ZSBhbmltYXRpb24gd2l0aCBpbmZpbml0ZSBkdXJhdGlvblwiLFwiSW52YWxpZFN0YXRlRXJyb3JcIik7dGhpcy5fY3VycmVudFRpbWU9dGhpcy5fdG90YWxEdXJhdGlvbn19LHBsYXk6ZnVuY3Rpb24oKXt0aGlzLl9wYXVzZWQ9ITEsKHRoaXMuX2lzRmluaXNoZWR8fHRoaXMuX2lkbGUpJiYodGhpcy5fcmV3aW5kKCksdGhpcy5fc3RhcnRUaW1lPW51bGwpLHRoaXMuX2ZpbmlzaGVkRmxhZz0hMSx0aGlzLl9pZGxlPSExLHRoaXMuX2Vuc3VyZUFsaXZlKCksYi5hcHBseURpcnRpZWRBbmltYXRpb24odGhpcyl9LHBhdXNlOmZ1bmN0aW9uKCl7dGhpcy5faXNGaW5pc2hlZHx8dGhpcy5fcGF1c2VkfHx0aGlzLl9pZGxlP3RoaXMuX2lkbGUmJih0aGlzLl9yZXdpbmQoKSx0aGlzLl9pZGxlPSExKTp0aGlzLl9jdXJyZW50VGltZVBlbmRpbmc9ITAsdGhpcy5fc3RhcnRUaW1lPW51bGwsdGhpcy5fcGF1c2VkPSEwfSxmaW5pc2g6ZnVuY3Rpb24oKXt0aGlzLl9pZGxlfHwodGhpcy5jdXJyZW50VGltZT10aGlzLl9wbGF5YmFja1JhdGU+MD90aGlzLl90b3RhbER1cmF0aW9uOjAsdGhpcy5fc3RhcnRUaW1lPXRoaXMuX3RvdGFsRHVyYXRpb24tdGhpcy5jdXJyZW50VGltZSx0aGlzLl9jdXJyZW50VGltZVBlbmRpbmc9ITEsYi5hcHBseURpcnRpZWRBbmltYXRpb24odGhpcykpfSxjYW5jZWw6ZnVuY3Rpb24oKXt0aGlzLl9pbkVmZmVjdCYmKHRoaXMuX2luRWZmZWN0PSExLHRoaXMuX2lkbGU9ITAsdGhpcy5fcGF1c2VkPSExLHRoaXMuX2lzRmluaXNoZWQ9ITAsdGhpcy5fZmluaXNoZWRGbGFnPSEwLHRoaXMuX2N1cnJlbnRUaW1lPTAsdGhpcy5fc3RhcnRUaW1lPW51bGwsdGhpcy5fZWZmZWN0Ll91cGRhdGUobnVsbCksYi5hcHBseURpcnRpZWRBbmltYXRpb24odGhpcykpfSxyZXZlcnNlOmZ1bmN0aW9uKCl7dGhpcy5wbGF5YmFja1JhdGUqPS0xLHRoaXMucGxheSgpfSxhZGRFdmVudExpc3RlbmVyOmZ1bmN0aW9uKGEsYil7XCJmdW5jdGlvblwiPT10eXBlb2YgYiYmXCJmaW5pc2hcIj09YSYmdGhpcy5fZmluaXNoSGFuZGxlcnMucHVzaChiKX0scmVtb3ZlRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbihhLGIpe2lmKFwiZmluaXNoXCI9PWEpe3ZhciBjPXRoaXMuX2ZpbmlzaEhhbmRsZXJzLmluZGV4T2YoYik7Yz49MCYmdGhpcy5fZmluaXNoSGFuZGxlcnMuc3BsaWNlKGMsMSl9fSxfZmlyZUV2ZW50czpmdW5jdGlvbihhKXtpZih0aGlzLl9pc0ZpbmlzaGVkKXtpZighdGhpcy5fZmluaXNoZWRGbGFnKXt2YXIgYj1uZXcgZCh0aGlzLHRoaXMuX2N1cnJlbnRUaW1lLGEpLGM9dGhpcy5fZmluaXNoSGFuZGxlcnMuY29uY2F0KHRoaXMub25maW5pc2g/W3RoaXMub25maW5pc2hdOltdKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuY2FsbChiLnRhcmdldCxiKX0pfSwwKSx0aGlzLl9maW5pc2hlZEZsYWc9ITB9fWVsc2UgdGhpcy5fZmluaXNoZWRGbGFnPSExfSxfdGljazpmdW5jdGlvbihhLGIpe3RoaXMuX2lkbGV8fHRoaXMuX3BhdXNlZHx8KG51bGw9PXRoaXMuX3N0YXJ0VGltZT9iJiYodGhpcy5zdGFydFRpbWU9YS10aGlzLl9jdXJyZW50VGltZS90aGlzLnBsYXliYWNrUmF0ZSk6dGhpcy5faXNGaW5pc2hlZHx8dGhpcy5fdGlja0N1cnJlbnRUaW1lKChhLXRoaXMuX3N0YXJ0VGltZSkqdGhpcy5wbGF5YmFja1JhdGUpKSxiJiYodGhpcy5fY3VycmVudFRpbWVQZW5kaW5nPSExLHRoaXMuX2ZpcmVFdmVudHMoYSkpfSxnZXQgX25lZWRzVGljaygpe3JldHVybiB0aGlzLnBsYXlTdGF0ZSBpbntwZW5kaW5nOjEscnVubmluZzoxfXx8IXRoaXMuX2ZpbmlzaGVkRmxhZ30sX3RhcmdldEFuaW1hdGlvbnM6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9lZmZlY3QuX3RhcmdldDtyZXR1cm4gYS5fYWN0aXZlQW5pbWF0aW9uc3x8KGEuX2FjdGl2ZUFuaW1hdGlvbnM9W10pLGEuX2FjdGl2ZUFuaW1hdGlvbnN9LF9tYXJrVGFyZ2V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fdGFyZ2V0QW5pbWF0aW9ucygpO2EuaW5kZXhPZih0aGlzKT09PS0xJiZhLnB1c2godGhpcyl9LF91bm1hcmtUYXJnZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl90YXJnZXRBbmltYXRpb25zKCksYj1hLmluZGV4T2YodGhpcyk7YiE9PS0xJiZhLnNwbGljZShiLDEpfX19KGMsZCxmKSxmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXt2YXIgYj1qO2o9W10sYTxxLmN1cnJlbnRUaW1lJiYoYT1xLmN1cnJlbnRUaW1lKSxxLl9hbmltYXRpb25zLnNvcnQoZSkscS5fYW5pbWF0aW9ucz1oKGEsITAscS5fYW5pbWF0aW9ucylbMF0sYi5mb3JFYWNoKGZ1bmN0aW9uKGIpe2JbMV0oYSl9KSxnKCksbD12b2lkIDB9ZnVuY3Rpb24gZShhLGIpe3JldHVybiBhLl9zZXF1ZW5jZU51bWJlci1iLl9zZXF1ZW5jZU51bWJlcn1mdW5jdGlvbiBmKCl7dGhpcy5fYW5pbWF0aW9ucz1bXSx0aGlzLmN1cnJlbnRUaW1lPXdpbmRvdy5wZXJmb3JtYW5jZSYmcGVyZm9ybWFuY2Uubm93P3BlcmZvcm1hbmNlLm5vdygpOjB9ZnVuY3Rpb24gZygpe28uZm9yRWFjaChmdW5jdGlvbihhKXthKCl9KSxvLmxlbmd0aD0wfWZ1bmN0aW9uIGgoYSxjLGQpe3A9ITAsbj0hMTt2YXIgZT1iLnRpbWVsaW5lO2UuY3VycmVudFRpbWU9YSxtPSExO3ZhciBmPVtdLGc9W10saD1bXSxpPVtdO3JldHVybiBkLmZvckVhY2goZnVuY3Rpb24oYil7Yi5fdGljayhhLGMpLGIuX2luRWZmZWN0PyhnLnB1c2goYi5fZWZmZWN0KSxiLl9tYXJrVGFyZ2V0KCkpOihmLnB1c2goYi5fZWZmZWN0KSxiLl91bm1hcmtUYXJnZXQoKSksYi5fbmVlZHNUaWNrJiYobT0hMCk7dmFyIGQ9Yi5faW5FZmZlY3R8fGIuX25lZWRzVGljaztiLl9pblRpbWVsaW5lPWQsZD9oLnB1c2goYik6aS5wdXNoKGIpfSksby5wdXNoLmFwcGx5KG8sZiksby5wdXNoLmFwcGx5KG8sZyksbSYmcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7fSkscD0hMSxbaCxpXX12YXIgaT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLGo9W10saz0wO3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9ZnVuY3Rpb24oYSl7dmFyIGI9aysrO3JldHVybiAwPT1qLmxlbmd0aCYmaShkKSxqLnB1c2goW2IsYV0pLGJ9LHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZT1mdW5jdGlvbihhKXtqLmZvckVhY2goZnVuY3Rpb24oYil7YlswXT09YSYmKGJbMV09ZnVuY3Rpb24oKXt9KX0pfSxmLnByb3RvdHlwZT17X3BsYXk6ZnVuY3Rpb24oYyl7Yy5fdGltaW5nPWEubm9ybWFsaXplVGltaW5nSW5wdXQoYy50aW1pbmcpO3ZhciBkPW5ldyBiLkFuaW1hdGlvbihjKTtyZXR1cm4gZC5faWRsZT0hMSxkLl90aW1lbGluZT10aGlzLHRoaXMuX2FuaW1hdGlvbnMucHVzaChkKSxiLnJlc3RhcnQoKSxiLmFwcGx5RGlydGllZEFuaW1hdGlvbihkKSxkfX07dmFyIGw9dm9pZCAwLG09ITEsbj0hMTtiLnJlc3RhcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gbXx8KG09ITAscmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7fSksbj0hMCksbn0sYi5hcHBseURpcnRpZWRBbmltYXRpb249ZnVuY3Rpb24oYSl7aWYoIXApe2EuX21hcmtUYXJnZXQoKTt2YXIgYz1hLl90YXJnZXRBbmltYXRpb25zKCk7Yy5zb3J0KGUpO3ZhciBkPWgoYi50aW1lbGluZS5jdXJyZW50VGltZSwhMSxjLnNsaWNlKCkpWzFdO2QuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1xLl9hbmltYXRpb25zLmluZGV4T2YoYSk7YiE9PS0xJiZxLl9hbmltYXRpb25zLnNwbGljZShiLDEpfSksZygpfX07dmFyIG89W10scD0hMSxxPW5ldyBmO2IudGltZWxpbmU9cX0oYyxkLGYpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIpe2Zvcih2YXIgYz0wLGQ9MDtkPGEubGVuZ3RoO2QrKyljKz1hW2RdKmJbZF07cmV0dXJuIGN9ZnVuY3Rpb24gZChhLGIpe3JldHVyblthWzBdKmJbMF0rYVs0XSpiWzFdK2FbOF0qYlsyXSthWzEyXSpiWzNdLGFbMV0qYlswXSthWzVdKmJbMV0rYVs5XSpiWzJdK2FbMTNdKmJbM10sYVsyXSpiWzBdK2FbNl0qYlsxXSthWzEwXSpiWzJdK2FbMTRdKmJbM10sYVszXSpiWzBdK2FbN10qYlsxXSthWzExXSpiWzJdK2FbMTVdKmJbM10sYVswXSpiWzRdK2FbNF0qYls1XSthWzhdKmJbNl0rYVsxMl0qYls3XSxhWzFdKmJbNF0rYVs1XSpiWzVdK2FbOV0qYls2XSthWzEzXSpiWzddLGFbMl0qYls0XSthWzZdKmJbNV0rYVsxMF0qYls2XSthWzE0XSpiWzddLGFbM10qYls0XSthWzddKmJbNV0rYVsxMV0qYls2XSthWzE1XSpiWzddLGFbMF0qYls4XSthWzRdKmJbOV0rYVs4XSpiWzEwXSthWzEyXSpiWzExXSxhWzFdKmJbOF0rYVs1XSpiWzldK2FbOV0qYlsxMF0rYVsxM10qYlsxMV0sYVsyXSpiWzhdK2FbNl0qYls5XSthWzEwXSpiWzEwXSthWzE0XSpiWzExXSxhWzNdKmJbOF0rYVs3XSpiWzldK2FbMTFdKmJbMTBdK2FbMTVdKmJbMTFdLGFbMF0qYlsxMl0rYVs0XSpiWzEzXSthWzhdKmJbMTRdK2FbMTJdKmJbMTVdLGFbMV0qYlsxMl0rYVs1XSpiWzEzXSthWzldKmJbMTRdK2FbMTNdKmJbMTVdLGFbMl0qYlsxMl0rYVs2XSpiWzEzXSthWzEwXSpiWzE0XSthWzE0XSpiWzE1XSxhWzNdKmJbMTJdK2FbN10qYlsxM10rYVsxMV0qYlsxNF0rYVsxNV0qYlsxNV1dfWZ1bmN0aW9uIGUoYSl7dmFyIGI9YS5yYWR8fDAsYz1hLmRlZ3x8MCxkPWEuZ3JhZHx8MCxlPWEudHVybnx8MCxmPShjLzM2MCtkLzQwMCtlKSooMipNYXRoLlBJKStiO3JldHVybiBmfWZ1bmN0aW9uIGYoYSl7c3dpdGNoKGEudCl7Y2FzZVwicm90YXRleFwiOnZhciBiPWUoYS5kWzBdKTtyZXR1cm5bMSwwLDAsMCwwLE1hdGguY29zKGIpLE1hdGguc2luKGIpLDAsMCwtTWF0aC5zaW4oYiksTWF0aC5jb3MoYiksMCwwLDAsMCwxXTtjYXNlXCJyb3RhdGV5XCI6dmFyIGI9ZShhLmRbMF0pO3JldHVybltNYXRoLmNvcyhiKSwwLC1NYXRoLnNpbihiKSwwLDAsMSwwLDAsTWF0aC5zaW4oYiksMCxNYXRoLmNvcyhiKSwwLDAsMCwwLDFdO2Nhc2VcInJvdGF0ZVwiOmNhc2VcInJvdGF0ZXpcIjp2YXIgYj1lKGEuZFswXSk7cmV0dXJuW01hdGguY29zKGIpLE1hdGguc2luKGIpLDAsMCwtTWF0aC5zaW4oYiksTWF0aC5jb3MoYiksMCwwLDAsMCwxLDAsMCwwLDAsMV07Y2FzZVwicm90YXRlM2RcIjp2YXIgYz1hLmRbMF0sZD1hLmRbMV0sZj1hLmRbMl0sYj1lKGEuZFszXSksZz1jKmMrZCpkK2YqZjtpZigwPT09ZyljPTEsZD0wLGY9MDtlbHNlIGlmKDEhPT1nKXt2YXIgaD1NYXRoLnNxcnQoZyk7Yy89aCxkLz1oLGYvPWh9dmFyIGk9TWF0aC5zaW4oYi8yKSxqPWkqTWF0aC5jb3MoYi8yKSxrPWkqaTtyZXR1cm5bMS0yKihkKmQrZipmKSprLDIqKGMqZCprK2YqaiksMiooYypmKmstZCpqKSwwLDIqKGMqZCprLWYqaiksMS0yKihjKmMrZipmKSprLDIqKGQqZiprK2MqaiksMCwyKihjKmYqaytkKmopLDIqKGQqZiprLWMqaiksMS0yKihjKmMrZCpkKSprLDAsMCwwLDAsMV07Y2FzZVwic2NhbGVcIjpyZXR1cm5bYS5kWzBdLDAsMCwwLDAsYS5kWzFdLDAsMCwwLDAsMSwwLDAsMCwwLDFdO2Nhc2VcInNjYWxleFwiOnJldHVyblthLmRbMF0sMCwwLDAsMCwxLDAsMCwwLDAsMSwwLDAsMCwwLDFdO2Nhc2VcInNjYWxleVwiOnJldHVyblsxLDAsMCwwLDAsYS5kWzBdLDAsMCwwLDAsMSwwLDAsMCwwLDFdO2Nhc2VcInNjYWxlelwiOnJldHVyblsxLDAsMCwwLDAsMSwwLDAsMCwwLGEuZFswXSwwLDAsMCwwLDFdO2Nhc2VcInNjYWxlM2RcIjpyZXR1cm5bYS5kWzBdLDAsMCwwLDAsYS5kWzFdLDAsMCwwLDAsYS5kWzJdLDAsMCwwLDAsMV07Y2FzZVwic2tld1wiOnZhciBsPWUoYS5kWzBdKSxtPWUoYS5kWzFdKTtyZXR1cm5bMSxNYXRoLnRhbihtKSwwLDAsTWF0aC50YW4obCksMSwwLDAsMCwwLDEsMCwwLDAsMCwxXTtjYXNlXCJza2V3eFwiOnZhciBiPWUoYS5kWzBdKTtyZXR1cm5bMSwwLDAsMCxNYXRoLnRhbihiKSwxLDAsMCwwLDAsMSwwLDAsMCwwLDFdO2Nhc2VcInNrZXd5XCI6dmFyIGI9ZShhLmRbMF0pO3JldHVyblsxLE1hdGgudGFuKGIpLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMV07Y2FzZVwidHJhbnNsYXRlXCI6dmFyIGM9YS5kWzBdLnB4fHwwLGQ9YS5kWzFdLnB4fHwwO3JldHVyblsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCxjLGQsMCwxXTtjYXNlXCJ0cmFuc2xhdGV4XCI6dmFyIGM9YS5kWzBdLnB4fHwwO3JldHVyblsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCxjLDAsMCwxXTtjYXNlXCJ0cmFuc2xhdGV5XCI6dmFyIGQ9YS5kWzBdLnB4fHwwO3JldHVyblsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLGQsMCwxXTtjYXNlXCJ0cmFuc2xhdGV6XCI6dmFyIGY9YS5kWzBdLnB4fHwwO3JldHVyblsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsZiwxXTtjYXNlXCJ0cmFuc2xhdGUzZFwiOnZhciBjPWEuZFswXS5weHx8MCxkPWEuZFsxXS5weHx8MCxmPWEuZFsyXS5weHx8MDtyZXR1cm5bMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsYyxkLGYsMV07Y2FzZVwicGVyc3BlY3RpdmVcIjp2YXIgbj1hLmRbMF0ucHg/LTEvYS5kWzBdLnB4OjA7cmV0dXJuWzEsMCwwLDAsMCwxLDAsMCwwLDAsMSxuLDAsMCwwLDFdO2Nhc2VcIm1hdHJpeFwiOnJldHVyblthLmRbMF0sYS5kWzFdLDAsMCxhLmRbMl0sYS5kWzNdLDAsMCwwLDAsMSwwLGEuZFs0XSxhLmRbNV0sMCwxXTtjYXNlXCJtYXRyaXgzZFwiOnJldHVybiBhLmR9fWZ1bmN0aW9uIGcoYSl7cmV0dXJuIDA9PT1hLmxlbmd0aD9bMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMV06YS5tYXAoZikucmVkdWNlKGQpfWZ1bmN0aW9uIGgoYSl7cmV0dXJuW2koZyhhKSldfXZhciBpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXtyZXR1cm4gYVswXVswXSphWzFdWzFdKmFbMl1bMl0rYVsxXVswXSphWzJdWzFdKmFbMF1bMl0rYVsyXVswXSphWzBdWzFdKmFbMV1bMl0tYVswXVsyXSphWzFdWzFdKmFbMl1bMF0tYVsxXVsyXSphWzJdWzFdKmFbMF1bMF0tYVsyXVsyXSphWzBdWzFdKmFbMV1bMF19ZnVuY3Rpb24gYihiKXtmb3IodmFyIGM9MS9hKGIpLGQ9YlswXVswXSxlPWJbMF1bMV0sZj1iWzBdWzJdLGc9YlsxXVswXSxoPWJbMV1bMV0saT1iWzFdWzJdLGo9YlsyXVswXSxrPWJbMl1bMV0sbD1iWzJdWzJdLG09W1soaCpsLWkqaykqYywoZiprLWUqbCkqYywoZSppLWYqaCkqYywwXSxbKGkqai1nKmwpKmMsKGQqbC1mKmopKmMsKGYqZy1kKmkpKmMsMF0sWyhnKmstaCpqKSpjLChqKmUtZCprKSpjLChkKmgtZSpnKSpjLDBdXSxuPVtdLG89MDtvPDM7bysrKXtmb3IodmFyIHA9MCxxPTA7cTwzO3ErKylwKz1iWzNdW3FdKm1bcV1bb107bi5wdXNoKHApfXJldHVybiBuLnB1c2goMSksbS5wdXNoKG4pLG19ZnVuY3Rpb24gZChhKXtyZXR1cm5bW2FbMF1bMF0sYVsxXVswXSxhWzJdWzBdLGFbM11bMF1dLFthWzBdWzFdLGFbMV1bMV0sYVsyXVsxXSxhWzNdWzFdXSxbYVswXVsyXSxhWzFdWzJdLGFbMl1bMl0sYVszXVsyXV0sW2FbMF1bM10sYVsxXVszXSxhWzJdWzNdLGFbM11bM11dXX1mdW5jdGlvbiBlKGEsYil7Zm9yKHZhciBjPVtdLGQ9MDtkPDQ7ZCsrKXtmb3IodmFyIGU9MCxmPTA7Zjw0O2YrKyllKz1hW2ZdKmJbZl1bZF07Yy5wdXNoKGUpfXJldHVybiBjfWZ1bmN0aW9uIGYoYSl7dmFyIGI9ZyhhKTtyZXR1cm5bYVswXS9iLGFbMV0vYixhWzJdL2JdfWZ1bmN0aW9uIGcoYSl7cmV0dXJuIE1hdGguc3FydChhWzBdKmFbMF0rYVsxXSphWzFdK2FbMl0qYVsyXSl9ZnVuY3Rpb24gaChhLGIsYyxkKXtyZXR1cm5bYyphWzBdK2QqYlswXSxjKmFbMV0rZCpiWzFdLGMqYVsyXStkKmJbMl1dfWZ1bmN0aW9uIGkoYSxiKXtyZXR1cm5bYVsxXSpiWzJdLWFbMl0qYlsxXSxhWzJdKmJbMF0tYVswXSpiWzJdLGFbMF0qYlsxXS1hWzFdKmJbMF1dfWZ1bmN0aW9uIGooail7dmFyIGs9W2ouc2xpY2UoMCw0KSxqLnNsaWNlKDQsOCksai5zbGljZSg4LDEyKSxqLnNsaWNlKDEyLDE2KV07aWYoMSE9PWtbM11bM10pcmV0dXJuIG51bGw7Zm9yKHZhciBsPVtdLG09MDttPDQ7bSsrKWwucHVzaChrW21dLnNsaWNlKCkpO2Zvcih2YXIgbT0wO208MzttKyspbFttXVszXT0wO2lmKDA9PT1hKGwpKXJldHVybiExO3ZhciBuLG89W107aWYoa1swXVszXXx8a1sxXVszXXx8a1syXVszXSl7by5wdXNoKGtbMF1bM10pLG8ucHVzaChrWzFdWzNdKSxvLnB1c2goa1syXVszXSksby5wdXNoKGtbM11bM10pO3ZhciBwPWIobCkscT1kKHApO249ZShvLHEpfWVsc2Ugbj1bMCwwLDAsMV07dmFyIHI9a1szXS5zbGljZSgwLDMpLHM9W107cy5wdXNoKGtbMF0uc2xpY2UoMCwzKSk7dmFyIHQ9W107dC5wdXNoKGcoc1swXSkpLHNbMF09ZihzWzBdKTt2YXIgdT1bXTtzLnB1c2goa1sxXS5zbGljZSgwLDMpKSx1LnB1c2goYyhzWzBdLHNbMV0pKSxzWzFdPWgoc1sxXSxzWzBdLDEsLXVbMF0pLHQucHVzaChnKHNbMV0pKSxzWzFdPWYoc1sxXSksdVswXS89dFsxXSxzLnB1c2goa1syXS5zbGljZSgwLDMpKSx1LnB1c2goYyhzWzBdLHNbMl0pKSxzWzJdPWgoc1syXSxzWzBdLDEsLXVbMV0pLHUucHVzaChjKHNbMV0sc1syXSkpLHNbMl09aChzWzJdLHNbMV0sMSwtdVsyXSksdC5wdXNoKGcoc1syXSkpLHNbMl09ZihzWzJdKSx1WzFdLz10WzJdLHVbMl0vPXRbMl07dmFyIHY9aShzWzFdLHNbMl0pO2lmKGMoc1swXSx2KTwwKWZvcih2YXIgbT0wO208MzttKyspdFttXSo9LTEsc1ttXVswXSo9LTEsc1ttXVsxXSo9LTEsc1ttXVsyXSo9LTE7dmFyIHcseCx5PXNbMF1bMF0rc1sxXVsxXStzWzJdWzJdKzE7cmV0dXJuIHk+MWUtND8odz0uNS9NYXRoLnNxcnQoeSkseD1bKHNbMl1bMV0tc1sxXVsyXSkqdywoc1swXVsyXS1zWzJdWzBdKSp3LChzWzFdWzBdLXNbMF1bMV0pKncsLjI1L3ddKTpzWzBdWzBdPnNbMV1bMV0mJnNbMF1bMF0+c1syXVsyXT8odz0yKk1hdGguc3FydCgxK3NbMF1bMF0tc1sxXVsxXS1zWzJdWzJdKSx4PVsuMjUqdywoc1swXVsxXStzWzFdWzBdKS93LChzWzBdWzJdK3NbMl1bMF0pL3csKHNbMl1bMV0tc1sxXVsyXSkvd10pOnNbMV1bMV0+c1syXVsyXT8odz0yKk1hdGguc3FydCgxK3NbMV1bMV0tc1swXVswXS1zWzJdWzJdKSx4PVsoc1swXVsxXStzWzFdWzBdKS93LC4yNSp3LChzWzFdWzJdK3NbMl1bMV0pL3csKHNbMF1bMl0tc1syXVswXSkvd10pOih3PTIqTWF0aC5zcXJ0KDErc1syXVsyXS1zWzBdWzBdLXNbMV1bMV0pLHg9WyhzWzBdWzJdK3NbMl1bMF0pL3csKHNbMV1bMl0rc1syXVsxXSkvdywuMjUqdywoc1sxXVswXS1zWzBdWzFdKS93XSksW3IsdCx1LHgsbl19cmV0dXJuIGp9KCk7YS5kb3Q9YyxhLm1ha2VNYXRyaXhEZWNvbXBvc2l0aW9uPWh9KGQsZiksZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhLGIpe3ZhciBjPWEuZXhlYyhiKTtpZihjKXJldHVybiBjPWEuaWdub3JlQ2FzZT9jWzBdLnRvTG93ZXJDYXNlKCk6Y1swXSxbYyxiLnN1YnN0cihjLmxlbmd0aCldfWZ1bmN0aW9uIGMoYSxiKXtiPWIucmVwbGFjZSgvXlxccyovLFwiXCIpO3ZhciBjPWEoYik7aWYoYylyZXR1cm5bY1swXSxjWzFdLnJlcGxhY2UoL15cXHMqLyxcIlwiKV19ZnVuY3Rpb24gZChhLGQsZSl7YT1jLmJpbmQobnVsbCxhKTtmb3IodmFyIGY9W107Oyl7dmFyIGc9YShlKTtpZighZylyZXR1cm5bZixlXTtpZihmLnB1c2goZ1swXSksZT1nWzFdLGc9YihkLGUpLCFnfHxcIlwiPT1nWzFdKXJldHVybltmLGVdO2U9Z1sxXX19ZnVuY3Rpb24gZShhLGIpe2Zvcih2YXIgYz0wLGQ9MDtkPGIubGVuZ3RoJiYoIS9cXHN8LC8udGVzdChiW2RdKXx8MCE9Yyk7ZCsrKWlmKFwiKFwiPT1iW2RdKWMrKztlbHNlIGlmKFwiKVwiPT1iW2RdJiYoYy0tLDA9PWMmJmQrKyxjPD0wKSlicmVhazt2YXIgZT1hKGIuc3Vic3RyKDAsZCkpO3JldHVybiB2b2lkIDA9PWU/dm9pZCAwOltlLGIuc3Vic3RyKGQpXX1mdW5jdGlvbiBmKGEsYil7Zm9yKHZhciBjPWEsZD1iO2MmJmQ7KWM+ZD9jJT1kOmQlPWM7cmV0dXJuIGM9YSpiLyhjK2QpfWZ1bmN0aW9uIGcoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBjPWEoYik7cmV0dXJuIGMmJihjWzBdPXZvaWQgMCksY319ZnVuY3Rpb24gaChhLGIpe3JldHVybiBmdW5jdGlvbihjKXt2YXIgZD1hKGMpO3JldHVybiBkP2Q6W2IsY119fWZ1bmN0aW9uIGkoYixjKXtmb3IodmFyIGQ9W10sZT0wO2U8Yi5sZW5ndGg7ZSsrKXt2YXIgZj1hLmNvbnN1bWVUcmltbWVkKGJbZV0sYyk7aWYoIWZ8fFwiXCI9PWZbMF0pcmV0dXJuO3ZvaWQgMCE9PWZbMF0mJmQucHVzaChmWzBdKSxjPWZbMV19aWYoXCJcIj09YylyZXR1cm4gZH1mdW5jdGlvbiBqKGEsYixjLGQsZSl7Zm9yKHZhciBnPVtdLGg9W10saT1bXSxqPWYoZC5sZW5ndGgsZS5sZW5ndGgpLGs9MDtrPGo7aysrKXt2YXIgbD1iKGRbayVkLmxlbmd0aF0sZVtrJWUubGVuZ3RoXSk7aWYoIWwpcmV0dXJuO2cucHVzaChsWzBdKSxoLnB1c2gobFsxXSksaS5wdXNoKGxbMl0pfXJldHVybltnLGgsZnVuY3Rpb24oYil7dmFyIGQ9Yi5tYXAoZnVuY3Rpb24oYSxiKXtyZXR1cm4gaVtiXShhKX0pLmpvaW4oYyk7cmV0dXJuIGE/YShkKTpkfV19ZnVuY3Rpb24gayhhLGIsYyl7Zm9yKHZhciBkPVtdLGU9W10sZj1bXSxnPTAsaD0wO2g8Yy5sZW5ndGg7aCsrKWlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGNbaF0pe3ZhciBpPWNbaF0oYVtnXSxiW2crK10pO2QucHVzaChpWzBdKSxlLnB1c2goaVsxXSksZi5wdXNoKGlbMl0pfWVsc2UhZnVuY3Rpb24oYSl7ZC5wdXNoKCExKSxlLnB1c2goITEpLGYucHVzaChmdW5jdGlvbigpe3JldHVybiBjW2FdfSl9KGgpO3JldHVybltkLGUsZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVwiXCIsYz0wO2M8YS5sZW5ndGg7YysrKWIrPWZbY10oYVtjXSk7cmV0dXJuIGJ9XX1hLmNvbnN1bWVUb2tlbj1iLGEuY29uc3VtZVRyaW1tZWQ9YyxhLmNvbnN1bWVSZXBlYXRlZD1kLGEuY29uc3VtZVBhcmVudGhlc2lzZWQ9ZSxhLmlnbm9yZT1nLGEub3B0aW9uYWw9aCxhLmNvbnN1bWVMaXN0PWksYS5tZXJnZU5lc3RlZFJlcGVhdGVkPWouYmluZChudWxsLG51bGwpLGEubWVyZ2VXcmFwcGVkTmVzdGVkUmVwZWF0ZWQ9aixhLm1lcmdlTGlzdD1rfShkKSxmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIpe2Z1bmN0aW9uIGMoYil7dmFyIGM9YS5jb25zdW1lVG9rZW4oL15pbnNldC9pLGIpO2lmKGMpcmV0dXJuIGQuaW5zZXQ9ITAsYzt2YXIgYz1hLmNvbnN1bWVMZW5ndGhPclBlcmNlbnQoYik7aWYoYylyZXR1cm4gZC5sZW5ndGhzLnB1c2goY1swXSksYzt2YXIgYz1hLmNvbnN1bWVDb2xvcihiKTtyZXR1cm4gYz8oZC5jb2xvcj1jWzBdLGMpOnZvaWQgMH12YXIgZD17aW5zZXQ6ITEsbGVuZ3RoczpbXSxjb2xvcjpudWxsfSxlPWEuY29uc3VtZVJlcGVhdGVkKGMsL14vLGIpO2lmKGUmJmVbMF0ubGVuZ3RoKXJldHVybltkLGVbMV1dfWZ1bmN0aW9uIGMoYyl7dmFyIGQ9YS5jb25zdW1lUmVwZWF0ZWQoYiwvXiwvLGMpO2lmKGQmJlwiXCI9PWRbMV0pcmV0dXJuIGRbMF19ZnVuY3Rpb24gZChiLGMpe2Zvcig7Yi5sZW5ndGhzLmxlbmd0aDxNYXRoLm1heChiLmxlbmd0aHMubGVuZ3RoLGMubGVuZ3Rocy5sZW5ndGgpOyliLmxlbmd0aHMucHVzaCh7cHg6MH0pO2Zvcig7Yy5sZW5ndGhzLmxlbmd0aDxNYXRoLm1heChiLmxlbmd0aHMubGVuZ3RoLGMubGVuZ3Rocy5sZW5ndGgpOyljLmxlbmd0aHMucHVzaCh7cHg6MH0pO2lmKGIuaW5zZXQ9PWMuaW5zZXQmJiEhYi5jb2xvcj09ISFjLmNvbG9yKXtmb3IodmFyIGQsZT1bXSxmPVtbXSwwXSxnPVtbXSwwXSxoPTA7aDxiLmxlbmd0aHMubGVuZ3RoO2grKyl7dmFyIGk9YS5tZXJnZURpbWVuc2lvbnMoYi5sZW5ndGhzW2hdLGMubGVuZ3Roc1toXSwyPT1oKTtmWzBdLnB1c2goaVswXSksZ1swXS5wdXNoKGlbMV0pLGUucHVzaChpWzJdKX1pZihiLmNvbG9yJiZjLmNvbG9yKXt2YXIgaj1hLm1lcmdlQ29sb3JzKGIuY29sb3IsYy5jb2xvcik7ZlsxXT1qWzBdLGdbMV09alsxXSxkPWpbMl07XG59cmV0dXJuW2YsZyxmdW5jdGlvbihhKXtmb3IodmFyIGM9Yi5pbnNldD9cImluc2V0IFwiOlwiIFwiLGY9MDtmPGUubGVuZ3RoO2YrKyljKz1lW2ZdKGFbMF1bZl0pK1wiIFwiO3JldHVybiBkJiYoYys9ZChhWzFdKSksY31dfX1mdW5jdGlvbiBlKGIsYyxkLGUpe2Z1bmN0aW9uIGYoYSl7cmV0dXJue2luc2V0OmEsY29sb3I6WzAsMCwwLDBdLGxlbmd0aHM6W3tweDowfSx7cHg6MH0se3B4OjB9LHtweDowfV19fWZvcih2YXIgZz1bXSxoPVtdLGk9MDtpPGQubGVuZ3RofHxpPGUubGVuZ3RoO2krKyl7dmFyIGo9ZFtpXXx8ZihlW2ldLmluc2V0KSxrPWVbaV18fGYoZFtpXS5pbnNldCk7Zy5wdXNoKGopLGgucHVzaChrKX1yZXR1cm4gYS5tZXJnZU5lc3RlZFJlcGVhdGVkKGIsYyxnLGgpfXZhciBmPWUuYmluZChudWxsLGQsXCIsIFwiKTthLmFkZFByb3BlcnRpZXNIYW5kbGVyKGMsZixbXCJib3gtc2hhZG93XCIsXCJ0ZXh0LXNoYWRvd1wiXSl9KGQpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gYS50b0ZpeGVkKDMpLnJlcGxhY2UoXCIuMDAwXCIsXCJcIil9ZnVuY3Rpb24gZChhLGIsYyl7cmV0dXJuIE1hdGgubWluKGIsTWF0aC5tYXgoYSxjKSl9ZnVuY3Rpb24gZShhKXtpZigvXlxccypbLStdPyhcXGQqXFwuKT9cXGQrXFxzKiQvLnRlc3QoYSkpcmV0dXJuIE51bWJlcihhKX1mdW5jdGlvbiBmKGEsYil7cmV0dXJuW2EsYixjXX1mdW5jdGlvbiBnKGEsYil7aWYoMCE9YSlyZXR1cm4gaSgwLDEvMCkoYSxiKX1mdW5jdGlvbiBoKGEsYil7cmV0dXJuW2EsYixmdW5jdGlvbihhKXtyZXR1cm4gTWF0aC5yb3VuZChkKDEsMS8wLGEpKX1dfWZ1bmN0aW9uIGkoYSxiKXtyZXR1cm4gZnVuY3Rpb24oZSxmKXtyZXR1cm5bZSxmLGZ1bmN0aW9uKGUpe3JldHVybiBjKGQoYSxiLGUpKX1dfX1mdW5jdGlvbiBqKGEsYil7cmV0dXJuW2EsYixNYXRoLnJvdW5kXX1hLmNsYW1wPWQsYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihlLGkoMCwxLzApLFtcImJvcmRlci1pbWFnZS13aWR0aFwiLFwibGluZS1oZWlnaHRcIl0pLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoZSxpKDAsMSksW1wib3BhY2l0eVwiLFwic2hhcGUtaW1hZ2UtdGhyZXNob2xkXCJdKSxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGUsZyxbXCJmbGV4LWdyb3dcIixcImZsZXgtc2hyaW5rXCJdKSxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGUsaCxbXCJvcnBoYW5zXCIsXCJ3aWRvd3NcIl0pLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoZSxqLFtcInotaW5kZXhcIl0pLGEucGFyc2VOdW1iZXI9ZSxhLm1lcmdlTnVtYmVycz1mLGEubnVtYmVyVG9TdHJpbmc9Y30oZCxmKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiKXtpZihcInZpc2libGVcIj09YXx8XCJ2aXNpYmxlXCI9PWIpcmV0dXJuWzAsMSxmdW5jdGlvbihjKXtyZXR1cm4gYzw9MD9hOmM+PTE/YjpcInZpc2libGVcIn1dfWEuYWRkUHJvcGVydGllc0hhbmRsZXIoU3RyaW5nLGMsW1widmlzaWJpbGl0eVwiXSl9KGQpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXthPWEudHJpbSgpLGYuZmlsbFN0eWxlPVwiIzAwMFwiLGYuZmlsbFN0eWxlPWE7dmFyIGI9Zi5maWxsU3R5bGU7aWYoZi5maWxsU3R5bGU9XCIjZmZmXCIsZi5maWxsU3R5bGU9YSxiPT1mLmZpbGxTdHlsZSl7Zi5maWxsUmVjdCgwLDAsMSwxKTt2YXIgYz1mLmdldEltYWdlRGF0YSgwLDAsMSwxKS5kYXRhO2YuY2xlYXJSZWN0KDAsMCwxLDEpO3ZhciBkPWNbM10vMjU1O3JldHVybltjWzBdKmQsY1sxXSpkLGNbMl0qZCxkXX19ZnVuY3Rpb24gZChiLGMpe3JldHVybltiLGMsZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gTWF0aC5tYXgoMCxNYXRoLm1pbigyNTUsYSkpfWlmKGJbM10pZm9yKHZhciBkPTA7ZDwzO2QrKyliW2RdPU1hdGgucm91bmQoYyhiW2RdL2JbM10pKTtyZXR1cm4gYlszXT1hLm51bWJlclRvU3RyaW5nKGEuY2xhbXAoMCwxLGJbM10pKSxcInJnYmEoXCIrYi5qb2luKFwiLFwiKStcIilcIn1dfXZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcImNhbnZhc1wiKTtlLndpZHRoPWUuaGVpZ2h0PTE7dmFyIGY9ZS5nZXRDb250ZXh0KFwiMmRcIik7YS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihjLGQsW1wiYmFja2dyb3VuZC1jb2xvclwiLFwiYm9yZGVyLWJvdHRvbS1jb2xvclwiLFwiYm9yZGVyLWxlZnQtY29sb3JcIixcImJvcmRlci1yaWdodC1jb2xvclwiLFwiYm9yZGVyLXRvcC1jb2xvclwiLFwiY29sb3JcIixcIm91dGxpbmUtY29sb3JcIixcInRleHQtZGVjb3JhdGlvbi1jb2xvclwiXSksYS5jb25zdW1lQ29sb3I9YS5jb25zdW1lUGFyZW50aGVzaXNlZC5iaW5kKG51bGwsYyksYS5tZXJnZUNvbG9ycz1kfShkLGYpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIpe2lmKGI9Yi50cmltKCkudG9Mb3dlckNhc2UoKSxcIjBcIj09YiYmXCJweFwiLnNlYXJjaChhKT49MClyZXR1cm57cHg6MH07aWYoL15bXihdKiR8XmNhbGMvLnRlc3QoYikpe2I9Yi5yZXBsYWNlKC9jYWxjXFwoL2csXCIoXCIpO3ZhciBjPXt9O2I9Yi5yZXBsYWNlKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGNbYV09bnVsbCxcIlVcIithfSk7Zm9yKHZhciBkPVwiVShcIithLnNvdXJjZStcIilcIixlPWIucmVwbGFjZSgvWy0rXT8oXFxkKlxcLik/XFxkKy9nLFwiTlwiKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJOXCIrZCxcImdcIiksXCJEXCIpLnJlcGxhY2UoL1xcc1srLV1cXHMvZyxcIk9cIikucmVwbGFjZSgvXFxzL2csXCJcIiksZj1bL05cXCooRCkvZywvKE58RClbKlxcL11OL2csLyhOfEQpT1xcMS9nLC9cXCgoTnxEKVxcKS9nXSxnPTA7ZzxmLmxlbmd0aDspZltnXS50ZXN0KGUpPyhlPWUucmVwbGFjZShmW2ddLFwiJDFcIiksZz0wKTpnKys7aWYoXCJEXCI9PWUpe2Zvcih2YXIgaCBpbiBjKXt2YXIgaT1ldmFsKGIucmVwbGFjZShuZXcgUmVnRXhwKFwiVVwiK2gsXCJnXCIpLFwiXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChkLFwiZ1wiKSxcIiowXCIpKTtpZighaXNGaW5pdGUoaSkpcmV0dXJuO2NbaF09aX1yZXR1cm4gY319fWZ1bmN0aW9uIGQoYSxiKXtyZXR1cm4gZShhLGIsITApfWZ1bmN0aW9uIGUoYixjLGQpe3ZhciBlLGY9W107Zm9yKGUgaW4gYilmLnB1c2goZSk7Zm9yKGUgaW4gYylmLmluZGV4T2YoZSk8MCYmZi5wdXNoKGUpO3JldHVybiBiPWYubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBiW2FdfHwwfSksYz1mLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gY1thXXx8MH0pLFtiLGMsZnVuY3Rpb24oYil7dmFyIGM9Yi5tYXAoZnVuY3Rpb24oYyxlKXtyZXR1cm4gMT09Yi5sZW5ndGgmJmQmJihjPU1hdGgubWF4KGMsMCkpLGEubnVtYmVyVG9TdHJpbmcoYykrZltlXX0pLmpvaW4oXCIgKyBcIik7cmV0dXJuIGIubGVuZ3RoPjE/XCJjYWxjKFwiK2MrXCIpXCI6Y31dfXZhciBmPVwicHh8ZW18ZXh8Y2h8cmVtfHZ3fHZofHZtaW58dm1heHxjbXxtbXxpbnxwdHxwY1wiLGc9Yy5iaW5kKG51bGwsbmV3IFJlZ0V4cChmLFwiZ1wiKSksaD1jLmJpbmQobnVsbCxuZXcgUmVnRXhwKGYrXCJ8JVwiLFwiZ1wiKSksaT1jLmJpbmQobnVsbCwvZGVnfHJhZHxncmFkfHR1cm4vZyk7YS5wYXJzZUxlbmd0aD1nLGEucGFyc2VMZW5ndGhPclBlcmNlbnQ9aCxhLmNvbnN1bWVMZW5ndGhPclBlcmNlbnQ9YS5jb25zdW1lUGFyZW50aGVzaXNlZC5iaW5kKG51bGwsaCksYS5wYXJzZUFuZ2xlPWksYS5tZXJnZURpbWVuc2lvbnM9ZTt2YXIgaj1hLmNvbnN1bWVQYXJlbnRoZXNpc2VkLmJpbmQobnVsbCxnKSxrPWEuY29uc3VtZVJlcGVhdGVkLmJpbmQodm9pZCAwLGosL14vKSxsPWEuY29uc3VtZVJlcGVhdGVkLmJpbmQodm9pZCAwLGssL14sLyk7YS5jb25zdW1lU2l6ZVBhaXJMaXN0PWw7dmFyIG09ZnVuY3Rpb24oYSl7dmFyIGI9bChhKTtpZihiJiZcIlwiPT1iWzFdKXJldHVybiBiWzBdfSxuPWEubWVyZ2VOZXN0ZWRSZXBlYXRlZC5iaW5kKHZvaWQgMCxkLFwiIFwiKSxvPWEubWVyZ2VOZXN0ZWRSZXBlYXRlZC5iaW5kKHZvaWQgMCxuLFwiLFwiKTthLm1lcmdlTm9uTmVnYXRpdmVTaXplUGFpcj1uLGEuYWRkUHJvcGVydGllc0hhbmRsZXIobSxvLFtcImJhY2tncm91bmQtc2l6ZVwiXSksYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihoLGQsW1wiYm9yZGVyLWJvdHRvbS13aWR0aFwiLFwiYm9yZGVyLWltYWdlLXdpZHRoXCIsXCJib3JkZXItbGVmdC13aWR0aFwiLFwiYm9yZGVyLXJpZ2h0LXdpZHRoXCIsXCJib3JkZXItdG9wLXdpZHRoXCIsXCJmbGV4LWJhc2lzXCIsXCJmb250LXNpemVcIixcImhlaWdodFwiLFwibGluZS1oZWlnaHRcIixcIm1heC1oZWlnaHRcIixcIm1heC13aWR0aFwiLFwib3V0bGluZS13aWR0aFwiLFwid2lkdGhcIl0pLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoaCxlLFtcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIixcImJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzXCIsXCJib3JkZXItdG9wLWxlZnQtcmFkaXVzXCIsXCJib3JkZXItdG9wLXJpZ2h0LXJhZGl1c1wiLFwiYm90dG9tXCIsXCJsZWZ0XCIsXCJsZXR0ZXItc3BhY2luZ1wiLFwibWFyZ2luLWJvdHRvbVwiLFwibWFyZ2luLWxlZnRcIixcIm1hcmdpbi1yaWdodFwiLFwibWFyZ2luLXRvcFwiLFwibWluLWhlaWdodFwiLFwibWluLXdpZHRoXCIsXCJvdXRsaW5lLW9mZnNldFwiLFwicGFkZGluZy1ib3R0b21cIixcInBhZGRpbmctbGVmdFwiLFwicGFkZGluZy1yaWdodFwiLFwicGFkZGluZy10b3BcIixcInBlcnNwZWN0aXZlXCIsXCJyaWdodFwiLFwic2hhcGUtbWFyZ2luXCIsXCJ0ZXh0LWluZGVudFwiLFwidG9wXCIsXCJ2ZXJ0aWNhbC1hbGlnblwiLFwid29yZC1zcGFjaW5nXCJdKX0oZCxmKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYil7cmV0dXJuIGEuY29uc3VtZUxlbmd0aE9yUGVyY2VudChiKXx8YS5jb25zdW1lVG9rZW4oL15hdXRvLyxiKX1mdW5jdGlvbiBkKGIpe3ZhciBkPWEuY29uc3VtZUxpc3QoW2EuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQobnVsbCwvXnJlY3QvKSksYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZChudWxsLC9eXFwoLykpLGEuY29uc3VtZVJlcGVhdGVkLmJpbmQobnVsbCxjLC9eLC8pLGEuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQobnVsbCwvXlxcKS8pKV0sYik7aWYoZCYmND09ZFswXS5sZW5ndGgpcmV0dXJuIGRbMF19ZnVuY3Rpb24gZShiLGMpe3JldHVyblwiYXV0b1wiPT1ifHxcImF1dG9cIj09Yz9bITAsITEsZnVuY3Rpb24oZCl7dmFyIGU9ZD9iOmM7aWYoXCJhdXRvXCI9PWUpcmV0dXJuXCJhdXRvXCI7dmFyIGY9YS5tZXJnZURpbWVuc2lvbnMoZSxlKTtyZXR1cm4gZlsyXShmWzBdKX1dOmEubWVyZ2VEaW1lbnNpb25zKGIsYyl9ZnVuY3Rpb24gZihhKXtyZXR1cm5cInJlY3QoXCIrYStcIilcIn12YXIgZz1hLm1lcmdlV3JhcHBlZE5lc3RlZFJlcGVhdGVkLmJpbmQobnVsbCxmLGUsXCIsIFwiKTthLnBhcnNlQm94PWQsYS5tZXJnZUJveGVzPWcsYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihkLGcsW1wiY2xpcFwiXSl9KGQsZiksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz0wO3JldHVybiBhLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYT09PWs/YltjKytdOmF9KX19ZnVuY3Rpb24gZChhKXtyZXR1cm4gYX1mdW5jdGlvbiBlKGIpe2lmKGI9Yi50b0xvd2VyQ2FzZSgpLnRyaW0oKSxcIm5vbmVcIj09YilyZXR1cm5bXTtmb3IodmFyIGMsZD0vXFxzKihcXHcrKVxcKChbXildKilcXCkvZyxlPVtdLGY9MDtjPWQuZXhlYyhiKTspe2lmKGMuaW5kZXghPWYpcmV0dXJuO2Y9Yy5pbmRleCtjWzBdLmxlbmd0aDt2YXIgZz1jWzFdLGg9bltnXTtpZighaClyZXR1cm47dmFyIGk9Y1syXS5zcGxpdChcIixcIiksaj1oWzBdO2lmKGoubGVuZ3RoPGkubGVuZ3RoKXJldHVybjtmb3IodmFyIGs9W10sbz0wO288ai5sZW5ndGg7bysrKXt2YXIgcCxxPWlbb10scj1qW29dO2lmKHA9cT97QTpmdW5jdGlvbihiKXtyZXR1cm5cIjBcIj09Yi50cmltKCk/bTphLnBhcnNlQW5nbGUoYil9LE46YS5wYXJzZU51bWJlcixUOmEucGFyc2VMZW5ndGhPclBlcmNlbnQsTDphLnBhcnNlTGVuZ3RofVtyLnRvVXBwZXJDYXNlKCldKHEpOnthOm0sbjprWzBdLHQ6bH1bcl0sdm9pZCAwPT09cClyZXR1cm47ay5wdXNoKHApfWlmKGUucHVzaCh7dDpnLGQ6a30pLGQubGFzdEluZGV4PT1iLmxlbmd0aClyZXR1cm4gZX19ZnVuY3Rpb24gZihhKXtyZXR1cm4gYS50b0ZpeGVkKDYpLnJlcGxhY2UoXCIuMDAwMDAwXCIsXCJcIil9ZnVuY3Rpb24gZyhiLGMpe2lmKGIuZGVjb21wb3NpdGlvblBhaXIhPT1jKXtiLmRlY29tcG9zaXRpb25QYWlyPWM7dmFyIGQ9YS5tYWtlTWF0cml4RGVjb21wb3NpdGlvbihiKX1pZihjLmRlY29tcG9zaXRpb25QYWlyIT09Yil7Yy5kZWNvbXBvc2l0aW9uUGFpcj1iO3ZhciBlPWEubWFrZU1hdHJpeERlY29tcG9zaXRpb24oYyl9cmV0dXJuIG51bGw9PWRbMF18fG51bGw9PWVbMF0/W1shMV0sWyEwXSxmdW5jdGlvbihhKXtyZXR1cm4gYT9jWzBdLmQ6YlswXS5kfV06KGRbMF0ucHVzaCgwKSxlWzBdLnB1c2goMSksW2QsZSxmdW5jdGlvbihiKXt2YXIgYz1hLnF1YXQoZFswXVszXSxlWzBdWzNdLGJbNV0pLGc9YS5jb21wb3NlTWF0cml4KGJbMF0sYlsxXSxiWzJdLGMsYls0XSksaD1nLm1hcChmKS5qb2luKFwiLFwiKTtyZXR1cm4gaH1dKX1mdW5jdGlvbiBoKGEpe3JldHVybiBhLnJlcGxhY2UoL1t4eV0vLFwiXCIpfWZ1bmN0aW9uIGkoYSl7cmV0dXJuIGEucmVwbGFjZSgvKHh8eXx6fDNkKT8kLyxcIjNkXCIpfWZ1bmN0aW9uIGooYixjKXt2YXIgZD1hLm1ha2VNYXRyaXhEZWNvbXBvc2l0aW9uJiYhMCxlPSExO2lmKCFiLmxlbmd0aHx8IWMubGVuZ3RoKXtiLmxlbmd0aHx8KGU9ITAsYj1jLGM9W10pO2Zvcih2YXIgZj0wO2Y8Yi5sZW5ndGg7ZisrKXt2YXIgaj1iW2ZdLnQsaz1iW2ZdLmQsbD1cInNjYWxlXCI9PWouc3Vic3RyKDAsNSk/MTowO2MucHVzaCh7dDpqLGQ6ay5tYXAoZnVuY3Rpb24oYSl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGEpcmV0dXJuIGw7dmFyIGI9e307Zm9yKHZhciBjIGluIGEpYltjXT1sO3JldHVybiBifSl9KX19dmFyIG09ZnVuY3Rpb24oYSxiKXtyZXR1cm5cInBlcnNwZWN0aXZlXCI9PWEmJlwicGVyc3BlY3RpdmVcIj09Ynx8KFwibWF0cml4XCI9PWF8fFwibWF0cml4M2RcIj09YSkmJihcIm1hdHJpeFwiPT1ifHxcIm1hdHJpeDNkXCI9PWIpfSxvPVtdLHA9W10scT1bXTtpZihiLmxlbmd0aCE9Yy5sZW5ndGgpe2lmKCFkKXJldHVybjt2YXIgcj1nKGIsYyk7bz1bclswXV0scD1bclsxXV0scT1bW1wibWF0cml4XCIsW3JbMl1dXV19ZWxzZSBmb3IodmFyIGY9MDtmPGIubGVuZ3RoO2YrKyl7dmFyIGoscz1iW2ZdLnQsdD1jW2ZdLnQsdT1iW2ZdLmQsdj1jW2ZdLmQsdz1uW3NdLHg9blt0XTtpZihtKHMsdCkpe2lmKCFkKXJldHVybjt2YXIgcj1nKFtiW2ZdXSxbY1tmXV0pO28ucHVzaChyWzBdKSxwLnB1c2goclsxXSkscS5wdXNoKFtcIm1hdHJpeFwiLFtyWzJdXV0pfWVsc2V7aWYocz09dClqPXM7ZWxzZSBpZih3WzJdJiZ4WzJdJiZoKHMpPT1oKHQpKWo9aChzKSx1PXdbMl0odSksdj14WzJdKHYpO2Vsc2V7aWYoIXdbMV18fCF4WzFdfHxpKHMpIT1pKHQpKXtpZighZClyZXR1cm47dmFyIHI9ZyhiLGMpO289W3JbMF1dLHA9W3JbMV1dLHE9W1tcIm1hdHJpeFwiLFtyWzJdXV1dO2JyZWFrfWo9aShzKSx1PXdbMV0odSksdj14WzFdKHYpfWZvcih2YXIgeT1bXSx6PVtdLEE9W10sQj0wO0I8dS5sZW5ndGg7QisrKXt2YXIgQz1cIm51bWJlclwiPT10eXBlb2YgdVtCXT9hLm1lcmdlTnVtYmVyczphLm1lcmdlRGltZW5zaW9ucyxyPUModVtCXSx2W0JdKTt5W0JdPXJbMF0seltCXT1yWzFdLEEucHVzaChyWzJdKX1vLnB1c2goeSkscC5wdXNoKHopLHEucHVzaChbaixBXSl9fWlmKGUpe3ZhciBEPW87bz1wLHA9RH1yZXR1cm5bbyxwLGZ1bmN0aW9uKGEpe3JldHVybiBhLm1hcChmdW5jdGlvbihhLGIpe3ZhciBjPWEubWFwKGZ1bmN0aW9uKGEsYyl7cmV0dXJuIHFbYl1bMV1bY10oYSl9KS5qb2luKFwiLFwiKTtyZXR1cm5cIm1hdHJpeFwiPT1xW2JdWzBdJiYxNj09Yy5zcGxpdChcIixcIikubGVuZ3RoJiYocVtiXVswXT1cIm1hdHJpeDNkXCIpLHFbYl1bMF0rXCIoXCIrYytcIilcIn0pLmpvaW4oXCIgXCIpfV19dmFyIGs9bnVsbCxsPXtweDowfSxtPXtkZWc6MH0sbj17bWF0cml4OltcIk5OTk5OTlwiLFtrLGssMCwwLGssaywwLDAsMCwwLDEsMCxrLGssMCwxXSxkXSxtYXRyaXgzZDpbXCJOTk5OTk5OTk5OTk5OTk5OXCIsZF0scm90YXRlOltcIkFcIl0scm90YXRleDpbXCJBXCJdLHJvdGF0ZXk6W1wiQVwiXSxyb3RhdGV6OltcIkFcIl0scm90YXRlM2Q6W1wiTk5OQVwiXSxwZXJzcGVjdGl2ZTpbXCJMXCJdLHNjYWxlOltcIk5uXCIsYyhbayxrLDFdKSxkXSxzY2FsZXg6W1wiTlwiLGMoW2ssMSwxXSksYyhbaywxXSldLHNjYWxleTpbXCJOXCIsYyhbMSxrLDFdKSxjKFsxLGtdKV0sc2NhbGV6OltcIk5cIixjKFsxLDEsa10pXSxzY2FsZTNkOltcIk5OTlwiLGRdLHNrZXc6W1wiQWFcIixudWxsLGRdLHNrZXd4OltcIkFcIixudWxsLGMoW2ssbV0pXSxza2V3eTpbXCJBXCIsbnVsbCxjKFttLGtdKV0sdHJhbnNsYXRlOltcIlR0XCIsYyhbayxrLGxdKSxkXSx0cmFuc2xhdGV4OltcIlRcIixjKFtrLGwsbF0pLGMoW2ssbF0pXSx0cmFuc2xhdGV5OltcIlRcIixjKFtsLGssbF0pLGMoW2wsa10pXSx0cmFuc2xhdGV6OltcIkxcIixjKFtsLGwsa10pXSx0cmFuc2xhdGUzZDpbXCJUVExcIixkXX07YS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihlLGosW1widHJhbnNmb3JtXCJdKX0oZCxmKSxmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEpe3ZhciBiPU51bWJlcihhKTtpZighKGlzTmFOKGIpfHxiPDEwMHx8Yj45MDB8fGIlMTAwIT09MCkpcmV0dXJuIGJ9ZnVuY3Rpb24gYyhiKXtyZXR1cm4gYj0xMDAqTWF0aC5yb3VuZChiLzEwMCksYj1hLmNsYW1wKDEwMCw5MDAsYiksNDAwPT09Yj9cIm5vcm1hbFwiOjcwMD09PWI/XCJib2xkXCI6U3RyaW5nKGIpfWZ1bmN0aW9uIGQoYSxiKXtyZXR1cm5bYSxiLGNdfWEuYWRkUHJvcGVydGllc0hhbmRsZXIoYixkLFtcImZvbnQtd2VpZ2h0XCJdKX0oZCksZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhKXt2YXIgYj17fTtmb3IodmFyIGMgaW4gYSliW2NdPS1hW2NdO3JldHVybiBifWZ1bmN0aW9uIGMoYil7cmV0dXJuIGEuY29uc3VtZVRva2VuKC9eKGxlZnR8Y2VudGVyfHJpZ2h0fHRvcHxib3R0b20pXFxiL2ksYil8fGEuY29uc3VtZUxlbmd0aE9yUGVyY2VudChiKX1mdW5jdGlvbiBkKGIsZCl7dmFyIGU9YS5jb25zdW1lUmVwZWF0ZWQoYywvXi8sZCk7aWYoZSYmXCJcIj09ZVsxXSl7dmFyIGY9ZVswXTtpZihmWzBdPWZbMF18fFwiY2VudGVyXCIsZlsxXT1mWzFdfHxcImNlbnRlclwiLDM9PWImJihmWzJdPWZbMl18fHtweDowfSksZi5sZW5ndGg9PWIpe2lmKC90b3B8Ym90dG9tLy50ZXN0KGZbMF0pfHwvbGVmdHxyaWdodC8udGVzdChmWzFdKSl7dmFyIGg9ZlswXTtmWzBdPWZbMV0sZlsxXT1ofWlmKC9sZWZ0fHJpZ2h0fGNlbnRlcnxPYmplY3QvLnRlc3QoZlswXSkmJi90b3B8Ym90dG9tfGNlbnRlcnxPYmplY3QvLnRlc3QoZlsxXSkpcmV0dXJuIGYubWFwKGZ1bmN0aW9uKGEpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBhP2E6Z1thXX0pfX19ZnVuY3Rpb24gZShkKXt2YXIgZT1hLmNvbnN1bWVSZXBlYXRlZChjLC9eLyxkKTtpZihlKXtmb3IodmFyIGY9ZVswXSxoPVt7XCIlXCI6NTB9LHtcIiVcIjo1MH1dLGk9MCxqPSExLGs9MDtrPGYubGVuZ3RoO2srKyl7dmFyIGw9ZltrXTtcInN0cmluZ1wiPT10eXBlb2YgbD8oaj0vYm90dG9tfHJpZ2h0Ly50ZXN0KGwpLGk9e2xlZnQ6MCxyaWdodDowLGNlbnRlcjppLHRvcDoxLGJvdHRvbToxfVtsXSxoW2ldPWdbbF0sXCJjZW50ZXJcIj09bCYmaSsrKTooaiYmKGw9YihsKSxsW1wiJVwiXT0obFtcIiVcIl18fDApKzEwMCksaFtpXT1sLGkrKyxqPSExKX1yZXR1cm5baCxlWzFdXX19ZnVuY3Rpb24gZihiKXt2YXIgYz1hLmNvbnN1bWVSZXBlYXRlZChlLC9eLC8sYik7aWYoYyYmXCJcIj09Y1sxXSlyZXR1cm4gY1swXX12YXIgZz17bGVmdDp7XCIlXCI6MH0sY2VudGVyOntcIiVcIjo1MH0scmlnaHQ6e1wiJVwiOjEwMH0sdG9wOntcIiVcIjowfSxib3R0b206e1wiJVwiOjEwMH19LGg9YS5tZXJnZU5lc3RlZFJlcGVhdGVkLmJpbmQobnVsbCxhLm1lcmdlRGltZW5zaW9ucyxcIiBcIik7YS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihkLmJpbmQobnVsbCwzKSxoLFtcInRyYW5zZm9ybS1vcmlnaW5cIl0pLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoZC5iaW5kKG51bGwsMiksaCxbXCJwZXJzcGVjdGl2ZS1vcmlnaW5cIl0pLGEuY29uc3VtZVBvc2l0aW9uPWUsYS5tZXJnZU9mZnNldExpc3Q9aDt2YXIgaT1hLm1lcmdlTmVzdGVkUmVwZWF0ZWQuYmluZChudWxsLGgsXCIsIFwiKTthLmFkZFByb3BlcnRpZXNIYW5kbGVyKGYsaSxbXCJiYWNrZ3JvdW5kLXBvc2l0aW9uXCIsXCJvYmplY3QtcG9zaXRpb25cIl0pfShkKSxmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIpe3ZhciBjPWEuY29uc3VtZVRva2VuKC9eY2lyY2xlLyxiKTtpZihjJiZjWzBdKXJldHVybltcImNpcmNsZVwiXS5jb25jYXQoYS5jb25zdW1lTGlzdChbYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZCh2b2lkIDAsL15cXCgvKSksZCxhLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKHZvaWQgMCwvXmF0LykpLGEuY29uc3VtZVBvc2l0aW9uLGEuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQodm9pZCAwLC9eXFwpLykpXSxjWzFdKSk7dmFyIGY9YS5jb25zdW1lVG9rZW4oL15lbGxpcHNlLyxiKTtpZihmJiZmWzBdKXJldHVybltcImVsbGlwc2VcIl0uY29uY2F0KGEuY29uc3VtZUxpc3QoW2EuaWdub3JlKGEuY29uc3VtZVRva2VuLmJpbmQodm9pZCAwLC9eXFwoLykpLGUsYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZCh2b2lkIDAsL15hdC8pKSxhLmNvbnN1bWVQb3NpdGlvbixhLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKHZvaWQgMCwvXlxcKS8pKV0sZlsxXSkpO3ZhciBnPWEuY29uc3VtZVRva2VuKC9ecG9seWdvbi8sYik7cmV0dXJuIGcmJmdbMF0/W1wicG9seWdvblwiXS5jb25jYXQoYS5jb25zdW1lTGlzdChbYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZCh2b2lkIDAsL15cXCgvKSksYS5vcHRpb25hbChhLmNvbnN1bWVUb2tlbi5iaW5kKHZvaWQgMCwvXm5vbnplcm9cXHMqLHxeZXZlbm9kZFxccyosLyksXCJub256ZXJvLFwiKSxhLmNvbnN1bWVTaXplUGFpckxpc3QsYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZCh2b2lkIDAsL15cXCkvKSldLGdbMV0pKTp2b2lkIDB9ZnVuY3Rpb24gYyhiLGMpe2lmKGJbMF09PT1jWzBdKXJldHVyblwiY2lyY2xlXCI9PWJbMF0/YS5tZXJnZUxpc3QoYi5zbGljZSgxKSxjLnNsaWNlKDEpLFtcImNpcmNsZShcIixhLm1lcmdlRGltZW5zaW9ucyxcIiBhdCBcIixhLm1lcmdlT2Zmc2V0TGlzdCxcIilcIl0pOlwiZWxsaXBzZVwiPT1iWzBdP2EubWVyZ2VMaXN0KGIuc2xpY2UoMSksYy5zbGljZSgxKSxbXCJlbGxpcHNlKFwiLGEubWVyZ2VOb25OZWdhdGl2ZVNpemVQYWlyLFwiIGF0IFwiLGEubWVyZ2VPZmZzZXRMaXN0LFwiKVwiXSk6XCJwb2x5Z29uXCI9PWJbMF0mJmJbMV09PWNbMV0/YS5tZXJnZUxpc3QoYi5zbGljZSgyKSxjLnNsaWNlKDIpLFtcInBvbHlnb24oXCIsYlsxXSxnLFwiKVwiXSk6dm9pZCAwfXZhciBkPWEuY29uc3VtZVBhcmVudGhlc2lzZWQuYmluZChudWxsLGEucGFyc2VMZW5ndGhPclBlcmNlbnQpLGU9YS5jb25zdW1lUmVwZWF0ZWQuYmluZCh2b2lkIDAsZCwvXi8pLGY9YS5tZXJnZU5lc3RlZFJlcGVhdGVkLmJpbmQodm9pZCAwLGEubWVyZ2VEaW1lbnNpb25zLFwiIFwiKSxnPWEubWVyZ2VOZXN0ZWRSZXBlYXRlZC5iaW5kKHZvaWQgMCxmLFwiLFwiKTthLmFkZFByb3BlcnRpZXNIYW5kbGVyKGIsYyxbXCJzaGFwZS1vdXRzaWRlXCJdKX0oZCksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYil7Yi5jb25jYXQoW2FdKS5mb3JFYWNoKGZ1bmN0aW9uKGIpe2IgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlJiYoZFthXT1iKX0pfXZhciBkPXt9O2MoXCJ0cmFuc2Zvcm1cIixbXCJ3ZWJraXRUcmFuc2Zvcm1cIixcIm1zVHJhbnNmb3JtXCJdKSxjKFwidHJhbnNmb3JtT3JpZ2luXCIsW1wid2Via2l0VHJhbnNmb3JtT3JpZ2luXCJdKSxjKFwicGVyc3BlY3RpdmVcIixbXCJ3ZWJraXRQZXJzcGVjdGl2ZVwiXSksYyhcInBlcnNwZWN0aXZlT3JpZ2luXCIsW1wid2Via2l0UGVyc3BlY3RpdmVPcmlnaW5cIl0pLGEucHJvcGVydHlOYW1lPWZ1bmN0aW9uKGEpe3JldHVybiBkW2FdfHxhfX0oZCxmKX0oKSwhZnVuY3Rpb24oKXtpZih2b2lkIDA9PT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLmFuaW1hdGUoW10pLm9uY2FuY2VsKXt2YXIgYTtpZih3aW5kb3cucGVyZm9ybWFuY2UmJnBlcmZvcm1hbmNlLm5vdyl2YXIgYT1mdW5jdGlvbigpe3JldHVybiBwZXJmb3JtYW5jZS5ub3coKX07ZWxzZSB2YXIgYT1mdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfTt2YXIgYj1mdW5jdGlvbihhLGIsYyl7dGhpcy50YXJnZXQ9YSx0aGlzLmN1cnJlbnRUaW1lPWIsdGhpcy50aW1lbGluZVRpbWU9Yyx0aGlzLnR5cGU9XCJjYW5jZWxcIix0aGlzLmJ1YmJsZXM9ITEsdGhpcy5jYW5jZWxhYmxlPSExLHRoaXMuY3VycmVudFRhcmdldD1hLHRoaXMuZGVmYXVsdFByZXZlbnRlZD0hMSx0aGlzLmV2ZW50UGhhc2U9RXZlbnQuQVRfVEFSR0VULHRoaXMudGltZVN0YW1wPURhdGUubm93KCl9LGM9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmFuaW1hdGU7d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmFuaW1hdGU9ZnVuY3Rpb24oZCxlKXt2YXIgZj1jLmNhbGwodGhpcyxkLGUpO2YuX2NhbmNlbEhhbmRsZXJzPVtdLGYub25jYW5jZWw9bnVsbDt2YXIgZz1mLmNhbmNlbDtmLmNhbmNlbD1mdW5jdGlvbigpe2cuY2FsbCh0aGlzKTt2YXIgYz1uZXcgYih0aGlzLG51bGwsYSgpKSxkPXRoaXMuX2NhbmNlbEhhbmRsZXJzLmNvbmNhdCh0aGlzLm9uY2FuY2VsP1t0aGlzLm9uY2FuY2VsXTpbXSk7c2V0VGltZW91dChmdW5jdGlvbigpe2QuZm9yRWFjaChmdW5jdGlvbihhKXthLmNhbGwoYy50YXJnZXQsYyl9KX0sMCl9O3ZhciBoPWYuYWRkRXZlbnRMaXN0ZW5lcjtmLmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oYSxiKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBiJiZcImNhbmNlbFwiPT1hP3RoaXMuX2NhbmNlbEhhbmRsZXJzLnB1c2goYik6aC5jYWxsKHRoaXMsYSxiKX07dmFyIGk9Zi5yZW1vdmVFdmVudExpc3RlbmVyO3JldHVybiBmLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oYSxiKXtpZihcImNhbmNlbFwiPT1hKXt2YXIgYz10aGlzLl9jYW5jZWxIYW5kbGVycy5pbmRleE9mKGIpO2M+PTAmJnRoaXMuX2NhbmNlbEhhbmRsZXJzLnNwbGljZShjLDEpfWVsc2UgaS5jYWxsKHRoaXMsYSxiKX0sZn19fSgpLGZ1bmN0aW9uKGEpe3ZhciBiPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxjPW51bGwsZD0hMTt0cnl7dmFyIGU9Z2V0Q29tcHV0ZWRTdHlsZShiKS5nZXRQcm9wZXJ0eVZhbHVlKFwib3BhY2l0eVwiKSxmPVwiMFwiPT1lP1wiMVwiOlwiMFwiO2M9Yi5hbmltYXRlKHtvcGFjaXR5OltmLGZdfSx7ZHVyYXRpb246MX0pLGMuY3VycmVudFRpbWU9MCxkPWdldENvbXB1dGVkU3R5bGUoYikuZ2V0UHJvcGVydHlWYWx1ZShcIm9wYWNpdHlcIik9PWZ9Y2F0Y2goYSl7fWZpbmFsbHl7YyYmYy5jYW5jZWwoKX1pZighZCl7dmFyIGc9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmFuaW1hdGU7d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmFuaW1hdGU9ZnVuY3Rpb24oYixjKXtyZXR1cm4gd2luZG93LlN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yJiZBcnJheS5wcm90b3R5cGUuZnJvbSYmYltTeW1ib2wuaXRlcmF0b3JdJiYoYj1BcnJheS5mcm9tKGIpKSxBcnJheS5pc0FycmF5KGIpfHxudWxsPT09Ynx8KGI9YS5jb252ZXJ0VG9BcnJheUZvcm0oYikpLGcuY2FsbCh0aGlzLGIsYyl9fX0oYyksYi50cnVlPWF9KHt9LGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViLWFuaW1hdGlvbnMubWluLmpzLm1hcCIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmxvcmlhbiBLbGFtcGZlclxuICogTGljZW5zZWQgdW5kZXIgTUlUXG4gKi9cblxuLy8gY29uc3QgSlNfRkVBVFVSRVMgPSBbXG4vLyAgICdmbi9hcnJheS9mb3ItZWFjaCcsXG4vLyAgICdmbi9mdW5jdGlvbi9iaW5kJyxcbi8vICAgJ2ZuL251bWJlci9jb25zdHJ1Y3RvcicsXG4vLyAgICdmbi9vYmplY3QvYXNzaWduJyxcbi8vICAgJ2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHknLFxuLy8gICAnZm4vb2JqZWN0L2tleXMnLFxuLy8gXTtcblxuLy8gY29uc3QgTU9ERVJOSVpSX1RFU1RTID0gW1xuLy8gICAnY3VzdG9tZXZlbnQnLFxuLy8gXTtcblxuY2xhc3MgTWl4IHt9XG5cbmNvbnN0IFN5bWJvbCA9IGdsb2JhbC5TeW1ib2wgfHwgKHggPT4gYF8ke3h9YCk7XG5cbmNvbnN0IGRlZiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eS5iaW5kKE9iamVjdCk7XG5cbmNvbnN0IFJPT1QgPSBTeW1ib2woJ3Jvb3QnKTtcbmNvbnN0IFNUQVRFID0gU3ltYm9sKCdzdGF0ZScpO1xuXG5mdW5jdGlvbiBjcmVhdGVFdmVudChldmVudE5hbWUsIGRhdGEgPSB7fSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCBkYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnN0IGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgdHJ1ZSwgZGF0YS5kZXRhaWwpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXR1cFByb3BlcnR5KGtleSwgc2lkZUVmZmVjdCkge1xuICBkZWYodGhpcywga2V5LCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6ICgpID0+IHRoaXNbU1RBVEVdW2tleV0sXG4gICAgc2V0OiAodmFsdWUpID0+IHtcbiAgICAgIGlmIChzaWRlRWZmZWN0ICE9IG51bGwpIHtcbiAgICAgICAgc2lkZUVmZmVjdCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFN0YXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sXG4gIH0pO1xufVxuXG4vLyBUT0RPOiBzdHVkeSBob3cgbmF0aXZlIGVsZW1lbnRzIGRlYWwgd2l0aCBhdHRyaWJ1dGVzL3Byb3Blcml0ZXNcbmZ1bmN0aW9uIHNldHVwUHJvcGVydGllcygpIHtcbiAgY29uc3Qgc2lkZUVmZmVjdHMgPSB0aGlzLnNpZGVFZmZlY3RzKCk7XG5cbiAgT2JqZWN0LmtleXModGhpc1tTVEFURV0pLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdGhpc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc3Qgc2lkZUVmZmVjdCA9IHNpZGVFZmZlY3RzW2tleV07XG4gICAgICBzZXR1cFByb3BlcnR5LmNhbGwodGhpcywga2V5LCBzaWRlRWZmZWN0KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCAoQyA9IE1peCkgPT4gY2xhc3MgZXh0ZW5kcyBDIHtcbiAgZ2V0IGNvbXBvbmVudE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50TmFtZSgpO1xuICB9XG5cbiAgZ2V0Q29tcG9uZW50TmFtZSgpIHtcbiAgICB0aHJvdyBFcnJvcignQ29tcG9uZW50IG5lZWRzIHRvIGhhdmUgYSBuYW1lLCBlLmcuIGBteS10YWdgLiBPdmVycmlkZSBgZ2V0Q29tcG9uZW50TmFtZWAnKTtcbiAgfVxuXG4gIHNldHVwQ29tcG9uZW50KGVsLCBzdGF0ZSkge1xuICAgIGRlZih0aGlzLCBTVEFURSwgeyB2YWx1ZTogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0cygpLCBzdGF0ZSkgfSk7XG4gICAgc2V0dXBQcm9wZXJ0aWVzLmNhbGwodGhpcyk7XG4gICAgZGVmKHRoaXMsIFJPT1QsIHsgdmFsdWU6IHRoaXMuc2V0dXBET00oZWwpIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2V0dXBET00oZWwpIHtcbiAgICByZXR1cm4gZWw7XG4gIH1cblxuICBnZXQgcm9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSb290KCk7XG4gIH1cblxuICBnZXQgZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWwoKTtcbiAgfVxuXG4gIGdldFJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXNbUk9PVF07XG4gIH1cblxuICBnZXRFbCgpIHtcbiAgICByZXR1cm4gdGhpc1tST09UXTtcbiAgfVxuXG4gIGZpcmVFdmVudChldmVudE5hbWUsIGRhdGEpIHtcbiAgICBjb25zdCBldmVudE5hbWVOUyA9IGAke3RoaXMuY29tcG9uZW50TmFtZX0tJHtldmVudE5hbWV9YDtcbiAgICB0aGlzLmVsLmRpc3BhdGNoRXZlbnQoY3JlYXRlRXZlbnQoZXZlbnROYW1lTlMsIGRhdGEpKTtcbiAgfVxuXG4gIGRlZmF1bHRzKCkge1xuICAgIC8vIFRPRE86IHByb2R1Y3Rpb24gYnVpbGRzIHdpdGggcHJlcHJvY2Vzcz9cbiAgICBjb25zb2xlLndhcm4oJ2RlZmF1bHRzIG5vdCBwcm92aWRlZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICByZXR1cm4ge307XG4gIH1cblxuICBzaWRlRWZmZWN0cygpIHtcbiAgICAvLyBUT0RPOiBwcm9kdWN0aW9uIGJ1aWxkcyB3aXRoIHByZXByb2Nlc3M/XG4gICAgY29uc29sZS53YXJuKCdzaWRlRWZmZWN0cyBub3QgcHJvdmlkZWQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgc2V0U3RhdGUoa2V5T3JNYXAsIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXlPck1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGVLVihrZXlPck1hcCwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGtleU9yTWFwID09PSAnb2JqZWN0Jykge1xuICAgICAgdGhpcy5zZXRTdGF0ZU1hcChrZXlPck1hcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IEVycm9yKCdzZXRTdGF0ZSBuZWVkcyBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIHNldFN0YXRlS1Yoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXNbU1RBVEVdW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHNldFN0YXRlTWFwKG1hcCkge1xuICAgIE9iamVjdC5rZXlzKHRoaXNbU1RBVEVdKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdGVLVihrZXksIG1hcFtrZXldKTtcbiAgICB9KTtcbiAgfVxufTtcbiIsIi8qKlxuICAqIEBwYXJhbSB0IGN1cnJlbnQgdGltZVxuICAqIEBwYXJhbSBiIHN0YXJ0IHZhbHVlXG4gICogQHBhcmFtIGMgY2hhbmdlIGluIHZhbHVlXG4gICogQHBhcmFtIGQgZHVyYXRpb25cbiAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAqL1xuZnVuY3Rpb24gbGluZWFyVHdlZW4odCwgYiwgYywgZCkge1xuICByZXR1cm4gKChjICogdCkgLyBkKSArIGI7XG59XG5cbmZ1bmN0aW9uIHBhZ2VEaXN0KHAxLCBwMikge1xuICByZXR1cm4gTWF0aC5zcXJ0KCgocDEucGFnZVggLSBwMi5wYWdlWCkgKiogMikgKyAoKHAxLnBhZ2VZIC0gcDIucGFnZVkpICoqIDIpKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnModGFyZ2V0LCBjbGFzc05hbWUpIHtcbiAgbGV0IHQgPSB0YXJnZXQ7XG4gIHdoaWxlICh0ICE9IG51bGwpIHtcbiAgICBpZiAodC5jbGFzc0xpc3QgJiYgdC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHQgPSB0LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgeyBsaW5lYXJUd2VlbiwgcGFnZURpc3QsIGNvbnRhaW5zIH07XG4iLCIvKlxuICogQWRhcHRlZCBmcm9tIFJhdGNoZXQncyBzbGlkZXJzLmpzXG4gKiBodHRwOi8vZ29yYXRjaGV0LmNvbS9jb21wb25lbnRzI3NsaWRlcnNcbiAqXG4gKiBBZGFwdGVkIGZyb20gQnJhZCBCaXJkc2FsbCdzIFN3aXBlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vdGhlYmlyZC9Td2lwZVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGbG9yaWFuIEtsYW1wZmVyXG4gKiBMaWNlbnNlZCB1bmRlciBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzLCBpbXBvcnQvbm8tdW5yZXNvbHZlZCwgaW1wb3J0L2V4dGVuc2lvbnMgKi9cblxuaW1wb3J0IGNvbXBvbmVudENvcmUgZnJvbSAneS1jb21wb25lbnQvc3JjL2NvbXBvbmVudC1jb3JlJztcblxuaW1wb3J0IHsgbGluZWFyVHdlZW4sIHBhZ2VEaXN0IH0gZnJvbSAnLi4vY29tbW9uJztcblxuLy8gY29uc3QgSlNfRkVBVFVSRVMgPSBbXG4vLyAgICdmbi9hcnJheS9mb3ItZWFjaCcsXG4vLyAgICdmbi9mdW5jdGlvbi9iaW5kJyxcbi8vICAgJ2ZuL251bWJlci9jb25zdHJ1Y3RvcicsXG4vLyAgICdmbi9vYmplY3QvYXNzaWduJyxcbi8vICAgJ2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHknLFxuLy8gICAnZm4vb2JqZWN0L2tleXMnLFxuLy8gICAnZm4vYXJyYXkvcmVkdWNlJyxcbi8vIF07XG4vL1xuLy8gY29uc3QgTU9ERVJOSVpSX1RFU1RTID0gW1xuLy8gICAnY3VzdG9tZXZlbnQnLFxuLy8gICAnZXZlbnRsaXN0ZW5lcicsXG4vLyAgICdxdWVyeXNlbGVjdG9yJyxcbi8vICAgJ3JlcXVlc3RhbmltYXRpb25mcmFtZScsXG4vLyAgICdjbGFzc2xpc3QnLFxuLy8gICAnb3BhY2l0eScsXG4vLyAgICdjc3N0cmFuc2Zvcm1zJyxcbi8vICAgJ2Nzc3BvaW50ZXJldmVudHMnLFxuLy8gXTtcblxuY29uc3QgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbCB8fCAoeCA9PiBgXyR7eH1gKTtcblxuY29uc3QgSURMRSA9IFN5bWJvbCgnaWRsZScpO1xuY29uc3QgVE9VQ0hJTkcgPSBTeW1ib2woJ3RvdWNoaW5nJyk7XG5jb25zdCBTVEFSVF9BTklNQVRJTkcgPSBTeW1ib2woJ3N0YXJ0QW5pbWF0aW5nJyk7XG5jb25zdCBBTklNQVRJTkcgPSBTeW1ib2woJ2FuaW1hdGluZycpO1xuXG5jb25zdCBWRUxPQ0lUWV9USFJFU0hPTEQgPSAwLjI7XG5jb25zdCBWRUxPQ0lUWV9MSU5FQVJfQ09NQklOQVRJT04gPSAwLjg7XG5cbmNvbnN0IGRlZiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eS5iaW5kKE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IEMgPT4gY2xhc3MgZXh0ZW5kcyBjb21wb25lbnRDb3JlKEMpIHtcblxuICAvLyBAb3ZlcnJpZGVcbiAgZ2V0Q29tcG9uZW50TmFtZSgpIHtcbiAgICByZXR1cm4gJ3ktZHJhd2VyJztcbiAgfVxuXG4gIC8vIEBvdmVycmlkZVxuICBkZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlbmVkOiBmYWxzZSxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMjAwLFxuICAgICAgcGVyc2lzdGVudDogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIC8vIEBvdmVycmlkZVxuICBzaWRlRWZmZWN0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlbmVkOiAobykgPT4ge1xuICAgICAgICBpZiAobyA9PT0gdHJ1ZSkgdGhpcy5vcGVuKCk7XG4gICAgICAgIGVsc2UgdGhpcy5jbG9zZSgpO1xuICAgICAgfSxcbiAgICAgIHBlcnNpc3RlbnQ6IChkKSA9PiB7XG4gICAgICAgIGlmIChkID09PSB0cnVlKSB0aGlzLnBlcnNpc3QoKTtcbiAgICAgICAgZWxzZSB0aGlzLnVucGVyc2lzdCgpO1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgLy8gQG92ZXJyaWRlXG4gIHNldHVwQ29tcG9uZW50KGVsLCBwcm9wcykge1xuICAgIHN1cGVyLnNldHVwQ29tcG9uZW50KGVsLCBwcm9wcyk7XG5cbiAgICB0aGlzLmNhY2hlRE9NRWxlbWVudHMoKTtcbiAgICB0aGlzLmRlZlByb3BlcnRpZXMoKTtcbiAgICB0aGlzLmJpbmRDYWxsYmFja3MoKTtcblxuICAgIHRoaXMuanVtcFRvKHRoaXMub3BlbmVkKTtcbiAgICBpZiAoIXRoaXMucGVyc2lzdGVudCkgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIGlmICh0aGlzLnBlcnNpc3RlbnQpIHRoaXMuc2NyaW0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2FjaGVET01FbGVtZW50cygpIHtcbiAgICBkZWYodGhpcywgJ3NjcmltJywgeyB2YWx1ZTogdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3IoJy55LWRyYXdlci1zY3JpbScpIH0pO1xuICAgIGRlZih0aGlzLCAnY29udGVudCcsIHsgdmFsdWU6IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKCcueS1kcmF3ZXItY29udGVudCcpIH0pO1xuICB9XG5cbiAgZGVmUHJvcGVydGllcygpIHtcbiAgICBkZWYodGhpcywgJ3N0YXJ0WCcsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnc3RhcnRZJywgeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdwYWdlWCcsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAncGFnZVknLCB7IHZhbHVlOiAwLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ2xhc3RQYWdlWCcsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnbGFzdFBhZ2VZJywgeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdpc1Njcm9sbGluZycsIHsgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdzdGFydGVkTW92aW5nJywgeyB2YWx1ZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnbG9vcFN0YXRlJywgeyB2YWx1ZTogSURMRSwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICd2ZWxvY2l0eScsIHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnc3RhcnRUcmFuc2xhdGVYJywgeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICd0cmFuc2xhdGVYJywgeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSk7XG4gICAgZGVmKHRoaXMsICdhbmltYXRpb25GcmFtZVJlcXVlc3RlZCcsIHsgdmFsdWU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSB9KTtcbiAgICBkZWYodGhpcywgJ3RvdWNoaW5nJywgeyB2YWx1ZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnbGFzdFRpbWUnLCB7IHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnc2xpZGVyV2lkdGgnLCB7IHdyaXRhYmxlOiB0cnVlIH0pO1xuICAgIGRlZih0aGlzLCAnYW5pbWF0aW9uJywgeyB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICB9XG5cbiAgYmluZENhbGxiYWNrcygpIHtcbiAgICBkZWYodGhpcywgJ3RvdWNoU3RhcnRDYWxsYmFjaycsIHsgdmFsdWU6IHRoaXMudG91Y2hTdGFydENhbGxiYWNrLmJpbmQodGhpcykgfSk7XG4gICAgZGVmKHRoaXMsICd0b3VjaE1vdmVDYWxsYmFjaycsIHsgdmFsdWU6IHRoaXMudG91Y2hNb3ZlQ2FsbGJhY2suYmluZCh0aGlzKSB9KTtcbiAgICBkZWYodGhpcywgJ3RvdWNoRW5kQ2FsbGJhY2snLCB7IHZhbHVlOiB0aGlzLnRvdWNoRW5kQ2FsbGJhY2suYmluZCh0aGlzKSB9KTtcbiAgICBkZWYodGhpcywgJ3NjcmltQ2xpY2tDYWxsYmFjaycsIHsgdmFsdWU6IHRoaXMuc2NyaW1DbGlja0NhbGxiYWNrLmJpbmQodGhpcykgfSk7XG4gICAgZGVmKHRoaXMsICdhbmltYXRpb25GcmFtZUNhbGxiYWNrJywgeyB2YWx1ZTogdGhpcy5hbmltYXRpb25GcmFtZUNhbGxiYWNrLmJpbmQodGhpcykgfSk7XG4gIH1cblxuICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy50b3VjaFN0YXJ0Q2FsbGJhY2ssIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy50b3VjaE1vdmVDYWxsYmFjaywgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMudG91Y2hFbmRDYWxsYmFjaywgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgIHRoaXMuc2NyaW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnNjcmltQ2xpY2tDYWxsYmFjayk7XG4gIH1cblxuICByZW1vdmVFdmVudExpc3RlbmVycygpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy50b3VjaFN0YXJ0Q2FsbGJhY2ssIHsgcGFzc2l2ZTogZmFsc2UgfSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy50b3VjaE1vdmVDYWxsYmFjaywgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMudG91Y2hFbmRDYWxsYmFjaywgeyBwYXNzaXZlOiBmYWxzZSB9KTtcblxuICAgIHRoaXMuc2NyaW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnNjcmltQ2xpY2tDYWxsYmFjayk7XG4gIH1cblxuICByZXF1ZXN0QW5pbWF0aW9uTG9vcCgpIHtcbiAgICBpZiAoIXRoaXMuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0ZWQpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVDYWxsYmFjayk7XG4gICAgfVxuICB9XG5cbiAgZ2V0TmVhcmVzdFRvdWNoKHRvdWNoZXMpIHtcbiAgICBpZiAodG91Y2hlcy5sZW5ndGggPT09IDEpIHJldHVybiB0b3VjaGVzWzBdO1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUucmVkdWNlLmNhbGwodG91Y2hlcywgKGFjYywgdG91Y2gpID0+IHtcbiAgICAgIGNvbnN0IGRpc3QgPSBwYWdlRGlzdCh0aGlzLCB0b3VjaCk7XG4gICAgICByZXR1cm4gKGRpc3QgPCBhY2MuZGlzdCkgPyB7XG4gICAgICAgIGRpc3QsXG4gICAgICAgIHRvdWNoLFxuICAgICAgfSA6IGFjYztcbiAgICB9LCB7XG4gICAgICBkaXN0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICB0b3VjaDogbnVsbCxcbiAgICB9KS50b3VjaDtcbiAgfVxuXG4gIHRvdWNoU3RhcnRDYWxsYmFjayhlKSB7XG4gICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuaXNTY3JvbGxpbmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIGNvbnN0IHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgICAgdGhpcy5zdGFydFggPSB0b3VjaC5wYWdlWDtcbiAgICAgIHRoaXMuc3RhcnRZID0gdG91Y2gucGFnZVk7XG4gICAgICB0aGlzLnBhZ2VYID0gdG91Y2gucGFnZVg7XG4gICAgICB0aGlzLnBhZ2VZID0gdG91Y2gucGFnZVk7XG4gICAgICB0aGlzLmxhc3RQYWdlWCA9IHRvdWNoLnBhZ2VYO1xuICAgICAgdGhpcy5sYXN0UGFnZVkgPSB0b3VjaC5wYWdlWTtcblxuICAgICAgaWYgKHRoaXMub3BlbmVkIHx8ICh0aGlzLnBhZ2VYIDwgd2luZG93LmlubmVyV2lkdGggLyAzKSkge1xuICAgICAgICB0aGlzLnByZXBJbnRlcmFjdGlvbigpO1xuICAgICAgICB0aGlzLnRvdWNoaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb29wU3RhdGUgPSBUT1VDSElORztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b3VjaE1vdmVDYWxsYmFjayhlKSB7XG4gICAgaWYgKHRoaXMudG91Y2hpbmcpIHtcbiAgICAgIGNvbnN0IHRvdWNoID0gdGhpcy5nZXROZWFyZXN0VG91Y2goZS50b3VjaGVzKTtcbiAgICAgIHRoaXMucGFnZVggPSB0b3VjaC5wYWdlWDtcbiAgICAgIHRoaXMucGFnZVkgPSB0b3VjaC5wYWdlWTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJyAmJiB0aGlzLnN0YXJ0ZWRNb3ZpbmcpIHtcbiAgICAgICAgdGhpcy5pc1Njcm9sbGluZyA9IE1hdGguYWJzKHRoaXMuc3RhcnRZIC0gdGhpcy5wYWdlWSkgPiBNYXRoLmFicyh0aGlzLnN0YXJ0WCAtIHRoaXMucGFnZVgpO1xuICAgICAgICBpZiAoIXRoaXMuaXNTY3JvbGxpbmcpIHtcbiAgICAgICAgICB0aGlzLmxvb3BTdGF0ZSA9IFRPVUNISU5HO1xuICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc1Njcm9sbGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5zdGFydGVkTW92aW5nID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVNZW51T3BlbigpIHtcbiAgICBpZiAodGhpcy52ZWxvY2l0eSA+IFZFTE9DSVRZX1RIUkVTSE9MRCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSgnb3BlbmVkJywgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnZlbG9jaXR5IDwgLVZFTE9DSVRZX1RIUkVTSE9MRCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSgnb3BlbmVkJywgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50cmFuc2xhdGVYID49IHRoaXMuc2xpZGVyV2lkdGggLyAyKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKCdvcGVuZWQnLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRTdGF0ZSgnb3BlbmVkJywgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHRvdWNoRW5kQ2FsbGJhY2soZSkge1xuICAgIGlmICh0aGlzLnRvdWNoaW5nKSB7XG4gICAgICBpZiAodGhpcy5pc1Njcm9sbGluZyB8fCBlLnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN0YXJ0ZWRNb3ZpbmcpIHtcbiAgICAgICAgdGhpcy51cGRhdGVNZW51T3BlbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgICAgdGhpcy5zY3JpbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2FsbCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNjcmltLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb29wU3RhdGUgPSBTVEFSVF9BTklNQVRJTkc7XG4gICAgICB0aGlzLnN0YXJ0ZWRNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMudG91Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzY3JpbUNsaWNrQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG5cbiAgcHJlcEludGVyYWN0aW9uKCkge1xuICAgIHRoaXMuY29udGVudC5zdHlsZS53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gICAgdGhpcy5zY3JpbS5zdHlsZS53aWxsQ2hhbmdlID0gJ29wYWNpdHknO1xuICAgIHRoaXMuY29udGVudC5jbGFzc0xpc3QucmVtb3ZlKCd5LWRyYXdlci1vcGVuZWQnKTtcbiAgICB0aGlzLnNsaWRlcldpZHRoID0gdGhpcy5nZXRNb3ZhYmxlU2xpZGVyV2lkdGgoKTtcbiAgfVxuXG4gIGdldE1vdmFibGVTbGlkZXJXaWR0aCgpIHtcbiAgICAvLyBTaW5jZSBwYXJ0IG9mIHRoZSBzbGlkZXIgY291bGQgYmUgdmlzaWJsZSxcbiAgICAvLyB0aGUgd2lkdGggdGhhdCBpcyBcIm1vdmFibGVcIiBpcyBsZXNzIHRoYW4gdGhlIGNvbXBsZXRlIHNsaWRlciB3aWR0aFxuICAgIC8vIGFuZCBnaXZlbiBieVxuICAgIHJldHVybiAtdGhpcy5jb250ZW50Lm9mZnNldExlZnQ7XG4gIH1cblxuICBhbmltYXRlVG8ob3BlbmVkKSB7XG4gICAgdGhpcy5wcmVwSW50ZXJhY3Rpb24oKTtcbiAgICB0aGlzLnNldFN0YXRlKCdvcGVuZWQnLCBvcGVuZWQpO1xuICAgIHRoaXMubG9vcFN0YXRlID0gU1RBUlRfQU5JTUFUSU5HO1xuICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkxvb3AoKTtcbiAgfVxuXG4gIGp1bXBUbyhvcGVuZWQpIHtcbiAgICB0aGlzLnByZXBJbnRlcmFjdGlvbigpO1xuICAgIHRoaXMuc2V0U3RhdGUoJ29wZW5lZCcsIG9wZW5lZCk7XG4gICAgdGhpcy5sb29wU3RhdGUgPSBJRExFO1xuICAgIHRoaXMuc3RhcnRUcmFuc2xhdGVYID0gb3BlbmVkICogdGhpcy5zbGlkZXJXaWR0aDtcbiAgICB0aGlzLmVuZEFuaW1hdGluZygpO1xuICAgIHRoaXMudXBkYXRlRE9NKHRoaXMuc3RhcnRUcmFuc2xhdGVYLCB0aGlzLnNsaWRlcldpZHRoKTtcbiAgfVxuXG4gIHVwZGF0ZVRyYW5zbGF0ZVgoKSB7XG4gICAgY29uc3QgZGVsdGFYID0gdGhpcy5wYWdlWCAtIHRoaXMuc3RhcnRYO1xuICAgIHRoaXMudHJhbnNsYXRlWCA9IHRoaXMuc3RhcnRUcmFuc2xhdGVYICsgZGVsdGFYO1xuICAgIHRoaXMudHJhbnNsYXRlWCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRoaXMuc2xpZGVyV2lkdGgsIHRoaXMudHJhbnNsYXRlWCkpO1xuICAgIHJldHVybiBkZWx0YVg7XG4gIH1cblxuICBhbmltYXRpb25GcmFtZUNhbGxiYWNrKHRpbWUpIHtcbiAgICBzd2l0Y2ggKHRoaXMubG9vcFN0YXRlKSB7XG4gICAgICBjYXNlIFRPVUNISU5HOiB7XG4gICAgICAgIHRoaXMudG91Y2hpbmdGcmFtZSh0aW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgU1RBUlRfQU5JTUFUSU5HOiB7XG4gICAgICAgIHRoaXMuc3RhcnRBbmltYXRpbmdGcmFtZSh0aW1lKTtcbiAgICAgICAgdGhpcy5sb29wU3RhdGUgPSBBTklNQVRJTkc7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVDYWxsYmFjayh0aW1lKTsgLy8ganVtcCB0byBuZXh0IGNhc2UgYmxvY2tcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgQU5JTUFUSU5HOiB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW5nRnJhbWUodGltZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRvdWNoaW5nRnJhbWUodGltZSkge1xuICAgIGNvbnN0IHRpbWVEaWZmID0gdGltZSAtIHRoaXMubGFzdFRpbWU7XG5cbiAgICBpZiAodGltZURpZmYgPiAwKSB7XG4gICAgICBjb25zdCBwYWdlWERpZmYgPSB0aGlzLnBhZ2VYIC0gdGhpcy5sYXN0UGFnZVg7XG4gICAgICB0aGlzLnZlbG9jaXR5ID0gKFZFTE9DSVRZX0xJTkVBUl9DT01CSU5BVElPTiAqIChwYWdlWERpZmYgLyB0aW1lRGlmZikpICtcbiAgICAgICAgICAgICAgICAgICAgICAoKDEgLSBWRUxPQ0lUWV9MSU5FQVJfQ09NQklOQVRJT04pICogdGhpcy52ZWxvY2l0eSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVUcmFuc2xhdGVYKCk7XG4gICAgdGhpcy51cGRhdGVET00odGhpcy50cmFuc2xhdGVYLCB0aGlzLnNsaWRlcldpZHRoKTtcblxuICAgIHRoaXMubGFzdFRpbWUgPSB0aW1lO1xuICAgIHRoaXMubGFzdFBhZ2VYID0gdGhpcy5wYWdlWDtcbiAgICB0aGlzLmxhc3RQYWdlWSA9IHRoaXMucGFnZVk7XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZUNhbGxiYWNrKTtcbiAgfVxuXG4gIHN0YXJ0QW5pbWF0aW5nRnJhbWUodGltZSkge1xuICAgIHRoaXMudXBkYXRlVHJhbnNsYXRlWCgpO1xuXG4gICAgLy8gc3RvcmUgYWxsIGFuaW1hdGlvbiByZWxhdGVkIGRhdGEgaW4gdGhpcyBvYmplY3QsXG4gICAgLy8gZGVsZXRlIGFmdGVyIGFuaW1hdGlvbiBpcyBjb21wbGV0ZWRcbiAgICBjb25zdCBhbmltYXRpb24gPSB7fTtcbiAgICBhbmltYXRpb24uc3RhcnRYID0gdGhpcy50cmFuc2xhdGVYO1xuICAgIGFuaW1hdGlvbi5lbmRYID0gKHRoaXMub3BlbmVkID8gMSA6IDApICogdGhpcy5zbGlkZXJXaWR0aDtcbiAgICBhbmltYXRpb24uY2hhbmdlSW5WYWx1ZSA9IGFuaW1hdGlvbi5lbmRYIC0gYW5pbWF0aW9uLnN0YXJ0WDtcbiAgICBhbmltYXRpb24uc3RhcnRUaW1lID0gdGltZTtcbiAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcbiAgfVxuXG4gIGFuaW1hdGluZ0ZyYW1lKHRpbWUpIHtcbiAgICBjb25zdCB0aW1lSW5BbmltYXRpb24gPSB0aW1lIC0gdGhpcy5hbmltYXRpb24uc3RhcnRUaW1lO1xuXG4gICAgaWYgKHRpbWVJbkFuaW1hdGlvbiA8IHRoaXMudHJhbnNpdGlvbkR1cmF0aW9uKSB7XG4gICAgICB0aGlzLmFuaW1hdGluZ0NvbnQodGltZUluQW5pbWF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hbmltYXRpbmdFbmQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZURPTSh0aGlzLnN0YXJ0VHJhbnNsYXRlWCwgdGhpcy5zbGlkZXJXaWR0aCk7XG4gIH1cblxuICBhbmltYXRpbmdDb250KHRpbWVJbkFuaW1hdGlvbikge1xuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSB0aGlzLmFuaW1hdGlvbi5zdGFydFg7XG4gICAgY29uc3QgY2hhbmdlSW5WYWx1ZSA9IHRoaXMuYW5pbWF0aW9uLmNoYW5nZUluVmFsdWU7XG4gICAgdGhpcy5zdGFydFRyYW5zbGF0ZVggPSBsaW5lYXJUd2Vlbih0aW1lSW5BbmltYXRpb24sIHN0YXJ0VmFsdWUsIGNoYW5nZUluVmFsdWUsXG4gICAgICB0aGlzLnRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVDYWxsYmFjayk7XG4gIH1cblxuICBhbmltYXRpbmdFbmQoKSB7XG4gICAgLy8gZW5kIGFuaW1hdGlvblxuICAgIHRoaXMuc3RhcnRUcmFuc2xhdGVYID0gdGhpcy5hbmltYXRpb24uZW5kWDtcbiAgICBkZWxldGUgdGhpcy5hbmltYXRpb247XG4gICAgdGhpcy5lbmRBbmltYXRpbmcoKTtcbiAgfVxuXG4gIGVuZEFuaW1hdGluZygpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkZyYW1lUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5sb29wU3RhdGUgPSBJRExFO1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuXG4gICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICAvLyBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93WSA9ICdoaWRkZW4nO1xuICAgICAgdGhpcy5zY3JpbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2FsbCc7XG4gICAgICB0aGlzLmNvbnRlbnQuY2xhc3NMaXN0LmFkZCgneS1kcmF3ZXItb3BlbmVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3dZID0gJyc7XG4gICAgICB0aGlzLnNjcmltLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnJztcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRlbnQuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMuc2NyaW0uc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuXG4gICAgdGhpcy5maXJlRXZlbnQoJ3RyYW5zaXRpb25lZCcpO1xuICB9XG5cbiAgdXBkYXRlRE9NKHRyYW5zbGF0ZVgsIHNsaWRlcldpZHRoKSB7XG4gICAgdGhpcy5jb250ZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7dHJhbnNsYXRlWH1weClgO1xuICAgIHRoaXMuc2NyaW0uc3R5bGUub3BhY2l0eSA9IHRyYW5zbGF0ZVggLyBzbGlkZXJXaWR0aDtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuYW5pbWF0ZVRvKGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5hbmltYXRlVG8odHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHBlcnNpc3QoKSB7XG4gICAgdGhpcy5zY3JpbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLnNldFN0YXRlKCdwZXJzaXN0ZW50JywgdHJ1ZSk7XG4gIH1cblxuICB1bnBlcnNpc3QoKSB7XG4gICAgdGhpcy5zY3JpbS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIHRoaXMuc2V0U3RhdGUoJ3BlcnNpc3RlbnQnLCBmYWxzZSk7XG4gIH1cbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZsb3JpYW4gS2xhbXBmZXJcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVFxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcywgaW1wb3J0L25vLXVucmVzb2x2ZWQsIGltcG9ydC9leHRlbnNpb25zICovXG5pbXBvcnQgZHJhd2VyQ29yZSBmcm9tICcuLi9jb3JlJztcblxuY29uc3Qgc3R5bGUgPSBgXG48c3R5bGU+XG5AbWVkaWEgc2NyZWVuIHtcbiAgLnktZHJhd2VyLXNjcmltIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgdG9wOiAwO1xuICAgIHJpZ2h0OiAwO1xuICAgIGJvdHRvbTogMDtcbiAgICBsZWZ0OiAwO1xuICAgIG9wYWNpdHk6IDA7XG4gICAgei1pbmRleDogMDtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsMCwwKTtcbiAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjY3KTtcbiAgfVxuXG4gIC55LWRyYXdlci1jb250ZW50IHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgbGVmdDogMDtcbiAgICBib3R0b206IDA7XG4gICAgdG9wOiAwO1xuICAgIHotaW5kZXg6IDE7XG4gICAgb3ZlcmZsb3cteDogaGlkZGVuO1xuICAgIG92ZXJmbG93LXk6IGF1dG87XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLDAsMCk7XG4gICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xuICAgIGNvbnRhaW46IHN0cmljdDtcblxuICAgIGxlZnQ6IC0xOHJlbTtcbiAgICB3aWR0aDogMThyZW07XG4gICAgYmFja2dyb3VuZDogI2U4ZThlODtcbiAgfVxuXG4gIC55LWRyYXdlci1jb250ZW50LnktZHJhd2VyLW9wZW5lZCB7XG4gICAgbGVmdDogMCFpbXBvcnRhbnQ7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLDAsMCkhaW1wb3J0YW50O1xuICB9XG59XG5cbkBtZWRpYSBwcmludCB7XG4gIC55LWRyYXdlci1zY3JpbSB7XG4gICAgZGlzcGxheTogbm9uZSFpbXBvcnRhbnQ7XG4gIH1cblxuICAueS1kcmF3ZXItY29udGVudCB7XG4gICAgdHJhbnNmb3JtOiBub25lIWltcG9ydGFudDtcbiAgfVxufVxuXG48L3N0eWxlPmA7XG5cblxuZnVuY3Rpb24gZnJhZ21lbnRGcm9tU3RyaW5nKHN0ckhUTUwpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KHN0ckhUTUwpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEcmF3ZXIgZXh0ZW5kcyBkcmF3ZXJDb3JlKCkge1xuICBjb25zdHJ1Y3RvcihlbCwgcHJvcHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2V0dXBDb21wb25lbnQoZWwsIHByb3BzKTtcbiAgfVxuXG4gIC8vIEBvdmVycmlkZVxuICBzZXR1cERPTShlbCkge1xuICAgIGlmICghZWwpIHRocm93IEVycm9yKCdObyBlbGVtZW50IHByb3ZpZGVkJyk7XG5cbiAgICBjb25zdCBzY3JpbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHNjcmltLmNsYXNzTGlzdC5hZGQoJ3ktZHJhd2VyLXNjcmltJyk7XG5cbiAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCd5LWRyYXdlci1jb250ZW50Jyk7XG4gICAgd2hpbGUgKGVsLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWwuY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIGVsLmFwcGVuZENoaWxkKHNjcmltKTtcbiAgICBlbC5hcHBlbmRDaGlsZChjb250ZW50KTtcblxuICAgIGNvbnN0IHJlZiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdHlsZScpWzBdO1xuICAgIHJlZi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShmcmFnbWVudEZyb21TdHJpbmcoc3R5bGUpLCByZWYpO1xuXG4gICAgcmV0dXJuIGVsO1xuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vU3Vic2NyaWJlcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBJbm5lclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbm5lclN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5uZXJTdWJzY3JpYmVyKHBhcmVudCwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMub3V0ZXJWYWx1ZSA9IG91dGVyVmFsdWU7XG4gICAgICAgIHRoaXMub3V0ZXJJbmRleCA9IG91dGVySW5kZXg7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeU5leHQodGhpcy5vdXRlclZhbHVlLCB2YWx1ZSwgdGhpcy5vdXRlckluZGV4LCB0aGlzLmluZGV4KyssIHRoaXMpO1xuICAgIH07XG4gICAgSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5RXJyb3IoZXJyb3IsIHRoaXMpO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICBJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQubm90aWZ5Q29tcGxldGUodGhpcyk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIHJldHVybiBJbm5lclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLklubmVyU3Vic2NyaWJlciA9IElubmVyU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmVyU3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL09ic2VydmFibGUnKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHB1c2gtYmFzZWQgZXZlbnQgb3IgdmFsdWUgdGhhdCBhbiB7QGxpbmsgT2JzZXJ2YWJsZX0gY2FuIGVtaXQuXG4gKiBUaGlzIGNsYXNzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIG9wZXJhdG9ycyB0aGF0IG1hbmFnZSBub3RpZmljYXRpb25zLFxuICogbGlrZSB7QGxpbmsgbWF0ZXJpYWxpemV9LCB7QGxpbmsgZGVtYXRlcmlhbGl6ZX0sIHtAbGluayBvYnNlcnZlT259LCBhbmRcbiAqIG90aGVycy4gQmVzaWRlcyB3cmFwcGluZyB0aGUgYWN0dWFsIGRlbGl2ZXJlZCB2YWx1ZSwgaXQgYWxzbyBhbm5vdGF0ZXMgaXRcbiAqIHdpdGggbWV0YWRhdGEgb2YsIGZvciBpbnN0YW5jZSwgd2hhdCB0eXBlIG9mIHB1c2ggbWVzc2FnZSBpdCBpcyAoYG5leHRgLFxuICogYGVycm9yYCwgb3IgYGNvbXBsZXRlYCkuXG4gKlxuICogQHNlZSB7QGxpbmsgbWF0ZXJpYWxpemV9XG4gKiBAc2VlIHtAbGluayBkZW1hdGVyaWFsaXplfVxuICogQHNlZSB7QGxpbmsgb2JzZXJ2ZU9ufVxuICpcbiAqIEBjbGFzcyBOb3RpZmljYXRpb248VD5cbiAqL1xudmFyIE5vdGlmaWNhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm90aWZpY2F0aW9uKGtpbmQsIHZhbHVlLCBlcnJvcikge1xuICAgICAgICB0aGlzLmtpbmQgPSBraW5kO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGtpbmQgPT09ICdOJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsaXZlcnMgdG8gdGhlIGdpdmVuIGBvYnNlcnZlcmAgdGhlIHZhbHVlIHdyYXBwZWQgYnkgdGhpcyBOb3RpZmljYXRpb24uXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcn0gb2JzZXJ2ZXJcbiAgICAgKiBAcmV0dXJuXG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmVycm9yICYmIG9ic2VydmVyLmVycm9yKHRoaXMuZXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmNvbXBsZXRlICYmIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIHNvbWUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFja3MsIGRlbGl2ZXIgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZVxuICAgICAqIGN1cnJlbnQgTm90aWZpY2F0aW9uIHRvIHRoZSBjb3JyZWN0bHkgY29ycmVzcG9uZGluZyBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogdm9pZH0gbmV4dCBBbiBPYnNlcnZlciBgbmV4dGAgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IGFueSk6IHZvaWR9IFtlcnJvcl0gQW4gT2JzZXJ2ZXIgYGVycm9yYCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gQW4gT2JzZXJ2ZXIgYGNvbXBsZXRlYCBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIHthbnl9XG4gICAgICovXG4gICAgTm90aWZpY2F0aW9uLnByb3RvdHlwZS5kbyA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIGtpbmQgPSB0aGlzLmtpbmQ7XG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQgJiYgbmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgJ0UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvciAmJiBlcnJvcih0aGlzLmVycm9yKTtcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZSAmJiBjb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUYWtlcyBhbiBPYnNlcnZlciBvciBpdHMgaW5kaXZpZHVhbCBjYWxsYmFjayBmdW5jdGlvbnMsIGFuZCBjYWxscyBgb2JzZXJ2ZWBcbiAgICAgKiBvciBgZG9gIG1ldGhvZHMgYWNjb3JkaW5nbHkuXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbih2YWx1ZTogVCk6IHZvaWR9IG5leHRPck9ic2VydmVyIEFuIE9ic2VydmVyIG9yXG4gICAgICogdGhlIGBuZXh0YCBjYWxsYmFjay5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGVycjogYW55KTogdm9pZH0gW2Vycm9yXSBBbiBPYnNlcnZlciBgZXJyb3JgIGNhbGxiYWNrLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW2NvbXBsZXRlXSBBbiBPYnNlcnZlciBgY29tcGxldGVgIGNhbGxiYWNrLlxuICAgICAqIEByZXR1cm4ge2FueX1cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24ucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uIChuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIGlmIChuZXh0T3JPYnNlcnZlciAmJiB0eXBlb2YgbmV4dE9yT2JzZXJ2ZXIubmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2ZShuZXh0T3JPYnNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kbyhuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQganVzdCBkZWxpdmVycyB0aGUgbm90aWZpY2F0aW9uIHJlcHJlc2VudGVkXG4gICAgICogYnkgdGhpcyBOb3RpZmljYXRpb24gaW5zdGFuY2UuXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5wcm90b3R5cGUudG9PYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2luZCA9IHRoaXMua2luZDtcbiAgICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUub2YodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlICdFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUudGhyb3codGhpcy5lcnJvcik7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgbm90aWZpY2F0aW9uIGtpbmQgdmFsdWUnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgc2hvcnRjdXQgdG8gY3JlYXRlIGEgTm90aWZpY2F0aW9uIGluc3RhbmNlIG9mIHRoZSB0eXBlIGBuZXh0YCBmcm9tIGFcbiAgICAgKiBnaXZlbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge1R9IHZhbHVlIFRoZSBgbmV4dGAgdmFsdWUuXG4gICAgICogQHJldHVybiB7Tm90aWZpY2F0aW9uPFQ+fSBUaGUgXCJuZXh0XCIgTm90aWZpY2F0aW9uIHJlcHJlc2VudGluZyB0aGVcbiAgICAgKiBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24uY3JlYXRlTmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb3RpZmljYXRpb24oJ04nLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudW5kZWZpbmVkVmFsdWVOb3RpZmljYXRpb247XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHNob3J0Y3V0IHRvIGNyZWF0ZSBhIE5vdGlmaWNhdGlvbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBgZXJyb3JgIGZyb20gYVxuICAgICAqIGdpdmVuIGVycm9yLlxuICAgICAqIEBwYXJhbSB7YW55fSBbZXJyXSBUaGUgYGVycm9yYCBlcnJvci5cbiAgICAgKiBAcmV0dXJuIHtOb3RpZmljYXRpb248VD59IFRoZSBcImVycm9yXCIgTm90aWZpY2F0aW9uIHJlcHJlc2VudGluZyB0aGVcbiAgICAgKiBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBOb3RpZmljYXRpb24uY3JlYXRlRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm90aWZpY2F0aW9uKCdFJywgdW5kZWZpbmVkLCBlcnIpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBzaG9ydGN1dCB0byBjcmVhdGUgYSBOb3RpZmljYXRpb24gaW5zdGFuY2Ugb2YgdGhlIHR5cGUgYGNvbXBsZXRlYC5cbiAgICAgKiBAcmV0dXJuIHtOb3RpZmljYXRpb248YW55Pn0gVGhlIHZhbHVlbGVzcyBcImNvbXBsZXRlXCIgTm90aWZpY2F0aW9uLlxuICAgICAqL1xuICAgIE5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVOb3RpZmljYXRpb247XG4gICAgfTtcbiAgICBOb3RpZmljYXRpb24uY29tcGxldGVOb3RpZmljYXRpb24gPSBuZXcgTm90aWZpY2F0aW9uKCdDJyk7XG4gICAgTm90aWZpY2F0aW9uLnVuZGVmaW5lZFZhbHVlTm90aWZpY2F0aW9uID0gbmV3IE5vdGlmaWNhdGlvbignTicsIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIE5vdGlmaWNhdGlvbjtcbn0oKSk7XG5leHBvcnRzLk5vdGlmaWNhdGlvbiA9IE5vdGlmaWNhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vdGlmaWNhdGlvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuZW1wdHkgPSB7XG4gICAgY2xvc2VkOiB0cnVlLFxuICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkgeyB9LFxuICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyKSB7IHRocm93IGVycjsgfSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24gKCkgeyB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuL1N1YnNjcmliZXInKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgT3V0ZXJTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3V0ZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE91dGVyU3Vic2NyaWJlcigpIHtcbiAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIE91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBPdXRlclN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUVycm9yID0gZnVuY3Rpb24gKGVycm9yLCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgICB9O1xuICAgIE91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIE91dGVyU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuT3V0ZXJTdWJzY3JpYmVyID0gT3V0ZXJTdWJzY3JpYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3V0ZXJTdWJzY3JpYmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpYmVyJyk7XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEgPSByZXF1aXJlKCcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InKTtcbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YmplY3RTdWJzY3JpcHRpb24nKTtcbnZhciByeFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4vc3ltYm9sL3J4U3Vic2NyaWJlcicpO1xuLyoqXG4gKiBAY2xhc3MgU3ViamVjdFN1YnNjcmliZXI8VD5cbiAqL1xudmFyIFN1YmplY3RTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ViamVjdFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgfVxuICAgIHJldHVybiBTdWJqZWN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmV4cG9ydHMuU3ViamVjdFN1YnNjcmliZXIgPSBTdWJqZWN0U3Vic2NyaWJlcjtcbi8qKlxuICogQGNsYXNzIFN1YmplY3Q8VD5cbiAqL1xudmFyIFN1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YmplY3QoKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9ic2VydmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMudGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBTdWJqZWN0LnByb3RvdHlwZVtyeFN1YnNjcmliZXJfMS4kJHJ4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ViamVjdFN1YnNjcmliZXIodGhpcyk7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gbmV3IEFub255bW91c1N1YmplY3QodGhpcywgdGhpcyk7XG4gICAgICAgIHN1YmplY3Qub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29weVtpXS5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50aHJvd25FcnJvciA9IGVycjtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcl8xLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgICAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb3B5W2ldLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIFN1YmplY3QucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBudWxsO1xuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLl90cnlTdWJzY3JpYmUuY2FsbCh0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXzEuT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKHRoaXMudGhyb3duRXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpcHRpb25fMS5TdWJqZWN0U3Vic2NyaXB0aW9uKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJqZWN0LnByb3RvdHlwZS5hc09ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKCk7XG4gICAgICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgfTtcbiAgICBTdWJqZWN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJqZWN0O1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5TdWJqZWN0ID0gU3ViamVjdDtcbi8qKlxuICogQGNsYXNzIEFub255bW91c1N1YmplY3Q8VD5cbiAqL1xudmFyIEFub255bW91c1N1YmplY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbm9ueW1vdXNTdWJqZWN0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFub255bW91c1N1YmplY3QoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24ubmV4dCkge1xuICAgICAgICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5jb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFub255bW91c1N1YmplY3Q7XG59KFN1YmplY3QpKTtcbmV4cG9ydHMuQW5vbnltb3VzU3ViamVjdCA9IEFub255bW91c1N1YmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaXB0aW9uXzEgPSByZXF1aXJlKCcuL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBTdWJqZWN0U3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ViamVjdFN1YnNjcmlwdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJqZWN0U3Vic2NyaXB0aW9uKHN1YmplY3QsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IHN1YnNjcmliZXI7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgfVxuICAgIFN1YmplY3RTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHZhciBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0O1xuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gc3ViamVjdC5vYnNlcnZlcnM7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IG51bGw7XG4gICAgICAgIGlmICghb2JzZXJ2ZXJzIHx8IG9ic2VydmVycy5sZW5ndGggPT09IDAgfHwgc3ViamVjdC5pc1N0b3BwZWQgfHwgc3ViamVjdC5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaWJlckluZGV4ID0gb2JzZXJ2ZXJzLmluZGV4T2YodGhpcy5zdWJzY3JpYmVyKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIG9ic2VydmVycy5zcGxpY2Uoc3Vic2NyaWJlckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YmplY3RTdWJzY3JpcHRpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5TdWJqZWN0U3Vic2NyaXB0aW9uID0gU3ViamVjdFN1YnNjcmlwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3RTdWJzY3JpcHRpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBpc0Z1bmN0aW9uXzEgPSByZXF1aXJlKCcuL3V0aWwvaXNGdW5jdGlvbicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi9TdWJzY3JpcHRpb24nKTtcbnZhciBPYnNlcnZlcl8xID0gcmVxdWlyZSgnLi9PYnNlcnZlcicpO1xudmFyIHJ4U3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi9zeW1ib2wvcnhTdWJzY3JpYmVyJyk7XG4vKipcbiAqIEltcGxlbWVudHMgdGhlIHtAbGluayBPYnNlcnZlcn0gaW50ZXJmYWNlIGFuZCBleHRlbmRzIHRoZVxuICoge0BsaW5rIFN1YnNjcmlwdGlvbn0gY2xhc3MuIFdoaWxlIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGlzIHRoZSBwdWJsaWMgQVBJIGZvclxuICogY29uc3VtaW5nIHRoZSB2YWx1ZXMgb2YgYW4ge0BsaW5rIE9ic2VydmFibGV9LCBhbGwgT2JzZXJ2ZXJzIGdldCBjb252ZXJ0ZWQgdG9cbiAqIGEgU3Vic2NyaWJlciwgaW4gb3JkZXIgdG8gcHJvdmlkZSBTdWJzY3JpcHRpb24tbGlrZSBjYXBhYmlsaXRpZXMgc3VjaCBhc1xuICogYHVuc3Vic2NyaWJlYC4gU3Vic2NyaWJlciBpcyBhIGNvbW1vbiB0eXBlIGluIFJ4SlMsIGFuZCBjcnVjaWFsIGZvclxuICogaW1wbGVtZW50aW5nIG9wZXJhdG9ycywgYnV0IGl0IGlzIHJhcmVseSB1c2VkIGFzIGEgcHVibGljIEFQSS5cbiAqXG4gKiBAY2xhc3MgU3Vic2NyaWJlcjxUPlxuICovXG52YXIgU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbih2YWx1ZTogVCk6IHZvaWR9IFtkZXN0aW5hdGlvbk9yTmV4dF0gQSBwYXJ0aWFsbHlcbiAgICAgKiBkZWZpbmVkIE9ic2VydmVyIG9yIGEgYG5leHRgIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZTogP2FueSk6IHZvaWR9IFtlcnJvcl0gVGhlIGBlcnJvcmAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3luY0Vycm9yVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gT2JzZXJ2ZXJfMS5lbXB0eTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBpZiAoIWRlc3RpbmF0aW9uT3JOZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBPYnNlcnZlcl8xLmVtcHR5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbk9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uT3JOZXh0IGluc3RhbmNlb2YgU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uT3JOZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5hZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFNhZmVTdWJzY3JpYmVyKHRoaXMsIGRlc3RpbmF0aW9uT3JOZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN1YnNjcmliZXIucHJvdG90eXBlW3J4U3Vic2NyaWJlcl8xLiQkcnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG4gICAgLyoqXG4gICAgICogQSBzdGF0aWMgZmFjdG9yeSBmb3IgYSBTdWJzY3JpYmVyLCBnaXZlbiBhIChwb3RlbnRpYWxseSBwYXJ0aWFsKSBkZWZpbml0aW9uXG4gICAgICogb2YgYW4gT2JzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbih4OiA/VCk6IHZvaWR9IFtuZXh0XSBUaGUgYG5leHRgIGNhbGxiYWNrIG9mIGFuIE9ic2VydmVyLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oZTogP2FueSk6IHZvaWR9IFtlcnJvcl0gVGhlIGBlcnJvcmAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpYmVyPFQ+fSBBIFN1YnNjcmliZXIgd3JhcHBpbmcgdGhlIChwYXJ0aWFsbHkgZGVmaW5lZClcbiAgICAgKiBPYnNlcnZlciByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxuICAgICAqL1xuICAgIFN1YnNjcmliZXIuY3JlYXRlID0gZnVuY3Rpb24gKG5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyKG5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIHN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVyO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIHtAbGluayBPYnNlcnZlcn0gY2FsbGJhY2sgdG8gcmVjZWl2ZSBub3RpZmljYXRpb25zIG9mIHR5cGUgYG5leHRgIGZyb21cbiAgICAgKiB0aGUgT2JzZXJ2YWJsZSwgd2l0aCBhIHZhbHVlLiBUaGUgT2JzZXJ2YWJsZSBtYXkgY2FsbCB0aGlzIG1ldGhvZCAwIG9yIG1vcmVcbiAgICAgKiB0aW1lcy5cbiAgICAgKiBAcGFyYW0ge1R9IFt2YWx1ZV0gVGhlIGBuZXh0YCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBlcnJvcmAgZnJvbVxuICAgICAqIHRoZSBPYnNlcnZhYmxlLCB3aXRoIGFuIGF0dGFjaGVkIHtAbGluayBFcnJvcn0uIE5vdGlmaWVzIHRoZSBPYnNlcnZlciB0aGF0XG4gICAgICogdGhlIE9ic2VydmFibGUgaGFzIGV4cGVyaWVuY2VkIGFuIGVycm9yIGNvbmRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge2FueX0gW2Vycl0gVGhlIGBlcnJvcmAgZXhjZXB0aW9uLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgYSB2YWx1ZWxlc3Mgbm90aWZpY2F0aW9uIG9mIHR5cGVcbiAgICAgKiBgY29tcGxldGVgIGZyb20gdGhlIE9ic2VydmFibGUuIE5vdGlmaWVzIHRoZSBPYnNlcnZlciB0aGF0IHRoZSBPYnNlcnZhYmxlXG4gICAgICogaGFzIGZpbmlzaGVkIHNlbmRpbmcgcHVzaC1iYXNlZCBub3RpZmljYXRpb25zLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZUFuZFJlY3ljbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF9wYXJlbnQgPSBfYS5fcGFyZW50LCBfcGFyZW50cyA9IF9hLl9wYXJlbnRzO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9wYXJlbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgICAgICB0aGlzLl9wYXJlbnRzID0gX3BhcmVudHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmliZXI7XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5TdWJzY3JpYmVyID0gU3Vic2NyaWJlcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU2FmZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYWZlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTYWZlU3Vic2NyaWJlcihfcGFyZW50U3Vic2NyaWJlciwgb2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fcGFyZW50U3Vic2NyaWJlciA9IF9wYXJlbnRTdWJzY3JpYmVyO1xuICAgICAgICB2YXIgbmV4dDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24ob2JzZXJ2ZXJPck5leHQpKSB7XG4gICAgICAgICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JzZXJ2ZXJPck5leHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBvYnNlcnZlck9yTmV4dDtcbiAgICAgICAgICAgIG5leHQgPSBvYnNlcnZlck9yTmV4dC5uZXh0O1xuICAgICAgICAgICAgZXJyb3IgPSBvYnNlcnZlck9yTmV4dC5lcnJvcjtcbiAgICAgICAgICAgIGNvbXBsZXRlID0gb2JzZXJ2ZXJPck5leHQuY29tcGxldGU7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24oY29udGV4dC51bnN1YnNjcmliZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChjb250ZXh0LnVuc3Vic2NyaWJlLmJpbmQoY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGV4dC51bnN1YnNjcmliZSA9IHRoaXMudW5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fbmV4dCA9IG5leHQ7XG4gICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuX2NvbXBsZXRlID0gY29tcGxldGU7XG4gICAgfVxuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0b3BwZWQgJiYgdGhpcy5fbmV4dCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fbmV4dCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHRoaXMuX25leHQsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fZXJyb3IsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9lcnJvciwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHRoaXMuX2NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHRoaXMuX2NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl9fdHJ5T3JVbnN1YiA9IGZ1bmN0aW9uIChmbiwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl9fdHJ5T3JTZXRFcnJvciA9IGZ1bmN0aW9uIChwYXJlbnQsIGZuLCB2YWx1ZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcGFyZW50LnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICAgICAgcGFyZW50LnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBTYWZlU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50U3Vic2NyaWJlciA9IG51bGw7XG4gICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2FmZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmliZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgaXNBcnJheV8xID0gcmVxdWlyZSgnLi91dGlsL2lzQXJyYXknKTtcbnZhciBpc09iamVjdF8xID0gcmVxdWlyZSgnLi91dGlsL2lzT2JqZWN0Jyk7XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi91dGlsL2lzRnVuY3Rpb24nKTtcbnZhciB0cnlDYXRjaF8xID0gcmVxdWlyZSgnLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3JfMSA9IHJlcXVpcmUoJy4vdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yJyk7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBkaXNwb3NhYmxlIHJlc291cmNlLCBzdWNoIGFzIHRoZSBleGVjdXRpb24gb2YgYW4gT2JzZXJ2YWJsZS4gQVxuICogU3Vic2NyaXB0aW9uIGhhcyBvbmUgaW1wb3J0YW50IG1ldGhvZCwgYHVuc3Vic2NyaWJlYCwgdGhhdCB0YWtlcyBubyBhcmd1bWVudFxuICogYW5kIGp1c3QgZGlzcG9zZXMgdGhlIHJlc291cmNlIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHN1YnNjcmlwdGlvbnMgbWF5IGJlIGdyb3VwZWQgdG9nZXRoZXIgdGhyb3VnaCB0aGUgYGFkZCgpYFxuICogbWV0aG9kLCB3aGljaCB3aWxsIGF0dGFjaCBhIGNoaWxkIFN1YnNjcmlwdGlvbiB0byB0aGUgY3VycmVudCBTdWJzY3JpcHRpb24uXG4gKiBXaGVuIGEgU3Vic2NyaXB0aW9uIGlzIHVuc3Vic2NyaWJlZCwgYWxsIGl0cyBjaGlsZHJlbiAoYW5kIGl0cyBncmFuZGNoaWxkcmVuKVxuICogd2lsbCBiZSB1bnN1YnNjcmliZWQgYXMgd2VsbC5cbiAqXG4gKiBAY2xhc3MgU3Vic2NyaXB0aW9uXG4gKi9cbnZhciBTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW3Vuc3Vic2NyaWJlXSBBIGZ1bmN0aW9uIGRlc2NyaWJpbmcgaG93IHRvXG4gICAgICogcGVyZm9ybSB0aGUgZGlzcG9zYWwgb2YgcmVzb3VyY2VzIHdoZW4gdGhlIGB1bnN1YnNjcmliZWAgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb24odW5zdWJzY3JpYmUpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoaXMgU3Vic2NyaXB0aW9uIGhhcyBhbHJlYWR5IGJlZW4gdW5zdWJzY3JpYmVkLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl91bnN1YnNjcmliZSA9IHVuc3Vic2NyaWJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgc3Vic2NyaXB0aW9uLiBNYXksIGZvciBpbnN0YW5jZSwgY2FuY2VsXG4gICAgICogYW4gb25nb2luZyBPYnNlcnZhYmxlIGV4ZWN1dGlvbiBvciBjYW5jZWwgYW55IG90aGVyIHR5cGUgb2Ygd29yayB0aGF0XG4gICAgICogc3RhcnRlZCB3aGVuIHRoZSBTdWJzY3JpcHRpb24gd2FzIGNyZWF0ZWQuXG4gICAgICogQHJldHVybiB7dm9pZH1cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaGFzRXJyb3JzID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvcnM7XG4gICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIF9wYXJlbnQgPSBfYS5fcGFyZW50LCBfcGFyZW50cyA9IF9hLl9wYXJlbnRzLCBfdW5zdWJzY3JpYmUgPSBfYS5fdW5zdWJzY3JpYmUsIF9zdWJzY3JpcHRpb25zID0gX2EuX3N1YnNjcmlwdGlvbnM7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50cyA9IG51bGw7XG4gICAgICAgIC8vIG51bGwgb3V0IF9zdWJzY3JpcHRpb25zIGZpcnN0IHNvIGFueSBjaGlsZCBzdWJzY3JpcHRpb25zIHRoYXQgYXR0ZW1wdFxuICAgICAgICAvLyB0byByZW1vdmUgdGhlbXNlbHZlcyBmcm9tIHRoaXMgc3Vic2NyaXB0aW9uIHdpbGwgbm9vcFxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBsZW4gPSBfcGFyZW50cyA/IF9wYXJlbnRzLmxlbmd0aCA6IDA7XG4gICAgICAgIC8vIGlmIHRoaXMuX3BhcmVudCBpcyBudWxsLCB0aGVuIHNvIGlzIHRoaXMuX3BhcmVudHMsIGFuZCB3ZVxuICAgICAgICAvLyBkb24ndCBoYXZlIHRvIHJlbW92ZSBvdXJzZWx2ZXMgZnJvbSBhbnkgcGFyZW50IHN1YnNjcmlwdGlvbnMuXG4gICAgICAgIHdoaWxlIChfcGFyZW50KSB7XG4gICAgICAgICAgICBfcGFyZW50LnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIGlmIHRoaXMuX3BhcmVudHMgaXMgbnVsbCBvciBpbmRleCA+PSBsZW4sXG4gICAgICAgICAgICAvLyB0aGVuIF9wYXJlbnQgaXMgc2V0IHRvIG51bGwsIGFuZCB0aGUgbG9vcCBleGl0c1xuICAgICAgICAgICAgX3BhcmVudCA9ICsraW5kZXggPCBsZW4gJiYgX3BhcmVudHNbaW5kZXhdIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb25fMS5pc0Z1bmN0aW9uKF91bnN1YnNjcmliZSkpIHtcbiAgICAgICAgICAgIHZhciB0cmlhbCA9IHRyeUNhdGNoXzEudHJ5Q2F0Y2goX3Vuc3Vic2NyaWJlKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRyaWFsID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMgfHwgKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yID9cbiAgICAgICAgICAgICAgICAgICAgZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZS5lcnJvcnMpIDogW2Vycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5XzEuaXNBcnJheShfc3Vic2NyaXB0aW9ucykpIHtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBsZW4gPSBfc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBzdWIgPSBfc3Vic2NyaXB0aW9uc1tpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0XzEuaXNPYmplY3Qoc3ViKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJpYWwgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHN1Yi51bnN1YnNjcmliZSkuY2FsbChzdWIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJpYWwgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0Vycm9ycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3JfMS5VbnN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmbGF0dGVuVW5zdWJzY3JpcHRpb25FcnJvcnMoZXJyLmVycm9ycykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzRXJyb3JzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdWJzY3JpcHRpb25FcnJvcl8xLlVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHRlYXIgZG93biB0byBiZSBjYWxsZWQgZHVyaW5nIHRoZSB1bnN1YnNjcmliZSgpIG9mIHRoaXNcbiAgICAgKiBTdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdGVhciBkb3duIGJlaW5nIGFkZGVkIGlzIGEgc3Vic2NyaXB0aW9uIHRoYXQgaXMgYWxyZWFkeVxuICAgICAqIHVuc3Vic2NyaWJlZCwgaXMgdGhlIHNhbWUgcmVmZXJlbmNlIGBhZGRgIGlzIGJlaW5nIGNhbGxlZCBvbiwgb3IgaXNcbiAgICAgKiBgU3Vic2NyaXB0aW9uLkVNUFRZYCwgaXQgd2lsbCBub3QgYmUgYWRkZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIHN1YnNjcmlwdGlvbiBpcyBhbHJlYWR5IGluIGFuIGBjbG9zZWRgIHN0YXRlLCB0aGUgcGFzc2VkXG4gICAgICogdGVhciBkb3duIGxvZ2ljIHdpbGwgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RlYXJkb3duTG9naWN9IHRlYXJkb3duIFRoZSBhZGRpdGlvbmFsIGxvZ2ljIHRvIGV4ZWN1dGUgb25cbiAgICAgKiB0ZWFyZG93bi5cbiAgICAgKiBAcmV0dXJuIHtTdWJzY3JpcHRpb259IFJldHVybnMgdGhlIFN1YnNjcmlwdGlvbiB1c2VkIG9yIGNyZWF0ZWQgdG8gYmVcbiAgICAgKiBhZGRlZCB0byB0aGUgaW5uZXIgc3Vic2NyaXB0aW9ucyBsaXN0LiBUaGlzIFN1YnNjcmlwdGlvbiBjYW4gYmUgdXNlZCB3aXRoXG4gICAgICogYHJlbW92ZSgpYCB0byByZW1vdmUgdGhlIHBhc3NlZCB0ZWFyZG93biBsb2dpYyBmcm9tIHRoZSBpbm5lciBzdWJzY3JpcHRpb25zXG4gICAgICogbGlzdC5cbiAgICAgKi9cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0ZWFyZG93bikge1xuICAgICAgICBpZiAoIXRlYXJkb3duIHx8ICh0ZWFyZG93biA9PT0gU3Vic2NyaXB0aW9uLkVNUFRZKSkge1xuICAgICAgICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVhcmRvd24gPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB0ZWFyZG93bjtcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgdGVhcmRvd24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRlYXJkb3duKTtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jbG9zZWQgfHwgdHlwZW9mIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbi5fYWRkUGFyZW50ICE9PSAnZnVuY3Rpb24nIC8qIHF1YWNrIHF1YWNrICovKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBzdWJzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLl9zdWJzY3JpcHRpb25zID0gW3RtcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucmVjb2duaXplZCB0ZWFyZG93biAnICsgdGVhcmRvd24gKyAnIGFkZGVkIHRvIFN1YnNjcmlwdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnMgfHwgKHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBbXSk7XG4gICAgICAgIHN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgICBzdWJzY3JpcHRpb24uX2FkZFBhcmVudCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBTdWJzY3JpcHRpb24gZnJvbSB0aGUgaW50ZXJuYWwgbGlzdCBvZiBzdWJzY3JpcHRpb25zIHRoYXQgd2lsbFxuICAgICAqIHVuc3Vic2NyaWJlIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUgcHJvY2VzcyBvZiB0aGlzIFN1YnNjcmlwdGlvbi5cbiAgICAgKiBAcGFyYW0ge1N1YnNjcmlwdGlvbn0gc3Vic2NyaXB0aW9uIFRoZSBzdWJzY3JpcHRpb24gdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge3ZvaWR9XG4gICAgICovXG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucztcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb25JbmRleCA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZihzdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbkluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuc3BsaWNlKHN1YnNjcmlwdGlvbkluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fYWRkUGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBfcGFyZW50ID0gX2EuX3BhcmVudCwgX3BhcmVudHMgPSBfYS5fcGFyZW50cztcbiAgICAgICAgaWYgKCFfcGFyZW50IHx8IF9wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHBhcmVudCwgb3IgdGhlIG5ldyBwYXJlbnQgaXMgdGhlIHNhbWUgYXMgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IHBhcmVudCwgdGhlbiBzZXQgdGhpcy5fcGFyZW50IHRvIHRoZSBuZXcgcGFyZW50LlxuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFfcGFyZW50cykge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhbHJlYWR5IG9uZSBwYXJlbnQsIGJ1dCBub3QgbXVsdGlwbGUsIGFsbG9jYXRlIGFuIEFycmF5IHRvXG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgcmVzdCBvZiB0aGUgcGFyZW50IFN1YnNjcmlwdGlvbnMuXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRzID0gW3BhcmVudF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoX3BhcmVudHMuaW5kZXhPZihwYXJlbnQpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gT25seSBhZGQgdGhlIG5ldyBwYXJlbnQgdG8gdGhlIF9wYXJlbnRzIGxpc3QgaWYgaXQncyBub3QgYWxyZWFkeSB0aGVyZS5cbiAgICAgICAgICAgIF9wYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLkVNUFRZID0gKGZ1bmN0aW9uIChlbXB0eSkge1xuICAgICAgICBlbXB0eS5jbG9zZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgfShuZXcgU3Vic2NyaXB0aW9uKCkpKTtcbiAgICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpKTtcbmV4cG9ydHMuU3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uO1xuZnVuY3Rpb24gZmxhdHRlblVuc3Vic2NyaXB0aW9uRXJyb3JzKGVycm9ycykge1xuICAgIHJldHVybiBlcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChlcnJzLCBlcnIpIHsgcmV0dXJuIGVycnMuY29uY2F0KChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yXzEuVW5zdWJzY3JpcHRpb25FcnJvcikgPyBlcnIuZXJyb3JzIDogZXJyKTsgfSwgW10pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaXB0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkZWZlcl8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9kZWZlcicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUuZGVmZXIgPSBkZWZlcl8xLmRlZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVmZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGFqYXhfMSA9IHJlcXVpcmUoJy4uLy4uLy4uL29ic2VydmFibGUvZG9tL2FqYXgnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmFqYXggPSBhamF4XzEuYWpheDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFqYXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZyb21FdmVudF8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9mcm9tRXZlbnQnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLmZyb21FdmVudCA9IGZyb21FdmVudF8xLmZyb21FdmVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyb21FdmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VfMSA9IHJlcXVpcmUoJy4uLy4uL29ic2VydmFibGUvbWVyZ2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLm1lcmdlID0gbWVyZ2VfMS5tZXJnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBvZl8xID0gcmVxdWlyZSgnLi4vLi4vb2JzZXJ2YWJsZS9vZicpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUub2YgPSBvZl8xLm9mO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRocm93XzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL3Rocm93Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS50aHJvdyA9IHRocm93XzEuX3Rocm93O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3cuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRpbWVyXzEgPSByZXF1aXJlKCcuLi8uLi9vYnNlcnZhYmxlL3RpbWVyJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS50aW1lciA9IHRpbWVyXzEudGltZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgY2F0Y2hfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2NhdGNoJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY2F0Y2ggPSBjYXRjaF8xLl9jYXRjaDtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5fY2F0Y2ggPSBjYXRjaF8xLl9jYXRjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkZWJvdW5jZVRpbWVfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RlYm91bmNlVGltZScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRlYm91bmNlVGltZSA9IGRlYm91bmNlVGltZV8xLmRlYm91bmNlVGltZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlVGltZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgZGVsYXlfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL2RlbGF5Jyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGVsYXkgPSBkZWxheV8xLmRlbGF5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkID0gZGlzdGluY3RVbnRpbEtleUNoYW5nZWRfMS5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBkb18xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZG8nKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5kbyA9IGRvXzEuX2RvO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLl9kbyA9IGRvXzEuX2RvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG8uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIGZpbHRlcl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvZmlsdGVyJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmlsdGVyID0gZmlsdGVyXzEuZmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBtYXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21hcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLm1hcCA9IG1hcF8xLm1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgbWVyZ2VBbGxfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL21lcmdlQWxsJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2VBbGwgPSBtZXJnZUFsbF8xLm1lcmdlQWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2VBbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHJldHJ5V2hlbl8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3IvcmV0cnlXaGVuJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUucmV0cnlXaGVuID0gcmV0cnlXaGVuXzEucmV0cnlXaGVuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmV0cnlXaGVuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBzaGFyZV8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc2hhcmUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zaGFyZSA9IHNoYXJlXzEuc2hhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc3RhcnRXaXRoXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zdGFydFdpdGgnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zdGFydFdpdGggPSBzdGFydFdpdGhfMS5zdGFydFdpdGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGFydFdpdGguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHN3aXRjaF8xID0gcmVxdWlyZSgnLi4vLi4vb3BlcmF0b3Ivc3dpdGNoJyk7XG5PYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3dpdGNoID0gc3dpdGNoXzEuX3N3aXRjaDtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5fc3dpdGNoID0gc3dpdGNoXzEuX3N3aXRjaDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN3aXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgc3dpdGNoTWFwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9zd2l0Y2hNYXAnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS5zd2l0Y2hNYXAgPSBzd2l0Y2hNYXBfMS5zd2l0Y2hNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zd2l0Y2hNYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRha2VfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3Rha2UnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50YWtlID0gdGFrZV8xLnRha2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB0YWtlVW50aWxfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3Rha2VVbnRpbCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnRha2VVbnRpbCA9IHRha2VVbnRpbF8xLnRha2VVbnRpbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2VVbnRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi8uLi9PYnNlcnZhYmxlJyk7XG52YXIgdGhyb3R0bGVUaW1lXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci90aHJvdHRsZVRpbWUnKTtcbk9ic2VydmFibGVfMS5PYnNlcnZhYmxlLnByb3RvdHlwZS50aHJvdHRsZVRpbWUgPSB0aHJvdHRsZVRpbWVfMS50aHJvdHRsZVRpbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvdHRsZVRpbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vLi4vT2JzZXJ2YWJsZScpO1xudmFyIHdpdGhMYXRlc3RGcm9tXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci93aXRoTGF0ZXN0RnJvbScpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLndpdGhMYXRlc3RGcm9tID0gd2l0aExhdGVzdEZyb21fMS53aXRoTGF0ZXN0RnJvbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdpdGhMYXRlc3RGcm9tLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciB6aXBfMSA9IHJlcXVpcmUoJy4uLy4uL29wZXJhdG9yL3ppcCcpO1xuT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUucHJvdG90eXBlLnppcCA9IHppcF8xLnppcFByb3RvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9emlwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIFNjYWxhck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vU2NhbGFyT2JzZXJ2YWJsZScpO1xudmFyIEVtcHR5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi9FbXB0eU9ic2VydmFibGUnKTtcbnZhciBpc1NjaGVkdWxlcl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc1NjaGVkdWxlcicpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBBcnJheU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcnJheU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIGlmICghc2NoZWR1bGVyICYmIGFycmF5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5faXNTY2FsYXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGFycmF5WzBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIEFycmF5T2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoYXJyYXksIHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZShhcnJheSwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHNvbWUgdmFsdWVzIHlvdSBzcGVjaWZ5IGFzIGFyZ3VtZW50cyxcbiAgICAgKiBpbW1lZGlhdGVseSBvbmUgYWZ0ZXIgdGhlIG90aGVyLCBhbmQgdGhlbiBlbWl0cyBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5FbWl0cyB0aGUgYXJndW1lbnRzIHlvdSBwcm92aWRlLCB0aGVuIGNvbXBsZXRlcy5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL29mLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogVGhpcyBzdGF0aWMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQgb25seVxuICAgICAqIGVtaXRzIHRoZSBhcmd1bWVudHMgZ2l2ZW4sIGFuZCB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uIHRoZXJlYWZ0ZXIuIEl0IGNhblxuICAgICAqIGJlIHVzZWQgZm9yIGNvbXBvc2luZyB3aXRoIG90aGVyIE9ic2VydmFibGVzLCBzdWNoIGFzIHdpdGgge0BsaW5rIGNvbmNhdH0uXG4gICAgICogQnkgZGVmYXVsdCwgaXQgdXNlcyBhIGBudWxsYCBJU2NoZWR1bGVyLCB3aGljaCBtZWFucyB0aGUgYG5leHRgXG4gICAgICogbm90aWZpY2F0aW9ucyBhcmUgc2VudCBzeW5jaHJvbm91c2x5LCBhbHRob3VnaCB3aXRoIGEgZGlmZmVyZW50IElTY2hlZHVsZXJcbiAgICAgKiBpdCBpcyBwb3NzaWJsZSB0byBkZXRlcm1pbmUgd2hlbiB0aG9zZSBub3RpZmljYXRpb25zIHdpbGwgYmUgZGVsaXZlcmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCAxMCwgMjAsIDMwLCB0aGVuICdhJywgJ2InLCAnYycsIHRoZW4gc3RhcnQgdGlja2luZyBldmVyeSBzZWNvbmQuPC9jYXB0aW9uPlxuICAgICAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS5vZigxMCwgMjAsIDMwKTtcbiAgICAgKiB2YXIgbGV0dGVycyA9IFJ4Lk9ic2VydmFibGUub2YoJ2EnLCAnYicsICdjJyk7XG4gICAgICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICAgKiB2YXIgcmVzdWx0ID0gbnVtYmVycy5jb25jYXQobGV0dGVycykuY29uY2F0KGludGVydmFsKTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIGVtcHR5fVxuICAgICAqIEBzZWUge0BsaW5rIG5ldmVyfVxuICAgICAqIEBzZWUge0BsaW5rIHRocm93fVxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi5UfSB2YWx1ZXMgQXJndW1lbnRzIHRoYXQgcmVwcmVzZW50IGBuZXh0YCB2YWx1ZXMgdG8gYmUgZW1pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAgICogdGhlIGVtaXNzaW9ucyBvZiB0aGUgYG5leHRgIG5vdGlmaWNhdGlvbnMuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGVhY2ggZ2l2ZW4gaW5wdXQgdmFsdWUuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgb2ZcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEFycmF5T2JzZXJ2YWJsZS5vZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NoZWR1bGVyID0gYXJyYXlbYXJyYXkubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcbiAgICAgICAgICAgIGFycmF5LnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2NoZWR1bGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICBpZiAobGVuID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGUoYXJyYXksIHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNjYWxhck9ic2VydmFibGVfMS5TY2FsYXJPYnNlcnZhYmxlKGFycmF5WzBdLCBzY2hlZHVsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGVfMS5FbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXJyYXlPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBhcnJheSA9IHN0YXRlLmFycmF5LCBpbmRleCA9IHN0YXRlLmluZGV4LCBjb3VudCA9IHN0YXRlLmNvdW50LCBzdWJzY3JpYmVyID0gc3RhdGUuc3Vic2NyaWJlcjtcbiAgICAgICAgaWYgKGluZGV4ID49IGNvdW50KSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KGFycmF5W2luZGV4XSk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcbiAgICB9O1xuICAgIEFycmF5T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICAgIHZhciBjb3VudCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEFycmF5T2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGFycmF5OiBhcnJheSwgaW5kZXg6IGluZGV4LCBjb3VudDogY291bnQsIHN1YnNjcmliZXI6IHN1YnNjcmliZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCAmJiAhc3Vic2NyaWJlci5jbG9zZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBcnJheU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkFycmF5T2JzZXJ2YWJsZSA9IEFycmF5T2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFycmF5T2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YmplY3RfMSA9IHJlcXVpcmUoJy4uL1N1YmplY3QnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIFN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaXB0aW9uJyk7XG4vKipcbiAqIEBjbGFzcyBDb25uZWN0YWJsZU9ic2VydmFibGU8VD5cbiAqL1xudmFyIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbm5lY3RhYmxlT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25uZWN0YWJsZU9ic2VydmFibGUoc291cmNlLCBzdWJqZWN0RmFjdG9yeSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuc3ViamVjdEZhY3RvcnkgPSBzdWJqZWN0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5fcmVmQ291bnQgPSAwO1xuICAgIH1cbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdWJqZWN0KCkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5nZXRTdWJqZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3ViamVjdCA9IHRoaXMuX3N1YmplY3Q7XG4gICAgICAgIGlmICghc3ViamVjdCB8fCBzdWJqZWN0LmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5fc3ViamVjdCA9IHRoaXMuc3ViamVjdEZhY3RvcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3ViamVjdDtcbiAgICB9O1xuICAgIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSB0aGlzLl9jb25uZWN0aW9uO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24gPSB0aGlzLl9jb25uZWN0aW9uID0gbmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5hZGQodGhpcy5zb3VyY2VcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKG5ldyBDb25uZWN0YWJsZVN1YnNjcmliZXIodGhpcy5nZXRTdWJqZWN0KCksIHRoaXMpKSk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gU3Vic2NyaXB0aW9uXzEuU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLnJlZkNvdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZWZDb3VudE9wZXJhdG9yKHRoaXMpKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25uZWN0YWJsZU9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkNvbm5lY3RhYmxlT2JzZXJ2YWJsZSA9IENvbm5lY3RhYmxlT2JzZXJ2YWJsZTtcbmV4cG9ydHMuY29ubmVjdGFibGVPYnNlcnZhYmxlRGVzY3JpcHRvciA9IHtcbiAgICBvcGVyYXRvcjogeyB2YWx1ZTogbnVsbCB9LFxuICAgIF9yZWZDb3VudDogeyB2YWx1ZTogMCwgd3JpdGFibGU6IHRydWUgfSxcbiAgICBfc3Vic2NyaWJlOiB7IHZhbHVlOiBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgfSxcbiAgICBnZXRTdWJqZWN0OiB7IHZhbHVlOiBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLmdldFN1YmplY3QgfSxcbiAgICBjb25uZWN0OiB7IHZhbHVlOiBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlLmNvbm5lY3QgfSxcbiAgICByZWZDb3VudDogeyB2YWx1ZTogQ29ubmVjdGFibGVPYnNlcnZhYmxlLnByb3RvdHlwZS5yZWZDb3VudCB9XG59O1xudmFyIENvbm5lY3RhYmxlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbm5lY3RhYmxlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25uZWN0YWJsZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgIH1cbiAgICBDb25uZWN0YWJsZVN1YnNjcmliZXIucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5fZXJyb3IuY2FsbCh0aGlzLCBlcnIpO1xuICAgIH07XG4gICAgQ29ubmVjdGFibGVTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICBDb25uZWN0YWJsZVN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gdGhpcy5jb25uZWN0YWJsZTtcbiAgICAgICAgaWYgKGNvbm5lY3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0gY29ubmVjdGFibGUuX2Nvbm5lY3Rpb247XG4gICAgICAgICAgICBjb25uZWN0YWJsZS5fcmVmQ291bnQgPSAwO1xuICAgICAgICAgICAgY29ubmVjdGFibGUuX3N1YmplY3QgPSBudWxsO1xuICAgICAgICAgICAgY29ubmVjdGFibGUuX2Nvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb25uZWN0YWJsZVN1YnNjcmliZXI7XG59KFN1YmplY3RfMS5TdWJqZWN0U3Vic2NyaWJlcikpO1xudmFyIFJlZkNvdW50T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZkNvdW50T3BlcmF0b3IoY29ubmVjdGFibGUpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgIH1cbiAgICBSZWZDb3VudE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICB2YXIgY29ubmVjdGFibGUgPSB0aGlzLmNvbm5lY3RhYmxlO1xuICAgICAgICBjb25uZWN0YWJsZS5fcmVmQ291bnQrKztcbiAgICAgICAgdmFyIHJlZkNvdW50ZXIgPSBuZXcgUmVmQ291bnRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGNvbm5lY3RhYmxlKTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUocmVmQ291bnRlcik7XG4gICAgICAgIGlmICghcmVmQ291bnRlci5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJlZkNvdW50ZXIuY29ubmVjdGlvbiA9IGNvbm5lY3RhYmxlLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH07XG4gICAgcmV0dXJuIFJlZkNvdW50T3BlcmF0b3I7XG59KCkpO1xudmFyIFJlZkNvdW50U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZkNvdW50U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWZDb3VudFN1YnNjcmliZXIoZGVzdGluYXRpb24sIGNvbm5lY3RhYmxlKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25uZWN0YWJsZSA9IGNvbm5lY3RhYmxlO1xuICAgIH1cbiAgICBSZWZDb3VudFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbm5lY3RhYmxlID0gdGhpcy5jb25uZWN0YWJsZTtcbiAgICAgICAgaWYgKCFjb25uZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3RhYmxlID0gbnVsbDtcbiAgICAgICAgdmFyIHJlZkNvdW50ID0gY29ubmVjdGFibGUuX3JlZkNvdW50O1xuICAgICAgICBpZiAocmVmQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0YWJsZS5fcmVmQ291bnQgPSByZWZDb3VudCAtIDE7XG4gICAgICAgIGlmIChyZWZDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8vXG4gICAgICAgIC8vIENvbXBhcmUgdGhlIGxvY2FsIFJlZkNvdW50U3Vic2NyaWJlcidzIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIHRvIHRoZVxuICAgICAgICAvLyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiBvbiB0aGUgc2hhcmVkIENvbm5lY3RhYmxlT2JzZXJ2YWJsZS4gSW4gY2FzZXNcbiAgICAgICAgLy8gd2hlcmUgdGhlIENvbm5lY3RhYmxlT2JzZXJ2YWJsZSBzb3VyY2Ugc3luY2hyb25vdXNseSBlbWl0cyB2YWx1ZXMsIGFuZFxuICAgICAgICAvLyB0aGUgUmVmQ291bnRTdWJzY3JpYmVyJ3MgZG93bnN0cmVhbSBPYnNlcnZlcnMgc3luY2hyb25vdXNseSB1bnN1YnNjcmliZSxcbiAgICAgICAgLy8gZXhlY3V0aW9uIGNvbnRpbnVlcyB0byBoZXJlIGJlZm9yZSB0aGUgUmVmQ291bnRPcGVyYXRvciBoYXMgYSBjaGFuY2UgdG9cbiAgICAgICAgLy8gc3VwcGx5IHRoZSBSZWZDb3VudFN1YnNjcmliZXIgd2l0aCB0aGUgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uLlxuICAgICAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAgICAgLy8gYGBgXG4gICAgICAgIC8vIE9ic2VydmFibGUucmFuZ2UoMCwgMTApXG4gICAgICAgIC8vICAgLnB1Ymxpc2goKVxuICAgICAgICAvLyAgIC5yZWZDb3VudCgpXG4gICAgICAgIC8vICAgLnRha2UoNSlcbiAgICAgICAgLy8gICAuc3Vic2NyaWJlKCk7XG4gICAgICAgIC8vIGBgYFxuICAgICAgICAvLyBJbiBvcmRlciB0byBhY2NvdW50IGZvciB0aGlzIGNhc2UsIFJlZkNvdW50U3Vic2NyaWJlciBzaG91bGQgb25seSBkaXNwb3NlXG4gICAgICAgIC8vIHRoZSBDb25uZWN0YWJsZU9ic2VydmFibGUncyBzaGFyZWQgY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gaWYgdGhlXG4gICAgICAgIC8vIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIGV4aXN0cywgKmFuZCogZWl0aGVyOlxuICAgICAgICAvLyAgIGEuIFJlZkNvdW50U3Vic2NyaWJlciBkb2Vzbid0IGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIHNoYXJlZCBjb25uZWN0aW9uXG4gICAgICAgIC8vICAgICAgU3Vic2NyaXB0aW9uIHlldCwgb3IsXG4gICAgICAgIC8vICAgYi4gUmVmQ291bnRTdWJzY3JpYmVyJ3MgY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gcmVmZXJlbmNlIGlzIGlkZW50aWNhbFxuICAgICAgICAvLyAgICAgIHRvIHRoZSBzaGFyZWQgY29ubmVjdGlvbiBTdWJzY3JpcHRpb25cbiAgICAgICAgLy8vXG4gICAgICAgIHZhciBjb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uO1xuICAgICAgICB2YXIgc2hhcmVkQ29ubmVjdGlvbiA9IGNvbm5lY3RhYmxlLl9jb25uZWN0aW9uO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICBpZiAoc2hhcmVkQ29ubmVjdGlvbiAmJiAoIWNvbm5lY3Rpb24gfHwgc2hhcmVkQ29ubmVjdGlvbiA9PT0gY29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgIHNoYXJlZENvbm5lY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJlZkNvdW50U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbm5lY3RhYmxlT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIERlZmVyT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmVyT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZlck9ic2VydmFibGUob2JzZXJ2YWJsZUZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub2JzZXJ2YWJsZUZhY3RvcnkgPSBvYnNlcnZhYmxlRmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQsIG9uIHN1YnNjcmliZSwgY2FsbHMgYW4gT2JzZXJ2YWJsZSBmYWN0b3J5IHRvXG4gICAgICogbWFrZSBhbiBPYnNlcnZhYmxlIGZvciBlYWNoIG5ldyBPYnNlcnZlci5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5DcmVhdGVzIHRoZSBPYnNlcnZhYmxlIGxhemlseSwgdGhhdCBpcywgb25seSB3aGVuIGl0XG4gICAgICogaXMgc3Vic2NyaWJlZC5cbiAgICAgKiA8L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2RlZmVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgICAqXG4gICAgICogYGRlZmVyYCBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0aGUgT2JzZXJ2YWJsZSBvbmx5IHdoZW4gdGhlIE9ic2VydmVyXG4gICAgICogc3Vic2NyaWJlcywgYW5kIGNyZWF0ZSBhIGZyZXNoIE9ic2VydmFibGUgZm9yIGVhY2ggT2JzZXJ2ZXIuIEl0IHdhaXRzIHVudGlsXG4gICAgICogYW4gT2JzZXJ2ZXIgc3Vic2NyaWJlcyB0byBpdCwgYW5kIHRoZW4gaXQgZ2VuZXJhdGVzIGFuIE9ic2VydmFibGUsXG4gICAgICogdHlwaWNhbGx5IHdpdGggYW4gT2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uLiBJdCBkb2VzIHRoaXMgYWZyZXNoIGZvciBlYWNoXG4gICAgICogc3Vic2NyaWJlciwgc28gYWx0aG91Z2ggZWFjaCBzdWJzY3JpYmVyIG1heSB0aGluayBpdCBpcyBzdWJzY3JpYmluZyB0byB0aGVcbiAgICAgKiBzYW1lIE9ic2VydmFibGUsIGluIGZhY3QgZWFjaCBzdWJzY3JpYmVyIGdldHMgaXRzIG93biBpbmRpdmlkdWFsXG4gICAgICogT2JzZXJ2YWJsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPlN1YnNjcmliZSB0byBlaXRoZXIgYW4gT2JzZXJ2YWJsZSBvZiBjbGlja3Mgb3IgYW4gT2JzZXJ2YWJsZSBvZiBpbnRlcnZhbCwgYXQgcmFuZG9tPC9jYXB0aW9uPlxuICAgICAqIHZhciBjbGlja3NPckludGVydmFsID0gUnguT2JzZXJ2YWJsZS5kZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICogICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAqICAgICByZXR1cm4gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICAgICAqICAgfSBlbHNlIHtcbiAgICAgKiAgICAgcmV0dXJuIFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogY2xpY2tzT3JJbnRlcnZhbC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAgICpcbiAgICAgKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmcgYmVoYXZpb3I6XG4gICAgICogLy8gSWYgdGhlIHJlc3VsdCBvZiBNYXRoLnJhbmRvbSgpIGlzIGdyZWF0ZXIgdGhhbiAwLjUgaXQgd2lsbCBsaXN0ZW5cbiAgICAgKiAvLyBmb3IgY2xpY2tzIGFueXdoZXJlIG9uIHRoZSBcImRvY3VtZW50XCI7IHdoZW4gZG9jdW1lbnQgaXMgY2xpY2tlZCBpdFxuICAgICAqIC8vIHdpbGwgbG9nIGEgTW91c2VFdmVudCBvYmplY3QgdG8gdGhlIGNvbnNvbGUuIElmIHRoZSByZXN1bHQgaXMgbGVzc1xuICAgICAqIC8vIHRoYW4gMC41IGl0IHdpbGwgZW1pdCBhc2NlbmRpbmcgbnVtYmVycywgb25lIGV2ZXJ5IHNlY29uZCgxMDAwbXMpLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpOiBTdWJzY3JpYmFibGVPclByb21pc2V9IG9ic2VydmFibGVGYWN0b3J5IFRoZSBPYnNlcnZhYmxlXG4gICAgICogZmFjdG9yeSBmdW5jdGlvbiB0byBpbnZva2UgZm9yIGVhY2ggT2JzZXJ2ZXIgdGhhdCBzdWJzY3JpYmVzIHRvIHRoZSBvdXRwdXRcbiAgICAgKiBPYnNlcnZhYmxlLiBNYXkgYWxzbyByZXR1cm4gYSBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGNvbnZlcnRlZCBvbiB0aGUgZmx5XG4gICAgICogdG8gYW4gT2JzZXJ2YWJsZS5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHdob3NlIE9ic2VydmVycycgc3Vic2NyaXB0aW9ucyB0cmlnZ2VyXG4gICAgICogYW4gaW52b2NhdGlvbiBvZiB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqIEBzdGF0aWMgdHJ1ZVxuICAgICAqIEBuYW1lIGRlZmVyXG4gICAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICAgKi9cbiAgICBEZWZlck9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKG9ic2VydmFibGVGYWN0b3J5KSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJPYnNlcnZhYmxlKG9ic2VydmFibGVGYWN0b3J5KTtcbiAgICB9O1xuICAgIERlZmVyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVmZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMub2JzZXJ2YWJsZUZhY3RvcnkpO1xuICAgIH07XG4gICAgcmV0dXJuIERlZmVyT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRGVmZXJPYnNlcnZhYmxlID0gRGVmZXJPYnNlcnZhYmxlO1xudmFyIERlZmVyU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmVyU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZlclN1YnNjcmliZXIoZGVzdGluYXRpb24sIGZhY3RvcnkpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmZhY3RvcnkgPSBmYWN0b3J5O1xuICAgICAgICB0aGlzLnRyeURlZmVyKCk7XG4gICAgfVxuICAgIERlZmVyU3Vic2NyaWJlci5wcm90b3R5cGUudHJ5RGVmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9jYWxsRmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlZmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2NhbGxGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5mYWN0b3J5KCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWZlclN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVmZXJPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBFbXB0eU9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbXB0eU9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW1wdHlPYnNlcnZhYmxlKHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG5vIGl0ZW1zIHRvIHRoZSBPYnNlcnZlciBhbmQgaW1tZWRpYXRlbHlcbiAgICAgKiBlbWl0cyBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5KdXN0IGVtaXRzICdjb21wbGV0ZScsIGFuZCBub3RoaW5nIGVsc2UuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy9lbXB0eS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uLiBJdCBjYW4gYmUgdXNlZCBmb3IgY29tcG9zaW5nIHdpdGggb3RoZXJcbiAgICAgKiBPYnNlcnZhYmxlcywgc3VjaCBhcyBpbiBhIHtAbGluayBtZXJnZU1hcH0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBudW1iZXIgNywgdGhlbiBjb21wbGV0ZS48L2NhcHRpb24+XG4gICAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUuZW1wdHkoKS5zdGFydFdpdGgoNyk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBhbmQgZmxhdHRlbiBvbmx5IG9kZCBudW1iZXJzIHRvIHRoZSBzZXF1ZW5jZSAnYScsICdiJywgJ2MnPC9jYXB0aW9uPlxuICAgICAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAgICogdmFyIHJlc3VsdCA9IGludGVydmFsLm1lcmdlTWFwKHggPT5cbiAgICAgKiAgIHggJSAyID09PSAxID8gUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKSA6IFJ4Lk9ic2VydmFibGUuZW1wdHkoKVxuICAgICAqICk7XG4gICAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZyB0byB0aGUgY29uc29sZTpcbiAgICAgKiAvLyB4IGlzIGVxdWFsIHRvIHRoZSBjb3VudCBvbiB0aGUgaW50ZXJ2YWwgZWcoMCwxLDIsMywuLi4pXG4gICAgICogLy8geCB3aWxsIG9jY3VyIGV2ZXJ5IDEwMDBtc1xuICAgICAqIC8vIGlmIHggJSAyIGlzIGVxdWFsIHRvIDEgcHJpbnQgYWJjXG4gICAgICogLy8gaWYgeCAlIDIgaXMgbm90IGVxdWFsIHRvIDEgbm90aGluZyB3aWxsIGJlIG91dHB1dFxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgICAqIEBzZWUge0BsaW5rIG5ldmVyfVxuICAgICAqIEBzZWUge0BsaW5rIG9mfVxuICAgICAqIEBzZWUge0BsaW5rIHRocm93fVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEEge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgICAqIHRoZSBlbWlzc2lvbiBvZiB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIFwiZW1wdHlcIiBPYnNlcnZhYmxlOiBlbWl0cyBvbmx5IHRoZSBjb21wbGV0ZVxuICAgICAqIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBlbXB0eVxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgRW1wdHlPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzY2hlZHVsZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGUoc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIEVtcHR5T2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBhcmcuc3Vic2NyaWJlcjtcbiAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgIH07XG4gICAgRW1wdHlPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEVtcHR5T2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwgeyBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRW1wdHlPYnNlcnZhYmxlO1xufShPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkpO1xuZXhwb3J0cy5FbXB0eU9ic2VydmFibGUgPSBFbXB0eU9ic2VydmFibGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbXB0eU9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEVycm9yT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVycm9yT2JzZXJ2YWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFcnJvck9ic2VydmFibGUoZXJyb3IsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbm8gaXRlbXMgdG8gdGhlIE9ic2VydmVyIGFuZCBpbW1lZGlhdGVseVxuICAgICAqIGVtaXRzIGFuIGVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICAgKlxuICAgICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5KdXN0IGVtaXRzICdlcnJvcicsIGFuZCBub3RoaW5nIGVsc2UuXG4gICAgICogPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy90aHJvdy5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICAgKiBlbWl0cyB0aGUgZXJyb3Igbm90aWZpY2F0aW9uLiBJdCBjYW4gYmUgdXNlZCBmb3IgY29tcG9zaW5nIHdpdGggb3RoZXJcbiAgICAgKiBPYnNlcnZhYmxlcywgc3VjaCBhcyBpbiBhIHtAbGluayBtZXJnZU1hcH0uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBudW1iZXIgNywgdGhlbiBlbWl0IGFuIGVycm9yLjwvY2FwdGlvbj5cbiAgICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS50aHJvdyhuZXcgRXJyb3IoJ29vcHMhJykpLnN0YXJ0V2l0aCg3KTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGUgPT4gY29uc29sZS5lcnJvcihlKSk7XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgYW5kIGZsYXR0ZW4gbnVtYmVycyB0byB0aGUgc2VxdWVuY2UgJ2EnLCAnYicsICdjJywgYnV0IHRocm93IGFuIGVycm9yIGZvciAxMzwvY2FwdGlvbj5cbiAgICAgKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgICAqIHZhciByZXN1bHQgPSBpbnRlcnZhbC5tZXJnZU1hcCh4ID0+XG4gICAgICogICB4ID09PSAxMyA/XG4gICAgICogICAgIFJ4Lk9ic2VydmFibGUudGhyb3coJ1RoaXJ0ZWVucyBhcmUgYmFkJykgOlxuICAgICAqICAgICBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpXG4gICAgICogKTtcbiAgICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGUgPT4gY29uc29sZS5lcnJvcihlKSk7XG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBjcmVhdGV9XG4gICAgICogQHNlZSB7QGxpbmsgZW1wdHl9XG4gICAgICogQHNlZSB7QGxpbmsgbmV2ZXJ9XG4gICAgICogQHNlZSB7QGxpbmsgb2Z9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gZXJyb3IgVGhlIHBhcnRpY3VsYXIgRXJyb3IgdG8gcGFzcyB0byB0aGUgZXJyb3Igbm90aWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZW1pc3Npb24gb2YgdGhlIGVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBlcnJvciBPYnNlcnZhYmxlOiBlbWl0cyBvbmx5IHRoZSBlcnJvciBub3RpZmljYXRpb25cbiAgICAgKiB1c2luZyB0aGUgZ2l2ZW4gZXJyb3IgYXJndW1lbnQuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgdGhyb3dcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEVycm9yT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAoZXJyb3IsIHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yT2JzZXJ2YWJsZShlcnJvciwgc2NoZWR1bGVyKTtcbiAgICB9O1xuICAgIEVycm9yT2JzZXJ2YWJsZS5kaXNwYXRjaCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIGVycm9yID0gYXJnLmVycm9yLCBzdWJzY3JpYmVyID0gYXJnLnN1YnNjcmliZXI7XG4gICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyb3IpO1xuICAgIH07XG4gICAgRXJyb3JPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy5lcnJvcjtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoc2NoZWR1bGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEVycm9yT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEVycm9yT2JzZXJ2YWJsZTtcbn0oT2JzZXJ2YWJsZV8xLk9ic2VydmFibGUpKTtcbmV4cG9ydHMuRXJyb3JPYnNlcnZhYmxlID0gRXJyb3JPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXJyb3JPYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vT2JzZXJ2YWJsZScpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgaXNGdW5jdGlvbl8xID0gcmVxdWlyZSgnLi4vdXRpbC9pc0Z1bmN0aW9uJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmZ1bmN0aW9uIGlzTm9kZVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0eXBlb2Ygc291cmNlT2JqLmFkZExpc3RlbmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VPYmoucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBpc0pRdWVyeVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iaikge1xuICAgIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0eXBlb2Ygc291cmNlT2JqLm9uID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VPYmoub2ZmID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gaXNOb2RlTGlzdChzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdG9TdHJpbmcuY2FsbChzb3VyY2VPYmopID09PSAnW29iamVjdCBOb2RlTGlzdF0nO1xufVxuZnVuY3Rpb24gaXNIVE1MQ29sbGVjdGlvbihzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdG9TdHJpbmcuY2FsbChzb3VyY2VPYmopID09PSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nO1xufVxuZnVuY3Rpb24gaXNFdmVudFRhcmdldChzb3VyY2VPYmopIHtcbiAgICByZXR1cm4gISFzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBzb3VyY2VPYmoucmVtb3ZlRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgRnJvbUV2ZW50T2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZyb21FdmVudE9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnJvbUV2ZW50T2JzZXJ2YWJsZShzb3VyY2VPYmosIGV2ZW50TmFtZSwgc2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc291cmNlT2JqID0gc291cmNlT2JqO1xuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGV2ZW50cyBvZiBhIHNwZWNpZmljIHR5cGUgY29taW5nIGZyb20gdGhlXG4gICAgICogZ2l2ZW4gZXZlbnQgdGFyZ2V0LlxuICAgICAqXG4gICAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNyZWF0ZXMgYW4gT2JzZXJ2YWJsZSBmcm9tIERPTSBldmVudHMsIG9yIE5vZGVcbiAgICAgKiBFdmVudEVtaXR0ZXIgZXZlbnRzIG9yIG90aGVycy48L3NwYW4+XG4gICAgICpcbiAgICAgKiA8aW1nIHNyYz1cIi4vaW1nL2Zyb21FdmVudC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSBieSBhdHRhY2hpbmcgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYW4gXCJldmVudCB0YXJnZXRcIixcbiAgICAgKiB3aGljaCBtYXkgYmUgYW4gb2JqZWN0IHdpdGggYGFkZEV2ZW50TGlzdGVuZXJgIGFuZCBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAsXG4gICAgICogYSBOb2RlLmpzIEV2ZW50RW1pdHRlciwgYSBqUXVlcnkgc3R5bGUgRXZlbnRFbWl0dGVyLCBhIE5vZGVMaXN0IGZyb20gdGhlXG4gICAgICogRE9NLCBvciBhbiBIVE1MQ29sbGVjdGlvbiBmcm9tIHRoZSBET00uIFRoZSBldmVudCBoYW5kbGVyIGlzIGF0dGFjaGVkIHdoZW5cbiAgICAgKiB0aGUgb3V0cHV0IE9ic2VydmFibGUgaXMgc3Vic2NyaWJlZCwgYW5kIHJlbW92ZWQgd2hlbiB0aGUgU3Vic2NyaXB0aW9uIGlzXG4gICAgICogdW5zdWJzY3JpYmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgY2xpY2tzIGhhcHBlbmluZyBvbiB0aGUgRE9NIGRvY3VtZW50PC9jYXB0aW9uPlxuICAgICAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gICAgICogY2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIC8vIFJlc3VsdHMgaW46XG4gICAgICogLy8gTW91c2VFdmVudCBvYmplY3QgbG9nZ2VkIHRvIGNvbnNvbGUgZXZlcnl0aW1lIGEgY2xpY2tcbiAgICAgKiAvLyBvY2N1cnMgb24gdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgZnJvbX1cbiAgICAgKiBAc2VlIHtAbGluayBmcm9tRXZlbnRQYXR0ZXJufVxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudFRhcmdldExpa2V9IHRhcmdldCBUaGUgRE9NRWxlbWVudCwgZXZlbnQgdGFyZ2V0LCBOb2RlLmpzXG4gICAgICogRXZlbnRFbWl0dGVyLCBOb2RlTGlzdCBvciBIVE1MQ29sbGVjdGlvbiB0byBhdHRhY2ggdGhlIGV2ZW50IGhhbmRsZXIgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSBvZiBpbnRlcmVzdCwgYmVpbmcgZW1pdHRlZCBieSB0aGVcbiAgICAgKiBgdGFyZ2V0YC5cbiAgICAgKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRocm91Z2ggdG8gYWRkRXZlbnRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSB7U2VsZWN0b3JNZXRob2RTaWduYXR1cmU8VD59IFtzZWxlY3Rvcl0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG9cbiAgICAgKiBwb3N0LXByb2Nlc3MgcmVzdWx0cy4gSXQgdGFrZXMgdGhlIGFyZ3VtZW50cyBmcm9tIHRoZSBldmVudCBoYW5kbGVyIGFuZFxuICAgICAqIHNob3VsZCByZXR1cm4gYSBzaW5nbGUgdmFsdWUuXG4gICAgICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn1cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSBmcm9tRXZlbnRcbiAgICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgICAqL1xuICAgIEZyb21FdmVudE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBvcHRpb25zLCBzZWxlY3Rvcikge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbl8xLmlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHNlbGVjdG9yID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcm9tRXZlbnRPYnNlcnZhYmxlKHRhcmdldCwgZXZlbnROYW1lLCBzZWxlY3Rvciwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnNldHVwU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24gKHNvdXJjZU9iaiwgZXZlbnROYW1lLCBoYW5kbGVyLCBzdWJzY3JpYmVyLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB1bnN1YnNjcmliZTtcbiAgICAgICAgaWYgKGlzTm9kZUxpc3Qoc291cmNlT2JqKSB8fCBpc0hUTUxDb2xsZWN0aW9uKHNvdXJjZU9iaikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VPYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBGcm9tRXZlbnRPYnNlcnZhYmxlLnNldHVwU3Vic2NyaXB0aW9uKHNvdXJjZU9ialtpXSwgZXZlbnROYW1lLCBoYW5kbGVyLCBzdWJzY3JpYmVyLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0V2ZW50VGFyZ2V0KHNvdXJjZU9iaikpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VfMSA9IHNvdXJjZU9iajtcbiAgICAgICAgICAgIHNvdXJjZU9iai5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvdXJjZV8xLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0pRdWVyeVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iaikpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VfMiA9IHNvdXJjZU9iajtcbiAgICAgICAgICAgIHNvdXJjZU9iai5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzb3VyY2VfMi5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc05vZGVTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlXzMgPSBzb3VyY2VPYmo7XG4gICAgICAgICAgICBzb3VyY2VPYmouYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc291cmNlXzMucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZXZlbnQgdGFyZ2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlci5hZGQobmV3IFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbih1bnN1YnNjcmliZSkpO1xuICAgIH07XG4gICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBzb3VyY2VPYmogPSB0aGlzLnNvdXJjZU9iajtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHRoaXMuZXZlbnROYW1lO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcjtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBzZWxlY3RvciA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaChzZWxlY3RvcikuYXBwbHkodm9pZCAwLCBhcmdzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSA6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBzdWJzY3JpYmVyLm5leHQoZSk7IH07XG4gICAgICAgIEZyb21FdmVudE9ic2VydmFibGUuc2V0dXBTdWJzY3JpcHRpb24oc291cmNlT2JqLCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEZyb21FdmVudE9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkZyb21FdmVudE9ic2VydmFibGUgPSBGcm9tRXZlbnRPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnJvbUV2ZW50T2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uL09ic2VydmFibGUnKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG52YXIgU2NhbGFyT2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjYWxhck9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2NhbGFyT2JzZXJ2YWJsZSh2YWx1ZSwgc2NoZWR1bGVyKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLl9pc1NjYWxhciA9IHRydWU7XG4gICAgICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgU2NhbGFyT2JzZXJ2YWJsZS5jcmVhdGUgPSBmdW5jdGlvbiAodmFsdWUsIHNjaGVkdWxlcikge1xuICAgICAgICByZXR1cm4gbmV3IFNjYWxhck9ic2VydmFibGUodmFsdWUsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgICBTY2FsYXJPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBkb25lID0gc3RhdGUuZG9uZSwgdmFsdWUgPSBzdGF0ZS52YWx1ZSwgc3Vic2NyaWJlciA9IHN0YXRlLnN1YnNjcmliZXI7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZG9uZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGUoc3RhdGUpO1xuICAgIH07XG4gICAgU2NhbGFyT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIHZhciBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICAgICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShTY2FsYXJPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsIHZhbHVlOiB2YWx1ZSwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNjYWxhck9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlNjYWxhck9ic2VydmFibGUgPSBTY2FsYXJPYnNlcnZhYmxlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2NhbGFyT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGlzTnVtZXJpY18xID0gcmVxdWlyZSgnLi4vdXRpbC9pc051bWVyaWMnKTtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xudmFyIGlzU2NoZWR1bGVyXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzU2NoZWR1bGVyJyk7XG52YXIgaXNEYXRlXzEgPSByZXF1aXJlKCcuLi91dGlsL2lzRGF0ZScpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbnZhciBUaW1lck9ic2VydmFibGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lck9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGltZXJPYnNlcnZhYmxlKGR1ZVRpbWUsIHBlcmlvZCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChkdWVUaW1lID09PSB2b2lkIDApIHsgZHVlVGltZSA9IDA7IH1cbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucGVyaW9kID0gLTE7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IDA7XG4gICAgICAgIGlmIChpc051bWVyaWNfMS5pc051bWVyaWMocGVyaW9kKSkge1xuICAgICAgICAgICAgdGhpcy5wZXJpb2QgPSBOdW1iZXIocGVyaW9kKSA8IDEgJiYgMSB8fCBOdW1iZXIocGVyaW9kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKHBlcmlvZCkpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlciA9IHBlcmlvZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzU2NoZWR1bGVyXzEuaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSkge1xuICAgICAgICAgICAgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICAgICAgdGhpcy5kdWVUaW1lID0gaXNEYXRlXzEuaXNEYXRlKGR1ZVRpbWUpID9cbiAgICAgICAgICAgICgrZHVlVGltZSAtIHRoaXMuc2NoZWR1bGVyLm5vdygpKSA6XG4gICAgICAgICAgICBkdWVUaW1lO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBzdGFydHMgZW1pdHRpbmcgYWZ0ZXIgYW4gYGluaXRpYWxEZWxheWAgYW5kXG4gICAgICogZW1pdHMgZXZlciBpbmNyZWFzaW5nIG51bWJlcnMgYWZ0ZXIgZWFjaCBgcGVyaW9kYCBvZiB0aW1lIHRoZXJlYWZ0ZXIuXG4gICAgICpcbiAgICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXRzIGxpa2Uge0BsaW5rIGludGVydmFsfSwgYnV0IHlvdSBjYW4gc3BlY2lmeSB3aGVuXG4gICAgICogc2hvdWxkIHRoZSBlbWlzc2lvbnMgc3RhcnQuPC9zcGFuPlxuICAgICAqXG4gICAgICogPGltZyBzcmM9XCIuL2ltZy90aW1lci5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICAgKlxuICAgICAqIGB0aW1lcmAgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYW4gaW5maW5pdGUgc2VxdWVuY2Ugb2YgYXNjZW5kaW5nXG4gICAgICogaW50ZWdlcnMsIHdpdGggYSBjb25zdGFudCBpbnRlcnZhbCBvZiB0aW1lLCBgcGVyaW9kYCBvZiB5b3VyIGNob29zaW5nXG4gICAgICogYmV0d2VlbiB0aG9zZSBlbWlzc2lvbnMuIFRoZSBmaXJzdCBlbWlzc2lvbiBoYXBwZW5zIGFmdGVyIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBgaW5pdGlhbERlbGF5YC4gVGhlIGluaXRpYWwgZGVsYXkgbWF5IGJlIGEge0BsaW5rIERhdGV9LiBCeSBkZWZhdWx0LCB0aGlzXG4gICAgICogb3BlcmF0b3IgdXNlcyB0aGUgYGFzeW5jYCBJU2NoZWR1bGVyIHRvIHByb3ZpZGUgYSBub3Rpb24gb2YgdGltZSwgYnV0IHlvdVxuICAgICAqIG1heSBwYXNzIGFueSBJU2NoZWR1bGVyIHRvIGl0LiBJZiBgcGVyaW9kYCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgb3V0cHV0XG4gICAgICogT2JzZXJ2YWJsZSBlbWl0cyBvbmx5IG9uZSB2YWx1ZSwgYDBgLiBPdGhlcndpc2UsIGl0IGVtaXRzIGFuIGluZmluaXRlXG4gICAgICogc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyBhc2NlbmRpbmcgbnVtYmVycywgb25lIGV2ZXJ5IHNlY29uZCAoMTAwMG1zKSwgc3RhcnRpbmcgYWZ0ZXIgMyBzZWNvbmRzPC9jYXB0aW9uPlxuICAgICAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS50aW1lcigzMDAwLCAxMDAwKTtcbiAgICAgKiBudW1iZXJzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIG9uZSBudW1iZXIgYWZ0ZXIgZml2ZSBzZWNvbmRzPC9jYXB0aW9uPlxuICAgICAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS50aW1lcig1MDAwKTtcbiAgICAgKiBudW1iZXJzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGludGVydmFsfVxuICAgICAqIEBzZWUge0BsaW5rIGRlbGF5fVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8RGF0ZX0gaW5pdGlhbERlbGF5IFRoZSBpbml0aWFsIGRlbGF5IHRpbWUgdG8gd2FpdCBiZWZvcmVcbiAgICAgKiBlbWl0dGluZyB0aGUgZmlyc3QgdmFsdWUgb2YgYDBgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGVyaW9kXSBUaGUgcGVyaW9kIG9mIHRpbWUgYmV0d2VlbiBlbWlzc2lvbnMgb2YgdGhlXG4gICAgICogc3Vic2VxdWVudCBudW1iZXJzLlxuICAgICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUgSVNjaGVkdWxlciB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICAgKiB0aGUgZW1pc3Npb24gb2YgdmFsdWVzLCBhbmQgcHJvdmlkaW5nIGEgbm90aW9uIG9mIFwidGltZVwiLlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIGAwYCBhZnRlciB0aGVcbiAgICAgKiBgaW5pdGlhbERlbGF5YCBhbmQgZXZlciBpbmNyZWFzaW5nIG51bWJlcnMgYWZ0ZXIgZWFjaCBgcGVyaW9kYCBvZiB0aW1lXG4gICAgICogdGhlcmVhZnRlci5cbiAgICAgKiBAc3RhdGljIHRydWVcbiAgICAgKiBAbmFtZSB0aW1lclxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgICovXG4gICAgVGltZXJPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChpbml0aWFsRGVsYXksIHBlcmlvZCwgc2NoZWR1bGVyKSB7XG4gICAgICAgIGlmIChpbml0aWFsRGVsYXkgPT09IHZvaWQgMCkgeyBpbml0aWFsRGVsYXkgPSAwOyB9XG4gICAgICAgIHJldHVybiBuZXcgVGltZXJPYnNlcnZhYmxlKGluaXRpYWxEZWxheSwgcGVyaW9kLCBzY2hlZHVsZXIpO1xuICAgIH07XG4gICAgVGltZXJPYnNlcnZhYmxlLmRpc3BhdGNoID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHN0YXRlLmluZGV4LCBwZXJpb2QgPSBzdGF0ZS5wZXJpb2QsIHN1YnNjcmliZXIgPSBzdGF0ZS5zdWJzY3JpYmVyO1xuICAgICAgICB2YXIgYWN0aW9uID0gdGhpcztcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KGluZGV4KTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGVyaW9kID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgYWN0aW9uLnNjaGVkdWxlKHN0YXRlLCBwZXJpb2QpO1xuICAgIH07XG4gICAgVGltZXJPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcGVyaW9kID0gX2EucGVyaW9kLCBkdWVUaW1lID0gX2EuZHVlVGltZSwgc2NoZWR1bGVyID0gX2Euc2NoZWR1bGVyO1xuICAgICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKFRpbWVyT2JzZXJ2YWJsZS5kaXNwYXRjaCwgZHVlVGltZSwge1xuICAgICAgICAgICAgaW5kZXg6IGluZGV4LCBwZXJpb2Q6IHBlcmlvZCwgc3Vic2NyaWJlcjogc3Vic2NyaWJlclxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUaW1lck9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLlRpbWVyT2JzZXJ2YWJsZSA9IFRpbWVyT2JzZXJ2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRpbWVyT2JzZXJ2YWJsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBEZWZlck9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vRGVmZXJPYnNlcnZhYmxlJyk7XG5leHBvcnRzLmRlZmVyID0gRGVmZXJPYnNlcnZhYmxlXzEuRGVmZXJPYnNlcnZhYmxlLmNyZWF0ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZmVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgcm9vdF8xID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9yb290Jyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9lcnJvck9iamVjdCcpO1xudmFyIE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4uLy4uL09ic2VydmFibGUnKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi8uLi9TdWJzY3JpYmVyJyk7XG52YXIgbWFwXzEgPSByZXF1aXJlKCcuLi8uLi9vcGVyYXRvci9tYXAnKTtcbmZ1bmN0aW9uIGdldENPUlNSZXF1ZXN0KCkge1xuICAgIGlmIChyb290XzEucm9vdC5YTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IHJvb3RfMS5yb290LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCEhcm9vdF8xLnJvb3QuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByb290XzEucm9vdC5YRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDT1JTIGlzIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBicm93c2VyJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0WE1MSHR0cFJlcXVlc3QoKSB7XG4gICAgaWYgKHJvb3RfMS5yb290LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgcm9vdF8xLnJvb3QuWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBwcm9nSWQgPSB2b2lkIDA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcHJvZ0lkcyA9IFsnTXN4bWwyLlhNTEhUVFAnLCAnTWljcm9zb2Z0LlhNTEhUVFAnLCAnTXN4bWwyLlhNTEhUVFAuNC4wJ107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dJZCA9IHByb2dJZHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXcgcm9vdF8xLnJvb3QuQWN0aXZlWE9iamVjdChwcm9nSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgcm9vdF8xLnJvb3QuQWN0aXZlWE9iamVjdChwcm9nSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hNTEh0dHBSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBicm93c2VyJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhamF4R2V0KHVybCwgaGVhZGVycykge1xuICAgIGlmIChoZWFkZXJzID09PSB2b2lkIDApIHsgaGVhZGVycyA9IG51bGw7IH1cbiAgICByZXR1cm4gbmV3IEFqYXhPYnNlcnZhYmxlKHsgbWV0aG9kOiAnR0VUJywgdXJsOiB1cmwsIGhlYWRlcnM6IGhlYWRlcnMgfSk7XG59XG5leHBvcnRzLmFqYXhHZXQgPSBhamF4R2V0O1xuO1xuZnVuY3Rpb24gYWpheFBvc3QodXJsLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZSh7IG1ldGhvZDogJ1BPU1QnLCB1cmw6IHVybCwgYm9keTogYm9keSwgaGVhZGVyczogaGVhZGVycyB9KTtcbn1cbmV4cG9ydHMuYWpheFBvc3QgPSBhamF4UG9zdDtcbjtcbmZ1bmN0aW9uIGFqYXhEZWxldGUodXJsLCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZSh7IG1ldGhvZDogJ0RFTEVURScsIHVybDogdXJsLCBoZWFkZXJzOiBoZWFkZXJzIH0pO1xufVxuZXhwb3J0cy5hamF4RGVsZXRlID0gYWpheERlbGV0ZTtcbjtcbmZ1bmN0aW9uIGFqYXhQdXQodXJsLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZSh7IG1ldGhvZDogJ1BVVCcsIHVybDogdXJsLCBib2R5OiBib2R5LCBoZWFkZXJzOiBoZWFkZXJzIH0pO1xufVxuZXhwb3J0cy5hamF4UHV0ID0gYWpheFB1dDtcbjtcbmZ1bmN0aW9uIGFqYXhQYXRjaCh1cmwsIGJvZHksIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gbmV3IEFqYXhPYnNlcnZhYmxlKHsgbWV0aG9kOiAnUEFUQ0gnLCB1cmw6IHVybCwgYm9keTogYm9keSwgaGVhZGVyczogaGVhZGVycyB9KTtcbn1cbmV4cG9ydHMuYWpheFBhdGNoID0gYWpheFBhdGNoO1xuO1xuZnVuY3Rpb24gYWpheEdldEpTT04odXJsLCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZSh7IG1ldGhvZDogJ0dFVCcsIHVybDogdXJsLCByZXNwb25zZVR5cGU6ICdqc29uJywgaGVhZGVyczogaGVhZGVycyB9KVxuICAgICAgICAubGlmdChuZXcgbWFwXzEuTWFwT3BlcmF0b3IoZnVuY3Rpb24gKHgsIGluZGV4KSB7IHJldHVybiB4LnJlc3BvbnNlOyB9LCBudWxsKSk7XG59XG5leHBvcnRzLmFqYXhHZXRKU09OID0gYWpheEdldEpTT047XG47XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xudmFyIEFqYXhPYnNlcnZhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWpheE9ic2VydmFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWpheE9ic2VydmFibGUodXJsT3JSZXF1ZXN0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgY3JlYXRlWEhSOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3Jvc3NEb21haW4gPyBnZXRDT1JTUmVxdWVzdC5jYWxsKHRoaXMpIDogZ2V0WE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcm9zc0RvbWFpbjogZmFsc2UsXG4gICAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICAgICAgICB0aW1lb3V0OiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgdXJsT3JSZXF1ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVxdWVzdC51cmwgPSB1cmxPclJlcXVlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHVybE9yUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGlmICh1cmxPclJlcXVlc3QuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdFtwcm9wXSA9IHVybE9yUmVxdWVzdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICB9XG4gICAgQWpheE9ic2VydmFibGUucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgICAgICByZXR1cm4gbmV3IEFqYXhTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucmVxdWVzdCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9ic2VydmFibGUgZm9yIGFuIEFqYXggcmVxdWVzdCB3aXRoIGVpdGhlciBhIHJlcXVlc3Qgb2JqZWN0IHdpdGhcbiAgICAgKiB1cmwsIGhlYWRlcnMsIGV0YyBvciBhIHN0cmluZyBmb3IgYSBVUkwuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUuYWpheCgnL3Byb2R1Y3RzJyk7XG4gICAgICogc291cmNlID0gUnguT2JzZXJ2YWJsZS5hamF4KHsgdXJsOiAncHJvZHVjdHMnLCBtZXRob2Q6ICdHRVQnIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSByZXF1ZXN0IENhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICAgKiAgIEEgc3RyaW5nIG9mIHRoZSBVUkwgdG8gbWFrZSB0aGUgQWpheCBjYWxsLlxuICAgICAqICAgQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzXG4gICAgICogICAtIHVybDogVVJMIG9mIHRoZSByZXF1ZXN0XG4gICAgICogICAtIGJvZHk6IFRoZSBib2R5IG9mIHRoZSByZXF1ZXN0XG4gICAgICogICAtIG1ldGhvZDogTWV0aG9kIG9mIHRoZSByZXF1ZXN0LCBzdWNoIGFzIEdFVCwgUE9TVCwgUFVULCBQQVRDSCwgREVMRVRFXG4gICAgICogICAtIGFzeW5jOiBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIGFzeW5jXG4gICAgICogICAtIGhlYWRlcnM6IE9wdGlvbmFsIGhlYWRlcnNcbiAgICAgKiAgIC0gY3Jvc3NEb21haW46IHRydWUgaWYgYSBjcm9zcyBkb21haW4gcmVxdWVzdCwgZWxzZSBmYWxzZVxuICAgICAqICAgLSBjcmVhdGVYSFI6IGEgZnVuY3Rpb24gdG8gb3ZlcnJpZGUgaWYgeW91IG5lZWQgdG8gdXNlIGFuIGFsdGVybmF0ZVxuICAgICAqICAgWE1MSHR0cFJlcXVlc3QgaW1wbGVtZW50YXRpb24uXG4gICAgICogICAtIHJlc3VsdFNlbGVjdG9yOiBhIGZ1bmN0aW9uIHRvIHVzZSB0byBhbHRlciB0aGUgb3V0cHV0IHZhbHVlIHR5cGUgb2ZcbiAgICAgKiAgIHRoZSBPYnNlcnZhYmxlLiBHZXRzIHtAbGluayBBamF4UmVzcG9uc2V9IGFzIGFuIGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgc2VxdWVuY2UgY29udGFpbmluZyB0aGUgWE1MSHR0cFJlcXVlc3QuXG4gICAgICogQHN0YXRpYyB0cnVlXG4gICAgICogQG5hbWUgYWpheFxuICAgICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAgKi9cbiAgICBBamF4T2JzZXJ2YWJsZS5jcmVhdGUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3JlYXRlID0gZnVuY3Rpb24gKHVybE9yUmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZSh1cmxPclJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgICAgICBjcmVhdGUuZ2V0ID0gYWpheEdldDtcbiAgICAgICAgY3JlYXRlLnBvc3QgPSBhamF4UG9zdDtcbiAgICAgICAgY3JlYXRlLmRlbGV0ZSA9IGFqYXhEZWxldGU7XG4gICAgICAgIGNyZWF0ZS5wdXQgPSBhamF4UHV0O1xuICAgICAgICBjcmVhdGUucGF0Y2ggPSBhamF4UGF0Y2g7XG4gICAgICAgIGNyZWF0ZS5nZXRKU09OID0gYWpheEdldEpTT047XG4gICAgICAgIHJldHVybiBjcmVhdGU7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gQWpheE9ic2VydmFibGU7XG59KE9ic2VydmFibGVfMS5PYnNlcnZhYmxlKSk7XG5leHBvcnRzLkFqYXhPYnNlcnZhYmxlID0gQWpheE9ic2VydmFibGU7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEFqYXhTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWpheFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWpheFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHJlcXVlc3QpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnMgfHwge307XG4gICAgICAgIC8vIGZvcmNlIENPUlMgaWYgcmVxdWVzdGVkXG4gICAgICAgIGlmICghcmVxdWVzdC5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydYLVJlcXVlc3RlZC1XaXRoJ10gPSAnWE1MSHR0cFJlcXVlc3QnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuc3VyZSBjb250ZW50IHR5cGUgaXMgc2V0XG4gICAgICAgIGlmICghKCdDb250ZW50LVR5cGUnIGluIGhlYWRlcnMpICYmICEocm9vdF8xLnJvb3QuRm9ybURhdGEgJiYgcmVxdWVzdC5ib2R5IGluc3RhbmNlb2Ygcm9vdF8xLnJvb3QuRm9ybURhdGEpICYmIHR5cGVvZiByZXF1ZXN0LmJvZHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLTgnO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb3Blcmx5IHNlcmlhbGl6ZSBib2R5XG4gICAgICAgIHJlcXVlc3QuYm9keSA9IHRoaXMuc2VyaWFsaXplQm9keShyZXF1ZXN0LmJvZHksIHJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10pO1xuICAgICAgICB0aGlzLnNlbmQoKTtcbiAgICB9XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCB4aHIgPSBfYS54aHIsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0LCBkZXN0aW5hdGlvbiA9IF9hLmRlc3RpbmF0aW9uO1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSBuZXcgQWpheFJlc3BvbnNlKGUsIHhociwgcmVxdWVzdCk7XG4gICAgICAgIGRlc3RpbmF0aW9uLm5leHQocmVzcG9uc2UpO1xuICAgIH07XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHJlcXVlc3QgPSBfYS5yZXF1ZXN0LCBfYiA9IF9hLnJlcXVlc3QsIHVzZXIgPSBfYi51c2VyLCBtZXRob2QgPSBfYi5tZXRob2QsIHVybCA9IF9iLnVybCwgYXN5bmMgPSBfYi5hc3luYywgcGFzc3dvcmQgPSBfYi5wYXNzd29yZCwgaGVhZGVycyA9IF9iLmhlYWRlcnMsIGJvZHkgPSBfYi5ib2R5O1xuICAgICAgICB2YXIgY3JlYXRlWEhSID0gcmVxdWVzdC5jcmVhdGVYSFI7XG4gICAgICAgIHZhciB4aHIgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKGNyZWF0ZVhIUikuY2FsbChyZXF1ZXN0KTtcbiAgICAgICAgaWYgKHhociA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54aHIgPSB4aHI7XG4gICAgICAgICAgICAvLyBzZXQgdXAgdGhlIGV2ZW50cyBiZWZvcmUgb3BlbiBYSFJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9Vc2luZ19YTUxIdHRwUmVxdWVzdFxuICAgICAgICAgICAgLy8gWW91IG5lZWQgdG8gYWRkIHRoZSBldmVudCBsaXN0ZW5lcnMgYmVmb3JlIGNhbGxpbmcgb3BlbigpIG9uIHRoZSByZXF1ZXN0LlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBwcm9ncmVzcyBldmVudHMgd2lsbCBub3QgZmlyZS5cbiAgICAgICAgICAgIHRoaXMuc2V0dXBFdmVudHMoeGhyLCByZXF1ZXN0KTtcbiAgICAgICAgICAgIC8vIG9wZW4gWEhSXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHhoci5vcGVuKS5jYWxsKHhociwgbWV0aG9kLCB1cmwsIGFzeW5jLCB1c2VyLCBwYXNzd29yZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHhoci5vcGVuKS5jYWxsKHhociwgbWV0aG9kLCB1cmwsIGFzeW5jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aW1lb3V0LCByZXNwb25zZVR5cGUgYW5kIHdpdGhDcmVkZW50aWFscyBjYW4gYmUgc2V0IG9uY2UgdGhlIFhIUiBpcyBvcGVuXG4gICAgICAgICAgICB4aHIudGltZW91dCA9IHJlcXVlc3QudGltZW91dDtcbiAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgICAgICAgICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gISFyZXF1ZXN0LndpdGhDcmVkZW50aWFscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBoZWFkZXJzXG4gICAgICAgICAgICB0aGlzLnNldEhlYWRlcnMoeGhyLCBoZWFkZXJzKTtcbiAgICAgICAgICAgIC8vIGZpbmFsbHkgc2VuZCB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgcmVzdWx0ID0gYm9keSA/IHRyeUNhdGNoXzEudHJ5Q2F0Y2goeGhyLnNlbmQpLmNhbGwoeGhyLCBib2R5KSA6IHRyeUNhdGNoXzEudHJ5Q2F0Y2goeGhyLnNlbmQpLmNhbGwoeGhyKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhocjtcbiAgICB9O1xuICAgIEFqYXhTdWJzY3JpYmVyLnByb3RvdHlwZS5zZXJpYWxpemVCb2R5ID0gZnVuY3Rpb24gKGJvZHksIGNvbnRlbnRUeXBlKSB7XG4gICAgICAgIGlmICghYm9keSB8fCB0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJvb3RfMS5yb290LkZvcm1EYXRhICYmIGJvZHkgaW5zdGFuY2VvZiByb290XzEucm9vdC5Gb3JtRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgc3BsaXRJbmRleCA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJzsnKTtcbiAgICAgICAgICAgIGlmIChzcGxpdEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gY29udGVudFR5cGUuc3Vic3RyaW5nKDAsIHNwbGl0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGJvZHkpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoZW5jb2RlVVJJKGtleSkgKyBcIj1cIiArIGVuY29kZVVSSShib2R5W2tleV0pKTsgfSkuam9pbignJicpO1xuICAgICAgICAgICAgY2FzZSAnYXBwbGljYXRpb24vanNvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9keTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWpheFN1YnNjcmliZXIucHJvdG90eXBlLnNldEhlYWRlcnMgPSBmdW5jdGlvbiAoeGhyLCBoZWFkZXJzKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBBamF4U3Vic2NyaWJlci5wcm90b3R5cGUuc2V0dXBFdmVudHMgPSBmdW5jdGlvbiAoeGhyLCByZXF1ZXN0KSB7XG4gICAgICAgIHZhciBwcm9ncmVzc1N1YnNjcmliZXIgPSByZXF1ZXN0LnByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgZnVuY3Rpb24geGhyVGltZW91dChlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB4aHJUaW1lb3V0LCBzdWJzY3JpYmVyID0gX2Euc3Vic2NyaWJlciwgcHJvZ3Jlc3NTdWJzY3JpYmVyID0gX2EucHJvZ3Jlc3NTdWJzY3JpYmVyLCByZXF1ZXN0ID0gX2EucmVxdWVzdDtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc1N1YnNjcmliZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yKG5ldyBBamF4VGltZW91dEVycm9yKHRoaXMsIHJlcXVlc3QpKTsgLy9UT0RPOiBNYWtlIGJldHRlcmVyLlxuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgeGhyLm9udGltZW91dCA9IHhoclRpbWVvdXQ7XG4gICAgICAgIHhoclRpbWVvdXQucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHhoclRpbWVvdXQuc3Vic2NyaWJlciA9IHRoaXM7XG4gICAgICAgIHhoclRpbWVvdXQucHJvZ3Jlc3NTdWJzY3JpYmVyID0gcHJvZ3Jlc3NTdWJzY3JpYmVyO1xuICAgICAgICBpZiAoeGhyLnVwbG9hZCAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgICAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgeGhyUHJvZ3Jlc3NfMTtcbiAgICAgICAgICAgICAgICB4aHJQcm9ncmVzc18xID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzU3Vic2NyaWJlciA9IHhoclByb2dyZXNzXzEucHJvZ3Jlc3NTdWJzY3JpYmVyO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc1N1YnNjcmliZXIubmV4dChlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChyb290XzEucm9vdC5YRG9tYWluUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICB4aHIub25wcm9ncmVzcyA9IHhoclByb2dyZXNzXzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSB4aHJQcm9ncmVzc18xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB4aHJQcm9ncmVzc18xLnByb2dyZXNzU3Vic2NyaWJlciA9IHByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB4aHJFcnJvcl8xO1xuICAgICAgICAgICAgeGhyRXJyb3JfMSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0geGhyRXJyb3JfMSwgcHJvZ3Jlc3NTdWJzY3JpYmVyID0gX2EucHJvZ3Jlc3NTdWJzY3JpYmVyLCBzdWJzY3JpYmVyID0gX2Euc3Vic2NyaWJlciwgcmVxdWVzdCA9IF9hLnJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc1N1YnNjcmliZXIuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IobmV3IEFqYXhFcnJvcignYWpheCBlcnJvcicsIHRoaXMsIHJlcXVlc3QpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIub25lcnJvciA9IHhockVycm9yXzE7XG4gICAgICAgICAgICB4aHJFcnJvcl8xLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgeGhyRXJyb3JfMS5zdWJzY3JpYmVyID0gdGhpcztcbiAgICAgICAgICAgIHhockVycm9yXzEucHJvZ3Jlc3NTdWJzY3JpYmVyID0gcHJvZ3Jlc3NTdWJzY3JpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHhoclJlYWR5U3RhdGVDaGFuZ2UoZSkge1xuICAgICAgICAgICAgdmFyIF9hID0geGhyUmVhZHlTdGF0ZUNoYW5nZSwgc3Vic2NyaWJlciA9IF9hLnN1YnNjcmliZXIsIHByb2dyZXNzU3Vic2NyaWJlciA9IF9hLnByb2dyZXNzU3Vic2NyaWJlciwgcmVxdWVzdCA9IF9hLnJlcXVlc3Q7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIElFOSBidWcgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTApXG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1c18xID0gdGhpcy5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB0aGlzLnN0YXR1cztcbiAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSAodGhpcy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/ICh0aGlzLnJlc3BvbnNlIHx8IHRoaXMucmVzcG9uc2VUZXh0KSA6IHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIC8vIGZpeCBzdGF0dXMgY29kZSB3aGVuIGl0IGlzIDAgKDAgc3RhdHVzIGlzIHVuZG9jdW1lbnRlZCkuXG4gICAgICAgICAgICAgICAgLy8gT2NjdXJzIHdoZW4gYWNjZXNzaW5nIGZpbGUgcmVzb3VyY2VzIG9yIG9uIEFuZHJvaWQgNC4xIHN0b2NrIGJyb3dzZXJcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSByZXRyaWV2aW5nIGZpbGVzIGZyb20gYXBwbGljYXRpb24gY2FjaGUuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1c18xID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c18xID0gcmVzcG9uc2UgPyAyMDAgOiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoMjAwIDw9IHN0YXR1c18xICYmIHN0YXR1c18xIDwgMzAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzU3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChlKTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzU3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IobmV3IEFqYXhFcnJvcignYWpheCBlcnJvciAnICsgc3RhdHVzXzEsIHRoaXMsIHJlcXVlc3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0geGhyUmVhZHlTdGF0ZUNoYW5nZTtcbiAgICAgICAgeGhyUmVhZHlTdGF0ZUNoYW5nZS5zdWJzY3JpYmVyID0gdGhpcztcbiAgICAgICAgeGhyUmVhZHlTdGF0ZUNoYW5nZS5wcm9ncmVzc1N1YnNjcmliZXIgPSBwcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICAgIHhoclJlYWR5U3RhdGVDaGFuZ2UucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgfTtcbiAgICBBamF4U3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGRvbmUgPSBfYS5kb25lLCB4aHIgPSBfYS54aHI7XG4gICAgICAgIGlmICghZG9uZSAmJiB4aHIgJiYgeGhyLnJlYWR5U3RhdGUgIT09IDQgJiYgdHlwZW9mIHhoci5hYm9ydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEFqYXhTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZXhwb3J0cy5BamF4U3Vic2NyaWJlciA9IEFqYXhTdWJzY3JpYmVyO1xuLyoqXG4gKiBBIG5vcm1hbGl6ZWQgQUpBWCByZXNwb25zZS5cbiAqXG4gKiBAc2VlIHtAbGluayBhamF4fVxuICpcbiAqIEBjbGFzcyBBamF4UmVzcG9uc2VcbiAqL1xudmFyIEFqYXhSZXNwb25zZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWpheFJlc3BvbnNlKG9yaWdpbmFsRXZlbnQsIHhociwgcmVxdWVzdCkge1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICAgICAgICB0aGlzLnhociA9IHhocjtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgICAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHhoci5yZXNwb25zZVR5cGUgfHwgcmVxdWVzdC5yZXNwb25zZVR5cGU7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICAgIGlmICgncmVzcG9uc2UnIGluIHhocikge1xuICAgICAgICAgICAgICAgICAgICAvL0lFIGRvZXMgbm90IHN1cHBvcnQganNvbiBhcyByZXNwb25zZVR5cGUsIHBhcnNlIGl0IGludGVybmFsbHlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHhoci5yZXNwb25zZVR5cGUgPyB4aHIucmVzcG9uc2UgOiBKU09OLnBhcnNlKHhoci5yZXNwb25zZSB8fCB4aHIucmVzcG9uc2VUZXh0IHx8ICdudWxsJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0IHx8ICdudWxsJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAneG1sJzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0geGhyLnJlc3BvbnNlWE1MO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSAoJ3Jlc3BvbnNlJyBpbiB4aHIpID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQWpheFJlc3BvbnNlO1xufSgpKTtcbmV4cG9ydHMuQWpheFJlc3BvbnNlID0gQWpheFJlc3BvbnNlO1xuLyoqXG4gKiBBIG5vcm1hbGl6ZWQgQUpBWCBlcnJvci5cbiAqXG4gKiBAc2VlIHtAbGluayBhamF4fVxuICpcbiAqIEBjbGFzcyBBamF4RXJyb3JcbiAqL1xudmFyIEFqYXhFcnJvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFqYXhFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBamF4RXJyb3IobWVzc2FnZSwgeGhyLCByZXF1ZXN0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLnhociA9IHhocjtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB4aHIuc3RhdHVzO1xuICAgIH1cbiAgICByZXR1cm4gQWpheEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5BamF4RXJyb3IgPSBBamF4RXJyb3I7XG4vKipcbiAqIEBzZWUge0BsaW5rIGFqYXh9XG4gKlxuICogQGNsYXNzIEFqYXhUaW1lb3V0RXJyb3JcbiAqL1xudmFyIEFqYXhUaW1lb3V0RXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBamF4VGltZW91dEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFqYXhUaW1lb3V0RXJyb3IoeGhyLCByZXF1ZXN0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsICdhamF4IHRpbWVvdXQnLCB4aHIsIHJlcXVlc3QpO1xuICAgIH1cbiAgICByZXR1cm4gQWpheFRpbWVvdXRFcnJvcjtcbn0oQWpheEVycm9yKSk7XG5leHBvcnRzLkFqYXhUaW1lb3V0RXJyb3IgPSBBamF4VGltZW91dEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWpheE9ic2VydmFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgQWpheE9ic2VydmFibGVfMSA9IHJlcXVpcmUoJy4vQWpheE9ic2VydmFibGUnKTtcbmV4cG9ydHMuYWpheCA9IEFqYXhPYnNlcnZhYmxlXzEuQWpheE9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWpheC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBtZXJnZV8xID0gcmVxdWlyZSgnLi4vb3BlcmF0b3IvbWVyZ2UnKTtcbmV4cG9ydHMubWVyZ2UgPSBtZXJnZV8xLm1lcmdlU3RhdGljO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVyZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgRXJyb3JPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuL0Vycm9yT2JzZXJ2YWJsZScpO1xuZXhwb3J0cy5fdGhyb3cgPSBFcnJvck9ic2VydmFibGVfMS5FcnJvck9ic2VydmFibGUuY3JlYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3cuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIENhdGNoZXMgZXJyb3JzIG9uIHRoZSBvYnNlcnZhYmxlIHRvIGJlIGhhbmRsZWQgYnkgcmV0dXJuaW5nIGEgbmV3IG9ic2VydmFibGUgb3IgdGhyb3dpbmcgYW4gZXJyb3IuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jYXRjaC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db250aW51ZXMgd2l0aCBhIGRpZmZlcmVudCBPYnNlcnZhYmxlIHdoZW4gdGhlcmUncyBhbiBlcnJvcjwvY2FwdGlvbj5cbiAqXG4gKiBPYnNlcnZhYmxlLm9mKDEsIDIsIDMsIDQsIDUpXG4gKiAgIC5tYXAobiA9PiB7XG4gKiBcdCAgIGlmIChuID09IDQpIHtcbiAqIFx0ICAgICB0aHJvdyAnZm91ciEnO1xuICogICAgIH1cbiAqXHQgICByZXR1cm4gbjtcbiAqICAgfSlcbiAqICAgLmNhdGNoKGVyciA9PiBPYnNlcnZhYmxlLm9mKCdJJywgJ0lJJywgJ0lJSScsICdJVicsICdWJykpXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiAgIC8vIDEsIDIsIDMsIEksIElJLCBJSUksIElWLCBWXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmV0cmllcyB0aGUgY2F1Z2h0IHNvdXJjZSBPYnNlcnZhYmxlIGFnYWluIGluIGNhc2Ugb2YgZXJyb3IsIHNpbWlsYXIgdG8gcmV0cnkoKSBvcGVyYXRvcjwvY2FwdGlvbj5cbiAqXG4gKiBPYnNlcnZhYmxlLm9mKDEsIDIsIDMsIDQsIDUpXG4gKiAgIC5tYXAobiA9PiB7XG4gKiBcdCAgIGlmIChuID09PSA0KSB7XG4gKiBcdCAgICAgdGhyb3cgJ2ZvdXIhJztcbiAqICAgICB9XG4gKiBcdCAgIHJldHVybiBuO1xuICogICB9KVxuICogICAuY2F0Y2goKGVyciwgY2F1Z2h0KSA9PiBjYXVnaHQpXG4gKiAgIC50YWtlKDMwKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogICAvLyAxLCAyLCAzLCAxLCAyLCAzLCAuLi5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5UaHJvd3MgYSBuZXcgZXJyb3Igd2hlbiB0aGUgc291cmNlIE9ic2VydmFibGUgdGhyb3dzIGFuIGVycm9yPC9jYXB0aW9uPlxuICpcbiAqIE9ic2VydmFibGUub2YoMSwgMiwgMywgNCwgNSlcbiAqICAgLm1hcChuID0+IHtcbiAqICAgICBpZiAobiA9PSA0KSB7XG4gKiAgICAgICB0aHJvdyAnZm91ciEnO1xuICogICAgIH1cbiAqICAgICByZXR1cm4gbjtcbiAqICAgfSlcbiAqICAgLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgdGhyb3cgJ2Vycm9yIGluIHNvdXJjZS4gRGV0YWlsczogJyArIGVycjtcbiAqICAgfSlcbiAqICAgLnN1YnNjcmliZShcbiAqICAgICB4ID0+IGNvbnNvbGUubG9nKHgpLFxuICogICAgIGVyciA9PiBjb25zb2xlLmxvZyhlcnIpXG4gKiAgICk7XG4gKiAgIC8vIDEsIDIsIDMsIGVycm9yIGluIHNvdXJjZS4gRGV0YWlsczogZm91ciFcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzZWxlY3RvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYXMgYXJndW1lbnRzIGBlcnJgLCB3aGljaCBpcyB0aGUgZXJyb3IsIGFuZCBgY2F1Z2h0YCwgd2hpY2hcbiAqICBpcyB0aGUgc291cmNlIG9ic2VydmFibGUsIGluIGNhc2UgeW91J2QgbGlrZSB0byBcInJldHJ5XCIgdGhhdCBvYnNlcnZhYmxlIGJ5IHJldHVybmluZyBpdCBhZ2Fpbi4gV2hhdGV2ZXIgb2JzZXJ2YWJsZVxuICogIGlzIHJldHVybmVkIGJ5IHRoZSBgc2VsZWN0b3JgIHdpbGwgYmUgdXNlZCB0byBjb250aW51ZSB0aGUgb2JzZXJ2YWJsZSBjaGFpbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgdGhhdCBvcmlnaW5hdGVzIGZyb20gZWl0aGVyIHRoZSBzb3VyY2Ugb3IgdGhlIG9ic2VydmFibGUgcmV0dXJuZWQgYnkgdGhlXG4gKiAgY2F0Y2ggYHNlbGVjdG9yYCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgY2F0Y2hcbiAqIEBuYW1lIGNhdGNoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBfY2F0Y2goc2VsZWN0b3IpIHtcbiAgICB2YXIgb3BlcmF0b3IgPSBuZXcgQ2F0Y2hPcGVyYXRvcihzZWxlY3Rvcik7XG4gICAgdmFyIGNhdWdodCA9IHRoaXMubGlmdChvcGVyYXRvcik7XG4gICAgcmV0dXJuIChvcGVyYXRvci5jYXVnaHQgPSBjYXVnaHQpO1xufVxuZXhwb3J0cy5fY2F0Y2ggPSBfY2F0Y2g7XG52YXIgQ2F0Y2hPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2F0Y2hPcGVyYXRvcihzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgfVxuICAgIENhdGNoT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBDYXRjaFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5zZWxlY3RvciwgdGhpcy5jYXVnaHQpKTtcbiAgICB9O1xuICAgIHJldHVybiBDYXRjaE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgQ2F0Y2hTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2F0Y2hTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhdGNoU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgc2VsZWN0b3IsIGNhdWdodCkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5jYXVnaHQgPSBjYXVnaHQ7XG4gICAgfVxuICAgIC8vIE5PVEU6IG92ZXJyaWRpbmcgYGVycm9yYCBpbnN0ZWFkIG9mIGBfZXJyb3JgIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudFxuICAgIC8vIHRvIGhhdmUgdGhpcyBmbGFnIHRoaXMgc3Vic2NyaWJlciBhcyBgaXNTdG9wcGVkYC4gV2UgY2FuIG1pbWljIHRoZVxuICAgIC8vIGJlaGF2aW9yIG9mIHRoZSBSZXRyeVN1YnNjcmliZXIgKGZyb20gdGhlIGByZXRyeWAgb3BlcmF0b3IpLCB3aGVyZVxuICAgIC8vIHdlIHVuc3Vic2NyaWJlIGZyb20gb3VyIHNvdXJjZSBjaGFpbiwgcmVzZXQgb3VyIFN1YnNjcmliZXIgZmxhZ3MsXG4gICAgLy8gdGhlbiBzdWJzY3JpYmUgdG8gdGhlIHNlbGVjdG9yIHJlc3VsdC5cbiAgICBDYXRjaFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLnNlbGVjdG9yKGVyciwgdGhpcy5jYXVnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmVycm9yLmNhbGwodGhpcywgZXJyMik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2F0Y2hTdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbi8qKlxuICogRW1pdHMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBvbmx5IGFmdGVyIGEgcGFydGljdWxhciB0aW1lIHNwYW5cbiAqIGhhcyBwYXNzZWQgd2l0aG91dCBhbm90aGVyIHNvdXJjZSBlbWlzc2lvbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBkZWxheX0sIGJ1dCBwYXNzZXMgb25seSB0aGUgbW9zdFxuICogcmVjZW50IHZhbHVlIGZyb20gZWFjaCBidXJzdCBvZiBlbWlzc2lvbnMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZGVib3VuY2VUaW1lLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZWJvdW5jZVRpbWVgIGRlbGF5cyB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBkcm9wc1xuICogcHJldmlvdXMgcGVuZGluZyBkZWxheWVkIGVtaXNzaW9ucyBpZiBhIG5ldyB2YWx1ZSBhcnJpdmVzIG9uIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoaXMgb3BlcmF0b3Iga2VlcHMgdHJhY2sgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlIGZyb20gdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZSwgYW5kIGVtaXRzIHRoYXQgb25seSB3aGVuIGBkdWVUaW1lYCBlbm91Z2ggdGltZSBoYXMgcGFzc2VkXG4gKiB3aXRob3V0IGFueSBvdGhlciB2YWx1ZSBhcHBlYXJpbmcgb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBhIG5ldyB2YWx1ZVxuICogYXBwZWFycyBiZWZvcmUgYGR1ZVRpbWVgIHNpbGVuY2Ugb2NjdXJzLCB0aGUgcHJldmlvdXMgdmFsdWUgd2lsbCBiZSBkcm9wcGVkXG4gKiBhbmQgd2lsbCBub3QgYmUgZW1pdHRlZCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogVGhpcyBpcyBhIHJhdGUtbGltaXRpbmcgb3BlcmF0b3IsIGJlY2F1c2UgaXQgaXMgaW1wb3NzaWJsZSBmb3IgbW9yZSB0aGFuIG9uZVxuICogdmFsdWUgdG8gYmUgZW1pdHRlZCBpbiBhbnkgdGltZSB3aW5kb3cgb2YgZHVyYXRpb24gYGR1ZVRpbWVgLCBidXQgaXQgaXMgYWxzb1xuICogYSBkZWxheS1saWtlIG9wZXJhdG9yIHNpbmNlIG91dHB1dCBlbWlzc2lvbnMgZG8gbm90IG9jY3VyIGF0IHRoZSBzYW1lIHRpbWUgYXNcbiAqIHRoZXkgZGlkIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gT3B0aW9uYWxseSB0YWtlcyBhIHtAbGluayBJU2NoZWR1bGVyfSBmb3JcbiAqIG1hbmFnaW5nIHRpbWVycy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBtb3N0IHJlY2VudCBjbGljayBhZnRlciBhIGJ1cnN0IG9mIGNsaWNrczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmRlYm91bmNlVGltZSgxMDAwKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXRUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZVRpbWV9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGR1ZVRpbWUgVGhlIHRpbWVvdXQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIChvciB0aGUgdGltZVxuICogdW5pdCBkZXRlcm1pbmVkIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgKSBmb3IgdGhlIHdpbmRvdyBvZlxuICogdGltZSByZXF1aXJlZCB0byB3YWl0IGZvciBlbWlzc2lvbiBzaWxlbmNlIGJlZm9yZSBlbWl0dGluZyB0aGUgbW9zdCByZWNlbnRcbiAqIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3JcbiAqIG1hbmFnaW5nIHRoZSB0aW1lcnMgdGhhdCBoYW5kbGUgdGhlIHRpbWVvdXQgZm9yIGVhY2ggdmFsdWUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZGVsYXlzIHRoZSBlbWlzc2lvbnMgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGUgc3BlY2lmaWVkIGBkdWVUaW1lYCwgYW5kIG1heSBkcm9wIHNvbWUgdmFsdWVzIGlmIHRoZXkgb2NjdXJcbiAqIHRvbyBmcmVxdWVudGx5LlxuICogQG1ldGhvZCBkZWJvdW5jZVRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlVGltZShkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNfMS5hc3luYzsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERlYm91bmNlVGltZU9wZXJhdG9yKGR1ZVRpbWUsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5kZWJvdW5jZVRpbWUgPSBkZWJvdW5jZVRpbWU7XG52YXIgRGVib3VuY2VUaW1lT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlYm91bmNlVGltZU9wZXJhdG9yKGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmR1ZVRpbWUgPSBkdWVUaW1lO1xuICAgICAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB9XG4gICAgRGVib3VuY2VUaW1lT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVlVGltZSwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZVRpbWVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlYm91bmNlVGltZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlYm91bmNlVGltZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGR1ZVRpbWUsIHNjaGVkdWxlcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuZHVlVGltZSA9IGR1ZVRpbWU7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNsZWFyRGVib3VuY2UoKTtcbiAgICAgICAgdGhpcy5sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCB0aGlzLmR1ZVRpbWUsIHRoaXMpKTtcbiAgICB9O1xuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWROZXh0KCk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9O1xuICAgIERlYm91bmNlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmRlYm91bmNlZE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJEZWJvdW5jZSgpO1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMubGFzdFZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVib3VuY2VUaW1lU3Vic2NyaWJlci5wcm90b3R5cGUuY2xlYXJEZWJvdW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoZGVib3VuY2VkU3Vic2NyaXB0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShkZWJvdW5jZWRTdWJzY3JpcHRpb24pO1xuICAgICAgICAgICAgZGVib3VuY2VkU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWJvdW5jZVRpbWVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcikpO1xuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0KHN1YnNjcmliZXIpIHtcbiAgICBzdWJzY3JpYmVyLmRlYm91bmNlZE5leHQoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYm91bmNlVGltZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIGFzeW5jXzEgPSByZXF1aXJlKCcuLi9zY2hlZHVsZXIvYXN5bmMnKTtcbnZhciBpc0RhdGVfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNEYXRlJyk7XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIE5vdGlmaWNhdGlvbl8xID0gcmVxdWlyZSgnLi4vTm90aWZpY2F0aW9uJyk7XG4vKipcbiAqIERlbGF5cyB0aGUgZW1pc3Npb24gb2YgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYSBnaXZlbiB0aW1lb3V0IG9yXG4gKiB1bnRpbCBhIGdpdmVuIERhdGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRpbWUgc2hpZnRzIGVhY2ggaXRlbSBieSBzb21lIHNwZWNpZmllZCBhbW91bnQgb2ZcbiAqIG1pbGxpc2Vjb25kcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZWxheS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBJZiB0aGUgZGVsYXkgYXJndW1lbnQgaXMgYSBOdW1iZXIsIHRoaXMgb3BlcmF0b3IgdGltZSBzaGlmdHMgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGF0IGFtb3VudCBvZiB0aW1lIGV4cHJlc3NlZCBpbiBtaWxsaXNlY29uZHMuIFRoZSByZWxhdGl2ZVxuICogdGltZSBpbnRlcnZhbHMgYmV0d2VlbiB0aGUgdmFsdWVzIGFyZSBwcmVzZXJ2ZWQuXG4gKlxuICogSWYgdGhlIGRlbGF5IGFyZ3VtZW50IGlzIGEgRGF0ZSwgdGhpcyBvcGVyYXRvciB0aW1lIHNoaWZ0cyB0aGUgc3RhcnQgb2YgdGhlXG4gKiBPYnNlcnZhYmxlIGV4ZWN1dGlvbiB1bnRpbCB0aGUgZ2l2ZW4gZGF0ZSBvY2N1cnMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RGVsYXkgZWFjaCBjbGljayBieSBvbmUgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBkZWxheWVkQ2xpY2tzID0gY2xpY2tzLmRlbGF5KDEwMDApOyAvLyBlYWNoIGNsaWNrIGVtaXR0ZWQgYWZ0ZXIgMSBzZWNvbmRcbiAqIGRlbGF5ZWRDbGlja3Muc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkRlbGF5IGFsbCBjbGlja3MgdW50aWwgYSBmdXR1cmUgZGF0ZSBoYXBwZW5zPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBkYXRlID0gbmV3IERhdGUoJ01hcmNoIDE1LCAyMDUwIDEyOjAwOjAwJyk7IC8vIGluIHRoZSBmdXR1cmVcbiAqIHZhciBkZWxheWVkQ2xpY2tzID0gY2xpY2tzLmRlbGF5KGRhdGUpOyAvLyBjbGljayBlbWl0dGVkIG9ubHkgYWZ0ZXIgdGhhdCBkYXRlXG4gKiBkZWxheWVkQ2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheVdoZW59XG4gKlxuICogQHBhcmFtIHtudW1iZXJ8RGF0ZX0gZGVsYXkgVGhlIGRlbGF5IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyAoYSBgbnVtYmVyYCkgb3JcbiAqIGEgYERhdGVgIHVudGlsIHdoaWNoIHRoZSBlbWlzc2lvbiBvZiB0aGUgc291cmNlIGl0ZW1zIGlzIGRlbGF5ZWQuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgdGltZS1zaGlmdCBmb3IgZWFjaCBpdGVtLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhlIHNwZWNpZmllZCB0aW1lb3V0IG9yIERhdGUuXG4gKiBAbWV0aG9kIGRlbGF5XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBkZWxheShkZWxheSwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICB2YXIgYWJzb2x1dGVEZWxheSA9IGlzRGF0ZV8xLmlzRGF0ZShkZWxheSk7XG4gICAgdmFyIGRlbGF5Rm9yID0gYWJzb2x1dGVEZWxheSA/ICgrZGVsYXkgLSBzY2hlZHVsZXIubm93KCkpIDogTWF0aC5hYnMoZGVsYXkpO1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IERlbGF5T3BlcmF0b3IoZGVsYXlGb3IsIHNjaGVkdWxlcikpO1xufVxuZXhwb3J0cy5kZWxheSA9IGRlbGF5O1xudmFyIERlbGF5T3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5T3BlcmF0b3IoZGVsYXksIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBEZWxheU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVsYXlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZGVsYXksIHRoaXMuc2NoZWR1bGVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGVsYXlPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIERlbGF5U3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlbGF5U3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWxheVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGRlbGF5LCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXJyb3JlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBEZWxheVN1YnNjcmliZXIuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHN0YXRlLnNvdXJjZTtcbiAgICAgICAgdmFyIHF1ZXVlID0gc291cmNlLnF1ZXVlO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gc3RhdGUuc2NoZWR1bGVyO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSBzdGF0ZS5kZXN0aW5hdGlvbjtcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDAgJiYgKHF1ZXVlWzBdLnRpbWUgLSBzY2hlZHVsZXIubm93KCkpIDw9IDApIHtcbiAgICAgICAgICAgIHF1ZXVlLnNoaWZ0KCkubm90aWZpY2F0aW9uLm9ic2VydmUoZGVzdGluYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZGVsYXlfMSA9IE1hdGgubWF4KDAsIHF1ZXVlWzBdLnRpbWUgLSBzY2hlZHVsZXIubm93KCkpO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSwgZGVsYXlfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2UuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX3NjaGVkdWxlID0gZnVuY3Rpb24gKHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShEZWxheVN1YnNjcmliZXIuZGlzcGF0Y2gsIHRoaXMuZGVsYXksIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcywgZGVzdGluYXRpb246IHRoaXMuZGVzdGluYXRpb24sIHNjaGVkdWxlcjogc2NoZWR1bGVyXG4gICAgICAgIH0pKTtcbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuc2NoZWR1bGVOb3RpZmljYXRpb24gPSBmdW5jdGlvbiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBtZXNzYWdlID0gbmV3IERlbGF5TWVzc2FnZShzY2hlZHVsZXIubm93KCkgKyB0aGlzLmRlbGF5LCBub3RpZmljYXRpb24pO1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKHNjaGVkdWxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5U3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU5vdGlmaWNhdGlvbihOb3RpZmljYXRpb25fMS5Ob3RpZmljYXRpb24uY3JlYXRlTmV4dCh2YWx1ZSkpO1xuICAgIH07XG4gICAgRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZXJyb3JlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgRGVsYXlTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVOb3RpZmljYXRpb24oTm90aWZpY2F0aW9uXzEuTm90aWZpY2F0aW9uLmNyZWF0ZUNvbXBsZXRlKCkpO1xuICAgIH07XG4gICAgcmV0dXJuIERlbGF5U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbnZhciBEZWxheU1lc3NhZ2UgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlbGF5TWVzc2FnZSh0aW1lLCBub3RpZmljYXRpb24pIHtcbiAgICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb24gPSBub3RpZmljYXRpb247XG4gICAgfVxuICAgIHJldHVybiBEZWxheU1lc3NhZ2U7XG59KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVsYXkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgdHJ5Q2F0Y2hfMSA9IHJlcXVpcmUoJy4uL3V0aWwvdHJ5Q2F0Y2gnKTtcbnZhciBlcnJvck9iamVjdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9lcnJvck9iamVjdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYWxsIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgYXJlIGRpc3RpbmN0IGJ5IGNvbXBhcmlzb24gZnJvbSB0aGUgcHJldmlvdXMgaXRlbS5cbiAqXG4gKiBJZiBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHRoZW4gaXQgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggaXRlbSB0byB0ZXN0IGZvciB3aGV0aGVyIG9yIG5vdCB0aGF0IHZhbHVlIHNob3VsZCBiZSBlbWl0dGVkLlxuICpcbiAqIElmIGEgY29tcGFyYXRvciBmdW5jdGlvbiBpcyBub3QgcHJvdmlkZWQsIGFuIGVxdWFsaXR5IGNoZWNrIGlzIHVzZWQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BIHNpbXBsZSBleGFtcGxlIHdpdGggbnVtYmVyczwvY2FwdGlvbj5cbiAqIE9ic2VydmFibGUub2YoMSwgMSwgMiwgMiwgMiwgMSwgMSwgMiwgMywgMywgNClcbiAqICAgLmRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTsgLy8gMSwgMiwgMSwgMiwgMywgNFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkFuIGV4YW1wbGUgdXNpbmcgYSBjb21wYXJlIGZ1bmN0aW9uPC9jYXB0aW9uPlxuICogaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgICBhZ2U6IG51bWJlcixcbiAqICAgIG5hbWU6IHN0cmluZ1xuICogfVxuICpcbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPihcbiAqICAgICB7IGFnZTogNCwgbmFtZTogJ0Zvbyd9LFxuICogICAgIHsgYWdlOiA3LCBuYW1lOiAnQmFyJ30sXG4gKiAgICAgeyBhZ2U6IDUsIG5hbWU6ICdGb28nfSlcbiAqICAgICB7IGFnZTogNiwgbmFtZTogJ0Zvbyd9KVxuICogICAgIC5kaXN0aW5jdFVudGlsQ2hhbmdlZCgocDogUGVyc29uLCBxOiBQZXJzb24pID0+IHAubmFtZSA9PT0gcS5uYW1lKVxuICogICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyB7IGFnZTogNCwgbmFtZTogJ0ZvbycgfVxuICogLy8geyBhZ2U6IDcsIG5hbWU6ICdCYXInIH1cbiAqIC8vIHsgYWdlOiA1LCBuYW1lOiAnRm9vJyB9XG4gKlxuICogQHNlZSB7QGxpbmsgZGlzdGluY3R9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY29tcGFyZV0gT3B0aW9uYWwgY29tcGFyaXNvbiBmdW5jdGlvbiBjYWxsZWQgdG8gdGVzdCBpZiBhbiBpdGVtIGlzIGRpc3RpbmN0IGZyb20gdGhlIHByZXZpb3VzIGl0ZW0gaW4gdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIGRpc3RpbmN0IHZhbHVlcy5cbiAqIEBtZXRob2QgZGlzdGluY3RVbnRpbENoYW5nZWRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRpc3RpbmN0VW50aWxDaGFuZ2VkKGNvbXBhcmUsIGtleVNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGlzdGluY3RVbnRpbENoYW5nZWRPcGVyYXRvcihjb21wYXJlLCBrZXlTZWxlY3RvcikpO1xufVxuZXhwb3J0cy5kaXN0aW5jdFVudGlsQ2hhbmdlZCA9IGRpc3RpbmN0VW50aWxDaGFuZ2VkO1xudmFyIERpc3RpbmN0VW50aWxDaGFuZ2VkT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERpc3RpbmN0VW50aWxDaGFuZ2VkT3BlcmF0b3IoY29tcGFyZSwga2V5U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5jb21wYXJlID0gY29tcGFyZTtcbiAgICAgICAgdGhpcy5rZXlTZWxlY3RvciA9IGtleVNlbGVjdG9yO1xuICAgIH1cbiAgICBEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY29tcGFyZSwgdGhpcy5rZXlTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIERpc3RpbmN0VW50aWxDaGFuZ2VkT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaXN0aW5jdFVudGlsQ2hhbmdlZFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb21wYXJlLCBrZXlTZWxlY3Rvcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMua2V5U2VsZWN0b3IgPSBrZXlTZWxlY3RvcjtcbiAgICAgICAgdGhpcy5oYXNLZXkgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb21wYXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgICAgICB9XG4gICAgfVxuICAgIERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgIHJldHVybiB4ID09PSB5O1xuICAgIH07XG4gICAgRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIga2V5U2VsZWN0b3IgPSB0aGlzLmtleVNlbGVjdG9yO1xuICAgICAgICB2YXIga2V5ID0gdmFsdWU7XG4gICAgICAgIGlmIChrZXlTZWxlY3Rvcikge1xuICAgICAgICAgICAga2V5ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLmtleVNlbGVjdG9yKSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdC5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmhhc0tleSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2hfMS50cnlDYXRjaCh0aGlzLmNvbXBhcmUpKHRoaXMua2V5LCBrZXkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3RfMS5lcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc0tleSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEJvb2xlYW4ocmVzdWx0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3RpbmN0VW50aWxDaGFuZ2VkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIGRpc3RpbmN0VW50aWxDaGFuZ2VkXzEgPSByZXF1aXJlKCcuL2Rpc3RpbmN0VW50aWxDaGFuZ2VkJyk7XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBhcmUgZGlzdGluY3QgYnkgY29tcGFyaXNvbiBmcm9tIHRoZSBwcmV2aW91cyBpdGVtLFxuICogdXNpbmcgYSBwcm9wZXJ0eSBhY2Nlc3NlZCBieSB1c2luZyB0aGUga2V5IHByb3ZpZGVkIHRvIGNoZWNrIGlmIHRoZSB0d28gaXRlbXMgYXJlIGRpc3RpbmN0LlxuICpcbiAqIElmIGEgY29tcGFyYXRvciBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBpdGVtIHRvIHRlc3QgZm9yIHdoZXRoZXIgb3Igbm90IHRoYXQgdmFsdWUgc2hvdWxkIGJlIGVtaXR0ZWQuXG4gKlxuICogSWYgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCwgYW4gZXF1YWxpdHkgY2hlY2sgaXMgdXNlZCBieSBkZWZhdWx0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkFuIGV4YW1wbGUgY29tcGFyaW5nIHRoZSBuYW1lIG9mIHBlcnNvbnM8L2NhcHRpb24+XG4gKlxuICogIGludGVyZmFjZSBQZXJzb24ge1xuICogICAgIGFnZTogbnVtYmVyLFxuICogICAgIG5hbWU6IHN0cmluZ1xuICogIH1cbiAqXG4gKiBPYnNlcnZhYmxlLm9mPFBlcnNvbj4oXG4gKiAgICAgeyBhZ2U6IDQsIG5hbWU6ICdGb28nfSxcbiAqICAgICB7IGFnZTogNywgbmFtZTogJ0Jhcid9LFxuICogICAgIHsgYWdlOiA1LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgeyBhZ2U6IDYsIG5hbWU6ICdGb28nfSlcbiAqICAgICAuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQoJ25hbWUnKVxuICogICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyB7IGFnZTogNCwgbmFtZTogJ0ZvbycgfVxuICogLy8geyBhZ2U6IDcsIG5hbWU6ICdCYXInIH1cbiAqIC8vIHsgYWdlOiA1LCBuYW1lOiAnRm9vJyB9XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QW4gZXhhbXBsZSBjb21wYXJpbmcgdGhlIGZpcnN0IGxldHRlcnMgb2YgdGhlIG5hbWU8L2NhcHRpb24+XG4gKlxuICogaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgICAgYWdlOiBudW1iZXIsXG4gKiAgICAgbmFtZTogc3RyaW5nXG4gKiAgfVxuICpcbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPihcbiAqICAgICB7IGFnZTogNCwgbmFtZTogJ0ZvbzEnfSxcbiAqICAgICB7IGFnZTogNywgbmFtZTogJ0Jhcid9LFxuICogICAgIHsgYWdlOiA1LCBuYW1lOiAnRm9vMid9LFxuICogICAgIHsgYWdlOiA2LCBuYW1lOiAnRm9vMyd9KVxuICogICAgIC5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgnbmFtZScsICh4OiBzdHJpbmcsIHk6IHN0cmluZykgPT4geC5zdWJzdHJpbmcoMCwgMykgPT09IHkuc3Vic3RyaW5nKDAsIDMpKVxuICogICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyB7IGFnZTogNCwgbmFtZTogJ0ZvbzEnIH1cbiAqIC8vIHsgYWdlOiA3LCBuYW1lOiAnQmFyJyB9XG4gKiAvLyB7IGFnZTogNSwgbmFtZTogJ0ZvbzInIH1cbiAqXG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxDaGFuZ2VkfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgU3RyaW5nIGtleSBmb3Igb2JqZWN0IHByb3BlcnR5IGxvb2t1cCBvbiBlYWNoIGl0ZW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY29tcGFyZV0gT3B0aW9uYWwgY29tcGFyaXNvbiBmdW5jdGlvbiBjYWxsZWQgdG8gdGVzdCBpZiBhbiBpdGVtIGlzIGRpc3RpbmN0IGZyb20gdGhlIHByZXZpb3VzIGl0ZW0gaW4gdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIGRpc3RpbmN0IHZhbHVlcyBiYXNlZCBvbiB0aGUga2V5IHNwZWNpZmllZC5cbiAqIEBtZXRob2QgZGlzdGluY3RVbnRpbEtleUNoYW5nZWRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKGtleSwgY29tcGFyZSkge1xuICAgIHJldHVybiBkaXN0aW5jdFVudGlsQ2hhbmdlZF8xLmRpc3RpbmN0VW50aWxDaGFuZ2VkLmNhbGwodGhpcywgZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKGNvbXBhcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKHhba2V5XSwgeVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geFtrZXldID09PSB5W2tleV07XG4gICAgfSk7XG59XG5leHBvcnRzLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkID0gZGlzdGluY3RVbnRpbEtleUNoYW5nZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIFBlcmZvcm0gYSBzaWRlIGVmZmVjdCBmb3IgZXZlcnkgZW1pc3Npb24gb24gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgcmV0dXJuXG4gKiBhbiBPYnNlcnZhYmxlIHRoYXQgaXMgaWRlbnRpY2FsIHRvIHRoZSBzb3VyY2UuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkludGVyY2VwdHMgZWFjaCBlbWlzc2lvbiBvbiB0aGUgc291cmNlIGFuZCBydW5zIGFcbiAqIGZ1bmN0aW9uLCBidXQgcmV0dXJucyBhbiBvdXRwdXQgd2hpY2ggaXMgaWRlbnRpY2FsIHRvIHRoZSBzb3VyY2UuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhIG1pcnJvcmVkIE9ic2VydmFibGUgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgbW9kaWZpZWQgc28gdGhhdFxuICogdGhlIHByb3ZpZGVkIE9ic2VydmVyIGlzIGNhbGxlZCB0byBwZXJmb3JtIGEgc2lkZSBlZmZlY3QgZm9yIGV2ZXJ5IHZhbHVlLFxuICogZXJyb3IsIGFuZCBjb21wbGV0aW9uIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZS4gQW55IGVycm9ycyB0aGF0IGFyZSB0aHJvd24gaW5cbiAqIHRoZSBhZm9yZW1lbnRpb25lZCBPYnNlcnZlciBvciBoYW5kbGVycyBhcmUgc2FmZWx5IHNlbnQgZG93biB0aGUgZXJyb3IgcGF0aFxuICogb2YgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIFRoaXMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgeW91ciBPYnNlcnZhYmxlcyBmb3IgdGhlIGNvcnJlY3QgdmFsdWVzXG4gKiBvciBwZXJmb3JtaW5nIG90aGVyIHNpZGUgZWZmZWN0cy5cbiAqXG4gKiBOb3RlOiB0aGlzIGlzIGRpZmZlcmVudCB0byBhIGBzdWJzY3JpYmVgIG9uIHRoZSBPYnNlcnZhYmxlLiBJZiB0aGUgT2JzZXJ2YWJsZVxuICogcmV0dXJuZWQgYnkgYGRvYCBpcyBub3Qgc3Vic2NyaWJlZCwgdGhlIHNpZGUgZWZmZWN0cyBzcGVjaWZpZWQgYnkgdGhlXG4gKiBPYnNlcnZlciB3aWxsIG5ldmVyIGhhcHBlbi4gYGRvYCB0aGVyZWZvcmUgc2ltcGx5IHNwaWVzIG9uIGV4aXN0aW5nXG4gKiBleGVjdXRpb24sIGl0IGRvZXMgbm90IHRyaWdnZXIgYW4gZXhlY3V0aW9uIHRvIGhhcHBlbiBsaWtlIGBzdWJzY3JpYmVgIGRvZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGV2ZXJ5IGV2ZXJ5IGNsaWNrIHRvIHRoZSBjbGllbnRYIHBvc2l0aW9uIG9mIHRoYXQgY2xpY2ssIHdoaWxlIGFsc28gbG9nZ2luZyB0aGUgY2xpY2sgZXZlbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHBvc2l0aW9ucyA9IGNsaWNrc1xuICogICAuZG8oZXYgPT4gY29uc29sZS5sb2coZXYpKVxuICogICAubWFwKGV2ID0+IGV2LmNsaWVudFgpO1xuICogcG9zaXRpb25zLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtYXB9XG4gKiBAc2VlIHtAbGluayBzdWJzY3JpYmV9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbn0gW25leHRPck9ic2VydmVyXSBBIG5vcm1hbCBPYnNlcnZlciBvYmplY3Qgb3IgYVxuICogY2FsbGJhY2sgZm9yIGBuZXh0YC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtlcnJvcl0gQ2FsbGJhY2sgZm9yIGVycm9ycyBpbiB0aGUgc291cmNlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NvbXBsZXRlXSBDYWxsYmFjayBmb3IgdGhlIGNvbXBsZXRpb24gb2YgdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgaWRlbnRpY2FsIHRvIHRoZSBzb3VyY2UsIGJ1dCBydW5zIHRoZVxuICogc3BlY2lmaWVkIE9ic2VydmVyIG9yIGNhbGxiYWNrKHMpIGZvciBlYWNoIGl0ZW0uXG4gKiBAbWV0aG9kIGRvXG4gKiBAbmFtZSBkb1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gX2RvKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEb09wZXJhdG9yKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpKTtcbn1cbmV4cG9ydHMuX2RvID0gX2RvO1xudmFyIERvT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERvT3BlcmF0b3IobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICB0aGlzLm5leHRPck9ic2VydmVyID0gbmV4dE9yT2JzZXJ2ZXI7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIH1cbiAgICBEb09wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRG9TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubmV4dE9yT2JzZXJ2ZXIsIHRoaXMuZXJyb3IsIHRoaXMuY29tcGxldGUpKTtcbiAgICB9O1xuICAgIHJldHVybiBEb09wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgRG9TdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRG9TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERvU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgbmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyXzEuU3Vic2NyaWJlcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGQoc2FmZVN1YnNjcmliZXIpO1xuICAgICAgICB0aGlzLnNhZmVTdWJzY3JpYmVyID0gc2FmZVN1YnNjcmliZXI7XG4gICAgfVxuICAgIERvU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gdGhpcy5zYWZlU3Vic2NyaWJlcjtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIGlmIChzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3Ioc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRG9TdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBzYWZlU3Vic2NyaWJlciA9IHRoaXMuc2FmZVN1YnNjcmliZXI7XG4gICAgICAgIHNhZmVTdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgIGlmIChzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3Ioc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEb1N1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNhZmVTdWJzY3JpYmVyID0gdGhpcy5zYWZlU3Vic2NyaWJlcjtcbiAgICAgICAgc2FmZVN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEb1N1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kby5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIFN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmliZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEZpbHRlciBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBieSBvbmx5IGVtaXR0aW5nIHRob3NlIHRoYXRcbiAqIHNhdGlzZnkgYSBzcGVjaWZpZWQgcHJlZGljYXRlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlXG4gKiBbQXJyYXkucHJvdG90eXBlLmZpbHRlcigpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXIpLFxuICogaXQgb25seSBlbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBpZiBpdCBwYXNzZXMgYSBjcml0ZXJpb24gZnVuY3Rpb24uPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZmlsdGVyLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFNpbWlsYXIgdG8gdGhlIHdlbGwta25vd24gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZCwgdGhpcyBvcGVyYXRvclxuICogdGFrZXMgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBwYXNzZXMgdGhlbSB0aHJvdWdoIGEgYHByZWRpY2F0ZWBcbiAqIGZ1bmN0aW9uIGFuZCBvbmx5IGVtaXRzIHRob3NlIHZhbHVlcyB0aGF0IHlpZWxkZWQgYHRydWVgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgb25seSBjbGljayBldmVudHMgd2hvc2UgdGFyZ2V0IHdhcyBhIERJViBlbGVtZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBjbGlja3NPbkRpdnMgPSBjbGlja3MuZmlsdGVyKGV2ID0+IGV2LnRhcmdldC50YWdOYW1lID09PSAnRElWJyk7XG4gKiBjbGlja3NPbkRpdnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0fVxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbENoYW5nZWR9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZH1cbiAqIEBzZWUge0BsaW5rIGlnbm9yZUVsZW1lbnRzfVxuICogQHNlZSB7QGxpbmsgcGFydGl0aW9ufVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogYm9vbGVhbn0gcHJlZGljYXRlIEEgZnVuY3Rpb24gdGhhdFxuICogZXZhbHVhdGVzIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGl0IHJldHVybnMgYHRydWVgLFxuICogdGhlIHZhbHVlIGlzIGVtaXR0ZWQsIGlmIGBmYWxzZWAgdGhlIHZhbHVlIGlzIG5vdCBwYXNzZWQgdG8gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS4gVGhlIGBpbmRleGAgcGFyYW1ldGVyIGlzIHRoZSBudW1iZXIgYGlgIGZvciB0aGUgaS10aCBzb3VyY2VcbiAqIGVtaXNzaW9uIHRoYXQgaGFzIGhhcHBlbmVkIHNpbmNlIHRoZSBzdWJzY3JpcHRpb24sIHN0YXJ0aW5nIGZyb20gdGhlIG51bWJlclxuICogYDBgLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIGB0aGlzYFxuICogaW4gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIHRoYXQgd2VyZVxuICogYWxsb3dlZCBieSB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24uXG4gKiBAbWV0aG9kIGZpbHRlclxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gZmlsdGVyKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IEZpbHRlck9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZykpO1xufVxuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG52YXIgRmlsdGVyT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZpbHRlck9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgdGhpcy50aGlzQXJnID0gdGhpc0FyZztcbiAgICB9XG4gICAgRmlsdGVyT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaWx0ZXJTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnRoaXNBcmcpKTtcbiAgICB9O1xuICAgIHJldHVybiBGaWx0ZXJPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEZpbHRlclN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaWx0ZXJTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZpbHRlclN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByZWRpY2F0ZSwgdGhpc0FyZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgfVxuICAgIC8vIHRoZSB0cnkgY2F0Y2ggYmxvY2sgYmVsb3cgaXMgbGVmdCBzcGVjaWZpY2FsbHkgZm9yXG4gICAgLy8gb3B0aW1pemF0aW9uIGFuZCBwZXJmIHJlYXNvbnMuIGEgdHJ5Q2F0Y2hlciBpcyBub3QgbmVjZXNzYXJ5IGhlcmUuXG4gICAgRmlsdGVyU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlLmNhbGwodGhpcy50aGlzQXJnLCB2YWx1ZSwgdGhpcy5jb3VudCsrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG4vKipcbiAqIEFwcGxpZXMgYSBnaXZlbiBgcHJvamVjdGAgZnVuY3Rpb24gdG8gZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUsIGFuZCBlbWl0cyB0aGUgcmVzdWx0aW5nIHZhbHVlcyBhcyBhbiBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlIFtBcnJheS5wcm90b3R5cGUubWFwKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L21hcCksXG4gKiBpdCBwYXNzZXMgZWFjaCBzb3VyY2UgdmFsdWUgdGhyb3VnaCBhIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIHRvIGdldFxuICogY29ycmVzcG9uZGluZyBvdXRwdXQgdmFsdWVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21hcC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBTaW1pbGFyIHRvIHRoZSB3ZWxsIGtub3duIGBBcnJheS5wcm90b3R5cGUubWFwYCBmdW5jdGlvbiwgdGhpcyBvcGVyYXRvclxuICogYXBwbGllcyBhIHByb2plY3Rpb24gdG8gZWFjaCB2YWx1ZSBhbmQgZW1pdHMgdGhhdCBwcm9qZWN0aW9uIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGV2ZXJ5IGV2ZXJ5IGNsaWNrIHRvIHRoZSBjbGllbnRYIHBvc2l0aW9uIG9mIHRoYXQgY2xpY2s8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHBvc2l0aW9ucyA9IGNsaWNrcy5tYXAoZXYgPT4gZXYuY2xpZW50WCk7XG4gKiBwb3NpdGlvbnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1hcFRvfVxuICogQHNlZSB7QGxpbmsgcGx1Y2t9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IFJ9IHByb2plY3QgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5XG4gKiB0byBlYWNoIGB2YWx1ZWAgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIFRoZSBgaW5kZXhgIHBhcmFtZXRlciBpc1xuICogdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIGVtaXNzaW9uIHRoYXQgaGFzIGhhcHBlbmVkIHNpbmNlIHRoZVxuICogc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXIgYDBgLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZWZpbmUgd2hhdCBgdGhpc2AgaXMgaW4gdGhlXG4gKiBgcHJvamVjdGAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgdHJhbnNmb3JtZWQgYnkgdGhlIGdpdmVuIGBwcm9qZWN0YCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgbWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtYXAocHJvamVjdCwgdGhpc0FyZykge1xuICAgIGlmICh0eXBlb2YgcHJvamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbi4gQXJlIHlvdSBsb29raW5nIGZvciBgbWFwVG8oKWA/Jyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1hcE9wZXJhdG9yKHByb2plY3QsIHRoaXNBcmcpKTtcbn1cbmV4cG9ydHMubWFwID0gbWFwO1xudmFyIE1hcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBPcGVyYXRvcihwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgfVxuICAgIE1hcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMudGhpc0FyZykpO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcE9wZXJhdG9yO1xufSgpKTtcbmV4cG9ydHMuTWFwT3BlcmF0b3IgPSBNYXBPcGVyYXRvcjtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgTWFwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgdGhpc0FyZykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLnRoaXNBcmcgPSB0aGlzQXJnIHx8IHRoaXM7XG4gICAgfVxuICAgIC8vIE5PVEU6IFRoaXMgbG9va3MgdW5vcHRpbWl6ZWQsIGJ1dCBpdCdzIGFjdHVhbGx5IHB1cnBvc2VmdWxseSBOT1RcbiAgICAvLyB1c2luZyB0cnkvY2F0Y2ggb3B0aW1pemF0aW9ucy5cbiAgICBNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmNhbGwodGhpcy50aGlzQXJnLCB2YWx1ZSwgdGhpcy5jb3VudCsrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9PYnNlcnZhYmxlJyk7XG52YXIgQXJyYXlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZScpO1xudmFyIG1lcmdlQWxsXzEgPSByZXF1aXJlKCcuL21lcmdlQWxsJyk7XG52YXIgaXNTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL3V0aWwvaXNTY2hlZHVsZXInKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENyZWF0ZXMgYW4gb3V0cHV0IE9ic2VydmFibGUgd2hpY2ggY29uY3VycmVudGx5IGVtaXRzIGFsbCB2YWx1ZXMgZnJvbSBldmVyeVxuICogZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG9nZXRoZXIgYnkgYmxlbmRpbmdcbiAqIHRoZWlyIHZhbHVlcyBpbnRvIG9uZSBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBtZXJnZWAgc3Vic2NyaWJlcyB0byBlYWNoIGdpdmVuIGlucHV0IE9ic2VydmFibGUgKGVpdGhlciB0aGUgc291cmNlIG9yIGFuXG4gKiBPYnNlcnZhYmxlIGdpdmVuIGFzIGFyZ3VtZW50KSwgYW5kIHNpbXBseSBmb3J3YXJkcyAod2l0aG91dCBkb2luZyBhbnlcbiAqIHRyYW5zZm9ybWF0aW9uKSBhbGwgdGhlIHZhbHVlcyBmcm9tIGFsbCB0aGUgaW5wdXQgT2JzZXJ2YWJsZXMgdG8gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIG9ubHkgY29tcGxldGVzIG9uY2UgYWxsIGlucHV0IE9ic2VydmFibGVzXG4gKiBoYXZlIGNvbXBsZXRlZC4gQW55IGVycm9yIGRlbGl2ZXJlZCBieSBhbiBpbnB1dCBPYnNlcnZhYmxlIHdpbGwgYmUgaW1tZWRpYXRlbHlcbiAqIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1lcmdlIHRvZ2V0aGVyIHR3byBPYnNlcnZhYmxlczogMXMgaW50ZXJ2YWwgYW5kIGNsaWNrczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrc09yVGltZXIgPSBjbGlja3MubWVyZ2UodGltZXIpO1xuICogY2xpY2tzT3JUaW1lci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWVyZ2UgdG9nZXRoZXIgMyBPYnNlcnZhYmxlcywgYnV0IG9ubHkgMiBydW4gY29uY3VycmVudGx5PC9jYXB0aW9uPlxuICogdmFyIHRpbWVyMSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCk7XG4gKiB2YXIgdGltZXIyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKS50YWtlKDYpO1xuICogdmFyIHRpbWVyMyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKS50YWtlKDEwKTtcbiAqIHZhciBjb25jdXJyZW50ID0gMjsgLy8gdGhlIGFyZ3VtZW50XG4gKiB2YXIgbWVyZ2VkID0gdGltZXIxLm1lcmdlKHRpbWVyMiwgdGltZXIzLCBjb25jdXJyZW50KTtcbiAqIG1lcmdlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IG90aGVyIEFuIGlucHV0IE9ic2VydmFibGUgdG8gbWVyZ2Ugd2l0aCB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlucHV0XG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPW51bGxdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3IgbWFuYWdpbmdcbiAqIGNvbmN1cnJlbmN5IG9mIGlucHV0IE9ic2VydmFibGVzLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIHRoYXQgYXJlIHRoZSByZXN1bHQgb2ZcbiAqIGV2ZXJ5IGlucHV0IE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIG1lcmdlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBtZXJnZSgpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKG1lcmdlU3RhdGljLmFwcGx5KHZvaWQgMCwgW3RoaXNdLmNvbmNhdChvYnNlcnZhYmxlcykpKTtcbn1cbmV4cG9ydHMubWVyZ2UgPSBtZXJnZTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIENyZWF0ZXMgYW4gb3V0cHV0IE9ic2VydmFibGUgd2hpY2ggY29uY3VycmVudGx5IGVtaXRzIGFsbCB2YWx1ZXMgZnJvbSBldmVyeVxuICogZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG9nZXRoZXIgYnkgYmxlbmRpbmdcbiAqIHRoZWlyIHZhbHVlcyBpbnRvIG9uZSBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBtZXJnZWAgc3Vic2NyaWJlcyB0byBlYWNoIGdpdmVuIGlucHV0IE9ic2VydmFibGUgKGFzIGFyZ3VtZW50cyksIGFuZCBzaW1wbHlcbiAqIGZvcndhcmRzICh3aXRob3V0IGRvaW5nIGFueSB0cmFuc2Zvcm1hdGlvbikgYWxsIHRoZSB2YWx1ZXMgZnJvbSBhbGwgdGhlIGlucHV0XG4gKiBPYnNlcnZhYmxlcyB0byB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvbmx5IGNvbXBsZXRlc1xuICogb25jZSBhbGwgaW5wdXQgT2JzZXJ2YWJsZXMgaGF2ZSBjb21wbGV0ZWQuIEFueSBlcnJvciBkZWxpdmVyZWQgYnkgYW4gaW5wdXRcbiAqIE9ic2VydmFibGUgd2lsbCBiZSBpbW1lZGlhdGVseSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NZXJnZSB0b2dldGhlciB0d28gT2JzZXJ2YWJsZXM6IDFzIGludGVydmFsIGFuZCBjbGlja3M8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBjbGlja3NPclRpbWVyID0gUnguT2JzZXJ2YWJsZS5tZXJnZShjbGlja3MsIHRpbWVyKTtcbiAqIGNsaWNrc09yVGltZXIuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIHRpbWVyIHdpbGwgZW1pdCBhc2NlbmRpbmcgdmFsdWVzLCBvbmUgZXZlcnkgc2Vjb25kKDEwMDBtcykgdG8gY29uc29sZVxuICogLy8gY2xpY2tzIGxvZ3MgTW91c2VFdmVudHMgdG8gY29uc29sZSBldmVyeXRpbWUgdGhlIFwiZG9jdW1lbnRcIiBpcyBjbGlja2VkXG4gKiAvLyBTaW5jZSB0aGUgdHdvIHN0cmVhbXMgYXJlIG1lcmdlZCB5b3Ugc2VlIHRoZXNlIGhhcHBlbmluZ1xuICogLy8gYXMgdGhleSBvY2N1ci5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NZXJnZSB0b2dldGhlciAzIE9ic2VydmFibGVzLCBidXQgb25seSAyIHJ1biBjb25jdXJyZW50bHk8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIGNvbmN1cnJlbnQgPSAyOyAvLyB0aGUgYXJndW1lbnRcbiAqIHZhciBtZXJnZWQgPSBSeC5PYnNlcnZhYmxlLm1lcmdlKHRpbWVyMSwgdGltZXIyLCB0aW1lcjMsIGNvbmN1cnJlbnQpO1xuICogbWVyZ2VkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAtIEZpcnN0IHRpbWVyMSBhbmQgdGltZXIyIHdpbGwgcnVuIGNvbmN1cnJlbnRseVxuICogLy8gLSB0aW1lcjEgd2lsbCBlbWl0IGEgdmFsdWUgZXZlcnkgMTAwMG1zIGZvciAxMCBpdGVyYXRpb25zXG4gKiAvLyAtIHRpbWVyMiB3aWxsIGVtaXQgYSB2YWx1ZSBldmVyeSAyMDAwbXMgZm9yIDYgaXRlcmF0aW9uc1xuICogLy8gLSBhZnRlciB0aW1lcjEgaGl0cyBpdCdzIG1heCBpdGVyYXRpb24sIHRpbWVyMiB3aWxsXG4gKiAvLyAgIGNvbnRpbnVlLCBhbmQgdGltZXIzIHdpbGwgc3RhcnQgdG8gcnVuIGNvbmN1cnJlbnRseSB3aXRoIHRpbWVyMlxuICogLy8gLSB3aGVuIHRpbWVyMiBoaXRzIGl0J3MgbWF4IGl0ZXJhdGlvbiBpdCB0ZXJtaW5hdGVzLCBhbmRcbiAqIC8vICAgdGltZXIzIHdpbGwgY29udGludWUgdG8gZW1pdCBhIHZhbHVlIGV2ZXJ5IDUwMG1zIHVudGlsIGl0IGlzIGNvbXBsZXRlXG4gKlxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKlxuICogQHBhcmFtIHsuLi5PYnNlcnZhYmxlSW5wdXR9IG9ic2VydmFibGVzIElucHV0IE9ic2VydmFibGVzIHRvIG1lcmdlIHRvZ2V0aGVyLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvciBtYW5hZ2luZ1xuICogY29uY3VycmVuY3kgb2YgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgdGhhdCBhcmUgdGhlIHJlc3VsdCBvZlxuICogZXZlcnkgaW5wdXQgT2JzZXJ2YWJsZS5cbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgbWVyZ2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIG1lcmdlU3RhdGljKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB2YXIgc2NoZWR1bGVyID0gbnVsbDtcbiAgICB2YXIgbGFzdCA9IG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpc1NjaGVkdWxlcl8xLmlzU2NoZWR1bGVyKGxhc3QpKSB7XG4gICAgICAgIHNjaGVkdWxlciA9IG9ic2VydmFibGVzLnBvcCgpO1xuICAgICAgICBpZiAob2JzZXJ2YWJsZXMubGVuZ3RoID4gMSAmJiB0eXBlb2Ygb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25jdXJyZW50ID0gb2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmN1cnJlbnQgPSBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gbnVsbCAmJiBvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEgJiYgb2JzZXJ2YWJsZXNbMF0gaW5zdGFuY2VvZiBPYnNlcnZhYmxlXzEuT2JzZXJ2YWJsZSkge1xuICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZXNbMF07XG4gICAgfVxuICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlXzEuQXJyYXlPYnNlcnZhYmxlKG9ic2VydmFibGVzLCBzY2hlZHVsZXIpLmxpZnQobmV3IG1lcmdlQWxsXzEuTWVyZ2VBbGxPcGVyYXRvcihjb25jdXJyZW50KSk7XG59XG5leHBvcnRzLm1lcmdlU3RhdGljID0gbWVyZ2VTdGF0aWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSB3aGljaFxuICogY29uY3VycmVudGx5IGRlbGl2ZXJzIGFsbCB2YWx1ZXMgdGhhdCBhcmUgZW1pdHRlZCBvbiB0aGUgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIGFuIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2VBbGwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1lcmdlQWxsYCBzdWJzY3JpYmVzIHRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcywgYWxzbyBrbm93biBhc1xuICogYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZSBlbWl0dGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlcywgaXQgc3Vic2NyaWJlcyB0byB0aGF0IGFuZCBkZWxpdmVycyBhbGwgdGhlIHZhbHVlcyBmcm9tIHRoZVxuICogaW5uZXIgT2JzZXJ2YWJsZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBvbmx5XG4gKiBjb21wbGV0ZXMgb25jZSBhbGwgaW5uZXIgT2JzZXJ2YWJsZXMgaGF2ZSBjb21wbGV0ZWQuIEFueSBlcnJvciBkZWxpdmVyZWQgYnlcbiAqIGEgaW5uZXIgT2JzZXJ2YWJsZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlNwYXduIGEgbmV3IGludGVydmFsIE9ic2VydmFibGUgZm9yIGVhY2ggY2xpY2sgZXZlbnQsIGFuZCBibGVuZCB0aGVpciBvdXRwdXRzIGFzIG9uZSBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHZhciBmaXJzdE9yZGVyID0gaGlnaGVyT3JkZXIubWVyZ2VBbGwoKTtcbiAqIGZpcnN0T3JkZXIuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvdW50IGZyb20gMCB0byA5IGV2ZXJ5IHNlY29uZCBmb3IgZWFjaCBjbGljaywgYnV0IG9ubHkgYWxsb3cgMiBjb25jdXJyZW50IHRpbWVyczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKSk7XG4gKiB2YXIgZmlyc3RPcmRlciA9IGhpZ2hlck9yZGVyLm1lcmdlQWxsKDIpO1xuICogZmlyc3RPcmRlci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZX1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaH1cbiAqIEBzZWUge0BsaW5rIHppcEFsbH1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbm5lclxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdmFsdWVzIGNvbWluZyBmcm9tIGFsbCB0aGVcbiAqIGlubmVyIE9ic2VydmFibGVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBtZXJnZUFsbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gbWVyZ2VBbGwoY29uY3VycmVudCkge1xuICAgIGlmIChjb25jdXJyZW50ID09PSB2b2lkIDApIHsgY29uY3VycmVudCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsgfVxuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IE1lcmdlQWxsT3BlcmF0b3IoY29uY3VycmVudCkpO1xufVxuZXhwb3J0cy5tZXJnZUFsbCA9IG1lcmdlQWxsO1xudmFyIE1lcmdlQWxsT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lcmdlQWxsT3BlcmF0b3IoY29uY3VycmVudCkge1xuICAgICAgICB0aGlzLmNvbmN1cnJlbnQgPSBjb25jdXJyZW50O1xuICAgIH1cbiAgICBNZXJnZUFsbE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKG9ic2VydmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlQWxsU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5jb25jdXJyZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWVyZ2VBbGxPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLk1lcmdlQWxsT3BlcmF0b3IgPSBNZXJnZUFsbE9wZXJhdG9yO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBNZXJnZUFsbFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNZXJnZUFsbFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWVyZ2VBbGxTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBjb25jdXJyZW50KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5jb25jdXJyZW50ID0gY29uY3VycmVudDtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgIH1cbiAgICBNZXJnZUFsbFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKG9ic2VydmFibGUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlIDwgdGhpcy5jb25jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBvYnNlcnZhYmxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKG9ic2VydmFibGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXJnZUFsbFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1lcmdlQWxsU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoaW5uZXJTdWIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuYWN0aXZlLS07XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE1lcmdlQWxsU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG5leHBvcnRzLk1lcmdlQWxsU3Vic2NyaWJlciA9IE1lcmdlQWxsU3Vic2NyaWJlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlQWxsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3ViamVjdF8xID0gcmVxdWlyZSgnLi4vU3ViamVjdCcpO1xudmFyIHRyeUNhdGNoXzEgPSByZXF1aXJlKCcuLi91dGlsL3RyeUNhdGNoJyk7XG52YXIgZXJyb3JPYmplY3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvZXJyb3JPYmplY3QnKTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBhbiBgZXJyb3JgLiBJZiB0aGUgc291cmNlIE9ic2VydmFibGVcbiAqIGNhbGxzIGBlcnJvcmAsIHRoaXMgbWV0aG9kIHdpbGwgZW1pdCB0aGUgVGhyb3dhYmxlIHRoYXQgY2F1c2VkIHRoZSBlcnJvciB0byB0aGUgT2JzZXJ2YWJsZSByZXR1cm5lZCBmcm9tIGBub3RpZmllcmAuXG4gKiBJZiB0aGF0IE9ic2VydmFibGUgY2FsbHMgYGNvbXBsZXRlYCBvciBgZXJyb3JgIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCBjYWxsIGBjb21wbGV0ZWAgb3IgYGVycm9yYCBvbiB0aGUgY2hpbGRcbiAqIHN1YnNjcmlwdGlvbi4gT3RoZXJ3aXNlIHRoaXMgbWV0aG9kIHdpbGwgcmVzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmV0cnlXaGVuLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyb3JzOiBPYnNlcnZhYmxlKTogT2JzZXJ2YWJsZX0gbm90aWZpZXIgLSBSZWNlaXZlcyBhbiBPYnNlcnZhYmxlIG9mIG5vdGlmaWNhdGlvbnMgd2l0aCB3aGljaCBhXG4gKiB1c2VyIGNhbiBgY29tcGxldGVgIG9yIGBlcnJvcmAsIGFib3J0aW5nIHRoZSByZXRyeS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IFRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBtb2RpZmllZCB3aXRoIHJldHJ5IGxvZ2ljLlxuICogQG1ldGhvZCByZXRyeVdoZW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHJldHJ5V2hlbihub3RpZmllcikge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFJldHJ5V2hlbk9wZXJhdG9yKG5vdGlmaWVyLCB0aGlzKSk7XG59XG5leHBvcnRzLnJldHJ5V2hlbiA9IHJldHJ5V2hlbjtcbnZhciBSZXRyeVdoZW5PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmV0cnlXaGVuT3BlcmF0b3Iobm90aWZpZXIsIHNvdXJjZSkge1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXRyeVdoZW5PcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFJldHJ5V2hlblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5ub3RpZmllciwgdGhpcy5zb3VyY2UpKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXRyeVdoZW5PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFJldHJ5V2hlblN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZXRyeVdoZW5TdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJldHJ5V2hlblN1YnNjcmliZXIoZGVzdGluYXRpb24sIG5vdGlmaWVyLCBzb3VyY2UpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBSZXRyeVdoZW5TdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IHRoaXMuZXJyb3JzO1xuICAgICAgICAgICAgdmFyIHJldHJpZXMgPSB0aGlzLnJldHJpZXM7XG4gICAgICAgICAgICB2YXIgcmV0cmllc1N1YnNjcmlwdGlvbiA9IHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgIGlmICghcmV0cmllcykge1xuICAgICAgICAgICAgICAgIGVycm9ycyA9IG5ldyBTdWJqZWN0XzEuU3ViamVjdCgpO1xuICAgICAgICAgICAgICAgIHJldHJpZXMgPSB0cnlDYXRjaF8xLnRyeUNhdGNoKHRoaXMubm90aWZpZXIpKGVycm9ycyk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHJpZXMgPT09IGVycm9yT2JqZWN0XzEuZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZXJyb3IuY2FsbCh0aGlzLCBlcnJvck9iamVjdF8xLmVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRyaWVzU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXRyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XG4gICAgICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSByZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgZXJyb3JzLm5leHQoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmV0cnlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlcnJvcnMgPSBfYS5lcnJvcnMsIHJldHJpZXNTdWJzY3JpcHRpb24gPSBfYS5yZXRyaWVzU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgICBlcnJvcnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0cmllc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0cmllc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHJpZXMgPSBudWxsO1xuICAgIH07XG4gICAgUmV0cnlXaGVuU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlcnJvcnMgPSBfYS5lcnJvcnMsIHJldHJpZXMgPSBfYS5yZXRyaWVzLCByZXRyaWVzU3Vic2NyaXB0aW9uID0gX2EucmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBudWxsO1xuICAgICAgICB0aGlzLnJldHJpZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XG4gICAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IHJldHJpZXNTdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuc291cmNlLnN1YnNjcmliZSh0aGlzKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXRyeVdoZW5TdWJzY3JpYmVyO1xufShPdXRlclN1YnNjcmliZXJfMS5PdXRlclN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5V2hlbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIE91dGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vT3V0ZXJTdWJzY3JpYmVyJyk7XG52YXIgc3Vic2NyaWJlVG9SZXN1bHRfMSA9IHJlcXVpcmUoJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnKTtcbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSBieVxuICogc3Vic2NyaWJpbmcgdG8gb25seSB0aGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIG9mIHRob3NlIGlubmVyIE9ic2VydmFibGVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzIGJ5IGRyb3BwaW5nIHRoZVxuICogcHJldmlvdXMgaW5uZXIgT2JzZXJ2YWJsZSBvbmNlIGEgbmV3IG9uZSBhcHBlYXJzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N3aXRjaC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgc3dpdGNoYCBzdWJzY3JpYmVzIHRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcywgYWxzbyBrbm93biBhcyBhXG4gKiBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZSBlbWl0dGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlcywgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHN1YnNjcmliZXMgdG8gdGhlIGlubmVyIE9ic2VydmFibGUgYW5kXG4gKiBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnkgdGhhdC4gU28gZmFyLCBpdCBiZWhhdmVzXG4gKiBsaWtlIHtAbGluayBtZXJnZUFsbH0uIEhvd2V2ZXIsIHdoZW4gYSBuZXcgaW5uZXIgT2JzZXJ2YWJsZSBpcyBlbWl0dGVkLFxuICogYHN3aXRjaGAgdW5zdWJzY3JpYmVzIGZyb20gdGhlIGVhcmxpZXItZW1pdHRlZCBpbm5lciBPYnNlcnZhYmxlIGFuZFxuICogc3Vic2NyaWJlcyB0byB0aGUgbmV3IGlubmVyIE9ic2VydmFibGUgYW5kIGJlZ2lucyBlbWl0dGluZyBpdGVtcyBmcm9tIGl0LiBJdFxuICogY29udGludWVzIHRvIGJlaGF2ZSBsaWtlIHRoaXMgZm9yIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiAvLyBFYWNoIGNsaWNrIGV2ZW50IGlzIG1hcHBlZCB0byBhbiBPYnNlcnZhYmxlIHRoYXQgdGlja3MgZXZlcnkgc2Vjb25kXG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiB2YXIgc3dpdGNoZWQgPSBoaWdoZXJPcmRlci5zd2l0Y2goKTtcbiAqIC8vIFRoZSBvdXRjb21lIGlzIHRoYXQgYHN3aXRjaGVkYCBpcyBlc3NlbnRpYWxseSBhIHRpbWVyIHRoYXQgcmVzdGFydHNcbiAqIC8vIG9uIGV2ZXJ5IGNsaWNrLiBUaGUgaW50ZXJ2YWwgT2JzZXJ2YWJsZXMgZnJvbSBvbGRlciBjbGlja3MgZG8gbm90IG1lcmdlXG4gKiAvLyB3aXRoIHRoZSBjdXJyZW50IGludGVydmFsIE9ic2VydmFibGUuXG4gKiBzd2l0Y2hlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcFRvfVxuICogQHNlZSB7QGxpbmsgemlwQWxsfVxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbXMgZW1pdHRlZCBieSB0aGVcbiAqIE9ic2VydmFibGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoXG4gKiBAbmFtZSBzd2l0Y2hcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIF9zd2l0Y2goKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoT3BlcmF0b3IoKSk7XG59XG5leHBvcnRzLl9zd2l0Y2ggPSBfc3dpdGNoO1xudmFyIFN3aXRjaE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTd2l0Y2hPcGVyYXRvcigpIHtcbiAgICB9XG4gICAgU3dpdGNoT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBTd2l0Y2hPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFN3aXRjaFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTd2l0Y2hTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN3aXRjaFN1YnNjcmliZXIoZGVzdGluYXRpb24pIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IDA7XG4gICAgICAgIHRoaXMuaGFzQ29tcGxldGVkID0gZmFsc2U7XG4gICAgfVxuICAgIFN3aXRjaFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVJbm5lcigpO1xuICAgICAgICB0aGlzLmFjdGl2ZSsrO1xuICAgICAgICB0aGlzLmFkZCh0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZUlubmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRoaXMuYWN0aXZlID4gMCA/IHRoaXMuYWN0aXZlIC0gMSA6IDA7XG4gICAgICAgIHZhciBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgICAgIGlmIChpbm5lclN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgaW5uZXJTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGlubmVyU3Vic2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4LCBpbm5lclN1Yikge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfTtcbiAgICBTd2l0Y2hTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH07XG4gICAgU3dpdGNoU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmVJbm5lcigpO1xuICAgICAgICBpZiAodGhpcy5oYXNDb21wbGV0ZWQgJiYgdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSwgZW1pdHRpbmcgdmFsdWVzIG9ubHkgZnJvbSB0aGUgbW9zdCByZWNlbnRseSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgc3dpdGNofS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zd2l0Y2hNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiAoc28tY2FsbGVkIFwiaW5uZXJcIikgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZVxuICogaW5uZXIgT2JzZXJ2YWJsZXMsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnlcbiAqIHRoYXQgaW5uZXIgT2JzZXJ2YWJsZS4gV2hlbiBhIG5ldyBpbm5lciBPYnNlcnZhYmxlIGlzIGVtaXR0ZWQsIGBzd2l0Y2hNYXBgXG4gKiBzdG9wcyBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBlYXJsaWVyLWVtaXR0ZWQgaW5uZXIgT2JzZXJ2YWJsZSBhbmQgYmVnaW5zXG4gKiBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBuZXcgb25lLiBJdCBjb250aW51ZXMgdG8gYmVoYXZlIGxpa2UgdGhpcyBmb3JcbiAqIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnN3aXRjaE1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgdGFraW5nIG9ubHkgdGhlIHZhbHVlcyBmcm9tIHRoZSBtb3N0IHJlY2VudGx5XG4gKiBwcm9qZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoTWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiBzd2l0Y2hNYXAocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTd2l0Y2hNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvcikpO1xufVxuZXhwb3J0cy5zd2l0Y2hNYXAgPSBzd2l0Y2hNYXA7XG52YXIgU3dpdGNoTWFwT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN3aXRjaE1hcE9wZXJhdG9yKHByb2plY3QsIHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgICAgIHRoaXMucmVzdWx0U2VsZWN0b3IgPSByZXN1bHRTZWxlY3RvcjtcbiAgICB9XG4gICAgU3dpdGNoTWFwT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hNYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy5yZXN1bHRTZWxlY3RvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaE1hcE9wZXJhdG9yO1xufSgpKTtcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG52YXIgU3dpdGNoTWFwU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN3aXRjaE1hcFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3dpdGNoTWFwU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgcHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnJlc3VsdFNlbGVjdG9yID0gcmVzdWx0U2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIH1cbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lubmVyU3ViKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9pbm5lclN1YiA9IGZ1bmN0aW9uIChyZXN1bHQsIHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIgaW5uZXJTdWJzY3JpcHRpb24gPSB0aGlzLmlubmVyU3Vic2NyaXB0aW9uO1xuICAgICAgICBpZiAoaW5uZXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGlubmVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGQodGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0XzEuc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgcmVzdWx0LCB2YWx1ZSwgaW5kZXgpKTtcbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICAgICAgaWYgKCFpbm5lclN1YnNjcmlwdGlvbiB8fCBpbm5lclN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl91bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfTtcbiAgICBTd2l0Y2hNYXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlDb21wbGV0ZSA9IGZ1bmN0aW9uIChpbm5lclN1Yikge1xuICAgICAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgICAgIHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyeU5vdGlmeU5leHQob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN3aXRjaE1hcFN1YnNjcmliZXIucHJvdG90eXBlLl90cnlOb3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFN3aXRjaE1hcFN1YnNjcmliZXI7XG59KE91dGVyU3Vic2NyaWJlcl8xLk91dGVyU3Vic2NyaWJlcikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3dpdGNoTWFwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgU3Vic2NyaWJlcl8xID0gcmVxdWlyZSgnLi4vU3Vic2NyaWJlcicpO1xudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEgPSByZXF1aXJlKCcuLi91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJyk7XG52YXIgRW1wdHlPYnNlcnZhYmxlXzEgPSByZXF1aXJlKCcuLi9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZScpO1xuLyoqXG4gKiBFbWl0cyBvbmx5IHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VGFrZXMgdGhlIGZpcnN0IGBjb3VudGAgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSwgdGhlblxuICogY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rha2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRha2VgIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGZpcnN0IGBjb3VudGAgdmFsdWVzIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgdGhlIHNvdXJjZSBlbWl0cyBmZXdlciB0aGFuIGBjb3VudGAgdmFsdWVzIHRoZW5cbiAqIGFsbCBvZiBpdHMgdmFsdWVzIGFyZSBlbWl0dGVkLiBBZnRlciB0aGF0LCBpdCBjb21wbGV0ZXMsIHJlZ2FyZGxlc3MgaWYgdGhlXG4gKiBzb3VyY2UgY29tcGxldGVzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlRha2UgdGhlIGZpcnN0IDUgc2Vjb25kcyBvZiBhbiBpbmZpbml0ZSAxLXNlY29uZCBpbnRlcnZhbCBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBmaXZlID0gaW50ZXJ2YWwudGFrZSg1KTtcbiAqIGZpdmUuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICogQHNlZSB7QGxpbmsgdGFrZVVudGlsfVxuICogQHNlZSB7QGxpbmsgdGFrZVdoaWxlfVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAdGhyb3dzIHtBcmd1bWVudE91dE9mUmFuZ2VFcnJvcn0gV2hlbiB1c2luZyBgdGFrZShpKWAsIGl0IGRlbGl2ZXJzIGFuXG4gKiBBcmd1bWVudE91dE9yUmFuZ2VFcnJvciB0byB0aGUgT2JzZXJ2ZXIncyBgZXJyb3JgIGNhbGxiYWNrIGlmIGBpIDwgMGAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IFRoZSBtYXhpbXVtIG51bWJlciBvZiBgbmV4dGAgdmFsdWVzIHRvIGVtaXQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgb25seSB0aGUgZmlyc3QgYGNvdW50YFxuICogdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBvciBhbGwgb2YgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIGlmIHRoZSBzb3VyY2UgZW1pdHMgZmV3ZXIgdGhhbiBgY291bnRgIHZhbHVlcy5cbiAqIEBtZXRob2QgdGFrZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGFrZShjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZV8xLkVtcHR5T2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGFrZU9wZXJhdG9yKGNvdW50KSk7XG4gICAgfVxufVxuZXhwb3J0cy50YWtlID0gdGFrZTtcbnZhciBUYWtlT3BlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRha2VPcGVyYXRvcih0b3RhbCkge1xuICAgICAgICB0aGlzLnRvdGFsID0gdG90YWw7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yXzEuQXJndW1lbnRPdXRPZlJhbmdlRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVGFrZU9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy50b3RhbCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRha2VPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRha2VTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFrZVN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFrZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIHRvdGFsKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy50b3RhbCA9IHRvdGFsO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICB9XG4gICAgVGFrZVN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMudG90YWw7XG4gICAgICAgIHZhciBjb3VudCA9ICsrdGhpcy5jb3VudDtcbiAgICAgICAgaWYgKGNvdW50IDw9IHRvdGFsKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSB0b3RhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBUYWtlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRha2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBPdXRlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoJy4uL091dGVyU3Vic2NyaWJlcicpO1xudmFyIHN1YnNjcmliZVRvUmVzdWx0XzEgPSByZXF1aXJlKCcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0Jyk7XG4vKipcbiAqIEVtaXRzIHRoZSB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdW50aWwgYSBgbm90aWZpZXJgXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxldHMgdmFsdWVzIHBhc3MgdW50aWwgYSBzZWNvbmQgT2JzZXJ2YWJsZSxcbiAqIGBub3RpZmllcmAsIGVtaXRzIHNvbWV0aGluZy4gVGhlbiwgaXQgY29tcGxldGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rha2VVbnRpbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGFrZVVudGlsYCBzdWJzY3JpYmVzIGFuZCBiZWdpbnMgbWlycm9yaW5nIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSXQgYWxzb1xuICogbW9uaXRvcnMgYSBzZWNvbmQgT2JzZXJ2YWJsZSwgYG5vdGlmaWVyYCB0aGF0IHlvdSBwcm92aWRlLiBJZiB0aGUgYG5vdGlmaWVyYFxuICogZW1pdHMgYSB2YWx1ZSBvciBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHN0b3BzXG4gKiBtaXJyb3JpbmcgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFuZCBjb21wbGV0ZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VGljayBldmVyeSBzZWNvbmQgdW50aWwgdGhlIGZpcnN0IGNsaWNrIGhhcHBlbnM8L2NhcHRpb24+XG4gKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBpbnRlcnZhbC50YWtlVW50aWwoY2xpY2tzKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICogQHNlZSB7QGxpbmsgdGFrZVdoaWxlfVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IG5vdGlmaWVyIFRoZSBPYnNlcnZhYmxlIHdob3NlIGZpcnN0IGVtaXR0ZWQgdmFsdWUgd2lsbFxuICogY2F1c2UgdGhlIG91dHB1dCBPYnNlcnZhYmxlIG9mIGB0YWtlVW50aWxgIHRvIHN0b3AgZW1pdHRpbmcgdmFsdWVzIGZyb20gdGhlXG4gKiBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgdmFsdWVzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSB1bnRpbCBzdWNoIHRpbWUgYXMgYG5vdGlmaWVyYCBlbWl0cyBpdHMgZmlyc3QgdmFsdWUuXG4gKiBAbWV0aG9kIHRha2VVbnRpbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gdGFrZVVudGlsKG5vdGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGFrZVVudGlsT3BlcmF0b3Iobm90aWZpZXIpKTtcbn1cbmV4cG9ydHMudGFrZVVudGlsID0gdGFrZVVudGlsO1xudmFyIFRha2VVbnRpbE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWtlVW50aWxPcGVyYXRvcihub3RpZmllcikge1xuICAgICAgICB0aGlzLm5vdGlmaWVyID0gbm90aWZpZXI7XG4gICAgfVxuICAgIFRha2VVbnRpbE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVVudGlsU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5vdGlmaWVyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVVudGlsT3BlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBUYWtlVW50aWxTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGFrZVVudGlsU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWtlVW50aWxTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBub3RpZmllcikge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMubm90aWZpZXIgPSBub3RpZmllcjtcbiAgICAgICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBub3RpZmllcikpO1xuICAgIH1cbiAgICBUYWtlVW50aWxTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICB9O1xuICAgIFRha2VVbnRpbFN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBub29wXG4gICAgfTtcbiAgICByZXR1cm4gVGFrZVVudGlsU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlVW50aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgYXN5bmNfMSA9IHJlcXVpcmUoJy4uL3NjaGVkdWxlci9hc3luYycpO1xuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGVuIGlnbm9yZXMgc3Vic2VxdWVudCBzb3VyY2VcbiAqIHZhbHVlcyBmb3IgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMsIHRoZW4gcmVwZWF0cyB0aGlzIHByb2Nlc3MuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxldHMgYSB2YWx1ZSBwYXNzLCB0aGVuIGlnbm9yZXMgc291cmNlIHZhbHVlcyBmb3IgdGhlXG4gKiBuZXh0IGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rocm90dGxlVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGhyb3R0bGVUaW1lYCBlbWl0cyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZVxuICogd2hlbiBpdHMgaW50ZXJuYWwgdGltZXIgaXMgZGlzYWJsZWQsIGFuZCBpZ25vcmVzIHNvdXJjZSB2YWx1ZXMgd2hlbiB0aGUgdGltZXJcbiAqIGlzIGVuYWJsZWQuIEluaXRpYWxseSwgdGhlIHRpbWVyIGlzIGRpc2FibGVkLiBBcyBzb29uIGFzIHRoZSBmaXJzdCBzb3VyY2VcbiAqIHZhbHVlIGFycml2ZXMsIGl0IGlzIGZvcndhcmRlZCB0byB0aGUgb3V0cHV0IE9ic2VydmFibGUsIGFuZCB0aGVuIHRoZSB0aW1lclxuICogaXMgZW5hYmxlZC4gQWZ0ZXIgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMgKG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZFxuICogaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmApIGhhcyBwYXNzZWQsIHRoZSB0aW1lciBpcyBkaXNhYmxlZCxcbiAqIGFuZCB0aGlzIHByb2Nlc3MgcmVwZWF0cyBmb3IgdGhlIG5leHQgc291cmNlIHZhbHVlLiBPcHRpb25hbGx5IHRha2VzIGFcbiAqIHtAbGluayBJU2NoZWR1bGVyfSBmb3IgbWFuYWdpbmcgdGltZXJzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2tzIGF0IGEgcmF0ZSBvZiBhdCBtb3N0IG9uZSBjbGljayBwZXIgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MudGhyb3R0bGVUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gVGltZSB0byB3YWl0IGJlZm9yZSBlbWl0dGluZyBhbm90aGVyIHZhbHVlIGFmdGVyXG4gKiBlbWl0dGluZyB0aGUgbGFzdCB2YWx1ZSwgbWVhc3VyZWQgaW4gbWlsbGlzZWNvbmRzIG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZFxuICogaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmAuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSBzYW1wbGluZy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBwZXJmb3JtcyB0aGUgdGhyb3R0bGUgb3BlcmF0aW9uIHRvXG4gKiBsaW1pdCB0aGUgcmF0ZSBvZiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlLlxuICogQG1ldGhvZCB0aHJvdHRsZVRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlVGltZShkdXJhdGlvbiwgc2NoZWR1bGVyKSB7XG4gICAgaWYgKHNjaGVkdWxlciA9PT0gdm9pZCAwKSB7IHNjaGVkdWxlciA9IGFzeW5jXzEuYXN5bmM7IH1cbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUaHJvdHRsZVRpbWVPcGVyYXRvcihkdXJhdGlvbiwgc2NoZWR1bGVyKSk7XG59XG5leHBvcnRzLnRocm90dGxlVGltZSA9IHRocm90dGxlVGltZTtcbnZhciBUaHJvdHRsZVRpbWVPcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGhyb3R0bGVUaW1lT3BlcmF0b3IoZHVyYXRpb24sIHNjaGVkdWxlcikge1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBUaHJvdHRsZVRpbWVPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRocm90dGxlVGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kdXJhdGlvbiwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgICB9O1xuICAgIHJldHVybiBUaHJvdHRsZVRpbWVPcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFRocm90dGxlVGltZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaHJvdHRsZVRpbWVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRocm90dGxlVGltZVN1YnNjcmliZXIoZGVzdGluYXRpb24sIGR1cmF0aW9uLCBzY2hlZHVsZXIpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgIH1cbiAgICBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMudGhyb3R0bGVkKSB7XG4gICAgICAgICAgICB0aGlzLmFkZCh0aGlzLnRocm90dGxlZCA9IHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgdGhpcy5kdXJhdGlvbiwgeyBzdWJzY3JpYmVyOiB0aGlzIH0pKTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRocm90dGxlVGltZVN1YnNjcmliZXIucHJvdG90eXBlLmNsZWFyVGhyb3R0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aHJvdHRsZWQgPSB0aGlzLnRocm90dGxlZDtcbiAgICAgICAgaWYgKHRocm90dGxlZCkge1xuICAgICAgICAgICAgdGhyb3R0bGVkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSh0aHJvdHRsZWQpO1xuICAgICAgICAgICAgdGhpcy50aHJvdHRsZWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gVGhyb3R0bGVUaW1lU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcl8xLlN1YnNjcmliZXIpKTtcbmZ1bmN0aW9uIGRpc3BhdGNoTmV4dChhcmcpIHtcbiAgICB2YXIgc3Vic2NyaWJlciA9IGFyZy5zdWJzY3JpYmVyO1xuICAgIHN1YnNjcmliZXIuY2xlYXJUaHJvdHRsZSgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGhyb3R0bGVUaW1lLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn07XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ29tYmluZXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggb3RoZXIgT2JzZXJ2YWJsZXMgdG8gY3JlYXRlIGFuIE9ic2VydmFibGVcbiAqIHdob3NlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBsYXRlc3QgdmFsdWVzIG9mIGVhY2gsIG9ubHkgd2hlbiB0aGVcbiAqIHNvdXJjZSBlbWl0cy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+V2hlbmV2ZXIgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUsIGl0XG4gKiBjb21wdXRlcyBhIGZvcm11bGEgdXNpbmcgdGhhdCB2YWx1ZSBwbHVzIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gb3RoZXIgaW5wdXRcbiAqIE9ic2VydmFibGVzLCB0aGVuIGVtaXRzIHRoZSBvdXRwdXQgb2YgdGhhdCBmb3JtdWxhLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3dpdGhMYXRlc3RGcm9tLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB3aXRoTGF0ZXN0RnJvbWAgY29tYmluZXMgZWFjaCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSAodGhlXG4gKiBpbnN0YW5jZSkgd2l0aCB0aGUgbGF0ZXN0IHZhbHVlcyBmcm9tIHRoZSBvdGhlciBpbnB1dCBPYnNlcnZhYmxlcyBvbmx5IHdoZW5cbiAqIHRoZSBzb3VyY2UgZW1pdHMgYSB2YWx1ZSwgb3B0aW9uYWxseSB1c2luZyBhIGBwcm9qZWN0YCBmdW5jdGlvbiB0byBkZXRlcm1pbmVcbiAqIHRoZSB2YWx1ZSB0byBiZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gQWxsIGlucHV0IE9ic2VydmFibGVzIG11c3RcbiAqIGVtaXQgYXQgbGVhc3Qgb25lIHZhbHVlIGJlZm9yZSB0aGUgb3V0cHV0IE9ic2VydmFibGUgd2lsbCBlbWl0IGEgdmFsdWUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+T24gZXZlcnkgY2xpY2sgZXZlbnQsIGVtaXQgYW4gYXJyYXkgd2l0aCB0aGUgbGF0ZXN0IHRpbWVyIGV2ZW50IHBsdXMgdGhlIGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLndpdGhMYXRlc3RGcm9tKHRpbWVyKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUxhdGVzdH1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gb3RoZXIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBjb21iaW5lIHdpdGggdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvamVjdF0gUHJvamVjdGlvbiBmdW5jdGlvbiBmb3IgY29tYmluaW5nIHZhbHVlc1xuICogdG9nZXRoZXIuIFJlY2VpdmVzIGFsbCB2YWx1ZXMgaW4gb3JkZXIgb2YgdGhlIE9ic2VydmFibGVzIHBhc3NlZCwgd2hlcmUgdGhlXG4gKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gKGUuZy5cbiAqIGBhLndpdGhMYXRlc3RGcm9tKGIsIGMsIChhMSwgYjEsIGMxKSA9PiBhMSArIGIxICsgYzEpYCkuIElmIHRoaXMgaXMgbm90XG4gKiBwYXNzZWQsIGFycmF5cyB3aWxsIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBwcm9qZWN0ZWQgdmFsdWVzIGZyb20gdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZXMgZnJvbSBlYWNoIGlucHV0IE9ic2VydmFibGUsIG9yIGFuIGFycmF5IG9mIHRoZSBtb3N0IHJlY2VudCB2YWx1ZXMgZnJvbVxuICogZWFjaCBpbnB1dCBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCB3aXRoTGF0ZXN0RnJvbVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gd2l0aExhdGVzdEZyb20oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcHJvamVjdDtcbiAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9qZWN0ID0gYXJncy5wb3AoKTtcbiAgICB9XG4gICAgdmFyIG9ic2VydmFibGVzID0gYXJncztcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBXaXRoTGF0ZXN0RnJvbU9wZXJhdG9yKG9ic2VydmFibGVzLCBwcm9qZWN0KSk7XG59XG5leHBvcnRzLndpdGhMYXRlc3RGcm9tID0gd2l0aExhdGVzdEZyb207XG52YXIgV2l0aExhdGVzdEZyb21PcGVyYXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2l0aExhdGVzdEZyb21PcGVyYXRvcihvYnNlcnZhYmxlcywgcHJvamVjdCkge1xuICAgICAgICB0aGlzLm9ic2VydmFibGVzID0gb2JzZXJ2YWJsZXM7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgfVxuICAgIFdpdGhMYXRlc3RGcm9tT3BlcmF0b3IucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoc3Vic2NyaWJlciwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5vYnNlcnZhYmxlcywgdGhpcy5wcm9qZWN0KSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2l0aExhdGVzdEZyb21PcGVyYXRvcjtcbn0oKSk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIoZGVzdGluYXRpb24sIG9ic2VydmFibGVzLCBwcm9qZWN0KSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlcyA9IG9ic2VydmFibGVzO1xuICAgICAgICB0aGlzLnByb2plY3QgPSBwcm9qZWN0O1xuICAgICAgICB0aGlzLnRvUmVzcG9uZCA9IFtdO1xuICAgICAgICB2YXIgbGVuID0gb2JzZXJ2YWJsZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnRvUmVzcG9uZC5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvYnNlcnZhYmxlID0gb2JzZXJ2YWJsZXNbaV07XG4gICAgICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdF8xLnN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG9ic2VydmFibGUsIG9ic2VydmFibGUsIGkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXIucHJvdG90eXBlLm5vdGlmeU5leHQgPSBmdW5jdGlvbiAob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCwgaW5uZXJTdWIpIHtcbiAgICAgICAgdGhpcy52YWx1ZXNbb3V0ZXJJbmRleF0gPSBpbm5lclZhbHVlO1xuICAgICAgICB2YXIgdG9SZXNwb25kID0gdGhpcy50b1Jlc3BvbmQ7XG4gICAgICAgIGlmICh0b1Jlc3BvbmQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gdG9SZXNwb25kLmluZGV4T2Yob3V0ZXJJbmRleCk7XG4gICAgICAgICAgICBpZiAoZm91bmQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdG9SZXNwb25kLnNwbGljZShmb3VuZCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9O1xuICAgIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudG9SZXNwb25kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbdmFsdWVdLmNvbmNhdCh0aGlzLnZhbHVlcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9qZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdHJ5UHJvamVjdChhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJvamVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFdpdGhMYXRlc3RGcm9tU3Vic2NyaWJlcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aXRoTGF0ZXN0RnJvbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xudmFyIEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZSgnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnKTtcbnZhciBpc0FycmF5XzEgPSByZXF1aXJlKCcuLi91dGlsL2lzQXJyYXknKTtcbnZhciBTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9TdWJzY3JpYmVyJyk7XG52YXIgT3V0ZXJTdWJzY3JpYmVyXzEgPSByZXF1aXJlKCcuLi9PdXRlclN1YnNjcmliZXInKTtcbnZhciBzdWJzY3JpYmVUb1Jlc3VsdF8xID0gcmVxdWlyZSgnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCcpO1xudmFyIGl0ZXJhdG9yXzEgPSByZXF1aXJlKCcuLi9zeW1ib2wvaXRlcmF0b3InKTtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4vKipcbiAqIEBwYXJhbSBvYnNlcnZhYmxlc1xuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn1cbiAqIEBtZXRob2QgemlwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5mdW5jdGlvbiB6aXBQcm90bygpIHtcbiAgICB2YXIgb2JzZXJ2YWJsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBvYnNlcnZhYmxlc1tfaSAtIDBdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKHppcFN0YXRpYy5hcHBseSh2b2lkIDAsIFt0aGlzXS5jb25jYXQob2JzZXJ2YWJsZXMpKSk7XG59XG5leHBvcnRzLnppcFByb3RvID0gemlwUHJvdG87XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0byBjcmVhdGUgYW4gT2JzZXJ2YWJsZSB3aG9zZSB2YWx1ZXMgYXJlIGNhbGN1bGF0ZWQgZnJvbSB0aGUgdmFsdWVzLCBpbiBvcmRlciwgb2YgZWFjaFxuICogb2YgaXRzIGlucHV0IE9ic2VydmFibGVzLlxuICpcbiAqIElmIHRoZSBsYXRlc3QgcGFyYW1ldGVyIGlzIGEgZnVuY3Rpb24sIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjb21wdXRlIHRoZSBjcmVhdGVkIHZhbHVlIGZyb20gdGhlIGlucHV0IHZhbHVlcy5cbiAqIE90aGVyd2lzZSwgYW4gYXJyYXkgb2YgdGhlIGlucHV0IHZhbHVlcyBpcyByZXR1cm5lZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db21iaW5lIGFnZSBhbmQgbmFtZSBmcm9tIGRpZmZlcmVudCBzb3VyY2VzPC9jYXB0aW9uPlxuICpcbiAqIGxldCBhZ2UkID0gT2JzZXJ2YWJsZS5vZjxudW1iZXI+KDI3LCAyNSwgMjkpO1xuICogbGV0IG5hbWUkID0gT2JzZXJ2YWJsZS5vZjxzdHJpbmc+KCdGb28nLCAnQmFyJywgJ0JlZXInKTtcbiAqIGxldCBpc0RldiQgPSBPYnNlcnZhYmxlLm9mPGJvb2xlYW4+KHRydWUsIHRydWUsIGZhbHNlKTtcbiAqXG4gKiBPYnNlcnZhYmxlXG4gKiAgICAgLnppcChhZ2UkLFxuICogICAgICAgICAgbmFtZSQsXG4gKiAgICAgICAgICBpc0RldiQsXG4gKiAgICAgICAgICAoYWdlOiBudW1iZXIsIG5hbWU6IHN0cmluZywgaXNEZXY6IGJvb2xlYW4pID0+ICh7IGFnZSwgbmFtZSwgaXNEZXYgfSkpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBvdXRwdXRzXG4gKiAvLyB7IGFnZTogMjcsIG5hbWU6ICdGb28nLCBpc0RldjogdHJ1ZSB9XG4gKiAvLyB7IGFnZTogMjUsIG5hbWU6ICdCYXInLCBpc0RldjogdHJ1ZSB9XG4gKiAvLyB7IGFnZTogMjksIG5hbWU6ICdCZWVyJywgaXNEZXY6IGZhbHNlIH1cbiAqXG4gKiBAcGFyYW0gb2JzZXJ2YWJsZXNcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59XG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIHppcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZnVuY3Rpb24gemlwU3RhdGljKCkge1xuICAgIHZhciBvYnNlcnZhYmxlcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9ic2VydmFibGVzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgcHJvamVjdCA9IG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdO1xuICAgIGlmICh0eXBlb2YgcHJvamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYnNlcnZhYmxlcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGVfMS5BcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMpLmxpZnQobmV3IFppcE9wZXJhdG9yKHByb2plY3QpKTtcbn1cbmV4cG9ydHMuemlwU3RhdGljID0gemlwU3RhdGljO1xudmFyIFppcE9wZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBaaXBPcGVyYXRvcihwcm9qZWN0KSB7XG4gICAgICAgIHRoaXMucHJvamVjdCA9IHByb2plY3Q7XG4gICAgfVxuICAgIFppcE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgWmlwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QpKTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBPcGVyYXRvcjtcbn0oKSk7XG5leHBvcnRzLlppcE9wZXJhdG9yID0gWmlwT3BlcmF0b3I7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIFppcFN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhaaXBTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFppcFN1YnNjcmliZXIoZGVzdGluYXRpb24sIHByb2plY3QsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgfVxuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbik7XG4gICAgICAgIHRoaXMuaXRlcmF0b3JzID0gW107XG4gICAgICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gKHR5cGVvZiBwcm9qZWN0ID09PSAnZnVuY3Rpb24nKSA/IHByb2plY3QgOiBudWxsO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuX25leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9ycyA9IHRoaXMuaXRlcmF0b3JzO1xuICAgICAgICBpZiAoaXNBcnJheV8xLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljQXJyYXlJdGVyYXRvcih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZVtpdGVyYXRvcl8xLiQkaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljSXRlcmF0b3IodmFsdWVbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSgpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVyYXRvcnMucHVzaChuZXcgWmlwQnVmZmVySXRlcmF0b3IodGhpcy5kZXN0aW5hdGlvbiwgdGhpcywgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwU3Vic2NyaWJlci5wcm90b3R5cGUuX2NvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgICAgIHZhciBsZW4gPSBpdGVyYXRvcnMubGVuZ3RoO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IGxlbjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLnN0aWxsVW5zdWJzY3JpYmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaXRlcmF0b3Iuc3Vic2NyaWJlKGl0ZXJhdG9yLCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZS0tOyAvLyBub3QgYW4gb2JzZXJ2YWJsZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5ub3RpZnlJbmFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmUtLTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcFN1YnNjcmliZXIucHJvdG90eXBlLmNoZWNrSXRlcmF0b3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgICAgIHZhciBsZW4gPSBpdGVyYXRvcnMubGVuZ3RoO1xuICAgICAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgICAgICAvLyBhYm9ydCBpZiBub3QgYWxsIG9mIHRoZW0gaGF2ZSB2YWx1ZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci5oYXNWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXRlcmF0b3IuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvdWxkQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JzW2ldO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBpdCdzIGNvbXBsZXRlZCBub3cgdGhhdCB5b3UndmUgZ290dGVuXG4gICAgICAgICAgICAvLyB0aGUgbmV4dCB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChpdGVyYXRvci5oYXNDb21wbGV0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHNob3VsZENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJncy5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvamVjdCkge1xuICAgICAgICAgICAgdGhpcy5fdHJ5UHJvamVjdChhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uLm5leHQoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZENvbXBsZXRlKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBaaXBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdHJ5UHJvamVjdCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIFppcFN1YnNjcmliZXI7XG59KFN1YnNjcmliZXJfMS5TdWJzY3JpYmVyKSk7XG5leHBvcnRzLlppcFN1YnNjcmliZXIgPSBaaXBTdWJzY3JpYmVyO1xudmFyIFN0YXRpY0l0ZXJhdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0aWNJdGVyYXRvcihpdGVyYXRvcikge1xuICAgICAgICB0aGlzLml0ZXJhdG9yID0gaXRlcmF0b3I7XG4gICAgICAgIHRoaXMubmV4dFJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICB9XG4gICAgU3RhdGljSXRlcmF0b3IucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICB0aGlzLm5leHRSZXN1bHQgPSB0aGlzLml0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFN0YXRpY0l0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0UmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgICAgICByZXR1cm4gbmV4dFJlc3VsdCAmJiBuZXh0UmVzdWx0LmRvbmU7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGljSXRlcmF0b3I7XG59KCkpO1xudmFyIFN0YXRpY0FycmF5SXRlcmF0b3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRpY0FycmF5SXRlcmF0b3IoYXJyYXkpIHtcbiAgICAgICAgdGhpcy5hcnJheSA9IGFycmF5O1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICB9XG4gICAgU3RhdGljQXJyYXlJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleCsrO1xuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICByZXR1cm4gaSA8IHRoaXMubGVuZ3RoID8geyB2YWx1ZTogYXJyYXlbaV0sIGRvbmU6IGZhbHNlIH0gOiB7IHZhbHVlOiBudWxsLCBkb25lOiB0cnVlIH07XG4gICAgfTtcbiAgICBTdGF0aWNBcnJheUl0ZXJhdG9yLnByb3RvdHlwZS5oYXNWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoID4gdGhpcy5pbmRleDtcbiAgICB9O1xuICAgIFN0YXRpY0FycmF5SXRlcmF0b3IucHJvdG90eXBlLmhhc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoID09PSB0aGlzLmluZGV4O1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRpY0FycmF5SXRlcmF0b3I7XG59KCkpO1xuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbnZhciBaaXBCdWZmZXJJdGVyYXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFppcEJ1ZmZlckl0ZXJhdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFppcEJ1ZmZlckl0ZXJhdG9yKGRlc3RpbmF0aW9uLCBwYXJlbnQsIG9ic2VydmFibGUpIHtcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5vYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcbiAgICAgICAgdGhpcy5zdGlsbFVuc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGVbaXRlcmF0b3JfMS4kJGl0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvLyBOT1RFOiB0aGVyZSBpcyBhY3R1YWxseSBhIG5hbWUgY29sbGlzaW9uIGhlcmUgd2l0aCBTdWJzY3JpYmVyLm5leHQgYW5kIEl0ZXJhdG9yLm5leHRcbiAgICAvLyAgICB0aGlzIGlzIGxlZ2l0IGJlY2F1c2UgYG5leHQoKWAgd2lsbCBuZXZlciBiZSBjYWxsZWQgYnkgYSBzdWJzY3JpcHRpb24gaW4gdGhpcyBjYXNlLlxuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwICYmIHRoaXMuaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG51bGwsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBidWZmZXIuc2hpZnQoKSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLmhhc1ZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5oYXNDb21wbGV0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDAgJiYgdGhpcy5pc0NvbXBsZXRlO1xuICAgIH07XG4gICAgWmlwQnVmZmVySXRlcmF0b3IucHJvdG90eXBlLm5vdGlmeUNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5pc0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Lm5vdGlmeUluYWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFppcEJ1ZmZlckl0ZXJhdG9yLnByb3RvdHlwZS5ub3RpZnlOZXh0ID0gZnVuY3Rpb24gKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgsIGlubmVyU3ViKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goaW5uZXJWYWx1ZSk7XG4gICAgICAgIHRoaXMucGFyZW50LmNoZWNrSXRlcmF0b3JzKCk7XG4gICAgfTtcbiAgICBaaXBCdWZmZXJJdGVyYXRvci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlVG9SZXN1bHRfMS5zdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCB0aGlzLm9ic2VydmFibGUsIHRoaXMsIGluZGV4KTtcbiAgICB9O1xuICAgIHJldHVybiBaaXBCdWZmZXJJdGVyYXRvcjtcbn0oT3V0ZXJTdWJzY3JpYmVyXzEuT3V0ZXJTdWJzY3JpYmVyKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD16aXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTdWJzY3JpcHRpb25fMSA9IHJlcXVpcmUoJy4uL1N1YnNjcmlwdGlvbicpO1xuLyoqXG4gKiBBIHVuaXQgb2Ygd29yayB0byBiZSBleGVjdXRlZCBpbiBhIHtAbGluayBTY2hlZHVsZXJ9LiBBbiBhY3Rpb24gaXMgdHlwaWNhbGx5XG4gKiBjcmVhdGVkIGZyb20gd2l0aGluIGEgU2NoZWR1bGVyIGFuZCBhbiBSeEpTIHVzZXIgZG9lcyBub3QgbmVlZCB0byBjb25jZXJuXG4gKiB0aGVtc2VsdmVzIGFib3V0IGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgYW4gQWN0aW9uLlxuICpcbiAqIGBgYHRzXG4gKiBjbGFzcyBBY3Rpb248VD4gZXh0ZW5kcyBTdWJzY3JpcHRpb24ge1xuICogICBuZXcgKHNjaGVkdWxlcjogU2NoZWR1bGVyLCB3b3JrOiAoc3RhdGU/OiBUKSA9PiB2b2lkKTtcbiAqICAgc2NoZWR1bGUoc3RhdGU/OiBULCBkZWxheTogbnVtYmVyID0gMCk6IFN1YnNjcmlwdGlvbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBjbGFzcyBBY3Rpb248VD5cbiAqL1xudmFyIEFjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgdGhpcyBhY3Rpb24gb24gaXRzIHBhcmVudCBTY2hlZHVsZXIgZm9yIGV4ZWN1dGlvbi4gTWF5IGJlIHBhc3NlZFxuICAgICAqIHNvbWUgY29udGV4dCBvYmplY3QsIGBzdGF0ZWAuIE1heSBoYXBwZW4gYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLFxuICAgICAqIGFjY29yZGluZyB0byB0aGUgYGRlbGF5YCBwYXJhbWV0ZXIsIGlmIHNwZWNpZmllZC5cbiAgICAgKiBAcGFyYW0ge1R9IFtzdGF0ZV0gU29tZSBjb250ZXh0dWFsIGRhdGEgdGhhdCB0aGUgYHdvcmtgIGZ1bmN0aW9uIHVzZXMgd2hlblxuICAgICAqIGNhbGxlZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVsYXldIFRpbWUgdG8gd2FpdCBiZWZvcmUgZXhlY3V0aW5nIHRoZSB3b3JrLCB3aGVyZSB0aGVcbiAgICAgKiB0aW1lIHVuaXQgaXMgaW1wbGljaXQgYW5kIGRlZmluZWQgYnkgdGhlIFNjaGVkdWxlci5cbiAgICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgICAqL1xuICAgIEFjdGlvbi5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAoc3RhdGUsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBBY3Rpb247XG59KFN1YnNjcmlwdGlvbl8xLlN1YnNjcmlwdGlvbikpO1xuZXhwb3J0cy5BY3Rpb24gPSBBY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciByb290XzEgPSByZXF1aXJlKCcuLi91dGlsL3Jvb3QnKTtcbnZhciBBY3Rpb25fMSA9IHJlcXVpcmUoJy4vQWN0aW9uJyk7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xudmFyIEFzeW5jQWN0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXN5bmNBY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXN5bmNBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHNjaGVkdWxlciwgd29yayk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVyID0gc2NoZWR1bGVyO1xuICAgICAgICB0aGlzLndvcmsgPSB3b3JrO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHdheXMgcmVwbGFjZSB0aGUgY3VycmVudCBzdGF0ZSB3aXRoIHRoZSBuZXcgc3RhdGUuXG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgLy8gU2V0IHRoZSBwZW5kaW5nIGZsYWcgaW5kaWNhdGluZyB0aGF0IHRoaXMgYWN0aW9uIGhhcyBiZWVuIHNjaGVkdWxlZCwgb3JcbiAgICAgICAgLy8gaGFzIHJlY3Vyc2l2ZWx5IHJlc2NoZWR1bGVkIGl0c2VsZi5cbiAgICAgICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICAvL1xuICAgICAgICAvLyBJbXBvcnRhbnQgaW1wbGVtZW50YXRpb24gbm90ZTpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gQWN0aW9ucyBvbmx5IGV4ZWN1dGUgb25jZSBieSBkZWZhdWx0LCB1bmxlc3MgcmVzY2hlZHVsZWQgZnJvbSB3aXRoaW4gdGhlXG4gICAgICAgIC8vIHNjaGVkdWxlZCBjYWxsYmFjay4gVGhpcyBhbGxvd3MgdXMgdG8gaW1wbGVtZW50IHNpbmdsZSBhbmQgcmVwZWF0XG4gICAgICAgIC8vIGFjdGlvbnMgdmlhIHRoZSBzYW1lIGNvZGUgcGF0aCwgd2l0aG91dCBhZGRpbmcgQVBJIHN1cmZhY2UgYXJlYSwgYXMgd2VsbFxuICAgICAgICAvLyBhcyBtaW1pYyB0cmFkaXRpb25hbCByZWN1cnNpb24gYnV0IGFjcm9zcyBhc3luY2hyb25vdXMgYm91bmRhcmllcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSG93ZXZlciwgSlMgcnVudGltZXMgYW5kIHRpbWVycyBkaXN0aW5ndWlzaCBiZXR3ZWVuIGludGVydmFscyBhY2hpZXZlZCBieVxuICAgICAgICAvLyBzZXJpYWwgYHNldFRpbWVvdXRgIGNhbGxzIHZzLiBhIHNpbmdsZSBgc2V0SW50ZXJ2YWxgIGNhbGwuIEFuIGludGVydmFsIG9mXG4gICAgICAgIC8vIHNlcmlhbCBgc2V0VGltZW91dGAgY2FsbHMgY2FuIGJlIGluZGl2aWR1YWxseSBkZWxheWVkLCB3aGljaCBkZWxheXNcbiAgICAgICAgLy8gc2NoZWR1bGluZyB0aGUgbmV4dCBgc2V0VGltZW91dGAsIGFuZCBzbyBvbi4gYHNldEludGVydmFsYCBhdHRlbXB0cyB0b1xuICAgICAgICAvLyBndWFyYW50ZWUgdGhlIGludGVydmFsIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCBtb3JlIHByZWNpc2VseSB0byB0aGVcbiAgICAgICAgLy8gaW50ZXJ2YWwgcGVyaW9kLCByZWdhcmRsZXNzIG9mIGxvYWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgd2UgdXNlIGBzZXRJbnRlcnZhbGAgdG8gc2NoZWR1bGUgc2luZ2xlIGFuZCByZXBlYXQgYWN0aW9ucy5cbiAgICAgICAgLy8gSWYgdGhlIGFjdGlvbiByZXNjaGVkdWxlcyBpdHNlbGYgd2l0aCB0aGUgc2FtZSBkZWxheSwgdGhlIGludGVydmFsIGlzIG5vdFxuICAgICAgICAvLyBjYW5jZWxlZC4gSWYgdGhlIGFjdGlvbiBkb2Vzbid0IHJlc2NoZWR1bGUsIG9yIHJlc2NoZWR1bGVzIHdpdGggYVxuICAgICAgICAvLyBkaWZmZXJlbnQgZGVsYXksIHRoZSBpbnRlcnZhbCB3aWxsIGJlIGNhbmNlbGVkIGFmdGVyIHNjaGVkdWxlZCBjYWxsYmFja1xuICAgICAgICAvLyBleGVjdXRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWxheSA9IGRlbGF5O1xuICAgICAgICAvLyBJZiB0aGlzIGFjdGlvbiBoYXMgYWxyZWFkeSBhbiBhc3luYyBJZCwgZG9uJ3QgcmVxdWVzdCBhIG5ldyBvbmUuXG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLmlkIHx8IHRoaXMucmVxdWVzdEFzeW5jSWQoc2NoZWR1bGVyLCB0aGlzLmlkLCBkZWxheSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gcm9vdF8xLnJvb3Quc2V0SW50ZXJ2YWwoc2NoZWR1bGVyLmZsdXNoLmJpbmQoc2NoZWR1bGVyLCB0aGlzKSwgZGVsYXkpO1xuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgaWQsIGRlbGF5KSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICAvLyBJZiB0aGlzIGFjdGlvbiBpcyByZXNjaGVkdWxlZCB3aXRoIHRoZSBzYW1lIGRlbGF5IHRpbWUsIGRvbid0IGNsZWFyIHRoZSBpbnRlcnZhbCBpZC5cbiAgICAgICAgaWYgKGRlbGF5ICE9PSBudWxsICYmIHRoaXMuZGVsYXkgPT09IGRlbGF5KSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGUgYWN0aW9uJ3MgZGVsYXkgdGltZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBkZWxheSxcbiAgICAgICAgLy8gY2xlYXIgdGhlIGludGVydmFsIGlkXG4gICAgICAgIHJldHVybiByb290XzEucm9vdC5jbGVhckludGVydmFsKGlkKSAmJiB1bmRlZmluZWQgfHwgdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSW1tZWRpYXRlbHkgZXhlY3V0ZXMgdGhpcyBhY3Rpb24gYW5kIHRoZSBgd29ya2AgaXQgY29udGFpbnMuXG4gICAgICogQHJldHVybiB7YW55fVxuICAgICAqL1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ2V4ZWN1dGluZyBhIGNhbmNlbGxlZCBhY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yID0gdGhpcy5fZXhlY3V0ZShzdGF0ZSwgZGVsYXkpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBlbmRpbmcgPT09IGZhbHNlICYmIHRoaXMuaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRGVxdWV1ZSBpZiB0aGUgYWN0aW9uIGRpZG4ndCByZXNjaGVkdWxlIGl0c2VsZi4gRG9uJ3QgY2FsbFxuICAgICAgICAgICAgLy8gdW5zdWJzY3JpYmUoKSwgYmVjYXVzZSB0aGUgYWN0aW9uIGNvdWxkIHJlc2NoZWR1bGUgbGF0ZXIuXG4gICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAgICAgICAgIC8vIGBgYFxuICAgICAgICAgICAgLy8gc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uIGRvV29yayhjb3VudGVyKSB7XG4gICAgICAgICAgICAvLyAgIC8qIC4uLiBJJ20gYSBidXN5IHdvcmtlciBiZWUgLi4uICovXG4gICAgICAgICAgICAvLyAgIHZhciBvcmlnaW5hbEFjdGlvbiA9IHRoaXM7XG4gICAgICAgICAgICAvLyAgIC8qIHdhaXQgMTAwbXMgYmVmb3JlIHJlc2NoZWR1bGluZyB0aGUgYWN0aW9uICovXG4gICAgICAgICAgICAvLyAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gICAgIG9yaWdpbmFsQWN0aW9uLnNjaGVkdWxlKGNvdW50ZXIgKyAxKTtcbiAgICAgICAgICAgIC8vICAgfSwgMTAwKTtcbiAgICAgICAgICAgIC8vIH0sIDEwMDApO1xuICAgICAgICAgICAgLy8gYGBgXG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZCh0aGlzLnNjaGVkdWxlciwgdGhpcy5pZCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgdmFyIGVycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndvcmsoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVycm9yVmFsdWUgPSAhIWUgJiYgZSB8fCBuZXcgRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yZWQpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvclZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmlkO1xuICAgICAgICB2YXIgc2NoZWR1bGVyID0gdGhpcy5zY2hlZHVsZXI7XG4gICAgICAgIHZhciBhY3Rpb25zID0gc2NoZWR1bGVyLmFjdGlvbnM7XG4gICAgICAgIHZhciBpbmRleCA9IGFjdGlvbnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgdGhpcy53b3JrID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWxheSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zY2hlZHVsZXIgPSBudWxsO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIG51bGwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNBY3Rpb247XG59KEFjdGlvbl8xLkFjdGlvbikpO1xuZXhwb3J0cy5Bc3luY0FjdGlvbiA9IEFzeW5jQWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXN5bmNBY3Rpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbnZhciBTY2hlZHVsZXJfMSA9IHJlcXVpcmUoJy4uL1NjaGVkdWxlcicpO1xudmFyIEFzeW5jU2NoZWR1bGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXN5bmNTY2hlZHVsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXN5bmNTY2hlZHVsZXIoKSB7XG4gICAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBTY2hlZHVsZXIgaXMgY3VycmVudGx5IGV4ZWN1dGluZyBhIGJhdGNoIG9mXG4gICAgICAgICAqIHF1ZXVlZCBhY3Rpb25zLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBpbnRlcm5hbCBJRCB1c2VkIHRvIHRyYWNrIHRoZSBsYXRlc3QgYXN5bmNocm9ub3VzIHRhc2sgc3VjaCBhcyB0aG9zZVxuICAgICAgICAgKiBjb21pbmcgZnJvbSBgc2V0VGltZW91dGAsIGBzZXRJbnRlcnZhbGAsIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLCBhbmRcbiAgICAgICAgICogb3RoZXJzLlxuICAgICAgICAgKiBAdHlwZSB7YW55fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIEFzeW5jU2NoZWR1bGVyLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9IGFjdGlvbi5leGVjdXRlKGFjdGlvbi5zdGF0ZSwgYWN0aW9uLmRlbGF5KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpOyAvLyBleGhhdXN0IHRoZSBzY2hlZHVsZXIgcXVldWVcbiAgICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB3aGlsZSAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jU2NoZWR1bGVyO1xufShTY2hlZHVsZXJfMS5TY2hlZHVsZXIpKTtcbmV4cG9ydHMuQXN5bmNTY2hlZHVsZXIgPSBBc3luY1NjaGVkdWxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzeW5jU2NoZWR1bGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xuZnVuY3Rpb24gc3ltYm9sSXRlcmF0b3JQb255ZmlsbChyb290KSB7XG4gICAgdmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICghU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICBTeW1ib2wuaXRlcmF0b3IgPSBTeW1ib2woJ2l0ZXJhdG9yIHBvbHlmaWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN5bWJvbC5pdGVyYXRvcjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFtmb3IgTW96aWxsYSBHZWNrbyAyNy0zNTpdKGh0dHBzOi8vbXpsLmxhLzJld0UxekMpXG4gICAgICAgIHZhciBTZXRfMSA9IHJvb3QuU2V0O1xuICAgICAgICBpZiAoU2V0XzEgJiYgdHlwZW9mIG5ldyBTZXRfMSgpWydAQGl0ZXJhdG9yJ10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiAnQEBpdGVyYXRvcic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIE1hcF8xID0gcm9vdC5NYXA7XG4gICAgICAgIC8vIHJlcXVpcmVkIGZvciBjb21wYXRhYmlsaXR5IHdpdGggZXM2LXNoaW1cbiAgICAgICAgaWYgKE1hcF8xKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE1hcF8xLnByb3RvdHlwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICAvLyBhY2NvcmRpbmcgdG8gc3BlYywgTWFwLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSBhbmQgTWFwLm9yb3RvdHlwZS5lbnRyaWVzIG11c3QgYmUgZXF1YWwuXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ2VudHJpZXMnICYmIGtleSAhPT0gJ3NpemUnICYmIE1hcF8xLnByb3RvdHlwZVtrZXldID09PSBNYXBfMS5wcm90b3R5cGVbJ2VudHJpZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ0BAaXRlcmF0b3InO1xuICAgIH1cbn1cbmV4cG9ydHMuc3ltYm9sSXRlcmF0b3JQb255ZmlsbCA9IHN5bWJvbEl0ZXJhdG9yUG9ueWZpbGw7XG5leHBvcnRzLiQkaXRlcmF0b3IgPSBzeW1ib2xJdGVyYXRvclBvbnlmaWxsKHJvb3RfMS5yb290KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWl0ZXJhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xuZnVuY3Rpb24gZ2V0U3ltYm9sT2JzZXJ2YWJsZShjb250ZXh0KSB7XG4gICAgdmFyICQkb2JzZXJ2YWJsZTtcbiAgICB2YXIgU3ltYm9sID0gY29udGV4dC5TeW1ib2w7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAkJG9ic2VydmFibGUgPSBTeW1ib2wub2JzZXJ2YWJsZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICQkb2JzZXJ2YWJsZSA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuICAgICAgICAgICAgU3ltYm9sLm9ic2VydmFibGUgPSAkJG9ic2VydmFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgICQkb2JzZXJ2YWJsZSA9ICdAQG9ic2VydmFibGUnO1xuICAgIH1cbiAgICByZXR1cm4gJCRvYnNlcnZhYmxlO1xufVxuZXhwb3J0cy5nZXRTeW1ib2xPYnNlcnZhYmxlID0gZ2V0U3ltYm9sT2JzZXJ2YWJsZTtcbmV4cG9ydHMuJCRvYnNlcnZhYmxlID0gZ2V0U3ltYm9sT2JzZXJ2YWJsZShyb290XzEucm9vdCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIHJvb3RfMSA9IHJlcXVpcmUoJy4uL3V0aWwvcm9vdCcpO1xudmFyIFN5bWJvbCA9IHJvb3RfMS5yb290LlN5bWJvbDtcbmV4cG9ydHMuJCRyeFN1YnNjcmliZXIgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgIFN5bWJvbC5mb3IoJ3J4U3Vic2NyaWJlcicpIDogJ0BAcnhTdWJzY3JpYmVyJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ4U3Vic2NyaWJlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhbiBlbGVtZW50IHdhcyBxdWVyaWVkIGF0IGEgY2VydGFpbiBpbmRleCBvZiBhblxuICogT2JzZXJ2YWJsZSwgYnV0IG5vIHN1Y2ggaW5kZXggb3IgcG9zaXRpb24gZXhpc3RzIGluIHRoYXQgc2VxdWVuY2UuXG4gKlxuICogQHNlZSB7QGxpbmsgZWxlbWVudEF0fVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICpcbiAqIEBjbGFzcyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvclxuICovXG52YXIgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBcmd1bWVudE91dE9mUmFuZ2VFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpIHtcbiAgICAgICAgdmFyIGVyciA9IF9zdXBlci5jYWxsKHRoaXMsICdhcmd1bWVudCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnQXJndW1lbnRPdXRPZlJhbmdlRXJyb3InO1xuICAgICAgICB0aGlzLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5Bcmd1bWVudE91dE9mUmFuZ2VFcnJvciA9IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJndW1lbnRPdXRPZlJhbmdlRXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufTtcbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gYW4gYWN0aW9uIGlzIGludmFsaWQgYmVjYXVzZSB0aGUgb2JqZWN0IGhhcyBiZWVuXG4gKiB1bnN1YnNjcmliZWQuXG4gKlxuICogQHNlZSB7QGxpbmsgU3ViamVjdH1cbiAqIEBzZWUge0BsaW5rIEJlaGF2aW9yU3ViamVjdH1cbiAqXG4gKiBAY2xhc3MgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JcbiAqL1xudmFyIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKSB7XG4gICAgICAgIHZhciBlcnIgPSBfc3VwZXIuY2FsbCh0aGlzLCAnb2JqZWN0IHVuc3Vic2NyaWJlZCcpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnIubmFtZSA9ICdPYmplY3RVbnN1YnNjcmliZWRFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLk9iamVjdFVuc3Vic2NyaWJlZEVycm9yID0gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1PYmplY3RVbnN1YnNjcmliZWRFcnJvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59O1xuLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBvbmUgb3IgbW9yZSBlcnJvcnMgaGF2ZSBvY2N1cnJlZCBkdXJpbmcgdGhlXG4gKiBgdW5zdWJzY3JpYmVgIG9mIGEge0BsaW5rIFN1YnNjcmlwdGlvbn0uXG4gKi9cbnZhciBVbnN1YnNjcmlwdGlvbkVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVW5zdWJzY3JpcHRpb25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycykge1xuICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIHZhciBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIGVycm9ycyA/XG4gICAgICAgICAgICBlcnJvcnMubGVuZ3RoICsgXCIgZXJyb3JzIG9jY3VycmVkIGR1cmluZyB1bnN1YnNjcmlwdGlvbjpcXG4gIFwiICsgZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyLCBpKSB7IHJldHVybiAoKGkgKyAxKSArIFwiKSBcIiArIGVyci50b1N0cmluZygpKTsgfSkuam9pbignXFxuICAnKSA6ICcnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZXJyLm5hbWUgPSAnVW5zdWJzY3JpcHRpb25FcnJvcic7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4gVW5zdWJzY3JpcHRpb25FcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuVW5zdWJzY3JpcHRpb25FcnJvciA9IFVuc3Vic2NyaXB0aW9uRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VbnN1YnNjcmlwdGlvbkVycm9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNPYmplY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIHdpbmRvdzogYnJvd3NlciBpbiBET00gbWFpbiB0aHJlYWRcbiAqIHNlbGY6IGJyb3dzZXIgaW4gV2ViV29ya2VyXG4gKiBnbG9iYWw6IE5vZGUuanMvb3RoZXJcbiAqL1xuZXhwb3J0cy5yb290ID0gKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93LndpbmRvdyA9PT0gd2luZG93ICYmIHdpbmRvd1xuICAgIHx8IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmXG4gICAgfHwgdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsKTtcbmlmICghZXhwb3J0cy5yb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSeEpTIGNvdWxkIG5vdCBmaW5kIGFueSBnbG9iYWwgY29udGV4dCAod2luZG93LCBzZWxmLCBnbG9iYWwpJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb290LmpzLm1hcCIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHVybCBpcyBleHRlcm5hbFxuICpcbiAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIHVybCAtIHVybCBiZWluZyBldmFsdWF0ZWRcbiAqIEBzZWUgICAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjIzODM1MS9mYXN0ZXN0LXdheS10by1kZXRlY3QtZXh0ZXJuYWwtdXJsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlcm5hbCh1cmwpIHtcbiAgY29uc3QgbWF0Y2ggPSB1cmwubWF0Y2goL14oW146XFwvPyNdKzopPyg/OlxcL1xcLyhbXlxcLz8jXSopKT8oW14/I10rKT8oXFw/W14jXSopPygjLiopPy8pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5cbiAgaWYgKHR5cGVvZiBtYXRjaFsxXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgIG1hdGNoWzFdLmxlbmd0aCA+IDAgJiZcbiAgICAgIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgIT09IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbFxuICAgICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgcG9ydCA9IHsgaHR0cDogODAsIGh0dHBzOiA0NDMgfVt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2xdO1xuXG4gIGlmICh0eXBlb2YgbWF0Y2hbMl0gPT09ICdzdHJpbmcnICYmXG4gICAgbWF0Y2hbMl0ubGVuZ3RoID4gMCAmJlxuICAgIG1hdGNoWzJdLnJlcGxhY2UobmV3IFJlZ0V4cChgOigke3BvcnR9KT8kYCksICcnKSAhPT0gd2luZG93LmxvY2F0aW9uLmhvc3QpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBTdHJpcHMgdGhlIGhhc2ggZnJvbSBhIHVybCBhbmQgcmV0dXJucyB0aGUgbmV3IGhyZWZcbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSAgICBocmVmIC0gdXJsIGJlaW5nIGV2YWx1YXRlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBIYXNoKGhyZWYpIHtcbiAgcmV0dXJuIGhyZWYucmVwbGFjZSgvIy4qLywgJycpO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHVybCBpcyBhbiBpbnRlcm5hbCBoYXNoXG4gKlxuICogQHBhcmFtICAge3N0cmluZ30gICAgaHJlZiAtIHVybCBiZWluZyBldmFsdWF0ZWRcbiAqIEBwYXJhbSAgIHtzdHJpbmd9ICAgIHByZXYgLSBwcmV2aW91cyB1cmwgKG9wdGlvbmFsKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNIYXNoKGhyZWYsIHByZXYpIHtcbiAgY29uc3QgcCA9IHByZXYgfHwgd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbiAgY29uc3QgaGFzSGFzaCA9IGhyZWYuaW5kZXhPZignIycpID4gLTE7XG4gIGNvbnN0IHNhbWVQYXRoID0gc3RyaXBIYXNoKGhyZWYpID09PSBzdHJpcEhhc2gocCk7XG5cbiAgcmV0dXJuIChoYXNIYXNoICYmIHNhbWVQYXRoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoZXMoZWwsIHNlbGVjdG9yKSB7XG4gIHJldHVybiAoZWwubWF0Y2hlcyB8fCBlbC5tYXRjaGVzU2VsZWN0b3IgfHwgZWwubXNNYXRjaGVzU2VsZWN0b3IgfHwgZWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgZWwud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm9NYXRjaGVzU2VsZWN0b3IpLmNhbGwoZWwsIHNlbGVjdG9yKTtcbiAgLy8gaWYgKCFtYXRjaGVzLm1lbW8pIHtcbiAgLy8gICBtYXRjaGVzLm1lbW8gPVxuICAvLyAgICAgZWwubWF0Y2hlcyB8fFxuICAvLyAgICAgZWwubWF0Y2hlc1NlbGVjdG9yIHx8XG4gIC8vICAgICBlbC5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAvLyAgICAgZWwubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gIC8vICAgICBlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcbiAgLy8gICAgIGVsLm9NYXRjaGVzU2VsZWN0b3I7XG4gIC8vIH1cbiAgLy8gcmV0dXJuIG1hdGNoZXMubWVtby5jYWxsKGVsLCBzZWxlY3Rvcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeVNlbGVjdG9ySW52KGVsLCBzZWxlY3Rvcikge1xuICBsZXQgY3VyciA9IGVsO1xuICB3aGlsZSAoY3VyciAhPT0gZG9jdW1lbnQgJiYgY3VyciAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgaWYgKG1hdGNoZXMoY3Vyciwgc2VsZWN0b3IpKSByZXR1cm4gY3VycjtcbiAgICBjdXJyID0gY3Vyci5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgd2Ugc2hvdWxkIGJlIGxvYWRpbmcgdGhpcyBVUkxcbiAqXG4gKiBAcGFyYW0gICB7c3RyaW5nfSAgICB1cmwgLSB1cmwgYmVpbmcgZXZhbHVhdGVkXG4gKiBAcGFyYW0gICB7c3RyaW5nfSAgICBibGFja2xpc3QgLSBqcXVlcnkgc2VsZWN0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZExvYWRBbmNob3IoYW5jaG9yLCBibGFja2xpc3QsIGhyZWZSZWdleCkge1xuICBjb25zdCBocmVmID0gYW5jaG9yLmhyZWY7XG4gIC8vIFVSTCB3aWxsIG9ubHkgYmUgbG9hZGVkIGlmIGl0J3Mgbm90IGFuIGV4dGVybmFsIGxpbmssIGhhc2gsIG9yXG4gIC8vIGJsYWNrbGlzdGVkXG4gIHJldHVybiAoXG4gICAgIWlzRXh0ZXJuYWwoaHJlZikgJiZcbiAgICAhaXNIYXNoKGhyZWYpICYmXG4gICAgIW1hdGNoZXMoYW5jaG9yLCBibGFja2xpc3QpICYmXG4gICAgYW5jaG9yLnRhcmdldCA9PT0gJycgJiYgKFxuICAgICAgaHJlZlJlZ2V4ID09PSBudWxsIHx8XG4gICAgICBocmVmLnNlYXJjaChocmVmUmVnZXgpICE9PSAtMVxuICAgIClcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbEhlaWdodCgpIHtcbiAgY29uc3QgaCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgY29uc3QgYiA9IGRvY3VtZW50LmJvZHk7XG4gIGNvbnN0IHNoID0gJ3Njcm9sbEhlaWdodCc7XG4gIHJldHVybiBoW3NoXSB8fCBiW3NoXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjcm9sbExlZnQoKSB7XG4gIHJldHVybiB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2Nyb2xsVG9wKCkge1xuICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhwSW50ZXJ2YWwoaW5pdCwgZXhwKSB7XG4gIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXIpID0+IHtcbiAgICBsZXQgbiA9IGluaXQ7XG4gICAgbGV0IGlkO1xuXG4gICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIG9ic2VydmVyLm5leHQobik7XG4gICAgICBuICo9IGV4cDtcbiAgICAgIGlkID0gc2V0VGltZW91dChuZXh0LCBuKTtcbiAgICB9XG5cbiAgICBpZCA9IHNldFRpbWVvdXQobmV4dCwgbik7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICB9O1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZyYWdtZW50RnJvbVN0cmluZyhzdHJIVE1MKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVSYW5nZSgpLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChzdHJIVE1MKTtcbn1cbiIsIi8qXG4gKiBBZGFwdGVkIGZyb20gTWlndWVsIMOBbmdlbCBQw6lyZXoncyBzbW9vdGhTdGF0ZS5qc1xuICogaHR0cHM6Ly9naXRodWIuY29tL21pZ3VlbC1wZXJlei9zbW9vdGhTdGF0ZS5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGbG9yaWFuIEtsYW1wZmVyXG4gKiBMaWNlbnNlZCB1bmRlciBNSVRcbiAqL1xuXG4vKlxuZXNsaW50LWRpc2FibGVcbmltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llcyxcbmltcG9ydC9uby11bnJlc29sdmVkLFxuaW1wb3J0L2V4dGVuc2lvbnMsXG5uby1jb25zb2xlXG4qL1xuXG4vLyBjb25zdCBKU19GRUFUVVJFUyA9IFtcbi8vICAgJ2ZuL2FycmF5L2Zvci1lYWNoJyxcbi8vICAgJ2ZuL2Z1bmN0aW9uL2JpbmQnLFxuLy8gICAnZm4vbnVtYmVyL2NvbnN0cnVjdG9yJyxcbi8vICAgJ2ZuL29iamVjdC9hc3NpZ24nLFxuLy8gICAnZm4vb2JqZWN0L2RlZmluZS1wcm9wZXJ0eScsXG4vLyAgICdmbi9vYmplY3Qva2V5cycsXG4vLyBdO1xuLy9cbi8vIGNvbnN0IE1PREVSTklaUl9URVNUUyA9IFtcbi8vICAgJ2N1c3RvbWV2ZW50Jyxcbi8vICAgJ2RvY3VtZW50ZnJhZ21lbnQnLFxuLy8gICAnZXZlbnRsaXN0ZW5lcicsXG4vLyAgICdoaXN0b3J5Jyxcbi8vICAgJ3JlcXVlc3RhbmltYXRpb25mcmFtZScsXG4vLyAgICdxdWVyeXNlbGVjdG9yJyxcbi8vIF07XG5cbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9kZWZlcic7XG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9tZXJnZSc7XG5pbXBvcnQgJ3J4anMvYWRkL29ic2VydmFibGUvb2YnO1xuaW1wb3J0ICdyeGpzL2FkZC9vYnNlcnZhYmxlL3Rocm93JztcbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS90aW1lcic7XG5cbmltcG9ydCAncnhqcy9hZGQvb2JzZXJ2YWJsZS9kb20vYWpheCc7XG5cbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvY2F0Y2gnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9kZWJvdW5jZVRpbWUnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9kZWxheSc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvZG8nO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9maWx0ZXInO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tYXAnO1xuaW1wb3J0ICdyeGpzL2FkZC9vcGVyYXRvci9tZXJnZUFsbCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3JldHJ5V2hlbic7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3NoYXJlJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivc3RhcnRXaXRoJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvdGFrZSc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3Rha2VVbnRpbCc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3Rocm90dGxlVGltZSc7XG5pbXBvcnQgJ3J4anMvYWRkL29wZXJhdG9yL3dpdGhMYXRlc3RGcm9tJztcbmltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvemlwJztcblxuaW1wb3J0IGNvbXBvbmVudENvcmUgZnJvbSAneS1jb21wb25lbnQvc3JjL2NvbXBvbmVudC1jb3JlJztcblxuaW1wb3J0IHtcbiAgc2hvdWxkTG9hZEFuY2hvcixcbiAgZ2V0U2Nyb2xsVG9wLFxuICBnZXRTY3JvbGxIZWlnaHQsXG4gIGV4cEludGVydmFsLFxuICBmcmFnbWVudEZyb21TdHJpbmcsXG59IGZyb20gJy4uL2NvbW1vbic7XG5cbmltcG9ydCB7IFB1c2gsIEhpbnQsIFBvcCB9IGZyb20gJy4va2luZCc7XG5cbi8vIH4gbWl4aW4gcHVzaFN0YXRlQ29yZSB3aXRoIGNvbXBvbmVudENvcmUgeyAuLi5cbmV4cG9ydCBkZWZhdWx0IEMgPT4gY2xhc3MgZXh0ZW5kcyBjb21wb25lbnRDb3JlKEMpIHtcblxuICAvLyBAb3ZlcnJpZGVcbiAgZ2V0Q29tcG9uZW50TmFtZSgpIHtcbiAgICByZXR1cm4gJ3ktcHVzaC1zdGF0ZSc7XG4gIH1cblxuICAvLyBAb3ZlcnJpZGVcbiAgZGVmYXVsdHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlcGxhY2VJZHM6IFtdLFxuICAgICAgbGlua1NlbGVjdG9yOiAnYVtocmVmXScsXG4gICAgICBzY3JvbGxSZXN0b3JhdGlvbjogZmFsc2UsXG4gICAgICBocmVmUmVnZXg6IG51bGwsXG4gICAgICBibGFja2xpc3Q6ICcubm8tcHVzaC1zdGF0ZScsXG4gICAgICBkdXJhdGlvbjogMCxcbiAgICAgIG5vUG9wRHVyYXRpb246IHRydWUsXG4gICAgfTtcbiAgfVxuXG4gIC8vIEBvdmVycmlkZVxuICBzaWRlRWZmZWN0cygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvLyBAb3ZlcnJpZGVcbiAgc3RhcnRIaXN0b3J5KCkge1xuICAgIHRoaXMuY2hlY2tQcmVDb25kaXRpb24oKTtcbiAgICB0aGlzLnNldHVwU2Nyb2xsUmVzdG9yYXRpb24oKTtcbiAgICB0aGlzLmNhY2hlVGl0bGVFbGVtZW50KCk7XG4gICAgdGhpcy5zZXR1cE9ic2VydmFibGVzKCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjaGVja1ByZUNvbmRpdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZXBsYWNlSWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmVsLmlkO1xuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gcmVwbGFjZSBpZHMgcHJvdmlkZWQuIFdpbGwgcmVwbGFjZSBlbnRpcmUgY29udGVudCBvZiAjJHtpZH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKCdObyByZXBsYWNlIGlkcyBwcm92aWRlZCBub3IgZG9lcyB0aGlzIGNvbXBvbmVudCBoYXZlIGFuZCBpZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNldHVwU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gICAgaWYgKCdzY3JvbGxSZXN0b3JhdGlvbicgaW4gaGlzdG9yeSkge1xuICAgICAgaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IHRoaXMuc2Nyb2xsUmVzdG9yYXRpb24gPyAnbWFudWFsJyA6ICdhdXRvJztcbiAgICB9XG5cbiAgICB0aGlzLnJlc2V0U2Nyb2xsUG9zdGlvbigpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCAoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZUhpc3RvcnlTdGF0ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgY2FjaGVUaXRsZUVsZW1lbnQoKSB7XG4gICAgdGhpcy50aXRsZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCd0aXRsZScpIHx8IHt9O1xuICB9XG5cbiAgYmluZFB1c2hFdmVudHMobGluayQpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tRXZlbnRzKGxpbmskLCAnY2xpY2snKVxuICAgICAgLm1hcChldmVudCA9PiBuZXcgUHVzaChldmVudCkpXG4gICAgICAuZmlsdGVyKGtpbmQgPT4gdGhpcy5pc1BhZ2VDaGFuZ2VFdmVudChraW5kKSlcbiAgICAgIC5kbygoeyBldmVudCB9KSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlSGlzdG9yeVN0YXRlKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcbiAgfVxuXG4gIGJpbmRIaW50RXZlbnRzKGxpbmskKSB7XG4gICAgcmV0dXJuIE9ic2VydmFibGUubWVyZ2UoXG4gICAgICAgIHRoaXMuZnJvbUV2ZW50cyhsaW5rJCwgJ21vdXNlZW50ZXInKSxcbiAgICAgICAgdGhpcy5mcm9tRXZlbnRzKGxpbmskLCAndG91Y2hzdGFydCcpLFxuICAgICAgICB0aGlzLmZyb21FdmVudHMobGluayQsICdmb2N1cycpLFxuICAgICAgKVxuICAgICAgLm1hcChldmVudCA9PiBuZXcgSGludChldmVudCkpXG4gICAgICAuZmlsdGVyKGtpbmQgPT4gdGhpcy5pc1BhZ2VDaGFuZ2VBbmNob3Ioa2luZCkpO1xuICB9XG5cbiAgYmluZFBvcHN0YXRlRXZlbnQoKSB7XG4gICAgcmV0dXJuIE9ic2VydmFibGUuZnJvbUV2ZW50KHdpbmRvdywgJ3BvcHN0YXRlJylcbiAgICAgIC5tYXAoZXZlbnQgPT4gbmV3IFBvcChldmVudCkpXG4gICAgICAuZmlsdGVyKCgpID0+IHdpbmRvdy5oaXN0b3J5LnN0YXRlICE9IG51bGwpO1xuICB9XG5cbiAgbGlua09ic2VydmFibGUoKSB7XG4gICAgcmV0dXJuIE9ic2VydmFibGUub2YodGhpcy5lbC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMubGlua1NlbGVjdG9yKSk7XG4gIH1cblxuICBmcm9tRXZlbnRzKGxpbmskLCBldmVudCkge1xuICAgIHJldHVybiBsaW5rJC5tYXAobGluayA9PiBPYnNlcnZhYmxlLmZyb21FdmVudChsaW5rLCBldmVudCkpLm1lcmdlQWxsKCk7XG4gIH1cblxuICBmZXRjaFBhZ2Uoa2luZCkge1xuICAgIHJldHVybiBPYnNlcnZhYmxlXG4gICAgICAuYWpheCh0aGlzLmhyZWZUb0FqYXgoa2luZCkpXG4gICAgICAubWFwKCh7IHJlc3BvbnNlIH0pID0+IE9iamVjdC5hc3NpZ24oa2luZCwgeyByZXNwb25zZSB9KSlcbiAgICAgIC5jYXRjaChlcnJvciA9PiB0aGlzLnJlY292ZXJJZlJlc3BvbnNlKGtpbmQsIGVycm9yKSlcbiAgICAgIC5yZXRyeVdoZW4oKCkgPT4gT2JzZXJ2YWJsZS5tZXJnZShcbiAgICAgICAgICBPYnNlcnZhYmxlLmZyb21FdmVudCh3aW5kb3csICdvbmxpbmUnKSxcbiAgICAgICAgICBleHBJbnRlcnZhbCgxMDAwLCAyKSlcbiAgICAgICAgLmRvKHRoaXMub25SZXRyeS5iaW5kKHRoaXMsIGtpbmQpKSk7XG4gIH1cblxuICBocmVmVG9BamF4KHsgaHJlZiB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmw6IGhyZWYsXG4gICAgICByZXNwb25zZVR5cGU6ICd0ZXh0JyxcbiAgICB9O1xuICB9XG5cbiAgcmVjb3ZlcklmUmVzcG9uc2Uoa2luZCwgZXJyb3IpIHtcbiAgICBjb25zdCB7IHN0YXR1cywgeGhyIH0gPSBlcnJvcjtcblxuICAgIGlmICh4aHIgJiYgc3RhdHVzICYmIHN0YXR1cyA+IDQwMCkge1xuICAgICAgLy8gUmVjb3ZlciB3aXRoIGVycm9yIHBhZ2UgcmV0dXJuZWQgZnJvbSBzZXJ2ZXIuXG4gICAgICAvLyBOT1RFOiBUaGlzIGFzc3VtZXMgZXJyb3IgcGFnZSBjb250YWlucyB0aGUgc2FtZSBpZHMgYXMgdGhlIG90aGVyIHBhZ2VzLi4uXG4gICAgICByZXR1cm4gT2JzZXJ2YWJsZS5vZihPYmplY3QuYXNzaWduKGtpbmQsIHsgcmVzcG9uc2U6IHhoci5yZXNwb25zZSB9KSk7XG4gICAgfVxuXG4gICAgLy8gZWxzZVxuICAgIHRoaXMub25FcnJvcihPYmplY3QuYXNzaWduKGtpbmQsIGVycm9yKSk7XG4gICAgcmV0dXJuIE9ic2VydmFibGUudGhyb3coZXJyb3IpO1xuICB9XG5cbiAgc2V0dXBPYnNlcnZhYmxlcygpIHtcbiAgICAvLyBTZWUgYHJlbmV3RXZlbnRMaXN0ZW5lcnNgXG4gICAgLy8gVE9ETzogUG9zc2libGUgd2l0aG91dCBzdWJqZWN0cz9cbiAgICB0aGlzLnB1c2gkJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgdGhpcy5oaW50JCQgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgY29uc3QgcHVzaCQgPSB0aGlzLnB1c2gkJC5zd2l0Y2goKVxuICAgICAgLy8gVE9ETzogVGhpcyBwcmV2ZW50cyBhIHdob2xlIGNsYXNzIG9mIGNvbmN1cnJlbmN5IGJ1Z3MsXG4gICAgICAvLyBUaGlzIGlzIG5vdCBhbiBpc3N1ZSBmb3IgZmFzdCBhbmltYXRpb25zIChhbmQgcHJldmVudHMgYWNjaWRlbnRpYWwgZG91YmxlIHRhcHBpbmcpXG4gICAgICAvLyBJZGVhbGx5IHRoZSBVSSBpcyBmdWxseSByZXBzb25zaXZlIGF0IGFsbCB0aW1lcyB0aG91Z2guLlxuICAgICAgLy8gTm90ZSB0aGF0IHNwYW1taW5nIHRoZSBiYWNrL2ZvcndhcmQgYnV0dG9uIGlzIHN0aWxsIHBvc3NpYmxlIChvbmx5IGFmZmVjdHMgYHB1c2gkYClcbiAgICAgIC50aHJvdHRsZVRpbWUodGhpcy5kdXJhdGlvbiArIDEwMCk7XG5cbiAgICBjb25zdCBwb3AkID0gdGhpcy5iaW5kUG9wc3RhdGVFdmVudCgpO1xuXG4gICAgLy8gRGVmaW5pdGl2ZSBwYWdlIGNoYW5nZSAoaS5lLiBlaXRoZXIgcHVzaCBvciBwb3AgZXZlbnQpXG4gICAgdGhpcy5wYWdlJCA9IE9ic2VydmFibGUubWVyZ2UocHVzaCQsIHBvcCQpLnNoYXJlKCk7XG5cbiAgICAvLyBXZSBkb24ndCB3YW50IHRvIHByZWZldGNoIChpLmUuIHVzZSBiYW5kd2lkdGgpIGZvciBhIF9wcm9iYWJpbGlzdGljXyBwYWdlIGxvYWQsXG4gICAgLy8gd2hpbGUgYSBfZGVmaW5pdGl2ZV8gcGFnZSBsb2FkIGlzIGdvaW5nIG9uID0+IGBwYXVzZXIkYCBzdHJlYW0uXG4gICAgLy8gTmVlZHMgdG8gYmUgZGVmZXJyZWQgYi9jIG9mIFwiY3ljbGljYWxcIiBkZXBlbmRlbmN5LlxuICAgIGNvbnN0IHBhdXNlciQgPSBPYnNlcnZhYmxlLmRlZmVyKCgpID0+XG4gICAgICBPYnNlcnZhYmxlLm1lcmdlKFxuICAgICAgICAvLyBBIHBhZ2UgY2hhbmdlIGV2ZW50IG1lYW5zIHdlIHdhbnQgdG8gcGF1c2UgcHJlZmV0Y2hpbmdcbiAgICAgICAgdGhpcy5wYWdlJC5tYXAoKCkgPT4gdHJ1ZSksXG4gICAgICAgIC8vIEEgcmVuZGVyIGNvbXBsZXRlIGV2ZW50IG1lYW5zIHdlIHdhbnQgdG8gcmVzdW1lIHByZWZldGNoaW5nXG4gICAgICAgIHRoaXMucmVuZGVyJC5tYXAoKCkgPT4gZmFsc2UpLFxuICAgICAgKVxuICAgICAgICAvLyBTdGFydCB3aXRoIHByZWZldGNoaW5nXG4gICAgICAgIC5zdGFydFdpdGgoZmFsc2UpLFxuICAgICk7XG5cbiAgICAvLyBUaGUgc3RyZWFtIG9mIGhpbnQgKHByZWZldGNoKSBldmVudHMsIHBvc3NpYmx5IHBhdXNlZC5cbiAgICAvLyBEcmVhbSBzeW50YXggKG5vdCBzdXBwb3J0ZWQsIHlldCk6IGB0aGlzLmhpbnQkJC5zd2l0Y2goKS5wYXVzZWFibGUocGF1c2VyJClgXG4gICAgdGhpcy5oaW50JCA9IHRoaXMuaGludCQkLnN3aXRjaCgpXG4gICAgICAud2l0aExhdGVzdEZyb20ocGF1c2VyJClcbiAgICAgIC5maWx0ZXIoKFssIHBhdXNlZF0pID0+IHBhdXNlZCA9PT0gZmFsc2UpXG4gICAgICAubWFwKChbeF0pID0+IHgpO1xuXG4gICAgLy8gVGhlIHN0cmVhbSBvZiAocHJlLSlmZXRjaCBldmVudHMuXG4gICAgLy8gSW5jbHVkZXMgZGVmaW5pdGl2ZSBwYWdlIGNoYW5nZSBldmVudHMgZG8gZGVhbCB3aXRoIHVuZXhwZWN0ZWQgcGFnZSBjaGFuZ2VzLlxuICAgIHRoaXMucHJlZmV0Y2gkID0gT2JzZXJ2YWJsZS5tZXJnZSh0aGlzLmhpbnQkLCB0aGlzLnBhZ2UkKVxuICAgICAgLmRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKCdocmVmJykgLy8gRG9uJ3QgYWJvcnQgYSByZXF1ZXN0IGlmIHRoZSB1c2VyIFwiamlnZ2xlc1wiIG92ZXIgYSBsaW5rXG4gICAgICAuc3dpdGNoTWFwKGtpbmQgPT4gdGhpcy5mZXRjaFBhZ2Uoa2luZCkpXG4gICAgICAuY2F0Y2goKGVyciwgY2F1Z2h0KSA9PiBjYXVnaHQpXG4gICAgICAuc3RhcnRXaXRoKHt9KSAvLyBTdGFydCB3aXRoIHNvbWUgdmFsdWUgc28gYHdpdGhMYXRlc3RGcm9tYCBiZWxvdyBkb2Vzbid0IFwiYmxvY2tcIlxuICAgICAgLnNoYXJlKCk7XG5cbiAgICB0aGlzLnJlbmRlciQgPSB0aGlzLnBhZ2UkXG4gICAgICAuZG8odGhpcy5vblN0YXJ0LmJpbmQodGhpcykpXG4gICAgICAud2l0aExhdGVzdEZyb20odGhpcy5wcmVmZXRjaCQpXG4gICAgICAuc3dpdGNoTWFwKHRoaXMuZ2V0UmVzcG9uc2UuYmluZCh0aGlzKSlcbiAgICAgIC5tYXAodGhpcy5yZXNwb25zZVRvQ29udGVudC5iaW5kKHRoaXMpKVxuICAgICAgLmRvKHRoaXMub25SZWFkeS5iaW5kKHRoaXMpKVxuICAgICAgLmRvKHRoaXMudXBkYXRlRE9NLmJpbmQodGhpcykpXG4gICAgICAuZG8odGhpcy5yZXNldFNjcm9sbFBvc3Rpb24uYmluZCh0aGlzKSlcbiAgICAgIC5kbyh0aGlzLm9uQWZ0ZXIuYmluZCh0aGlzKSlcbiAgICAgIC5jYXRjaCgoZXJyb3IsIGNhdWdodCkgPT4ge1xuICAgICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gY2F1Z2h0O1xuICAgICAgfSlcbiAgICAgIC8vIGBzaGFyZWBpbmcgdGhlIHN0cmVhbSBiZXR3ZWVuIHRoZSBzdWJzY3JpcHRpb24gYmVsb3cgYW5kIGBwYXVzZXIkYC5cbiAgICAgIC5zaGFyZSgpO1xuXG4gICAgdGhpcy5yZW5kZXIkXG4gICAgICAvLyBSZW5ld2luZyBldmVudCBsaXN0ZW5lcnMgYWZ0ZXIgRE9NIHVwZGF0ZS9sYXlvdXQvcGFpbnRpbmcgaXMgY29tcGxldGVcbiAgICAgIC8vIEhBQ0s6IGRvbid0IHVzZSB0aW1lLCB1c2Ugb3V0c2lkZSBvYnNlcnZhYmxlIGluc3RlYWQ/XG4gICAgICAuZGVib3VuY2VUaW1lKHRoaXMuZHVyYXRpb24pXG4gICAgICAuZG8odGhpcy5yZW5ld0V2ZW50TGlzdGVuZXJzLmJpbmQodGhpcykpXG4gICAgICAuc3Vic2NyaWJlKCk7XG5cbiAgICAvLyBmaXJlIGBwcm9ncmVzc2AgZXZlbnQgd2hlbiBmZXRjaGluZyB0YWtlcyBsb25nZXIgdGhhbiBgdGhpcy5kdXJhdGlvbmAuXG4gICAgdGhpcy5wYWdlJFxuICAgICAgLy8gSEFDSzogYWRkIHNvbWUgdGltZSwganRic1xuICAgICAgLnN3aXRjaE1hcCgoKSA9PiBPYnNlcnZhYmxlLnRpbWVyKHRoaXMuZHVyYXRpb24gKyAyMDApLnRha2VVbnRpbCh0aGlzLnJlbmRlciQpKVxuICAgICAgLnN1YnNjcmliZSh0aGlzLm9uUHJvZ3Jlc3MuYmluZCh0aGlzKSk7XG5cbiAgICAvLyBTdGFydCBwdWxsaW5nIHZhbHVlc1xuICAgIHRoaXMucmVuZGVyJC5zdWJzY3JpYmUoKTtcblxuICAgIC8vIFB1c2ggc3RyZWFtcyBpbnRvIGBwdXNoJCRgIGFuZCBgaGludCQkYFxuICAgIHRoaXMucmVuZXdFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgZ2V0UmVzcG9uc2UoW2tpbmQsIHByZWZldGNoXSkge1xuICAgIGxldCByZXM7XG5cbiAgICAvLyBQcmVmZXRjaCBhbHJlYWR5IGNvbXBsZXRlLCB1c2UgcmVzdWx0XG4gICAgaWYgKGtpbmQuaHJlZiA9PT0gcHJlZmV0Y2guaHJlZikge1xuICAgICAgcmVzID0gT2JzZXJ2YWJsZS5vZihPYmplY3QuYXNzaWduKGtpbmQsIHsgcmVzcG9uc2U6IHByZWZldGNoLnJlc3BvbnNlIH0pKTtcblxuICAgICAgaWYgKGtpbmQgaW5zdGFuY2VvZiBQdXNoIHx8ICF0aGlzLm5vUG9wRHVyYXRpb24pIHtcbiAgICAgICAgLy8gSEFDSzogYWRkIHNvbWUgZXh0cmEgdGltZSB0byBwcmV2ZW50ICdmbGlja2VyaW5nJ1xuICAgICAgICAvLyBpZGVhbGx5LCB3ZSdkIGxpa2UgdG8gdGFrZSBhbiBhbmltYXRpb24gb2JzZXJ2YWJsZSBhcyBpbnB1dCBpbnN0ZWFkXG4gICAgICAgIHJlcyA9IHJlcy5kZWxheSh0aGlzLmR1cmF0aW9uICsgMTAwKTtcbiAgICAgIH1cbiAgICAvLyBQcmVmZXRjaCBpbiBwcm9ncmVzcywgdXNlIG5leHQgcmVzdWx0ICh0aGlzIGlzIHdoeSBgcHJlZmV0Y2gkYCBoYWQgdG8gYmUgYHNoYXJlYGQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHRoaXMucHJlZmV0Y2gkLnRha2UoMSlcbiAgICAgICAgLm1hcChmZXRjaCA9PiBPYmplY3QuYXNzaWduKGtpbmQsIHsgcmVzcG9uc2U6IGZldGNoLnJlc3BvbnNlIH0pKTtcblxuICAgICAgaWYgKGtpbmQgaW5zdGFuY2VvZiBQdXNoIHx8ICF0aGlzLm5vUG9wRHVyYXRpb24pIHtcbiAgICAgICAgLy8gSEFDSzogYWRkIHNvbWUgZXh0cmEgdGltZSB0byBwcmV2ZW50ICdmbGlja2VyaW5nJ1xuICAgICAgICAvLyBpZGVhbGx5LCB3ZSdkIGxpa2UgdG8gdGFrZSBhbiBhbmltYXRpb24gb2JzZXJ2YWJsZSBhcyBpbnB1dCBpbnN0ZWFkXG4gICAgICAgIHJlcyA9IHJlcy56aXAoT2JzZXJ2YWJsZS50aW1lcih0aGlzLmR1cmF0aW9uICsgMTAwKSwgeCA9PiB4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgb25TdGFydChzcG9uZ2UpIHtcbiAgICBjb25zdCB7IGhyZWYgfSA9IHNwb25nZTtcblxuICAgIGlmIChzcG9uZ2UgaW5zdGFuY2VvZiBQdXNoKSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoeyBpZDogdGhpcy5jb21wb25lbnROYW1lIH0sICcnLCBocmVmKTtcbiAgICB9XG5cbiAgICB0aGlzLmZpcmVFdmVudCgnc3RhcnQnLCB7IGRldGFpbDogc3BvbmdlIH0pO1xuICB9XG5cbiAgb25Qcm9ncmVzcyhzcG9uZ2UpIHtcbiAgICB0aGlzLmZpcmVFdmVudCgncHJvZ3Jlc3MnLCB7IGRldGFpbDogc3BvbmdlIH0pO1xuICB9XG5cbiAgcmVzcG9uc2VUb0NvbnRlbnQoc3BvbmdlKSB7XG4gICAgY29uc3QgeyByZXNwb25zZSB9ID0gc3BvbmdlO1xuXG4gICAgY29uc3QgZG9jdW1lbnRGcmFnbWVudCA9IGZyYWdtZW50RnJvbVN0cmluZyhyZXNwb25zZSk7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLmdldFRpdGxlRnJvbURvY3VtZW50RnJhZ21lbnQoZG9jdW1lbnRGcmFnbWVudCk7XG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudEZyb21Eb2N1bWVudEZyYWdtZW50KGRvY3VtZW50RnJhZ21lbnQpO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3BvbmdlLCB7IHRpdGxlLCBjb250ZW50IH0pO1xuICB9XG5cbiAgb25SZWFkeShzcG9uZ2UpIHtcbiAgICB0aGlzLmZpcmVFdmVudCgncmVhZHknLCB7IGRldGFpbDogc3BvbmdlIH0pO1xuICB9XG5cbiAgdXBkYXRlRE9NKHNwb25nZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGhyZWYsIHRpdGxlLCBjb250ZW50IH0gPSBzcG9uZ2U7XG5cbiAgICAgIGlmIChzcG9uZ2UgaW5zdGFuY2VvZiBQdXNoKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7IGlkOiB0aGlzLmNvbXBvbmVudE5hbWUgfSwgdGl0bGUsIGhyZWYpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRpdGxlRWxlbWVudC50ZXh0Q29udGVudCA9IHRpdGxlO1xuICAgICAgdGhpcy5yZXBsYWNlQ29udGVudChjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihzcG9uZ2UsIHsgZXJyb3IgfSk7XG4gICAgfVxuICB9XG5cbiAgb25BZnRlcihzcG9uZ2UpIHtcbiAgICB0aGlzLmZpcmVFdmVudCgnYWZ0ZXInLCB7IGRldGFpbDogc3BvbmdlIH0pO1xuICB9XG5cbiAgcmVuZXdFdmVudExpc3RlbmVycygpIHtcbiAgICBjb25zdCBsaW5rJCA9IHRoaXMubGlua09ic2VydmFibGUoKTtcbiAgICB0aGlzLnB1c2gkJC5uZXh0KHRoaXMuYmluZFB1c2hFdmVudHMobGluayQpKTtcbiAgICB0aGlzLmhpbnQkJC5uZXh0KHRoaXMuYmluZEhpbnRFdmVudHMobGluayQpKTtcbiAgfVxuXG4gIG9uRXJyb3IoZXJyKSB7XG4gICAgdGhpcy5lbC5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gICAgdGhpcy5maXJlRXZlbnQoJ2Vycm9yJywgeyBkZXRhaWw6IGVyciB9KTtcbiAgfVxuXG4gIG9uUmV0cnkoa2luZCkge1xuICAgIHRoaXMuZmlyZUV2ZW50KCdyZXRyeScsIHsgZGV0YWlsOiBraW5kIH0pO1xuICB9XG5cbiAgaXNQYWdlQ2hhbmdlRXZlbnQoa2luZCkge1xuICAgIGNvbnN0IHsgZXZlbnQgfSA9IGtpbmQ7XG4gICAgcmV0dXJuIChcbiAgICAgICFldmVudC5tZXRhS2V5ICYmXG4gICAgICAhZXZlbnQuY3RybEtleSAmJlxuICAgICAgdGhpcy5pc1BhZ2VDaGFuZ2VBbmNob3Ioa2luZClcbiAgICApO1xuICB9XG5cbiAgaXNQYWdlQ2hhbmdlQW5jaG9yKHsgZXZlbnQ6IHsgY3VycmVudFRhcmdldDogYW5jaG9yIH0gfSkge1xuICAgIHJldHVybiAoXG4gICAgICBhbmNob3IgIT0gbnVsbCAmJlxuICAgICAgc2hvdWxkTG9hZEFuY2hvcihhbmNob3IsIHRoaXMuYmxhY2tsaXN0LCB0aGlzLmhyZWZSZWdleClcbiAgICApO1xuICB9XG5cbiAgZ2V0VGl0bGVGcm9tRG9jdW1lbnRGcmFnbWVudChkb2N1bWVudEZyYWdtZW50KSB7XG4gICAgcmV0dXJuIChkb2N1bWVudEZyYWdtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RpdGxlJykgfHwge30pLnRleHRDb250ZW50O1xuICB9XG5cbiAgZ2V0Q29udGVudEZyb21Eb2N1bWVudEZyYWdtZW50KGRvY3VtZW50RnJhZ21lbnQpIHtcbiAgICBpZiAodGhpcy5yZXBsYWNlSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VJZHMubWFwKGlkID0+IGRvY3VtZW50RnJhZ21lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9jdW1lbnRGcmFnbWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmVsLmlkKTtcbiAgfVxuXG4gIHJlcGxhY2VDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5yZXBsYWNlSWRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucmVwbGFjZUNvbnRlbnRCeUlkcyhjb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXBsYWNlQ29udGVudFdob2xlc2FsZShjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICByZXBsYWNlQ29udGVudEJ5SWRzKGVsZW1lbnRzKSB7XG4gICAgY29uc3Qgb2xkRWxlbWVudHMgPSB0aGlzLnJlcGxhY2VJZHNcbiAgICAgIC5tYXAoaWQgPT4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcblxuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwob2xkRWxlbWVudHMsIChvbGRFbGVtZW50KSA9PiB7XG4gICAgICBvbGRFbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGVsZW1lbnRzLnNoaWZ0KCksIG9sZEVsZW1lbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVwbGFjZUNvbnRlbnRXaG9sZXNhbGUoY29udGVudCkge1xuICAgIHRoaXMuZWwuaW5uZXJIVE1MID0gY29udGVudC5pbm5lckhUTUw7XG4gIH1cblxuICBzYXZlU2Nyb2xsUG9zaXRpb24oc3RhdGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdGF0ZSwge1xuICAgICAgc2Nyb2xsVG9wOiBnZXRTY3JvbGxUb3AoKSxcbiAgICAgIHNjcm9sbEhlaWdodDogZ2V0U2Nyb2xsSGVpZ2h0KCksXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVIaXN0b3J5U3RhdGUoKSB7XG4gICAgbGV0IHN0YXRlID0gaGlzdG9yeS5zdGF0ZSB8fCB7IGlkOiB0aGlzLmNvbXBvbmVudE5hbWUgfTtcbiAgICBzdGF0ZSA9IHRoaXMuc2Nyb2xsUmVzdG9yYXRpb24gPyB0aGlzLnNhdmVTY3JvbGxQb3NpdGlvbihzdGF0ZSkgOiBzdGF0ZTtcbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgZG9jdW1lbnQudGl0bGUsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgfVxuXG4gIHJlc2V0U2Nyb2xsUG9zdGlvbihzcG9uZ2UpIHtcbiAgICBpZiAodGhpcy5zY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgaWYgKHNwb25nZSBpbnN0YW5jZW9mIFBvcCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGhpc3Rvcnkuc3RhdGUgfHwge307XG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubWluSGVpZ2h0ID0gYCR7c3RhdGUuc2Nyb2xsSGVpZ2h0IHx8IDB9cHhgO1xuICAgICAgICBpZiAoc3RhdGUuc2Nyb2xsVG9wICE9IG51bGwpIHdpbmRvdy5zY3JvbGwod2luZG93LnBhZ2VYT2Zmc2V0LCBzdGF0ZS5zY3JvbGxUb3ApO1xuICAgICAgfVxuXG4gICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm1pbkhlaWdodCA9ICcnO1xuICAgIH1cbiAgfVxufTtcbiIsImV4cG9ydCBjbGFzcyBLaW5kIHtcbiAgY29uc3RydWN0b3IoZXZlbnQpIHtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFB1c2ggZXh0ZW5kcyBLaW5kIHtcbiAgY29uc3RydWN0b3IoZXZlbnQpIHtcbiAgICBzdXBlcihldmVudCk7XG4gICAgdGhpcy5ocmVmID0gZXZlbnQuY3VycmVudFRhcmdldC5ocmVmO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7IHJldHVybiAncHVzaCc7IH1cbn1cblxuZXhwb3J0IGNsYXNzIEhpbnQgZXh0ZW5kcyBLaW5kIHtcbiAgY29uc3RydWN0b3IoZXZlbnQpIHtcbiAgICBzdXBlcihldmVudCk7XG4gICAgdGhpcy5ocmVmID0gZXZlbnQuY3VycmVudFRhcmdldC5ocmVmO1xuICB9XG5cbiAgZ2V0IHR5cGUoKSB7IHJldHVybiAnaGludCc7IH1cbn1cblxuZXhwb3J0IGNsYXNzIFBvcCBleHRlbmRzIEtpbmQge1xuICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgIHN1cGVyKGV2ZW50KTtcbiAgICB0aGlzLmhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgfVxuXG4gIGdldCB0eXBlKCkgeyByZXR1cm4gJ3BvcCc7IH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmxvcmlhbiBLbGFtcGZlclxuICogTGljZW5zZWQgdW5kZXIgTUlUXG4gKi9cbmltcG9ydCBwdXNoU3RhdGVDb3JlIGZyb20gJy4uL2NvcmUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQdXNoU3RhdGUgZXh0ZW5kcyBwdXNoU3RhdGVDb3JlKCkge1xuICBjb25zdHJ1Y3RvcihlbCwgcHJvcHMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc2V0dXBDb21wb25lbnQoZWwsIHByb3BzKTtcbiAgfVxuXG4gIC8vIEBvdmVycmlkZVxuICBzZXR1cERPTShlbCkge1xuICAgIGlmICghZWwpIHRocm93IEVycm9yKCdObyBlbGVtZW50IHByb3ZpZGVkJyk7XG4gICAgcmV0dXJuIGVsO1xuICB9XG59XG4iXX0=
